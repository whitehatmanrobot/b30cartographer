e next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_asbcWorkInfo[tileSize].pShuntBuffer,
                                        g_asbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_asbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_MEDIUM_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_asbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_asbcWorkInfo[tileSize].mruIndex = (g_asbcWorkInfo[tileSize].mruIndex + 1) %
                               g_asbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
//
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (g_sbcThrashers[i].hsurf == pSurfObj->hsurf)
        {
            bitmapInList = TRUE;

            if (g_sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             g_sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - g_sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                g_sbcThrashers[i].tickCount = nextTickCount;
                g_sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i=0 ; i<SBC_NUM_THRASHERS ; i++)
        {
            if (evictTickCount > g_sbcThrashers[i].tickCount)
            {
                evictTickCount = g_sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     g_sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        g_sbcThrashers[updateIndex] = g_sbcThrashers[0];

        g_sbcThrashers[0].hsurf     = pSurfObj->hsurf;
        g_sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        g_sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
//
DWORD SBCDDGetTickCount(void)
{
    DWORD       tickCount;
    LONGLONG    perfTickCount;

    DebugEntry(SBCDDGetTickCount);

    //
    // Get the number of system ticks since the system was started.
    //
    EngQueryPerformanceCounter(&perfTickCount);

    //
    // Now convert this into a number of centi-seconds.  g_sbcPerfFrequency
    // contains the number of system ticks per second.
    //
    tickCount = (DWORD)((100 * perfTickCount) / g_sbcPerfFrequency);

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    g_sbcSendingBPP     = pCapabilities->sendingBpp;
    memcpy(&g_asbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_asbcCacheInfo));

    DebugExitVOID(SBCSetNewCapabilities);
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\acpi.h ===
//
// ACPI.H
// This file is included by ObMan applets (namely, the old Whiteboard)
//
// Copyright (c) Microsoft, 1998-
//

#ifndef _H_ACPI
#define _H_ACPI


#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

//
// Header that sets up OS flags. Include before everything else
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>


//
// Application Loader Programming Interface
//
#include <al.h>

//
// T.120 Data Conferencing Stuff
//
#include <ast120.h>

#ifdef __cplusplus
}
#endif // __cplusplus

//
// Whiteboard Programming Interface
// C++
//
#include <wb.hpp>


#endif // _H_ACPI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\trc.c ===
#include "precomp.h"


//
// TRC.C
// Debug Tracing
// This emulates the code found in NMUTIL for ring0
//
// Copyright(c) Microsoft 1997-
//


#if defined(DEBUG) || defined(INIT_TRACE)


char        s_ASDbgArea[] = "NetMtg ";

#ifdef _M_ALPHA

va_list     g_trcDummyVa                =   {NULL, 0};
#define DUMMY_VA_LIST       g_trcDummyVa

#else

#define DUMMY_VA_LIST       NULL

#endif // _M_ALPHA



//
// Debug only
//

#ifdef DEBUG

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
// DbgZPrintFnExitPVOID()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s\n", szFn);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN %d\n", szFn, dwResult);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}

void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        sprintf(g_szDbgBuf, "%s, RETURN 0x%p\n", szFn, ptr);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, DUMMY_VA_LIST);
    }
}


//
// DbgZPrintTrace()
//
// This prints out a trace string
//
void DbgZPrintTrace(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_TRACE)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "TRACE: %s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintWarning()
//
// This prints out a warning string
//
void DbgZPrintWarning(PSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "WARNING: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);
}


#endif // DEBUG




//
// DbgZPrintInit()
//
// This is special case tracing only for the init code, which can be
// built even in retail
//

void DbgZPrintInit(LPSTR szFormat, ...)
{
    if (g_trcConfig & ZONE_INIT)
    {
        va_list varArgs;

        va_start(varArgs, szFormat);

        sprintf(g_szDbgBuf, "%s\n", szFormat);
        EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

        va_end(varArgs);
    }
}



//
// DbgZPrintError()
//
// This prints out an error string then breaks into the kernel debugger.
//
void DbgZPrintError(LPSTR szFormat, ...)
{
    va_list varArgs;

    va_start(varArgs, szFormat);

    sprintf(g_szDbgBuf, "ERROR: %s\n", szFormat);
    EngDebugPrint(s_ASDbgArea, g_szDbgBuf, varArgs);

    va_end(varArgs);

    EngDebugBreak();
}




#endif // DEBUG or INIT_TRACE

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\dd\ssi.c ===
#include "precomp.h"


//
// SSI.C
// Save Screenbits Interceptor, display driver side
//
// Copyright(c) Microsoft 1997-
//


//
// SSI_DDProcessRequest - see ssi.h
//
BOOL SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            if (cbRequest != sizeof(SSI_RESET_LEVEL))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_RESET_LEVEL",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            if (cbRequest != sizeof(SSI_NEW_CAPABILITIES))
            {
                ERROR_OUT(("SSI_DDProcessRequest:  Invalid size %d for SSI_ESC_NEW_CAPABILITIES",
                    cbRequest));
                rc = FALSE;
                DC_QUIT;
            }

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}



//
// SSI_SaveScreenBitmap()
//
// see ssi.h for description.
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand)
{
    BOOL rc;

    DebugEntry(SSI_SaveScreenBitmap);

    //
    // Decide whether we can transmit this particular SaveBitmap command as
    // an order.
    //
    switch (wCommand)
    {
        case ONBOARD_SAVE:
        {
            //
            // Save the bits.
            //
            rc = SSISaveBits(lpRect);
        }
        break;

        case ONBOARD_RESTORE:
        {
            //
            // Restore the bits.
            //
            rc = SSIRestoreBits(lpRect);
        }
        break;

        case ONBOARD_DISCARD:
        {
            //
            // Discard the saved bits.
            //
            rc = SSIDiscardBits(lpRect);
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            rc = FALSE;
        }
    }

    if (g_ssiLocalSSBState.saveLevel == 0)
    {
        ASSERT(g_ssiRemoteSSBState.pelsSaved == 0);
    }

    DebugExitBOOL(SSI_SaveScreenBitmap, rc);
    return(rc);
}



//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits.
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the number of remote pels saved.
    //
    g_ssiRemoteSSBState.pelsSaved = 0;


    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT      lpRect,
    UINT        wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        WARNING_OUT(("SSISendSaveBitmapOrder failing; save bits orders not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(("SSISendSaveBitmapOrder:  ONBOARD_SAVE is failing; not enough space for %08d pels",
                    cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =  g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;


            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                                  CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       (TSHR_INT16)pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       (TSHR_INT16)pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       (TSHR_INT16)pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       (TSHR_INT16)pSaveBitmapOrder->nBottomRect;
            break;


        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            DC_QUIT;
    }

    TRACE_OUT(( "SaveBitmap op %d pos %ld rect %d %d %d %d",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // We deliberately do not call OA_DDClipAndAddOrder() because the
    // SaveBitmap order is never clipped.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we can't save it, no
// big deal--we'll fail the restore and that info will go as screen data.
//
// NOTE THAT THIS ROUTINE IS IN OPPOSITE FROM WIN95.  In Win95, we always
// return FALSE from save so that USER always uses bitmaps for save bits and
// we can track them.  In NT we always return TRUE from save because we
// can't track USER bitmaps.
//
// ALWAYS RETURN TRUE FROM THIS FUNCTION
//
// If FALSE is returned on a Display Driver SaveBits operation then Windows
// (USER) simulates the SaveBits call using BitBlts and DOES NOT make a
// corresponding RestoreBits call.  This makes it impossible for us to
// correctly track the drawing operations (the restore operation is a
// bitblt on a task that may not have been tracked) - and we can end up
// with unrestored areas on the remote.
//
// Therefore this routine should always return TRUE (apart from when
// something very very unexpected happens).  In the cases where we haven't
// saved the data we simply note the fact by storing ST_FAILED_TO_SAVE in
// our local SSB state structure.  Because we return TRUE, we get a
// RestoreBits call and, seeing that the Save failed (by looking in the
// local SSB state structure), we _then_ return FALSE to indicate that the
// Restore failed which causes Windows to invalidate and repaint the
// affected area.
//
//
BOOL SSISaveBits(LPRECT lpRect)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(( "saveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data, so if we sent a SAVEBITS order at
    // this point, we would not save the intersecting Screen Data.
    //
    // Otherwise mark the bits as saved (we don't have to do anything since
    // we are a chained display driver).
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_DISPLAY_DRIVER;
    }

    //
    // Store the rectangle saved
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = NULL;
    CURRENT_LOCAL_SSB_STATE.rect     = *lpRect;

    //
    // If the bits were successfully saved then we can try to send the
    // SaveBits command as an order.
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;
    
    TRACE_OUT(("SSISaveBits:"));
    TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

DC_EXIT_POINT:
    DebugExitBOOL(SSISaveBits, TRUE);
    return(TRUE);
}



//
// FUNCTION: SSIFindSlotAndDiscardAbove
//
// DESCRIPTION:
//
// Finds the top slot in the SSB stack which matches lpRect and updates
// g_ssiLocalSSBState.saveLevel to index it.
//
// PARAMETERS:
//
// lpRect - the SSB rectangle
//
// RETURNS: TRUE if a match was found, FALSE otherwise
//
//
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    //
    // Find the bits we are trying to restore
    //
    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if ((g_ssiLocalSSBState.saveState[i].rect.left   == lpRect->left)  &&
            (g_ssiLocalSSBState.saveState[i].rect.right  == lpRect->right) &&
            (g_ssiLocalSSBState.saveState[i].rect.top    == lpRect->top)   &&
            (g_ssiLocalSSBState.saveState[i].rect.bottom == lpRect->bottom) )
        {
            //
            // Found the one we were looking for
            //
            TRACE_OUT(("Found SPB at slot %d", i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    TRACE_OUT(("SSIFindSlotAndDiscardAbove:"));
    TRACE_OUT(("      saveLevel   is      %d", iNewSaveLevel));
    TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}





//
// FUNCTION: SSIRestoreBits
//
// DESCRIPTION:
//
// Attempts to restore the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// If the bits were saved remotely then a RestoreBits order is sent to
// restore the remote bits.
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
// Note: if FALSE is returned on a RestoreBits operation then Windows will
// restore the screen by invalidating the area to be restored.
//
//
BOOL SSIRestoreBits(LPRECT lpRect)
{
    BOOL      rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(lpRect))
    {
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(lpRect, ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIRestoreBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}


//
// FUNCTION: SSIDiscardBits
//
// DESCRIPTION:
//
// Attempts to discard the specified screen rectangle bits (using the same
// scheme as we previously used to save the bits: either the Display Driver
// our SaveBitmap simulation).
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// RETURNS:
//
// TRUE or FALSE - this will be returned to Windows as the return code of
// the SaveScreenBitmap call.
//
//
BOOL SSIDiscardBits(LPRECT lpRect)
{
    BOOL rc = TRUE;

    DebugEntry(SSIDiscardBits);

    //
    // SS_FREE (discard) isn't called with a rectangle.  It is used to
    // discard the most recent save.
    //
    if (g_ssiLocalSSBState.saveLevel > 0)
    {
        --g_ssiLocalSSBState.saveLevel;

        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes
        // into.
        //

        //
        // If the bits were saved remotely then send a DISCARDBITS order.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            // 
            SSISendSaveBitmapOrder(lpRect, ONBOARD_DISCARD);
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }

        TRACE_OUT(("SSIDiscardBits:"));
        TRACE_OUT(("      saveLevel   is      %d", g_ssiLocalSSBState.saveLevel));
        TRACE_OUT(("      pelsSaved   is      %d", g_ssiRemoteSSBState.pelsSaved));
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}


//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth    = 0;
    UINT    rectHeight   = 0;
    UINT    xGranularity = 1;
    UINT    yGranularity = 1;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect != NULL);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = lpRect->right  - lpRect->left;
    rectHeight = lpRect->bottom - lpRect->top;

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc =
      ((DWORD)(rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
      ((DWORD)(rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}


//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\as.h ===
//
// App Sharing Header
//
// <DCS.H> is included BEFORE the other component headers, it has common
//      constants and typedefs.
// <AS.H> is included AFTER the other component headers, it has structure
//      definitions that depend on the structures in the component headers.
//

#ifndef _H_AS
#define _H_AS

class ASHost;
class ASPerson;
class ASView;
class ASShare;



//
// This is the data we keep for when we HOST application.  When not
// hosting, we don't have this data at all.  It's a fair amount of variables,
// hence it's worth allocating/freeing.  And when we support multiple
// simultaneous conferences, won't we be glad we don't have globals to
// remove?
//

class ASHost
{
public:
    STRUCTURE_STAMP

    //
    // Pointer back to share
    //
    ASShare *               m_pShare;

    //
    // Bounds rects
    //
    UINT                    m_baNumRects;
    RECT                    m_abaRects[BA_NUM_RECTS];

    //
    // Active Window Coordinator
    //
    HWND                    m_awcLastActiveWindow;
    UINT                    m_awcLastActiveMsg;

    //
    // Control
    //
    BOOL                    m_caRetrySendState;
    BOOL                    m_caAutoAcceptRequests:1;
    BOOL                    m_caTempRejectRequests:1;

    //
    // Cursor Manager
    //
    BOOL                    m_cmfUseColorCursorProtocol:1;
    BOOL                    m_cmfCursorHidden:1;
    BOOL                    m_cmfSyncPos:1;
    BOOL                    m_cmfCursorTransformApplied:1;
    POINT                   m_cmLastCursorPos;
    CURSORDESCRIPTION       m_cmLastCursorShape;
    UINT                    m_cmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_cmTxCacheHandle;

    //
    // Host Tracker
    //
    GUIEFFECTS              m_hetEffects;

    //
    // Order Accumulator
    //
    UINT                    m_oaFlow;

    //
    // OE2 OUTGOING encoding
    //
    PARTYORDERDATA          m_oe2Tx;

    //
    // PM OUTGOING cache, current colors
    //
    BOOL                    m_pmMustSendPalette:1;
    BOOL                    m_pmBuggedDriver:1;
    PALETTEENTRY            m_apmCurrentSystemPaletteEntries[PM_NUM_8BPP_PAL_ENTRIES];
    TSHR_RGBQUAD            m_apmTxPaletteColors[PM_NUM_8BPP_PAL_ENTRIES];
    HPALETTE                m_pmTxPalette;
    UINT                    m_pmNumTxCacheEntries;    // CAN GO AWAY IN 4.0
    PCHCACHE                m_pmTxCacheHandle;
    PCOLORTABLECACHE        m_pmNextTxCacheEntry;
    COLORTABLECACHE         m_apmTxCache[TSHR_PM_CACHE_ENTRIES];
    TSHR_RGBQUAD            m_apmDDGreyRGB[PM_GREY_COUNT];

    //
    // Send bitmap cache
    //
    SBC_ORDER_INFO          m_sbcOrderInfo;
    SBC_TILE_WORK_INFO      m_asbcWorkInfo[SBC_NUM_TILE_SIZES];
    BMC_DIB_CACHE           m_asbcBmpCaches[NUM_BMP_CACHES];
    SBC_SHM_CACHE_INFO      m_asbcCacheInfo[NUM_BMP_CACHES];
    LPSBC_FASTPATH          m_sbcFastPath;


    //
    // Screen data
    //
    RECT                    m_sdgPendingRect;
    BOOL                    m_sdgRectIsPending:1;
    UINT                    m_sdgcLossy;
    RECT                    m_asdgLossyRect[BA_NUM_RECTS];

    //
    // Save bits
    //
    DWORD                   m_ssiSaveBitmapSize;  // Can go away in 4.0

    //
    // Shared window list
    //
    BOOL                    m_swlfForceSend:1;
    BOOL                    m_swlfSyncing:1;
    BOOL                    m_swlfRegionalChanges:1;
    ATOM                    m_swlPropAtom;
    UINT                    m_swlCurrentDesktop;
    char                    m_aswlOurDesktopName[SWL_DESKTOPNAME_MAX];
    UINT                    m_swlCurIndex;
    SWLWINATTRIBUTES        m_aswlFullWinStructs[2*SWL_MAX_WINDOWS];
    SWLWINATTRIBUTES        m_aswlCompactWinStructs[2*SWL_MAX_WINDOWS];
    LPSTR                   m_aswlWinNames[2];
    UINT                    m_aswlWinNamesSize[2];
    UINT                    m_aswlNumFullWins[2];
    UINT                    m_aswlNumCompactWins[2];
    UINT                    m_aswlNRSize[2];
    LPTSHR_UINT16           m_aswlNRInfo[2];

    //
    // Updates
    //
    BOOL                    m_upBackPressure;
    BOOL                    m_upfUseSmallPackets:1;
    BOOL                    m_upfSyncTokenRequired:1;
    DWORD                   m_upLastSDTime;
    DWORD                   m_upLastOrdersTime;
    DWORD                   m_upLastTrialTime;
    DWORD                   m_upDeltaSD;
    DWORD                   m_upSDAccum;
    DWORD                   m_upDeltaOrders;
    DWORD                   m_upOrdersAccum;

    UINT                    m_usrSendingBPP;
    HDC                     m_usrWorkDC;

public:

    //
    // Local host starting
    //
    BOOL                    HET_HostStarting(ASShare *);

    BOOL                    CM_HostStarting(void);
    BOOL                    OE2_HostStarting(void);
    BOOL                    PM_HostStarting(void);
    BOOL                    SBC_HostStarting(void);
    BOOL                    SSI_HostStarting(void);
    BOOL                    SWL_HostStarting(void);
    BOOL                    VIEW_HostStarting(void);
    BOOL                    USR_HostStarting(void);

    //
    // Local host ended
    //
    void                    HET_HostEnded(void);

    void                    CA_HostEnded(void);
    void                    CM_HostEnded(void);
    void                    OE2_HostEnded(void);
    void                    PM_HostEnded(void);
    void                    SBC_HostEnded(void);
    void                    SWL_HostEnded(void);
    void                    USR_HostEnded(void);

    //
    // Syncing, when already hosting and somebody else joins
    //
    void                    HET_SyncCommon(void);

    void                    HET_SyncAlreadyHosting(void);
    void                    CA_SyncAlreadyHosting(void);

    void                    AWC_SyncOutgoing(void);
    void                    BA_SyncOutgoing(void);
    void                    CM_SyncOutgoing(void);
    void                    OA_SyncOutgoing(void);
    void                    OE2_SyncOutgoing(void);
    void                    PM_SyncOutgoing(void);
    void                    SBC_SyncOutgoing(void);
    void                    SSI_SyncOutgoing(void);
    void                    SWL_SyncOutgoing(void);

    //
    // Periodic
    //
    void                    AWC_Periodic(void);
    void                    CA_Periodic(void);
    void                    CM_Periodic(void);
    UINT                    SWL_Periodic(void);
    void                    UP_Periodic(UINT currentTime);


    //
    // Component routines - public
    //

    void                    AWC_ActivateWindow(HWND hwnd);

    void                    BA_AddRect(LPRECT pRect);
    void                    BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);
    void                    BA_FetchBounds(void);
    UINT                    BA_QueryAccumulation(void);
    void                    BA_ReturnBounds(void);

    UINT                    CH_CacheData(PCHCACHE  pCache, LPBYTE pData,
                                UINT cbSize, UINT evictionCategory);
    void                    CH_ClearCache(PCHCACHE pCache );
    BOOL                    CH_CreateCache(PCHCACHE * ppCache, UINT cEntries,
                                UINT cEvictionCategories, UINT cbNotHashed,
                                PFNCACHEDEL pfnCacheDel);
    void                    CH_DestroyCache(PCHCACHE hCache);
    void                    CH_RemoveCacheEntry(PCHCACHE pCache, UINT iCacheEntry);
    BOOL                    CH_SearchAndCacheData(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    BOOL                    CH_SearchCache(PCHCACHE pCache, LPBYTE pData,
                                UINT cbData, UINT evictionCategory, UINT* piEntry);
    void                    CH_TouchCacheEntry(PCHCACHE pCache, UINT iCacheEntry);

    void                    CM_ApplicationMovedCursor(void);
    void                    CM_Controlled(ASPerson * pasControlledBy);
    void                    CM_MaybeSendCursorMovedPacket(void);

    void                    HET_RepaintAll(void);

    void                    OA_FlowControl(UINT newBufferSize);
    LPINT_ORDER             OA_GetFirstListOrder(void);
    UINT                    OA_GetTotalOrderListBytes(void);
    void                    OA_LocalHostReset(void);
    UINT                    OA_QueryOrderAccum(void);
    LPINT_ORDER             OA_RemoveListOrder(LPINT_ORDER pCondemnedOrder);
    void                    OA_ResetOrderList(void);

    BOOL                    OE_RectIntersectsSDA(LPRECT lpRect);

    TSHR_UINT16             OE2_EncodeOrder(LPINT_ORDER pIntOrder,
                                LPVOID pBuffer, TSHR_UINT16 cbBufferSize);
    BOOL                    OE2_UseFont(LPSTR pName, TSHR_UINT16 facelength,
                                TSHR_UINT16 CodePage, TSHR_UINT16 MaxHeight,
                                TSHR_UINT16 Height, TSHR_UINT16 Width,
                                TSHR_UINT16 Weight, TSHR_UINT16 flags);

    void                    PM_AdjustColorsForBuggedDisplayDrivers(LPTSHR_RGBQUAD pColors,
                                UINT cColors);
    BOOL                    PM_CacheTxColorTable(LPUINT pIndex, LPBOOL pNewEntry,
                                UINT cColors, LPTSHR_RGBQUAD pColors);
    HPALETTE                PM_GetLocalPalette(void);
    void                    PM_GetSystemPaletteEntries(LPTSHR_RGBQUAD pColors);
    BOOL                    PM_MaybeSendPalettePacket(void);

    void                    SBC_CacheCleared(void);
    void                    SBC_CacheEntryRemoved(UINT cache, UINT cacheIndex);
    UINT                    SBC_CopyPrivateOrderData(LPBYTE pDst,
                                LPCOM_ORDER pOrder, UINT cbFree);
    void                    SBC_OrderSentNotification(LPINT_ORDER pOrder);
    void                    SBC_PMCacheEntryRemoved(UINT cacheIndex);
    void                    SBC_ProcessInternalOrder(LPINT_ORDER pOrder);
    BOOL                    SBC_ProcessMemBltOrder(LPINT_ORDER pOrder,
                                LPINT_ORDER * ppNextOrder);
    void                    SBC_RecreateSendCache(UINT cache, UINT newEntries,
                                UINT newCellSize);

    void                    SDG_SendScreenDataArea(LPBOOL pBackPressure, UINT * pcPackets);

    HWND                    SWL_GetSharedIDFromLocalID(HWND hwnd);
    UINT_PTR                SWL_GetWindowProperty(HWND hwnd);
    void                    SWL_InitFullWindowListEntry(HWND hwnd, UINT prop,
                                LPSTR * ppNames, PSWLWINATTRIBUTES pFullWinEntry);
    BOOL                    SWL_IsOurDesktopActive(void);
    void                    SWL_UpdateCurrentDesktop(void);

    void                    UP_FlowControl(UINT newSize);
    BOOL                    UP_MaybeSendSyncToken(void);

protected:
    void                    CHAvlBalanceTree(PCHCACHE, PCHENTRY);
    void                    CHAvlDelete(PCHCACHE, PCHENTRY, UINT);
    PCHENTRY                CHAvlFind(PCHCACHE, UINT, UINT);
    PCHENTRY                CHAvlFindEqual(PCHCACHE, PCHENTRY);
    void                    CHAvlInsert(PCHCACHE, PCHENTRY);
    LPBYTE                  CHAvlNext(PCHENTRY);
    LPBYTE                  CHAvlPrev(PCHENTRY);
    void                    CHAvlRebalance(PCHENTRY *);
    void                    CHAvlRotateLeft(PCHENTRY *);
    void                    CHAvlRotateRight(PCHENTRY *);
    void                    CHAvlSwapLeftmost(PCHCACHE, PCHENTRY, PCHENTRY);
    void                    CHAvlSwapRightmost(PCHCACHE, PCHENTRY, PCHENTRY);
    UINT                    CHCheckSum(LPBYTE pData, UINT cbDataSize);
    int                     CHCompare(UINT key, UINT cbSize, PCHENTRY pEntry);
    UINT                    CHEvictCacheEntry(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);
    UINT                    CHEvictLRUCacheEntry(PCHCACHE pCache, UINT evictionCategory, UINT evictionCount);
    BOOL                    CHFindFreeCacheEntry(PCHCACHE pCache, UINT* piEntry, UINT* pEvictionCount);
    void                    CHInitEntry(PCHENTRY);
    void                    CHRemoveEntry(PCHCACHE pCache, UINT iCacheEntry);
    UINT                    CHTreeSearch(PCHCACHE pCache, UINT checksum, UINT cbDataSize, LPBYTE pData);
    void                    CHUpdateMRUList(PCHCACHE pCache, UINT iEntry, UINT evictionCategory);

    BOOL                    CMGetColorCursorDetails( LPCM_SHAPE pCursor,
                                LPTSHR_UINT16 pcxWidth, LPTSHR_UINT16 pcyHeight,
                                LPTSHR_UINT16 pxHotSpot, LPTSHR_UINT16 pyHotSpot,
                                LPBYTE pANDMask, LPTSHR_UINT16 pcbANDMask,
                                LPBYTE pXORBitmap, LPTSHR_UINT16 pcbXORBitmap );
    BOOL                    CMGetCursorTagInfo(LPCSTR szTagName);
    void                    CMRemoveCursorTransform(void);
    BOOL                    CMSetCursorTransform(LPBYTE pANDMask, LPBITMAPINFO pXORDIB);
    BOOL                    CMSendBitmapCursor(void);
    BOOL                    CMSendCachedCursor(UINT iCacheEntry);
    BOOL                    CMSendColorBitmapCursor(LPCM_SHAPE pCursor,
                                UINT iCacheEntry);
    BOOL                    CMSendCursorShape(LPCM_SHAPE lpCursorShape,
                                UINT cbCursorDataSize);
    BOOL                    CMSendMonoBitmapCursor(LPCM_SHAPE pCursor);
    BOOL                    CMSendSystemCursor(UINT cursorIDC);

    void                    OAFreeAllOrders(LPOA_SHARED_DATA);

    void                    OE2EncodeBounds(LPBYTE * ppNextFreeSpace,
                                LPTSHR_RECT16 pRect);

    void                    PMGetGrays(void);
    BOOL                    PMSendPalettePacket(LPTSHR_RGBQUAD  pColorTable,
                                UINT numColors);
    BOOL                    PMUpdateSystemPaletteColors(void);
    BOOL                    PMUpdateTxPaletteColors(void);

    void                    SBCAddToFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT cache,
                                UINT cacheIndex, UINT colorCacheIndex);
    BOOL                    SBCCacheBits(LPINT_ORDER pOrder, UINT cbDst,
                                LPBYTE pDIBits, UINT bitmapWidth,
                                UINT fixedBitmapWidth, UINT bitmapHeight,
                                UINT numBytes, UINT * pCache, UINT * pCacheIndex,
                                LPBOOL pIsNewEntry);
    BOOL                    SBCCacheColorTable(LPINT_ORDER pColorTableOrder,
                                LPTSHR_RGBQUAD pColorTable, UINT numColors,
                                UINT * pCacheIndex, LPBOOL pIsNewEntry);
    BOOL                    SBCFindInFastPath(UINT_PTR majorInfo, UINT minorInfo,
                                UINT_PTR majorPalette, UINT minorPalette, int srcX,
                                int srcY, UINT width, UINT height, UINT * pCache,
                                UINT * pCacheIndex, UINT * pColorCacheIndex);
    void                    SBCFreeInternalOrders(void);
    BOOL                    SBCGetTileData(UINT tileId, LPSBC_TILE_DATA * ppTileData,
                                UINT * pTileType);
    void                    SBCInitCacheStructures(void);
    BOOL                    SBCInitFastPath(void);
    BOOL                    SBCInitInternalOrders(void);
    BOOL                    SBCSelectCache(UINT bitsSize, UINT * pCacheIndex);

    BOOL                    SDGSmallBltToNetwork(LPRECT pRect);
    BOOL                    SDGSplitBltToNetwork(LPRECT pRect, UINT * pcPacket);

    void                    SWLAddHostWindowTitle(HWND, UINT, HWND, LPSTR *);
    void                    SWLAdjustZOrderForTransparency(PSWLWINATTRIBUTES pTrans,
                                PSWLWINATTRIBUTES pLast, UINT pos, LPSTR pWinNames,
                                UINT sizeWinNames);
    UINT                    SWLCompactWindowList(UINT, PSWLWINATTRIBUTES, PSWLWINATTRIBUTES);
    void                    SWLInitHostFullWinListEntry(HWND hwnd, UINT prop,
                                HWND hwndOwner, PSWLWINATTRIBUTES pFullWinEntry);
    BOOL                    SWLSendPacket(PSWLWINATTRIBUTES pWindows,
                                UINT numWindows, LPSTR pTitles, UINT lenTitles,
                               UINT NRInfoSize, LPTSHR_UINT16 pNRInfo);
    BOOL                    SWLWindowIsOnTaskBar(HWND hwnd);
    BOOL                    SWLWindowIsTaggable(HWND hwnd);

    UINT                    UPFetchOrdersIntoBuffer(LPBYTE pBuffer,
                                LPTSHR_UINT16 pcOrders, LPUINT pcbBufferSize);
    BOOL                    UPSendOrders(UINT *);
    UINT                    UPSendUpdates(void);

};


void PMCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);
void SBCCacheCallback(ASHost* pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);




//
// This is the per-person data we keep to VIEW a host.  When this person
// starts to host, we allocate this structure, and then subblocks as
// necessary like caches.  When this person stops hosting, we free it
// after freeing the objects contained within.
//
// NOTE that for some whacky 2.x compatibility, some things that should
// be in the ASView structure are actually kept in ASPerson because
// the information contained within has to stay around when that person
// isn't hosting.  With 3.0 hosts that's not the case.  So when 2.x
// compatibility goes away, move OD2 PM RBC fields here also.
//

class ASView
{
public:
    STRUCTURE_STAMP

    // DS vars
    // For NM 2.x machines only, the offset if their desktop is scrolled over
    POINT                   m_dsScreenOrigin;

    // OD vars, for playback of orders from this remote host
    HRGN                    m_odInvalRgnOrder;
    HRGN                    m_odInvalRgnTotal;
    UINT                    m_odInvalTotal;

    COLORREF                m_odLastBkColor;
    COLORREF                m_odLastTextColor;
    int                     m_odLastBkMode;
    int                     m_odLastROP2;
    UINT                    m_odLastFillMode;
    UINT                    m_odLastArcDirection;
    UINT                    m_odLastPenStyle;
    UINT                    m_odLastPenWidth;
    COLORREF                m_odLastPenColor;
    COLORREF                m_odLastForeColor;
    int                     m_odLastBrushOrgX;
    int                     m_odLastBrushOrgY;
    COLORREF                m_odLastBrushBkColor;
    COLORREF                m_odLastBrushTextColor;
    HBITMAP                 m_odLastBrushPattern;
    UINT                    m_odLastLogBrushStyle;
    UINT                    m_odLastLogBrushHatch;
    TSHR_COLOR              m_odLastLogBrushColor;
    BYTE                    m_odLastLogBrushExtra[7];
    int                     m_odLastCharExtra;
    int                     m_odLastJustExtra;
    int                     m_odLastJustCount;
    HFONT                   m_odLastFontID;
    UINT                    m_odLastFontCodePage;
    UINT                    m_odLastFontWidth;
    UINT                    m_odLastFontHeight;
    UINT                    m_odLastFontWeight;
    UINT                    m_odLastFontFlags;
    UINT                    m_odLastFontFaceLen;
    BYTE                    m_odLastFaceName[FH_FACESIZE];
    UINT                    m_odLastBaselineOffset;
    COLORREF                m_odLastVGAColor[OD_NUM_COLORS];
    TSHR_COLOR              m_odLastVGAResult[OD_NUM_COLORS];
    BOOL                    m_odRectReset;
    int                     m_odLastLeft;
    int                     m_odLastTop;
    int                     m_odLastRight;
    int                     m_odLastBottom;

    // SSI vars
    HDC                     m_ssiDC;
    HBITMAP                 m_ssiBitmap;              // Bitmap handle
    HBITMAP                 m_ssiOldBitmap;
    int                     m_ssiBitmapHeight;

    // SWL vars
    int                     m_swlCount;
    SWLWINATTRIBUTES        m_aswlLast[SWL_MAX_WINDOWS];

    // USR vars
    HDC                     m_usrDC;
    HDC                     m_usrWorkDC;
    HBITMAP                 m_usrBitmap;
    HBITMAP                 m_usrOldBitmap;

    // VIEW vars
    HWND                    m_viewFrame;                // Frame
    HWND                    m_viewClient;               // Host view
    HWND                    m_viewStatusBar;            // Status bar
    UINT                    m_viewStatus;               // Current status
    HMENU                   m_viewMenuBar;              // Menu bar
    RECT                    m_viewSavedWindowRect;      // When full screen, old pos
    HWND                    m_viewInformDlg;            // Notification message up
    UINT                    m_viewInformMsg;            // Informational message

    BOOL                    m_viewFocus:1;              // Key strokes are going to this
    BOOL                    m_viewInMenuMode:1;         // In menu mode
    BOOL                    m_viewFullScreen:1;         // Full screen UI
    BOOL                    m_viewWindowBarOn:1;
    BOOL                    m_viewStatusBarOn:1;
    BOOL                    m_viewSavedWindowBarOn:1;
    BOOL                    m_viewSavedStatusBarOn:1;
    BOOL                    m_viewFullScreenExitTrack:1;
    BOOL                    m_viewFullScreenExitMove:1;

    POINT                   m_viewSavedPos;
    POINT                   m_viewFullScreenExitStart;

    HWND                    m_viewWindowBar;            // App window bar
    BASEDLIST               m_viewWindowBarItems;       // Items in window bar
    PWNDBAR_ITEM            m_viewWindowBarActiveItem;  // Current item
    int                     m_viewWindowBarItemFirst;   // Index of 1st visible item
    int                     m_viewWindowBarItemFitCount;    // # of items that fit
    int                     m_viewWindowBarItemCount;   // # of items total

    UINT                    m_viewMouseFlags;           // For capture
    POINT                   m_viewMouse;                // Mouse pos
    BOOL                    m_viewMouseOutside;         // Mouse is down, outside client
    int                     m_viewMouseWheelDelta;      // Intellimouse wheel insanity

    //
    // These are kept always in the view's client coords.  When the view
    // scrolls over, the shared and obscured regions are adjusted too.
    // When a new SWL packet for the host comes in, these regions are
    // saved accounting for scrolling too.
    //
    HRGN                    m_viewSharedRgn;           // Shared area, not obscured
    HRGN                    m_viewObscuredRgn;         // Shared area, obscured
    HRGN                    m_viewExtentRgn;
    HRGN                    m_viewScreenRgn;
    HRGN                    m_viewPaintRgn;
    HRGN                    m_viewScratchRgn;

    POINT                   m_viewPos;                 // View scroll pos
    POINT                   m_viewPage;                // View page size
    POINT                   m_viewPgSize;              // Page scroll inc
    POINT                   m_viewLnSize;              // Line scroll inc
};




//
// This is the per-person data we keep for each person in a conference.
// We dynamically allocate everybody but ourself (the local dude).
//


class ASPerson
{
public:
    STRUCTURE_STAMP

    ASPerson *              pasNext;

    // VIEW vars (allocated when this person is hosting that we use to VIEW them)
    ASView *                m_pView;

    // SC vars
    UINT_PTR                    mcsID;                      // MCS user_id
    char                    scName[TSHR_MAX_PERSON_NAME_LEN];  // Name
    BYTE                    scSyncSendStatus[SC_STREAM_COUNT];
    BYTE                    scSyncRecStatus[SC_STREAM_COUNT];

    //
    // AWC vars
    // When 2.x compat goes away, move these to AS_VIEW
    //
    UINT_PTR             awcActiveWinID;

    // CA vars
    BOOL                    m_caAllowControl;
    BOOL                    m_caControlPaused;      // ONLY HOST CONTROLLED BY US or US PAUSED
    UINT                    m_caControlID;          // ONLY NODE WE ARE CONTROLLING/CONTROLLED BY
    ASPerson *              m_caControlledBy;
    ASPerson *              m_caInControlOf;
    BOOL                    m_ca2xCooperating;

    //
    // CM vars
    // When 2.x compat goes away, move most of these to AS_VIEW
    //
    POINT                   cmPos;              // Position of the remote cursor, in his screen coords
    POINT                   cmHotSpot;          // The remote cursor hotspot
    BOOL                    cmShadowOff;
    HCURSOR                 cmhRemoteCursor;
    UINT                    ccmRxCache;         // # of entries in cache
    PCACHEDCURSOR           acmRxCache;         // Cached cursor array

    // CPC vars
    CPCALLCAPS              cpcCaps;

    // DCS vars
    PGDC_DICTIONARY         adcsDict;                   // POINTER

    // HET vars
    int                     hetCount;

    // OE vars
    UINT                    oecFonts;
    POEREMOTEFONT           poeFontInfo;

    //
    // NOTE:
    // These are here and not in the HOST data for 2.x compat.  2.x systems
    // don't reset outgoing info if they stay in a share while stopping/
    // restarting hosting.  3.0 systems do (look in HET_HostStarting()).
    // So we must keep the old gunky cache/decode data around for backlevel
    // systems.  Therefore we allocate it dynamically still.
    //

    // OD2 vars
    PPARTYORDERDATA         od2Party;

    // PM vars
    HPALETTE                pmPalette;
    UINT                    pmcColorTable;
    PCOLORTABLECACHE        apmColorTable;

    // RBC vars
    PRBC_HOST_INFO          prbcHost;

    // VIEW vars
    // NOTE: because of bugs in 2.x VD calcs, this is kept around while
    // the person is in the share, whether they are hosting or not.
    POINT                   viewExtent;              // View extent (may be > usrScreenSize for 2.x dudes)
};



//
// Allocated when in a share
//

class ASShare
{
public:
    STRUCTURE_STAMP

    ASHost *                m_pHost;
    ASPerson *              m_pasLocal;    // People list, starting with local person

    //
    // Bitmap Compressor/Decompressor
    //
    MATCH *                 m_amatch;
    LPBYTE                  m_abNormal;
    LPBYTE                  m_abXor;

    //
    // Control Arbitrator
    //
    char                    m_caToggle;
    char                    m_caPad1;
    short                   m_caPad2;
    BASEDLIST               m_caQueuedMsgs;
    ASPerson *              m_caWaitingForReplyFrom;
    UINT                    m_caWaitingForReplyMsg;

    HWND                    m_caQueryDlg;
    CA30PENDING             m_caQuery;

    ASPerson *              m_ca2xControlTokenOwner;    // Person owning control token
    UINT_PTR                m_ca2xControlGeneration;

    //
    // Cursor
    //
    UINT                    m_cmCursorWidth;
    UINT                    m_cmCursorHeight;
    HCURSOR                 m_cmArrowCursor;
    POINT                   m_cmArrowCursorHotSpot;
    HBRUSH                  m_cmHatchBrush;
    HFONT                   m_cmCursorTagFont;

    DWORD                   m_dcsLastScheduleTime;
    DWORD                   m_dcsLastFastMiscTime;
    DWORD                   m_dcsLastIMTime;
    UINT                    m_dcsCompressionLevel;
    UINT                    m_dcsCompressionSupport;
    BOOL                    m_dcsLargePacketCompressionOnly;

    //
    // PKZIP
    //
    BYTE                    m_agdcWorkBuf[GDC_WORKBUF_SIZE];

    //
    // Fonts
    //
    BOOL                    m_fhLocalInfoSent;

    //
    // Hosting
    //
    UINT                    m_hetHostCount;
    BOOL                    m_hetRetrySendState;
    BOOL                    m_hetViewers;

    //
    // Input Manager
    //

    // GLOBAL (or costly to calc/load and undo repeatedly)
    WORD                    m_imScanVKLShift;
    WORD                    m_imScanVKRShift;
    HINSTANCE               m_imImmLib;
    IMMGVK                  m_imImmGVK;

    // IN CONTROL
    BOOL                    m_imfInControlEventIsPending:1;
    BOOL                    m_imfInControlCtrlDown:1;
    BOOL                    m_imfInControlShiftDown:1;
    BOOL                    m_imfInControlMenuDown:1;
    BOOL                    m_imfInControlCapsLock:1;
    BOOL                    m_imfInControlNumLock:1;
    BOOL                    m_imfInControlScrollLock:1;
    BOOL                    m_imfInControlConsumeMenuUp:1;
    BOOL                    m_imfInControlConsumeEscapeUp:1;
    BOOL                    m_imfInControlNewEvent:1;

    IMEVENT                 m_imInControlPendingEvent;
    IMEVENTQ                m_imInControlEventQ;
    BYTE                    m_aimInControlKeyStates[256];
    int                     m_imInControlMouseDownCount;
    DWORD                   m_imInControlMouseDownTime;
    UINT                    m_imInControlMouseWithhold;
    DWORD                   m_imInControlMouseSpoilRate;
    UINT                    m_imInControlNumEventsPending;
    UINT                    m_imInControlNumEventsReturned;
    UINT                    m_aimInControlEventsToReturn[15];
    UINT                    m_imInControlNextHotKeyEntry;
    BYTE                    m_aimInControlHotKeyArray[4];
    UINT                    m_imInControlNumDeadKeysDown;
    UINT                    m_imInControlNumDeadKeys;
    BYTE                    m_aimInControlDeadKeys[IM_MAX_DEAD_KEYS];

    // CONTROLLED (only when hosting!)
    BOOL                    m_imfControlledMouseButtonsReversed:1;
    BOOL                    m_imfControlledMouseClipped:1;
    BOOL                    m_imfControlledPaceInjection:1;
    BOOL                    m_imfControlledNewEvent:1;
    UINT                    m_imControlledNumEventsPending;
    UINT                    m_imControlledNumEventsReturned;
    UINT                    m_aimControlledEventsToReturn[15];
    UINT                    m_imControlledVKToReplay;
    IMEVENTQ                m_imControlledEventQ;
    IMOSQ                   m_imControlledOSQ;
    BYTE                    m_aimControlledControllerKeyStates[256];
    BYTE                    m_aimControlledKeyStates[256];
    BYTE                    m_aimControlledSavedKeyStates[256];
    DWORD                   m_imControlledLastLowLevelMouseEventTime;
    DWORD                   m_imControlledLastMouseRemoteTime;
    DWORD                   m_imControlledLastMouseLocalTime;
    DWORD                   m_imControlledLastIncompleteConversion;
    DWORD                   m_imControlledMouseBacklog;
    POINT                   m_imControlledLastMousePos;

    //
    // Order Encoder
    //
    BOOL                    m_oefSendOrders:1;
    BOOL                    m_oefTextEnabled:1;
    BOOL                    m_oefOE2EncodingOn:1;
    BOOL                    m_oefOE2Negotiable:1;
    BOOL                    m_oefBaseOE:1;
    BOOL                    m_oefAlignedOE:1;
    BYTE                    m_aoeOrderSupported[ORD_NUM_INTERNAL_ORDERS];
    PROTCAPS_ORDERS         m_oeCombinedOrderCaps;
    UINT                    m_oeOE2Flag;

    //
    // Share Controller
    //
    BOOL                    m_scfViewSelf:1;
#ifdef _DEBUG
    BOOL                    m_scfInSync:1;
#endif // _DEBUG
    UINT                    m_scShareVersion;
    int                     m_ascSynced[SC_STREAM_COUNT];
    LPBYTE                  m_ascTmpBuffer;

    TSHR_UINT16             m_swlLastTokenSeen;
    WORD                    m_swlPad;

    POINT                   m_viewVDSize;
    int                     m_viewEdgeCX;
    int                     m_viewEdgeCY;
    HBRUSH                  m_viewObscuredBrush;
    HICON                   m_viewFullScreenExitIcon;
    int                     m_viewFullScreenCX;
    int                     m_viewFullScreenCY;
    int                     m_viewItemCX;
    int                     m_viewItemCY;
    int                     m_viewItemScrollCX;
    int                     m_viewItemScrollCY;
    int                     m_viewStatusBarCY;
    int                     m_viewWindowBarCY;
    HCURSOR                 m_viewNotInControl;
    UINT                    m_viewMouseWheelScrollLines;

    HBITMAP                 m_usrBmp16;
    HBITMAP                 m_usrBmp32;
    HBITMAP                 m_usrBmp48;
    HBITMAP                 m_usrBmp64;
    HBITMAP                 m_usrBmp80;
    HBITMAP                 m_usrBmp96;
    HBITMAP                 m_usrBmp112;
    HBITMAP                 m_usrBmp128;
    HBITMAP                 m_usrBmp256;
    HBITMAP                 m_usrBmp1024;
    LPBYTE                  m_usrPBitmapBuffer;
    BOOL                    m_usrHatchBitmaps;
    BOOL                    m_usrHatchScreenData;
    int                     m_usrHatchColor;

public:
#ifdef _DEBUG
    void                ValidatePerson(ASPerson * pasPerson);
    void                ValidateView(ASPerson * pasPerson);
#else
    __inline void       ValidatePerson(ASPerson * pasPerson) {}
    __inline void       ValidateView(ASPerson * pasPerson) {}
#endif // _DEBUG


    //
    // Share init
    //
    BOOL                SC_ShareStarting(void);

    BOOL                BCD_ShareStarting(void);
    BOOL                CM_ShareStarting(void);
    BOOL                IM_ShareStarting(void);
    BOOL                VIEW_ShareStarting(void);
    BOOL                USR_ShareStarting(void);

    //
    // Share term
    //
    void                SC_ShareEnded(void);

    void                BCD_ShareEnded(void);
    void                CM_ShareEnded(void);
    void                IM_ShareEnded(void);
    void                VIEW_ShareEnded(void);
    void                USR_ShareEnded(void);

    //
    // Member joining share
    //
    BOOL                SC_PartyAdded(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    ASPerson *          SC_PartyJoiningShare(UINT mcsID, LPSTR szName, UINT cbCaps, LPVOID pCaps);
    BOOL                CM_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                CPC_PartyJoiningShare(ASPerson * pasPerson, UINT cbCaps, void* pCapsData);
    BOOL                DCS_PartyJoiningShare(ASPerson * pasPerson);
    BOOL                HET_PartyJoiningShare(ASPerson * pasPerson);

    //
    // Member leaving share
    //
    void                SC_PartyDeleted(UINT_PTR mcsID);
    void                SC_PartyLeftShare(UINT_PTR mcsID);
    void                CA_PartyLeftShare(ASPerson * pasPerson);
    void                CM_PartyLeftShare(ASPerson * pasPerson);
    void                DCS_PartyLeftShare(ASPerson * pasPerson);
    void                HET_PartyLeftShare(ASPerson * pasPerson);
    void                OD2_PartyLeftShare(ASPerson * pasPerson);
    void                OE_PartyLeftShare(ASPerson * pasPerson);
    void                PM_PartyLeftShare(ASPerson * pasPerson);
    void                RBC_PartyLeftShare(ASPerson * pasPerson);
    void                SWL_PartyLeftShare(ASPerson * pasPerson);
    void                VIEW_PartyLeftShare(ASPerson * pasPerson);


    //
    // Recalc caps after somebody joined or left
    //
    void                SC_RecalcCaps(BOOL fJoiner);

    void                CM_RecalcCaps(BOOL fJoiner);
    void                DCS_RecalcCaps(BOOL fJoiner);
    void                OE_RecalcCaps(BOOL fJoiner);
    void                PM_RecalcCaps(BOOL fJoiner);
    void                SBC_RecalcCaps(BOOL fJoiner);
    void                SSI_RecalcCaps(BOOL fJoiner);
    void                USR_RecalcCaps(BOOL fJoiner);


    //
    // Syncing due to new member joined or reset
    //
    void                DCS_SyncOutgoing(void);
    void                IM_SyncOutgoing(void);
    void                OD2_SyncIncoming(ASPerson * pasPerson);
    void                OE_SyncOutgoing(void);


    //
    // Starting host view
    //
    BOOL                HET_ViewStarting(ASPerson * pasPerson);

    BOOL                CA_ViewStarting(ASPerson * pasPerson);
    BOOL                CM_ViewStarting(ASPerson * pasPerson);
    BOOL                OD_ViewStarting(ASPerson * pasPerson);
    BOOL                OD2_ViewStarting(ASPerson * pasPerson);
    BOOL                PM_ViewStarting(ASPerson * pasPErson);
    BOOL                RBC_ViewStarting(ASPerson * pasPerson);
    BOOL                SSI_ViewStarting(ASPerson * pasPerson);
    BOOL                VIEW_ViewStarting(ASPerson * pasPerson);
    BOOL                USR_ViewStarting(ASPerson * pasPerson);


    //
    // Stopped host view
    //
    void                HET_ViewEnded(ASPerson * pasPerson);

    void                CA_ViewEnded(ASPerson * pasPerson);
    void                CM_ViewEnded(ASPerson * pasPerson);
    void                OD_ViewEnded(ASPerson * pasPerson);
    void                OD2_ViewEnded(ASPerson * pasPerson);
    void                PM_ViewEnded(ASPerson * pasPerson);
    void                RBC_ViewEnded(ASPerson * pasPerson);
    void                SSI_ViewEnded(ASPerson * pasPerson);
    void                VIEW_ViewEnded(ASPerson * pasPerson);
    void                USR_ViewEnded(ASPerson * pasPerson);

    //
    // Periodic processing when in share, mostly for when hosting
    //
    void                SC_Periodic(void);

    void                CA_Periodic(void);
    void                HET_Periodic(void);
    void                IM_Periodic(void);
    void                OE_Periodic(void);

    //
    // Incoming packet handling
    //
    void                SC_ReceivedPacket(PS20DATAPACKET pPacket);
    void                AWC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CA30_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                CPC_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                FH_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                HET_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                PM_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                OD_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                SDP_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                SWL_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);
    void                UP_ReceivedPacket(ASPerson * pasFrom, PS20DATAPACKET pPacket);

    //
    // Random component routines
    //
    BOOL                AWC_SendMsg(UINT_PTR userTo, UINT msg, UINT_PTR data1, UINT_PTR data2);

    BOOL                BC_CompressBitmap( LPBYTE  pSrcBitmap,
                                LPBYTE  pDstBuffer,
                                LPUINT   pDstBufferSize,
                                UINT    bitmapWidth,
                                UINT    bitmapHeight,
                                UINT    bitmapBitsPerPel,
                                LPBOOL   pLossy);
    BOOL                BD_DecompressBitmap( LPBYTE  pCompressedData,
                                  LPBYTE  pDstBitmap,
                                  UINT    srcDataSize,
                                  UINT    bitmapWidth,
                                  UINT    bitmapHeight,
                                  UINT    bitmapBitsPerPel );

    void                CA_TakeControl(ASPerson * pasHost);
    void                CA_CancelTakeControl(ASPerson * pasHost, BOOL fPacket);
    void                CA_ReleaseControl(ASPerson * pasFrom, BOOL fPacket);
    void                CA_PassControl(ASPerson * pasHost, ASPerson * pasViewer);

    void                CA_AllowControl(BOOL fAllow);
    void                CA_GiveControl(ASPerson * pasInvite);
    void                CA_CancelGiveControl(ASPerson * pasViewer, BOOL fPacket);
    void                CA_RevokeControl(ASPerson * pasController, BOOL fPacket);
    void                CA_PauseControl(ASPerson * pasController,  BOOL fPause, BOOL fPacket);

    void                CA_ClearLocalState(UINT clearFlags, ASPerson * pasRemote, BOOL fPacket);
    BOOL                CA_QueryDlgProc(HWND, UINT, WPARAM, LPARAM);

    void                CM_DrawShadowCursor(ASPerson * pasPerson, HDC hdc );
    void                CM_UpdateShadowCursor(ASPerson * pasPerson, BOOL fOff,
                                int xPosNew, int yPosNew, int xHotNew, int yHotNew);

    void                CPC_UpdatedCaps(PPROTCAPS pCaps);

#ifdef _DEBUG
    UINT                DCS_CompressAndSendPacket(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#else
    void                DCS_CompressAndSendPacket(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket, UINT packetLength);
#endif // _DEBUG
    void                DCS_FlowControl(UINT newBufferSize);

    void                DCS_TakeControl(UINT gccOf);
    void                DCS_CancelTakeControl(UINT gccOf);
    void                DCS_ReleaseControl(UINT gccOf);
    void                DCS_PassControl(UINT gccOf, UINT gccTo);
    void                DCS_GiveControl(UINT gccTo);
    void                DCS_CancelGiveControl(UINT gccTo);
    void                DCS_RevokeControl(UINT gccTo);
    void                DCS_PauseControl(UINT gccTo, BOOL fPause);

    void                FH_ConvertAnyFontIDToLocal(LPCOM_ORDER pOrder, ASPerson * pasPerson);
    void                FH_DetermineFontSupport(void);
    void                FH_SendLocalFontInfo(void);

    void                HET_CalcViewers(ASPerson * pasLeaving);
    void                HET_HandleNewTopLevel(BOOL fShowing);
    void                HET_HandleRecountTopLevel(UINT newCount);
    void                HET_ShareApp(WPARAM, LPARAM);
    void                HET_ShareDesktop(void);
    void                HET_UnshareAll(void);
    void                HET_UnshareApp(WPARAM, LPARAM);
    BOOL                HET_WindowIsHosted(HWND winid);

    BOOL                IM_Controlled(ASPerson * pasControlledBy);
    void                IM_InControl(ASPerson * pasInControlOf);
    void                IM_OutgoingKeyboardInput(ASPerson * pasHost,
                            UINT vkCode, UINT keyData);
    void                IM_OutgoingMouseInput(ASPerson * pasHost,
                            LPPOINT pMousePos, UINT message, UINT extra);
    void                IM_ReceivedPacket(ASPerson * pasPerson, PS20DATAPACKET pPacket);
    void                IM_SyncOutgoingKeyboard(void);

    void                OD_ReplayOrder(ASPerson * pasFrom, LPCOM_ORDER pOrder, BOOL fPalRGB);
    void                OD_ResetRectRegion(ASPerson * pasPerson);
    void                OD_UpdateView(ASPerson * pasHost);

    void                OD2_CalculateBounds(LPCOM_ORDER pOrder, LPRECT pRect,
                                BOOL fDecoding, ASPerson * pasPerson);
    void                OD2_CalculateTextOutBounds(LPTEXTOUT_ORDER pTextOut,
                                LPRECT pRect, BOOL fDecoding, ASPerson * pasPerson);
    LPCOM_ORDER         OD2_DecodeOrder(void * pEOrder, LPUINT LengthDecoded,
                            ASPerson * pasPerson);

    void                OE_EnableText(BOOL enable);
    BOOL                OE_SendAsOrder(DWORD order);

    BOOL                PM_CacheRxColorTable(ASPerson *  pasPerson,
                                UINT index, UINT cColors, LPTSHR_RGBQUAD pColors);
    BOOL                PM_CreatePalette(UINT cEntries, LPTSHR_COLOR pNewEntries,
                            HPALETTE* phPal );
    void                PM_DeletePalette(HPALETTE palette);
    void                PM_GetColorTable(ASPerson * pasPerson, UINT index,
                                UINT * pcColors, LPTSHR_RGBQUAD pColors);

    HBITMAP             RBC_MapCacheIDToBitmapHandle(ASPerson * pasPerson,
                                UINT cacheIndex, UINT entry, UINT colorTable);
    void                RBC_ProcessCacheOrder(ASPerson * pasPerson, LPCOM_ORDER_UA pOrder);

    PS20DATAPACKET      SC_AllocPkt(UINT streamID, UINT_PTR nodeID, UINT_PTR len);
    ASPerson *          SC_PersonAllocate(UINT mcsID, LPSTR szName);
    ASPerson *          SC_PersonFromNetID(UINT_PTR mcsID);
    ASPerson *          SC_PersonFromGccID(UINT gccID);
    void                SC_PersonFree(ASPerson * pasFree);
    BOOL                SC_ValidateNetID(UINT_PTR mcsID, ASPerson** pLocal);

    void                SDP_DrawHatchedRect( HDC surface, int x, int y, int width, int height, UINT color);

    void                SSI_SaveBitmap(ASPerson * pasPerson, LPSAVEBITMAP_ORDER pSaveBitmap);

    TSHR_UINT16         SWL_CalculateNextToken(TSHR_UINT16 curToken);

    BOOL                VIEW_DlgProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FrameWindowProc(HWND, UINT, WPARAM, LPARAM);
    LRESULT             VIEW_FullScreenExitProc(HWND, UINT, WPARAM, LPARAM);
    void                VIEW_HostStateChange(ASPerson * pasHost);
    void                VIEW_InControl(ASPerson * pasRemote, BOOL fStart);
    void                VIEW_InvalidateRect(ASPerson * pasHost, LPRECT lprc);
    void                VIEW_InvalidateRgn(ASPerson * pasHost, HRGN rgnUpdated);
    BOOL                VIEW_IsPointShared(ASPerson * pasHost, POINT pt);
    void                VIEW_Message(ASPerson * pasHost, UINT ids);
    void                VIEW_PausedInControl(ASPerson * pasRemote, BOOL fPaused);
    void                VIEW_RecalcExtent(ASPerson * pasHost);
    void                VIEW_RecalcVD(void);
    void                VIEW_ScreenChanged(ASPerson * pasPerson);
    void                VIEW_SetHostRegions(ASPerson * pasHost, HRGN rgnShared, HRGN rgnObscured);
    void                VIEW_SyncCursorPos(ASPerson * pasHost, int x, int y);
    void                VIEW_UpdateStatus(ASPerson * pasHost, UINT idsStatus);
    LRESULT             VIEW_ViewWindowProc(HWND, UINT, WPARAM, LPARAM);


    void                VIEW_WindowBarChangedActiveWindow(ASPerson * pasHost);
    void                VIEW_WindowBarEndUpdateItems(ASPerson * pasHost, BOOL fAnyChanges);
    LRESULT             VIEW_WindowBarItemsProc(HWND, UINT, WPARAM, LPARAM);
    BOOL                VIEW_WindowBarUpdateItem(ASPerson * pasHost, PSWLWINATTRIBUTES pWinNew, LPSTR pText);
    LRESULT             VIEW_WindowBarProc(HWND, UINT, WPARAM, LPARAM);

    void                USR_InitDIBitmapHeader(BITMAPINFOHEADER * pbh, UINT bpp);
    void                USR_ScreenChanged(ASPerson * pasPerson);
    void                USR_ScrollDesktop(ASPerson * pasPerson, int xNew, int yNew);
    BOOL                USR_UseFont(HDC hdc, HFONT* pHFONT,
                            LPTEXTMETRIC pMetrics, LPSTR pName, UINT charSet,
                            UINT maxHeight, UINT height, UINT width,
                            UINT weight, UINT flags);


protected:
    void                CAClearRemoteState(ASPerson * pasClear);
    BOOL                CAClearHostState(ASPerson * pasHost, ASPerson * pasController);
    void                CAStartWaiting(ASPerson * pasWait, UINT msgWait);

    BOOL                CAStartQuery(ASPerson * pasFrom, UINT msg, PCA30P pReq);
    void                CAFinishQuery(UINT result);
    void                CACancelQuery(ASPerson * pasFrom, BOOL fPacket);

    void                CAHandleRequestTakeControl(ASPerson * pasViewer, PCA_RTC_PACKET pPacket);
    void                CACompleteRequestTakeControl(ASPerson * pasFrom, PCA_RTC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestTakeControl(ASPerson * pasHost, PCA_REPLY_RTC_PACKET pPacket);

    void                CAHandleRequestGiveControl(ASPerson * pasHost, PCA_RGC_PACKET pPacket);
    void                CACompleteRequestGiveControl(ASPerson * pasFrom, PCA_RGC_PACKET pPacket, UINT result);
    void                CAHandleReplyRequestGiveControl(ASPerson * pasViewer, PCA_REPLY_RGC_PACKET pPacket);

    void                CAHandlePreferPassControl(ASPerson * pasController, PCA_PPC_PACKET pPacket);
    void                CACompletePreferPassControl(ASPerson * pasViewer, UINT_PTR mcsOrg, PCA_PPC_PACKET pPacket, UINT result);

    void                CAHandleInformReleasedControl(ASPerson * pasController, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformRevokedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformPausedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);
    void                CAHandleInformUnpausedControl(ASPerson * pasHost, PCA_INFORM_PACKET pPacket);

    void                CAHandleNewState(ASPerson * pasHost, PCANOTPACKET pPacket);
    void                CAStartControlled(ASPerson * pasInControl, UINT controlID);
    void                CAStopControlled(void);
    void                CAStartInControl(ASPerson * pasControlled, UINT controlID);
    void                CAStopInControl(void);

    // 2.x stuff
    void                CA2xCooperateChange(ASPerson * pasFrom, BOOL fCooperating);
    void                CA2xGrantedControl(ASPerson * pasFrom, PCAPACKET pPacket);
    BOOL                CA2xQueueSendMsg(UINT_PTR destID, UINT msg, UINT_PTR data1,
                            UINT_PTR data2);
    void                CA2xRequestControl(ASPerson * pasFrom, PCAPACKET pPacket);
    BOOL                CA2xSendMsg(UINT_PTR destID, UINT msg, UINT_PTR data1, UINT_PTR data2);
    void                CA2xTakeControl(ASPerson * pas2xHost);

    BOOL                CAFlushOutgoingPackets();
    void                CALangToggle(BOOL);
    UINT                CANewRequestID(void);
    BOOL                CAQueueSendPacket(UINT_PTR destID, UINT msg, PCA30P pPacket);
    BOOL                CASendPacket(UINT_PTR destID, UINT msg, PCA30P pPacket);

    BOOL                CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);
    HCURSOR             CMCreateColorCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap, UINT cbANDMask, UINT cbXORBitmap);
    BOOL                CMCreateIncoming(ASPerson * pasPerson);
    HCURSOR             CMCreateMonoCursor(UINT xHotSpot, UINT yHotSpot,
                                UINT cxWidth, UINT cyHeight, LPBYTE pANDMask,
                                LPBYTE pXORBitmap);
    void                CMDrawCursorTag(ASPerson * pasPerson, HDC hdc);
    void                CMFreeIncoming(ASPerson * pasPerson);
    UINT                CMProcessColorCursorPacket( PCMPACKETCOLORBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMProcessCursorIDPacket(PCMPACKETID pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot);
    UINT                CMProcessMonoCursorPacket(PCMPACKETMONOBITMAP pCMPacket,
                                HCURSOR * phNewCursor, LPPOINT pNewHotSpot );
    void                CMReceivedCursorMovedPacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );
    void                CMReceivedCursorShapePacket(ASPerson * pasPerson, PCMPACKETHEADER pCMPacket );

    BOOL                CPCCapabilitiesChange(ASPerson * pasPerson, PPROTCAPS pCaps);

    ASPerson *          DCSGetPerson(UINT gccID, BOOL fNull);

    UINT                FHConsiderRemoteFonts(UINT cCommonFonts, ASPerson * pasPerson);
    UINT                FHGetLocalFontHandle(UINT remoteFont, ASPerson * pasPerson);
    void                FHMaybeEnableText(void);

    void                HETCheckSharing(BOOL fStartHost);
    BOOL                HETStartHosting(BOOL fDesktop);
    void                HETStopHosting(BOOL fDesktop);
    void                HETSendLocalCount(void);
    void                HETUpdateLocalCount(UINT newCount);
    void                HETUpdateRemoteCount(ASPerson * pasPerson, UINT newCount);

    BOOL                IMConvertAndSendEvent(ASPerson * pasFor, LPIMEVENT pIMEvent);
    UINT                IMConvertIMEventToOSEvent(LPIMEVENT pEvent, LPIMOSEVENT pOSEvent);
    void                IMDiscardUnreplayableOSEvents(void);
    void                IMGenerateFakeKeyPress(TSHR_UINT16 type,
                            TSHR_UINT16 key, TSHR_UINT16 flags);
    BYTE                IMGetHighLevelKeyState(UINT vk);
    void                IMSendKeyboardState(void);
    BOOL                IMTranslateIncoming(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    BOOL                IMTranslateOutgoing(LPIMEVENT pIMIn, LPIMEVENT pIMOut);
    void                IMAppendNetEvent(LPIMEVENT pIMEvent);

    void                IMFlushOutgoingEvents(void);
    void                IMInject(BOOL fStart);
    BOOL                IMInjectEvent(LPIMOSEVENT pEvent);
    BOOL                IMInjectingEvents(void);
    UINT                IMInsertModifierKeystrokes(BYTE curKBState, BYTE targetKBState,
                            LPUINT pEventQueue);
    void                IMMaybeAddDeadKey(BYTE vk);
    void                IMMaybeInjectEvents(void);
    void                IMSpoilEvents(void);
    void                IMUpdateAsyncArray(LPBYTE pimKeyStates, LPIMOSEVENT pEvent);

    void                ODAdjustColor(ASPerson * pasPerson, const TSHR_COLOR * pColorIn, LPTSHR_COLOR pColorOut, int type);
    void                ODDrawTextOrder(ASPerson * pasPerson, BOOL fExtText, BOOL fPalRGB,
                            LPCOMMON_TEXTORDER pCommon, LPSTR pText, UINT cchText,
                            LPRECT pExtRect, UINT extOptions, LPINT pExtDx);
    void                ODReplayARC(ASPerson * pasFrom, LPARC_ORDER pArc, BOOL fPalRGB);
    void                ODReplayCHORD(ASPerson * pasFrom, LPCHORD_ORDER pChord, BOOL fPalRGB);
    void                ODReplayDSTBLT(ASPerson * pasFrom, LPDSTBLT_ORDER pDstBlt, BOOL fPalRGB);
    void                ODReplayELLIPSE(ASPerson * pasFrom, LPELLIPSE_ORDER pEllipse, BOOL fPalRGB);
    void                ODReplayEXTTEXTOUT(ASPerson * pasFrom, LPEXTTEXTOUT_ORDER pExtTextOut, BOOL fPalRGB);
    void                ODReplayLINETO(ASPerson * pasFrom, LPLINETO_ORDER pLineTo, BOOL fPalRGB);
    void                ODReplayMEM3BLT(ASPerson * pasFrom, LPMEM3BLT_ORDER pMem3Blt, BOOL fPalRGB);
    void                ODReplayMEMBLT(ASPerson * pasFrom, LPMEMBLT_ORDER pMemBlt, BOOL fPalRGB);
    void                ODReplayOPAQUERECT(ASPerson * pasFrom, LPOPAQUERECT_ORDER pOpaqeRect, BOOL fPalRGB);
    void                ODReplayPATBLT(ASPerson * pasFrom, LPPATBLT_ORDER pPatBlt, BOOL fPalRGB);
    void                ODReplayPIE(ASPerson * pasFrom, LPPIE_ORDER pPie, BOOL fPalRGB);
    void                ODReplayPOLYBEZIER(ASPerson * pasFrom, LPPOLYBEZIER_ORDER pPolyBezier, BOOL fPalRGB);
    void                ODReplayPOLYGON(ASPerson * pasFrom, LPPOLYGON_ORDER pPolygon, BOOL fPalRGB);
    void                ODReplayRECTANGLE(ASPerson * pasFrom, LPRECTANGLE_ORDER pRectangle, BOOL fPalRGB);
    void                ODReplayROUNDRECT(ASPerson * pasFrom, LPROUNDRECT_ORDER pRoundRect, BOOL fPalRGB);
    void                ODReplaySCRBLT(ASPerson * pasFrom, LPSCRBLT_ORDER pScrBlt, BOOL fPalRGB);
    void                ODReplayTEXTOUT(ASPerson * pasFrom, LPTEXTOUT_ORDER pTextOut, BOOL fPalRGB);
    void                ODUseArcDirection(ASPerson * pasPerson, UINT dir);
    void                ODUseBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseBkMode(ASPerson * pasPerson, int mode);
    void                ODUseBrush(ASPerson * pasPerson, BOOL fPalRGB,
                            int x, int y, UINT Style, UINT Hatch,
                            TSHR_COLOR Color, BYTE  Extra[7]);
    void                ODUseFillMode(ASPerson * pasPerson, UINT mode);
    void                ODUseFont(ASPerson * pasPerson, LPSTR pName, UINT cchName,
                            UINT codePage, UINT maxHeight, UINT Height,
                            UINT Width, UINT Weight, UINT flags);
    void                ODUsePen(ASPerson * pasPerson, BOOL fPalRGB,
                            UINT style, UINT width, TSHR_COLOR color);
    void                ODUseRectRegion(ASPerson * pasPerson, int left,
                            int top, int right, int bottom);
    void                ODUseROP2(ASPerson * pasPerson, int rop);
    void                ODUseTextBkColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextCharacterExtra(ASPerson * pasPerson, int extra);
    void                ODUseTextColor(ASPerson * pasPerson, BOOL fPalRGB, TSHR_COLOR color);
    void                ODUseTextJustification(ASPerson * pasPerson, int extra, int count);

    void                OD2CopyFromDeltaCoords(LPTSHR_INT8* ppSrc, LPVOID pDst,
                                UINT cbDstField, BOOL fSigned, UINT numElements);
    void                OD2DecodeBounds(LPBYTE *ppNextDataToCopy,
                                LPTSHR_RECT16 pRect, ASPerson * pasPerson);
    void                OD2DecodeField(LPBYTE*  ppSrc, LPVOID pDest,
                                UINT cbSrcField, UINT cbDstField, BOOL fSigned,
                                UINT numElements);
    void                OD2FreeIncoming(ASPerson * pasPerson);
    BOOL                OD2UseFont(ASPerson * pasPerson, LPSTR pName,
                                UINT facelength, UINT codePage, UINT MaxHeight,
                                UINT Height, UINT Width, UINT Weight, UINT flags);

    void                OECapabilitiesChanged(void);

    void                PMFreeIncoming(ASPerson * pasPerson);

    void                RBCFreeIncoming(ASPerson * pasPerson);
    void                RBCStoreBitsInCacheBitmap(ASPerson *  pasPerson,
                            UINT cacheID, UINT iCacheEntry, UINT cxSubWidth,
                            UINT cxFixedWidth, UINT cySubHeight, UINT bpp,
                            LPBYTE pBitmapBits, UINT cbBitmapBits, BOOL fCompressed);

    BOOL                SCSyncStream(UINT streamID);

    void                SDPDrawHatchedRegion(HDC hdc, HRGN region, UINT hatchColor);
    void                SDPPlayScreenDataToRDB(ASPerson * pasPerson,
                            PSDPACKET pUpdates, LPBYTE pBits, LPRECT pPosition);

    void                VIEWClientAutoScroll(ASPerson *);
    void                VIEWClientCaptureStolen(ASPerson *);
    void                VIEWClientExtentChange(ASPerson * pasHost, BOOL fRedraw);
    void                VIEWClientGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWClientMouseDown(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMove(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseMsg(ASPerson *, UINT, WPARAM, LPARAM);
    void                VIEWClientMouseUp(ASPerson *, UINT, WPARAM, LPARAM, BOOL);
    void                VIEWClientMouseWheel(ASPerson *, WPARAM, LPARAM);
    void                VIEWClientPaint(ASPerson * pasHost);
    BOOL                VIEWClientScroll(ASPerson * pasHost, int xNew, int yNew);

    void                VIEWFrameAbout(ASPerson * pasHost);
    void                VIEWFrameCommand(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    BOOL                VIEWFrameCreate(ASPerson * pasHost);
    void                VIEWFrameFullScreen(ASPerson * pasHost, BOOL fFull);
    void                VIEWFrameGetSize(ASPerson * pasHost, LPRECT lprc);
    void                VIEWFrameHelp(ASPerson * pasHost);
    void                VIEWFrameInitMenuBar(ASPerson * pasHost);
    void                VIEWFrameOnMenuSelect(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    void                VIEWFrameResize(ASPerson * pasHost);
    void                VIEWFrameResizeChanged(ASPerson * pasHost);
    void                VIEWFrameSetStatus(ASPerson * pasHost, UINT idsStatus);

    void                VIEWFullScreenExitPaint(ASPerson * pasHost, HWND hwnd);

    void                VIEWStartControlled(BOOL fControlled);

    void                VIEWWindowBarDoActivate(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    void                VIEWWindowBarChangeActiveItem(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    BOOL                VIEWWindowBarCreate(ASPerson * pasHost, HWND hwndBar);
    PWNDBAR_ITEM        VIEWWindowBarFirstVisibleItem(ASPerson * pasHost);
    void                VIEWWindowBarItemsClick(ASPerson * pasHost, HWND hwndItems, int x, int y);
    void                VIEWWindowBarItemsInvalidate(ASPerson * pasHost, PWNDBAR_ITEM pItem);
    void                VIEWWindowBarItemsPaint(ASPerson * pasHost, HWND hwndItems);
    void                VIEWWindowBarItemsScroll(ASPerson * pasHost, WPARAM wParam, LPARAM lParam);
    void                VIEWWindowBarResize(ASPerson * pasHost, HWND hwndBar);


    BOOL                USRCreateRemoteDesktop(ASPerson * pasPerson);
    void                USRDeleteRemoteDesktop(ASPerson * pasPerson);

};




typedef struct tagASSession
{
    // pasNext someday!
    UINT                    scState;

    UINT_PTR                    callID;     // ID of call
    MCSID                   gccID;      // GCC node_id
    BOOL                    fShareCreator;
    NM30_MTG_PERMISSIONS    attendeePermissions;

    UINT                    cchLocalName;
    char                    achLocalName[TSHR_MAX_PERSON_NAME_LEN];
    ASShare *               pShare;
#ifdef _DEBUG
    DWORD                   scShareTime;
#endif

    HWND                    hwndHostUI;
    BOOL                    fHostUI:1;
    BOOL                    fHostUIFrozen:1;
}
ASSession;


#endif // _H_AS

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\al.h ===
//
// Application Loader
//

#ifndef _H_AL
#define _H_AL

//
//
// Includes
//
//
#include <om.h>


//
// THERE IS ONLY ONE CLIENT OF THE APP-LOADER:  OLD WHITEBOARD
//

#define AL_RETRY_DELAY                      100

#define AL_NEW_CALL_RETRY_COUNT             5



//
// Result codes passed in ALS_LOAD_RESULT events
//
typedef enum
{
    AL_LOAD_SUCCESS = 0,
    AL_LOAD_FAIL_NO_FP,
    AL_LOAD_FAIL_NO_EXE,
    AL_LOAD_FAIL_BAD_EXE,
    AL_LOAD_FAIL_LOW_MEM
}
AL_LOAD_RESULT;




//
//
// Application Loader OBMAN object used to communicate result of attempted
// loads
//
// szFunctionProfile : Function Profile being loaded
// personName      : Name of site that attempted the load
// result          : Result of attempted load
//
// NET PROTOCOL.  All network raw data structures, which CAN NOT CHANGE,
// are prefixed with TSHR_.
//
typedef struct tagTSHR_AL_LOAD_RESULT
{
    char        szFunctionProfile[OM_MAX_FP_NAME_LEN];
    char        personName[TSHR_MAX_PERSON_NAME_LEN];
    TSHR_UINT16 result;
    TSHR_UINT16 pad;
}
TSHR_AL_LOAD_RESULT;
typedef TSHR_AL_LOAD_RESULT * PTSHR_AL_LOAD_RESULT;





typedef struct tagAL_PRIMARY
{
    STRUCTURE_STAMP
    PUT_CLIENT          putTask;
    POM_CLIENT          pomClient;
    PCM_CLIENT          pcmClient;

    BOOL                eventProcRegistered:1;
    BOOL                exitProcRegistered:1;
    BOOL                inCall:1;
    BOOL                alWorksetOpen:1;
    BOOL                alWBRegPend:1;
    BOOL                alWBRegSuccess:1;

    // Call Info
    UINT                callID;

    OM_CORRELATOR       omWSGCorrelator;
    OM_CORRELATOR       omWSCorrelator;
    NET_UID             omUID;
    OM_WSGROUP_HANDLE   omWSGroupHandle;
    OM_WSGROUP_HANDLE   alWSGroupHandle;

    // Whiteboard Client
    PUT_CLIENT          putWB;
}
AL_PRIMARY;
typedef struct tagAL_PRIMARY * PAL_PRIMARY;


__inline void ValidateALP(PAL_PRIMARY palPrimary)
{
    ASSERT(!IsBadWritePtr(palPrimary, sizeof(AL_PRIMARY)));
}



//
//
// Application Loader Events
//
// Note: these events are defined relative to AL_BASE_EVENT and use the
//       range AL_BASE_EVENT to AL_BASE_EVENT + 0x7F.  The application
//       loader internally uses events in the range AL_BASE_EVENT+0x80 to
//       AL_BASE_EVENT+0xFF, so events in this range must not be defined
//       as part of the API.
//
//


enum
{
    ALS_LOCAL_LOAD = AL_BASE_EVENT,
    ALS_REMOTE_LOAD_RESULT,
    AL_INT_RETRY_NEW_CALL,
    AL_INT_STARTSTOP_WB
};



//
// ALS_LOAD_RESULT
//
// Overview:
//
//   This event informs a task of the result of an attempted load on a
//   remote machine.
//
// Parameters:
//
//   param_1 :      AL_LOAD_RESULT  reasonCode;
//   param_2 :      UINT            alPersonHandle;
//
//   reasonCode           : Result of attempt to load application
//
//   alPersonHandle       : Handle for the site that attempted the load
//                          (pass to ALS_GetPersonData() to get site name)
//
// Issued to:
//
//   Applications that have registered a function profile that has been
//   used by the Application Loader on a remote site.
//
// Circumstances when issued:
//
//   When the Application Loader on a remote site attempts to load an
//   application due to a new Function Profile object being added to a
//   call.
//
// Receivers response:
//
//   None
//
//



//
// AL_RETRY_NEW_CALL
//
// If AL fails to register with ObManControl on receipt of a CMS_NEW_CALL,
// it will in certain circumstances retry the registration after a short
// delay.  This is implemented by posting an AL_RETRY_NEW_CALL event back
// to itself.
//


//
// AL_INT_STARTSTOP_WB
//
// This starts/stops the old Whiteboard, which is now an MFC dll in CONF's
// process that creates/terminates a thread.  By having CONF itself start
// old WB through us, autolaunch and normal launch are synchronized.
//
// TEMP HACK:
// param1 == TRUE or FALSE (TRUE for new WB TEMP HACK!, FALSE for normal old WB)
// param2 == memory block (receiver must free) of file name to open
//



//
// PRIMARY functions
//


//
// ALP_Init()
// ALP_Term()
//
BOOL ALP_Init(BOOL * pfCleanup);
void ALP_Term(void);


BOOL CALLBACK ALPEventProc(LPVOID palPrimary, UINT event, UINT_PTR param1, UINT_PTR param2);
void CALLBACK ALPExitProc(LPVOID palPrimary);


void ALEndCall(PAL_PRIMARY palPrimary, UINT callID);

void ALNewCall(PAL_PRIMARY palPrimary, UINT retryCount, UINT callID);

BOOL ALWorksetNewInd(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup, OM_WORKSET_ID worksetID);

BOOL ALNewWorksetGroup(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup, POM_OBJECT pObj);

void ALWorksetRegisterCon(PAL_PRIMARY palPrimary, UINT correlator,
            UINT result, OM_WSGROUP_HANDLE hWSGroup);

BOOL ALRemoteLoadResult(PAL_PRIMARY palPrimary, OM_WSGROUP_HANDLE hWSGroup,
                                        POM_OBJECT  alObjHandle);

void ALLocalLoadResult(PAL_PRIMARY palPrimary, BOOL success);


//
// SECONDARY functions
//

void CALLBACK ALSExitProc(LPVOID palClient);

//
// Launching/activation of WB
// TEMP HACK FOR NEW WB!
//

BOOL ALStartStopWB(PAL_PRIMARY palPrimary, LPCTSTR szFile);
DWORD WINAPI OldWBThreadProc(LPVOID lpv);

//
// Start, Run, Cleanup routines
//
typedef BOOL (WINAPI * PFNINITWB)(void);
typedef void (WINAPI * PFNRUNWB)(void);
typedef void (WINAPI * PFNTERMWB)(void);


#endif // _H_AL

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\asmaster.h ===
#ifndef _ASMASTER_H_
#define _ASMASTER_H_




class ASMaster : public IAppSharing
{
    friend BOOL CALLBACK eventProc(LPVOID, UINT, UINT_PTR, UINT_PTR);

public:

	ASMaster(UINT flags, IAppSharingNotify * pNotify);
    ~ASMaster();

	//
	// IUnknown methods:
	//

    STDMETHOD(QueryInterface)(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

	//
	// IAppSharing methods:
	//

    //
    // Status
    //
    STDMETHODIMP_(BOOL) IsSharingAvailable();
    STDMETHODIMP_(BOOL) CanShareNow();
    STDMETHODIMP_(BOOL) IsInShare();
    STDMETHODIMP_(BOOL) IsSharing();
    STDMETHODIMP_(BOOL) IsWindowShareable(HWND hwnd);
    STDMETHODIMP_(BOOL) IsWindowShared(HWND hwnd);
    STDMETHODIMP_(BOOL) CanAllowControl();
    STDMETHODIMP_(BOOL) IsControllable();
    STDMETHODIMP GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus);

    // Share/Unshare this window
    STDMETHODIMP LaunchHostUI(void);
	STDMETHODIMP GetShareableApps(IAS_HWND_ARRAY **ppHwnds);
    STDMETHODIMP FreeShareableApps(IAS_HWND_ARRAY *pHwnds);
	STDMETHODIMP Share(HWND hwnd, IAS_SHARE_TYPE how);
	STDMETHODIMP Unshare(HWND hwnd);

    //
    // Control
    //

    // Viewer side
    STDMETHODIMP TakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP CancelTakeControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP ReleaseControl(IAS_GCC_ID PersonOf);
    STDMETHODIMP PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo);

    // Host side
    STDMETHODIMP AllowControl(BOOL fAllowed);
    STDMETHODIMP GiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP CancelGiveControl(IAS_GCC_ID PersonTo);
    STDMETHODIMP RevokeControl(IAS_GCC_ID PersonTo);

    STDMETHODIMP PauseControl(IAS_GCC_ID PersonInControl);
    STDMETHODIMP UnpauseControl(IAS_GCC_ID PersonInControl);

    //
    // Event notifications
    //
    BOOL        OnEvent(UINT event, UINT_PTR param1, UINT_PTR param2);

public:
    IAppSharingNotify * m_pNotify;

protected:
    LONG                m_cRefs;
};


// callbacks

BOOL CALLBACK eventProc(LPVOID, UINT, UINT, UINT);

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait);
HWND         IsForDialog(HWND hwnd);


#endif // ! _ASMASTER_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\awc.h ===
//
// AWC.H
// Active Window Coordinator
//
// Copyright(c) Microsoft 1997-
//

#ifndef _H_AWC
#define _H_AWC

//
//
// CONSTANTS
//
//

#define AWC_INVALID_HWND            ((HWND)1)
#define AWC_SYNC_MSG_TOKEN          0xffff


//
//
// MACROS
//
//

#define AWC_IS_INDICATION(msg) \
    ((msg == AWC_MSG_ACTIVE_CHANGE_LOCAL) ||      \
     (msg == AWC_MSG_ACTIVE_CHANGE_INVISIBLE) ||  \
     (msg == AWC_MSG_ACTIVE_CHANGE_CAPTURED) ||   \
     (msg == AWC_MSG_ACTIVE_CHANGE_SHARED))

#define AWC_IS_REQUEST(msg) \
    ((msg == AWC_MSG_ACTIVATE_WINDOW) ||        \
     (msg == AWC_MSG_RESTORE_WINDOW))


#endif // _H_AWC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\bmc.h ===
//
// BMC.H
// Bitmap Cache
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BMC
#define _H_BMC


//
// Bitmap caching order header
//
typedef struct tagBMC_ORDER_HDR
{
    TSHR_UINT8        bmcPacketType;
}
BMC_ORDER_HDR;
typedef BMC_ORDER_HDR FAR * PBMC_ORDER_HDR;


//
// Structure of data stored in DIB cache.
// The first few fields are variable and therefore not included in the
// cache hash.
//
#define BMC_DIB_NOT_HASHED   (FIELD_OFFSET(BMC_DIB_ENTRY, cx))
typedef struct tagBMC_DIB_ENTRY
{
    BYTE            inUse;
    BYTE            bCompressed;
    TSHR_UINT16     iCacheIndex;
    TSHR_UINT16     cx;
    TSHR_UINT16     cxFixed;
    TSHR_UINT16     cy;
    TSHR_UINT16     bpp;
    UINT            cCompressed;
    UINT            cBits;
    BYTE            bits[1];
}
BMC_DIB_ENTRY;
typedef BMC_DIB_ENTRY FAR * PBMC_DIB_ENTRY;


//
// DIB cache header
//
typedef struct tagBMC_DIB_CACHE
{
    PCHCACHE        handle;
    PBMC_DIB_ENTRY  freeEntry;
    LPBYTE          data;
    UINT            cEntries;
    UINT            cCellSize;
    UINT            cSize;
}
BMC_DIB_CACHE;
typedef BMC_DIB_CACHE * PBMC_DIB_CACHE;



//
// WE HAVE NO SMALL TILES ANYMORE
// Medium sized tiles must fit into a medium cell for the sending depth.
// Large sized tiles must fit into a large cell for the sending depth.
//
// Since true color sending can change dynamically, the easiest thing to do
// to cut down on memory usage is to check the capture depth.  If it's
// <= 8, then we can never send true color, so allocate for 8bpp.  Else
// allocate for 24bpp.
//

#define BYTES_IN_SCANLINE(width, bpp)   ((((width)*(bpp))+31)/32)*4

#define BYTES_IN_BITMAP(width, height, bpp)  (BYTES_IN_SCANLINE(width, bpp)*height)


__inline UINT  MaxBitmapHeight(UINT width, UINT bpp)
{
    UINT    bytesPerRow;

    //
    // If bpp is 4, there are width/2 bytes per Row
    // If bpp is 8, there are width bytes per Row
    // If bpp is 24, there are 3*width bytes per Row
    //
    bytesPerRow = BYTES_IN_SCANLINE(width, bpp);
    return((TSHR_MAX_SEND_PKT - sizeof(S20DATAPACKET) + sizeof(DATAPACKETHEADER)) / bytesPerRow);
}


//
// Define the cache identifiers which are transmitted in the hBitmap field
// of Memory->Screen blt orders.
//
// These are replaced by the receiver with their local (real) bitmap
// handle of the specified cache.
//
// Note that they are assumed to be contiguous with the smallest as 0
//
//
#define ID_SMALL_BMP_CACHE              0
#define ID_MEDIUM_BMP_CACHE             1
#define ID_LARGE_BMP_CACHE              2
#define NUM_BMP_CACHES                  3


//
// WHEN 2.X COMPAT IS GONE, WE CAN PLAY WITH THESE SIZES AT WILL.  But
// since the cell size (width * height * bpp) is negotiated when a 2.x
// node is in the share, we can not. Back level nodes assume a certain
// cell size.  So do new level nodes for now!
//

#define MP_SMALL_TILE_WIDTH             16
#define MP_SMALL_TILE_WIDTH             16
#define MP_MEDIUM_TILE_WIDTH            32
#define MP_MEDIUM_TILE_HEIGHT           32
#define MP_LARGE_TILE_WIDTH             64
#define MP_LARGE_TILE_HEIGHT            63


#define MP_CACHE_CELLSIZE(width, height, bpp)   \
    (BYTES_IN_BITMAP(width, height, bpp) + sizeof(BMC_DIB_ENTRY) - 1)


//
// Upper bound on the total cache memory we'll use (2 MB)
//
#define MP_MEMORY_MAX                   0x200000

#define COLORCACHEINDEX_NONE            0xFF

#define MEMBLT_CACHETABLE(pMemBlt) ((TSHR_UINT16)LOBYTE(pMemBlt->cacheId))
#define MEMBLT_COLORINDEX(pMemBlt) ((TSHR_UINT16)HIBYTE(pMemBlt->cacheId))
#define MEMBLT_COMBINEHANDLES(colort, bitmap)   ((TSHR_UINT16)MAKEWORD(bitmap, colort))


BOOL BMCAllocateCacheData(UINT numEntries, UINT cellSize, UINT cacheID,
        PBMC_DIB_CACHE pCache);
void BMCFreeCacheData(PBMC_DIB_CACHE pCache);


#endif // H_BMC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ch.h ===
//
// CH.H
// Cache Handler
// 
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CH
#define _H_CH


//
//
// DEFINES
//
//
#define CH_NUM_EVICTION_CATEGORIES  3

// 
// NOTES:
// 64K limit on cache
// CHCACHE includes one entry, so only subtract out header part
//
#define CH_MAX_CACHE_ENTRIES \
    ( (65535 - (sizeof(CHCACHE) - sizeof(CHENTRY))) / sizeof(CHENTRY) )


//
//
// TYPEDEFS
//
//


typedef struct tagCHCHAIN
{
    WORD    next;
    WORD    prev;
} CHCHAIN;
typedef CHCHAIN * PCHCHAIN;



//
// There are going to be thousands of cache entries so we need to keep
// the header as compact as possible.  We could drop the eviction
// category, but it is useful info and does round the entry to 16 bytes
// which makes indexing efficient.
//
// Note that the 16 bit code is restricted to 4096 entries unless we take
// steps to allow huge addressing of the entry array.
//


//
// CHENTRY
// Cache entry in a Cache tree
//
typedef struct tagCHENTRY
{
    struct tagCHENTRY * pParent;
    struct tagCHENTRY * pLeft;
    struct tagCHENTRY * pRight;
    WORD                lHeight;
    WORD                rHeight;
    UINT                cbData;
    LPBYTE              pData;
    UINT                checkSum;
    CHCHAIN             chain;
    WORD                evictionCategory;
    WORD                free;
} CHENTRY;
typedef CHENTRY * PCHENTRY;



//
// A CACHE
//

// FORWARD DECLARATION
typedef struct tagCHCACHE * PCHCACHE;

#ifdef __cplusplus

typedef void (* PFNCACHEDEL)(class ASHost * pHost, PCHCACHE pCache, UINT iEntry, LPBYTE pData);

//
// Each cache may have several eviction categories.  These allow the caller
// to define classes of data so that it can control what is evicted from
// the cache.  To be a candidate for eviction the eviction class of a LRU
// entry must match, unless the number of entries in that category is
// less than the eviction threshold, in which case any cache entry is
// up for grabs.
//
// The EvictionThreshold() function can be used to tune eviction thresholds
// which default to cEntries/cNumEvictionCategories
//

typedef struct tagCHCACHE
{
    STRUCTURE_STAMP

    PFNCACHEDEL     pfnCacheDel;
    UINT            cEntries;
    UINT            cNumEvictionCategories;
    UINT            cbNotHashed;

    //
    // NOTE:  CH_NUM_EVICTION_CATEGORIES is 3, so 3 words + 3 words +
    // 3 words == 9 words, not DWORD aligned.  Hence we stick the WORD
    // field free after iMRUTail.  If CH_NUM_EVICTION_CATEGORIES ever
    // changes to an even value, reshuffle this structure.
    // 
    WORD            cEvictThreshold[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUHead[CH_NUM_EVICTION_CATEGORIES];
    WORD            iMRUTail[CH_NUM_EVICTION_CATEGORIES];
    WORD            free;

    PCHENTRY        pRoot;
    PCHENTRY        pFirst;
    PCHENTRY        pLast;

    CHENTRY         Entry[1];
}
CHCACHE;
typedef CHCACHE * PCHCACHE;

#endif // __cplusplus


//
//
// MACROS
//
//

//
// BOGUS LAURABU
// In future, have debug signatures at front of objects to catch heap corruption
//

#define IsValidCache(pCache) \
    (!IsBadWritePtr((pCache), sizeof(CHCACHE)))

#define IsValidCacheEntry(pEntry) \
    (!IsBadWritePtr((pEntry), sizeof(CHENTRY)))

#define IsValidCacheIndex(pCache, iEntry) \
    ((iEntry >= 0) && (iEntry < (pCache)->cEntries))

#define IsCacheEntryInTree(pEntry) \
    (((pEntry)->lHeight != 0xFFFF) && ((pEntry)->rHeight != 0xFFFF))




#endif // _H_CH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ast120.h ===
//
// AppSharing T.120 Layer
//      * GCC (conference management)
//      * MCS (data)
//      * FLOW (data queuing, flow control)
//
// This is also used by ObMan for old Whiteboard, but old Whiteboard will
// disappear in the next version of NM.
//
// Copyright (c) Microsoft 1998-
//

#ifndef _H_AST120
#define _H_AST120

#include <confreg.h>

// REAL T.120 headers
#include <t120.h>
#include <igccapp.h>
#include <imcsapp.h>
#include <iappldr.h>
#include <mtgset.h>

//
// GCC PART
//

//
// Call Manager Secondaries
//
#define CMTASK_FIRST    0
typedef enum
{
    CMTASK_OM = CMTASK_FIRST,
    CMTASK_AL,
    CMTASK_DCS,
    CMTASK_WB,
    CMTASK_MAX
}
CMTASK;



//
// The GCC Application Registry Key.  This is used for enrolling Groupware
// with GCC and for assigning tokens: for all tokens the registration key
// is the Groupware application key followed by the specific tokenKey for
// this secondary.
//
// The MFGCODE portion of this key has been assigned by the ITU.
//
//     USACode1    0xb5
//     USACode2    0x00
//     MFGCode1    0x53
//     MFGCode2    0x4c
//     "Groupware" 0x02
//
// The length of the key in bytes including the NULLTERM.
//
//
#define GROUPWARE_GCC_APPLICATION_KEY     "\xb5\x00\x53\x4c\x02"





//
// Call Manager Events
//
enum
{
    CMS_NEW_CALL = CM_BASE_EVENT,
    CMS_END_CALL,
    CMS_PERSON_JOINED,
    CMS_PERSON_LEFT,
    CMS_CHANNEL_REGISTER_CONFIRM,
    CMS_TOKEN_ASSIGN_CONFIRM
};



//
// CM_STATUS
//
typedef struct tagCM_STATUS
{
    UINT_PTR            callID;
    UINT            peopleCount;
    BOOL            fTopProvider;
    UINT            topProviderID;
    NM30_MTG_PERMISSIONS attendeePermissions;

    TSHR_PERSONID   localHandle;
    char            localName[TSHR_MAX_PERSON_NAME_LEN];
}
CM_STATUS;
typedef CM_STATUS * PCM_STATUS;




//
// Secondary instance data
//
typedef struct tagCM_CLIENT
{
    STRUCTURE_STAMP
    PUT_CLIENT      putTask;
    CMTASK          taskType;
    UINT            useCount;

    // Registering Channel
    UINT            channelKey;

    // Assigning Token
    UINT            tokenKey;

    BOOL            exitProcRegistered:1;
}
CM_CLIENT;
typedef CM_CLIENT * PCM_CLIENT;



//
// Person element in linked list of people currently in conference
//
typedef struct tagCM_PERSON
{
    BASEDLIST           chain;
    TSHR_PERSONID       netID;
}
CM_PERSON;
typedef CM_PERSON * PCM_PERSON;



//
// Primary data
//
typedef struct tagCM_PRIMARY
{
    STRUCTURE_STAMP
    PUT_CLIENT          putTask;

    BOOL                exitProcRegistered;

    //
    // Secondary tasks
    //
    PCM_CLIENT          tasks[CMTASK_MAX];

    //
    // T.120/call state stuff
    //
    UINT_PTR            callID;
    BOOL                currentCall;
    BOOL                fTopProvider;

    BOOL                bGCCEnrolled;

    IGCCAppSap        * pIAppSap;
    UserID              gccUserID;
    UserID              gccTopProviderID;

    //
    // People conference stuff
    //
    char                localName[TSHR_MAX_PERSON_NAME_LEN];

    UINT                peopleCount;
    BASEDLIST           people;
}
CM_PRIMARY;
typedef CM_PRIMARY * PCM_PRIMARY;



__inline void ValidateCMP(PCM_PRIMARY pcmPrimary)
{
    ASSERT(!IsBadWritePtr(pcmPrimary, sizeof(CM_PRIMARY)));
    ASSERT(pcmPrimary->putTask);
}



__inline void ValidateCMS(PCM_CLIENT pcm)
{
    extern PCM_PRIMARY  g_pcmPrimary;

    ValidateCMP(g_pcmPrimary);

    ASSERT(!IsBadWritePtr(pcm, sizeof(CM_CLIENT)));
    ASSERT(pcm->putTask);

    ASSERT(pcm->taskType >= CMTASK_FIRST);
    ASSERT(pcm->taskType < CMTASK_MAX);
    ASSERT(g_pcmPrimary->tasks[pcm->taskType] == pcm);
}

//
// CM Primary Functions
//

BOOL CMP_Init(BOOL * pfCleanup);
void CMP_Term(void);

void CMPCallEnded(PCM_PRIMARY pcmPrimary);
void CMPBroadcast(PCM_PRIMARY pcmPrimary, UINT event, UINT param1, UINT_PTR param2);

void CALLBACK CMPExitProc(LPVOID pcmPrimary);


BOOL CMPGCCEnroll(PCM_PRIMARY pcmPrimary,
                  GCCConferenceID  conferenceID,
                  BOOL          fEnroll);

void CMPProcessPermitToEnroll(PCM_PRIMARY pcmPrimary,
                              GCCAppPermissionToEnrollInd FAR * pMsg);

void CMPProcessEnrollConfirm(PCM_PRIMARY pcmPrimary,
                             GCCAppEnrollConfirm FAR * pMsg);

void CMPProcessRegistryConfirm(PCM_PRIMARY pcmPrimary,
                               GCCMessageType         messageType,
                               GCCRegistryConfirm FAR * pMsg);

void CMPProcessAppRoster(PCM_PRIMARY pcmPrimary,
                         GCCConferenceID confID,
                         GCCApplicationRoster FAR * pAppRoster);

//
// Process GCC callbacks
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg FAR * pMsg);

void CMPBuildGCCRegistryKey(UINT dcgKeyNum, GCCRegistryKey FAR * pGCCKey, LPSTR dcgKeyStr);



//
// CM Secondary
//

BOOL CMS_Register(PUT_CLIENT putTask, CMTASK taskType, PCM_CLIENT * pCmHandle);
void CMS_Deregister(PCM_CLIENT * pCmHandle);

#ifdef __cplusplus
extern "C"
{
#endif
BOOL WINAPI CMS_GetStatus(PCM_STATUS pCmStats);
#ifdef __cplusplus
}
#endif

BOOL CMS_ChannelRegister(PCM_CLIENT pcmClient, UINT channelKey, UINT channelID);
BOOL CMS_AssignTokenId(PCM_CLIENT pcmClient, UINT tokenKey);

void CALLBACK CMSExitProc(LPVOID pcmClient);



//
// MCS PART
//


//
// Errors
//
enum
{
    // Generic errors
    NET_RC_NO_MEMORY                = NET_BASE_RC,
    NET_RC_INVALID_STATE,

    // S20 errors
    NET_RC_S20_FAIL,

    // MGC errors
    NET_RC_MGC_ALREADY_INITIALIZED,
    NET_RC_MGC_INVALID_USER_HANDLE,
    NET_RC_MGC_INVALID_LENGTH,
    NET_RC_MGC_INVALID_DOMAIN,
    NET_RC_MGC_TOO_MUCH_IN_USE,
    NET_RC_MGC_NOT_YOUR_BUFFER,
    NET_RC_MGC_LIST_FAIL,
    NET_RC_MGC_NOT_CONNECTED,
    NET_RC_MGC_NOT_SUPPORTED,
    NET_RC_MGC_NOT_INITIALIZED,
    NET_RC_MGC_INIT_FAIL,
    NET_RC_MGC_DOMAIN_IN_USE,
    NET_RC_MGC_NOT_ATTACHED,
    NET_RC_MGC_INVALID_CONN_HANDLE,
    NET_RC_MGC_INVALID_UP_DOWN_PARM,
    NET_RC_MGC_INVALID_REMOTE_ADDRESS,
    NET_RC_MGC_CALL_FAILED
};


//
// Results
//
typedef TSHR_UINT16     NET_RESULT;

enum
{
    NET_RESULT_OK   = 0,
    NET_RESULT_NOK,
    NET_RESULT_CHANNEL_UNAVAILABLE,
    NET_RESULT_DOMAIN_UNAVAILABLE,
    NET_RESULT_REJECTED,
    NET_RESULT_TOKEN_ALREADY_GRABBED,
    NET_RESULT_TOKEN_NOT_OWNED,
    NET_RESULT_NOT_SPECIFIED,
    NET_RESULT_UNKNOWN,
    NET_RESULT_USER_REJECTED
};


//
// Reaons
//
typedef enum
{
    NET_REASON_DOMAIN_DISCONNECTED = 1,
    NET_REASON_DOMAIN_UNAVAILABLE,
    NET_REASON_TOKEN_NONEXISTENT,
    NET_REASON_USER_REQUESTED,
    NET_REASON_CHANNEL_UNAVAILABLE,
    NET_REASON_UNKNOWN
}
NET_REASON;



//
// Events
//
enum
{
    NET_EVENT_USER_ATTACH = NET_BASE_EVENT,
    NET_EVENT_USER_DETACH,
    NET_EVENT_CHANNEL_JOIN,
    NET_EVENT_CHANNEL_LEAVE,
    NET_EVENT_TOKEN_GRAB,
    NET_EVENT_TOKEN_INHIBIT,
    NET_EVENT_DATA_RECEIVED,
    NET_FEEDBACK,
    NET_FLOW,
    NET_MG_SCHEDULE,
    NET_MG_WATCHDOG
};




//
// FOR MCS USERS (ALL APPS, INCLUDING CALL MANAGER)
//
//          state->|   0  |  1     |  2     |    3     |   4     |   5
//                 |CTRLR |CTRLR   |CTLR    |CTLR      |CTLR     |CTLR
//                 |state |state 2,|state2, |state2,   |state 3, |state 3
//                 | 0/1  |user not|user    |user      |user     |user
// verb/event      |      |attached|pending |attached  |attached |pending
//       |         |......|........|........|..........|.........|.........
//       V         |      |        |        |          |         |
// _get_buffer     |   X  |  X     |   X    |    -     |  **     |  X
// _free_buffer    |   X  |  X     |   X    |    -     |  -      |  -
// _realloc_bfr    |   X  |  X     |   X    |    -     |  -      |  -
// _attach_user    |   X  |  ->2   |   X    |    X     |  X      |  X
// _detach_user    |   X  |  X     |   X    |    ->1   |  ->0    |  X
// _channel_join   |   X  |  X     |   X    |    -     |  X      |  X
// _channel_leave  |   X  |  X     |   X    |    -     |  -      |  X
// _send_data      |   X  |  X     |   X    |    -     |  X      |  X
//                 |      |        |        |          |         |
// _STOP_CONTRLR*  |      |  ->0   |  ->5   |    ->4   |         |
//                 |      |        |        |          |         |
// _ATTACH_CNF OK  |      |        |  ->3   |          |         |  ->4
// _ATTACH_CNF FAIL|      |        |  ->1   |          |         |  ->0
// _DETACH_IND-SELF|      |        |  ->1   |   ->1    |  ->0    |
// _DETACH_IND-othr|      |        |        |    -     |  -      |
// _JOIN_CONFIRM   |      |        |        |    -     |  -      |
// _LEAVE_INDICAT  |      |        |        |    -     |  -      |
// _SEND_INDICAT   |      |        |        |    -     |  -      |
// =======================================================================
//
// NOTES ** when the controller is STOPPING the NET_GetBuffer
//          verb is valid but always returns a NULL buffer (no memory)
//
//       *  the STOP_CONTROLLER event is internally generated, and is
//          not seen across the API.  It is generated when the controller
//          issues the NET_StopController verb and causes the state change
//          (to state 0, 4 or 5) such that the NET_AttachUser,
//          ChannelJoin and NET_SendData verbs are rejected.
//
//
//



//
// Priorities
//
#define NET_INVALID_PRIORITY        ((NET_PRIORITY)-1)

enum
{
    NET_TOP_PRIORITY = 0,
    NET_HIGH_PRIORITY,
    NET_MEDIUM_PRIORITY,
    NET_LOW_PRIORITY,
    NET_NUM_PRIORITIES
};


//
// SFR6025: This flag is or-ed with the priority bit to indicate to the MCS
//          glue that it should send data on all channels.
//

//
// FOR OBMAN ONLY -- REMOVE IN NM 4.0
//
#define NET_SEND_ALL_PRIORITIES          0x8000






#define NET_ALL_REMOTES             ((NET_UID)1)
#define NET_INVALID_DOMAIN_ID       (0xFFFFFFFF)
#define NET_UNUSED_IDMCS            1





typedef TSHR_UINT16         NET_UID;            // MCS user IDs
typedef TSHR_UINT16         NET_CHANNEL_ID;     // MCS channel IDs
typedef TSHR_UINT16         NET_TOKEN_ID;       // MCS token IDs
typedef TSHR_UINT16         NET_PRIORITY;       // MCS priorities



//
// Forward decls of MGC structures
//
typedef struct tagMG_BUFFER *   PMG_BUFFER;
typedef struct tagMG_CLIENT *   PMG_CLIENT;


//
// Flow control structure - This contains the target latency (in mS) and
// stream size (in bytes) for each User Attachment
// lonchanc: used by S20, MG, and OM.
//
typedef struct tag_NET_FLOW_CONTROL
{
    UINT        latency[NET_NUM_PRIORITIES];
    UINT        streamSize[NET_NUM_PRIORITIES];
}
NET_FLOW_CONTROL, * PNET_FLOW_CONTROL;



//
// NET_EV_JOIN_CONFIRM and NET_EV_JOIN_CONFIRM_BY_KEY
// join_channel confirm:
// lonchanc: used by S20, MG, and OM.
//
typedef struct tagNET_JOIN_CNF_EVENT
{
    UINT_PTR                callID;

    NET_RESULT              result;      // NET_RESULT_USER_ACCEPTED/REJECTED
    TSHR_UINT16             pad1;

    NET_CHANNEL_ID          correlator;
    NET_CHANNEL_ID          channel;
}
NET_JOIN_CNF_EVENT;
typedef NET_JOIN_CNF_EVENT * PNET_JOIN_CNF_EVENT;


//
// NET_EV_SEND_INDICATION
// send data indication: see MG_SendData()
// Despite its name, this event indicates that data has been RECEIVED!
// lonchanc: used by MG and S20
//
typedef struct tag_NET_SEND_IND_EVENT
{
    UINT_PTR                callID;

    NET_PRIORITY            priority;
    NET_CHANNEL_ID          channel;

    UINT                    lengthOfData;
    LPBYTE                  data_ptr;      // Pointer to the real data.
}
NET_SEND_IND_EVENT;
typedef NET_SEND_IND_EVENT * PNET_SEND_IND_EVENT;



//
// MGC, FLOW CONTROL
//

//
// MG tasks
//
#define MGTASK_FIRST    0
typedef enum
{
    MGTASK_OM = MGTASK_FIRST,
    MGTASK_DCS,
    MGTASK_MAX
}
MGTASK;


//
// Buffer types
//
enum
{
    MG_TX_BUFFER = 1,
    MG_RX_BUFFER,
    MG_EV_BUFFER,
    MG_TX_PING,
    MG_TX_PONG,
    MG_TX_PANG,
    MG_RQ_CHANNEL_JOIN,
    MG_RQ_CHANNEL_JOIN_BY_KEY,
    MG_RQ_CHANNEL_LEAVE,
    MG_RQ_TOKEN_GRAB,
    MG_RQ_TOKEN_INHIBIT,
    MG_RQ_TOKEN_RELEASE
};


//
// Period of watchdog timer to detect lost connections
//
#define MG_TIMER_PERIOD                 1000


//
// MG priorities:
//
#define MG_HIGH_PRIORITY        NET_HIGH_PRIORITY
#define MG_MEDIUM_PRIORITY      NET_MEDIUM_PRIORITY
#define MG_LOW_PRIORITY         NET_LOW_PRIORITY

#define MG_PRIORITY_HIGHEST     MG_HIGH_PRIORITY
#define MG_PRIORITY_LOWEST      MG_LOW_PRIORITY
#define MG_NUM_PRIORITIES       (MG_PRIORITY_LOWEST - MG_PRIORITY_HIGHEST + 1)


//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NETPRIORITY_LOWEST.  Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set.  So, to validate a priority:
//  - knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
//  - set the valid raw prioririty to
//      NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//      NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//      the raw priority if it is in the valid range
//  - add the original ...ALL_PRIORITIES flag to the valid raw priority
//
#define MG_VALID_PRIORITY(p)                                                 \
    ((((p)&~NET_SEND_ALL_PRIORITIES)<MG_HIGH_PRIORITY)?                      \
      (MG_HIGH_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                      \
      (((p)&~NET_SEND_ALL_PRIORITIES)>MG_LOW_PRIORITY)?                      \
        (MG_LOW_PRIORITY|((p)&NET_SEND_ALL_PRIORITIES)):                     \
        (p))


//
//
// The initial stream size setting may appear high, but it is set so that
// in a LAN scenario we do not require the app to place a lot of forward
// pressure on the pipe before it opens up.  In a non-LAN scenario we may
// not do enough spoiling to start with, but in actual fact DCS tends
// to send less data than this limit anyway, so we should reduce it
// quite quickly without flooding the buffers.
//
#define FLO_INIT_STREAMSIZE     8000
#define FLO_MIN_STREAMSIZE       500
#define FLO_MAX_STREAMSIZE    256000
#define FLO_MIN_PINGTIME         100
#define FLO_INIT_PINGTIME       1000

//
// This is the max number of bytes that can be allocated per stream if a
// pong has not been received (i.e. FC is not operational).
//
#define FLO_MAX_PRE_FC_ALLOC   16000

//
// This is the max number of pkts outstanding before we apply back
// pressure:
//
#define FLO_MAX_RCV_PACKETS       5

//
// This is the max number of pkts outstanding before we get worried about
// creep:
//
#define FLO_MAX_RCV_PKTS_CREEP    250

//
// The maximum number of flow controlled streams.
//
#define FLO_MAX_STREAMS       128
#define FLO_NOT_CONTROLLED    FLO_MAX_STREAMS




//
// STRUCTURE : FLO_STREAM_DATA
//
// DESCRIPTION:
//
// This structure holds all the static data for a flow control stream
//
// FIELDS:
//
// channel
// priority
// pingValue         - Next ping value to be sent on the pipe
// eventNeeded       - We need to wake up the app because we have rejected
//                     a buffer allocation request
// backlog           - the allowable backlog in mS bejond which we apply
//                     back pressure
// pingNeeded        - Send a ping at the next opportunity
// pingTime          - Minimum time, in mS, between each ping
// gotPong           - Indicates we have received a pong from some remote
//                     party and so flow control can commence
// lastPingTime      - Time for last ping, in timer ticks
// nextPingTime      - Time for next ping, in timer ticks
// lastDenialTime    - Previous time (in ticks) that we started denying
//                     buffer requests
// curDenialTime     - Time in ticks that we most recently started denying
//                     buffer requests
// DC_ABSMaxBytesInPipe
//                   - Absolute maximum buffer allocation for this stream
// maxBytesInPipe    - Current buffer allocation limit
// bytesInPipe       - Current amount of data outstanding on this stream.
//                     This includes data currently waiting to be sent.
// users             - Base for queue of User correlators
// bytesAllocated    - The current amount of data in the glue for this
//                     stream which has not been sent. This is different
//                     to bytesInPipe which is the amount of unacknowledged
//                     data in this stream.
//
//
typedef struct tagFLO_STREAM_DATA
{
    STRUCTURE_STAMP

    NET_CHANNEL_ID      channel;
    WORD                gotPong:1;
    WORD                eventNeeded:1;
    WORD                pingNeeded:1;

    UINT                priority;
    UINT                pingValue;
    UINT                backlog;
    UINT                pingTime;
    UINT                lastPingTime;
    UINT                nextPingTime;
    UINT                lastDenialTime;
    UINT                curDenialTime;
    UINT                DC_ABSMaxBytesInPipe;
    UINT                maxBytesInPipe;
    UINT                bytesInPipe;
    UINT                bytesAllocated;

    BASEDLIST              users;
}
FLO_STREAM_DATA;
typedef FLO_STREAM_DATA * PFLO_STREAM_DATA;


void __inline ValidateFLOStr(PFLO_STREAM_DATA pStr)
{
    if (pStr != NULL)
    {
        ASSERT(!IsBadWritePtr(pStr, sizeof(FLO_STREAM_DATA)));
    }
}



//
// The FLO callback function
//
// A wakeup type callback indicates that a back pressure situation has
// been relieved.
//
// A buffermod callback indicates this as well, but also indicates that
// the buffer size for controlling flow on the designated channel/priority
// has changed.
//
#define FLO_WAKEUP     1
#define FLO_BUFFERMOD  2
typedef void (* PFLOCALLBACK)(PMG_CLIENT    pmgClient,
                                     UINT       callbackType,
                                     UINT       priority,
                                     UINT       newBufferSize);


//
// STRUCTURE : FLO_STATIC_DATA
//
// DESCRIPTION:
//
// This structure holds all the instance specific static data for the
// Flow Control DLL
//
// FIELDS:
//
// numStreams     - ID of the highest allocated stream
// rsvd           - reserved
// callback       - pointer to a callback function
// pStrData       - an array of FLO_STREAM_DATA pointers.
//
//
typedef struct FLO_STATIC_DATA
{
    UINT                numStreams;
    PFLOCALLBACK        callBack;
    PFLO_STREAM_DATA    pStrData[FLO_MAX_STREAMS];
}
FLO_STATIC_DATA;
typedef FLO_STATIC_DATA * PFLO_STATIC_DATA;



typedef struct FLO_USER
{
    BASEDLIST          list;

    STRUCTURE_STAMP

    WORD            userID;
    WORD            lastPongRcvd;
    WORD            pongNeeded;
    BYTE            sendPongID;
    BYTE            pad1;

    UINT            sentPongTime;    // Time we actually sent the pong
    WORD            rxPackets;       // Count of packets outstanding
    WORD            gotPong;         // Indicates this user has ponged
                                        // and they are permitted to apply
                                        // back pressure to our sends
    UINT            numPongs;        // total number of pongs from user
    UINT            pongDelay;       // total latency across pongs
}
FLO_USER;
typedef FLO_USER * PFLO_USER;


void __inline ValidateFLOUser(PFLO_USER pFloUser)
{
    ASSERT(!IsBadWritePtr(pFloUser, sizeof(FLO_USER)));
}


//
// Maximum wait time before assuming a user is offline
// We need to keep this high until the apps become "well behaved" and
// respond to the flow control buffer size recommendations.
//
#define FLO_MAX_WAIT_TIME     20000



//
//
// Client Control Block
//
//

typedef struct tagMG_CLIENT
{
    PUT_CLIENT      putTask;
    PCM_CLIENT      pcmClient;

    BASEDLIST       buffers;       // list of children buffers
    BASEDLIST       pendChain;     // Chain of pending request from client
    BASEDLIST       joinChain;     // Chain of pending join-by-key requests

    //
    // MCS user attachment info
    //
    PIMCSSap      	m_piMCSSap;       // user interface ptr returned by MCS
    UserID          userIDMCS;        // user ID returned by MCS
    FLO_STATIC_DATA flo;              // flow control structure


    WORD            eventProcReg:1;
    WORD            lowEventProcReg:1;
    WORD            exitProcReg:1;
    WORD            joinPending:1;   // Is there a channel join outstanding ?
    WORD            userAttached:1;

    WORD            joinNextCorr;

    NET_FLOW_CONTROL flowControl;  // flow control latency/backlog params
}
MG_CLIENT;


void __inline ValidateMGClient(PMG_CLIENT pmgc)
{
    ASSERT(!IsBadWritePtr(pmgc, sizeof(MG_CLIENT)));
    ValidateUTClient(pmgc->putTask);
}



typedef struct tagMG_INT_PKT_HEADER
{
    TSHR_UINT16         useCount;   // The use count of this packet.  This
                                    //   is required for sending the same
                                    //   data on multiple channels.

    TSHR_NET_PKT_HEADER header;
}
MG_INT_PKT_HEADER;
typedef MG_INT_PKT_HEADER * PMG_INT_PKT_HEADER;




//
//
// Buffer Control Block
//
//
typedef struct tagMG_BUFFER
{
    STRUCTURE_STAMP

    UINT                type;

    BASEDLIST           pendChain;      // Used when the buffer is added to the
    BASEDLIST           clientChain;

    PMG_INT_PKT_HEADER  pPktHeader;     // Pointer to MCS control info
    void *              pDataBuffer;    // Pointer passed to apps
    UINT                length;         // length of the associated packet

    ChannelID           channelId;      // Send destination, or token grab req
    ChannelID           channelKey;

    UserID              senderId;
    NET_PRIORITY        priority;

    BOOL                eventPosted;
    UINT                work;           // work field for misc use

    PFLO_STREAM_DATA    pStr;           // Pointer to the FC stream
}
MG_BUFFER;


void __inline ValidateMGBuffer(PMG_BUFFER pmgb)
{
    ASSERT(!IsBadWritePtr(pmgb, sizeof(MG_BUFFER)));
}


//
//
//
// MACROS
//
//
//

//
// MCS priority validation.
// Priorities are contiguous numbers in the range NET_PRIORITY_HIGHEST..
// NET_PRIORITY_LOWEST. Priorities supplied to MG may also have the
// NET_SEND_ALL_PRIORITIES flag set. So, to validate a priority:
// -  knock off the NET_SEND_ALL_PRIORITIES flag to give the raw priority
// -  set the valid raw priority to
//   -  NET_PRIORITY_HIGHEST if the raw priority is less than ...ITY_HIGHEST
//   -  NET_PRIORITY_LOWEST if the raw priority is more than ...ITY_LOWEST
//   -  the raw priority if it is in the valid range
// -  add the original ...ALL_PRIORITIES flag to the valid raw priority.
//


//
//
//
// FUNCTION PROTOTYPES
//
//
//

//
//
//  MGLongStopHandler(...)
//
// This function is registered as a low priority event handler for each
// client.  It catches any unprocessed network events and frees any
// associated memory.
//
//
BOOL CALLBACK MGLongStopHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);

//
//
//  MGEventHandler(...)
//
// This function is registered as a high priority event handler for the
// processing of MG_ChannelJoinByKey, MCS request handling and scheduling.
// It catches NET channel join confirm and CMS register channel confirm
// events, and massages them into the correct return events for the app.
// It queues requests coming from the app context into the glue context
// and schedules queued requests.
//
//
BOOL CALLBACK MGEventHandler(LPVOID pmgClient, UINT event, UINT_PTR param1, UINT_PTR param2);


//
UINT MGHandleSendInd(PMG_CLIENT pmgClient, PSendData pSendInfo);



//
//
//  MGNewBuffer(...)
//  NewTxBuffer(...)
//  NewRxBuffer(...)
//  FreeBuffer(...)
//
// The New function allocates and initialises a buffer , allocates buffer
// memory of the specified size and type and adds the  to the client's
// list of buffer s.
//
// The Tx version performs flow control on the buffer allocation request
// The Rx version just allocates a receive buffer
//
// The Free function discards a buffer , discards the associated buffer
// memory, decrements the client's count of memory in use and removes the
//  from the client's list of buffer s.
//
//

void MGNewCorrelator(PMG_CLIENT ppmgClient, WORD * pCorrelator);

UINT MGNewBuffer(PMG_CLIENT pmgClient, UINT typeOfBuffer,
                                PMG_BUFFER     * ppBuffer);

UINT MGNewDataBuffer(PMG_CLIENT           pmgClient,
                                  UINT                typeOfBuffer,
                                  UINT                sizeOfBuffer,
                                  PMG_BUFFER     * ppBuffer);

UINT MGNewTxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                UINT              sizeOfBuffer,
                                PMG_BUFFER   * ppBuffer);

UINT MGNewRxBuffer(PMG_CLIENT         pmgClient,
                                NET_PRIORITY          priority,
                                NET_CHANNEL_ID        channel,
                                NET_CHANNEL_ID        senderID,
                                PMG_BUFFER   		* ppBuffer);

void MGFreeBuffer(PMG_CLIENT pmgClient, PMG_BUFFER  * ppBuffer);


//
//
//  MGProcessDomainWatchdog(...)
//
// Handle domain watchdog timer ticks.
//
//
void MGProcessDomainWatchdog(PMG_CLIENT pmgClient);

void MGProcessEndFlow(PMG_CLIENT pmgClient, ChannelID channel);

UINT MGPostJoinConfirm(PMG_CLIENT pmgClient,
                                    NET_RESULT      result,
                                    NET_CHANNEL_ID  channel,
                                    NET_CHANNEL_ID  correlator);



NET_RESULT TranslateResult(WORD Result);


//
//
//  MGFLOCallBack(...)
//
// Callback poked by flow control to trigger the app to retry buffer
// requests thet were previously rejected
//
//
void        MGFLOCallBack(PMG_CLIENT    pmgClient,
                                  UINT      callbackType,
                                  UINT      priority,
                                  UINT      newBufferSize);




//
//
//  MGProcessPendingQueue(...)
//
// Called whenever MG wants to try and execute pending requests.  Requests
// are queued because they may fail for a transient reason, such as MCS
// buffer shortage.
//
//
UINT MGProcessPendingQueue(PMG_CLIENT pmgClient);




BOOL    MG_Register(MGTASK task, PMG_CLIENT * pmgClient, PUT_CLIENT putTask);
void    MG_Deregister(PMG_CLIENT * ppmgClient);

void CALLBACK MGExitProc(LPVOID uData);






UINT  MG_Attach(PMG_CLIENT pmgClient,  UINT_PTR callID, PNET_FLOW_CONTROL pFlowControl);
void  MG_Detach(PMG_CLIENT pmgClient);
void  MGDetach(PMG_CLIENT pmgClient);



UINT MG_ChannelJoin(PMG_CLIENT pmgClient, NET_CHANNEL_ID * pCorrelator,
                                        NET_CHANNEL_ID  channel);

UINT MG_ChannelJoinByKey(PMG_CLIENT pmgClient,
                                             NET_CHANNEL_ID * pCorrelator,
                                             WORD          channelKey);

void MG_ChannelLeave(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel);


UINT MG_GetBuffer(PMG_CLIENT pmgClient, UINT length,
                                      NET_PRIORITY   priority,
                                      NET_CHANNEL_ID channel,
                                      void **       buffer);

void MG_FreeBuffer(PMG_CLIENT pmgClient,
                                       void **      buffer);

UINT MG_SendData(PMG_CLIENT pmgClient,
                                     NET_PRIORITY   priority,
                                     NET_CHANNEL_ID channel,
                                     UINT       length,
                                     void **       data);

UINT  MG_TokenGrab(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

UINT  MG_TokenInhibit(PMG_CLIENT pmgClient, NET_TOKEN_ID token);

void MG_FlowControlStart(PMG_CLIENT  pmgClient,
                                          NET_CHANNEL_ID channel,
                                          NET_PRIORITY   priority,
                                          UINT       backlog,
                                          UINT       maxBytesOutstanding);

//
// API FUNCTION: FLO_UserTerm
//
// DESCRIPTION:
//
// Called by an application to end flow control on all the channels
// associated with a particular user.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
//
// RETURNS: Nothing.
//
//
void FLO_UserTerm(PMG_CLIENT pmgClient);



//
// API FUNCTION: FLO_StartControl
//
// DESCRIPTION:
//
// The application calls this function whenever it wants a data stream to
// be flow controlled
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// channel - channel id of channel to be flow controlled
// priority - priority of the stream to be controlled
// backlog - the maximum backlog (in mS) allowed for this stream
// maxBytesOutstanding - the maximum number of bytes allowed in the stream
//                       irrespective of the backlog.  0 = use default of
//                       64 KBytes
//
// RETURNS:
// None
//
//
void FLO_StartControl(PMG_CLIENT    pmgClient,
                              NET_CHANNEL_ID channel,
                              UINT       priority,
                              UINT       backlog,
                              UINT       maxBytesOutstanding);


void FLO_EndControl
(
    PMG_CLIENT      pmgClient,
    NET_CHANNEL_ID  channel,
    UINT            priority
);

//
// API FUNCTION: FLO_AllocSend
//
// DESCRIPTION:
//
// The application is requesting a buffer in order to send a packet.  This
// may trigger a flow control packet in advance of the application packet.
// Flow control may choose to reject the packet with NET_OUT_OF_RESOURCE in
// which case the application must reschedule the allocation at a ater
// date.  To assist the rescheduling, if ever a send is rejected then flow
// control will call the application callback to trigger the reschedule.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     priority - The priority for this buffer
//     channel  - The channnel on which to send the packet
//     size     - The size of the packet
//     ppStr    - Pointer to the pointer to the FC stream. This is a
//                return value.
//
//
UINT FLO_AllocSend(PMG_CLIENT   pmgClient,
                             UINT               priority,
                             NET_CHANNEL_ID         channel,
                             UINT               size,
                             PFLO_STREAM_DATA * ppStr);

//
// API FUNCTION: FLO_ReallocSend
//
// DESCRIPTION:
//
// The application has requested that the glue send a packet, but the
// packet contains less data than originally requested.
// Flow control heuristics get thrown out unless we logically free the
// unused portion of the packet for reuse for other allocations.
// If we didn't do this then we might see a 8K packet, for example,
// complete in 1 second because the app only put 1K of data in it.
//
// PARAMETERS:
//
//     pUser  - MCS Glue User attachment
//     pStr     - The flow control stream to be corrected
//     size     - The size of the packet that has been unused
//
// RETURNS:
//
// None
//
//
void FLO_ReallocSend(PMG_CLIENT pmgClient,
                             PFLO_STREAM_DATA       pStr,
                             UINT               size);

//
// API FUNCTION: FLO_DecrementAlloc
//
// DESCRIPTION:
//
// This function decrements the bytesAllocated count for a given stream.
// It is called whenever a packet is sent or removed from the send chain.
//
// PARAMETERS:
//
//     pStr     - The flow control stream to be decremented
//     size     - The size to decrement
//
// RETURNS:
//
// None
//
//
void FLO_DecrementAlloc(      PFLO_STREAM_DATA       pStr,
                                UINT               size);

//
// API FUNCTION: FLO_ReceivedPacket
//
// DESCRIPTION:
//
// Upon receipt of a flow control packet the MCS glue calls this function
// and then ignores the packet.
//
// PARAMETERS:
//
// pUser  - MCS Glue User attachment
// pPkt     - pointer to the packet, for FLO to process
//
// RETURNS:
//
// None
//
//
void FLO_ReceivedPacket(PMG_CLIENT pmgClient, PTSHR_FLO_CONTROL pPkt);


//
// API FUNCTION: FLO_AllocReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer is now in use by the application
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attacgment cb
// priority
// channel
// size        - size of the buffer just been allocated
//
// RETURNS:
//
// None
//
//
void FLO_AllocReceive(PMG_CLIENT         pmgClient,
                              UINT       priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_FreeReceive
//
// DESCRIPTION:
//
// Called to indicate that a receive buffer has ben handed back by the
// application.
//
// PARAMETERS:
//
// pmg         - pointer to the glue user attachment cb
// priority
// channel
// size        - size of the buffer just been freed
//
// RETURNS:
//
// None
//
//
void FLO_FreeReceive(PMG_CLIENT    pmgClient,
                              NET_PRIORITY priority,
                              NET_CHANNEL_ID channel,
                              UINT       senderID);

//
// API FUNCTION: FLO_CheckUsers
//
// DESCRIPTION:
//
// Called periodically by each client to allow flow control to determine if
// remote users have left the channel
//
// PARAMETERS:
//
// pmg - pointer to the user
//
// RETURNS:
//
// None
//
//
void FLO_CheckUsers(PMG_CLIENT pmgClient);

//
// FLOGetStream()
//
UINT FLOGetStream(PMG_CLIENT pmgClient, NET_CHANNEL_ID channel, UINT priority,
        PFLO_STREAM_DATA * ppStr);


void FLOStreamEndControl(PMG_CLIENT pmgClient, UINT stream);

void FLOPing(PMG_CLIENT pmgClient, UINT stream, UINT curtime);
void FLOPang(PMG_CLIENT pmgClient, UINT stream, UINT userID);
void FLOPong(PMG_CLIENT pmgClient, UINT stream, UINT userID, UINT pongID);


//
// API FUNCTION: FLOAddUser
//
// DESCRIPTION:
//
// Add a user to a flow controlled stream
//
// PARAMETERS:
//
// userID - ID of the new user (single member channel ID)
// pStr - pointer to the stream to receive the new user
//
// RETURNS:
//
// None
//
//
PFLO_USER FLOAddUser(UINT         userID,
                                PFLO_STREAM_DATA pStr);

//
// API FUNCTION: FLO_RemoveUser
//
// DESCRIPTION:
//
// Remove a user from a flow controlled stream
//
// PARAMETERS:
//
// pmg - pointer to the MCS glue user
// userID - ID of the bad user (single member channel ID)
//
// RETURNS:
//
// None
//
//
void FLO_RemoveUser(PMG_CLIENT pmgClient, UINT userID);



//
// FUNCTION: MGCallback
//
// DESCRIPTION:
//
// This function is the callback passed to MCS.  The glue layer receives
// all communication from MCS via this function.  It converts MCS messages
// into DC-Groupware events and posts them to the relevant client(s).
//
//
void CALLBACK MGCallback( unsigned int       mcsMessageType,
                          UINT_PTR      eventData,
                          UINT_PTR      pUser );


#endif // _H_AST120

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\bcd.h ===
//
// BCD.H
// Bitmap Compression & Decompression
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_BCD
#define _H_BCD



#define BCD_MATCHCOUNT      8192
#define BCD_NORMALSIZE      65000
#define BCD_XORSIZE         65000


//
// VERSION 2 RLE codes
//
//
// The following codes fill a full single byte address space.  The approach
// is to use the high order bits to identify the code type and the low
// order bits to encode the length of the associated run.  There are two
// forms of order
// - regular orders which have a 5 bit length field (31 bytes of data)
// - "lite" orders with a 4 bit length
//
// A value of 0 in the length field indicates an extended length, where
// the following byte contains the length of the data.  There is also a
// "mega mega" form which has a two byte length field. (See end of
// codespace of the codes that define the megamega form).
//
// A set of codes at the high end of the address space is used to encode
// commonly occuring short sequences, in particular
// - certain single byte FGBG codings
// - single bytes of BLACK and WHITE
//
//
// SUMMARY
// *******
//                      7 6 5 4 3 2 1 0  76543210  76543210  76543210
//
// MEGA_BG_RUN          0 0 0 0 0 0 0 0  <length>
//
// BG_RUN               0 0 0 <length->
//
// MEGA_FG_RUN          0 0 1 0 0 0 0 0  <length>
//
// FG_RUN               0 0 1 <length->
//
// MEGA_FG_BG_IMAGE     0 1 0 0 0 0 0 0  <length>  <-data->  ...
//
// FG_BG_IMAGE          0 1 0 <length->  <-data->  ...
//
// MEGA_COLOR_RUN       0 1 1 0 0 0 0 0  <length>  <-color>
//
// COLOR_RUN            0 1 1 <length->  <color->
//
// MEGA_COLOR_IMAGE     1 0 0 0 0 0 0 0  <length>  <-data->  ...
//
// COLOR_IMAGE          1 0 0 <length->  <-data->  ...
//
// MEGA_PACKED_CLR_IMG  1 0 1 0 0 0 0 0  <length>  <-data->  ...
//
// PACKED COLOR IMAGE   1 0 1 <length->  <-data->  ...
//
// SET_FG_MEGA_FG_RUN   1 1 0 0 0 0 0 0  <length>  <-color>
//
// SET_FG_FG_RUN        1 1 0 0 <-len->  <color->
//
// SET_FG_MEGA_FG_BG    1 1 0 1 0 0 0 0  <length>  <-color>  <-data->  ...
//
// SET_FG_FG_BG         1 1 0 1 <-len->  <color->  <-data->  ...
//
// MEGA_DITHERED_RUN    1 1 1 0 0 0 0 0  <length>  <-data->  <-data->
//
// DITHERED_RUN         1 1 1 0 <-len->  <-data->  <-data->
//
// MEGA_MEGA_BG_RUN     1 1 1 1 0 0 0 0
//
// MEGA_MEGA_FG_RUN     1 1 1 1 0 0 0 1
//
// MEGA_MEGA_FGBG       1 1 1 1 0 0 1 0
//
// MEGA_MEGA_COLOR_RUN  1 1 1 1 0 0 1 1
//
// MEGA_MEGA_CLR_IMG    1 1 1 1 0 1 0 0
//
// MEGA_MEGA_PACKED_CLR 1 1 1 1 0 1 0 1
//
// MEGA_MEGA_SET_FG_RUN 1 1 1 1 0 1 1 0
//
// MEGA_MEGA_SET_FGBG   1 1 1 1 0 1 1 1
//
// MEGA_MEGA_DITHER     1 1 1 1 1 0 0 0
//
// Special FGBG code 1  1 1 1 1 1 0 0 1  FGBG code 0x03 = 11000000
// (Note that 0x01 will generally handled by the single pel insertion code)
//
// Special FBBG code 2  1 1 1 1 1 0 1 0  FGBG code 0x05 = 10100000
//
// Special FBBG code 3  1 1 1 1 1 0 1 1  FGBG code 0x07 = 11100000
//
// Special FBBG code 4  1 1 1 1 1 1 0 0  FGBG code 0x0F = 11110000
//
// BLACK                1 1 1 1 1 1 0 1
//
// WHITE                1 1 1 1 1 1 1 0
//
// START_LOSSY          1 1 1 1 1 1 1 1
//
//
//
// GENERAL NOTES
//
//
// - For MEGA runs the length encoded is the length of the run minus the
//   maximum length of the non-mega form.
//   In  the mega-mega form we encode the plain 16 bit length, to keep
//   encoding/deconding simple.
//
// - The sequence BG_RUN,BG_RUN is not exactly what it appears.  We
//   use the fact that this is not generated in normal encoding to
//   encode <n background><1 foreground><n background>.  The same pel
//   insertion convention applies to any combination of MEGA_BG run and
//   BG_RUN
//
// - A packed image is encoded when we find that all the color fields in a
//   run have 0 in the high order nibble. We do not currently use this code
//   for 8 bit compression, but it is supported by the V2 decoder.
//
// - The set fg color code (Used to exist in V1) has been retired in favor
//   of separate commands for those codes that may embed a color.  Generally
//   This saves one byte for every foreground color transition for 8bpp.
//
// - The color run code is new for V2.  It indicates a color run where the
//   XOR is not performed.  This applies to, for example, the line of bits
//   immediately below a text line.  (There is no special case for runs of
//   the bg color - these are treated as any other color run.)
//
// - Observation shows a high occurrence of BG runs split by single FGBG
//   codes.  In decreasing probability these are 3,5,7,9,f,11,1f,3f (1 is
//   handled by the implicit BG run break). Save 1 byte by encoding as
//   single codes
//
// - There is a relatively high occurrence of single pel color codes ff and
//   00.  Save 1 byte by encoding as special characters
//
// - The length in a FGBG run is slightly strange.  Because they generally
//   occur in multiples of 8 bytes we get a big saving if we encode the
//   length of a short run as length/8.  However, for those special
//   cases where the length is not a multiple of 8 we encode a long run.
//   Therefore the long form can only cover the range 1-256 bytes.
//   beyond that we use the mega-mega form.
//
//
// DETAILS OF COMPRESSION CODES
//
//
// BG_RUN
//
// Represents a background run (black:0) of the specified length.
//
//
//
// FG_BG_IMAGE/SET_FG_FG_BG_IMAGE
//
// Represents a binary image containing only the current foreground(1) and
// background(0) colors.
//
//
//
// FG_RUN/SET_FG_FG_RUN
//
// Represents a continuous foreground run of the specified length.
// The foreground color is white by default, and is changed by the
// SET_FG_FG_RUN version of this code.
//
//
//
// DITHERED_RUN
//
// Represents a run of alternating colors of the specified length.
//
//
//
// COLOR_IMAGE
//
// Represents a color image of the specified length.  No XOR is performed.
// This data is uncompressed, so we hope that we won't see
// many of these codes!
//
//
//
// COLOR_RUN
//
// Represents a color run of the specified length.  No XOR is performed.
// Since the color is not XORed, it is unlikely to match the running
// foreground color information.  Therefore this code always carries a
// color byte and there is no SET_FG_COLOR_RUN form of the code.
//
//
//
// PACKED_COLOR_IMAGE
//
// Represents a color image of the specified length, with pairs of colors
// packed into a single byte.  (This can only be done when the color info
// is zero in the high order nibble.)
//
//
//
// START_LOSSY
//
// Informs the decoder that lossy mode has been established and any of the
// following color runs will need pixel doubling performing.
// RLE decoding will remain in this mode until the end of this block
//
//

#define CODE_MASK                   0xE0
#define CODE_MASK_LITE              0xF0

#define CODE_BG_RUN                 0x00   // 20
#define CODE_FG_RUN                 0x20   // 20
#define CODE_FG_BG_IMAGE            0x40   // 20
#define CODE_COLOR_RUN              0x60   // 20
#define CODE_COLOR_IMAGE            0x80   // 20
#define CODE_PACKED_COLOR_IMAGE     0xA0   // 20
#define CODE_SET_FG_FG_RUN          0xC0   // 10
#define CODE_SET_FG_FG_BG           0xD0   // 10
#define CODE_DITHERED_RUN           0xE0   // 10
#define CODE_MEGA_MEGA_BG_RUN       0xF0
#define CODE_MEGA_MEGA_FG_RUN       0xF1
#define CODE_MEGA_MEGA_FGBG         0xF2
#define CODE_MEGA_MEGA_COLOR_RUN    0xF3
#define CODE_MEGA_MEGA_CLR_IMG      0xF4
#define CODE_MEGA_MEGA_PACKED_CLR   0xF5
#define CODE_MEGA_MEGA_SET_FG_RUN   0xF6
#define CODE_MEGA_MEGA_SET_FGBG     0xF7
#define CODE_MEGA_MEGA_DITHER       0xF8
#define CODE_SPECIAL_FGBG_1         0xF9
#define CODE_SPECIAL_FGBG_2         0xFA
#define CODE_SPECIAL_FGBG_3         0xFB
#define CODE_SPECIAL_FGBG_4         0xFC
#define CODE_WHITE                  0xFD
#define CODE_BLACK                  0xFE
#define CODE_START_LOSSY            0xFF

#define MAX_LENGTH_ORDER            31
#define MAX_LENGTH_LONG_ORDER       287

#define MAX_LENGTH_ORDER_LITE       15
#define MAX_LENGTH_LONG_ORDER_LITE  271

#define MAX_LENGTH_FGBG_ORDER       (31*8)
#define MAX_LENGTH_FGBG_ORDER_LITE  (15*8)
#define MAX_LENGTH_LONG_FGBG_ORDER  255

//
// The special FGBG codes that correspond to codes F0-F7
//
#define SPECIAL_FGBG_CODE_1         0x03
#define SPECIAL_FGBG_CODE_2         0x05
#define SPECIAL_FGBG_CODE_3         0x07
#define SPECIAL_FGBG_CODE_4         0x0F

//
// Run types as stored in the run index array
//
#define RUN_BG                      1
#define RUN_BG_PEL                  2
#define RUN_FG                      3
#define RUN_COLOR                   4
#define RUN_DITHER                  5
#define IMAGE_FGBG                  6
#define IMAGE_COLOR                 7
#define IMAGE_LOSSY_ODD             8


//
// The following structure contains the results of our intermediate scan of
// the buffer.  The offset field contains the expected offset into the
// target buffer following decompression of the associated order and is
// used for self-diagnosis.
//
typedef struct
{
    WORD    length;
    BYTE    type;
    BYTE    fgChar;
}
MATCH;



//
// Function Prototypes
//
// Note that the function compresses the whole bitmap in one call.  However
// it performs two cycles internally, once for the first line and once for
// all subsequent lines.  pelsPerLine (the number of pels on a row) MUST be
// supplied.
//
// The paremeters should be obvious, save
//
// pLossy = pointer to flag indicating we maydiscard part of incompressible
//          data
//
// When lossy compression is enabled any color run carries only half the
// pels and they must be doubled up.  (Also the encoder replaces color on
// alternate lines with BG_RUN thus giving a fourfold reduction in the
// data, but the decoder does not need any special code to handle this).
//
// The encoder may decide not to honor the lossy request because the data
// is highly compressible anyway.  If it determines this then the lossy
// flag is reset so that the caller may determine whether a subsequent
// non-lossy transmission is required or not.
//
//


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void Unpack4bpp(LPBYTE destbuf,
                             LPBYTE srcbuf,
                             UINT   srclen);

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void Pack4bpp(LPBYTE destbuf,
                           LPBYTE srcbuf,
                           UINT   srclen);

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
void XORBuffer(LPBYTE destbuf, LPBYTE srcbuf, UINT srclen, int rowDelta);

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   numPels,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  UINT   dstBufferSize,
                                  LPBOOL pLossy,
                                  LPBYTE nrmbuf,
                                  LPBYTE xorbuf,
                                  MATCH  FAR  *match);

UINT    DecompressV2Int(LPBYTE pSrc,
                                  LPBYTE pDst,
                                  UINT   bytes,
                                  UINT   bpp,
                                  UINT   rowDelta,
                                  LPBYTE nrmbuf);



//
// The Compressed Data header structure.
//
// Rather than add a field to indicate V1 vs V2 compression we use the
// fact that V2 compression treats all the bitmap as main body and sets
// the first row size to zero to distinguish them.  I hesitate to do this
// but any bandwidth saving is important.
//
typedef struct _CD_HEADER
{
    TSHR_UINT16     cbCompFirstRowSize;
    TSHR_UINT16     cbCompMainBodySize;
    TSHR_UINT16     cbScanWidth;
    TSHR_UINT16     cbUncompressedSize;
} CD_HEADER;
typedef CD_HEADER *PCD_HEADER;

#define IsV2CompressedDataHeader(p)  ((p)->cbCompFirstRowSize == 0)
#define SetV2CompressedDataHeader(p) ((p)->cbCompFirstRowSize = 0)


//
// Types of bitmap compression.
//
#ifdef _DEBUG // for assertion
#define RLE_V1     1
#endif
#define RLE_V2     2



//
//
// PROTOTYPES
//
//


#endif // _H_BCD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ba.h ===
//
// Bounds Accumulation
//

#ifndef _H_BA
#define _H_BA


//
// Number of rectangles used by the SDA.
// NOTE:  You can play around with this setting, building the core & the 
// display driver.  Bumping it up means finer update areas, bumping it down
// means more rect blobs of data.
//
#define BA_NUM_RECTS      10
#define BA_INVALID_RECT_INDEX ((UINT)-1)


//
// Values for OSI escape codes
//
#define BA_ESC(code)            (OSI_BA_ESC_FIRST + code)

#define BA_ESC_GET_BOUNDS       BA_ESC(0)
#define BA_ESC_RETURN_BOUNDS    BA_ESC(1)


//
//
// MACROS
//
//

//
// Macros to access the fast swapping shared memory.
//
#ifdef DLL_DISP

#define BA_FST_START_WRITING    SHM_StartAccess(SHM_BA_FAST)
#define BA_FST_STOP_WRITING     SHM_StopAccess(SHM_BA_FAST)


#else


#define BA_FST_START_READING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_READING

#define BA_FST_START_WRITING    &g_asSharedMemory->baFast[\
            1 - g_asSharedMemory->fastPath.newBuffer]
#define BA_FST_STOP_WRITING


#endif // DLL_DISP



//
//
// TYPES
//
//




//
// Structure: BA_BOUNDS_INFO
//
// Description: Structure used to pass bounds information between the
//              share core and the driver.
//
//
typedef struct tagBA_BOUNDS_INFO
{
    OSI_ESCAPE_HEADER   header;             // Common header               
    DWORD       numRects;                   // Num of bounds rects
    RECTL       rects[BA_NUM_RECTS];        // Rects
}
BA_BOUNDS_INFO;
typedef BA_BOUNDS_INFO FAR * LPBA_BOUNDS_INFO;


//
// Structure: BA_FAST_DATA
//
// Used to pass data from the screen output task to the Share Core on each
// periodic processing.
//
typedef struct tagBA_FAST_DATA
{
    DWORD    totalSDA;
} BA_FAST_DATA;
typedef BA_FAST_DATA FAR * LPBA_FAST_DATA;



//
//
// OVERVIEW
//
// The bounds code used to be common to the share core and the display
// driver, with the data stored in the double buffered shared memory.  This
// is no longer the case.
//
// The display driver now "owns" the bounds - they are no longer stored in
// shared memory - and does all the complex manipulations such as merging
// rectangles.  When the share core needs to process bounds, it gets a copy
// from the driver by calling BA_FetchBounds(), sends as much of the data
// as possible, then returns the remaining bounds to the driver by calling
// BA_ReturnBounds().
//
// The nett result of these changes is that all the code which was common
// to the share core and the display driver (in abaapi.c and abaint.c) is
// now only in the driver (in nbaapi.c and nbaint.c).  There are vastly
// simplified versions of the functions in the share core.
//
//



//
// BA_ResetBounds
//
#ifdef DLL_DISP
void BA_DDInit(void);

void BA_ResetBounds(void);
#endif // DLL_DISP



//
// Name:      BA_ReturnBounds
//
// Purpose:   Pass the share core's copy of the bounds to the driver.
//
// Returns:   Nothing
//
// Params:    None
//
// Operation: This resets the share core's bounds to NULL.
//

void BA_ReturnBounds(void);




//
// Name:        BA_CopyBounds
//
// Description: Copies the bounding rectangle list.
//
// Params (IN): pRects - pointer to array of RECTs to fill in.
//        (OUT):pNumrects - filled in with number of RECTs copied.
//        (IN): reset current rects or just get current state w/o changing
//              state.
//
// Returns:     TRUE or FALSE
//
// DESCRIPTION
//
// Returns the accumulated bounds for all applications in the bounds
// code's current list of applications.  The bounds returned will
// include all updates originating from these applications but they may
// also include updates outside these applications windows and updates
// originating from other applications.  Therefore the caller must clip
// the returned bounds to the windows of the applications being
// shadowed.
//
// PARAMETERS
//
// pRects:
//
// A pointer to an array of rectangles in which the bounds will be
// returned.  The contents of this array are only valid if *pRegion is NULL
// on return from BA_GetBounds.  There must
// be room for maxRects rectangles (as specified in the bndInitialise
// call).  pRects may be a NULL pointer if maxRects was set to 0 in the
// bndInitialise call.
//
// pNumRects:
//
// A pointer to a variable where the number of rectangles returned at
// pRects is returned.  The contents of this variable are only valid if
// *pRegion is NULL on return from BA_GetBounds.
//
// fReset:
// Whether to reset the core's bounds variables after getting the current
// state or not.
//
//
void BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset);


#ifdef DLL_DISP


typedef struct tagDD_BOUNDS
{
    UINT    iNext;
    BOOL    InUse;
    RECT    Coord;
    DWORD   Area;
} DD_BOUNDS;
typedef DD_BOUNDS FAR* LPDD_BOUNDS;



//
// Name:      BA_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    BA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
BOOL    BA_DDProcessRequest(DWORD fnEscape, LPOSI_ESCAPE_HEADER pRequest,
                DWORD cbRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif // !IS_16


//
// Name:      BA_QuerySpoilingBounds
//
// Purpose:   Return the current spoiling bounds.  That is, the bounds
//            which the share core is currently processing.
//
// Returns:   Nothing
//
// Params:    IN/OUT pRects    - Pointer to an array of rectangles to
//                               return the bounds in.  There must be at
//                               least BA_NUM_RECTS entries in this
//                               array.  The first *pNumRects entries are
//                               valid on return.
//            IN/OUT pNumRects - Returns the number of rectangles forming
//                               the spoiling bounds (can be zero).
//

void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects);



//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//

//
// Note that bndRectsArray and bndRectsSizeArray must contain space for
// BA_NUM_RECTS+1 rectangles for the merge algorithm.
//

//
// The function will recurse to a maximum level when trying to split
// rectangles up.  When this limit is reached it will start merging
// rather than splitting
//
#define ADDR_RECURSE_LIMIT 20

//
// The following constants are used to determine overlaps.
//
// - OL_NONE through OL_MERGE_YMAX are return codes - which need to be
//   distinct from all possible outcode combinations - allowing for the
//   minus outcodes for enclosed cases.
//
// - EE_XMIN through EE_YMAX are outcodes - which need to be uniquely
//   ORable binary constants within a single nibble.
//
// - OL_ENCLOSED through OL_SPLIT_XMAX_YMAX are outcode combinations for
//   internal and external edge overlap cases.
//
// See Overlap() for further description.
//
#define OL_NONE               -1
#define OL_MERGE_XMIN         -2
#define OL_MERGE_YMIN         -3
#define OL_MERGE_XMAX         -4
#define OL_MERGE_YMAX         -5

#define EE_XMIN 0x0001
#define EE_YMIN 0x0002
#define EE_XMAX 0x0004
#define EE_YMAX 0x0008

#define OL_ENCLOSED           -(EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_XMIN -(EE_XMIN | EE_YMIN | EE_YMAX)
#define OL_PART_ENCLOSED_YMIN -(EE_XMIN | EE_YMIN | EE_XMAX)
#define OL_PART_ENCLOSED_XMAX -(EE_YMIN | EE_XMAX | EE_YMAX)
#define OL_PART_ENCLOSED_YMAX -(EE_XMIN | EE_XMAX | EE_YMAX)

#define OL_ENCLOSES           EE_XMIN | EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMIN EE_XMAX | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_XMAX EE_XMIN | EE_YMIN | EE_YMAX
#define OL_PART_ENCLOSES_YMIN EE_XMIN | EE_XMAX | EE_YMAX
#define OL_PART_ENCLOSES_YMAX EE_XMIN | EE_XMAX | EE_YMIN
#define OL_SPLIT_X            EE_YMIN | EE_YMAX
#define OL_SPLIT_Y            EE_XMIN | EE_XMAX
#define OL_SPLIT_XMIN_YMIN    EE_XMAX | EE_YMAX
#define OL_SPLIT_XMAX_YMIN    EE_XMIN | EE_YMAX
#define OL_SPLIT_XMIN_YMAX    EE_XMAX | EE_YMIN
#define OL_SPLIT_XMAX_YMAX    EE_XMIN | EE_YMIN

int BAOverlap(LPRECT pRect1, LPRECT pRect2 );

//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect);

//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect);


void BA_AddScreenData(LPRECT pRect);


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect( LPRECT pCand,  int level );


#endif // DLL_DISP



#endif // _H_BA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\cm.h ===
//
// Cursor Manager
//

#ifndef _H_CM
#define _H_CM


//
//
// CONSTANTS
//
//

//
// Maximum cursor sizes.
//
#define CM_MAX_CURSOR_WIDTH            32
#define CM_MAX_CURSOR_HEIGHT           32

//
// This is the maximum size of the cursor data for the combined 1bpp AND
// mask and n bpp XOR mask.  We currently allow for a 32x32 cursor at
// 32bpp.  In this case the AND mask consumes 32*32/8 bytes (128) and the
// XOR mask consumes 32*32*4 bytes (4096).  Total is 32*4 + 32*32*4, which
// is (32*4)*(1 + 32), which is (32*4)*33
//
#define CM_MAX_CURSOR_DATA_SIZE        \
    ((CM_MAX_CURSOR_WIDTH/8) * CM_MAX_CURSOR_HEIGHT * 33)


//
// Thresholds for color intensity to distinguish between 24bpp colors which
// map to black, white, or a hatch pattern
//
#define CM_WHITE_THRESHOLD  (TSHR_UINT32)120000
#define CM_BLACK_THRESHOLD  (TSHR_UINT32)40000


//
// Shadow cursor tag constant declarations.
//
#define	NTRUNCLETTERS	    5 // For CreateAbbreviatedName - "A. B."
#define MAX_CURSOR_TAG_FONT_NAME_LENGTH 64
#define CURSOR_TAG_FONT_HEIGHT  -11

//
// This defines the size of the tag.. careful if you change these
// values... they must define a tag that fits in a hardcoded 32x32 bitmap.
//
#define	TAGXOFF	8
#define	TAGYOFF	20
#define	TAGXSIZ 24
#define	TAGYSIZ	12


typedef struct tag_curtaginfo
{
	WORD cHeight;
	WORD cWidth;
	BYTE aAndBits[ 32 * 32 / 8 ];
	BITMAPINFO bmInfo; // includes foreground color
	RGBQUAD rgbBackground[1]; // describes background color
	BYTE aXorBits[ 32 * 32 / 8 ]; // packed bits follow BITMAPINFO, color table
}
CURTAGINFO, * PCURTAGINFO;



typedef struct tagCACHEDCURSOR
{
    HCURSOR  hCursor;
    POINT     hotSpot;
}
CACHEDCURSOR;
typedef CACHEDCURSOR * PCACHEDCURSOR;


//
// Information about a remote party's cursor.
//
//
//
//
// Calculates the number of bytes wide a cursor is given the width of the
// cursor in pels. Cursors are 1bpp and word padded.
//
#define CM_BYTES_FROM_WIDTH(width) ((((width)+15)/16)*2)


//
//
// TYPES
//
//

//
// A POINTL has 32-bit coords in both 16-bit and 32-bit code
//
typedef struct tagCM_SHAPE_HEADER
{
    POINTL  ptHotSpot;
    WORD    cx;
    WORD    cy;
    WORD    cbRowWidth;
    BYTE    cPlanes;
    BYTE    cBitsPerPel;
} CM_SHAPE_HEADER;
typedef CM_SHAPE_HEADER FAR * LPCM_SHAPE_HEADER;

typedef struct tagCM_SHAPE
{
    CM_SHAPE_HEADER     hdr;
    BYTE                Masks[1]; // 1bpp AND mask, followed by n bpp XOR mask
} CM_SHAPE;
typedef CM_SHAPE FAR * LPCM_SHAPE;


typedef struct tagCM_SHAPE_DATA
{
    CM_SHAPE_HEADER     hdr;
    BYTE                data[CM_MAX_CURSOR_DATA_SIZE];
}
CM_SHAPE_DATA;
typedef CM_SHAPE_DATA FAR * LPCM_SHAPE_DATA;



// Structure: CM_FAST_DATA
//
// Description: Shared memory data - cursor description and usage flag
//
//   cmCursorStamp     - Cursor identifier: an integer written by the
//                       display driver
//   bitmasks          - RGB bitmasks for >8bpp cursors
//   colorTable        - Color table for <= 8bpp cursors
//   cmCursorShapeData - Cursor definition (AND, XOR masks, etc)
//
//
//
//  Note that a PALETTEENTRY is a DWORD, same in 16-bit and 32-bit code
//
typedef struct tagCM_FAST_DATA
{
    DWORD                   cmCursorStamp;
    DWORD                   bitmasks[3];
    PALETTEENTRY            colorTable[256];
    CM_SHAPE_DATA           cmCursorShapeData;
}
CM_FAST_DATA;
typedef CM_FAST_DATA FAR * LPCM_FAST_DATA;



//
//
// MACROS
//
//
#define CURSOR_AND_MASK_SIZE(pCursorShape) \
    ((pCursorShape)->hdr.cbRowWidth * (pCursorShape)->hdr.cy)

#define ROW_WORD_PAD(cbUnpaddedRow) \
    (((cbUnpaddedRow) + 1) & ~1)

#define CURSOR_XOR_BITMAP_SIZE(pCursorShape)                                 \
                     (ROW_WORD_PAD(((pCursorShape)->hdr.cx *                 \
                                    (pCursorShape)->hdr.cBitsPerPel) / 8) *  \
                     (pCursorShape)->hdr.cy)

#define CURSOR_DIB_BITS_SIZE(cx, cy, bpp)   \
                                       (ROW_WORD_PAD(((cx) * (bpp))/8) * (cy))

#define CURSORSHAPE_SIZE(pCursorShape) \
    sizeof(CM_SHAPE_HEADER) +               \
    CURSOR_AND_MASK_SIZE(pCursorShape) +     \
    CURSOR_XOR_BITMAP_SIZE(pCursorShape)

//
// Null cursor indications
//
#define CM_CURSOR_IS_NULL(pCursor) ((((pCursor)->hdr.cPlanes==(BYTE)0xFF) && \
                                    (pCursor)->hdr.cBitsPerPel == (BYTE)0xFF))

#define CM_SET_NULL_CURSOR(pCursor) (pCursor)->hdr.cPlanes = 0xFF;          \
                                    (pCursor)->hdr.cBitsPerPel = 0xFF;

//
// Expands a particular bit into a byte.  The bits are zero-indexed and
// numbered from the left.  The allowable range for pos is 0 to 7
// inclusive.
//
#define BIT_TO_BYTE(cbyte, pos) \
             ( (BYTE) ((((cbyte) >> (7 - (pos))) & 0x01) ? 0xFF : 0x00))

//
// Get two bits from a byte.  The bits are zero-indexed and numbered from
// the left.  The allowable range for pos is 0 to 3 inclusive.
//
#define GET_TWO_BITS(cbyte, pos)                                \
  ( (BYTE) (((cbyte) >> (2 * (3 - (pos)))) & 0x03) )

//
// Return the maximum size of palette (in bytes) required for a DIB at a
// given bpp.  This is 2 ^ bpp for bpp < 8, or 0 for > 8 bpp
//
#define PALETTE_SIZE(BPP)   (((BPP) > 8) ? 0 : ((1<<(BPP)) * sizeof(RGBQUAD)))


//
// Return a pointer to the actual bitmap bits within a DIB.
//
#define POINTER_TO_DIB_BITS(pDIB)                     \
        ((void *) ((LPBYTE)(pDIB) + DIB_BITS_OFFSET(pDIB)) )

//
// Calculate the offset of the data bits in a DIB.
//
#define DIB_BITS_OFFSET(pDIB)                         \
        (PALETTE_SIZE((pDIB)->bmiHeader.biBitCount) +   \
        sizeof(BITMAPINFOHEADER))

//
// Trace out info about a DIB.  PH is a pointer to a BITMAPINFOHEADER
//
#define CAP_TRACE_DIB_DBG(PH, NAME)                                          \
    TRACE_OUT(( "%s: %#.8lx, %ld x %ld, %hd bpp, %s encoded",               \
        (NAME), (DWORD)(PH), (PH)->biWidth, (PH)->biHeight, (PH)->biBitCount,\
        ((PH)->biCompression == BI_RLE8) ? "RLE8"                            \
            : (((PH)->biCompression == BI_RLE4) ? "RLE4" : "not")))

//
// Is the parameter a pointer to a Device Dependant Bitmap?
//
#define IS_DIB(PARAM) (*((LPWORD)(PARAM)) == 0x28)

//
// Driver supports color_cursors and async SetCursor.  This value is taken
// from the Win95 DDK.
//
#define C1_COLORCURSOR  0x0800


//
//
// PROTOTYPES
//
//





//
// Specific values for OSI escape codes
//
#define CM_ESC(code)        (OSI_CM_ESC_FIRST + code)

#define CM_ESC_XFORM        CM_ESC(0)



//
//
// STRUCTURES
//
//


// Structure: CM_DRV_XFORM_INFO
//
// Description: Structure passed from the share core to the display driver
// to pass cursor transform data
//
typedef struct tagCM_DRV_XFORM_INFO
{
    OSI_ESCAPE_HEADER header;

    //
    // Share core -> display driver.
    // Pointers to AND mask.  Note that this user-space pointer is also
    // valid in the display driver realm (ring0 if NT, 16-bit if W95)
    //
    LPBYTE          pANDMask;
    DWORD           width;
    DWORD           height;

    //
    // Driver -> share core.
    //
    DWORD           result;

} CM_DRV_XFORM_INFO;
typedef CM_DRV_XFORM_INFO FAR * LPCM_DRV_XFORM_INFO;


//
//
// PROTOTYPES
//
//

#ifdef DLL_DISP

//
// Name:      CM_DDProcessRequest
//
// Purpose:   Process CM requests from the Share Core which have been
//            to the display driver through the DrvEscape mechanism.
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//

#ifdef IS_16
BOOL    CM_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);
#else
ULONG   CM_DDProcessRequest(SURFOBJ*  pso,
                                UINT  cjIn,
                                void *   pvIn,
                                UINT  cjOut,
                                void *   pvOut);
#endif


#ifdef IS_16
BOOL    CM_DDInit(HDC);
#else
BOOL    CM_DDInit(LPOSI_PDEV ppDev);
#endif  // IS_16


#ifdef IS_16
void    CM_DDViewing(BOOL fViewers);
#else
void    CM_DDViewing(SURFOBJ * pso, BOOL fViewers);
#endif // IS_16

//
// Name:      CM_DDTerm
//
// Purpose:   Terminates the display driver component of the cursor
//            manager.
//
// Params:    None.
//
void CM_DDTerm(void);


#endif // DLL_DISP


typedef void ( *PFNCMCOPYTOMONO) ( LPBYTE pSrc,
                                                    LPBYTE pDst,
                                                    UINT   cx,
                                                    UINT   cy );


//
// Cursor type (as required by CMMaybeSendCursor).  The values are:
//
//  DEFAULTCURSOR   - standard pointer
//  DISPLAYEDCURSOR - displayed (eg.  bitmap) cursor
//
#define CM_CT_DEFAULTCURSOR   1
#define CM_CT_DISPLAYEDCURSOR 2

//
// Types of displayed cursor:
//
//  UNKNOWN      - ONLY to be used by resyncing code
//  SYSTEMCURSOR - Standard windows cursor
//  BITMAPCURSOR - Displayed cursor
//
#define CM_CD_UNKNOWN         0
#define CM_CD_SYSTEMCURSOR    1
#define CM_CD_BITMAPCURSOR    2

typedef struct tagCURSORDESCRIPTION
{
    DWORD       type;
    DWORD       id;
} CURSORDESCRIPTION;
typedef CURSORDESCRIPTION FAR * LPCURSORDESCRIPTION;

typedef struct tagCURSORIMAGE
{
    WORD                xHotSpot;
    WORD                yHotSpot;
    BITMAPINFOHEADER    crHeader;
    BYTE                crMasks[1];
} CURSORIMAGE;
typedef CURSORIMAGE FAR *LPCURSORIMAGE;



#ifndef DLL_DISP



BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf, UINT cbBuf);




//
// BOGUS LAURABU:
// We should use normal GDI StretchBlts to get the bitmap bits, not
// our own whacky pack/unpack code.
//
void CMCopy1bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy4bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy8bppTo1bpp( LPBYTE pSrc,
                                    LPBYTE pDst,
                                    UINT   cx,
                                    UINT   cy );

void CMCopy16bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

void CMCopy24bppTo1bpp( LPBYTE pSrc,
                                     LPBYTE pDst,
                                     UINT   cx,
                                     UINT   cy );

BOOL CMGetMonoCursor( LPTSHR_UINT16 pcxWidth,
                                   LPTSHR_UINT16 pcyHeight,
                                   LPTSHR_UINT16 pxHotSpot,
                                   LPTSHR_UINT16 pyHotSpot,
                                   LPBYTE  pANDBitmap,
                                   LPBYTE  pXORBitmap );



void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor);

void CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                              LPUINT      pcbANDMaskSize,
                                              LPUINT      pcbXORBitmapSize );

BOOL CMGetMonoCursorDetails( LPCM_SHAPE pCursor,
                                          LPTSHR_UINT16      pcxWidth,
                                          LPTSHR_UINT16      pcyHeight,
                                          LPTSHR_UINT16      pxHotSpot,
                                          LPTSHR_UINT16      pyHotSpot,
                                          LPBYTE       pANDBitmap,
                                          LPTSHR_UINT16      pcbANDBitmap,
                                          LPBYTE       pXORBitmap,
                                          LPTSHR_UINT16      pcbXORBitmap );


void CMRefreshWindowCursor(HWND window);


BOOL CMGetCursorShape( LPCM_SHAPE * ppCursorShape,
                                    LPUINT              pcbCursorDataSize );

HWND CMGetControllingWindow(void);


#define CM_SHM_START_READING  &g_asSharedMemory->cmFast[\
                   1 - g_asSharedMemory->fastPath.newBuffer]
#define CM_SHM_STOP_READING


#else


#ifdef IS_16
BOOL    CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult);
void    CMDDJiggleCursor(void);
#else
BOOL    CMDDSetTransform(LPOSI_PDEV ppDev, LPCM_DRV_XFORM_INFO pXformInfo);
#endif


#define CM_SHM_START_WRITING  SHM_StartAccess(SHM_CM_FAST)
#define CM_SHM_STOP_WRITING   SHM_StopAccess(SHM_CM_FAST)



#endif // !DLL_DISP



#endif // _H_CM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\dbgzones.h ===
#ifndef _DEBUG_ZONES_H_
#define _DEBUG_ZONES_H_

#include <mlzdbg.h>

#if defined(_DEBUG) && defined(MULTI_LEVEL_ZONES)

enum
{
    ZONE_CORE = BASE_ZONE_INDEX,
    ZONE_NET,
    ZONE_ORDER,
    ZONE_OM,
    ZONE_INPUT,
    ZONE_WB,
    ZONE_UT
};

#endif // _DEBUG && MULTI_LEVEL_ZONES


#endif // _DEBUG_ZONES_H_


// lonchanc: this must be outside the _DEBUG_ZONE_H_ protection
// because cpi32dll.c and crspdll.c need to include this header
// again in order to initialize the debug zone data.
#if defined(_DEBUG) && defined(INIT_DBG_ZONE_DATA) && defined(MULTI_LEVEL_ZONES)

static const PSTR c_apszDbgZones[] =
{
    "AppShr",      // debug zone module name
    DEFAULT_ZONES
    "Core",
    "Network",
    "Order",
    "ObMan",
    "Input",
    "Whiteboard",
    "UT",
};

#endif // _DEBUG && INIT_DBG_ZONE_DATA && MULTI_LEVEL_ZONES
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\control.h ===
//
// CONTROL.H
// Control by us, control of us
//
// Copyright (c) Microsoft 1997-
//

#ifndef _H_CA
#define _H_CA


//
//
// CONSTANTS
//
//

#define CA_SEND_EVENT           0x0001
#define CA_ALLOW_EVENT          0x0002


//
// Cleanup flags
//
#define CACLEAR_HOST            0x0001
#define CACLEAR_VIEW            0x0002
#define CACLEAR_ALL             0x0003


//
// Queued responses to control requests.  We try to send them right away,
// but that can fail.  
// Here's the logic:
//      
// (1) For TAKING/RELEASING control (viewer)
//     There's only one at most pending.  That's because a pending RELEASE
//          cancels out a pending TAKE.  
//
// (2) For RESPONDING/REVOKING control (host)
//     These never cancel out.  Each one will have a successive sequence ID.
//          There should NEVER be a pending BOUNCE in the queue with a 
//          pending RESPOND for the same controller/request ID.  Of course not,
//          since we don't change our state until the packet goes out,
//          and if the RESPOND CONFIRM packet hasn't gone out, we wouldn't
//          be bouncing anybody.
//      
// Outgoing requests take precedence over incoming ones.  In other words,
// if the UI/user/SDK code asks us to take control of a remote, we will
// turn any pending RESPOND CONFIRM packets into RESPOND DENIED ones.  If
// we are in control of another already, take will fail, it's the intermediate
// phase that's undoable only.
//
// Here's the basic logic flow to TAKE CONTROL:
//      Viewer makes new sequence ID
//      Viewer sends private packet to host, requesting control
//      Viewer changes state to "asked for control"
//      Host receives private packet
//      Host sends private response packet to viewer, confirming or denying control
//      If confirming, host broadcasts notification to everybody sometime
//          later.
//      When viewer gets response, viewer moves to incontrol state, or
//          backs off
//
// Here's the basic logic flow to RELEASE CONTROL:
//      Viewer initiated:
//          Send INFORM RELEASED private packet to host
//          Change state to not in control
//          Host receives private packet
//          Host ignores if out of date (bounced already or whatever)
//          Host changes state to not controlled otherwise
//      Host initiated:
//          Send INFORM BOUNCED private packet to viewer
//          Change state to not controlled
//          Viewer receives private packet
//          Viewer ignores if out of date (released already or whatever)
//          Viewer changes state to not in control otherwise
//
// While pending take control, waiting to here confirmation, or in control
//      pending requests to control us are denied.
//


enum
{
    REQUEST_2X  = 0,
    REQUEST_30
};

typedef struct tagCA2XREQ
{
    UINT_PTR            data1;
    UINT_PTR            data2;
}
CA2XREQ;


typedef union
{
    CA_RTC_PACKET       rtc;
    CA_REPLY_RTC_PACKET rrtc;
    CA_RGC_PACKET       rgc;
    CA_REPLY_RGC_PACKET rrgc;
    CA_PPC_PACKET       ppc;
    CA_INFORM_PACKET    inform;
}
CA30P;
typedef CA30P * PCA30P;

class ASPerson;

typedef struct tagCA30PENDING
{
    ASPerson *      pasReplyTo;
    UINT_PTR        mcsOrg;
    UINT            msg;
    CA30P           request;
}
CA30PENDING;
typedef CA30PENDING * PCA30PENDING;


typedef struct tagCA30XREQ
{
    CA30P           packet;
}
CA30REQ;


//
// Private send/responses get queued up and our state can NOT change until
// they go out.
//
typedef struct tagCAREQUEST
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    UINT            type;
    UINT_PTR        destID;
    UINT            msg;

    union
    {
        CA2XREQ     req2x;
        CA30REQ     req30;
    }
    req;
}
CAREQUEST;
typedef CAREQUEST * PCAREQUEST;


//
// The location of the keyboard language toggle hotkey setting in the
// registry.
//
#define LANGUAGE_TOGGLE_KEY     "keyboard layout\\toggle"
#define LANGUAGE_TOGGLE_KEY_VAL "Hotkey"

//
// A value we use to indicate that the registry entry is not present - it
// could be any value except for '1', '2', or '3'
//
#define LANGUAGE_TOGGLE_NOT_PRESENT   0


//
// Query dialog
//

#define IDT_CAQUERY         50
#define PERIOD_CAQUERY      30000   // 30 seconds

INT_PTR CALLBACK CAQueryDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_CA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\drvdbg.h ===
//
// DRVDBG.H
// Display Driver (NT-only right now) Debug Macros
//
// Copyright(c) Microsoft 1997-
//

#ifndef _H_DRVDBG
#define _H_DRVDBG


#ifdef  ASSERT
#undef  ASSERT
#endif // ASSERT


#define CCH_DEBUG_MAX           256

// Standard Zones
#define ZONE_INIT               0x0001
#define ZONE_TRACE              0x0002
#define ZONE_FUNCTION           0x0004
#define ZONE_MASK               0x0007
#define ZONE_OAHEAPCHECK        0x0008



#ifndef DEBUG

#define DebugEntry(x)
#define DebugExitVOID(x)
#define DebugExitDWORD(x, dw)
#define DebugExitBOOL(x, f)
#define DebugExitPVOID(x, ptr)

#define TRACE_OUT(x)
#define WARNING_OUT(x)
#define ASSERT(x)

#else



void DbgZPrintFn(LPSTR szFn);
void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult);
void DbgZPrintFnExitPVOID(LPSTR szFn, PVOID ptr);

#define DebugEntry(szFn)                DbgZPrintFn("ENTER "#szFn)
#define DebugExitVOID(szFn)             DbgZPrintFn("LEAVE "#szFn)
#define DebugExitDWORD(szFn, dwResult)  DbgZPrintFnExitDWORD("LEAVE "#szFn, dwResult)
#define DebugExitBOOL(szFn, fResult)    DbgZPrintFnExitDWORD("LEAVE "#szFn, fResult)
#define DebugExitPVOID(szFn, dwResult)  DbgZPrintFnExitPVOID("LEAVE "#szFn, dwResult)


void _cdecl DbgZPrintTrace(LPSTR pszFormat, ...);
void _cdecl DbgZPrintWarning(LPSTR pszFormat, ...);

#define TRACE_OUT(szMsg)                DbgZPrintTrace  szMsg
#define WARNING_OUT(szMsg)              DbgZPrintWarning  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg


extern char g_szAssertionFailure[];

#define ASSERT(exp)                     if (!(exp)) ERROR_OUT((g_szAssertionFailure))



#endif // !DEBUG


//
// For driver start up tracing in retail as well
//
#if defined(DEBUG) || defined(INIT_TRACE)

void _cdecl DbgZPrintInit(LPSTR pszFormat, ...);
void _cdecl DbgZPrintError(LPSTR pszFormat, ...);

#define INIT_OUT(szMsg)                 DbgZPrintInit  szMsg
#define ERROR_OUT(szMsg)                DbgZPrintError  szMsg

#else

#define INIT_OUT(x)
#define ERROR_OUT(x)

#endif // DEBUG or INIT_TRACE



#endif // _H_DRVDBG

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\datainit.h ===
//
// Macros that create storage for vars
//

//
// Clear any previous definitions of the macros.
//
#undef DC_DATA
#undef DC_DATA_VAL
#undef DC_CONST_DATA
#undef DC_DATA_ARRAY
#undef DC_CONST_DATA_ARRAY
#undef DC_DATA_2D_ARRAY
#undef DC_CONST_DATA_2D_ARRAY


// This is for structs that can't use the DC_DATA macros; they can switch on it
#define DC_DEFINE_DATA

//
// Allocate Storage
//

#define DC_DATA(TYPE, Name) \
            TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            TYPE Name = Value

#define DC_CONST_DATA(TYPE, Name, Value) \
            const TYPE Name = Value


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            const TYPE Name[Size] = Value


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            const TYPE Name[Size1][Size2] = Value
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\dcs.h ===
//
// DC-Share Stuff
//

#ifndef _H_DCS
#define _H_DCS



//
// RESOURCES
//

#include <resource.h>



//
// We piggyback some extra flags into the ExtTextOut options.  We must
// ensure that we dont clash with the Windows defined ones.
//
#define     ETO_WINDOWS         (0x0001 | ETO_OPAQUE | ETO_CLIPPED)
#define     ETO_LPDX            0x8000U


//
// Debugging Options (also in retail)
//
// NOTE:  THESE MUST STAY IN SYNC WITH WHAT'S in \ui\conf\dbgmenu.*
//

// View one's own shared stuff in a frame to see what others are getting
#define VIEW_INI_VIEWSELF                    "ViewOwnSharedStuff"

// Hatch the areas sent as screen data from the host when viewing them
#define USR_INI_HATCHSCREENDATA             "HatchScreenData"

// Hatch the areas sent as bitmap orders from the host when viewing them
#define USR_INI_HATCHBMPORDERS               "HatchBitmapOrders"

// Turn off flow control
#define S20_INI_NOFLOWCONTROL               "NoFlowControl"

// Turn off OM compression
#define OM_INI_NOCOMPRESSION                "NoOMCompression"

//
// Change compression type (bunch of bit flags)
//      0x0000 (CT_NONE) is no compression
//      0x0001 (CT_PKZIP) is non-persistent dictionary PKZIP
//      0x0002 (CT_PERSIST_PKZIP) is persistent dictionary PKZIP
//
// Default value is 0x0003 (pkzip + persist pkzip)
//      
#define GDC_INI_COMPRESSION                 "GDCCompression"

//
// Change 2nd level order encoding (bunch of bitflags)
//      0x0001 (CAPS_ENCODING_BASE_OE)
//      0x0002 (CAPS_ENCODING_OE2_NEGOTIABLE)
//      0x0004 (CAPS_ENCODING_OE2_DISABLED)
//      0x0008 (CAPS_ENCODING_ALIGNED_OE)
//
// Default value is 0x0002
// To turn off 2nd level encoding, use 0x0006 (negotiable + disabled)
//
#define OE2_INI_2NDORDERENCODING            "2ndLevelOrderEncoding"


//
// Speedy link constant
//
#define DCS_FAST_THRESHOLD                      50000

//
// We will not compress packets smaller than this, whatever the link speed
//
#define DCS_MIN_COMPRESSABLE_PACKET             256

//
// We will not compress packets smaller than this on a fast link
// NOTE that is is the largest single T.120 preallocated packet size.
//
#define DCS_MIN_FAST_COMPRESSABLE_PACKET        8192

//
// We will not try to persistently compress packets larger than this
//
#define DCS_MAX_PDC_COMPRESSABLE_PACKET         4096





//
// Frequency (ms) with which the core performs timer tasks
//
// VOLUME_SAMPLE is the time beyond which we will take another sample of
// the bounds accumulation data.  If the screendata accumulated in this
// time is less than BOUNDS_ACCUM then we will try and send it immediately
// otherwise we wait until the orders have slowed down.
//
// UPDATE_PERIOD is the absolute maximum time between attempts to send data
//
// ANIMATION_SLOWDOWN id how many times we attempt to send mem-scrn blits
// over a PSTN connection.
//
// ANIMATION_DETECTION the interval, in mS, below which we determine the
// app is performing animation.  Must be low otherwise we slowdown during
// rapid typing.  The algorithm simply looks for repeated memblts to the
// same area
//
// DCS_ORDERS_TURNOFF_FREQUENCY
// The frequency of orders above which we start time slicing order
// transmission in order to give the host system a chance to draw the
// orders without having to send them in individual network packets.
//
// DCS_BOUNDS_TURNOFF_RATE
// Very important for performance of typing in Word that this value is not
// too low, since Word can generate 50K per keystroke.  On the other hand,
// it is important not to allow the capture of screendata until after an
// app that does a lot of blitting to the screen has finished.
//
// DCS_BOUNDS_IMMEDIATE_RATE
// To avoid sending excessive amounts of screendata we only send at the
// most ten times per second.  However, if the volumes are small then we
// override this to reduce latency
//
//
// The other rates control individual timer functions - see adcsapi.c for
// further details
// Note that the IM period is less than the likely rate of this function
// being scheduled.  This is set low so that we will, in general, call IM
// periodic every time to keep mouse moves flowing, but it will not be
// called repeatedly if there are several wakeups pending within a single
// scheduling cycle.
//
//
#define DCS_VOLUME_SAMPLE                       500
#define DCS_BOUNDS_TURNOFF_RATE              400000
#define DCS_BOUNDS_IMMEDIATE_RATE            100000
#define DCS_ORDERS_TURNOFF_FREQUENCY            100
#define DCS_SD_UPDATE_SHORT_PERIOD              100
#define DCS_SD_UPDATE_LONG_PERIOD              5000
#define DCS_ORDER_UPDATE_PERIOD                 100
#define DCS_FAST_MISC_PERIOD                    200
#define DCS_IM_PERIOD                            80



//
// Special Messages to synchronize APIs etc.
//
#if defined(DLL_CORE) || defined(DLL_HOOK)

#define DCS_FIRST_MSG               WM_APP

enum
{
    DCS_FINISH_INIT_MSG             = DCS_FIRST_MSG,
    DCS_PERIODIC_SCHEDULE_MSG,
    DCS_KILLSHARE_MSG,
    DCS_SHARE_MSG,
    DCS_UNSHARE_MSG,
    DCS_NEWTOPLEVEL_MSG,
    DCS_RECOUNTTOPLEVEL_MSG,
    DCS_TAKECONTROL_MSG,
    DCS_CANCELTAKECONTROL_MSG,
    DCS_RELEASECONTROL_MSG,
    DCS_PASSCONTROL_MSG,
    DCS_ALLOWCONTROL_MSG,
    DCS_GIVECONTROL_MSG,
    DCS_CANCELGIVECONTROL_MSG,
    DCS_REVOKECONTROL_MSG,
    DCS_PAUSECONTROL_MSG
};

#endif // DLL_CORE or DLL_HOOK



//
//
// PROTOTYPES
//
//


BOOL DCS_Init(void);
void DCS_FinishInit(void);
void DCS_Term(void);





//
// DCS_NotifyUI()
//
// DESCRIPTION:
// Called by app sharing to notify the front end of various changes and
// actions.
//
void DCS_NotifyUI(UINT event, UINT parm1, UINT parm2);


void DCSLocalDesktopSizeChanged( UINT width, UINT height );



#define DCS_MAIN_WINDOW_CLASS   "AS_MainWindow"


LRESULT CALLBACK DCSMainWndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);





#define SHP_POLICY_NOAPPSHARING         0x0001
#define SHP_POLICY_NOSHARING            0x0002
#define SHP_POLICY_NODOSBOXSHARE        0x0004
#define SHP_POLICY_NOEXPLORERSHARE      0x0008
#define SHP_POLICY_SHAREMASK            (SHP_POLICY_NODOSBOXSHARE | SHP_POLICY_NOEXPLORERSHARE)
#define SHP_POLICY_NODESKTOPSHARE       0x0010
#define SHP_POLICY_NOTRUECOLOR          0x0020

#define SHP_POLICY_NOCONTROL            0x2000
#define SHP_POLICY_NOOLDWHITEBOARD      0x8000

#define SHP_SETTING_TRUECOLOR           0x0001


//
// EVENTS
//

enum
{
    SH_EVT_APPSHARE_READY = SPI_BASE_EVENT,
    SH_EVT_SHARE_STARTED,
    SH_EVT_SHARING_STARTED,
    SH_EVT_SHARE_ENDED,
    SH_EVT_PERSON_JOINED,
    SH_EVT_PERSON_LEFT,
    SH_EVT_CONTROLLABLE,
    SH_EVT_STARTCONTROLLED,
    SH_EVT_STOPCONTROLLED,
    SH_EVT_PAUSEDCONTROLLED,
    SH_EVT_UNPAUSEDCONTROLLED,
    SH_EVT_STARTINCONTROL,
    SH_EVT_STOPINCONTROL,
    SH_EVT_PAUSEDINCONTROL,
    SH_EVT_UNPAUSEDINCONTROL
};


//
// Function PROTOTYPES
//



#if defined(DLL_CORE)

#include <ias.h>



HRESULT     SHP_GetPersonStatus(UINT dwID, IAS_PERSON_STATUS * pStatus);


#define SHP_DESKTOP_PROCESS     0xFFFFFFFF

HRESULT     SHP_LaunchHostUI(void);
BOOL        SHP_Share(HWND hwnd, IAS_SHARE_TYPE uType);
HRESULT     SHP_Unshare(HWND hwnd);


//
// COLLABORATION
//
HRESULT     SHP_TakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_CancelTakeControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_ReleaseControl(IAS_GCC_ID PersonOf);
HRESULT     SHP_PassControl(IAS_GCC_ID PersonOf, UINT PersonTo);

HRESULT     SHP_AllowControl(BOOL fAllow);
HRESULT     SHP_GiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_CancelGiveControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_RevokeControl(IAS_GCC_ID PersonTo);
HRESULT     SHP_PauseControl(IAS_GCC_ID PersonControlledBy, BOOL fPaused);


void        DCS_Share(HWND hwnd, IAS_SHARE_TYPE uType);
void        DCS_Unshare(HWND hwnd);

#endif // DLL_CORE



#endif // _H_DCS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\dcg.h ===
//
// DC Groupware Common stuff
//

#ifndef _H_DCG
#define _H_DCG



#include <stddef.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <time.h>
#include <memory.h>

#ifdef DLL_DISP

#ifdef IS_16
//
// Win16 Display Driver
//
#define STRICT
#define UNALIGNED
#include <windows.h>
#include <windowsx.h>


#define abs(A)  (((A) < 0)? -(A) : (A))

#define FIELD_OFFSET(type, field)       FIELDOFFSET(type, field)

#else

//
// Windows NT DDK include files (used to replace standard windows.h)       
//                                                                         
// The display driver runs in the Kernel space and so MUST NOT access any  
// Win32 functions or data.  Instead we can only use the Win32k functions  
// as described in the DDK.                                                
//
#include <ntddk.h>
#include <windef.h>
#include <wingdi.h>
#include <ntddvdeo.h>

#endif // IS_16

// DDI
#include <winddi.h>

// Debugging Macros
#include <drvdbg.h>


#else

#ifndef STRICT
#define STRICT
#endif

#define OEMRESOURCE
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <winable.h>


#include <mlzdbg.h> // multi-level zone debug header file
#include <oprahcom.h>

#endif // DLL_DISP


//
// DC_DATA macros to generate extern declarations.
// NOTE:  Keep this section in ssync with datainit.h, the header included
// by a file to actually generate storage for variables declared using the
// DC_DATA macros
//


#define DC_DATA(TYPE, Name) \
            extern TYPE Name

#define DC_DATA_VAL(TYPE, Name, Value) \
            extern TYPE Name

#define DC_CONST_DATA(TYPE, Name, Value) \
            extern const TYPE Name


#define DC_DATA_ARRAY(TYPE, Name, Size) \
            extern TYPE Name[Size]

#define DC_CONST_DATA_ARRAY(TYPE, Name, Size, Value) \
            extern const TYPE Name[Size]


#define DC_DATA_2D_ARRAY(TYPE, Name, Size1, Size2) \
            extern TYPE Name[Size1][Size2]

#define DC_CONST_DATA_2D_ARRAY(TYPE, Name, Size1, Size2, Value) \
            extern const TYPE Name[Size1][Size2]



typedef UINT FAR*       LPUINT;


typedef UINT                        MCSID;
#define MCSID_NULL                  ((MCSID)0)


//
// T.128 PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


#include <t_share.h>



//
// Defines the maximum number of BYTES allowed in a translated "shared by "
// string.                                                                 
//
#define DC_MAX_SHARED_BY_BUFFER     64
#define DC_MAX_SHAREDDESKTOP_BUFFER 64


//
// Registry prefix.                                                        
//
#define DC_REG_PREFIX             TEXT("SOFTWARE\\Microsoft\\Conferencing\\AppSharing\\")

//
// Limits                                                                  
//
#define MAX_TSHR_UINT16                 65535


//
// Return codes
//
#define UT_BASE_RC                     0x0000

#define OM_BASE_RC                     0x0200
#define OM_LAST_RC                     0x02FF

#define WB_BASE_RC                     0x0300
#define WB_LAST_RC                     0x03FF

#define NET_BASE_RC                    0x0700
#define NET_LAST_RC                    0x07FF

#define CM_BASE_RC                     0x0800
#define CM_LAST_RC                     0x08FF

#define AL_BASE_RC                     0x0a00
#define AL_LAST_RC                     0x0aFF


//
// Events                                                                  
// ======                                                                  
// This section lists the ranges available for each component when defining
// its events.  A component must not define events outside its permitted   
// range.                                                                  
//
#define UT_BASE_EVENT        (0x0600)   // Utility service events
#define UT_LAST_EVENT        (0x06FF)   // are in this range     

#define OM_BASE_EVENT        (0x0700)   // Object Manager events 
#define OM_LAST_EVENT        (0x07FF)   // are in this range     

#define NET_BASE_EVENT       (0x0800)   // Network layer events  
#define NET_LAST_EVENT       (0x08FF)   // are in this range     

#define CM_BASE_EVENT        (0x0900)   // Call Manager events   
#define CM_LAST_EVENT        (0x09FF)   // are in this range     

#define AL_BASE_EVENT        (0x0A00)   // Application Loader evts
#define AL_LAST_EVENT        (0x0AFF)   // are in this range     

#define SPI_BASE_EVENT       (0x0B00)   // SPI event numbers     
#define SPI_LAST_EVENT       (0x0BFF)

#define S20_BASE_EVENT       (0x0C00)   // S20 event numbers     
#define S20_LAST_EVENT       (0x0CFF)

//
// NOTE:  Keep this above WM_USER; WB reposts the events using the event
// as the message.  So it CANNOT conflict with an existing Win message.
//
#define WB_BASE_EVENT        (0x0D00)   // Whiteboard events     
#define WB_LAST_EVENT        (0x0DFF)   // are in this range     

#define SC_BASE_EVENT        (0x0E00)   // SC event numbers      
#define SC_LAST_EVENT        (0x0EFF)


#define DBG_INI_SECTION_NAME            "Debug"


//
// The GCC channel keys used with MG_ChannelJoinByKey.  They must be      
// unique.                                                                 
//                                                                         
// SFR6043: Modified these values from 41-43 to 421-423.  These values now 
// represent the default static channel numbers used.                      
//                                                                         
// FT (potentially) uses all key numbers in the range 600-1100.  If you add
// a new channel key, do not use a number in that range.                   
//
#define GCC_OBMAN_CHANNEL_KEY       421
#define GCC_AS_CHANNEL_KEY          422

//
// GCC Token keys                                                          
//
#define GCC_OBMAN_TOKEN_KEY         500



//
//                                                                         
// MACROS                                                                  
//                                                                         
//

#define DC_QUIT                        goto DC_EXIT_POINT


//
// DEBUG structure type stamps, to help us track memory leaks
//
#ifdef _DEBUG

typedef struct tagDBGSTAMP
{
    char    idStamp[8];
}
DBGSTAMP;

#define STRUCTURE_STAMP                 DBGSTAMP    stamp;
#define SET_STAMP(lpv, st)              lstrcpyn((lpv)->stamp.idStamp, "AS"#st, sizeof(DBGSTAMP))

#else

#define STRUCTURE_STAMP
#define SET_STAMP(lpv, st)

#endif // _DEBUG

//
// Cousin of the the FIELD macros supplied by 16-bit windows.h.       
//
#define FIELD_SIZE(type, field)   (sizeof(((type FAR *)0L)->field))


//
// Macro to round up a number to the nearest multiple of four.             
//
#define DC_ROUND_UP_4(x)  (((x) + 3L) & ~(3L))


//
// Unaligned pointer access macros -- first macros to extract an integer   
// from an UNALIGNED pointer.  Note that these macros assume that the      
// integer is in local byte order                                          
//
#ifndef DC_NO_UNALIGNED

#define EXTRACT_TSHR_UINT16_UA(pA)      (*(LPTSHR_UINT16_UA)(pA))
#define EXTRACT_TSHR_INT16_UA(pA)       (*(LPTSHR_INT16_UA)(pA))
#define EXTRACT_TSHR_UINT32_UA(pA)      (*(LPTSHR_UINT32_UA)(pA))
#define EXTRACT_TSHR_INT32_UA(pA)       (*(LPTSHR_INT32_UA)(pA))

#define INSERT_TSHR_UINT16_UA(pA,V)     (*(LPTSHR_UINT16_UA)(pA)) = (V)
#define INSERT_TSHR_INT16_UA(pA,V)      (*(LPTSHR_INT16_UA)(pA)) = (V)
#define INSERT_TSHR_UINT32_UA(pA,V)     (*(LPTSHR_UINT32_UA)(pA)) = (V)
#define INSERT_TSHR_INT32_UA(pA,V)      (*(LPTSHR_INT32_UA)(pA)) = (V)

#else

#define EXTRACT_TSHR_UINT16_UA(pA) ((TSHR_UINT16)  (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_UINT16) ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_INT16_UA(pA)  ((TSHR_INT16)   (((LPBYTE)(pA))[0]) |        \
                                    (TSHR_INT16)  ((((LPBYTE)(pA))[1]) << 8) )

#define EXTRACT_TSHR_UINT32_UA(pA) ((TSHR_UINT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_UINT32) ((((LPBYTE)(pA))[3]) << 24) )

#define EXTRACT_TSHR_INT32_UA(pA)  ((TSHR_INT32)  (((LPBYTE)(pA))[0])        | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[1]) << 8)  | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[2]) << 16) | \
                                    (TSHR_INT32) ((((LPBYTE)(pA))[3]) << 24) )


#define INSERT_TSHR_UINT16_UA(pA,V)                                     \
             {                                                          \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)     & 0x00FF);  \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8) & 0x00FF);  \
             }
#define INSERT_TSHR_INT16_UA(pA,V)  INSERT_TSHR_UINT16_UA(pA,V)

#define INSERT_TSHR_UINT32_UA(pA,V)                                           \
             {                                                              \
                 (((LPBYTE)(pA))[0]) = (BYTE)( (V)      & 0x000000FF); \
                 (((LPBYTE)(pA))[1]) = (BYTE)(((V)>>8)  & 0x000000FF); \
                 (((LPBYTE)(pA))[2]) = (BYTE)(((V)>>16) & 0x000000FF); \
                 (((LPBYTE)(pA))[3]) = (BYTE)(((V)>>24) & 0x000000FF); \
             }
#define INSERT_TSHR_INT32_UA(pA,V)  INSERT_TSHR_UINT32_UA(pA,V)


#endif




//
// Stamp type and macro: each module should use these when stamping its    
// data structures.                                                        
//
typedef TSHR_UINT32                       DC_ID_STAMP;

#define DC_MAKE_ID_STAMP(X1, X2, X3, X4)                                    \
   ((DC_ID_STAMP) (((DC_ID_STAMP) X4) << 24) |                                 \
                  (((DC_ID_STAMP) X3) << 16) |                                 \
                  (((DC_ID_STAMP) X2) <<  8) |                                 \
                  (((DC_ID_STAMP) X1) <<  0) )


//
// BOGUS LAURABU!
// COM_SIZEOF_RECT() was the old name of COM_SIZEOF_RECT_EXCLUSIVE(). But
// it was being used in the display driver on INCLUSIVE rects.  I fixed this,
// I changed it to use COM_SIZEOF_RECT_INCLUSIVE.  But this may uncover 
// other bugs.  The reason I found this--my 16-bit display driver generates
// no orders yet, all the DDI calls just add screen data.  So each little
// patblted strip, one pixel wide/high, gets sent via draw bounds as screen
// data.
//

__inline DWORD COM_SizeOfRectInclusive(LPRECT prc)
{
    return((DWORD)(prc->right+1-prc->left) * (DWORD)(prc->bottom+1-prc->top));
}

__inline DWORD COM_SizeOfRectExclusive(LPRECT prc)
{
    return((DWORD)(prc->right-prc->left) * (DWORD)(prc->bottom-prc->top));
}


//
// NORMAL rect<->rectl conversions
//
__inline void RECTL_TO_RECT(const RECTL FAR* lprclSrc, LPRECT lprcDst)
{
    lprcDst->left = lprclSrc->left;
    lprcDst->top = lprclSrc->top;
    lprcDst->right = lprclSrc->right;
    lprcDst->bottom = lprclSrc->bottom;
}


__inline void RECT_TO_RECTL(const RECT FAR* lprcSrc, LPRECTL lprclDst)
{
    lprclDst->left = lprcSrc->left;
    lprclDst->top = lprcSrc->top;
    lprclDst->right = lprcSrc->right;
    lprclDst->bottom = lprcSrc->bottom;
}


//
// This macro works on 32 bit unsigned ticks and returns TRUE if TIME is   
// between BEGIN and END (both inclusive) allowing for the wraparound.     
//
#define IN_TIME_RANGE(BEGIN, END, TIME)                                     \
    (((BEGIN) < (END)) ?                                                    \
    (((TIME) >= (BEGIN)) && ((TIME) <= (END))) :                            \
    (((TIME) >= (BEGIN)) || ((TIME) <= (END))))


//
// Convert BPP to number of colors.                                        
//
#define COLORS_FOR_BPP(BPP) (((BPP) > 8) ? 0 : (1 << (BPP)))


#define MAX_ITOA_LENGTH     18


#endif // _H_DCG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\gdc.h ===
//
// General Data Compression
//

#ifndef _H_GDC
#define _H_GDC


//
//
// CONSTANTS
//
//


//
// Scratch buffer mutex
//
#define GDC_MUTEX_NAME "GDCMutex"


//
// Compression Types (bit flags)
//
#define GCT_NOCOMPRESSION    0x0000
#define GCT_PKZIP            0x0001
#define GCT_PERSIST_PKZIP    0x0002
#define GCT_DEFAULT          (GCT_PKZIP | GCT_PERSIST_PKZIP)

//
// Compression Options for GCT_PKZIP
//
#define GDCCO_MAXSPEED        0
#define GDCCO_MAXCOMPRESSION  1



//
// Data sizes used to determine the saved dictionary space in our work 
// buffer.
//
#define GDC_DATA_SMALL          1024
#define GDC_DATA_MEDIUM         2048
#define GDC_DATA_MAX            4096


//
// Persistent Dictionaries used for compression/decompression
//
enum
{
    GDC_DICT_UPDATES = 0,
    GDC_DICT_MISC,
    GDC_DICT_INPUT,
    GDC_DICT_COUNT
};


typedef struct tagGDC_DICTIONARY
{
    UINT        cbUsed;                     // Amount of saved data
    BYTE        pData[GDC_DATA_MAX];      // Saved uncompressed data
} GDC_DICTIONARY;
typedef GDC_DICTIONARY * PGDC_DICTIONARY;


//
// Byte runs that can be replaced with smaller bit sequences
//
#define GDC_MINREP              2
#define GDC_MAXREP              (GDC_MINREP+(8*1)+2+4+8+16+32+64+128+256-4)
// GDC_MAXREP is 516, 129*4


//
// Holds uncompressed data for both compression/decompression
//
#define GDC_UNCOMPRESSED        (GDC_MAXREP + 2*GDC_DATA_MAX)

// 
// We don't need to double-buffer compressed data--we just read it out
// of the caller's source or write it into the caller's dest directly.
//
// NOTE:  With real PKZIP, which mostly reads from/writes to files,
// they don't have memory pointers containing raw data already.  That's
// whe original code we got used Read/Write routine callbacks.  This is
// no longer necessary.
//



//
// Random, little understood PKZIP table values, codes
//
#define KMP_THRESHOLD       10


#define GDC_LIT_SIZE        (256 + GDC_MAXREP + 2) 
// GDC_LIT_SIZE is 774


// EOF is last index of Lit array
#define EOF_CODE            (GDC_LIT_SIZE-1)
#define ABORT_CODE          (EOF_CODE+1)


//
// EXT_DIST_BITS is the # of bits needed to store an index into a GDC_DIST_SIZE
// array.  That's defined to be 64, which is 2^6, hence 6 bits.  Smaller
// dictionary compressions use fewer bits and hence not all of the DIST
// items.  The mask
// is used to pull the 6-bit sized index out of a byte.
//
#define GDC_DIST_SIZE               64

#define EXT_DIST_BITS_MIN           4
#define EXT_DIST_BITS_MEDIUM        5
#define EXT_DIST_BITS_MAC           6


#define GDC_LEN_SIZE                16
#define GDC_DECODED_SIZE            256


//
// The hash function has 4*256+5*256 different values, which means
// we need that many entries in our hash array.
//
#define GDC_HASHFN(x)               (4*(x)[0] + 5*(x)[1])
#define GDC_HASH_SIZE               (4*256 + 5*256)





//
// Structure:   GDC_IMPLODE
//
// Workspace for compressing our data.  We have simplified and shrunk this
// structure a fair amount, by having constant code/bit tables and not
// double-buffering the compressed result.  PKZIP's implode calculates the
// LitBits & LitCodes every time through (rather than storing 2 774 byte
// arrays in data--which would be a pain to declare anyway!), and makes a 
// private copy of the DistBits & DistCodes.  
//

typedef struct tagGDC_IMPLODE
{
    //
    // NO SOURCE INFO--we copy source chunks and maybe dictionary into 
    // RawData.  Then at the end we copy RawData back into the dictionary
    // if there is one.
    //

    //
    // Destination info
    //
    LPBYTE              pDst;       // Current Dest ptr (advances as we write)
    UINT                cbDst;      // Amount of Dest left (shrinks as we write)
    UINT                iDstBit;    // Current bit pos in Current Dest ptr byte

    //
    // Compression info
    //
    UINT                cbDictSize;
    UINT                cbDictUsed;
    UINT                ExtDistBits;
    UINT                ExtDistMask;

    //
    // Working info
    //
    UINT                Distance;            
    UINT                ibRawData;

    // NOTE: GDC_UNCOMPRESSED is a multiple of 4
    BYTE                RawData[GDC_UNCOMPRESSED];

    // NOTE:  This is DWORD aligned (GDC_MAXREP is a multiple of 4
    // and the extra 2 WORDS == 1 DWORD
    short               Next[2 + GDC_MAXREP];

    // NOTE: GDC_UNCOMPRESED is a multiple of 4
    WORD                SortArray[GDC_UNCOMPRESSED];

    // NOTE: This is DWORD aligned since GDC_HASH_SIZE is a multiple of 4
    WORD                HashArray[GDC_HASH_SIZE];
} GDC_IMPLODE, * PGDC_IMPLODE;



//
// GDC_EXPLODE
// Workspace for uncompressing our data.  We have vastly simplified and
// shrunk this structure as per the comments for GDC_IMPLODE.
//

typedef struct tagGDC_EXPLODE
{
    //
    // Source info
    //
    LPBYTE              pSrc;       // Current Src ptr (advances as we read)
    UINT                cbSrc;      // Amount of Src left (shrinks as we read)
    UINT                SrcByte;    // Look ahead byte in source
    UINT                SrcBits;    // Remainded src bits

    //
    // NO DEST INFO--we copy maybe dictionary into RawData at the beginning.
    // Then at the end we maybe copy RawData back into the dictionary.
    //

    //
    // Compression info
    //
    UINT                ExtDistBits;
    UINT                ExtDistMask;
    UINT                cbDictUsed;

    UINT                Distance;   
    UINT                iRawData;   // Current index into RawData
    BYTE                RawData[GDC_UNCOMPRESSED];
} GDC_EXPLODE, *PGDC_EXPLODE;


#define GDC_WORKBUF_SIZE    max(sizeof(GDC_IMPLODE), sizeof(GDC_EXPLODE))



//
// EXTERNAL FUNCTIONS
//

//
// API FUNCTION: GDC_Init()
//
// DESCRIPTION:
//
// Initialises the General Data Compressor.
// Must be called before any other GDC functions.
//
// PARAMETERS:
//
//
//
void GDC_Init(void);



//
// FUNCTION: GDC_Compress(..)
//
// DESCRIPTION:
//
// Compresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, valid ptr if persistent
//
// Options                  - specifies whether speed of compression or
//      size of the compressed data is the most important factor.  This
//      basically affects the amount of previous data saved for looking
//      backwards.  MAXSPEED means smaller dictionary.  MAXCOMPRESSION
//      means a bigger one.  The dictionary size is basically the amount
//      of overlap in the source data used when calculating the hash
//      index.
//
//   GDCCO_MAXSPEED         - compress the data as quickly as possible, at
//                            the expense of increased compressed data size
//
//   GDCCO_MAXCOMPRESSION   - compress the data as much as possible, at the
//                            expense of increased compression time.
// With a persistent dictionary, only GDCCO_MAXCOMPRESSION is meaningful.
//
// pSrc                     - pointer to the source (uncompressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            compressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the destina-
//                            tion can hold.  If the compressed result ends
//                            up being bigger than this amount, we bail
//                            out and don't compress the source at all.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.
//
//
BOOL GDC_Compress
(
    PGDC_DICTIONARY     pDictionary,
    UINT                Options,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);


//
// API FUNCTION: GDC_Decompress(..)
//
// DESCRIPTION:
//
// Decompresses source data into a destination buffer.
//
//
// PARAMETERS:
//
// pDictionary              - NULL if old PKZIP, ptr to saved data if
//                            persistent.
//
// pSrc                     - pointer to the source (compressed) data.
//
// cbSrcSize                - the number of bytes of source.
//
// pDst                     - pointer to the destination, where the
//                            uncompressed result will go.
//
// pcbDstSize               - pointer to the maximum amount the desina-
//                            tion can hold.  If the uncompressed result
//                            ends up being bigger than this amount, we
//                            bail out since we can't decompress it.
//                            Otherwise the resulting size is written back.
//
// RETURNS:
//
// TRUE if success, FALSE if failure.

//
BOOL GDC_Decompress
(
    PGDC_DICTIONARY     pDictionary,
    LPBYTE              pWorkBuf,
    LPBYTE              pSrc,
    UINT                cbSrcSize,
    LPBYTE              pDst,
    UINT *              pcbDstSize
);




//
// INTERNAL FUNCTIONS
//


void GDCCalcDecode(const BYTE * pBits, const BYTE * pCodes, UINT size, LPBYTE pDecode);

LPBYTE GDCGetWorkBuf(void);
void   GDCReleaseWorkBuf(LPBYTE);


UINT GDCFindRep(PGDC_IMPLODE pgdcImp, LPBYTE Start);

void GDCSortBuffer(PGDC_IMPLODE pgdcImp, LPBYTE low, LPBYTE hi);

BOOL GDCOutputBits(PGDC_IMPLODE pgdcImp, WORD Cnt, WORD Code);



UINT GDCDecodeLit(PGDC_EXPLODE);

UINT GDCDecodeDist(PGDC_EXPLODE pgdcExp, UINT Len);

BOOL GDCWasteBits(PGDC_EXPLODE pgdcExp, UINT Bits);


#endif // _H_GDC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\host.h ===
//
// Hosting (local or remote)
//

#ifndef _H_HET
#define _H_HET



//
// DC-Share includes
//
#include <osi.h>




//
// Names of special classes
//

#define HET_MENU_CLASS          "#32768"        // Moved around
#define HET_TOOLTIPS98_CLASS    "ToolTips"      // Win98 moved around
#define HET_TOOLTIPSNT5_CLASS   "#32774"        // NT5 moved around
#define HET_DIALOG_CLASS        "#32770"
#define HET_SCREEN_SAVER_CLASS  "WindowsScreenSaverClass"
#define HET_OLEDRAGDROP_CLASS   "CLIPBRDWNDCLASS"

//
// Policy windows
//
#define HET_CMD95_CLASS         "tty"
#define HET_CMDNT_CLASS         "ConsoleWindowClass"
#define HET_EXPLORER_CLASS      "ExploreWClass"
#define HET_CABINET_CLASS       "CabinetWClass"

//
// Maximum size of a class name queried.  This should be at least as large
// as the size of HET_MENU_CLASS, HET_PROPERTY_CLASS and
// HET_SCREEN_SAVER_CLASS.
//
#define HET_CLASS_NAME_SIZE     32


#if defined(DLL_CORE)


//
// Refresh timer
//
#define IDT_REFRESH         51
#define PERIOD_REFRESH      10000

typedef struct tagHOSTENUM
{
    BASEDLIST       list;
    UINT            count;
    UINT            countShared;
}
HOSTENUM, * PHOSTENUM;


BOOL    HET_GetAppsList(IAS_HWND_ARRAY **ppHwnds);
void    HET_FreeAppsList(IAS_HWND_ARRAY * pArray);

BOOL    HET_IsWindowShareable(HWND hwnd);
BOOL    HET_IsWindowShared(HWND hwnd);
BOOL CALLBACK HostEnumProc(HWND, LPARAM);


BOOL    HET_Init(void);
void    HET_Term(void);

INT_PTR CALLBACK HostDlgProc(HWND, UINT, WPARAM, LPARAM);
void    HOST_InitDialog(HWND);
void    HOST_OnCall(HWND, BOOL);
void    HOST_OnSharing(HWND, BOOL);
void    HOST_OnControllable(HWND, BOOL);
void    HOST_UpdateTitle(HWND, UINT);
BOOL    HOST_MeasureItem(HWND, LPMEASUREITEMSTRUCT);
BOOL    HOST_DeleteItem(HWND, LPDELETEITEMSTRUCT);
BOOL    HOST_DrawItem(HWND, LPDRAWITEMSTRUCT);
void    HOST_EnableCtrl(HWND, UINT, BOOL);

enum
{
    CHANGE_UNSHARED = 0,
    CHANGE_SHARED,
    CHANGE_TOGGLE,
    CHANGE_ALLUNSHARED
};
void    HOST_ChangeShareState(HWND hwnd, UINT change);

void    HOST_FillList(HWND hwnd);
void    HOST_OnSelChange(HWND hwnd);



//
// Private messages to host dialog
//
enum
{
    HOST_MSG_OPEN = WM_APP,
    HOST_MSG_CLOSE,
    HOST_MSG_CALL,
    HOST_MSG_UPDATELIST,
    HOST_MSG_HOSTSTART,
    HOST_MSG_HOSTEND,
    HOST_MSG_ALLOWCONTROL,
    HOST_MSG_CONTROLLED
};


//
// Host dialog list item
//
typedef struct HOSTITEM
{
    HWND    hwnd;
    HICON   hIcon;
    BOOL    fShared:1;
    BOOL    fAvailable:1;
}
HOSTITEM, * PHOSTITEM;

#endif // DLL_CORE

//
// Hosting Property name
//
#define HET_ATOM_NAME               "MNMHosted"


//
// Property values, flags
//

//
// Here's the general idea with the following cases:
//
// An explictly shared process/thread
//      We enumerate all its top level windows, and mark the showing ones
//      with the VISIBLE option, which contributes to the hosted count,
//      and mark the hidden ones with the INVISIBLE option.  Those become
//      hosted VISIBLE the second they are shown.  They will always
//      be shared as long as they exist or the process/thread is shared.
//
//      From then on, we watch for CREATEs of new top level windows in the
//      same process, and mark them the same way.
//
//      On SHOWs, we change the state to visible, and update the visible
//      top level count.  On HIDEs, we change the state to invisible, and
//      update the visible top level count.  We wipe any properties off
//      real children to make sure that SetParent() of a top level window
//      (like OLE insitu) to a child doesn't keep garbage around.  We do
//      the opposite for children that have become top level, like tear off
//      toolbars.  On a SHOW, if there are other non-TEMPORARY hosted windows
//      in the same thread/process, we mark this dude as shared also.
//
// Unshared process/thread
//      On CREATE, if this is the first window in this thread/process, and
//      its parent process is shared (has at least one shared window of any
//      kind, temporary or invisible even, we mark this guy.  From then on,
//      it behaves like an explicitly shared process.
//
//      On SHOW, if this is a top level window, we look for any other window
//      visible on this thread which is shared.  If so, we show this one
//      TEMPORARILY also.  We also look at the owner of this window.  If
//      it is shared in any way, we also share this one TEMPORARILY.  When
//      TEMP shared, we enum all other windows in this thread and mark
//      the visible ones as TEMP shared also.  This takes care of the cached
//      global popup menu window case.
//
//      On HIDE, if this is TEMP shared, we unshare it.  This is only for
//      the BYWINDOW case.
//
// WINHLP32.EXE
//      Creation the first time works normally via task tracking.  But
//      if you have Help up in one app then go to another app, not shared,
//      and choose Help, it will come up shared there also.  WINHLP32 doesn't
//      go away, it keeps a couple invisible MS_ class windows around.  The
//      dialogs are destroyed.
//

//
// Classes to skip
//

// Flags:
#define HET_HOSTED_BYPROCESS    0x0010
#define HET_HOSTED_BYTHREAD     0x0020
#define HET_HOSTED_BYWINDOW     0x0040      // CURRENTLY ONLY FOR TEMPORARY

// Hosted types:
#define HET_HOSTED_PERMANENT    0x0001
#define HET_HOSTED_TEMPORARY    0x0002
#define HET_HOSTED_MASK         0x000F

// App types
#define HET_WOWVDM_APP          0x0001
#define HET_WINHELP_APP         0x0002      // Not used, but maybe someday

//
// NOTE that all HET_ property values are non-zero.  That way all possible
// permutations of known properties are non-zero.  Only windows with no
// property at all will get zero back from HET_GetHosting().
//


#if (defined(DLL_CORE) || defined(DLL_HOOK))

UINT_PTR __inline HET_GetHosting(HWND hwnd)
{
    extern ATOM g_asHostProp;

    return((UINT_PTR)GetProp(hwnd, MAKEINTATOM(g_asHostProp)));
}

BOOL __inline HET_SetHosting(HWND hwnd, UINT_PTR hostType)
{
    extern ATOM g_asHostProp;

    return(SetProp(hwnd, MAKEINTATOM(g_asHostProp), (HANDLE)hostType));
}


UINT_PTR __inline HET_ClearHosting(HWND hwnd)
{
    extern ATOM g_asHostProp;

    return((UINT_PTR)RemoveProp(hwnd, MAKEINTATOM(g_asHostProp)));
}

typedef struct tagGUIEFFECTS
{
    UINT_PTR            hetAdvanced;
    UINT_PTR            hetCursorShadow;
    ANIMATIONINFO   hetAnimation;
}
GUIEFFECTS;

void  HET_SetGUIEffects(BOOL fOn, GUIEFFECTS * pEffects);



#endif // DLL_CORE or DLL_HOOK


//
// Define escape codes
//

// These are normal
enum
{
    // These are normal
    HET_ESC_SHARE_DESKTOP       = OSI_HET_ESC_FIRST,
    HET_ESC_UNSHARE_DESKTOP,
    HET_ESC_VIEWER
};


// These are WNDOBJ_SETUP
enum
{
    HET_ESC_SHARE_WINDOW = OSI_HET_WO_ESC_FIRST,
    HET_ESC_UNSHARE_WINDOW,
    HET_ESC_UNSHARE_ALL
};



//
// Structure passed with a HET_ESC_SHARE_WINDOW request
//
typedef struct tagHET_SHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD_PTR           winID;          // window to share
    DWORD               result;         // Return code from HET_DDShareWindow
}
HET_SHARE_WINDOW;
typedef HET_SHARE_WINDOW FAR * LPHET_SHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_WINDOW request
//
typedef struct tagHET_UNSHARE_WINDOW
{
    OSI_ESCAPE_HEADER   header;
    DWORD_PTR               winID;          // window to unshare
}
HET_UNSHARE_WINDOW;
typedef HET_UNSHARE_WINDOW FAR * LPHET_UNSHARE_WINDOW;

//
// Structure passed with a HET_ESC_UNSHARE_ALL request
//
typedef struct tagHET_UNSHARE_ALL
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_ALL;
typedef HET_UNSHARE_ALL FAR * LPHET_UNSHARE_ALL;


//
// Structure passed with HET_ESC_SHARE_DESKTOP
//
typedef struct tagHET_SHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_SHARE_DESKTOP;
typedef HET_SHARE_DESKTOP FAR * LPHET_SHARE_DESKTOP;


//
// Structure passed with HET_ESC_UNSHARE_DESKTOP
//
typedef struct tagHET_UNSHARE_DESKTOP
{
    OSI_ESCAPE_HEADER   header;
}
HET_UNSHARE_DESKTOP;
typedef HET_UNSHARE_DESKTOP FAR * LPHET_UNSHARE_DESKTOP;


//
// Structure passed with HET_ESC_VIEWER
//
typedef struct tagHET_VIEWER
{
    OSI_ESCAPE_HEADER   header;
    LONG                viewersPresent;
}
HET_VIEWER;
typedef HET_VIEWER FAR * LPHET_VIEWER;



#ifdef DLL_DISP

#ifndef IS_16
//
// Number of rectangles allocated per window structure.  If a visible
// region exceeds that number, we will merge rects together and end up
// trapping a bit more output than necessary.
//
#define HET_WINDOW_RECTS        10


//
// HET's version of ENUMRECTS.  This is the same as Windows', except that
// it has HET_WINDOW_RECTS rectangles, not 1
//
typedef struct tagHET_ENUM_RECTS
{
    ULONG   c;                          // count of rectangles in use
    RECTL   arcl[HET_WINDOW_RECTS];     // rectangles
} HET_ENUM_RECTS;
typedef HET_ENUM_RECTS FAR * LPHET_ENUM_RECTS;

//
// The Window Structure kept for each tracked window
//
typedef struct tagHET_WINDOW_STRUCT
{
    BASEDLIST           chain;             // list chaining info
    HWND             hwnd;              // hwnd of this window
    WNDOBJ         * wndobj;            // WNDOBJ for this window
    HET_ENUM_RECTS   rects;             // rectangles
} HET_WINDOW_STRUCT;
typedef HET_WINDOW_STRUCT FAR * LPHET_WINDOW_STRUCT;


//
// Initial number of windows for which space is allocated
// We alloc about 1 page for each block of windows.  Need to account for
// the BASEDLIST at the front of HET_WINDOW_MEMORY.
//
#define HET_WINDOW_COUNT        ((0x1000 - sizeof(BASEDLIST)) / sizeof(HET_WINDOW_STRUCT))


//
// Layout of memory ued to hold window structures
//
typedef struct tagHET_WINDOW_MEMORY
{
    BASEDLIST              chain;
    HET_WINDOW_STRUCT   wnd[HET_WINDOW_COUNT];
} HET_WINDOW_MEMORY;
typedef HET_WINDOW_MEMORY FAR * LPHET_WINDOW_MEMORY;

#endif // !IS_16



#ifdef IS_16

void    HETDDViewing(BOOL fViewers);

#else

void    HETDDViewing(SURFOBJ *pso, BOOL fViewers);

BOOL    HETDDShareWindow(SURFOBJ *pso, LPHET_SHARE_WINDOW  pReq);
void    HETDDUnshareWindow(LPHET_UNSHARE_WINDOW  pReq);
void    HETDDUnshareAll(void);

BOOL    HETDDAllocWndMem(void);
void    HETDDDeleteAndFreeWnd(LPHET_WINDOW_STRUCT pWnd);

VOID CALLBACK HETDDVisRgnCallback(WNDOBJ *pwo, FLONG fl);
#endif


#endif // DLL_DISP




//
// HET_IsShellThread()
// HET_IsShellWindow()
// Returns TRUE if this window is in the thread of the tray or the desktop
// and therefore should be ignored.
//

BOOL HET_IsShellThread(DWORD dwThreadID);
BOOL HET_IsShellWindow(HWND hwnd);




#ifdef DLL_DISP

//
// INIT, TERM.  TERM is used to free the window list blocks when NetMeeting
// shuts down.  Otherwise that memory will stay allocated in the display
// driver forever.
//

void HET_DDTerm(void);


//
//
// Name:        HET_DDProcessRequest
//
// Description: Handle a DrvEscape request for HET
//
// Params:      pso   - pointer to a SURFOBJ
//              cjIn  - size of input buffer
//              pvIn  - input buffer
//              cjOut - size of output buffer
//              pvOut - output buffer
//
//
#ifdef IS_16

BOOL    HET_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

#else

ULONG   HET_DDProcessRequest(SURFOBJ  *pso,
                                        UINT cjIn,
                                        void *  pvIn,
                                        UINT cjOut,
                                        void *  pvOut);
#endif // IS_16


//
//
// Name:        HET_DDOutputIsHosted
//
// Description: determines whether a point is inside a hosted area
//
// Params:      pt - point to query
//
// Returns:     TRUE  - output is hosted
//              FALSE - output is not hosted
//
// Operation:
//
//
BOOL HET_DDOutputIsHosted(POINT pt);


//
//
// Name:        HET_DDOutputRectIsHosted
//
// Description: determines whether a rect intersects a hosted area
//
// Params:      pRect - rect to query
//
// Returns:     TRUE  - output is hosted
//              FALSE - output is not hosted
//
// Operation:
//
//
BOOL HET_DDOutputRectIsHosted(LPRECT pRect);

#endif // DLL_DISP


//
// Functions for window, task tracking (hook dll for NT, hook/dd for Win95)
//
void WINAPI HOOK_Init(HWND dcsCore, ATOM atom);     // NT only
void        HOOK_Load(HINSTANCE hInst);             // NT only
void        HOOK_NewThread(void);                   // NT only


typedef struct tagHET_SHARE_INFO
{
    int     cWnds;
    UINT    uType;
    DWORD   dwID;
} HET_SHARE_INFO, FAR* LPHET_SHARE_INFO;


void          HET_Clear(void);
BOOL CALLBACK HETShareCallback(HWND hwnd, LPARAM lParam);
BOOL CALLBACK HETUnshareCallback(HWND hwnd, LPARAM lParam);




#if defined(DLL_CORE) || defined(DLL_HOOK)

//
// HET_GetShellTray
//
__inline HWND HET_GetShellTray(void)
{
    #define HET_SHELL_TRAY_CLASS        "Shell_TrayWnd"

    return(FindWindow(HET_SHELL_TRAY_CLASS, NULL));
}


//
// HET_GetShellDesktop
//
__inline HWND HET_GetShellDesktop(void)
{
    return(GetShellWindow());
}

#endif // DLL_CORE || DLL_HOOK


//
// Functions in the Core Process DLL
//
BOOL CALLBACK HETUnshareAllWindows(HWND hwnd, LPARAM lParam);

BOOL CALLBACK HETRepaintWindow(HWND hwnd, LPARAM lParam);


//
// Internal Hook functions
//
#ifdef DLL_HOOK

BOOL HET_WindowIsHosted(HWND hwnd);

#ifdef IS_16
LRESULT CALLBACK HETEventProc(int, WPARAM, LPARAM);
LRESULT CALLBACK HETTrackProc(int, WPARAM, LPARAM);
#else


//
// The following definitions are taken from <ntddk.h> and <ntdef.h>.  They
// are required to make use of the <NtQueryInformationProcess> function
// in NTDLL.DLL.
//
typedef struct _PEB *PPEB;
typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;
typedef LONG KPRIORITY;
typedef LONG NTSTATUS;


//
// Types of Win Event hook/unhook functions
//
typedef HWINEVENTHOOK (WINAPI * SETWINEVENTHOOK)(
                                                DWORD        eventMin,
                                                DWORD        eventMax,
                                                HMODULE      hmodWinEventProc,
                                                WINEVENTPROC lpfnWinEventProc,
                                                DWORD        idProcess,
                                                DWORD        idThread,
                                                DWORD        dwFlags);

typedef BOOL (WINAPI * UNHOOKWINEVENT)(HWINEVENTHOOK hEventId);

//
// Process Information Classes
//
typedef enum _PROCESSINFOCLASS {
    ProcessBasicInformation,
    ProcessQuotaLimits,
    ProcessIoCounters,
    ProcessVmCounters,
    ProcessTimes,
    ProcessBasePriority,
    ProcessRaisePriority,
    ProcessDebugPort,
    ProcessExceptionPort,
    ProcessAccessToken,
    ProcessLdtInformation,
    ProcessLdtSize,
    ProcessDefaultHardErrorMode,
    ProcessIoPortHandlers,          // Note: this is kernel mode only
    ProcessPooledUsageAndLimits,
    ProcessWorkingSetWatch,
    ProcessUserModeIOPL,
    ProcessEnableAlignmentFaultFixup,
    ProcessPriorityClass,
    ProcessWx86Information,
    ProcessHandleCount,
    ProcessAffinityMask,
    ProcessPriorityBoost,
    MaxProcessInfoClass
    } PROCESSINFOCLASS;

//
// Basic Process Information
//  NtQueryInformationProcess using ProcessBasicInfo
//
typedef struct _PROCESS_BASIC_INFORMATION {
    NTSTATUS ExitStatus;
    PPEB PebBaseAddress;
    KAFFINITY AffinityMask;
    KPRIORITY BasePriority;
    ULONG UniqueProcessId;
    ULONG InheritedFromUniqueProcessId;
} PROCESS_BASIC_INFORMATION;
typedef PROCESS_BASIC_INFORMATION *PPROCESS_BASIC_INFORMATION;

//
// Declare our function prototype for <NtQueryInformationProcess>.
//
typedef NTSTATUS (NTAPI* NTQIP)(HANDLE ProcessHandle,
                                PROCESSINFOCLASS ProcessInformationClass,
                                void* ProcessInformation,
                                ULONG ProcessInformationLength,
                                PULONG ReturnLength);

//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//
#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)


//
// Name of the DLL containing <NtQueryInformationProcess>.
//
#define NTDLL_DLL       "ntdll.dll"


#define HET_MIN_WINEVENT        EVENT_OBJECT_CREATE
#define HET_MAX_WINEVENT        EVENT_OBJECT_HIDE


void CALLBACK HETTrackProc(HWINEVENTHOOK hEvent, DWORD event, HWND hwnd,
        LONG idObject, LONG idChild, DWORD dwThreadId, DWORD dwmsEventTime);

#endif // IS_16


void    HETHandleCreate(HWND);
void    HETHandleDestroy(HWND);
void    HETHandleShow(HWND, BOOL);
void    HETHandleHide(HWND);
void    HETCheckParentChange(HWND);

//
// We try to do just one enumerate (and stop as soon as we can) on events
// for purposes of speed.
//

BOOL CALLBACK HETShareEnum(HWND, LPARAM);

typedef struct tagHET_TRACK_INFO
{
    HWND    hwndUs;
#ifndef IS_16
    BOOL    fWOW;
#endif
    UINT    cWndsApp;
    UINT    cWndsSharedThread;
    UINT    cWndsSharedProcess;
    DWORD   idProcess;
    DWORD   idThread;
} HET_TRACK_INFO, FAR* LPHET_TRACK_INFO;

void    HETGetParentProcessID(DWORD processID, LPDWORD pParentProcessID);

void    HETNewTopLevelCount(void);
BOOL CALLBACK   HETCountTopLevel(HWND, LPARAM);
BOOL CALLBACK   HETUnshareWOWServiceWnds(HWND, LPARAM);


#endif // DLL_HOOK


BOOL WINAPI OSI_ShareWindow(HWND hwnd, UINT uType, BOOL fRepaint, BOOL fUpdateCount);
BOOL WINAPI OSI_UnshareWindow(HWND hwnd, BOOL fUpdateCount);

//
// OSI_StartWindowTracking()
// Called when we start sharing the very first app
//
BOOL WINAPI OSI_StartWindowTracking(void);


//
// OSI_StopWindowTracking()
// Called when we stop sharing the very last app
//
void WINAPI OSI_StopWindowTracking(void);


//
// Utility functions for windows
//
BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd);

#define GCL_WOWWORDS    -27
BOOL WINAPI OSI_IsWOWWindow(HWND hwnd);



#endif // _H_HET
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\fh.h ===
//
// Font Handler
//

#ifndef _H_FH
#define _H_FH


//
// This is needed to define LPCOM_ORDER
//
#include <oa.h>


//
// Constants.
//

//
// The sent ID field is set up when we copy fonts to send; if we don't send
// the font we set it to this value:
//
#define FONT_NOT_SENT  (-1)

//
// Because a font can match to font ID zero, actually having an explicit
// 'no match' constant acts as an extra 'firewall'.  The remote match array
// is of UINTs, so we have to make this constant positive...
//
#define NO_FONT_MATCH  (0xffff)

//
// This dummy font id is used instead of a remote ID of 0 when we need to
// distinguish between a remote ID of 0, and a remote ID that on conversion
// to local gives zero.
//
#define DUMMY_FONT_ID   0xFFFF



//
// Font Width Table type.
//
typedef struct tagFHWIDTHTABLE
{
    BYTE     charWidths[256];
} FHWIDTHTABLE, FAR * PFHWIDTHTABLE;

//
// The local font structure contains the extra info we need for font
// matching; we can't change the NETWORKFONT structure because we have to
// maintain back compatibility
//
// This comment is slight tosh.  We can and do change NETWORKFONT (though
// only in a carefully managed way!).  The point is that the data outside
// of the Details field is only needed locally - it is not transmitted
// across the wire.
//
// Note that in FH_Init, we do a qsort, which assumes
// that the first thing in the LOCALFONT structure is the facename.  So
// bear this in mind if you change it.  We assume that the NETWORKFONT
// structure will always start with the facename.
//
typedef struct _LOCALFONT
{
    NETWORKFONT Details;                  // old structure - sent over wire
    TSHR_UINT16 lMaxBaselineExt;          // max height of this font
    char        RealName[FH_FACESIZE];    // Real font name
    TSHR_UINT32 SupportCode;              // font is supported - see below
}
LOCALFONT;
typedef LOCALFONT FAR * LPLOCALFONT;

//
// The following values are set in the SupportCode field of the LOCALFONT
// structure to indicate whether a font is supported in the current
// share. The values are designed to make it easy to calculate the lowest
// common denominator of two support codes (l.c.d.  = code1 & code2).
//
// A SupportCode contains the bit flag
//    FH_SC_MATCH if it describes any sort of match at all
//    FH_SC_ALL_CHARS if the match applies to all characters in the font,
//        as opposed to just the ASCII alphanumeric characters
//    FH_SC_EXACT if the match is considered exact,
//        as opposed to an approximate match
//
//
#define FH_SC_MATCH            1
#define FH_SC_ALL_CHARS        2
#define FH_SC_EXACT            4

//
// Forget it: no viable match.
//
#define FH_SC_NO_MATCH 0

//
// Every char is a good but not exact match.
//
#define FH_SC_APPROX_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS)

//
// Every char is likely to be an accurate match.
//
#define FH_SC_EXACT_MATCH (FH_SC_MATCH | FH_SC_ALL_CHARS | FH_SC_EXACT)

//
// Chars 20->7F are likely to be an accurate match.
//
#define FH_SC_EXACT_ASCII_MATCH (FH_SC_MATCH | FH_SC_EXACT)

//
// Chars 20->7F are likely to be good but not exact matches.
//
#define FH_SC_APPROX_ASCII_MATCH (FH_SC_MATCH)



//
// Structures and typedefs.
//
// The FONTNAME structure is used for each entry in the array of font
// names.
//
typedef struct tagFONTNAME
{
    char        szFontName[FH_FACESIZE];
}
FONTNAME;
typedef FONTNAME FAR * LPFONTNAME;


//
// Maximum number of fonts that we can handle at all.
//
#define FH_MAX_FONTS \
    (((TSHR_MAX_SEND_PKT - sizeof(FHPACKET)) / sizeof(NETWORKFONT)) + 1 )

//
// Size of index into local font table
//
#define FH_LOCAL_INDEX_SIZE  256


typedef struct tagFHFAMILIES
{
    STRUCTURE_STAMP

    UINT        fhcFamilies;
    FONTNAME    afhFamilies[FH_MAX_FONTS];
}
FHFAMILIES;
typedef FHFAMILIES FAR * LPFHFAMILIES;



//
// Local font list
//
// NOTE: The font index is an array of bookmarks that indicate the first
// entry in the local font table that starts with a particular character.
// For example, afhFontIndex[65] gives the first index in afhFonts
// that starts with the character 'A'.
//
//
typedef struct tagFHLOCALFONTS
{
    STRUCTURE_STAMP

    UINT        fhNumFonts;
    TSHR_UINT16 afhFontIndex[FH_LOCAL_INDEX_SIZE];
    LOCALFONT   afhFonts[FH_MAX_FONTS];
}
FHLOCALFONTS;
typedef FHLOCALFONTS FAR * LPFHLOCALFONTS;




//
// FUNCTION: FH_GetFaceNameFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the face name of the font.
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// pFaceNameLength - pointer to variable to receive the length of the face
// name returned.
//
// RETURNS: pointer to face name.
//
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT  fontHandle,
                                                  LPUINT faceNameLength);

UINT FH_GetMaxHeightFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT FH_GetFontFlagsFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CharSet value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: CodePage
//
//
UINT FH_GetCodePageFromLocalHandle(UINT  fontHandle);

//
// FUNCTION: FH_Init
//
// DESCRIPTION:
//
// This routine finds all the fonts in the local system.  It is called from
// USR.
//
// PARAMETERS: VOID
//
// RETURNS: Number of fonts found
//
//
UINT FH_Init(void);
void FH_Term(void);


//
// API FUNCTION: FH_CreateAndSelectFont
//
// DESCRIPTION:
//
// Creates a logical font for the HPS/HDC supplied.
//
// PARAMETERS:
//
// surface - surface to create logical font for.
//
// pHNewFont - pointer to new font handle to use. This is returned.
//
// pHOldFont - pointer to old font handle (which was previously selected
// into the HPS or HDC).
//
// fontName - the facename of the font.
//
// codepage - codepage (though in most case just holds charset)
//
// fontMaxHeight - the max baseline extent of the font. (Do not confuse
// with fontHeight which is the cell height of the font).
//
// fontWidth,fontWeight,fontFlags - take the same values as the equivalent
// fields in a TEXTOUT or EXTTEXTOUT order.
//
// RETURNS: TRUE - success, FALSE - failure.
//
BOOL FH_CreateAndSelectFont(HDC    hdc,
                                         HFONT *        pHNewFont,
                                         HFONT *        pHOldFont,
                                         LPSTR        fontName,
                                         UINT         codepage,
                                         UINT         fontMaxHeight,
                                         UINT         fontHeight,
                                         UINT         fontWidth,
                                         UINT         fontWeight,
                                         UINT         fontFlags);


//
// API FUNCTION: FH_DeleteFont
//
// DESCRIPTION:
//
// Deletes/frees the supplied system font handle.
//
// PARAMETERS:
//
//  sysFontHandle - system font handle to delete/free
//
// RETURNS:
//
//  None
//
void FH_DeleteFont(HFONT hFont);

//
// API FUNCTION: FH_SelectFont
//
// DESCRIPTION:
//
// Selects a font identified by its system font handle into a surface.
//
// PARAMETERS:
//
//  surface - the surface to select the font into
//  sysFontHandle - system font handle
//
// RETURNS:
//
//  None
//
void FH_SelectFont(HDC hdc, HFONT hFont);


void FHAddFontToLocalTable( LPSTR  faceName,
                                         TSHR_UINT16 fontFlags,
                                         TSHR_UINT16 codePage,
                                         TSHR_UINT16 maxHeight,
                                         TSHR_UINT16 aveHeight,
                                         TSHR_UINT16 aveWidth,
                                         TSHR_UINT16 aspectX,
                                         TSHR_UINT16 aspectY,
                                         TSHR_UINT16 maxAscent);



void FHConsiderAllLocalFonts(void);

void FHSortAndIndexLocalFonts(void);

int  FHComp(LPVOID p1, LPVOID p2);
void FH_qsort(LPVOID base, UINT num, UINT size);

// prototypes UT_qsort routines
void shortsort(char *lo, char *hi, unsigned  width);
void swap(char *p, char *q, unsigned int width);

// this parameter defines the cutoff between using quick sort and
// insertion sort for arrays; arrays with lengths shorter or equal to the
// below value use insertion sort

#define CUTOFF 8


BOOL FHGenerateFontWidthTable(PFHWIDTHTABLE pTable,
                                           LPLOCALFONT    pFontInfo,
                                           UINT        fontHeight,
                                           UINT        fontWidth,
                                           UINT        fontWeight,
                                           UINT        fontFlags,
                                           LPTSHR_UINT16     pMaxAscent);

BOOL FHGetStringSpacing(UINT fontHandle,
                                     UINT fontHeight,
                                     UINT fontWidth,
                                     UINT fontWeight,
                                     UINT fontFlags,
                                     UINT stringLength,
                                     LPSTR string,
                                     LPTSHR_INT16 deltaXArray);

//
// FHCalculateSignatures - see fh.c.
//
void FHCalculateSignatures(PFHWIDTHTABLE  pTable,
                                        LPTSHR_INT16       pSigFats,
                                        LPTSHR_INT16       pSigThins,
                                        LPTSHR_INT16       pSigSymbol);

//
// Although wingdi.h defines the first two parameters for an ENUMFONTPROC
// as LOGFONT and TEXTMETRIC (thereby disagreeing with MSDN), tests show
// that the structures are actually as defined in MSDN (i.e.  we get valid
// information when accessing the extended fields)
//
int CALLBACK FHEachFontFamily(
                            const ENUMLOGFONT   FAR * enumlogFont,
                            const NEWTEXTMETRIC FAR * TextMetric,
                            int                       FontType,
                            LPARAM                    lParam);

int CALLBACK FHEachFont(const ENUMLOGFONT   FAR * enumlogFont,
                              const NEWTEXTMETRIC FAR * TextMetric,
                              int                       FontType,
                              LPARAM                    lParam);


#endif // _H_FH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ndcgver.h ===
//
// NDCGVER.H
// NM app sharing version for display driver/app checking
//
// Copyright (c) Microsoft 1997-
//
#define DCS_BUILD_STR "4.3.0."VERSIONBUILD_STR

#define DCS_BUILD_NUMBER    0

//
// This allows the ring 3 code and ring 0 code to check each other, make
// sure they are the same version.  We're changing setup and getting close
// to shipping version 2.0, we want to prevent weird faults and blue
// screens caused by mismatched components.  This is not something we will
// do forever.  When NT 5 is here, we'll dyna load and init our driver at
// startup and terminate it at shutdown.  But for now, since installing
// one of these beasts is messsy, an extra sanity check is a good thing.
//
#define DCS_PRODUCT_NUMBER  3               // Version 3.0 of NM
#define DCS_MAKE_VERSION()  MAKELONG(VERSIONBUILD, DCS_PRODUCT_NUMBER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\oa.h ===
//
// Order Accumulator
//

#ifndef _H_OA
#define _H_OA


#include <osi.h>

//
// Specific values for OSI escape codes
//
#define OA_ESC(code)                (OSI_OA_ESC_FIRST + code)
#define OA_ESC_FLOW_CONTROL         OA_ESC(0)


//
// Flow control constants for sizes/depths when slow, fast, etc.  The
// SLOW/FAST heap sizes are simply for spoiling.  OA_HEAP_MAX is really
// the size of the heap.
//
#define OA_FAST_HEAP                50000
#define OA_SLOW_HEAP                20000

//
// NOTE:  This is 64K - sizeof OA_SHARED_DATA header
//        If you add fields to header, subtract from this value
//
#define OA_HEAP_MAX                 65512

//
// Flow control constants for depth of order spoiling
//
#define OA_FAST_SCAN_DEPTH               50
#define OA_SLOW_SCAN_DEPTH              500


//
// Threshold for switching from FAST to SLOW order accum
//
#define OA_FAST_THRESHOLD           20000

//
// Value to indicate that you have reached the end of the order list
//
#define OA_NO_LIST          -1


#ifdef DLL_DISP

#define OA_SHM_START_WRITING    SHM_StartAccess(SHM_OA_DATA)
#define OA_SHM_STOP_WRITING     SHM_StopAccess(SHM_OA_DATA)

#define OA_FST_START_WRITING    SHM_StartAccess(SHM_OA_FAST)
#define OA_FST_STOP_WRITING     SHM_StopAccess(SHM_OA_FAST)

#else

#define OA_SHM_START_READING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_READING


#define OA_SHM_START_WRITING    g_poaData[\
        1 - g_asSharedMemory->displayToCore.newBuffer]
#define OA_SHM_STOP_WRITING


#define OA_FST_START_READING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_READING     


#define OA_FST_START_WRITING    &g_asSharedMemory->oaFast[\
        1 - g_asSharedMemory->fastPath.newBuffer]
#define OA_FST_STOP_WRITING     


#endif


//
// Maximum memory allowed for variable order data.
//
#define MAX_ADDITIONAL_DATA_BYTES 400000

//
// Invalid value to assign to deallocated order header pointers.
//
#define OA_DEAD_ORDER ((void FAR *)0xffffffff)

//
// Define the space to be reserved at the beginning of the segment
// for heap management.
//
#define RESERVED_HEAP_BYTES 16

//
// Define clip function return codes.
//
#define CR_NO_OVERLAP        1
#define CR_COMPLETE_OVERLAP  2
#define CR_SIMPLE_CLIP       3
#define CR_COMPLEX_OVERLAP   4
#define CR_COMPLEX_CLIP      5

//
// Macros that return the width and height of an order.
//
#define ORDER_WIDTH(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.right - \
                                pOrder->OrderHeader.Common.rcsDst.left + 1 )
#define ORDER_HEIGHT(pOrder) \
 ( pOrder->OrderHeader.Common.rcsDst.bottom - \
                                pOrder->OrderHeader.Common.rcsDst.top + 1 )

//
// Define the minimum width and height of an order for us to try to spoil
// previous orders with it.  This helps performance, because it saves us
// trying to spoil earlier orders with very small orders.  However, if the
// order exceeds the FULL_SPOIL values then we spoil as originally, with
// the proviso that flow control may still prevent it.
//
#define FULL_SPOIL_WIDTH  16
#define FULL_SPOIL_HEIGHT 16


//
// Define a macro that calculates whether a rectangle lies completely
// within another rectangle.
//
#define RECT1_WITHIN_RECT2(rect1, rect2)   \
        ( (rect1.left   >= rect2.left  ) &&    \
          (rect1.top    >= rect2.top   ) &&    \
          (rect1.right  <= rect2.right ) &&    \
          (rect1.bottom <= rect2.bottom) )



//
// Structure: OA_NEW_PARAMS
//
// Description:
//
// Structure to pass new OA parameters down to the display driver from the
// Share Core.
//
//

enum
{
    OAFLOW_FAST = 0,
    OAFLOW_SLOW
};

typedef struct tagOA_FLOW_CONTROL
{
    OSI_ESCAPE_HEADER   header;     // Common header
    DWORD               oaFlow;     // Type -- fast, slow, etc.
}
OA_FLOW_CONTROL;
typedef OA_FLOW_CONTROL FAR * LPOA_FLOW_CONTROL;

//
// Structure used to store orders in the shared memory
//
// totalHeapOrderBytes       - Total bytes used in the order heap
//
// totalOrderBytes           - Total bytes used by order data
//
// totalAdditionalOrderBytes - Total bytes used as additional order data
//
// nextOrder                 - Offset for start of next new order
//
// orderListHead             - Order list head (uses standard BASEDLIST
//                             manipulation code)
//
// orderHeap                 - Order heap
//
typedef struct tagOA_SHARED_DATA
{
    DWORD       totalHeapOrderBytes;
    DWORD       totalOrderBytes;
    DWORD       totalAdditionalOrderBytes;
    LONG        nextOrder;

    BASEDLIST      orderListHead;

    BYTE        orderHeap[OA_HEAP_MAX];
}
OA_SHARED_DATA;
typedef OA_SHARED_DATA FAR * LPOA_SHARED_DATA;

//
// Structure used to store orders in the shared memory
//
// ordersAccumulated         - number of orders accumulated in the heap
//                             since the last double buffer swap.
//
//
typedef struct tagOA_FAST_DATA
{
    DWORD     ordersAccumulated;
} OA_FAST_DATA;
typedef OA_FAST_DATA FAR * LPOA_FAST_DATA;


//
//
// INT_ORDER_HEADER
//
// This structure contains the Common header (containing the fields which
// are sent over the network) and some additional fields which are only
// used on the host side)
//
// list
//     Offset to next and previous orders in the list
//     This field does not need to be transmitted across the network.
//
// additionalOrderData
//     Offset to the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// cbAdditionalOrderData
//     Size of the additional data for this order.
//     This field does not need to be transmitted across the network.
//
// Common
//     Common header (which IS sent over the network)
//
// N.B.  If you change this structure, please make sure that you haven't
// broken the code in SBCInitInternalOrders.
//
//
typedef struct INT_ORDER_HEADER
{
    BASEDLIST              list;
    LONG                additionalOrderData;
    WORD                cbAdditionalOrderDataLength;
    WORD                pad1;
    COM_ORDER_HEADER    Common;
} INT_ORDER_HEADER;
typedef INT_ORDER_HEADER FAR *LPINT_ORDER_HEADER;


//
// Define an order with the internal only fields defined (this is only used
// on the sending end)
//
typedef struct _INT_ORDER
{
    INT_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
} INT_ORDER;
typedef INT_ORDER FAR *LPINT_ORDER;


// Structure: INT_COLORTABLE_ORDER_xBPP
//
// Description: Internal structures used to pass color table data to the
// share core.  These are never sent across the wire.
//
typedef struct tagINT_COLORTABLE_HEADER
{
    TSHR_UINT16    type;           // holds "CT" - INTORD_COLORTABLE
    TSHR_UINT16    bpp;            // 1, 4 or 8
} INT_COLORTABLE_HEADER, FAR * LPINT_COLORTABLE_HEADER;

typedef struct tagINT_COLORTABLE_ORDER_1BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[2];
} INT_COLORTABLE_ORDER_1BPP, FAR * LPINT_COLORTABLE_ORDER_1BPP;

typedef struct tagINT_COLORTABLE_ORDER_4BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[16];
} INT_COLORTABLE_ORDER_4BPP, FAR * LPINT_COLORTABLE_ORDER_4BPP;

typedef struct tagINT_COLORTABLE_ORDER_8BPP
{
    INT_COLORTABLE_HEADER   header;
    TSHR_RGBQUAD               colorData[256];
} INT_COLORTABLE_ORDER_8BPP, FAR * LPINT_COLORTABLE_ORDER_8BPP;



//
// Macro to calculate a basic internal order size (including the Order
// Header).
//
#define INT_ORDER_SIZE(pOrder) \
(pOrder->OrderHeader.Common.cbOrderDataLength + sizeof(INT_ORDER_HEADER))


//
// Macro to calculate the maximum possible size of an order, including
// any Additional Order Data.
//
#define MAX_ORDER_SIZE(pOrder) \
(INT_ORDER_SIZE(pOrder) + (pOrder->OrderHeader.cbAdditionalOrderDataLength))

//
// Macro to determine whether an order is SCRBLT_ORDER.
//
#define ORDER_IS_SCRBLT(pOrder) \
         (((LPSCRBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_SCRBLT))

//
// Macro to determine whether an order is MEMBLT_ORDER.
//
#define ORDER_IS_MEMBLT(pOrder) \
     (((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT) || \
      ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEMBLT_R2))

//
// Macro to determine whether an order is MEM3BLT_ORDER.
//
#define ORDER_IS_MEM3BLT(pOrder) \
    (((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT) || \
     ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->type == LOWORD(ORD_MEM3BLT_R2))



//
// PROTOTYPES
//

#ifdef DLL_DISP


//
// FUNCTION:      OA_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an OA specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL  OA_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
            DWORD cbResult);


//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength );

//
//
// OA_DDFreeOrderMem(..)
//
// Frees order memory allocated by OA_AllocOrderMem(..).
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
// Order memory is normally freed when the order is transmitted.
//
// This will be used if order memory has been allocated, and
// subsequently, before the order is passed to AddOrder(..), the
// allocator decides that the order should not be sent (e.g. if it
// is completely clipped out).
//
//
void OA_DDFreeOrderMem(LPINT_ORDER pOrder);

void OA_DDResetOrderList(void);

LPINT_ORDER OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder);

void OA_DDSyncUpdatesNow(void);

//
// Name:      OA_DDSpoilOrdersByRect
//
// Purpose:   Try to spoil orders by a given rectangle.
//
// Returns:   Nothing
//
// Params:    IN    pRect - Pointer to the spoiling rectangle
//
// Operation: This function will start at the end of the order heap (from
//            the newest order) and work towards the start of the heap.
//
void OA_DDSpoilOrdersByRect(LPRECT pRect);


//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completely covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo);


void     OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder);

LPINT_ORDER OADDAllocOrderMemInt(LPOA_SHARED_DATA lpoaShared, UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength);

void     OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder);

void     OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared);

BOOL     OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap);

void     OATrySpoilingByOrders(void);

void     OADDSpoilFromOrder(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder, LPRECT pRect);


#ifdef DEBUG
void    CheckOaHeap(LPOA_SHARED_DATA);
#else
#define CheckOaHeap(lpoaShared)
#endif

#endif // !DLL_DISP

#endif // _H_OA
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\im.h ===
//
// Input Manager
//

#ifndef _H_IM
#define _H_IM


#if defined(DLL_CORE) || defined(DLL_HOOK)

//
//
// CONSTANTS
//
//


//
// Values used when accumulating events to return from IEM_TranslateLocal
// and IEM_TranslateRemote.
//
#define IEM_EVENT_CTRL_DOWN         1
#define IEM_EVENT_CTRL_UP           2
#define IEM_EVENT_SHIFT_DOWN        3
#define IEM_EVENT_SHIFT_UP          4
#define IEM_EVENT_MENU_DOWN         5
#define IEM_EVENT_MENU_UP           6
#define IEM_EVENT_FORWARD           7
#define IEM_EVENT_CONSUMED          8
#define IEM_EVENT_REPLAY            9
#define IEM_EVENT_REPLAY_VK         10
#define IEM_EVENT_REPLAY_VK_DOWN    11
#define IEM_EVENT_REPLAY_VK_UP      12
#define IEM_EVENT_CAPS_LOCK_UP      13
#define IEM_EVENT_CAPS_LOCK_DOWN    14
#define IEM_EVENT_NUM_LOCK_UP       15
#define IEM_EVENT_NUM_LOCK_DOWN     16
#define IEM_EVENT_SCROLL_LOCK_UP    17
#define IEM_EVENT_SCROLL_LOCK_DOWN  18
#define IEM_EVENT_REPLAY_SPECIAL_VK 21
#define IEM_EVENT_EXTENDED_KEY      22
#define IEM_EVENT_REPLAY_SECONDARY  23
#define IEM_EVENT_SYSTEM            24
#define IEM_EVENT_NORMAL            25

#define IEM_EVENT_HOTKEY_BASE       50
//
// Range of hotkeys is 0 - 99
//
#define IEM_EVENT_KEYPAD0_DOWN      150
//
// Range of keypad down is 0-9
//
#define IEM_EVENT_KEYPAD0_UP        160

//
// The flags used in the return value from VkKeyScan.
//
#define IEM_SHIFT_DOWN              0x0001
#define IEM_CTRL_DOWN               0x0002
#define IEM_MENU_DOWN               0x0004


//
// Virtual key codes.
//
#define VK_INVALID      0xFF


//
// Given the keyboard packet flags the following macros tell us things
// about the key event.
//

//
// This is TRUE if this event is a key press.  It is FALSE for key releases
// and key repeats.
//
#define IS_IM_KEY_PRESS(A) \
(((A) & (TSHR_UINT16)(IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==0)

//
// This is TRUE if this event is a key release.  It is FALSE for key
// presses and key repeats.  Note that it is also TRUE for the
// theoretically impossible case of a key release when the key is already
// up (this combination could conceviably be generated if events are
// discarded by USER or our emulation of USER).
//
#define IS_IM_KEY_RELEASE(A) (((A) & IM_FLAG_KEYBOARD_RELEASE))

//
// This is TRUE if this event is a key repeat.  It is FALSE for key presses
// and key releases.
//
#define IS_IM_KEY_REPEAT(A) \
(((A) & (IM_FLAG_KEYBOARD_RELEASE | IM_FLAG_KEYBOARD_DOWN))==\
IM_FLAG_KEYBOARD_DOWN)

//
// This is TRUE if the key is the right-variant of a modifier.  It is FALSE
// otherwise.
//
#define IS_IM_KEY_RIGHT(A) (((A) & IM_FLAG_KEYBOARD_RIGHT))


//
// The maximum amount of time that we expect an injected event to take to
// pass through USER.
//
#define IM_EVENT_PERCOLATE_TIME 300

//
// Max VK sync attempts.
//
#define IM_MAX_VK_SYNC_ATTEMPTS     10

//
// Declare our function prototype for <ImmGetVirtualKey>.
//
typedef UINT (WINAPI* IMMGVK)(HWND);



//
//
// MACROS
//
//
//
// Macros to convert between logical mouse co-ordinates (e.g. (320,240) for
// the centre of a VGA screen to the full 16-bit range co-ordinates used
// by Windows (e.g. (320,240) is (32767, 32767).
//
#define IM_MOUSEPOS_LOG_TO_OS(coord, size)                                  \
        (((65535L * (TSHR_UINT32)coord) + 32768L) / (TSHR_UINT32)size)

//
// Macros extracting information from the mouse event flags field (event
// mask).
//
#define IM_MEV_MOVE_ONLY(e) ((e).event.mouse.flags == MOUSEEVENTF_MOVE)
#define IM_MEV_MOVE(e) (((e).event.mouse.flags & MOUSEEVENTF_MOVE) != 0 )
#define IM_MEV_ABS_MOVE(e) ((((e).event.mouse.flags &                   \
                 (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE)) ==             \
                             (MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE) ))
#define IM_MEV_BUTTON_DOWN(e) \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS) != 0 )
#define IM_MEV_BUTTON_UP(e)   \
           (((e).event.mouse.flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS) != 0 )

#define IM_EVMASK_B1_DOWN(m) (((m) & MOUSEEVENTF_LEFTDOWN)   != 0 )
#define IM_EVMASK_B1_UP(m)   (((m) & MOUSEEVENTF_LEFTUP)     != 0 )
#define IM_EVMASK_B2_DOWN(m) (((m) & MOUSEEVENTF_RIGHTDOWN)  != 0 )
#define IM_EVMASK_B2_UP(m)   (((m) & MOUSEEVENTF_RIGHTUP)    != 0 )
#define IM_EVMASK_B3_DOWN(m) (((m) & MOUSEEVENTF_MIDDLEDOWN) != 0 )
#define IM_EVMASK_B3_UP(m)   (((m) & MOUSEEVENTF_MIDDLEUP)   != 0 )

#define IM_MEV_BUTTON1_DOWN(e) (IM_EVMASK_B1_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON2_DOWN(e) (IM_EVMASK_B2_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON3_DOWN(e) (IM_EVMASK_B3_DOWN((e).event.mouse.flags))
#define IM_MEV_BUTTON1_UP(e) (IM_EVMASK_B1_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON2_UP(e) (IM_EVMASK_B2_UP((e).event.mouse.flags))
#define IM_MEV_BUTTON3_UP(e) (IM_EVMASK_B3_UP((e).event.mouse.flags))

#define IM_KEV_KEYUP(e)    ((e).event.keyboard.flags & KEYEVENTF_KEYUP)
#define IM_KEV_KEYDOWN(e)  (!IM_KEV_KEYUP(e))
#define IM_KEV_VKCODE(e)   ((e).event.keyboard.vkCode)

#define IM_MOUSEEVENTF_BASE_FLAGS  ( MOUSEEVENTF_MOVE       | \
                                     MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_CLICK_FLAGS ( MOUSEEVENTF_LEFTUP     | \
                                     MOUSEEVENTF_LEFTDOWN   | \
                                     MOUSEEVENTF_RIGHTUP    | \
                                     MOUSEEVENTF_RIGHTDOWN  | \
                                     MOUSEEVENTF_MIDDLEUP   | \
                                     MOUSEEVENTF_MIDDLEDOWN )


#define IM_MOUSEEVENTF_BUTTONDOWN_FLAGS ( MOUSEEVENTF_LEFTDOWN  |   \
                                          MOUSEEVENTF_RIGHTDOWN |   \
                                          MOUSEEVENTF_MIDDLEDOWN )

#define IM_MOUSEEVENTF_BUTTONUP_FLAGS ( MOUSEEVENTF_LEFTUP  |   \
                                        MOUSEEVENTF_RIGHTUP |   \
                                        MOUSEEVENTF_MIDDLEUP )



typedef struct tagKBDEV
{
    WORD    vkCode;
    WORD    scanCode;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
KBDEV, FAR *LPKBDEV;


typedef struct tagMSEV
{
    POINTL  pt;
    DWORD   cButtons;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    DWORD   dwExtraInfo;
}
MSEV, FAR *LPMSEV;


//
// The IMOSEVENTS which we queue as they arrive from the mouse or
// keyboard hooks or after IMINCOMINGEVENTS have been translated into local
// events by the IEM.
//
typedef struct tagIMOSEVENT
{
    TSHR_UINT32      type;
        #define IM_MOUSE_EVENT      1
        #define IM_KEYBOARD_EVENT   2

    TSHR_UINT32      flags;
        #define IM_FLAG_DONT_REPLAY     0x0001
        #define IM_FLAG_UPDATESTATE     0x0002

    TSHR_UINT32     time;
    union
    {
        MSEV    mouse;
        KBDEV   keyboard;
    }
    event;
}
IMOSEVENT;
typedef IMOSEVENT FAR * LPIMOSEVENT;




#define IM_TRANSFER_EVENT_BUFFER_SIZE   32
#define IM_MAX_TRANSFER_EVENT_INDEX     (IM_TRANSFER_EVENT_BUFFER_SIZE-1)


typedef struct tagIMTRANSFEREVENT
{
    LONG        fInUse;
    IMOSEVENT   event;
}
IMTRANSFEREVENT, FAR * LPIMTRANSFEREVENT;



//
// For handling keyboard events in hooks
//
#define IM_MASK_KEYBOARD_SYSFLAGS           0xE100
#define IM_MASK_KEYBOARD_SYSSCANCODE        0x00FF

#define IM_MAX_DEAD_KEYS                    20

#define IM_SIZE_EVENTQ                      40
#define IM_SIZE_OSQ                         80  // 2*EVENTQ size - key up/down

//
// Define the flags that can be returned by IMConvertIMPacketToOSEvent().
//
#define IM_IMQUEUEREMOVE    0x0001
#define IM_OSQUEUEINJECT    0x0002

//
// For managing our key state arrays.
//
#define IM_KEY_STATE_FLAG_TOGGLE    (BYTE)0x01
#define IM_KEY_STATE_FLAG_DOWN      (BYTE)0x80

//
// Bounds for local mouse spoiling and packet piggyback target withhold
// Note that these are local spoiling values, to prevent the data pipe from
// getting clogged and introducing unnecessary latency.  Now, you may think
// that 30 move messages per second is a little low, but put this up any
// higher and USER at the other end will just spoil them when it injects
// them into the app - that would be totally wasteful of precious bandwidth.
//
#define IM_LOCAL_MOUSE_SAMPLING_GAP_LOW_MS    100
#define IM_LOCAL_MOUSE_SAMPLING_GAP_MEDIUM_MS  75
#define IM_LOCAL_MOUSE_SAMPLING_GAP_HIGH_MS    50
#define IM_LOCAL_WITHHOLD_DELAY               150
#define IM_LOCAL_MOUSE_WITHHOLD                 5
#define IM_LOCAL_KEYBOARD_WITHHOLD              2

//
// For pacing the accumulation and injecting of mouse events.
// We should play back at the same rate as the highest local sampling rate
// less a small amount for processing delay on the remote system
//
#define IM_REMOTE_MOUSE_PLAYBACK_GAP_MS     20

//
// The amount of time to hold on to a mouse button down event in case a the
// user is just clicking on eg a scroll button.  If we did not hold on to
// the mouse button down event then the mouse button up would be sent in
// the next packet.  On a slow network this means the remote application
// may process the down period for much longer than the user wanted.
//
#define IM_MOUSE_UP_WAIT_TIME  50

#define IM_MIN_RECONVERSION_INTERVAL_MS     150


//
// #define used non-Windows to flag a VK code that equates to an ascii char
//
#define IM_TYPE_VK_ASCII       ((TSHR_UINT16)0x8880)


//
// Used for checking events about to be injected.
//
#define IM_KEY_IS_TOGGLE(A) \
(((A)==VK_CAPITAL)||((A)==VK_SCROLL)||((A)==VK_NUMLOCK))

#define IM_KEY_IS_MODIFIER(A) \
(((A)==VK_SHIFT)||((A)==VK_CONTROL)||((A)==VK_MENU))

//
// Used to check values in key state arrays.
//
#define IM_KEY_STATE_IS_UP(A) (!((A)&IM_KEY_STATE_FLAG_DOWN))
#define IM_KEY_STATE_IS_DOWN(A) ((A)&IM_KEY_STATE_FLAG_DOWN)

//
// Used to determine what sort of mouse event this is from the flags.
//
#define IM_IS_MOUSE_MOVE(A) \
    ((A) & IM_FLAG_MOUSE_MOVE)

#define IM_IS_MOUSE_PRESS(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && ((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_MOUSE_RELEASE(A) \
    ((!IM_IS_MOUSE_MOVE(A)) && !((A) & IM_FLAG_MOUSE_DOWN))

#define IM_IS_LEFT_CLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1))
#define IM_IS_LEFT_DCLICK(A) \
    (((A) & (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE)) == (IM_FLAG_MOUSE_DOWN | IM_FLAG_MOUSE_BUTTON1 | IM_FLAG_MOUSE_DOUBLE))



//
// Holds NETWORK events, to person controlled by us, or from person in control
// of us.
//
typedef struct tagIMEVENTQ
{
    DWORD           head;
    DWORD           numEvents;
    IMEVENT         events[IM_SIZE_EVENTQ];
}
IMEVENTQ;
typedef IMEVENTQ FAR * LPIMEVENTQ;


//
// Holds translated events, suitable for injection from person
// in control of us, or pre-translated events to person controlled by us.
//
typedef struct tagIMOSQ
{
    DWORD           head;
    DWORD           numEvents;
    IMOSEVENT       events[IM_SIZE_OSQ];
}
IMOSQ;
typedef IMOSQ FAR * LPIMOSQ;


#define CIRCULAR_INDEX(start, rel_index, size) \
    (((start) + (rel_index)) % (size))




//
// To support collaboration in both NT (background service thread) and Win95
// (win16 code) with as much of the common incoming/outgoing processing in
// one places, the IM data is separated into 4 types.  There are structures
// for each of these types, so that moving a variable from one to another
// is as easy as possible.  Note that the declarations are bitness-safe;
// they are the same size in 16-bit and 32-bit code.  And that the structures
// are DWORD aligned.
//
// (1) IM_SHARED_DATA
// This is data that both the CPI32 library needs to access, and one or
// more of the NT/Win95 implementations of collaboration.
//
// (2) IM_NT_DATA
// This is data that only the NT version of collaboration needs.
//
// (3) IM_WIN95_DATA
// This is data that only the Win95 version of collaboration needs.
//


//
// For NT, this shared structures is just declared in MNMCPI32.NT's data,
// and a pointer to it is used by the common lib.
//
// For Win95, this shared structure is allocated in a global memory block
// that can GlobalSmartPageLock() it as needed for access at interrupt time,
// and a pointer to it is mapped flat and returned to the common lib.
//
typedef struct tagIM_SHARED_DATA
{
#ifdef DEBUG
    DWORD           cbSize;         // To make sure everybody agrees on size
#endif

    //
    // For critical errors -- nonzero if one is up
    //
    DWORD           imSuspended;

    //
    // Control state
    //
    LONG            imControlled;
    LONG            imPaused;
    LONG            imUnattended;
}
IM_SHARED_DATA, FAR* LPIM_SHARED_DATA;


// NT specific IM state variables
typedef struct tagIM_NT_DATA
{
    //
    // Low level hook thread
    //
    DWORD           imLowLevelInputThread;

    //
    // Other desktop injection helper thread
    //
    DWORD           imOtherDesktopThread;

    //
    // Low level hook handles
    //
    HHOOK           imhLowLevelMouseHook;
    HHOOK           imhLowLevelKeyboardHook;
}
IM_NT_DATA, FAR* LPIM_NT_DATA;



// Win95 specific IM state variables
typedef struct tagIM_WIN95_DATA
{
    BOOL            imInjecting;
    BOOL            imLowLevelHooks;

    //
    // High level hook handles
    //
    HHOOK           imhHighLevelMouseHook;
}
IM_WIN95_DATA, FAR* LPIM_WIN95_DATA;



//
//
// MACROS
//
//
#define IM_SET_VK_DOWN(A) (A) |= (BYTE)0x80
#define IM_SET_VK_UP(A)   (A) &= (BYTE)0x7F
#define IM_TOGGLE_VK(A)   (A) ^= (BYTE)0x01

//
//
// PROTOTYPES
//
//


// NT only
BOOL WINAPI OSI_InstallHighLevelMouseHook(BOOL fOn);

BOOL WINAPI OSI_InstallControlledHooks(BOOL fOn, BOOL fDesktop);
void WINAPI OSI_InjectMouseEvent(DWORD flags, LONG x, LONG y,  DWORD mouseData, DWORD dwExtraInfo);
void WINAPI OSI_InjectKeyboardEvent(DWORD flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);
void WINAPI OSI_InjectCtrlAltDel(void);
void WINAPI OSI_DesktopSwitch(UINT from, UINT to);


//
// Internal Hook DLL functions.
//
#ifdef DLL_HOOK

#ifdef IS_16
BOOL    IM_DDInit(void);
void    IM_DDTerm(void);
#endif // IS_16

LRESULT CALLBACK IMMouseHookProc(int    code,
                                 WPARAM wParam,
                                 LPARAM lParam);

#endif // DLL_HOOK


#ifdef IS_16
void    IMCheckWin16LockPulse(void);
#else
DWORD   WINAPI IMLowLevelInputProcessor(LPVOID hEventWait);
DWORD   WINAPI IMOtherDesktopProc(LPVOID hEventWait);
LRESULT CALLBACK IMLowLevelMouseProc(int, WPARAM, LPARAM);
LRESULT CALLBACK IMLowLevelKeyboardProc(int, WPARAM, LPARAM);
#endif // IS_16

#endif // DLL_CORE or DLL_HOOK

#endif // _H_IM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\om.h ===
//
// Object Manager
//

#ifndef _H_OM
#define _H_OM



#include <gdc.h>
#include <ast120.h>

//
//
// CONSTANTS
//
//



//
// Function Profiles (apps)
//
#define OMFP_FIRST        0

typedef enum
{
    OMFP_AL = OMFP_FIRST,
    OMFP_OM,
    OMFP_WB,                  // For old whiteboard
    OMFP_MAX
}
OMFP;


//
// These are the corresponding strings (part of the protocol)
//
#define AL_FP_NAME                  "APP-LOAD-1.0"
#define OM_FP_NAME                  "OMCONTROL-1.0"
#define WB_FP_NAME                  "WHITEBOARD-1.0"



//
// ObMan clients
//
#define OMCLI_FIRST     0
typedef enum
{
    OMCLI_AL = OMCLI_FIRST,
    OMCLI_WB,
    OMCLI_MAX
}
OMCLI;


//
// ObMan workset groups
//
#define OMWSG_FIRST     0
typedef enum
{
    OMWSG_OM    = OMWSG_FIRST,
    OMWSG_AL,
    OMWSG_WB,
    OMWSG_MAX,
    OMWSG_MAXPERCLIENT
}
OMWSG;



//
// These are the corresponding strings (part of the protocol)
//
#define OMC_WSG_NAME            "OBMANCONTROL"
#define AL_WSG_NAME             "APP-LOADER"
#define WB_WSG_NAME             "WHITEBOARD"


//
// Specify this in place of a valid Domain handle to create/move a workset
// group outside of any calls:
//

#define OM_NO_CALL            NET_INVALID_DOMAIN_ID


//
//
// SYSTEM LIMITS
//
// These are limits imposed by the architecture/design of the system.
//
//

//
// Workset group names
//
// Workset groups names are null-terminated strings, up to 32 characters
// long (including the NULL character).  They are intended to be
// human-readable names, and must contain only ASCII characters between
// 0x2C and 0x5B.  This range includes all uppercase characters, all digits
// and certain punctuation marks.
//

#define OM_MAX_WSGROUP_NAME_LEN          32

//
// Function Profile names
//
// Function profile names must be no longer than 16 characters (including
// the NULL character).  The range of characters allowable is the same as
// for workset group names.
//

#define OM_MAX_FP_NAME_LEN               16


//
// Maximum number of changes allowed to a workset
//
// Each time a workset is changed, we increment its "generation number",
// which is used in resequencing operations.  The largest size for an
// integer is 32 bits, so the maximum generation number using a convenient
// type is 2^32-1.
//
//

#define OM_MAX_GENERATION_NUMBER         0xffffffff

//
// Maximum size of an object
//
// This derives from the maximum size of a huge memory block under Windows
// (16MB less 64KB):
//

#define OM_MAX_OBJECT_SIZE               ((UINT) (0x1000000 - 0x10000))

//
// Maximum update size of an object
//
// This derives from the necessity to send updates atomically in one
// network packet (see SFR 990)
//

#define OM_MAX_UPDATE_SIZE               ((UINT) (0x00001f00))

//
// Maximum number of worksets per workset group
//
// This derives from the desire to make workset IDs 8-bit quantities so
// that they can fit in DC-Groupware events with a workset group handle and
// an object ID:
//
// Note: this value must be at most 255 so that certain ObMan for-loops
//       don't cycle for ever.
//

#define OM_MAX_WORKSETS_PER_WSGROUP         255

//
// Maximum number of workset groups per Domain
//
// This derives from the use of the ObManControl workset group: it has one
// control workset and then one workset for each workset group in the
// Domain, so there can only be this many workset groups in a Domain:
//
// Note: this number must be at most one less that
//       OM_MAX_WORKSETS_PER_WSGROUP
//

#define OM_MAX_WSGROUPS_PER_DOMAIN          64


//
// Special WSGROUPID for OMC:
//
#define WSGROUPID_OMC           0

//
//
// RETURN CODES
//
// Return codes are defined relative to the OM_BASE_RC base
//
//

enum
{
    OM_RC_NO_MORE_HANDLES = OM_BASE_RC,
    OM_RC_WORKSET_DOESNT_EXIST,
    OM_RC_WORKSET_EXHAUSTED,
    OM_RC_OBJECT_DELETED,
    OM_RC_BAD_OBJECT_ID,
    OM_RC_NO_SUCH_OBJECT,
    OM_RC_WORKSET_LOCKED,
    OM_RC_TOO_MANY_CLIENTS,
    OM_RC_TOO_MANY_WSGROUPS,
    OM_RC_ALREADY_REGISTERED ,
    OM_RC_CANNOT_MOVE_WSGROUP,
    OM_RC_LOCAL_WSGROUP,
    OM_RC_ALREADY_IN_CALL,
	OM_RC_NOT_ATTACHED,
    OM_RC_WORKSET_ALREADY_OPEN,
    OM_RC_OUT_OF_RESOURCES,
    OM_RC_NETWORK_ERROR,
    OM_RC_TIMED_OUT,
    OM_RC_NO_PRIMARY,
    OM_RC_WSGROUP_NOT_FOUND,
    OM_RC_WORKSET_NOT_FOUND,
    OM_RC_OBJECT_NOT_FOUND,
    OM_RC_WORKSET_LOCK_GRANTED,
    OM_RC_SPOILED,
    OM_RC_RECEIVE_CB_NOT_FOUND,
    OM_RC_OBJECT_PENDING_DELETE,
    OM_RC_NO_NODES_READY,
    OM_RC_BOUNCED
};


//
// Setting defaults
//
#define OM_LOCK_RETRY_COUNT_DFLT            10

#define OM_LOCK_RETRY_DELAY_DFLT            1000

#define OM_REGISTER_RETRY_COUNT_DFLT        40

#define OM_REGISTER_RETRY_DELAY_DFLT        5000

//
// This is the number of bytes we zero at the start of each object
// allocated.  It must be less than DCMEM_MAX_SIZE, since ObjectAlloc
// assumes that this many bytes at the start of an object are all in the
// same segment.
//

#define OM_ZERO_OBJECT_SIZE               0x400


//
// EVENTS
// Public then Internal
//

enum
{
    OM_OUT_OF_RESOURCES_IND = OM_BASE_EVENT,
    OM_WSGROUP_REGISTER_CON,
    OM_WSGROUP_MOVE_CON,
    OM_WSGROUP_MOVE_IND,
    OM_WORKSET_OPEN_CON,
    OM_WORKSET_NEW_IND,
    OM_WORKSET_LOCK_CON,
    OM_WORKSET_UNLOCK_IND,
    OM_WORKSET_CLEAR_IND,
    OM_WORKSET_CLEARED_IND,
    OM_OBJECT_ADD_IND,
    OM_OBJECT_MOVE_IND,
    OM_OBJECT_DELETE_IND,
    OM_OBJECT_REPLACE_IND,
    OM_OBJECT_UPDATE_IND,
    OM_OBJECT_LOCK_CON,
    OM_OBJECT_UNLOCK_IND,
    OM_OBJECT_DELETED_IND,
    OM_OBJECT_REPLACED_IND,
    OM_OBJECT_UPDATED_IND,
    OM_PERSON_JOINED_IND,
    OM_PERSON_LEFT_IND,
    OM_PERSON_DATA_CHANGED_IND,

    OMINT_EVENT_LOCK_TIMEOUT,
	OMINT_EVENT_SEND_QUEUE,
	OMINT_EVENT_PROCESS_MESSAGE,
	OMINT_EVENT_WSGROUP_REGISTER,
    OMINT_EVENT_WSGROUP_MOVE,
	OMINT_EVENT_WSGROUP_REGISTER_CONT,
	OMINT_EVENT_WSGROUP_DEREGISTER,
	OMINT_EVENT_WSGROUP_DISCARD
};




//
// Data transmission constants:
//

#define OM_NET_MAX_TRANSFER_SIZE             60000

//
// These constants identify the types of network buffer pools we use:
//

#define OM_NET_OWN_RECEIVE_POOL              1
#define OM_NET_OMC_RECEIVE_POOL              2
#define OM_NET_WSG_RECEIVE_POOL              3
#define OM_NET_SEND_POOL                     4

//
// These constants are the sizes of the receive pools for each priority and
// for each type of channel we join:
//

#define OM_NET_RECEIVE_POOL_SIZE             0x00002000

#define OM_NET_OWN_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OWN_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_OMC_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_OMC_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_WSG_RECEIVE_POOL_TOP          OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_HIGH         OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_MEDIUM       OM_NET_RECEIVE_POOL_SIZE
#define OM_NET_WSG_RECEIVE_POOL_LOW          OM_NET_RECEIVE_POOL_SIZE

#define OM_NET_SEND_POOL_SIZE                0x00004000

#define OM_NET_SEND_POOL_TOP                 OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_HIGH                OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_MEDIUM              OM_NET_SEND_POOL_SIZE
#define OM_NET_SEND_POOL_LOW                 OM_NET_SEND_POOL_SIZE

//
// These constants are used to decide what priority to send data transfers
// at when a Client has specified OBMAN_CHOOSES_PRIORITY for the workset:
//
#define OM_NET_HIGH_PRI_THRESHOLD            0x0100
#define OM_NET_MED_PRI_THRESHOLD             0x1000

#define OM_CHECKPOINT_WORKSET                OM_MAX_WORKSETS_PER_WSGROUP



//
//
// DATA STRUCTURES
//
// This section defines the main data structures of the ObMan API.
//
//


typedef struct tagOM_CLIENT *        POM_CLIENT;
typedef struct tagOM_PRIMARY *          POM_PRIMARY;


// Client objects are record pointers
typedef struct tagOM_OBJECT *           POM_OBJECT;
typedef struct tagOM_WSGROUP *          POM_WSGROUP;
typedef struct tagOM_DOMAIN *           POM_DOMAIN;


//
// ObMan correlators
//
typedef WORD    OM_CORRELATOR;


//
// Workset ID
//
// Within a workset group, worksets are identified by an 8-bit ID.
//

typedef BYTE                              OM_WSGROUP_HANDLE;

typedef BYTE                              OM_WORKSET_ID;
typedef OM_WORKSET_ID *                  POM_WORKSET_ID;

//
// Object structure
//
// Objects and object pointers are defined as follows:
//

typedef struct tagOM_OBJECTDATA
{
   TSHR_UINT32      length;      // length of the data field
   BYTE             data[1];     // object data, uninterpreted by ObMan;
                                  // in reality, not 1 byte but <length>
                                  // bytes long
}
OM_OBJECTDATA;
typedef OM_OBJECTDATA *             POM_OBJECTDATA;
typedef POM_OBJECTDATA *            PPOM_OBJECTDATA;

//
// Note that the maximum permitted size of an object, INCLUDING the
// <length> field, is 16MB less 64KB.
//

void __inline ValidateObjectData(POM_OBJECTDATA pData)
{
    ASSERT(!IsBadWritePtr(pData, sizeof(OM_OBJECTDATA)));
    ASSERT((pData->length > 0) && (pData->length < OM_MAX_OBJECT_SIZE));
}


//
// Object IDs
//
// Internally, object IDs are a combination of a network ID and a four-byte
// sequence counter:
//

typedef struct tagOM_OBJECT_ID
{
    TSHR_UINT32     sequence;
    NET_UID         creator;       // MCS user ID of node which created it
    WORD            pad1;
} OM_OBJECT_ID;
typedef OM_OBJECT_ID *             POM_OBJECT_ID;



//
// Partitioning of the first parameter on an event for INDICATION events
//

typedef struct tagOM_EVENT_DATA16
{
    OM_WSGROUP_HANDLE   hWSGroup;
    OM_WORKSET_ID       worksetID;
}
OM_EVENT_DATA16;
typedef OM_EVENT_DATA16 *  POM_EVENT_DATA16;

//
// Partitioning of the second parameter on an event for CONFIRM events
//

typedef struct tagOM_EVENT_DATA32
{
    WORD                result;
    OM_CORRELATOR       correlator;
}
OM_EVENT_DATA32;
typedef OM_EVENT_DATA32 *  POM_EVENT_DATA32;



//
//
// OBMANCONTROL
//
// This section describes the ObManControl Function Profile, as used by the
// Object Manager.
//
//


//
//
// DESCRIPTION
//
// In addition to the purely local records of workset groups, all instances
// of ObMan attached to a given Domain jointly maintain a control workset
// group containing
//
// - one workset (workset #0) listing the name, Function Profile, ID
//   and MCS channel of each of the "standard" workset groups in
//   the Domain, as well as the MCS user IDs of all the instances of ObMan
//   in the Domain
//
// - one "registration workset" per workset group (worksets #1-#255)
//   listing the MCS user IDs of the instances of ObMan which have one or
//   more local Clients registered with the workset group.
//
// Creating a new workset group in a Domain causes ObMan to
//
// - add a new identification object to workset #0 and
//
// - create a new registration workset
//
// Registering with a workset group causes ObMan to
//
// - add a registration object to the appropriate registration workset.
//

//
//
// USAGE
//
// ObMan Clients can register with the ObManControl workset group, and then
// open and examine the contents of workset #0 to discover the names and
// Function Profiles of all the workset groups existing in a Domain.
//
// ObMan Clients must not attempt to lock or change the contents of this
// workset group in any way.
//
//

//
//
// OBJECT DEFINITIONS
//
// This section provides the definitions for the objects contained in the
// worksets of the ObManControl workset group.
//
//


typedef BYTE                        OM_WSGROUP_ID;
typedef OM_WSGROUP_ID *            POM_WSGROUP_ID;


//
//
// WORKSET GROUP IDENTIFICATION OBJECT
//
// This structure identifies a workset within a Domain.  Objects of this
// form reside in workset #0 of ObManControl, known as the INFO workset.
//
//

#define OM_INFO_WORKSET             ((OM_WORKSET_ID) 0)

//
// NET PROTOCOL
//
typedef struct
{
   TSHR_UINT32          length;           // size of this structure, less four
                                       // bytes (for length field itself)

   DC_ID_STAMP       idStamp;          // == OM_WSGINFO_ID_STAMP

   NET_CHANNEL_ID    channelID;        // workset group's MCS channel

   NET_UID           creator;          // NET user ID of instance of ObMan
                                       // which created workset group

   OM_WSGROUP_ID     wsGroupID;        // Domain-unique ID
    BYTE pad1;
    WORD pad2;

   char            functionProfile[ OM_MAX_FP_NAME_LEN ];

                                       // function profile

   char            wsGroupName[ OM_MAX_WSGROUP_NAME_LEN ];

                                       // Client-supplied name
}
OM_WSGROUP_INFO;
typedef OM_WSGROUP_INFO *         POM_WSGROUP_INFO;

#define OM_WSGINFO_ID_STAMP            DC_MAKE_ID_STAMP('O', 'M', 'W', 'I')

void __inline ValidateObjectDataWSGINFO(POM_WSGROUP_INFO pInfoObj)
{
    ValidateObjectData((POM_OBJECTDATA)pInfoObj);
    ASSERT(pInfoObj->idStamp == OM_WSGINFO_ID_STAMP);
}


//
//
// WORKSET GROUP REGISTRATION OBJECTS
//
// This structure identifies a node's usage of a workset group.  These
// objects can reside in any ObManControl workset.
//
// In the case of workset #0, these objects identify a node's usage of the
// ObManControl workset group itself.  Since all instances of ObMan in a
// Domain are use the ObManControl workset group, the registration objects
// in workset #0 form a complete list of all the instances of ObMan in a
// Domain.
//
//

//
// NET PROTOCOL
//
typedef struct
{
   TSHR_UINT32          length;           // size of this structure, less four
                                       // bytes (for length field itself)

   DC_ID_STAMP       idStamp;          // == OM_WSGREGREC_ID_STAMP

   NET_UID           userID;           // user ID of ObMan to which the
                                       // object relates
   TSHR_UINT16          status;           // see below for status values

   TSHR_PERSON_DATA   personData;
}
OM_WSGROUP_REG_REC;
typedef OM_WSGROUP_REG_REC *      POM_WSGROUP_REG_REC;

#define OM_WSGREGREC_ID_STAMP          DC_MAKE_ID_STAMP('O', 'M', 'R', 'R')


void __inline ValidateObjectDataWSGREGREC(POM_WSGROUP_REG_REC pRegObject)
{
    ValidateObjectData((POM_OBJECTDATA)pRegObject);
    ASSERT(pRegObject->idStamp == OM_WSGREGREC_ID_STAMP);
}


//
// Value for <status> field:
//

#define CATCHING_UP     1
#define READY_TO_SEND   2



//
//
// LATE JOINER PROTOCOL
//
// If a Client registers with a workset group which already exists
// elsewhere in the Domain, that Client is considered a late joiner for
// that workset group.  The protocol for bringing late joiners up to date
// is as follows (except where explicitly stated, "ObMan" means "the local
// instance of ObMan"):
//
// OVERVIEW
//
// A late-joiner node asks another "helper" node for a copy of the workset
// group.  The helper node broadcasts a low-priority sweep message to all
// other nodes in the call and when it has received their replies, sends
// what it believes to be the current copy of the workset to the
// late-joiner.
//
// DETAILS
//
// At the local node, ObMan
//
// 1.  locks the ObManControl workset group (one effect of this is that no
//     other ObMan in the Domain will discard any workset groups it has
//     local copies of)
//
// 2.  examines the ObManControl workset group to determine
//
//     - the MCS channel ID for the workset group
//
//     - the MCS user ID of an instance of ObMan which has a copy of the
//       workset group
//
// 3.  requests to join the workset group channel
//
// 4.  waits for the join to succeed
//
// 5.  sends an OMNET_WSGROUP_SEND_REQ at high priority on the user ID
//     channel of that instance of ObMan, known as the "helper"
//
// 6.  broadcasts an OMNET_WORKSET_UNLOCK message at low priority to unlock
//     the ObManControl workset group (on the ObManControl channel)
//
// At the helper node, ObMan
//
// 7.  receives the OMNET_WSGROUP_SEND_REQ
//
// 8.  marks its copy of the workset group as non-discardable
//
// 9.  examines the ObManControl workset to determine the MCS user IDs
//     of the remote instances of ObMan which already have copies
//     of the workset group
//
// 10.  broadcasts an OMNET_WSGROUP_SWEEP_REQ message on the workset group
//      channel at high priority
//
// At each of the nodes queried in step 10, ObMan
//
// 11.  receives the OMNET_WSGROUP_SWEEP_REQ
//
// 12.  sends an OMNET_WSGROUP_SWEEP_REPLY message to the helper node at
//      low priority
//
// Back at the helper node, ObMan
//
// 13.  records each OMNET_WSGROUP_SWEEP_REPLY until all have been
//      received*
//
// 14.  sends one OMNET_WORKSET_NEW message for each workset in the workset
//      group (on the late-joiners single-member channel)
//
// 15.  sends an OMNET_OBJECT_ADD message for each object in each workset,
//      again on the late-joiner's single member channel
//
// 16.  sends an OMNET_WSGROUP_SEND_COMPLETE to the late-joiner; this
//      message serves as a back marker for the late-joiner so that it
//      knows when it has caught up with the state of the workset group as
//      it was when it joined
//
// ASSUMPTIONS
//
// This protocol relies on the following assumptions:
//
// - The helper node receives the OMNET_WSGROUP_SEND_REQ message before
//   the OMNET_WORKSET_UNLOCK message (as otherwise there is a window
//   where its copy of the workset group may be discarded).
//
//   This assumption is based on the fact that low-priority MCS data does
//   not overtake high priority MCS data sent from the same node EVEN ON
//   DIFFERENT CHANNELS.
//
//   If this assumption proves invalid then either
//
//   - the OMNET_WSGROUP_SEND_REQ message must be acknowledged before the
//     late joiner can unlock the ObManControl workset, or
//
//   - the OMNET_WSGROUP_SEND_REQ must be sent on the ObManControl
//     broadcast channel, with an extra field indicating the node for which
//     it is intended.
//
// - Any data received at the helper node after stage 14 begins is
//   forwarded by MCS to the late-joiner.
//
//   This assumption is based on the fact that the late-joiner is marked
//   at the helper's MCS system as joined to the relevant channel before
//   stage 14 begins.  MCS guarantees that once a NET_CHANNEL_JOIN_IND has
//   been received locally, the MCS system at every other node in the
//   Domain is aware that the late-joiner has joined the channel.
//
// Note that in R1.1, the helper node will discover, at step 9, that there
// are no other nodes in the Domain.  Therefore, steps 10-13 are eliminated
// i.e.  the helper sends its copy of the workset as soon as it receives
// the request from the late-joiner.
//
// This is a major simplification and the code to implement these steps is
// not to be included in R1.1.
//
// * The glib "until all have been received" condition is actually
//   difficult to implement since nodes may disappear while the helper is
//   waiting.  The solution to this is deferred to R2.0 (but see section on
//   locking for suggested implementation).
//
//

//
//
// WORKSET LOCKING PROTOCOL
//
// In what follows, the "state" refers to the lock state of the workset, as
// stored in the workset record.
//
// At the locking node, ObMan does the following:
//
// 1.  if the state is LOCK_GRANTED, post FAILURE then quit
//
// 2.  examine the workset in ObManControl which corresponds to the
//     workset group containing the workset to be locked, to determine the
//     IDs of the other nodes which are in using the workset group (at most
//     1 node in R1.1); put these IDs in a list of "expected respondents"
//     (Note: do not include own ID in this list)
//
// 3.  if this list is empty, we have succeeded so post SUCCESS and quit
//
// 4.  else broadcast an OMNET_WORKSET_LOCK_REQ message on the workset
//     group channel (i.e.  to each of these nodes)
//
// 5.  set the workset state to LOCKING and post a delayed
//     OMINT_EVENT_LOCK_TIMEOUT event
//
// At the other node(s), ObMan does the following:
//
// 6.  receive the OMNET_WORKSET_LOCK_REQ message from the locking node
//
// 7.  examine its current workset state
//
// 8.  if it is LOCK_REQUESTED and the MCS user ID of the locking node is
//     less than that of the current node, goto DENY
//
// 9.  else, goto GRANT
//
// DENY:
//
// 10.  send an OMNET_WORKSET_LOCK_DENY message to the locking node
//
// GRANT:
//
// 11.  if the state if LOCKING, then we are giving the lock to a higher
//      "priority" ObMan even though we wanted it ourselves, so post
// FAILURE
//      locally (continue to 12)
//
// 12.  set the state to LOCK_GRANTED
//
// 13.  send an OMNET_WORKSET_LOCK_GRANT message to the locking node
//
// Back at the locking node, one of the following happens:
//
//  ObMan receives an OMNET_WORKSET_LOCK_GRANT message
//
//        it then deletes the ID of the node which sent it from the list of
//        expected respondents
//
//        if this list is now empty, all nodes have replied so post SUCCESS
//        to Client
//
// OR
//
//  ObMan receives an OMNET_WORKSET_LOCK_DENY message
//
//        if the state is LOCKING, set it to READY, post FAILURE and quit
//
//        if the state is anything else, this reply has come too late
//        (we've timed out) so ignore it
//
// OR
//
//  ObMan receives the OMINT_EVENT_LOCK_TIMEOUT event
//
//        if the state is not LOCKING, the lock has succeeded so ignore the
//        timeout
//
//        otherwise, ObMan checks the ObManControl workset as in step 2 to
//        see if any nodes still on the expected respondents list have in
//        fact disappeared; if so post SUCCESS
//
//        else post FAILURE.
//
//
//
// The state machine for the locking process is as follows (R1.1 version):
//
//                         |---------+-----------+---------+--------------|
//                         |UNLOCKED | LOCKING   | LOCKED  | LOCK_GRANTED |
//                         |   1     |    2      |   3     |      4       |
//                         |---------+-----------+---------+--------------|
// WorksetLock()           |broadcast|   FAIL    |  FAIL   |     FAIL     |
//                         |LOCK_REQ,|           |         |              |
//                         | ->2     |           |         |              |
//                         |---------+-----------+---------+--------------|
// WorksetUnlock()         |   X     |broadcast UNLOCK, ->1|      X       |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_REQ  |reply    |compare    |reply    |      -       |
//                         |GRANT,   |MCS IDs:   |DENY     |              |
//                         | ->4     |if we're   |         | (in R1.1,    |
//                         |         |greater,   |         | this should  |
//                         |         |reply DENY |         | be an error) |
//                         |         |else reply |         |              |
//                         |         |GRANT, ->4 |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_GRANT|   -     |SUCCESS,   |   -     |     -        |
//                         |         | ->3       |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_LOCK_DENY |   -     |FAIL, ->1  |   X     |     -        |
//                         |         |           |         |              |
//                         |---------+-----------+---------+--------------|
// OMINT_EVENT_LOCK_TIMEOUT      |   -     |if other   |   -     |     -        |
//                         |         |box gone,  |         |              |
//                         |         |SUCCESS,   |         |              |
//                         |         |->3, else  |         |              |
//                         |         |FAIL, ->1  |         |              |
//                         |---------+-----------+---------+--------------|
// OMNET_WORKSET_UNLOCK    |   -     |    -      |   X     |     ->1      |
//                         |---------+-----------+---------+--------------|
//
//
// where 'X' indicates an error condition and '-' indicates that the event
// or message is ignored.
//
//

//
//
// NOTES FOR R2.0 WORKSET LOCKING
//
// 1.  If A tries to lock a workset and B grants the lock but C denies it,
//     B will think that A has the lock.  A has to broadcast an unlock,
//     or else B has to realise that the conflict will be resolved in
//     favour of C over A.
//
//


//
//
// DATA PROPAGATION and FLOW NOTIFICATION PROTOCOL
//
// When a local Client adds an object to a workset, or replaces or updates
// an existing object in a workset, ObMan broadcasts an appropriate
// OMNET_...  message on the workset group channel.
//
// This header message identifies the object and the type of operation to
// be performed.  It also includes a correlator value and the total size of
// the data to be sent in the following data packets.
//
// After sending the header, ObMan broadcasts one or more
// OMNET_GENERIC_DATA packets on the same channel.  These packets, which
// are of arbitrary size, all contain the same correlator value as was
// included in the header packet.
//
// No sequence numbers are included as MCS guarantees that data packets
// sent at the same priority on the same channel from the same node will
// arrive at all other nodes in the sequence in which they were sent.
//
// It is the responsibility of the receiving node to detect when all data
// packets have arrived and then to insert, update or replace the object in
// the local copy of the workset.
//
// In addition, the receiving node, on receipt of EACH data packet sends a
// data acknowledgment message (OMNET_DATA_ACK) to the sending node (on its
// single-user channel), indicating the number of bytes received in that
// data packet.
//
//

//
//
// STANDARD OPERATION BROADCAST PROTOCOL
//
// When a local Client deletes or moves an object in a workset, or clears
// or creates a workset, ObMan broadcasts a single uncorrelated operation
// packet on the workset group channel.
//
// It is the responsibility of the receiving node to implement the
// operation locally.
//
//

//
//
// OPERATION SEQUENCING AND RESEQUENCING
//
// In order to consistently sequence operations which may arrive in
// different sequences at different nodes, each operation carries with it
// enough information for ObMan to reconstruct the workset, at each node,
// as if all the operations on it had arrived in the same sequence.
//
// To do this, all operations are assigned a sequence stamp before being
// broadcast.  When ObMan receives an operation from the network, it
// compares its stamp to various stamps it maintains locally.  Whether and
// how to perform the operation locally is determined on the basis of these
// comparisons, according to the rules defined below.
//
//

//
//
// SEQUENCE STAMPS AND THE WORKSET GENERATION NUMBER
//
// The sequencing order must be a globally consistent method of ordering
// events ("global" here refers to geographical distribution of all nodes
// operating on a given workset; it is not necessary that events be
// sequenced across different worksets, since operations on separate
// worksets can never interfere).
//
// We define an ObMan sequence stamp to be a combination of the workset
// generation number and the node id.
//
// The node ID is the user ID allocated by the MCS subsystem to the ObMan
// task and is therefore unique within a Domain.
//
// The workset generation number
//
// - is set to zero when the workset is created
//
// - is incremented each time ObMan performs an operation on behalf
//   of a local Client
//
// - is, whenever an operation arrives from the network, set to the
//   greater of its existing local value and the value in the
//   operation's sequence stamp.
//
// The ordering of sequence stamps is defined as follows (notation: stampX
// = wsetGenX.nodeX):
//
// - if wsetGen1 < wsetGen2, then stamp1 < ("is lower than") stamp2
//
// - elsif wsetGen1 = wsetGen2, then
//
//     - if node1 < node2, then stamp1 < stamp2
//
// - else stamp2 < stamp1.
//
// For the purposes of sequencing the different types of operations, ObMan
// maintains
//
// - one sequence stamp per workset:
//
//   - the last 'time' it was cleared (the clear stamp)
//
// - four sequence stamps per object:
//
//   - the 'time' the object was added (the addition stamp)
//
//   - the 'time' the object was last moved (the position stamp)
//
//   - the 'time' the object was last updated (the update stamp)
//
//   - the 'time' the object was last replace (the replace stamp; in
//     reality, only one of the update/replace stamps is required for
//     sequencing but both are needed for optimum spoiling).
//
// The initial values of the position, update and replace stamps are set to
// the value of the addition stamp.
//
// The initial value of the clear stamp is set to <0.ID> where ID is the ID
// of the node which created the workset.
//
// In addition, each object has a position field (either FIRST or LAST in
// R1.1) which indicates where the object was most recently positioned i.e.
// it is set when the object is added and then each time the object is
// moved within the workset.
//
//

//
//
// SEQUENCING PROTOCOLS
//
// The treatment of each type of operation is now considered in turn.
//
// 1.  Operations on unknown objects or worksets
//
// ObMan may at any time receive operations on objects or worksets which do
// not exist locally.  These operations may be on objects or worksets which
//
// - this node has not yet heard of, or
//
// - have been deleted.
//
// Operations on the first kind need to be delayed and reprocessed at a
// later time.  Operations on the second kind can be thrown away (note that
// there are no workset operations of this kind as once opened, worksets
// are never deleted in the lifetime of the workset group).
//
// To differentiate between the two, ObMan keeps a record of deleted
// objects.  When an operation on a deleted object arrives, it is
// discarded.  When an operation arrives for an object which is not in
// either the active object list or the deleted object list, ObMan bounces
// the event from the network layer back to its event loop, with a suitable
// delay, and attempts to process it later.
//
// For simplicity, the deleted object list is implemented by flagging
// deleted objects as such and leaving them in the main list of objects
// (i.e.  the workset), rather than moving them to a separate list.  The
// object data is, however, discarded; only the object record needs to be
// kept.
//
// Events from the network layer referring to operations on unknown
// worksets are automatically bounced back onto ObMan's event queue.
//
// 2.  Adding an object
//
// If ObMan receives an Add operation for an object which it has already
// added to a workset (i.e.  the object IDs are the same), it discards the
// operation.
//
// This normally will not happen since each object is added by only one
// node, and no node adds an object with the same ID twice.
//
// However, while a late-joiner is catching up with the contents of a
// workset, it is possible that it will receive notification of a
// particular object from both
//
// - the node which added the object
//
// - the helper node which is sending it the entire workset
//   contents.
//
// Therefore, the late-joiner checks object IDs as they arrive and discards
// them if they have already been received.  Note that since the
// positioning algorithm presented below will position each occurrence of
// the object in adjacent positions, checking for ID clashes is a simple
// matter, performed after the correct position has been found.
//
// 3.  Positioning (adding or moving) an object in a workset
//
// The desired sequence of objects in a workset is defined to be one
// whereby
//
// - all the objects which were positioned at the start of a workset (FIRST
//   objects) are before all the objects which were positioned at the end
//   of a workset (LAST objects)
//
// - the position stamps of all the FIRST objects decrease monotonically
//   from the start of the workset forward
//
// - the position stamps of all the LAST objects decrease monotonically
//   from the end of the workset backward.
//
// Accordingly, the protocol when positioning an object at the start of a
// workset is as follows (instructions for end-of-workset positioning in
// brackets):
//
// ObMan searches forward (back) from the start (end) of the workset until
// if finds an object which either
//
// - is not a FIRST (LAST) object, or
//
// - has a lower (lower) position stamp
//
// ObMan inserts the new/moved object before (after) this object.
//
// 4.  Clearing a workset
//
// On receiving a Clear operation, ObMan searches through the workset and
// deletes all objects which have an addition stamp lower than the clear
// operation's stamp.
//
// On receiving an addition to a workset, ObMan discards the operation if
// its stamp is lower than the workset's clear stamp.
//
// 5.  Updating an object
//
// On receiving an Update operation, ObMan compares its stamp with the
// object's update and replace stamps.  If the operation's stamp is higher
// than both, the operation is performed; otherwise, the operation is
// discarded (since an Update is superceded either by a later Replace or by
// a later Update).
//
// 6.  Replacing an object
//
// On receiving a Replace operation, ObMan compares its stamp with the
// object's replace stamp.  If the operation's stamp is higher, the
// operation is performed; otherwise, the operation is discarded (since a
// Replace is superceded by a later Replace but not by a later Update).
//
// 7.  Deleting an object
//
// By definition, a Delete is the last operation that should be performed
// on an object.  Delete operations are therefore processed immediately by
// setting the <deleted> flag in the object record to TRUE.
//
//

//
//
// OPERATION RESEQUENCING - SUMMARY
//
// In summary, therefore,
//
// - all object operations are discarded if object found on the deleted
//   object queue
//
// - Add operations are discarded if they refer to an existing object.
//
// - Add/Clear operations are requeued if the workset is not present
//   locally
//
// - Update/Replace/Move/Delete operations are requeued if the object or
//   workset is not present locally
//
// - Update operations are discarded if an Update or a Replace with a later
//   sequence stamp has already been received.
//
// - Replace operations are discarded if a Replace with a later sequence
//   stamp has already been received.
//
// By default, all operations are performed.
//
//


//
//
// OBJECT IDS
//
// Object IDs are structures which identify an object within a workset.
// For a given workset, they are unique throughout the Domain.
//
// To ensure uniqueness, the MCS user ID is used as a (two-byte) prefix to
// a four-byte sequence number generated locally, on a per workset basis.
//
// Workset groups can exist independently of a Domain, and therefore
// potentially before ObMan has been allocated an MCS user ID.  When
// allocating object IDs in this situation, ObMan uses zero (0) as the
// prefix to the sequence number.
//
// If that workset group is subsequently moved into a Domain, for all
// subsequent ID allocations ObMan uses its MCS user ID for that Domain as
// the prefix.  Other instances of ObMan may also start adding objects to
// the worksets in the group at this point, and they too use their MCS user
// IDs as the object ID prefix.  Uniqueness is preserved by the MCS
// guarantee that zero is never a valid user ID, so no post-share generated
// ID can conflict with a pre-share generated ID.
//
//


//
//
// SEQUENCE STAMPS
//
// Sequence stamps define a Domain-wide ordering for operations.  They are
// used to correctly execute operations which may arrive at a node in an
// indeterminate order.
//
//

typedef struct tagOM_SEQUENCE_STAMP
{
   TSHR_UINT32      genNumber;            // the workset generation number
                                           // which was current when the
                                           // stamp was issued
   NET_UID          userID;               // the MCS user ID for ObMan at
                                           // the node which issued it

    WORD            pad1;
} OM_SEQUENCE_STAMP;

typedef OM_SEQUENCE_STAMP *            POM_SEQUENCE_STAMP;


//
//
// OBJECT POSITION STAMPS
//
// When an object is added to or moved within a workset, it is important to
// know where it has been added.  Therefore, Add and Move operations
// include within them a position field, with the following type:
//
//

typedef BYTE            OM_POSITION;

//
// Possible values for an OM_POSITION variable:
//

#define LAST            1
#define FIRST           2
#define BEFORE          3
#define AFTER           4



//
//
// SEQUENCE STAMP MANIPULATION
//
// These macro manipulate sequence stamps.
//
//

//
//
// STAMP_IS_LOWER(stamp1, stamp2)
//
// This macro compares one sequence stamp with another.  It evaluates to
// TRUE if the first stamp is lower than the second.
//
//

#define STAMP_IS_LOWER(stamp1, stamp2)                                      \
                                                                            \
   (((stamp1).genNumber  <  (stamp2).genNumber) ?                           \
    TRUE :                                                                  \
    (((stamp1).genNumber == (stamp2).genNumber)                             \
     &&                                                                     \
     ((stamp1).userID    <  (stamp2).userID)))


//
//
// SET_NULL_SEQ_STAMP(stamp)
//
// This macro sets the sequence stamp <stamp> to NULL.
//
//

#define SET_NULL_SEQ_STAMP(stamp)                                           \
                                                                            \
   (stamp).userID     = 0;                                                  \
   (stamp).genNumber  = 0

//
//
// SEQ_STAMP_IS_NULL(stamp)
//
// This macro evaluates to TRUE if the sequence stamp <stamp> is a NULL
// sequence stamp.
//
//

#define SEQ_STAMP_IS_NULL(stamp)                                            \
                                                                            \
   ((stamp.userID == 0) && (stamp.genNumber == 0))

//
//
// COPY_SEQ_STAMP(stamp1, stamp2)
//
// This macro sets the value of the first sequence stamp to that of the
// second.
//
//

#define COPY_SEQ_STAMP(stamp1, stamp2)                                      \
                                                                            \
   (stamp1).userID    = (stamp2).userID;                                    \
   (stamp1).genNumber = (stamp2).genNumber


//
//
// MESSAGE FORMATS
//
// This section describes the formats of the messages sent between
// different instances of ObMan.
//
// The names of these messages are prefixed OMNET_...
//
// These events have the following format:
//
//    typedef struct
//    {
//       OMNET_PKT_HEADER   header;
//       :
//       : [various event specific fields]
//       :
//
//    } OMNET_...
//
// The OMNET_PKT_HEADER type is defined below.
//
//

typedef TSHR_UINT16                OMNET_MESSAGE_TYPE;

typedef struct tagOMNET_PKT_HEADER
{
    NET_UID              sender;            // MCS user ID of sender
    OMNET_MESSAGE_TYPE   messageType;       // == OMNET_...
}
OMNET_PKT_HEADER;
typedef OMNET_PKT_HEADER *             POMNET_PKT_HEADER;

//
// Possible values for a OMNET_MESSAGE_TYPE variable:
//

#define OMNET_NULL_MESSAGE             ((OMNET_MESSAGE_TYPE)  0x00)

#define OMNET_HELLO                    ((OMNET_MESSAGE_TYPE)  0x0A)
#define OMNET_WELCOME                  ((OMNET_MESSAGE_TYPE)  0x0B)

#define OMNET_LOCK_REQ                 ((OMNET_MESSAGE_TYPE)  0x15)
#define OMNET_LOCK_GRANT               ((OMNET_MESSAGE_TYPE)  0x16)
#define OMNET_LOCK_DENY                ((OMNET_MESSAGE_TYPE)  0x17)
#define OMNET_UNLOCK                   ((OMNET_MESSAGE_TYPE)  0x18)
#define OMNET_LOCK_NOTIFY              ((OMNET_MESSAGE_TYPE)  0x19)

#define OMNET_WSGROUP_SEND_REQ         ((OMNET_MESSAGE_TYPE)  0x1E)
#define OMNET_WSGROUP_SEND_MIDWAY      ((OMNET_MESSAGE_TYPE)  0x1F)
#define OMNET_WSGROUP_SEND_COMPLETE    ((OMNET_MESSAGE_TYPE)  0x20)
#define OMNET_WSGROUP_SEND_DENY        ((OMNET_MESSAGE_TYPE)  0x21)

#define OMNET_WORKSET_CLEAR            ((OMNET_MESSAGE_TYPE)  0x28)
#define OMNET_WORKSET_NEW              ((OMNET_MESSAGE_TYPE)  0x29)
#define OMNET_WORKSET_CATCHUP          ((OMNET_MESSAGE_TYPE)  0x30)

#define OMNET_OBJECT_ADD               ((OMNET_MESSAGE_TYPE)  0x32)
#define OMNET_OBJECT_CATCHUP           ((OMNET_MESSAGE_TYPE)  0x33)
#define OMNET_OBJECT_REPLACE           ((OMNET_MESSAGE_TYPE)  0x34)
#define OMNET_OBJECT_UPDATE            ((OMNET_MESSAGE_TYPE)  0x35)
#define OMNET_OBJECT_DELETE            ((OMNET_MESSAGE_TYPE)  0x36)
#define OMNET_OBJECT_MOVE              ((OMNET_MESSAGE_TYPE)  0x37)

#define OMNET_MORE_DATA                ((OMNET_MESSAGE_TYPE)  0x46)


//
//
// GENERIC OPERATION PACKET
//
// ObMan uses this structure for the following messages:
//
//   OMNET_MORE_DATA                uses first 1 field (4 bytes), plus data
//
//   OMNET_WORKSET_NEW              } use first 7 fields (24 bytes)
//   OMNET_WORKSET_CATCHUP          }
//
//   OMNET_WORKSET_CLEAR            uses first 6 fields (16 bytes);
//                                  doesn't use <position), <flags>
//
//   OMNET_OBJECT_MOVE              uses first 7 fields (24 bytes);
//                                  doesn't use <flags>
//
//   OMNET_OBJECT_DELETE            uses first 7 fields (24 bytes);
//                                  doesn't use <position), <flags>
//
//   OMNET_OBJECT_REPLACE           } use first 8 fields (28 bytes), plus
//   OMNET_OBEJCT_UPDATE            } data; don't use <position), <flags>
//
//   OMNET_OBJECT_ADD               uses first 9 fields (32 bytes), plus
//                                  data; doesn't use <flags>
//
//   OMNET_OBJECT_CATCHUP           uses all 12 fields (56 bytes), plus
//                                  data
//
//

typedef struct tagOMNET_OPERATION_PKT
{
    OMNET_PKT_HEADER     header;

    OM_WSGROUP_ID        wsGroupID;
    OM_WORKSET_ID        worksetID;
    BYTE                 position;       // <position> for Add/Move/Catchup
    BYTE                 flags;          // <flags> for ObjectCatchUp

       //
       // Note: for WORKSET_NEW/CATCHUP messages, the two bytes occupied by
       // the <position> and <flags> fields hold a NET_PRIORITY value.
       //

    OM_SEQUENCE_STAMP    seqStamp;       // operation sequence stamp
                                        // (== addStamp for ObjectCatchUp,
                                        // curr stamp for WorksetCatchUp)
    OM_OBJECT_ID         objectID;

       //
       // Note: for WORKSET_NEW/CATCHUP messages, the first byte occupied
       // by the <objectID> field holds a BOOL indicating whether the
       // workset is persistent.
       //

    TSHR_UINT32             totalSize;      // total size of transfer
    TSHR_UINT32             updateSize;

    OM_SEQUENCE_STAMP       positionStamp;
    OM_SEQUENCE_STAMP       replaceStamp;
    OM_SEQUENCE_STAMP       updateStamp;
}
OMNET_OPERATION_PKT;
typedef OMNET_OPERATION_PKT *          POMNET_OPERATION_PKT;

#define OMNET_MORE_DATA_SIZE               4
#define OMNET_WORKSET_NEW_SIZE             24
#define OMNET_WORKSET_CATCHUP_SIZE         24
#define OMNET_WORKSET_CLEAR_SIZE           16
#define OMNET_OBJECT_MOVE_SIZE             24
#define OMNET_OBJECT_DELETE_SIZE           24
#define OMNET_OBJECT_REPLACE_SIZE          28
#define OMNET_OBJECT_UPDATE_SIZE           28
#define OMNET_OBJECT_ADD_SIZE              32
#define OMNET_OBJECT_CATCHUP_SIZE          56

//
// These define the sizes of the packets we used in R1.1: we must only send
// packets of this size to R1.1 systems.
//

//
//
// HELLO/WELCOME MESSAGE
//
// When ObMan attaches to a Domain that contains an outgoing call, it
// broadcasts an OMNET_WELCOME message on the well-known ObManControl
// channel.
//
// When ObMan attaches to a Domain that contains an incoming call, it
// broadcasts an OMNET_HELLO message on the well-known ObManControl
// channel.
//
// When ObMan receives a HELLO message, it replies with a WELCOME message,
// just as if it had just joined the call.
//
// This allows each late-joining ObMan in the call to discover the user ID
// of each of the other instances of ObMan.
//
// A late-joining ObMan uses this information by asking one of the nodes
// which WELCOMEd it for a copy of the ObManControl workset group.
//
// HELLO/WELCOME packets are NEVER compressed.
//
// WELCOME and HELLO messages have the following format:
//
//

typedef struct tagOMNET_JOINER_PKT
{
    OMNET_PKT_HEADER    header;
    TSHR_UINT32         capsLen;             // == 4 in this version.
    TSHR_UINT32         compressionCaps;     // bitwise OR of OM_CAPS_ bits
}
OMNET_JOINER_PKT;
typedef OMNET_JOINER_PKT *     POMNET_JOINER_PKT;


//
// The actual compression type used in any given packet is specified as the
// first byte of the packet (before the header and other structures
// specified in this file).  The compression type is the numeric value of
// the bit position corresponding to the compression capability.  For
// example, if XYZ compression has a capability value of 0x8, then packets
// compressed with XYZ will have 3 in their first byte.
//
// '0' is never valid as an OM_PROT_...  compression type (which is why bit
// 1 is not used as an OM_CAPS_...  flag).
//
#define OM_PROT_PKW_COMPRESSED      0x01
#define OM_PROT_NOT_COMPRESSED      0x02

//
// Values for compressionCaps.  These must be separate bits, since they may
// be ORed together if a node supports multiple compression types.
//
// Note that OM_CAPS_NO_COMPRESSION is always supported.
//
// Bit 1 is not used.
//
#define OM_CAPS_PKW_COMPRESSION     0x0002
#define OM_CAPS_NO_COMPRESSION      0x0004


//
//
// LATE-JOINER PROTOCOL - WORKSET GROUP SEND REQUEST/SEND COMPLETE
//
// The SEND_REQUEST message is sent when ObMan has "late-joined" a
// particular workset group and would like another node to send it the
// current contents.
//
// The message is sent to an arbitrary "helper" node (known to have a copy
// of the workset group) on its single-user channel.
//
// The recipient responds by flushing the relevant channel (in R1.1, a
// no-op; in R2.0, perform a WORKSET_CHECKPOINT) and then sending the
// contents of the workset.
//
// When the WORKSET_CATCHUP messages have been sent, we send a
// WSGROUP_SEND_MIDWAY message to let the late joiner know that it now
// knows about all the worksets which are currently in use (otherwise, it
// might create a workset already in use which happened to be locked on the
// sending machine add then an object to it.
//
// The SEND_MIDWAY message also containing the max sequence number
// previously used by the late joiner's ID in this workset group (to
// prevent re-use of object IDs).
//
// When the contents have been sent, i.e.  after the last data packet of
// the last object in the last workset of the group, the helper sends a
// SEND_COMPLETE message.
//
// If the chosen helper node is not in a position to send the contents of
// the workset group, it must repsond with a SEND_DENY message, upon
// receipt of which the late joiner will choose someone else to catch up
// from.
//
// The SEND_REQUEST, SEND_MIDWAY, SEND_COMPLETE and SEND_DENY message
// packets have the following structure:
//
//

typedef struct tagOMNET_WSGROUP_SEND_PKT
{
    OMNET_PKT_HEADER    header;
    OM_WSGROUP_ID       wsGroupID;
    BYTE                pad1;
    TSHR_UINT16         correlator;         // Holds the catchup correlator
    OM_OBJECT_ID        objectID;
    TSHR_UINT32         maxObjIDSeqUsed;
}
OMNET_WSGROUP_SEND_PKT;
typedef OMNET_WSGROUP_SEND_PKT *       POMNET_WSGROUP_SEND_PKT;


//
//
// LOCKING PROTOCOL - LOCK PACKET
//
// When ObMan wants to lock a workset/object, it broadcasts one of these
// packets (with type == OMNET_LOCK_REQ).
//
// When ObMan receives one of these packets, it decides to deny or grant
// the lock to the sender, and replies with another packet of the same
// structure but with type == OMNET_LOCK_DENY or OMNET_LOCK_GRANT as
// appropriate.
//
// When ObMan wants to unlock a workste/object it has previously locked, it
// broadcasts one of these packets with type == OMNET_UNLOCK.
//

typedef struct tagOMNET_LOCK_PKT
{
    OMNET_PKT_HEADER     header;
    OM_WSGROUP_ID        wsGroupID;
    OM_WORKSET_ID        worksetID;
    TSHR_UINT16          data1;          // used as correlator for GRANT/DENY
                                        // used to indicate who's got lock
                                        // for NOTIFY
    // lon: need to keep pLockReqCB field for backward compatability!
    void *              pLockReqCB;     // R1.1 uses this to find the lock
                                        // request CB
}
OMNET_LOCK_PKT;
typedef OMNET_LOCK_PKT *            POMNET_LOCK_PKT;


//
//
// DATA STRUCTURES
//
//


//
//
// OPERATION TYPES
//
// This is the type defined for operations which Clients may perform on
// objects and worksets.  Pending operation lists use this type.
//
//

typedef TSHR_UINT16             OM_OPERATION_TYPE;

//
// Possible values for a OM_OPERATION_TYPE variable:
//

#define NULL_OP              ((OM_OPERATION_TYPE)  0)
#define WORKSET_CLEAR        ((OM_OPERATION_TYPE)  1)
#define OBJECT_ADD           ((OM_OPERATION_TYPE)  2)
#define OBJECT_MOVE          ((OM_OPERATION_TYPE)  3)
#define OBJECT_DELETE        ((OM_OPERATION_TYPE)  4)
#define OBJECT_REPLACE       ((OM_OPERATION_TYPE)  5)
#define OBJECT_UPDATE        ((OM_OPERATION_TYPE)  6)


//
//
// PENDING OPERATION LISTS
//
// When ObMan receives a request (either from a local Client or over the
// network) to delete, update or replace an object, or to clear a workset,
// it cannot perform the operation until the local Client has confirmed it.
// These operations are therefore put in a list and processed when the
// appropriate Confirm function is invoked.
//
// This list is hung off the workset record; its elements have the
// following format:
//
//

typedef struct tagOM_PENDING_OP
{
    STRUCTURE_STAMP

    BASEDLIST                  chain;

    POM_OBJECT              pObj;        // NULL if a clear operation
    POM_OBJECTDATA          pData;

    OM_SEQUENCE_STAMP       seqStamp;    // the sequence stamp which was
                                     // current in the workset when the
                                     // operation was invoked

    OM_OPERATION_TYPE       type;        // == WORKSET_CLEAR, OBJECT_DELETE,
                                    // OBJECT_UPDATE or OBJECT_REPLACE

    WORD    pad1;

}
OM_PENDING_OP;
typedef OM_PENDING_OP *         POM_PENDING_OP;


//
//
// OBJECT RECORDS
//
// This structure holds information about a particular object,
//
typedef struct tagOM_OBJECT
{
    STRUCTURE_STAMP

    BASEDLIST              chain;

    OM_OBJECT_ID        objectID;           // Unique within domain
    POM_OBJECTDATA      pData;              // Ptr to data

    OM_SEQUENCE_STAMP   addStamp;            // the sequence stamps used
    OM_SEQUENCE_STAMP   positionStamp;          OM_SEQUENCE_STAMP   replaceStamp;
    OM_SEQUENCE_STAMP   updateStamp;

    UINT                updateSize;         // size of (all) updates

    BYTE                flags;               // defined below
    OM_POSITION         position;            // either LAST or FIRST,
                                             // indicating where the object
                                             // was most recently placed
    WORD pad1;
}
OM_OBJECT;


BOOL __inline ValidObject(POM_OBJECT pObj)
{
    return(!IsBadWritePtr(pObj, sizeof(OM_OBJECT)));
}
void __inline ValidateObject(POM_OBJECT pObj)
{
    ASSERT(ValidObject(pObj));
}


//
// Flags used:
//

#define DELETED             0x0001
#define PENDING_DELETE      0x0002


//
//
// UNUSED OBJECTS LISTS
//
// When a Client allocates an object using OM_ObjectAlloc, a reference to
// the memory allocated is stored in the Client's unused objects list for
// this workset group.
//
// The reference is removed when the Client either
//
// - discards the object using OM_ObjectDiscard, or
//
// - inserts the object in a workset with an Add, Update or Replace
//   function.
//
// This list of objects (which is hung off the usage record) is checked
// when a workset is closed to discard any objects the Client didn't
// explicitly discard or use.
//
// The elements of the list have the following form:
//
//

typedef struct tagOM_OBJECTDATA_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    POM_OBJECTDATA      pData;

    UINT                size;       // Used to verify that Client hasn't grown size

    OM_WORKSET_ID       worksetID;
    BYTE                pad1;
    WORD                pad2;
}
OM_OBJECTDATA_LIST;
typedef OM_OBJECTDATA_LIST *     POM_OBJECTDATA_LIST;


//
//
// OBJECTS-IN-USE LISTS
//
// When a Client reads an object using OM_ObjectRead, the use count of the
// chunk of memory containing the object is increased.
//
// The use count is deceremented again when the Client calls
// OM_ObjectRelease, but if the Client abends, or simply closes a workset
// without releasing the objects it has read, we still need to be able to
// free the memory.
//
// Therefore we keep a list, on a per-workset-group basis, of the objects
// that a Client is using.  Objects (identified by handles) are added to
// the list when a Client calls OM_ObjectRead, and removed from the list
// when the Client calls OM_ObjectRelease.
//
// In addition, the list is checked when a workset is closed to release any
// handles the Client didn't release explicitly.
//
// Like the unused objects list, this list is hung off the usage record.
//
// The elements of these lists have the following form:
//
//

typedef struct tagOM_OBJECT_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    POM_OBJECT          pObj;

    OM_WORKSET_ID       worksetID;        // the ID of the workset
    BYTE                pad1;
    WORD                pad2;
}
OM_OBJECT_LIST;
typedef OM_OBJECT_LIST *          POM_OBJECT_LIST;


//
//
// NODE LIST STRUCTURES
//
// When requesting locks etc.  from other nodes in a Domain, ObMan keeps a
// list of remote nodes which it expects a reply from.  A node is
// identified by the MCS user ID of the instance of ObMan running on that
// node.
//
// The elements of these lists have the folllowing form:
//
//

typedef struct tagOM_NODE_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    NET_UID          userID;         // user ID of remote ObMan

    WORD             pad1;
}
OM_NODE_LIST;

typedef OM_NODE_LIST *           POM_NODE_LIST;


//
//
// LOCK REQUEST CONTROL BLOCKS
//
// When ObMan is in the process of getting a lock for a workset or object
// it creates one of these structures to correlate the lock replies.
//
//

typedef struct tagOM_LOCK_REQ
{
    STRUCTURE_STAMP

    BASEDLIST               chain;

    PUT_CLIENT           putTask;           // task to notify on success
                                             // or failure
    OM_CORRELATOR        correlator;          // returned by WorksetLockReq
    OM_WSGROUP_ID        wsGroupID;           // workset group and workset
    OM_WORKSET_ID        worksetID;           // containing the lock

    POM_WSGROUP          pWSGroup;

    BASEDLIST               nodes;               // MCS user IDs of nodes which
                                             // haven't yet replies to req
                                             // (an OM_NODE_LIST list)

    WORD                retriesToGo;        // Decremented on each timeout
    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE                type;               // PRIMARY or SECONDARY
}
OM_LOCK_REQ;
typedef OM_LOCK_REQ *                    POM_LOCK_REQ;

#define LOCK_PRIMARY        0x01
#define LOCK_SECONDARY      0x02



//
//
// CLIENT LIST STRUCTURE
//
// The lists of Clients stored per workset group and per workset contain
// elements of this type.  The <hWSGroup> field refers to the workset group
// handle by which the Client knows the workset group concerned.
//
//

typedef struct tagOM_CLIENT_LIST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;
    PUT_CLIENT          putTask;         // the Client's putTask
    WORD                mode;
    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE                pad1;
}
OM_CLIENT_LIST;
typedef OM_CLIENT_LIST *      POM_CLIENT_LIST;


//
//
// WORKSET RECORDS
//
// This structure holds the state information for a workset.  It resides at
// offset zero (0) in the huge memory block associated with this workset.
//
// ObMan allocates a workset record when a workset is created and discards
// it when the workset is discarded.
//
//

typedef struct tagOM_WORKSET
{
    STRUCTURE_STAMP

    UINT                numObjects;    // the current number of objects in
                                       // workset (excluding the sentinels)

    UINT                genNumber;     // current workset generation number

    OM_SEQUENCE_STAMP   clearStamp;    // the clear stamp for the workset

    NET_PRIORITY        priority;      // MCS priority for the workset
    OM_WORKSET_ID       worksetID;
    BYTE                lockState;     // one of the values defined below

    WORD                lockCount;     // LOCAL lock count
    NET_UID             lockedBy;      // MCS user ID of node which has the
                                       //  lock, if any

    BASEDLIST              objects;       // root of list of workset's objects

    UINT                bytesUnacked;  // bytes still to be acked

    BASEDLIST              pendingOps;    // root of list of operations which
                                       // are pending for this workset

    BASEDLIST              clients;       // root of list of Clients which
                                       // have this workset open
    BOOL                fTemp;
}
OM_WORKSET;
typedef OM_WORKSET   *            POM_WORKSET;

void __inline ValidateWorkset(POM_WORKSET pWorkset)
{
    ASSERT(!IsBadWritePtr(pWorkset, sizeof(OM_WORKSET)));
}

//
// Possible values for the <lockState> field above:
//

#define UNLOCKED              0x00
#define LOCKING               0x01
#define LOCKED                0x02
#define LOCK_GRANTED          0x03


//
//
// WORKSET GROUP RECORDS
//
// This structure holds information about a workset group.
//
// ObMan maintains one of these structures for each workset group with
// which one or more local Clients are registered.
//
// It will be discarded when the last local Client registered with the
// workset group deregisters from it.
//
//

typedef struct tagOM_WSGROUP
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    OMWSG           wsg;
    OMFP            fpHandler;

    NET_CHANNEL_ID  channelID;      // MCS channel ID used for WSG
    OM_WSGROUP_ID   wsGroupID;      // workset group ID
    BYTE            state;          // one of the values defined below

    POM_OBJECT   pObjReg;     // Registration object in the OMC workset

    BASEDLIST          clients;        // the Clients using the WSG

    POM_DOMAIN      pDomain;

    NET_UID         helperNode;     // ID of the node we are catching up from.
    WORD            valid:1;
    WORD            toBeDiscarded:1;

    UINT            bytesUnacked;   // sum of bytesUnacked field for each
                                     // workset in the workset group

    BYTE            sendMidwCount;  // # of SEND_MIDWAYs received
    BYTE            sendCompCount;  // # of SEND_MIDWAYs received
    OM_CORRELATOR   catchupCorrelator; // Used to correlate SEND_REQUESTS
                                        // to SEND_MIDWAYs and
                                        // SEND_COMPLETEs.
    POM_WORKSET     apWorksets[ OM_MAX_WORKSETS_PER_WSGROUP + 1];
}
OM_WSGROUP;



void __inline ValidateWSGroup(POM_WSGROUP pWSGroup)
{
    ASSERT(!IsBadWritePtr(pWSGroup, sizeof(OM_WSGROUP)));
}



//
// Workset group <state> values
//

#define INITIAL                  0x00
#define LOCKING_OMC              0x01
#define PENDING_JOIN             0x02
#define PENDING_SEND_MIDWAY      0x03
#define PENDING_SEND_COMPLETE    0x04
#define WSGROUP_READY            0x05


//
//
// USAGE RECORDS
//
// A usage record identifies a Client's use of a particular workset group
// and holds state information about that usage.
//
// Usage records reside in the OMGLBOAL memory block at the offset (from
// the base) specified in the Client record.
//
//

typedef struct tagOM_USAGE_REC
{
    STRUCTURE_STAMP

    POM_WSGROUP      pWSGroup;         // Client pointer to workset group

    BASEDLIST           unusedObjects;    // start sentinel in list of
                                         // pointers to unused objects

    BASEDLIST           objectsInUse;     // OM_OBJECT_LIST

    BYTE             mode;
    BYTE             flags;

    BYTE             worksetOpenFlags[(OM_MAX_WORKSETS_PER_WSGROUP + 7)/8];

                                         // bitfield array of flags
                                         // indicating the worksets the
                                         // Client has open
}
OM_USAGE_REC;
typedef OM_USAGE_REC *               POM_USAGE_REC;

__inline void ValidateUsageRec(POM_USAGE_REC pUsageRec)
{
    ASSERT(!IsBadWritePtr(pUsageRec, sizeof(OM_USAGE_REC)));
}

//
// Values for flags:
//

#define ADDED_TO_WSGROUP_LIST       0x0002
#define PWSGROUP_IS_PREGCB          0x0004

//
//
// LOCK STACKS
//
// Clients must request and release object and workset locks in accordance
// with the Universal Locking Order as defined in the Functional Spec (in
// order to avoid deadlock).
//
// In order to detect lock order violations, ObMan maintains, for each
// Client, a stack of locks which the Client holds or has requested.  This
// stack is implemented as a linked list, with the most recently acquired
// lock (which must, by definition, be the one latest in the Universal
// Locking Order) being the first element.
//
// A Client's lock stack is initialised when the Client registers with
// ObMan and discarded when the Client deregisters from ObMan.  Lock stacks
// are hung off the Client record.
//
// Note that we need the store the object ID here, as opposed to the
// handle, since we must enforce the universal lock order across all nodes.
//
// Elements of lock stacks have the following form:
//
//

typedef struct tagOM_LOCK
{
    STRUCTURE_STAMP

    BASEDLIST                chain;

    POM_WSGROUP           pWSGroup;      // Client pointer to workset group
                                        // needed to detect lock violations

    OM_OBJECT_ID          objectID;      // the object ID is 0 if this is a
                                        // workset lock (in R1.1, always).
    OM_WORKSET_ID         worksetID;
    BYTE pad1;
    WORD pad2;
}
OM_LOCK;
typedef OM_LOCK *                   POM_LOCK;


int __inline CompareLocks(POM_LOCK pLockFirst, POM_LOCK pLockSecond)
{
    int     result;

    result = (pLockSecond->pWSGroup->wsg - pLockFirst->pWSGroup->wsg);

    if (result == 0)
    {
        // Same WSG, so compare worksets
        result = (pLockSecond->worksetID - pLockFirst->worksetID);
    }

    return(result);
}


//
//
// CLIENT RECORD
//
// ObMan maintains instance data for every registered Client.  This
// structure, a Client record, holds the Client instance data.
//
// A Client's ObMan handle is a Client pointer to this structure.
//
// A Client's workset group handle is an index into the array of usage record
// ptrs.
//
// If the value of apUsageRecs is 0 or -1, x is not a valid workset
// group handle.
//
//

typedef struct tagOM_CLIENT
{
    STRUCTURE_STAMP

    PUT_CLIENT      putTask;

    BOOL            exitProcReg:1;
    BOOL            hiddenHandlerReg:1;

    BASEDLIST          locks;        // root of list of locks held

    POM_USAGE_REC   apUsageRecs[OMWSG_MAXPERCLIENT];
    BOOL            wsgValid[OMWSG_MAXPERCLIENT];
}
OM_CLIENT;



BOOL __inline ValidWSGroupHandle(POM_CLIENT pomClient, OM_WSGROUP_HANDLE hWSGroup)
{
    return((hWSGroup != 0) &&
           (pomClient->wsgValid[hWSGroup]) &&
           (pomClient->apUsageRecs[hWSGroup] != NULL));
}


//
//
// DOMAIN RECORD
//
// This structure holds information about a Domain.  We support two:
//      * The current call
//      * Limbo (no call) for cleanup after a call and maintenance of info
//          across calls
//
typedef struct tagOM_DOMAIN
{
    STRUCTURE_STAMP

    BASEDLIST          chain;

    UINT            callID;             // MCS Domain Handle

    NET_UID         userID;             // ObMan's MCS user ID and token ID
    NET_TOKEN_ID    tokenID;            //  for this domain

    NET_CHANNEL_ID  omcChannel;         // ObMan's broadcast channel
    BYTE            state;              // one of the values defined below
    BYTE            omchWSGroup;        // ObMan's hWSGroup for this domain's

    BOOL            valid:1;
    BOOL            sendEventOutstanding:1;

    UINT            compressionCaps;    // Domain-wide compression caps

    BASEDLIST          wsGroups;           // root of list of workset groups
    BASEDLIST          pendingRegs;        // root of list of pending workset
                                        // group registration request
    BASEDLIST          pendingLocks;       // root of list of pending
                                        // lock requests
    BASEDLIST          receiveList;        // root of list of control blocks
                                        // for receives in progress
    BASEDLIST          bounceList;         // root of list of control blocks
                                        // for bounced messages
    BASEDLIST          helperCBs;          // root of list of helper CBs for
                                        // checkpoints in progress

    BASEDLIST          sendQueue[NET_NUM_PRIORITIES];
                                        // array of roots of list of send
                                        // queue instructions (by priority)
    BOOL            sendInProgress[NET_NUM_PRIORITIES];
                                        // array of send-in-progress flags
}
OM_DOMAIN;


//
// Possible values for <state> field:
//

#define PENDING_ATTACH         0x01
#define PENDING_JOIN_OWN       0x02
#define PENDING_JOIN_OMC       0x03
#define PENDING_TOKEN_ASSIGN   0x04
#define PENDING_TOKEN_GRAB     0x05
#define PENDING_TOKEN_INHIBIT  0x06
#define PENDING_WELCOME        0x07
#define GETTING_OMC            0x08
#define DOMAIN_READY           0x09




//
//
// SHARED MEMORY STRUCTURE
//
// This structure holds various private (to ObMan) state information.
//
// The ObMan task allocates and initialises one instance of this structure
// when it initialises; it resides at the base of the OMGLOBAL memory
// block.
//
// It is discarded when the ObMan task terminates.
//
//

typedef struct tagOM_PRIMARY
{
    STRUCTURE_STAMP

    PUT_CLIENT      putTask;
    PMG_CLIENT      pmgClient;              // OM's network layer handle
    PCM_CLIENT      pcmClient;              // OM's Call Manager handle

    BASEDLIST       domains;                // Domains
    OM_CLIENT       clients[OMCLI_MAX];     // Secondaries

    UINT            objectIDsequence;

    BOOL            exitProcReg:1;
    BOOL            eventProcReg:1;

    OM_CORRELATOR   correlator;
    WORD            pad1;

    LPBYTE          pgdcWorkBuf;
    BYTE            compressBuffer[OM_NET_SEND_POOL_SIZE / 2];
}
OM_PRIMARY;


void __inline ValidateOMP(POM_PRIMARY pomPrimary)
{
    ASSERT(!IsBadWritePtr(pomPrimary, sizeof(OM_PRIMARY)));
}


void __inline ValidateOMS(POM_CLIENT pomClient)
{
    extern POM_PRIMARY  g_pomPrimary;

    ValidateOMP(g_pomPrimary);

    ASSERT(!IsBadWritePtr(pomClient, sizeof(OM_CLIENT)));

    ASSERT(pomClient < &(g_pomPrimary->clients[OMCLI_MAX]));
    ASSERT(pomClient >= &(g_pomPrimary->clients[OMCLI_FIRST]));
}




//
//
// Workset group registration/move request control block
//
// This structure is used to pass the parameters of a workset group
// registration/move request to the ObMan task (from a Client task).
//
// Not all fields are used by both the registration and the move process.
//
// The <type> field is used to distinguish between a WSGroupMove and a
// WSGroupRegister.
//
//

typedef struct tagOM_WSGROUP_REG_CB
{
    STRUCTURE_STAMP

    BASEDLIST          chain;
    PUT_CLIENT      putTask;
    UINT            callID;

    OMWSG           wsg;
    OMFP            fpHandler;

    OM_CORRELATOR   correlator;
    OM_CORRELATOR   lockCorrelator;
    OM_CORRELATOR   channelCorrelator;
    WORD            retryCount;

    POM_USAGE_REC   pUsageRec;
    POM_WSGROUP     pWSGroup;

    POM_DOMAIN      pDomain;            // ObMan pointer to Domain record
    BOOL            valid;

    OM_WSGROUP_HANDLE   hWSGroup;
    BYTE            type;               // REGISTER or MOVE
    BYTE            mode;               // PRIMARY or SECONDARY
    BYTE            flags;              // see below
}
OM_WSGROUP_REG_CB;
typedef OM_WSGROUP_REG_CB *         POM_WSGROUP_REG_CB;

//
// Values for the <type> field:
//

#define WSGROUP_MOVE       0x01
#define WSGROUP_REGISTER   0x02

//
// Flags for the <flags> field:
//

#define BUMPED_CBS         0x0001    // indicates whether we bumped use
                                        // counts of pWSGroup, pDomain
#define LOCKED_OMC         0x0002    // indicates whether we've locked
                                        // ObManControl

//
// Values for the <mode> field (we use the flag macro because the values
// may be ORed together and so need to be bit-independent):
//

#define PRIMARY            0x0001
#define SECONDARY          0x0002


//
//
// HELPER CONTROL BLOCK
//
// When we receive a WSG_SEND_REQUEST from a remote node, we checkpoint the
// workset group requested.  This is an asynchronous process (it's
// essentially getting a lock on a dummy workset), so we need to store the
// details of the remote node away somewhere.  We do this using a help CB
// with the following structure:
//
//

typedef struct tagOM_HELPER_CB
{
    STRUCTURE_STAMP

    BASEDLIST          chain;

    NET_UID         lateJoiner;             // MCS user ID of late joiner
    OM_CORRELATOR   remoteCorrelator;

    POM_WSGROUP     pWSGroup;               // pWSGroup is bumped during
                                            //  checkpoint

    OM_CORRELATOR   lockCorrelator;         // returned by WorksetLockReq
                                           //  and recd in WORKSET_LOCK_CON

    WORD            pad1;
}
OM_HELPER_CB;
typedef OM_HELPER_CB *         POM_HELPER_CB;



//
//
// THE SEND QUEUE
//
// For each Domain, and for each network priority, ObMan maintains a queue
// of message and data to be sent to the network.  Clients, when executing
// API functions, cause instructions to be added to the tail of one of
// these queues.
//
// The ObMan task, in response to an OMINT_EVENT_SEND_QUEUE event, processes as
// many send queue operations as possible, giving up for a while when it
// runs out of network buffers.
//
// This is subject to the restriction that no operations are processed from
// one send queue when operations exist on a queue of higher priority in
// the same Domain.
//
// Instructions on the send queue have the following format:
//
//

typedef struct tagOM_SEND_INST
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    UINT                callID;         // the relevant Domain

    NET_CHANNEL_ID      channel;       // the channel to send the event on
    NET_PRIORITY        priority;      // priority to send event on

    POM_WSGROUP         pWSGroup;
    POM_WORKSET         pWorkset;
    POMNET_PKT_HEADER   pMessage;
    POM_OBJECT          pObj;

    POM_OBJECTDATA      pDataStart;
    POM_OBJECTDATA      pDataNext;

    WORD                messageSize;   // length of message at pMessage
    OMNET_MESSAGE_TYPE  messageType;   // == OMNET_OBJECT_ADD, etc.

    UINT                dataLeftToGo;  // number of bytes of data left to
                                       // be sent

    UINT                compressOrNot; // Some packets are never compressed

}
OM_SEND_INST;
typedef OM_SEND_INST *             POM_SEND_INST;

//
//
// RECEIVE LIST
//
// ObMan maintains a list of structures holding information about data
// transfers (receives) which have begun but not finished.  This is known
// as the receive list.
//
// When ObMan receives a header packet for an Add, Update or Replace
// operation, it adds an entry to the receive list.  Subsequent data
// packets are then correlated with this entry, until the entire object has
// been received, at which point the Add/Update/Replace operation is
// carried out.
//
// The receive list is a linked list of entries with the following format:
//
//

typedef struct tagOM_RECEIVE_CB
{
    STRUCTURE_STAMP

    BASEDLIST               chain;

    POM_DOMAIN           pDomain;     // Domain record pointer

    POMNET_OPERATION_PKT pHeader;        // ObMan pointer to message header

    void *               pData;          // ObMan pointer to the data that
                                        // is being transferred

    UINT                 bytesRecd;      // total bytes received so far for
                                        // this transfer

    LPBYTE               pCurrentPosition;  // points to where next chunk
                                           // of data should be copied

    NET_PRIORITY         priority;       // priority of data transfer
    NET_CHANNEL_ID       channel;

}
OM_RECEIVE_CB;
typedef OM_RECEIVE_CB *             POM_RECEIVE_CB;



//
// HANDLE <--> PTR CONVERSION ROUTINES
// Object, usage, domain, workset group, worksets
//


POM_WSGROUP  __inline GetOMCWsgroup(POM_DOMAIN pDomain)
{
    POM_WSGROUP pWSGroup;

    pWSGroup = (POM_WSGROUP)COM_BasedListFirst(&(pDomain->wsGroups),
        FIELD_OFFSET(OM_WSGROUP, chain));

    ValidateWSGroup(pWSGroup);

    return(pWSGroup);
}



POM_WORKSET  __inline GetOMCWorkset(POM_DOMAIN pDomain, OM_WORKSET_ID worksetID)
{
    POM_WSGROUP pWSGroup;

    pWSGroup = GetOMCWsgroup(pDomain);
    return(pWSGroup->apWorksets[worksetID]);
}




OM_CORRELATOR __inline NextCorrelator(POM_PRIMARY pomPrimary)
{
    return(pomPrimary->correlator++);
}



void __inline UpdateWorksetGeneration(POM_WORKSET pWorkset, POMNET_OPERATION_PKT pPacket)
{
    pWorkset->genNumber = max(pWorkset->genNumber, pPacket->seqStamp.genNumber) + 1;
}


//
//
// CHECK_WORKSET_NOT_EXHAUSTED(pWorkset)
//
// This macro checks that the specified workset is not exhausted.  If it
// is, it calls DC_QUIT.
//
//

#define CHECK_WORKSET_NOT_EXHAUSTED(pWorkset)                               \
                                                                            \
   if (pWorkset->genNumber == OM_MAX_GENERATION_NUMBER)                     \
   {                                                                        \
      WARNING_OUT(("Workset %hx exhausted", pWorkset->worksetID));          \
      rc = OM_RC_WORKSET_EXHAUSTED;                                         \
      DC_QUIT;                                                              \
   }

//
//
// CHECK_WORKSET_NOT_LOCKED(pWorkset)
//
// This macro checks that the specified workset is not locked.  If it is,
// it calls DC_QUIT with an error.
//
//

#define CHECK_WORKSET_NOT_LOCKED(pWorkset)                                  \
                                                                            \
   if (pWorkset->lockState == LOCK_GRANTED)                                 \
   {                                                                        \
      rc = OM_RC_WORKSET_LOCKED;                                            \
      WARNING_OUT(("Workset %hx locked - can't proceed", worksetID));       \
      DC_QUIT;                                                              \
   }


//
//
// OBJECT ID MANIPULATION
//
// These macros manipulate object IDs.
//
//

//
//
// OBJECT_ID_IS_NULL(objectID)
//
// This macro evaluates to TRUE if the supplied object ID is a null ID,
// and FALSE otherwise.
//
//

#define OBJECT_ID_IS_NULL(objectID)                                         \
                                                                            \
   (((objectID).creator  == 0) && ((objectID).sequence == 0))

//
//
// GET_NEXT_OBJECT_ID(objectID, pDomain, pWorkset)
//
// This macro allocates a new object ID for the workset specified by
// <pWorkset>.  It copies the ID into the structure specified by
// <objectID>.
//
// The first field in the ID is ObMan's MCS user ID in the Domain to which
// the workset group <pWSGroup> belongs.
//
//

#define GET_NEXT_OBJECT_ID(objectID, pDomain, pomPrimary)                 \
   (objectID).creator     = pDomain->userID;                             \
   (objectID).sequence    = pomPrimary->objectIDsequence++;                  \
   (objectID).pad1        = 0

//
//
// OBJECT_IDS_ARE_EQUAL(objectID1, objectID2)
//
// Evaluates to TRUE if the two object IDs are equal and FALSE otherwise.
//
//

#define OBJECT_IDS_ARE_EQUAL(objectID1, objectID2)                          \
                                                                            \
   (memcmp(&(objectID1), &(objectID2), sizeof(OM_OBJECT_ID)) == 0)

//
//
// SEQUENCE STAMP MANIPULATION
//
// These macro manipulate sequence stamps.
//
//

//
//
// GET_CURR_SEQ_STAMP(stamp, pWSGroup, pWorkset)
//
// This macro copies the current sequence stamp of the workset specified by
// <pWorkset> into the sequence stamp structure identified by <stamp>.
//
//

#define GET_CURR_SEQ_STAMP(stamp, pDomain, pWorkset)                     \
                                                                            \
   (stamp).userID     = pDomain->userID;                                 \
   (stamp).genNumber  = pWorkset->genNumber


//
// GenerateMessage(...)
//
// Allocates and initialises an OMNET_OPERATION_PKT of the specified type.
// Note that the <size> field is set to zero even if <messageType> is an
// add, update or replace.  The QueueMessage function will set the size to
// the correct value when the message is queued.
//
UINT GenerateOpMessage(                             POM_WSGROUP                pWSGroup,
                                      OM_WORKSET_ID              worksetID,
                                      POM_OBJECT_ID              pObjectID,
                                      POM_OBJECTDATA             pData,
                                      OMNET_MESSAGE_TYPE         messageType,
                                      POMNET_OPERATION_PKT *    ppPacket);


//
//
// QueueMessage(...)
//
// This function creates a send instruction for the specified message and
// places the instruction on the specified send queue for the specified
// Domain.  It them sends an event to ObMan prompting it to examine the
// queue.
//
//

UINT QueueMessage(PUT_CLIENT putTask,
                         POM_DOMAIN pDomain,
                                     NET_CHANNEL_ID       channelID,
                                     NET_PRIORITY         priority,
                                     POM_WSGROUP          pWSGroup,
                                     POM_WORKSET         pWorkset,
                                     POM_OBJECT      pObjectRec,
                                     POMNET_PKT_HEADER    pPacket,
                                     POM_OBJECTDATA          pData,
                                     BOOL               compressOrNot);

//
// GetMessageSize(...)
//
UINT GetMessageSize(OMNET_MESSAGE_TYPE  messageType);


//
// PreProcessMessage(...)
//
UINT PreProcessMessage(POM_DOMAIN            pDomain,
                                      OM_WSGROUP_ID             wsGroupID,
                                      OM_WORKSET_ID             worksetID,
                                      POM_OBJECT_ID             pObjectID,
                                      OMNET_MESSAGE_TYPE        messageType,
                                      POM_WSGROUP      *    ppWSGroup,
                                      POM_WORKSET     *    ppWorkset,
                                      POM_OBJECT  *    ppObjectRec);


//
//
// PurgeNonPersistent(...)
//
// Purges any objects added by <userID> from non-persistent worksets in the
// workset group identified by <wsGroupID> in the specified domain.
//
//

void PurgeNonPersistent(POM_PRIMARY pomPrimary,
                                         POM_DOMAIN      pDomain,
                                         OM_WSGROUP_ID       wsGroupID,
                                         NET_UID             userID);

//
// ProcessWorksetNew(...)
//
UINT ProcessWorksetNew(PUT_CLIENT putTask,
                                          POMNET_OPERATION_PKT   pPacket,
                                          POM_WSGROUP            pWSGroup);


//
// ProcessWorksetClear(...)
//
UINT ProcessWorksetClear(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                            POMNET_OPERATION_PKT  pPacket,
                                            POM_WSGROUP           pWSGroup,
                                            POM_WORKSET          pWorkset);


//
// ProcessObjectAdd(...)
//
UINT ProcessObjectAdd(PUT_CLIENT putTask,
                                         POMNET_OPERATION_PKT    pPacket,
                                         POM_WSGROUP             pWSGroup,
                                         POM_WORKSET            pWorkset,
                                         POM_OBJECTDATA         pData,
                                         POM_OBJECT *       ppObj);


//
// ProcessObjectMove(...)
//
void ProcessObjectMove(PUT_CLIENT putTask,
                                        POMNET_OPERATION_PKT    pPacket,
                                        POM_WORKSET            pWorkset,
                                        POM_OBJECT         pObjectRec);


//
// ProcessObjectDRU(...)
//
UINT ProcessObjectDRU(PUT_CLIENT putTask,
                                         POMNET_OPERATION_PKT  pPacket,
                                         POM_WSGROUP           pWSGroup,
                                         POM_WORKSET          pWorkset,
                                         POM_OBJECT       pObj,
                                         POM_OBJECTDATA      pData);


//
// ObjectAdd(...)
//
UINT ObjectAdd(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                  POM_WSGROUP             pWSGroup,
                                  POM_WORKSET            pWorkset,
                                  POM_OBJECTDATA         pData,
                                  UINT                updateSize,
                                  OM_POSITION             position,
                                  OM_OBJECT_ID     *  pObjectID,
                                  POM_OBJECT *   ppObj);




//
// WSGroupEventPost(...)
//
// This function posts the specified event to all local Clients registered
// with the workset group.  The <param2> parameter is the second parameter
// on the event to be posted.
//
//

UINT WSGroupEventPost(PUT_CLIENT    putTaskFrom,
                                       POM_WSGROUP         pWSGroup,
                                       BYTE             target,
                                       UINT             event,
                                       OM_WORKSET_ID       worksetID,
                                       UINT_PTR param2);


//
//
// This function is called by
//
// - OM_WorksetOpen, when a Client creates a new workset
//
// - ProcessLockRequest, when a lock request arrives for a workset we
//   don't yet know about
//
// - xx, when an OMNET_WORKSET_NEW message arrives.
//
// It creates the local data structures for the workset and posts an event
// to all local Clients registered with the workset group.
//
//

//
//
// WorksetCreate(...)
//
// This function creates a new workset in the specified workset group.
//
// It calls GenerateMessage, ProcessWorksetNew and QueueMessage.
//
//

UINT WorksetCreate(PUT_CLIENT putTask,
                                      POM_WSGROUP           pWSGroup,
                                      OM_WORKSET_ID         worksetID,
                                      BOOL                  fTemp,
                                      NET_PRIORITY          priority);


//
//
// WorksetEventPost(...)
//
// This function posts the specified event to all local Clients which have
// the workset open (at most 1 Client in R1.1).
//
// The <putTask> parameter is the putTask of the invoking task (and NOT
// the handle of the task to post the event to).
//
// The number of Clients the event was successfully posted to is returned
// in *pNumPosts, if pNumPosts is not NULL.  A caller which wishes to
// ignore the number of events posted can pass in NULL as the pNumPosts
// parameter.
//
//

UINT WorksetEventPost(PUT_CLIENT putTask,
                                       POM_WORKSET        pWorkset,
                                       BYTE             target,
                                       UINT             event,
                                       POM_OBJECT   pObj);


//
// WorksetDoClear(...)
//
void WorksetDoClear(PUT_CLIENT putTask,
                                     POM_WSGROUP        pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_PENDING_OP    pPendingOp);



//
//
// ProcessLockRequest(...)
//
// This function is called when ObMan receives an OMNET_LOCK_REQ message
// from another node.
//
// If we
//
// - have the workset locked already, or
//
// - are trying to lock the workset and our MCS user ID is greater than the
//   node which sent us the request,
//
// we deny the lock (i.e.  send back a negative OMNET_LOCK_REPLY).
//
// In all other cases, we grant the lock (i.e.  send back an affirmative
// OMNET_LOCK_REPLY).
//
// If we grant the lock to the remote node when we were trying to get it
// for ourselves, our attempt to lock the workset has failed so we call
// WorksetLockResult with a failure code.
//
//

void ProcessLockRequest(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN     pDomain,
                                     POMNET_LOCK_PKT    pLockReqPkt);


//
//
// QueueLockReply(...)
//
// This function is called when we have decided to grant or deny a lock
// request received from another node.  It queues the appropriate response
// on ObMan's send queue.
//
//

void QueueLockReply(POM_PRIMARY pomPrimary,
                                   POM_DOMAIN           pDomain,
                                   OMNET_MESSAGE_TYPE       result,
                                   NET_CHANNEL_ID           destination,
                                   POMNET_LOCK_PKT          pLockReqPkt);


//
//
// QueueLockNotify(...)
//
// Queues a LOCK_NOTIFY command on the broadcast channel for the workset
// group, indicating that we have granted the lock to the <locker>.
//
//

void QueueLockNotify(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN          pDomain,
                                    POM_WSGROUP             pWSGroup,
                                    POM_WORKSET            pWorkset,
                                    NET_UID                 locker);


//
//
// ProcessLockReply(...)
//
// This function is called when ObMan receives an OMNET_LOCK_GRANT or
// OMNET_LOCK_DENY message from another node, in response to an
// OMNET_LOCK_REQ message we sent out earlier.
//
// The function removes this node from the list of expected respondents for
// this lock (if it is in the list).
//
// If the list is now empty, the lock has succeeded so WorksetLockResult is
// called.
//
// Otherwise, nothing else happens for the moment.
//
//

void ProcessLockReply(POM_PRIMARY pomPrimary,
                                   POM_DOMAIN       pDomain,
                                   NET_UID              sender,
                                   OM_CORRELATOR        correlator,
                                   OMNET_MESSAGE_TYPE   replyType);


//
// PurgeLockRequests(...)
//
void PurgeLockRequests(POM_DOMAIN      pDomain,
                                    POM_WSGROUP         pWSGroup);


//
//
// ProcessLockTimeout(...)
//
// This function is called when ObMan receives a lock timeout event.  It
// checks to see if any of the nodes from whom we are still expecting lock
// replies have in fact gone away; if they have, it removes them from the
// list of expected respondents.
//
// If this list is now empty, the lock has succeeded and WorksetLockResult
// is called.
//
// If the list is not empty, then another delayed lock timeout event is
// posted to ObMan, unless we have already had the maximum number of
// timeouts for this lock, in which case the lock has failed and
// WorksetLockResult is called.
//
//

void ProcessLockTimeout(POM_PRIMARY  pomPrimary,
                                     UINT          retriesToGo,
                                     UINT          callID);



//
//
// WorksetLockReq(...)
//
// This function is called
//
// - by OM_WorksetLockReq, when a Client wants to lock a workset
//
// - by LockObManControl, when ObMan wants to lock workset #0 in
//   ObManControl.
//
// The function decides whether the lock can be granted or refused
// synchronously, and if so calls WorksetLockResult.  If not, it posts an
// OMINT_EVENT_LOCK_REQ event to the ObMan task, which results in the
// ProcessLocalLockRequest function being called later.
//
// The <hWSGroup> parameter is the workset group handle which will be
// included in the eventual OM_WORKSET_LOCK_CON event.  Its value is not
// used in the function; when this function is called in the ObMan task
// this value is set to zero (since the ObMan task doesn't use workset
// group handles).
//
// On successful completion, the <pCorrelator> parameter points to the
// correlator value which will be included in the eventual
// OM_WORKSET_LOCK_CON event.
//
//

void WorksetLockReq(PUT_CLIENT putTask, POM_PRIMARY pomPrimary,
                                     POM_WSGROUP       pWSGroup,
                                     POM_WORKSET      pWorkset,
                                     OM_WSGROUP_HANDLE  hWSGroup,
                                     OM_CORRELATOR    * pCorrelator);


//
//
// WorksetLockResult(...)
//
// This function is called when we have finished processing a request to
// obtain a workset lock.  The function sets the workset state accordingly,
// posts an appropriate event to the task which requested the lock, and
// frees the lock request control block.
//
//
void WorksetLockResult(PUT_CLIENT putTask,
                                        POM_LOCK_REQ *   ppLockReq,
                                        UINT             result);


//
//
// BuildNodeList(...)
//
// This function builds a list of the remote nodes which are registered
// with the workset group referenced in the lock request CB passed in.
//
//

UINT BuildNodeList(POM_DOMAIN pDomain, POM_LOCK_REQ pLockReq);


//
//
// HandleMultLockReq(...)
//
// This function searches the global list of pending lock requests (stored
// in the root data structure) for any lock requests matching the Domain,
// workset group and workset specified.
//
//

void HandleMultLockReq(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN         pDomain,
                                    POM_WSGROUP            pWSGroup,
                                    POM_WORKSET           pWorkset,
                                    UINT               result);


//
//
// FindLockReq(...)
//
// This function searches the global list of pending lock requests (stored
// in the root data structure) for a lock request that matches the Domain,
// workset group and workset specified.
//
// If found, a pointer to the lock request is returned in <ppLockReq>.
//
// It can search for a primary lock request if needed
//
//

void FindLockReq(POM_DOMAIN         pDomain,
                              POM_WSGROUP            pWSGroup,
                              POM_WORKSET           pWorkset,
                              POM_LOCK_REQ *     ppLockreq,
                              BYTE               lockType);


//
// ReleaseAllNetLocks(...)
//
void ReleaseAllNetLocks(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN      pDomain,
                                     OM_WSGROUP_ID       wsGroupID,
                                     NET_UID             userID);

//
//
// ProcessUnlock(...)
//
// This function is called when an OMNET_UNLOCK message is received from
// the network.  The function is a wrapper which just derives a workset
// pointer and calls ProcessUnlock (above).
//
//

void ProcessUnlock(POM_PRIMARY pomPrimary,
                                POM_WORKSET        pWorkset,
                                NET_UID             sender);

//
// WorksetUnlock(...)
//
void WorksetUnlock(PUT_CLIENT putTask, POM_WSGROUP     pWSGroup,
                                    POM_WORKSET    pWorkset);

//
// WorksetUnlockLocal(...)
//
void WorksetUnlockLocal(PUT_CLIENT putTask, POM_WORKSET     pWorkset);



//
//
// ObjectDoDelete(...)
//
// This function deletes an object in a workset.  It is called by
//
// - OM_ObjectDeleteConfirm, when a Client confirms the deletion of an
//   object.
//
// - WorksetDoClear, to delete each individual object
//
// - ProcessObjectDelete when ObMan receives a Delete message from the
//   network for an object in a workset which no local Clients have open.
//
//

void ObjectDoDelete(PUT_CLIENT putTask,
                                     POM_WSGROUP        pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_OBJECT    pObj,
                                     POM_PENDING_OP    pPendingOp);


//
//
// ObjectDRU(...)
//
// This function generate, processes and queues a message of type DELETE,
// REPLACE or UPDATE (as specified by <type>).
//
//
UINT ObjectDRU(PUT_CLIENT putTask,
                                  POM_WSGROUP             pWSGroup,
                                  POM_WORKSET            pWorkset,
                                  POM_OBJECT         pObj,
                                  POM_OBJECTDATA            pData,
                                  OMNET_MESSAGE_TYPE      type);


//
//
// ObjectRead(...)
//
// This function converts an object handle to a pointer to the object data.
// An invalid handle causes an assertion failure.
//
//

void ObjectRead(POM_CLIENT pomClient,
                            POM_OBJECT pObj,
                             POM_OBJECTDATA *    ppData);


//
// ObjectInsert(...)
//
void ObjectInsert(POM_WORKSET pWorkset,
                               POM_OBJECT   pObj,
                               OM_POSITION       position);


//
// ObjectDoMove(...)
//
void ObjectDoMove(POM_OBJECT   pObjToMove,
                               POM_OBJECT   pOtherObjectRec,
                               OM_POSITION       position);


//
// ObjectDoUpdate(...)
//
void ObjectDoUpdate(PUT_CLIENT putTask,
                                    POM_WSGROUP      pWSGroup,
                                     POM_WORKSET       pWorkset,
                                     POM_OBJECT    pObj,
                                     POM_PENDING_OP    pPendingOp);


//
// ObjectDoReplace(...)
//
void ObjectDoReplace(PUT_CLIENT putTask,
                                    POM_WSGROUP      pWSGroup,
                                      POM_WORKSET       pWorkset,
                                      POM_OBJECT    pObj,
                                      POM_PENDING_OP    pPendingOp);


//
// ObjectIDToPtr(...)
//
UINT ObjectIDToPtr(POM_WORKSET pWorkset,
                                        OM_OBJECT_ID              objectID,
                                        POM_OBJECT *        ppObj);



//
// FindPendingOp(...)
//
void FindPendingOp(POM_WORKSET             pWorkset,
                                    POM_OBJECT          pObj,
                                    OM_OPERATION_TYPE        type,
                                    POM_PENDING_OP *    ppPendingOp);


//
// WSGRecordFind(...)
//
void WSGRecordFind(POM_DOMAIN pDomain, OMWSG wsg, OMFP fpHandler,
                                    POM_WSGROUP *  ppWSGroup);


//
// DeterminePriority(...)
//
void DeterminePriority(NET_PRIORITY *   pPriority,
                                    POM_OBJECTDATA          pData);


//
// RemoveClientFromWSGList(...)
//
// The second parameter is the putTask of the Client to be deregistered.
// It is NOT (well, not necessarily) the putTask of the calling task, and
// for this reason (to avoid it being used as such) is passed as a 32-bit
// integer.
//
void RemoveClientFromWSGList(
                                    PUT_CLIENT putUs,
                                    PUT_CLIENT putTask,
                                              POM_WSGROUP    pWSGroup);


//
// AddClientToWSGList(...)
//
UINT AddClientToWSGList(PUT_CLIENT putTask,
                                       POM_WSGROUP             pWSGroup,
                                       OM_WSGROUP_HANDLE    hWSGroup,
                                       UINT         mode);


//
// AddClientToWsetList(...)
//
UINT AddClientToWsetList(PUT_CLIENT putTask,
                                    POM_WORKSET           pWorkset,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                    UINT            mode,
                                    POM_CLIENT_LIST * pClientListEntry);


//
// PostWorksetNewEvents(...)
//
UINT PostWorksetNewEvents(PUT_CLIENT putFrom,
                                       PUT_CLIENT       putTask,
                                       POM_WSGROUP      pWSGroup,
                                       OM_WSGROUP_HANDLE hWSGroup);


//
//
// QueueUnlock(...)
//
// This function queues a workset unlock packet for sending to the
// specified destination.
//
//

UINT QueueUnlock(PUT_CLIENT putTask,
                                    POM_DOMAIN      pDomain,
                                    OM_WSGROUP_ID       wsGroupID,
                                    OM_WORKSET_ID       worksetID,
                                    NET_UID             destination,
                                    NET_PRIORITY        priority);

//
// PurgeReceiveCBs(...)
//
void PurgeReceiveCBs(POM_DOMAIN        pDomain,
                                  NET_CHANNEL_ID        channel);


//
// FreeSendInst()
//
void FreeSendInst(POM_SEND_INST pSendInst);


//
// SetPersonData(...)
//
UINT SetPersonData(POM_PRIMARY   pomPrimary,
                                      POM_DOMAIN   pDomain,
                                      POM_WSGROUP      pWSGroup);


//
//
// FindInfoObject(...)
//
// This function searches workset #0 in the ObManControl workset group in
// the specified Domain for a matching info object.
//
// The match is performed as follows:
//
// - if functionProfile and wsGroupName are not NULL, the first object
//   matching both is returned
//
// - if functionProfile is not NULL but wsGroupName is, the first object
//   matching functionProfile is returned
//
// - if functionProfile is NULL, the first object matching wsGroupID is
//   returned.
//
//

void FindInfoObject(POM_DOMAIN         pDomain,
                                     OM_WSGROUP_ID      wsGroupID,
                                     OMWSG              wsg,
                                     OMFP               fpHandler,
                                     POM_OBJECT *  ppInfoObjectRec);


//
//
// FindPersonObject(...)
//
// This function searches the specified workset in ObManControl looking for
// a registration object which has
//
// - the same user ID as <userID>, if <searchType> == FIND_THIS
//
// - a different user ID from <userID>, if <searchType> == FIND_OTHERS.
//
//

void FindPersonObject(POM_WORKSET          pOMCWorkset,
                                       NET_UID               userID,
                                       UINT              searchType,
                                       POM_OBJECT * ppRegObjectRec);

#define FIND_THIS          1
#define FIND_OTHERS        2

//
// ProcessOMCWorksetNew(...)
//
void ProcessOMCWorksetNew(POM_PRIMARY pomPrimary, OM_WSGROUP_HANDLE hWSGroup,
                                       OM_WORKSET_ID      worksetID);


//
// ProcessOMCObjectEvents(...)
//
void ProcessOMCObjectEvents(POM_PRIMARY pomPrimary,
                                         UINT            event,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                         OM_WORKSET_ID      worksetID,
                                         POM_OBJECT     pObj);


//
// GeneratePersonEvents(...)
//
void GeneratePersonEvents(POM_PRIMARY pomPrimary,
                                       UINT            event,
                                       POM_WSGROUP        pWSGroup,
                                       POM_OBJECT   pObj);


//
// PostAddEvents(...)
//
UINT PostAddEvents(PUT_CLIENT putTaskFrom,
                                      POM_WORKSET       pWorkset,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                      PUT_CLIENT        putTaskTo);


//
// RemovePersonObject(...)
//
void RemovePersonObject(POM_PRIMARY pomPrimary,
                                     POM_DOMAIN         pDomain,
                                     OM_WSGROUP_ID          wsGroupID,
                                     NET_UID                detachedUserID);


//
// RemoveInfoObject(...)
//
void RemoveInfoObject(POM_PRIMARY pomPrimary, POM_DOMAIN   pDomain,
                                       OM_WSGROUP_ID    wsGroupID);




//
//
// DEBUG ONLY FUNCTIONS
//
// These functions are debug code only - for normal compilations, the
// declarations are #defined to nothing and the definitions are
// preprocessed out altogether.
//
//

#ifndef _DEBUG

#define CheckObjectCount(x, y)
#define CheckObjectOrder(x)
#define DumpWorkset(x, y)

#else // _DEBUG

//
//
// CheckConstants(...)
//
// The ObMan code relies on certain assumptions about the sizes and formats
// of various data structures, and the values of certain constants.
//
//
// The OMNET_OPERATION_PKT type has two one-byte fields, <position> and
// <flags>, which are used to hold
//
// - a NET_PRIORITY value which indicates the priority for the
//   workset for WORKSET_NEW/WORKSET_CATCHUP messages, and
//
// - a UINT (the number of bytes being acknowledged) in the case
//   of a DATA_ACK message.
//
// GenerateOpMessage and AckData cast the <position> field to a two-byte
// quantity for this purpose.  Therefore, it is necessary that these two
// fields exist, that they are adjacent and that the <position> one
// comes first.
//
// In addition, since the priority information is a NET_PRIORITY, we
// must ensure that a NET_PRIORITY is indeed two bytes long.
//
//
// ASSERT((sizeof(NET_PRIORITY) == (2 * sizeof(BYTE))));
//
// ASSERT((offsetof(OMNET_OPERATION_PKT, position) + 1 ==
//            offsetof(OMNET_OPERATION_PKT, flags)));
//
//
// In many places, for-loops use workset IDs as the loop variable and
// OM_MAX_WORKSETS_PER_WSGROUP as the end condition.  To avoid infinite
// loops, this constant must be less than 256:
//
// ASSERT((OM_MAX_WORKSETS_PER_WSGROUP < 256));
//
// The OMC WSG has one workset for each WSG in the Domain.  Since the
// number of worksets per WSG is limited, the # of WSGs per Domain is
// limited in the same way:
//
// ASSERT(OM_MAX_WSGROUPS_PER_DOMAIN <= OM_MAX_WORKSETS_PER_WSGROUP);
//


//
//
// CheckObjectCount(...)
//
// This function counts the number of non-deleted objects in the specified
// workset and compares this against the <numObjects> field of the workset
// record.  A mismatch causes an assertion failure.
//
//
void CheckObjectCount(POM_WSGROUP        pWSGroup,
                                   POM_WORKSET       pWorkset);

//
// CheckObjectOrder(...)
//
void CheckObjectOrder(POM_WORKSET pWorkset);


#endif // _DEBUG


//
//
// WORKSET OPEN/CLOSE BITFIELD MANIPULATION MACROS
//
// ObMan maintains one usage record for each workset group a Client is
// registered with.  One of the fields of the usage record is an 32-byte
// bitfield which is interpreted as an array of 256 booleans, indicating
// whether a Client has the corresponding workset open.
//
// These macros use the EXTRACT_BIT, SET_BIT and CLEAR_BIT macros to set and clear the bit
// for <worksetID> in the <worksetOpenFlags> bitfield of the usage record.
//
//

BOOL __inline WORKSET_IS_OPEN(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    return((pUsageRec->worksetOpenFlags[worksetID / 8] & (0x80 >> (worksetID % 8))) != 0);
}

void __inline WORKSET_SET_OPEN(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    pUsageRec->worksetOpenFlags[worksetID / 8] |= (0x80 >> (worksetID % 8));
}

void __inline WORKSET_SET_CLOSED(POM_USAGE_REC pUsageRec, OM_WORKSET_ID worksetID)
{
    pUsageRec->worksetOpenFlags[worksetID / 8] &= ~(0x80 >> (worksetID % 8));
}


//
//
// ReleaseAllLocks(...)
//
// This function releases all the locks held by a particular Client for a
// particular workset.  In R1.1, this is at most one lock (the workset
// lock) but if/when object locking is supported, this function will also
// release all object locks held.
//
// This function is closed when a Client is closing a workset.
//
//

void ReleaseAllLocks(POM_CLIENT       pomClient,
                                  POM_USAGE_REC   pUsageRec,
                                  POM_WORKSET    pWorkset);


//
//
// ReleaseAllObjects(...)
//
// This function releases all the objects held by a particular Client in a
// particular workset.
//
// This function is called when a Client closes a workset.
//
void ReleaseAllObjects(POM_USAGE_REC pUsageRec, POM_WORKSET pWorkset);


//
//
// ConfirmAll(...)
//
// This function confirms any pending operations for the workset specified.
//
// The function is called when a Client closes a workset.
//
// Since this function may call WorksetDoClear, the caller must hold the
// workset group mutex.
//
//

void ConfirmAll(POM_CLIENT       pomClient,
                             POM_USAGE_REC   pUsageRec,
                             POM_WORKSET    pWorkset);


//
//
// DiscardAllObjects(...)
//
// This function discards any objects allocated for the specified Client
// for the specified workset but so far unused.
//
// The function is called when a Client closes a workset.
//
//
void DiscardAllObjects(POM_USAGE_REC   pUsageRec,
                                    POM_WORKSET    pWorkset);


//
//
// RemoveFromUnusedList
//
// This function removes an object (specified by a pointer to the object)
// from the Client's list of unused objects.  It is called by
//
// - OM_ObjectAdd, OM_ObjectUpdate and OM_ObjectReplace when a
//   Client inserts an object into a workset, or
//
// - OM_ObjectDiscard, when a Client discards an unused object.
//
//

void RemoveFromUnusedList(POM_USAGE_REC pUsageRec, POM_OBJECTDATA pData);


//
//
// OM_ObjectAdd(...)
//
// This function adds an object to a worksets, in the specified position.
//
// Although it is not strictly an API function, it performs full parameter
// validation and could be externalised easily.
//
//

UINT OM_ObjectAdd(POM_CLIENT           pomClient,
                                 OM_WSGROUP_HANDLE hWSGroup,
                                 OM_WORKSET_ID       worksetID,
                                 POM_OBJECTDATA *   ppData,
                                 UINT            updateSize,
                                 POM_OBJECT *   ppObj,
                                 OM_POSITION         position);


//
//
// OM_ObjectMove(...)
//
// This function moves an object to the start or end of a workset.  It is
// called by OM_ObjectMoveFirst and OM_ObjectMoveLast.
//
// Although it is not strictly an API function, it performs full parameter
// validation and could be externalised easily.
//
//

UINT OM_ObjectMove(POM_CLIENT           pomClient,
                                  OM_WSGROUP_HANDLE hWSGroup,
                                  OM_WORKSET_ID       worksetID,
                                  POM_OBJECT    pObj,
                                  OM_POSITION         position);


//
//
// ValidateParamsX(...)
//
// These functions are used to validate parameters and convert them to
// various pointers, as follows:
//
// ValidateParams2 - checks pomClient, hWSGroup
//                 - returns pUsageRec, pWSGroup
//
// ValidateParams3 - checks pomClient, hWSGroup, worksetID,
//                 - returns pUsageRec, pWorkset
//
//                   Note: also asserts that workset is open
//
// ValidateParams4 - checks pomClient, hWSGroup, worksetID, pObj
//
// Each of the functions uses DCASSERT to bring down the calling task if an
// invalid parameter is detected.
//
//

__inline void ValidateParams2(POM_CLIENT          pomClient,
                                  OM_WSGROUP_HANDLE hWSGroup,
                                  UINT          requiredMode,
                                  POM_USAGE_REC  *  ppUsageRec,
                                  POM_WSGROUP       *  ppWSGroup)
{
    ValidateOMS(pomClient);
    ASSERT(ValidWSGroupHandle(pomClient, hWSGroup));

    *ppUsageRec = pomClient->apUsageRecs[hWSGroup];
    ValidateUsageRec(*ppUsageRec);
    ASSERT(requiredMode & (*ppUsageRec)->mode);

    *ppWSGroup = (*ppUsageRec)->pWSGroup;
    ValidateWSGroup(*ppWSGroup);
}


__inline void ValidateParams3(POM_CLIENT                pomClient,
                                  OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  UINT                  requiredMode,
                                  POM_USAGE_REC     *   ppUsageRec,
                                  POM_WORKSET      *    ppWorkset)
{
    POM_WSGROUP pWSGroup;

    ValidateParams2(pomClient, hWSGroup, requiredMode, ppUsageRec, &pWSGroup);

    ASSERT(WORKSET_IS_OPEN(*ppUsageRec, worksetID));

    *ppWorkset = pWSGroup->apWorksets[worksetID];
    ValidateWorkset(*ppWorkset);
}


__inline void ValidateParams4(POM_CLIENT                pomClient,
                                  OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  POM_OBJECT            pObj,
                                  UINT                  requiredMode,
                                  POM_USAGE_REC     *   ppUsageRec,
                                  POM_WORKSET      *    ppWorkset)
{
    ValidateParams3(pomClient, hWSGroup, worksetID, requiredMode, ppUsageRec,
        ppWorkset);

    ValidateObject(pObj);
    ASSERT(!(pObj->flags & DELETED));
}



//
//
// SetUpUsageRecord(...)
//
UINT SetUpUsageRecord(POM_CLIENT             pomClient,
                                     UINT           mode,
                                     POM_USAGE_REC* ppUsageRec,
                                     OM_WSGROUP_HANDLE * phWSGroup);


//
// FindUnusedWSGHandle()
//
UINT FindUnusedWSGHandle(POM_CLIENT pomClient, OM_WSGROUP_HANDLE * phWSGroup);


//
//
// ObjectRelease(...)
//
// This function releases the specified Client's hold on the the specified
// object and removes the relevant entry from the Client's objects-in-use
// list.
//
// If <pObj> is NULL, the function releases the first object held by
// this Client in the specified workset, if any.  If there are none, the
// function returns OM_RC_OBJECT_NOT_FOUND.
//
//

UINT ObjectRelease(POM_USAGE_REC             pUsageRec,
                                  OM_WORKSET_ID             worksetID,
                                  POM_OBJECT            pObj);


//
//
// WorksetClearPending(...)
//
// Look for a CLEAR_IND which is outstanding for the given workset which,
// when confirmed, will cause the given object to be deleted.
//
// Returns TRUE if such a CLEAR_IND is outstanding, FALSE otherwise.
//
//

BOOL WorksetClearPending(POM_WORKSET pWorkset, POM_OBJECT pObj);




UINT OM_Register(PUT_CLIENT putTask, OMCLI omClient, POM_CLIENT * ppomClient);

//
//
//   Description:
//
// This function registers a DC-Groupware task as an ObMan Client.  A task
// must be a registered ObMan Client in order to call any of the other API
// functions.
//
// On successful completion, the value at <ppomClient> is this Client's ObMan
// handle, which must be passed as a parameter to all other API functions.
//
// This function registers an event handler and an exit procedure for the
// Client, so Clients must have previously registered fewer than the maximum
// number of Utility Service event handlers and exit procedures.
//
// If the are too many Clients already registered with ObMan, an error is
// returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_TOO_MANY_CLIENTS
//
//

void OM_Deregister(POM_CLIENT * ppomCient);
void CALLBACK OMSExitProc(LPVOID pomClient);

//
//
//   Description:
//
// This function deregisters an ObMan Client.
//
// On completion, the ObMan handle which the Client was using becomes
// invalid and the value at <ppomClient> is set to NULL to prevent the task
// from using it again.
//
// This function deregisters the Client from any workset groups with which
// it was registered.
//
//   Ensuing Events:
//
// None
//
//   Return Codes
//
// None
//
//

UINT OM_WSGroupRegisterPReq(POM_CLIENT  pomClient,
                                              UINT         call,
                                              OMFP          fpHandler,
                                              OMWSG         wsg,
                                              OM_CORRELATOR *        pCorrelator);

//
//
//   Description:
//
// This is an asynchronous function which requests that ObMan register a
// Client with a particular workset group for PRIMARY access.  The workset
// group is determined by the following:
//
// - <call> is the DC-Groupware Call which contains/is to contain the
//          workset group (or OM_NO_CALL if the workset group is/is to
//          be a local workset group)
//
// - <functionProfile> is the Function Profile for the workset group
//
// - <wsGroupName> is the name of the workset group.
//
// The <pomClient> parameter is the ObMan handle returned by the OM_Register
// function.
//
// If a Client wishes to create a new, or register with an existing, workset
// group which exists only on the local machine, the value OM_NO_CALL should
// be specified for the <call> parameter.  Workset groups created in this
// way for purely local use may be subsequently transferred into a call by
// invoking OM_WSGroupMoveReq at some later time.
//
// If this function completes successfully, the Client will subsequently
// receive an OM_WSGROUP_REGISTER_CON event indicating the success or
// failure of the registration.
//
// Registering with a workset group is a prerequisite to opening any of its
// worksets.
//
// If no workset group with this name and function profile exists in the
// specified call (or locally, if OM_NO_CALL specified), a new, empty
// workset group is created and assigned <wsGroupName> as its name.  This
// name must be a valid workset group name.
//
// If the workset group already exists in the Call, its contents are copied
// from another node.  This data transfer is made at low priority (note that
// subsequent receipt of the OM_WSGROUP_REGISTER_CON event does not indicate
// that this data transfer has completed).
//
// If there are worksets existing in the workset group, the Client will
// receive one or more OM_WORKSET_NEW_IND events after receiving the
// OM_WSGROUP_REGISTER_CON event.
//
// Note also that the contents of the workset group may be copied to this
// node in any order.  Therefore, if objects in a workset reference other
// objects, the Client should not assume that the referenced object is
// present locally once the reference arrives.
//
// Clients registered for primary access to a workset group have full read
// and write access to the workset group and have a responsilibity to
// confirm destructive operations (such as workset clear and object delete,
// update and replace operations), as described in the relevant sections
// below.
//
// At most one Client per node may be registered with a given workset group
// for primary access.  If a second Client attempts to register for primary
// access, OM_RC_TOO_MANY_CLIENTS is returned asynchronously via the
// OM_WSGROUP_REGISTER_CON event.
//
// On successful completion of the function, the return parameter
// <pCorrelator> points to a value which may be used by the Client to
// correlate this call with the event it generates.  Notification of a
// successful registration will contain a workset group handle which the
// Client must uses subsequently when invoking other ObMan functions
// relating to this workset group.
//
// If the maximum number of workset groups in concurrent use per call has
// been reached, the OM_RC_TOO_MANY_WSGROUPS error is returned
// asynchronously.  If the maximum number of workset groups in use by one
// Client is reached, OM_RC_NO_MORE HANDLES is returned synchronously.  If
// ObMan cannot create a new workset group for any other reason, the
// OM_RC_CANNOT_CREATE_WSG error is returned (synchronously or
// asynchronously).
//
// Note that separate DC-Groupware tasks must each register independently
// with the workset groups they wish to use, as workset group handles may
// not be passed between tasks.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_WSGROUP_REGISTER_CON event to be
// posted to the invoking Client.
//
// If ObMan is forced at some later stage to move the workset group out of
// the call for which it was intended (usually at call end time), the Client
// will receive an OM_WSGROUP_MOVE_IND event.
//
// When a Client has successfully registered with a workset group, it will
// receive OM_PERSON_JOINED_IND, OM_PERSON_LEFT_IND and
// OM_PERSON_DATA_CHANGED_IND events as primaries (including the calling
// Client) register and deregister from the workset group and change their
// person data.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_NO_MORE_HANDLES
//
//

UINT OM_WSGroupRegisterS(POM_CLIENT                 pomClient,
                                   UINT             call,
                                   OMFP             fpHandler,
                                   OMWSG            wsg,
                                OM_WSGROUP_HANDLE * phWSGroup);

//
//
//   Description:
//
// This is a synchronous function which requests that ObMan register a
// Client with a particular workset group for SECONDARY access.  The workset
// group is determined by the following:
//
// - <call> is the DC-Groupware call which contains the workset group (or
//          OM_NO_CALL if the workset group is a local workset group)
//
// - <functionProfile> is the Function Profile of the workset group
//
// - <wsGroupName> is the name of the workset group.
//
// The <pomClient> parameter is the ObMan handle returned by the OM_Register
// function.
//
// A Client may only register for secondary access for a workset group when
// there is already a local Client fully registered for primary access to
// that workset group.  If there is no such local primary, OM_RC_NO_PRIMARY
// is returned.
//
// If there are worksets existing in the workset group, the Client will
// receive one or more OM_WORKSET_NEW_IND events after this function
// completes.
//
// Registering for secondary access to a workset group gives a Client the
// same access privileges as a primary Client except for:
//
// - creating worksets
//
// - moving workset groups into/out of Calls
//
// - locking worksets and objects
//
// In addition, secondary Clients of a workset group will receive events
// relating to the workset group in the same way as primary Clients.
// However, the following important difference applies: secondary Clients
// will receive notification of object deletes, updates and replaces AFTER
// the associated operations have taken place (as opposed to primary
// Clients, who are informed BEFORE action is taken and must invoke the
// relevant confirmation function).
//
// To highlight this difference, these events have a primary and a secondary
// variety:
//
//
//
//    Primary                               Secondary
//
//  - OM_WORKSET_CLEAR_IND                  OM_WORKSET_CLEARED_IND
//  - OM_OBJECT_DELETE_IND                  OM_OBJECT_DELETED_IND
//  - OM_OBJECT_REPLACE_IND                 OM_OBJECT_REPLACED_IND
//  - OM_OBJECT_UPDATE_IND                  OM_OBJECT_UPDATED_IND
//
//
//
// Several Clients per node, up to a defined limit, may be registered with
// a given workset group for secondary access.  Once this limit is reached,
// OM_RC_TOO_MANY_CLIENTS is returned.
//
// On successful completion of the function, the return parameter
// <phWSGoup> points to a workset group handle which the Client must uses
// subsequently when invoking other ObMan functions relating to this
// workset group.
//
// Note that separate DC-Groupware tasks must each register independently
// with the workset groups they wish to use, as workset group handles may
// not be passed between tasks.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_NO_MORE_HANDLES
//  OM_RC_NO_PRIMARY
//  OM_RC_TOO_MANY_CLIENTS
//
//

UINT OM_WSGroupMoveReq(POM_CLIENT           pomClient,
                            OM_WSGROUP_HANDLE hWSGroup,
                                          UINT            callID,
                                          OM_CORRELATOR *          pCorrelator);

//
//
//   Description:
//
// This function requests that ObMan move a local workset group previously
// created as a local workset group (i.e.  created specifying the OM_NO_CALL
// for the Call ID parameter) into the DC-Groupware Call identified by
// <callID>.  If the move is successful, the workset group becomes available
// at all nodes in the Call.
//
// The workset group to move is specified by <hWSGroup>, which must be a
// valid workset group handle.
//
// If the function completes successfully, the OM_WSGROUP_MOVE_CON event is
// posted to the Client when the attempt to move the workset group into the
// Call has completed.  This event indicates whether the attempt was
// successful.
//
// If there is already a (different) workset group in the specified Call
// with the same name and Function Profile, this function will fail
// asynchronously.
//
//   Ensuing Events:
//
// Invoking this function causes the OM_WSGROUP_MOVE_CON to be posted to the
// invoking Client.  If the move is successful, the OM_WSGROUP_MOVE_IND
// event is also posted to all local Clients which are registered with the
// workset group, including the invoking Client.
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_ALREADY_IN_CALL
//  Utility Service return codes
//
//

void OM_WSGroupDeregister(POM_CLIENT pomClient, OM_WSGROUP_HANDLE * phWSGroup);

//
//
//   Description:
//
// This function deregisters the Client from the workset group specified by
// the handle at <phWSGroup>.  Any worksets which the Client had open in
// the workset group are closed (thereby releasing all locks), and the
// Client will receive no more events relating to this workset group.
//
// This call may cause the local copy of the workset group and its worksets
// to be discarded; in this sense, this function is destructive.
//
// This call sets the value at <phWSGroup> to NULL to prevent the Client
// using this handle in further calls to ObMan.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetOpenPReq(POM_CLIENT            pomClient,
                               OM_WSGROUP_HANDLE     hWSGroup,
                                  OM_WORKSET_ID         worksetID,
                                  NET_PRIORITY          priority,
                                  BOOL              fTemp,
                                  OM_CORRELATOR *            pCorrelator);

UINT OM_WorksetOpenS(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                        OM_WORKSET_ID       worksetID);

//
//
//   Description:
//
// These functions open a specified workset for a Client.
//
// OM_WorksetOpenPReq is an asynchronous function which will create the
// workset if it does not exist.  Only primary Clients of this workset group
// may call this function.
//
// OM_WorksetOpenS is a synchronous function which will return
// OM_RC_WORKSET_DOESNT_EXIST if the workset does not exist.  Only secondary
// Clients of this workset group may call this function.
//
// In the asynchronous (primary) case, when ObMan has opened the workset for
// the Client, or failed to do so, it posts an OM_WORKSET_OPEN_CON event to
// the Client indicating success or the reason for failure.  This event will
// contain the correlator value returned in <pCorrelator> by this function.
//
// If this action results in the creation of a new workset, <priority> will
// specify the MCS priority at which data relating to the workset will be
// transmitted.  Note that NET_TOP_PRIORITY is reserved for ObMan's private
// use and must not be specified as the <priority> parameter.
//
// If OM_OBMAN_CHOOSES_PRIORITY is specified as the <priority> parameter,
// ObMan will prioritise data transfers according to size.
//
// If the workset already exists, the Client will receive an
// OM_OBJECT_ADD_IND event for each object that is in the workset when it is
// opened.
//
// Opening a workset is a prerequisite to performing any operations on it or
// its contents.  Once a Client has opened a workset it will receive events
// when changes are made to the workset or its contents.
//
// If this Client has already opened this workset,
// OM_RC_WORKSET_ALREADY_OPEN is returned.  No 'use count' of opens is
// maintained, so the first OM_WorksetClose will close the workset,
// irrespective of how many times it has been opened.
//
//   Ensuing Events:
//
// Invoking OM_WorksetOpenPReq causes the OM_WORKSET_OPEN_CON event to be
// posted to the invoking Client.
//
// If this action results in the creation of a new workset, an
// OM_WORKSET_NEW_IND is posted to all Clients which are registered with the
// workset group, including the invoking Client.
//
// In both the primary and secondary cases, if the workset contains any
// objects, an OM_OBJECT_ADD_IND event will be posted to the Client for each
// one.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_DOESNT_EXIST
//  OM_RC_WORKSET_ALREADY_OPEN
//
//

#define OM_OBMAN_CHOOSES_PRIORITY   (NET_INVALID_PRIORITY)


void OM_WorksetClose(POM_CLIENT pomClient,
                                      OM_WSGROUP_HANDLE hWSGroup,
                                      OM_WORKSET_ID           worksetID);

//
//
//   Description:
//
// This function closes the workset in <hWSGroup> identified by <worksetID>.
// The Client may no longer access this workset and will receive no more
// events relating to it.  ObMan will however continue to update the
// contents of the workset in the background; in this sense, this function
// is non-destructive.
//
// When a Client closes a workset, ObMan automatically releases the
// following resources:
//
// - any locks the Client has relating to this workset
//
// - any objects which the Client had been reading or had allocated
//   for writing in the workset.
//
// If indication events which require a Confirm function to be invoked have
// been received by the Client but not yet confirmed, these Confirms are
// implicitly executed by ObMan AND THE CLIENT MUST NOT SUBSEQUENTLY ATTEMPT
// TO CONFIRM THEM.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

void   OM_WorksetFlowQuery(POM_CLIENT           pomClient,
                                   OM_WSGROUP_HANDLE    hWSGroup,
                                   OM_WORKSET_ID       worksetID,
                                   UINT*           pBytesOutstanding);

//
//
//   Description:
//
// A Client calls this function whenever it wishes to discover the size of
// the backlog of data relating to the workset identified by <hWSGroup> and
// <worksetID>.
//
// The "backlog" is defined as the total number of bytes of object data
// which ObMan has been given by its local Clients and which have not yet
// been acknowledged by all remote nodes where there are Clients registered
// with the workset group.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetLockReq(POM_CLIENT               pomClient,
                                   OM_WSGROUP_HANDLE hWSGroup,
                                          OM_WORKSET_ID         worksetID,
                                          OM_CORRELATOR *       pCorrelator);

//
//
//   Description:
//
// This is an asynchronous function which requests a lock for the workset in
// <hWSGroup> identified by <worksetID>.  When ObMan has processed the lock
// request, it will send an OM_WORKSET_LOCK_CON event to the Client
// indicating success or the reason for failure.
//
// Holding a workset lock prevents other Clients from making any changes to
// the workset or any of its objects.  Specifically, the following functions
// are prohibited:
//
// - locking the same workset
//
// - locking an object in the workset
//
// - moving an object within the workset
//
// - adding an object to the workset
//
// - deleting an object from the workset
//
// - updating or replacing an object in the workset.
//
// Locking a workset does not prevent other Clients from reading its
// contents.
//
// The function will cause an assertion failure if the Client requesting the
// lock already holds or has requested a lock which is equal to or after
// this one in the Universal Locking Order.
//
// On successful completion of the function, the value at <pCorrelator> is a
// value which the Client can use to correlate the subsequent
// OM_OBJECT_LOCK_CON event with this request.
//
// A Client must release the lock when it no longer needs it, using the
// OM_WorksetUnlock function.  Locks will be automatically released when a
// Client closes the workset or deregisters from the workset group.
//
// Only primary Clients of a workset group may call this function.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_WORKSET_LOCK_CON event to be
// posted to the invoking Client at some later time.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_WorksetUnlock(POM_CLIENT               pomClient,
                                       OM_WSGROUP_HANDLE hWSGroup,
                                       OM_WORKSET_ID           worksetID);

//
//
//   Description:
//
// This function unlocks the workset in <hWSGroup> identified by
// <worksetID>.  This must be the lock most recently acquired or requested
// by the Client; otherwise, the lock violation error causes an assertion
// failure.
//
// If this function is called before the OM_WORKSET_LOCK_CON event is
// received, the Client will not subsequently receive the event.
//
//   Ensuing Events:
//
// This function causes an OM_WORKSET_UNLOCK_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes:
//
// None
//
//

void OM_WorksetCountObjects(
                                    POM_CLIENT              pomClient,
                                    OM_WSGROUP_HANDLE       hWSGroup,
                                    OM_WORKSET_ID           worksetID,
                                    UINT*               pCount);

//
//
//   Description:
//
// On successful completion of this function , the value at <pCount> is the
// number of objects in the workset in <hWSGroup> identified by
// <worksetID>.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_WorksetClear(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE   hWSGroup,
                                        OM_WORKSET_ID   worksetID);

//
//
//   Description:
//
// This function requests that ObMan clear (i.e.  delete the contents of)
// the workset in <hWSGroup> identified by <worksetID>.
//
// When this function is invoked, all Clients with the workset open
// (including the invoking Client) are notified of the impending clear via
// the OM_WORKSET_CLEAR_IND event.  In response, each Client must invoke the
// OM_WorksetClearConfirm function; its view of the workset will not be
// cleared until it has done so.
//
//   Ensuing Events:
//
// This function will result in the OM_WORKSET_CLEAR_IND being posted to all
// Clients which have the workset open, including the invoking Client.
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_EXHAUSTED
//
//

void OM_WorksetClearConfirm(
                                    POM_CLIENT          pomClient,
                                    OM_WSGROUP_HANDLE   hWSGroup,
                                    OM_WORKSET_ID       worksetID);

//
//
//   Description:
//
// A Client must call this function after it receives an
// OM_WORKSET_CLEAR_IND.  When the function is invoked, ObMan clears this
// Client's view of the workset.  It is bad Groupware programming practice
// for a Client to unduly delay invoking this function.
//
// Note however that this function has a purely local effect: delaying (or
// executing) a clear confirm at one node will not affect the contents of
// the workset group at any other node.
//
// It is illegal to call this function when a Client has not received an
// OM_WORKSET_CLEAR_IND event.
//
// The arguments to the function must be the same as the workset group
// handle and workset ID included with the OM_WORKSET_CLEAR_IND event.
//
// The function will fail if ObMan is not expecting a clear-confirmation for
// this workset.
//
// This function causes all objects being read in this workset, and all
// object locks in this workset, to be released (i.e.  the function performs
// implicit OM_ObjectUnlock and OM_ObjectRelease functions).  It does not
// cause objects allocated using OM_ObjectAlloc to be discarded.
//
// If there are indication events for object Deletes, Replaces or Confirms
// which have been posted to the Client but not yet confirmed, these
// confirmations are implicitly executed.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms a clear using this
// function, an OM_WORKSET_CLEARED_IND is posted to all local secondary
// Clients of the workset group.
//
//   Return Codes:
//
// None
//
//


//
//
//   Description:
//
// These functions add an object to the workset in <hWSGroup> identified by
// <worksetID>.  The <ppObject> parameter is a pointer to a pointer to the
// object.
//
// The position to add the object is determined as follows:
//
// - OM_ObjectAddLast: after the last object in the workset
//
// - OM_ObjectAddFirst: before the first object in the workset
//
// - OM_ObjectAddAfter: after the object specified by <hExistingObject>
//
// - OM_ObjectAddBefore: before the object specified by <hExistingObject>.
//
// Note that the OM_ObjectAddAfter and OM_ObjectAddBefore functions require
// that the invoking Client holds a workset lock, whereas the
// OM_ObjectAddFirst and OM_ObjectAddLast functions will fail if the workset
// is locked by another Client.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectAddAfter and OM_ObjectAddBefore are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// On successful completion of the function, <phNewObject> points to the
// newly created handle of the object added.  The Client should use this
// handle in all subsequent ObMan calls relating to this object.
//
// The <ppObject> parameter must be a pointer to a valid object pointer
// returned by the OM_ObjectAlloc function.  If the function completes
// successfully, ObMan assumes ownership of the object and the value at
// <ppObject> is set to NULL to prevent the Client using the object pointer
// again.
//
// The <updateSize> parameter is the size (in bytes) of that portion of the
// object which may be updated using the OM_ObjectUpdate function (not
// counting the <length> field).
//
// Additions to a workset will be sequenced identically at all nodes which
// have the workset open, but the actual sequence arising from simultaneous
// additions by multiple Clients cannot be predicted in advance.
//
// If a set of Clients wishes to impose a particular sequence, they can
// enforce this using an agreed locking protocol based on the workset
// locking (in most cases, it is only necessary that the order is the same
// everywhere, which is why locking is not enforced by ObMan).
//
//   Ensuing Events:
//
// This function causes an OM_OBJECT_ADD_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED (AddFirst, AddLast only)
//  OM_RC_WORKSET_EXHAUSTED
//
//


//
//
//   Description:
//
// These functions move an object within a workset.  The workset is
// specified by <worksetID> and <hWSGroup> and the handle of the object to
// be moved is specified by <pObj>
//
// The position to which the object is moved is determined as follows:
//
// - OM_ObjectMoveLast: after the last object in the workset
//
// - OM_ObjectMoveFirst: before the first object in the workset
//
// - OM_ObjectMoveAfter: after the object specified by <pObj2>
//
// - OM_ObjectMoveBefore: before the object specified by <pObj2>.
//
// Note that OM_ObjectMoveAfter and OM_ObjectMoveBefore require that the
// invoking Client holds a workset lock, whereas the OM_ObjectMoveFirst and
// OM_ObjectMoveLast functions will fail if the workset is locked by another
// Client.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectMoveAfter and OM_ObjectMoveBefore are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// Locked objects may be moved.
//
// Neither the handle nor the ID of an object is altered by moving it within
// a workset.
//
//   Ensuing Events
//
// This action causes the OM_OBJECT_MOVE_IND to be posted to all Clients
// which have the workset open, including the invoking Client.
//
//   Return Codes
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_EXHAUSTED
//  OM_RC_WORKSET_LOCKED (MoveFirst, MoveLast only)
//
//

UINT OM_ObjectDelete(
                               POM_CLIENT               pomClient,
                               OM_WSGROUP_HANDLE	hWSGroup,
                               OM_WORKSET_ID           worksetID,
                               POM_OBJECT       pObj);

//
//
//   Description:
//
// This function requests that ObMan delete an object from a workset.  The
// workset is specified by <worksetID> and <hWSGroup> and the handle of the
// object to be deleted is <pObj>.
//
// The local copy of the object is not actually deleted until the Client
// invokes OM_ObjectDeleteConfirm in response to the OM_OBJECT_DELETE_IND
// event which this function generates.
//
// When this function is invoked, all Clients with the workset open
// (including the invoking Client) are notified of the impending deletion
// via the OM_OBJECT_DELETE_IND event.  In response, each Client must invoke
// the OM_ObjectDeleteConfirm function; each Client will have access to the
// object until it has done so.
//
// If this object is already pending deletion (i.e.  a DELETE_IND event has
// been posted to the Client but not yet Confirmed) this function returns
// the OM_RC_OBJECT_DELETED error.
//
// ObMan guarantees not to reuse a discarded object handle in the same
// workset within the lifetime of the workset group.
//
//   Ensuing Events:
//
// This function causes the OM_OBJECT_DELETE_IND to be posted to all Clients
// which have the workset open, including the invoking Client (except as
// where stated above).
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED
//  OM_RC_WORKSET_EXHAUSTED
//  OM_RC_OBJECT_DELETED
//
//

void   OM_ObjectDeleteConfirm(
                                      POM_CLIENT               pomClient,
                                      OM_WSGROUP_HANDLE	hWSGroup,
                                      OM_WORKSET_ID           worksetID,
                                      POM_OBJECT pObj);

//
//
//   Description:
//
// A Client must call this function after it receives an
// OM_OBJECT_DELETE_IND.  When the function is invoked, ObMan deletes the
// object specified by <hWSGroup>, <worksetID> and the value at <ppObj>.
// It is bad Groupware programming practice for a Client to unduly delay
// invoking this function.
//
// Note however that this function has a purely local effect: delaying (or
// executing) a delete confirm at one node will not affect the contents of
// the workset group at any other node.
//
// On successful completion, the handle of the deleted object becomes
// invalid and the value at <ppObj> is set to NULL to prevent the Client
// from further accessing this object.
//
// Any pointer to the previous version of this object which the Client had
// obtained using OM_ObjectRead becomes invalid and should not be referred
// to again (i.e.  the function performs an implicit OM_ObjectRelease).
//
// The function will cause an assertion failure if ObMan is not expecting a
// delete-confirmation for this object.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms a delete using this
// function, an OM_OBJECT_DELETED_IND is posted to all local secondary
// Clients of the workset group.
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectReplace(
                                POM_CLIENT               pomClient,
                                OM_WSGROUP_HANDLE	hWSGroup,
                                OM_WORKSET_ID           worksetID,
                                POM_OBJECT      pObj,
                                POM_OBJECTDATA *   ppData);

UINT OM_ObjectUpdate(
                                POM_CLIENT               pomClient,
                                OM_WSGROUP_HANDLE	hWSGroup,
                                OM_WORKSET_ID           worksetID,
                                POM_OBJECT      pObj,
                                POM_OBJECTDATA *    ppData);

//
//
//   Description:
//
// This function requests that ObMan replaces/updates the object specified
// by <pObj> in the workset specified by <worksetID> and <hWSGroup>.
//
// "Replacing" one object with another causes the previous object to be
// lost.  "Updating" an object causes only the first N bytes of the object
// to be replaced by the <data> field of the object supplied, where N is the
// <length> field of the update.  The rest of the object data remains the
// same, as does the length of the object.
//
// The local copy of the object is not actually replaced/updated until the
// Client invokes OM_ObjectReplaceConfirm/OM_ObjectUpdateConfirm in response
// to the OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND which this function
// generates.
//
// The <ppObject> parameter must be a pointer to a valid object pointer
// returned by the OM_ObjectAlloc function.  If the function completes
// successfully, ObMan assumes ownership of the object and the value at
// <ppObject> is set to NULL to prevent the Client using the object pointer
// again.
//
// Neither the handle nor the ID of an object is altered by replacing or
// updating the object.
//
// If the object is pending deletion i.e.  if ObMan has posted an
// OM_OBJECT_DELETE_IND event which has not yet been confirmed, the
// OM_RC_OBJECT_DELETED error is returned.
//
// If the object is pending replace or update i.e.  if ObMan has posted an
// OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND event which has not yet been
// confirmed, this replace/update spoils the previous one.  In this case, no
// further event is posted, and when the outstanding event is confirmed, the
// most recent replace/update is performed.
//
// The <reserved> parameter to OM_ObjectUpdate is not used in DC-Groupware
// R1.1 and must be set to zero.
//
// For a replace, the size of the object specified by <ppObject> must be at
// least as large as the <updateSize> specified when the object was
// originally added.
//
// For an update, the size of the object specified by <ppObject> must be the
// same as the <updateSize> specified when the object was originally added.
//
// Object replaces/updates will be sequenced identically at all nodes, but
// the actual sequence arising from simultaneous replace/update operations
// by multiple Clients cannot be predicted in advance.
//
// If a set of Clients wishes to impose a particular sequence, they should
// use an agreed locking protocol based on object or workset locking (in
// most cases, it is only necessary that the order is the same everywhere,
// which is why locking is not enforced by ObMan).
//
// Replaces and updates may be spoiled by ObMan so Client should not assume
// that an event will be generated for each replace or update carried out.
//
//   Ensuing Events:
//
// This function causes the OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND to be
// posted to all Clients which have the workset open, including the invoking
// Client.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//  OM_RC_WORKSET_LOCKED
//  OM_RC_OBJECT_LOCKED
//  OM_RC_OBJECT_DELETED
//
//

void OM_ObjectReplaceConfirm(
                                     POM_CLIENT               pomClient,
                                     OM_WSGROUP_HANDLE	hWSGroup,
                                     OM_WORKSET_ID           worksetID,
                                     POM_OBJECT     pObj);

void OM_ObjectUpdateConfirm(
                                     POM_CLIENT               pomClient,
                                     OM_WSGROUP_HANDLE	hWSGroup,
                                     OM_WORKSET_ID           worksetID,
                                     POM_OBJECT     pObj);

//
//
//   Description:
//
// When a Client receives an OM_OBJECT_REPLACE_IND/OM_OBJECT_UPDATE_IND, it
// must confirm the relevant operation by calling OM_ObjectReplaceConfirm or
// OM_ObjectUpdateConfirm.
//
// When the functions are invoked, ObMan replaces/updates the object
// specified by <hWSGroup>, <worksetID> and <pObj>.  It is bad Groupware
// programming practice for a Client to unduly delay invoking this function.
//
// Note however that these functions have a purely local effect: delaying
// (or executing) replace/update confirms at one node will not affect the
// contents of the workset group at any other node.
//
// Any pointer to the previous version of this object which the Client had
// obtained using OM_ObjectRead becomes invalid and should not be referred
// to again (i.e.  the functions perform an implicit OM_ObjectRelease).
//
// The functions will cause an assertion failure if ObMan is not expecting a
// replace- or update-confirmation for this object.
//
//   Ensuing Events:
//
// When the primary Client of a workset group confirms an update or replace
// using this function, an OM_OBJECT_UPDATED_IND/OM_OBJECT_REPLACED_IND is
// posted to all local secondary Clients of the workset group.
//
//   Return Codes
//
// None
//
//


UINT OM_ObjectLockReq(POM_CLIENT pomClient, OM_WSGROUP_HANDLE hWSGroup,
        OM_WORKSET_ID worksetID, POM_OBJECT pObj, BOOL reserved,
        OM_CORRELATOR * pCorrelator);


//
//
//   Description:
//
// This is an asynchronous function which requests a lock for the object
// specified by <pObj> in the workset identified by <worksetID> and
// <hWSGroup>.  When ObMan has processed the lock request, it will send an
// OM_OBJECT_LOCK_CON to the Client indicating success or the reason for
// failure.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectLockReq and OM_ObjectUnlock are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
// Holding an object lock prevents other Clients from
//
// - locking the workset
//
// - locking the object
//
// - updating or replacing the object
//
// - deleting the object.
//
// It does not prevent other Clients from reading the object or moving it
// within a workset.
//
// The function will cause an assertion failure if the Client requesting the
// lock already holds or has requested a lock which is equal to or after
// this one in the Universal Locking Order.
//
// On successful completion of the function, the value at <pCorrelator> is a
// value which the Client can use to correlate the subsequent
// OM_OBJECT_LOCK_CON event with this request.
//
// The <reserved> parameter is not used in DC-Groupware R1.1 and must be set
// to zero.
//
// A Client must release the lock when it no longer needs it, using the
// OM_ObjectUnlock function.  Locks will be automatically released when a
// Client closes the workset or deregisters from the workset group.
//
//   Ensuing Events:
//
// Invoking this function will cause the OM_OBJECT_LOCK_CON event to be
// posted to the invoking Client at some later time.
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void   OM_ObjectUnlock(
                               POM_CLIENT               pomClient,
                               OM_WSGROUP_HANDLE	hWSGroup,
                               OM_WORKSET_ID           worksetID,
                               POM_OBJECT       pObj);

//
//
//   Description:
//
// This function unlocks the object specified by <worksetID> and <pObj>.
// This must be the lock most recently acquired or requested by the Client;
// otherwise, the lock violation error causes an assertion failure.
//
// If this function is called before the OM_OBJECT_LOCK_CON event is
// received, the Client will not subsequently receive the event.
//
// ------------------------------------------------------------------------
//
// Note: OM_ObjectLockReq and OM_ObjectUnlock are not implemented in
//       DC-Groupware R1.1.
//
// ------------------------------------------------------------------------
//
//   Ensuing Events:
//
// This function causes an OM_OBJECT_UNLOCK_IND to be posted to all other
// Clients which have the workset open.
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectH(POM_CLIENT               pomClient,
                                        OM_WSGROUP_HANDLE	hWSGroup,
                                        OM_WORKSET_ID           worksetID,
                                        POM_OBJECT      pObjOther,
                                        POM_OBJECT *    pObj,
                                        OM_POSITION omPos);

UINT OM_ObjectRead(POM_CLIENT               pomClient,
                                      OM_WSGROUP_HANDLE	hWSGroup,
                                      OM_WORKSET_ID     worksetID,
                                      POM_OBJECT     pObj,
                                      POM_OBJECTDATA *  ppData);

//
//
//   Description:
//
// This function enables a Client to read the contents of an object by
// converting an object handle into a pointer to the object.
//
// On successful completion, the value at <ppObject> points to the specified
// object.
//
// Invoking this function causes the object to be held in memory at the
// location indicated by the return value at <ppObject>.  When it has
// finished reading the object, the Client must release it using the
// OM_ObjectRelease function.  Holding object pointer for extended lengths
// of time may adversely affect ObMan's ability to efficiently manage its
// memory.
//
// This pointer is valid until the Client releases the object, either
// explicitly with OM_ObjectRelease or implicitly.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_ObjectRelease(POM_CLIENT               pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID           worksetID,
                                       POM_OBJECT       pObj,
                                       POM_OBJECTDATA *    ppData);

//
//
//   Description:
//
// Calling this function indicates to ObMan that the Client has finished
// reading the object specified by the handle <pObj>.  The <ppObject>
// parameter is a pointer to a pointer to the object, which was previously
// obtained using OM_ObjectRead.
//
// On successful completion, the pointer to this object which the Client
// acquired using OM_ObjectRead becomes invalid (as the object may
// subsequently move in memory) and the value at <ppObject> is set to NULL
// to prevent the Client from using it again.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectAlloc(POM_CLIENT            pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID        worksetID,
                                       UINT                 length,
                                       POM_OBJECTDATA *     ppData);

//
//
//   Description:
//
// This function allocates a new, empty object the <data> field of which is
// <length> bytes long.  The object must be intended for subsequent
// insertion into the workset specified by <hWSGroup> and <worksetID>.
//
// Note that the <length> parameter is the length of the object's data field
// (so the total memory requirement for this function is length+4 bytes).
//
// The contents of the memory allocated are undefined, and it is the
// Client's responsibility to fill in the <length> field at the start of the
// object.
//
// On successful completion, the value at <ppObject> points to the new
// object.  This pointer is valid until the Client returns the object to
// ObMan using one of the functions mentioned here.
//
// A Client may write in this object and will normally insert it in the
// workset for which it was allocated using one of the object add, update or
// replace functions.  However, if a Client fails to do so or decides for
// some other reason not to do so, it must free up the object by calling the
// OM_ObjectDiscard function.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  Utility Service return codes
//
//

void OM_ObjectDiscard(POM_CLIENT             pomClient,
                                       OM_WSGROUP_HANDLE	hWSGroup,
                                       OM_WORKSET_ID         worksetID,
                                       POM_OBJECTDATA *     ppData);

//
//
//   Description:
//
// This function discards an object which a Client previously allocated
// using OM_ObjectAlloc.  A Client will call this function if for some
// reason it does not want to or cannot insert the object into the workset
// for which it was allocated.  A Client must not call this function for an
// object which it has already added to a workset or used to update or
// replace an object in a workset.
//
// On successful completion, the value at <ppObject> is set to NULL to
// prevent the Client from accessing the object again.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//

UINT OM_ObjectIDToPtr(POM_CLIENT            pomClient,
                                            OM_WSGROUP_HANDLE	hWSGroup,
                                            OM_WORKSET_ID        worksetID,
                                            OM_OBJECT_ID         objectID,
                                            POM_OBJECT *    ppObj);

//
//
//   Description:
//
// This functions converts an object ID to an object handle.  If no object
// with the specified ID is found in the specified workset, an error is
// returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_BAD_OBJECT_ID
//
//

void OM_ObjectPtrToID(POM_CLIENT            pomClient,
                                OM_WSGROUP_HANDLE   hWSGroup,
                                          OM_WORKSET_ID        worksetID,
                                          POM_OBJECT        pObj,
                                          POM_OBJECT_ID        pObjectID);

//
//
//   Description:
//
// This functions converts an object handle to an object ID.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
// None
//
//



//
//
//   Description
//
// These functions return information about a particular primary Client
// (identified by <hPerson>) of the workset group identified by <hWSGroup>
// <function profile> combination.
//
// If the person handle <hPerson> is invalid, the OM_RC_NO_SUCH_PERSON error
// is returned.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_NO_SUCH_PERSON
//  Utility Service return codes
//
//

UINT OM_GetNetworkUserID(
                                   POM_CLIENT                   pomClient,
                                   OM_WSGROUP_HANDLE    hWSGroup,
                                   NET_UID            *    pNetUserID);

//
//
//   Description:
//
// This functions returns ObMan's Network user ID for the call which
// contains the workset group specified by <hWSGroup>.
//
// This network ID corresponds to the <creator> field of objects defined by
// the Object Manager Function Profile.
//
// If the specified workset group is a local workset group (i.e.  its
// "call" is OM_NO_CALL), then the function returns OM_RC_LOCAL_WSGROUP.
//
//   Ensuing Events:
//
// None
//
//   Return Codes:
//
//  0 (== OK)
//  OM_RC_LOCAL_WSGROUP
//
//


BOOL CALLBACK OMSEventHandler(LPVOID pomClient, UINT event, UINT_PTR param1, UINT_PTR param2);

//
//
//   Description
//
// This is the handler that ObMan registers (as a Utility Service event
// handler) for Client tasks to trap ObMan events.  It serves two main
// purposes:
//
// - some state changes associated with events posted to Client tasks
//   are better made when the event arrives than when it is posted
//
// - this handler can detect and discard "out-of-date" events, such as
//   those arriving for a workset which a Client has just closed.
//
// The first parameter is the Client's ObMan handle, as returned by
// OM_Register, cast to a UINT.
//
// The second parameter is the event to be processed.
//
// The third and fourth parameters to the function are the two parameters
// associated with the event.
//
//


//
//
// OM_OUT_OF_RESOURCES_IND
//
//   Description:
//
// This abnormal failure event is posted when ObMan cannot allocate
// sufficient resources to complete a particular action, usually one
// prompted by a network event.
//
// Clients should treat this event as a fatal error and attempt to
// terminate.
//
// The parameters included with the event are reserved.
//
//

//
//
// OM_WSGROUP_REGISTER_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// register a Client with a workset group.  The parameters included with
// the event are defined as follows:
//
// - the second parameter is an OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the value which was returned by
//       the corresponding invocation of the OM_WSGroupRegisterPReq
//       function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          Utility Service return codes
//          OM_RC_OUT_OF_RESOURCES
//          OM_RC_TOO_MANY_CLIENTS
//          OM_RC_TOO_MANY_WSGROUPS
//          OM_RC_ALREADY_REGISTERED
//          OM_RC_CANNOT_CREATE_WSG
//
// - if the <result> field is 0 (== OK), the first parameter is an
//   OM_EVENT_DATA16 structure which contains a newly created handle
//   to the workset group involved (the <worksetID> field is
//   reserved).
//
// Once a Client has received this notification, it will receive
// OM_WORKSET_NEW_IND events to notify it of the existing worksets in the
// group, if there are any.
//
//

//
//
// OM_WSGROUP_MOVE_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// move an existing workset group into a Call.  The parameters included
// with the event are defined as follows:
//
// - the second parameter is an OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the value which was returned by
//       the corresponding invocation of the OM_WSGroupMoveReq
//       function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          Utility Service return codes
//          OM_RC_CANNOT_MOVE_WSGROUP
//
// - the first parameter is a OM_EVENT_DATA16 structure which contains the
//   handle of the workset group involved (the <worksetID> field is
//   reserved).
//
//

//
//
// OM_WSGROUP_MOVE_IND
//
//   Description:
//
// This event is posted when ObMan has moved a workset group either into or
// out of a Call.
//
// This will happen
//
// - when the workset group is moved out of a Call (because e.g.  the call
//   has ended), thus becoming a local workset group
//
// - when a local Client requests to move a local workset group into a
//   Call.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group involved (the <worksetID> field is reserved).
//
// - the second parameter is the handle of the Call into which the
//   workset group has been moved (== OM_NO_CALL when the workset group
//   has been moved out of a Call).
//
// If the workset group has been moved out of a call, it continues in
// existence as a local workset group and the Client may continue to use it
// as before.  However, no updates will be sent to or received from Clients
// residing on other nodes.
//
// If a Client wishes to move this workset group into another Call, it can
// do so using the OM_WSGroupMoveReq function.  Note that an attempt to move
// the workset group back into the same Call is likely to fail due to a name
// clash since the original version probably still exists in the Call.
//
// This event may also be prompted by the failure to allocate memory for a
// large object being transferred from another node.
//
//

//
//
// OM_WORKSET_NEW_IND
//
//   Description:
//
// This event is posted when a new workset has been created (by the
// receiving Client or by another Client).  The parameters included with
// the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_OPEN_CON
//
//   Description:
//
// This event is posted when ObMan has finished processing a request to
// open a workset for a specific Client.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_WorksetOpenReq function
//
//     - the <result> field is one of
//
//          0 (== OK)
//          OM_RC_OUT_OF_RESOURCES.
//
// In all but the case of OK, the open request has failed and the Client
// does not have the workset open.
//
//

//
//
// OM_WORKSET_LOCK_CON
//
//   Description:
//
// This event is posted to a Client when ObMan has succeeded in obtaining,
// or failed to obtain, a workset lock which the Client had requested.  The
// parameters included with the event are as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_WorksetLockReq function
//
//     - the <result> field is one of
//
//       0 (== OK)
//       OM_RC_OUT_OF_RESOURCES
//       OM_RC_WORKSET_LOCKED
//       OM_RC_OBJECT_LOCKED.
//
// In all but the case of OK, the lock request has failed and the Client
// does not hold the lock.
//
//

//
//
// OM_WORKSET_UNLOCK_IND
//
//   Description:
//
// This event is posted when a workset is unlocked using the
// OM_WorksetUnlock function.  The parameters included with the event are
// as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_CLEAR_IND
//
//   Description:
//
// This event is posted (to primary Clients only) after a local or remote
// Client has invoked the OM_WorksetClear function.  After a Client receives
// this event, it must call OM_WorksetClearConfirm to enable ObMan to clear
// the workset.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_WORKSET_CLEARED_IND
//
//   Description:
//
// This event is posted (to secondary Clients only) when a workset has been cleared.
//
// The parameters included with the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset involved
//
// - the second parameter is reserved.
//
//

//
//
// OM_OBJECT_ADD_IND
//
//   Description:
//
// This event is posted after a new object has been added to a workset.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_MOVE_IND
//
//   Description:
//
// This event is posted after a new object has been moved within a workset.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_DELETE_IND
//
//   Description:
//
// This event is posted (to primary Clients only) after a local or remote
// Client has invoked the OM_ObjectDelete function.  After a Client
// receives this event, it must call OM_ObjectDeleteConfirm to enable ObMan
// to delete the object.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
// See also OM_OBJECT_DELETED_IND.
//
//

//
//
// OM_OBJECT_REPLACE_IND
// OM_OBJECT_UPDATE_IND
//
//   Description:
//
// These events are posted (to primary Clients only) after a local or remote
// Client has invoked the OM_ObjectReplace/OM_ObjectUpdate function.  After
// a Client receives this event, it must call OM_ObjectReplaceConfirm/
// OM_ObjectUpdateConfirm to enable ObMan to replace/update the object.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
// See also OM_OBJECT_REPLACED_IND/OM_OBJECT_UPDATED_IND.
//
//

//
//
// OM_OBJECT_DELETED_IND
//
//   Description:
//
// This event is posted (to secondary Clients only) when an object has been
// deleted from a workset.  The handle it contains is thus invalid and can
// only be used to cross-reference against lists maintained by the Client.
//
// The Client must not invoke the OM_ObjectDeleteConfirm function on
// receipt of this event.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 identifying the workset
//   group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_REPLACED_IND
// OM_OBJECT_UPDATED_IND
//
//   Description:
//
// These events are posted (to secondary Clients only) when an object has
// been replaced or updated.  When the Client receives this event, the
// previous data is thus inaccessible.
//
// The Client must not invoke the OM_ObjectReplaceConfirm/
// OM_ObjectUpdateConfirm function on receipt of this event.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 identifying the workset
//   group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_OBJECT_LOCK_CON
//
//   Description:
//
// This event is posted to a Client when ObMan has succeeded in obtaining
// (or failed to obtain) an object lock which the Client had requested.
// The parameters included with the event are defined as follows:
//
// - the first parameter is reserved
//
// - the second parameter is a OM_EVENT_DATA32 structure:
//
//     - the <correlator> field is the correlator which was
//       returned by the corresponding invocation of the
//       OM_ObjectLockReq function
//
//     - the <result> field is one of
//
//       0 (== OK)
//       Utility Service return codes
//       OM_RC_WORKSET_LOCKED
//       OM_RC_OBJECT_LOCKED.
//
// In all but the case of OK, the lock request has failed and the Client
// does not hold the lock.
//
//

//
//
// OM_OBJECT_UNLOCK_IND
//
//   Description:
//
// This event is posted when a Client has released an object lock using the
// OM_ObjectUnlock function.
//
// The parameters to the event are defined as follows:
//
// - the first parameter is a OM_EVENT_DATA16 which identifies the
//   workset group and workset involved
//
// - the second parameter is the handle of the object involved.
//
//

//
//
// OM_PERSON_JOINED_IND
// OM_PERSON_LEFT_IND
// OM_PERSON_DATA_CHANGED_IND
//
//  Description:
//
// These events inform clients registered with a workset group when clients
// register with the workset group, deregister from it and set their person
// data, respectively.
//
// A client will also receive the appropriate events when it performs these
// actions itself.
//
//  Parameters:
//
// The first parameter in an OM_EVENT_DATA16 which identifies the workset
// group to which the event relates.  The <worksetID> field of the structure
// is undefined.
//
// The second parameter is the POM_EXTOBJEECT for the person to which the
// event relates.  These handles are not guaranteed to be still valid.  In
// particular, the handle received on the OM_PERSON_LEFT_IND is never valid.
// If a client wishes to correlate these events with a list of clients,
// then it is responsible for maintaining the list itself.
//
//


//
// OMP_Init()
// OMP_Term()
//

BOOL OMP_Init(BOOL * pfCleanup);
void OMP_Term(void);


void CALLBACK OMPExitProc(LPVOID pomPrimary);
BOOL CALLBACK OMPEventsHandler(LPVOID pomPrimary, UINT event, UINT_PTR param1, UINT_PTR param2);


//
//
// ProcessNetData(...)
//
// This function is called when a NET_EV_SEND_INDICATION event is received,
// indicating the arrival of a message from another instance of ObMan.  The
// function determines which OMNET_...  message is contained in the network
// packet and invokes the appropriate ObMan function to process the
// message.
//
//

void ProcessNetData(POM_PRIMARY          pomPrimary,
                    POM_DOMAIN           pDomain,
                    PNET_SEND_IND_EVENT  pNetEvent);


//
//
// ProcessNetDetachUser(...)
//
// This function is called when a NET_EV_DETACH_INDICATION event is received
// from the network layer.
//
// The function determines whether
//
// - we have been thrown out of the Domain by MCS, or
//
// - someone else has left/been thrown out
//
// and calls ProcessOwnDetach or ProcessOtherDetach as appropriate.
//
//

void ProcessNetDetachUser(POM_PRIMARY pomPrimary, POM_DOMAIN pDomain,
        NET_UID userID);

//
//
// ProcessNetAttachUser(...)
//
// This function is called when a NET_ATTACH_INDICATION event is received
// from the network layer.  The function calls MG_ChannelJoin to join us
// to our own single-user channel.
//
//

void ProcessNetAttachUser(POM_PRIMARY pomPrimary, POM_DOMAIN pDomain,
        NET_UID userID, NET_RESULT result);


//
//
// ProcessNetJoinChannel(...)
//
// This function is called when a NET_EV_JOIN_CONFIRM event is received from
// the network layer.  This function determines whether the join was
// successful and whether the channel joined is
//
// - our own single-user channel
//
// - the well-known ObManControl channel
//
// - a regular workset group channel
//
// and then takes appropriate action.
//
//

void ProcessNetJoinChannel(POM_PRIMARY        pomPrimary,
                                          POM_DOMAIN       pDomain,
                                          PNET_JOIN_CNF_EVENT  pNetJoinCnf);


//
//
// ProcessNetLeaveChannel(...)
//
// This function is called when a NET_EV_LEAVE_INDICATION event is received
// from the network layer, indicating that we've been thrown out of a
// channel.  This function determines whether the channel is
//
// - our own single-user channel
//
// - the well-known ObManControl channel
//
// - a regular workset group channel
//
// and then takes appropriate action; in the first two cases, this means
// behaving as if we've been thrown out of the Domain altogether, whereas
// we treat the last case just as if a Client had asked to move the workset
// group into the local Domain.
//
//

UINT ProcessNetLeaveChannel(POM_PRIMARY      pomPrimary,
                                           POM_DOMAIN     pDomain,
                                           NET_CHANNEL_ID     channel);


//
//
// DomainRecordFindOrCreate(...)
//
//

UINT DomainRecordFindOrCreate(POM_PRIMARY        pomPrimary,
                                            UINT             callID,
                                            POM_DOMAIN * ppDomain);


//
//
// DomainDetach(...)
//
void DomainDetach(POM_PRIMARY pomPrimary, POM_DOMAIN * ppDomain, BOOL fExit);


//
//
// DeregisterLocalClient(...)
//
// This function is called by the ObMan task after the local client
// deregisters from a workset group.  It causes this node's person object
// for the workset group to be deleted.
//
// If this node was the last node to be registered with the workset group,
// it also causes the relevant INFO object to be discarded.
//
// If this in turn causes the last workset group in the domain (which must
// be ObManControl) to be removed, ObMan is detached from the domain and
// the domain record becomes invalid.  In this case, the ppDomain
// pointer passed in is nulled out.
//
//

void DeregisterLocalClient(POM_PRIMARY pomPrimary,
                                        POM_DOMAIN *   ppDomain,
                                        POM_WSGROUP            pWSGroup,
                                        BOOL fExit);


//
//
// GetOMCWorksetPtr(...)
//
// This function derives a pointer to a specified workset in the
// ObManControl workset in the specified Domain.
//
//

UINT GetOMCWorksetPtr(POM_PRIMARY       pomPrimary,
                                     POM_DOMAIN      pDomain,
                                     OM_WORKSET_ID       worksetID,
                                     POM_WORKSET *  ppWorkset);


//
//
// SayWelcome(...)
//
// This function is called
//
// - when the "top" ObMan finishes initalizing (the WELCOME is broadcast)
//
// - when ObMan receives an HELLO message from a late joiner (the WELCOME
//   is sent to the late joiner)
//
//

UINT SayWelcome(POM_PRIMARY        pomPrimary,
                               POM_DOMAIN       pDomain,
                               NET_CHANNEL_ID       channel);


//
//
// ProcessWelcome(...)
//
// Called when a WELCOME is received from another node.  This may be in
// response to a HELLO, or it may be the "top" ObMan announcing the
// completion of its initialization.
//
// If this is the first WELCOME we've got for this Domain, we merge the
// capabilities and reply to the sender, asking for a copy of the
// ObManControl workset group.
//
//

UINT ProcessWelcome(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POMNET_JOINER_PKT  pWelcomePkt,
                                   UINT           lengthOfPkt);


//
//
// SayHello(...)
//
// Called when we join that domain and determine that we're not the "top"
// ObMan.  We expect a WELCOME to come in response.  We include our
// capabilities in the broadcast HELLO packet so that everyone knows what
// we support.
//
//

UINT SayHello(POM_PRIMARY   pomPrimary,
                             POM_DOMAIN  pDomain);


//
//
// ProcessHello(...)
//
// Called when we get a HELLO from another node.  If we've completed our
// own initialization in the domain, we merge in that node's capabilities,
// then we respond with a WELCOME.
//
//

UINT ProcessHello(POM_PRIMARY        pomPrimary,
                                 POM_DOMAIN       pDomain,
                                 POMNET_JOINER_PKT    pHelloPkt,
                                 UINT             lengthOfPkt);


//
//
// MergeCaps(...)
//
// Called by ProcessHello and ProcessWelcome to merge in capabilities
// received in the packet (which will be, respectively, a late joiner's
// capabilities or the domain-wide capabilities as determined by the sender
// of the WELCOME).
//
//

void MergeCaps(POM_DOMAIN       pDomain,
                            POMNET_JOINER_PKT    pJoinerPkt,
                            UINT             lengthOfPkt);


//
//
// ProcessOwnDetach(...)
//
// This function is called when a NET_EV_DETACH_INDICATION is received for a
// user ID that matches our own.  The function moves all of the workset
// groups for this Domain into ObMan's own "local" Domain.
//
//
UINT ProcessOwnDetach(POM_PRIMARY    pomPrimary,
                                     POM_DOMAIN   pDomain);


//
//
// ProcessOtherDetach(...)
//
// This function is called when a NET_EV_DETACH_INDICATION is received for a
// user ID that doesn't match our own.  The function examines each workset
// in the ObManControl workset group and deletes any registration objects
// that the departed node may have put there.
//
// If any local Clients have any of these worksets open, they are informed
// of the delete.  However, OBEJCT_DELETE messages are not broadcast
// throughout the Domain, since each ObMan will do them locally.
//
//

UINT ProcessOtherDetach(POM_PRIMARY     pomPrimary,
                                       POM_DOMAIN    pDomain,
                                       NET_UID           detachedUserID);


//
//
// WSGRegisterStage1(...)
//
// This function is ObMan's handler for the OMINT_EVENT_WSGROUP_REGISTER
// function.  It is the first step in the chain of functions running in the
// ObMan context which are invoked during the workset group registration
// process (the OM_WSGroupRegisterReq, running in the Client context,
// posted the original OMINT_EVENT_WSGROUP_REGISTER event).
//
// This function ensures that we are fully attached to the Domain (if not,
// it starts the Domain attach procedure and reposts a delayed
// OMINT_EVENT_WSGROUP_REGISTER event) and then starts the process of locking
// workset #0 in the ObManControl workset group.
//
//

void WSGRegisterStage1(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB);


//
// ProcessOMCLockConfirm(...)
//
void ProcessOMCLockConfirm(POM_PRIMARY pomPrimary, OM_CORRELATOR cor, UINT result);


//
// ProcessCheckpoint(...)
//
void ProcessCheckpoint(POM_PRIMARY pomPrimary, OM_CORRELATOR cor, UINT result);


//
//
// WSGRegisterStage2(...)
//
// This function is called when we have successfully locked workset #0 in
// ObManControl.
//
// The function checks workset #0 in ObManControl to see if the workset
// group we're trying to register the Client with already exists in the
// Domain.
//
// If it does, it finds the channel number and requests to join the
// channel.
//
// If it doesn't, it requests to join a new channel and also calls
// WSGGetNewID to generate a new workset group ID (unique within the
// Domain).
//
//

void WSGRegisterStage2(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB);


//
//
// WSGGetNewID(...)
//
// This function is called by WSGRegisterStage2 to generate a new workset
// group ID, in the case where the workset group doesn't already exist.
//
// It also creates a new workset in ObManControl with the same ID as the ID
// just generated.  This workset which will hold the registration objects
// for the new workset group
//
//

UINT WSGGetNewID(POM_PRIMARY     pomPrimary,
                                POM_DOMAIN    pDomain,
                                POM_WSGROUP_ID    pWSGroupID);


//
//
// WSGRegisterStage3(...)
//
// This function is called by ProcessNetJoinChannel when a Join event
// arrives for a workset group channel.
//
// Depending on whether or not the workset was created in Stage2, the
// function calls WSGAnnounce (if it was) or WSGCatchUp (if it was not).
//
// It then unlocks the ObManControl workset and calls WSGRegisterResult.
//
//

void WSGRegisterStage3(POM_PRIMARY         pomPrimary,
                                    POM_DOMAIN        pDomain,
                                    POM_WSGROUP_REG_CB    pRegistrationCB,
                                    NET_CHANNEL_ID        channelID);


//
//
// CreateAnnounce(...)
//
// This function is called by WSGRegisterStage3 after we have joined the
// channel for a new workset group.
//
// The function announces the new workset group throughout the Domain by
// adding an object containing the name, Function Profile, ObMan ID and MCS
// channel of the workset group to workset #0 in ObManControl.
//
// Note that this "announcement" cannot be made before the Join completes
// since we only learn the ID of the channel joined when we receive the
// Join event.
//
//

UINT CreateAnnounce(POM_PRIMARY    pomPrimary,
                                   POM_DOMAIN   pDomain,
                                   POM_WSGROUP      pWSGroup);


//
//
// RegAnnounceBegin(...)
//
// This function adds a registration object to a workset in ObManControl.
// The workset is determined by the ID of the workset group identified by
// <pWSGroup>.
//
// This function is called
//
// - when ObMan creates a workset group
//
// - when ObMan receives a request to send a workset group to a late
//   joiner.
//
// In the first case, the registration object identifies this node's use of
// the workset group.  In the second case, the reg object identifies the
// late joiner's use of the workset group.
//
// The object ID returned is the ID of the reg object added.
//
//

UINT RegAnnounceBegin(POM_PRIMARY          pomPrimary,
                                     POM_DOMAIN         pDomain,
                                     POM_WSGROUP            pWSGroup,
                                     NET_UID                nodeID,
                                     POM_OBJECT *   ppObjReg);


//
//
// RegAnnounceComplete(...)
//
// This function is called when we are fully caught up with a workset group
// we have joined, either because we have received the SEND_COMPLETE
// message or because we just created the group ourselves.
//
// The function updates the reg object specified by <regObjectID> by
// changing the <status> field to READY_TO_SEND.
//
//

UINT RegAnnounceComplete(POM_PRIMARY    pomPrimary,
                                        POM_DOMAIN   pDomain,
                                        POM_WSGROUP      pWSGroup);


//
//
// WSGCatchUp(...)
//
// This function is called by Stage3 after we have joined the channel
// belonging to a workset group which already exists in the Domain.
//
// The function examines ObManControl to find the MCS ID of an instance of
// ObMan which claims to have a copy of this workset group, then sends it a
// request to transfer the workset group.
//
// The function also posts a delayed timeout event so we don't wait for
// ever to get a workset group from a particular node (this timeout is
// processed in ProcessWSGSendTimeout).
//
//

UINT WSGCatchUp(POM_PRIMARY          pomPrimary,
                               POM_DOMAIN         pDomain,
                               POM_WSGROUP            pWSGroup);


//
//
// WSGRegisterResult(...)
//
// This function is called wherever any of the workset group registration
// functions have done enough processing to know the outcome of the
// registration attempt.  If all is well, it will be called by Stage3 but
// it may also be called earlier if an error occurs.
//
// The function posts an OM_WSGROUP_REGISTER_CON event to the Clientn which
// initiated the workset group registration.
//
//

void WSGRegisterResult(POM_PRIMARY        pomPrimary,
                                    POM_WSGROUP_REG_CB   pRegistrationCB,
                                    UINT             result);


//
//
// WSGRegisterRetry(...)
//
// This function is called wherever any of the workset group registration
// functions encounter a recoverable "error" situation, such as failing to
// get the ObManControl lock.
//
// This function checks if we've exceeded the retry count for this
// registration attempt and if not, reposts the OMINT_EVENT_WSGROUP_REGISTER
// event, so that the whole process is started again from Stage1.
//
// If we've run out of retries, WSGRegisterResult is invoked to post
// failure to the Client.
//
//

void WSGRegisterRetry(POM_PRIMARY       pomPrimary,
                                   POM_WSGROUP_REG_CB  pRegistrationCB);


//
//
// ProcessSendReq(...)
//
// This function is called when an OMNET_WSGROUP_SEND_REQ message is
// received from another node (i.e.  a late joiner)
//
// The function starts the process of sending the workset group contents to
// the late joiner.
//
//
void ProcessSendReq(POM_PRIMARY pomPrimary,
                                 POM_DOMAIN           pDomain,
                                 POMNET_WSGROUP_SEND_PKT  pSendReq);


//
//
// SendWSGToLateJoiner(...)
//
// This function is called when the checkpointing for a workset has
// completed.  It sends the contents to the late joiner node.
//
//

void SendWSGToLateJoiner(POM_PRIMARY pomPrimary,
                                      POM_DOMAIN        pDomain,
                                      POM_WSGROUP           pWSGroup,
                                      NET_UID               lateJoiner,
                                      OM_CORRELATOR          remoteCorrelator);

//
//
// ProcessSendMidway(...)
//
// This function is called when an OMNET_WSGROUP_SEND_MIDWAY message is
// received from another node (the node which was helping us by sending us
// the contents of a workset group).
//
// We have now received all the WORKSET_CATCHUP messages (one for each
// workset).  If all is well we inform the client that registration has
// been successful and set the workset group state to
// PENDING_SEND_COMPLETE.
//
//

void ProcessSendMidway(POM_PRIMARY           pomPrimary,
                                    POM_DOMAIN          pDomain,
                                    POMNET_WSGROUP_SEND_PKT pSendMidwayPkt);


//
//
// ProcessSendComplete(...)
//
// This function is called when an OMNET_WSGROUP_SEND_COMPLETE message is
// received from another node (the node which was helping us by sending us
// the contents of a workset group).
//
// If this message relates to the ObManControl workset group, we now have
// most of the ObManControl workset group (only "most" since there could be
// some recent objects still flying around).
//
// However, we do know that we have ALL the contents of workset #0 in
// ObManControl, since that workset is only ever altered under lock.
//
// Accordingly, we now consider ourselves to be fully-fledged members of
// the Domain, in the sense that we can correctly process our Clients
// requests to register with workset groups.
//
// If the message relates to another workset group, we now have enough of
// its contents to consider ourselves eligible to help other late joiners
// (as we have just been).  Therefore, we announce this eligibilty
// throughout the Domain (using the ObManControl workset group).
//
//

UINT ProcessSendComplete(
                         POM_PRIMARY             pomPrimary,
                         POM_DOMAIN            pDomain,
                         POMNET_WSGROUP_SEND_PKT   pSendCompletePkt);


//
//
// MaybeRetryCatchUp(...)
//
// This function is called on receipt of a DETACH indication from MCS or a
// SEND_DENY message from another node.  In both cases we compare the
// helperNode field in OM_WSGROUP structure with the userID and if they
// match then we retry the catch up.
//
// Depending on the workset group status we do the following:
//
// PENDING_SEND_MIDWAY : Retry the registration from the top.
// PENDING_SEND_COMPLETE : Just repeat the catch up.
//
// If there is no one to catch up from then we do the following depending
// on the workset group status:
//
// PENDING_SEND_MIDWAY : Retry the registration from the top.  Regardless
// of whether someone else is out there or not (they cannot be in the
// READY_TO_SEND state) we will end up in a consistent state.
//
// PENDING_SEND_COMPLETE : If two (or more) nodes are in this state and
// catching up from the same box who then leaves, they will have two
// partial sets of objects one of which may or may not be a subset of the
// other.  If there is no one else in the READY_TO_SEND state then each
// node needs to obtain a copy of all the objects in a given workset at the
// other node.
//
//

void MaybeRetryCatchUp(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN      pDomain,
                                    OM_WSGROUP_ID       wsGroupID,
                                    NET_UID             userID);


//
//
// IssueSendDeny(...)
//
// This function issues a SEND_DENY message to a remote node.
//
//
void IssueSendDeny(POM_PRIMARY pomPrimary,
                                  POM_DOMAIN    pDomain,
                                  OM_WSGROUP_ID     wsGroupID,
                                  NET_UID           sender,
                                  OM_CORRELATOR        remoteCorrelator);


//
//
// WSGRecordMove(...)
//
// This function moves the record for specified workset group from one
// Domain record to another, and posts events to all relevant Clients.  If
// does not check for name contention in the destination Domain.
//
//

void WSGRecordMove(POM_PRIMARY         pomPrimary,
                                POM_DOMAIN        pDestDomainRec,
                                POM_WSGROUP           pWSGroup);


//
//
// WSGMove(...)
//
// This function moves the record for specified workset group from one
// Domain record to another, and posts events to all relevant Clients.  If
// does not check for name contention in the destination Domain.
//
//

UINT WSGMove(POM_PRIMARY         pomPrimary,
                            POM_DOMAIN        pDestDomainRec,
                            POM_WSGROUP           pWSGroup);


//
//
// DomainAttach(...)
//
// This function calls MG_AttachUser to start the process of attaching to
// a Domain.  It also allocates and initialises the local structures
// associated with the Domain (the Domain record).
//
// A pointer to the newly-created Domain record is returned.
//
//

UINT DomainAttach(POM_PRIMARY          pomPrimary,
                                 UINT               callID,
                                 POM_DOMAIN *   ppDomainord);


//
//
// WSGRecordFindOrCreate(...)
//
// This function searches the workset group list in the specified Domain
// record for a workset group record whose name and FP match the ones
// specified.  If none is found, a new workset group record is allocated,
// initialised and inserted into the list.
//
// A pointer to the found-or-created workset group record is returned.
//
// NOTE: This function does not cause ObMan to join the workset group
//       channel or copy the workset group from another node if it
//       exists elsewhere; it merely creates the local structures for
//       the workset group.
//
//

UINT WSGRecordFindOrCreate(POM_PRIMARY pomPrimary,
                                          POM_DOMAIN     pDomain,
                                          OMWSG             wsg,
                                          OMFP            fpHandler,
                                          POM_WSGROUP *  ppWSGroup);


//
//
// ProcessSendQueue(...)
//
// This function prompts ObMan to examine the send queues for the specified
// Domain.  If there are any messages queued for sending (including remains
// of messages which have been partly sent), ObMan will try to send more
// data.  ObMan stops when either the send queues are all empty or the
// network layer has stopped giving us memory.
//
// The <domainRecBumped> flag indicates whether the Domain record has had
// its use count bumped; if TRUE, then this function calls UT_SubFreeShared
// to decrement the use count.
//
//

void ProcessSendQueue(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   BOOL             domainRecBumped);



//
// ProcessWSGDiscard(...)
//
void ProcessWSGDiscard(POM_PRIMARY pomPrimary, POM_WSGROUP pWSGroup);


//
// ProcessWSGMove(...)
//
UINT ProcessWSGMove(POM_PRIMARY    pomPrimary, long moveCBOffset);


//
// ProcessNetTokenGrab(...)
//
UINT ProcessNetTokenGrab(POM_PRIMARY           pomPrimary,
                                        POM_DOMAIN          pDomain,
                                        NET_RESULT              result);


//
// ProcessCMSTokenAssign(...)
//
void ProcessCMSTokenAssign(POM_PRIMARY         pomPrimary,
                                        POM_DOMAIN        pDomain,
                                        BOOL             success,
                                        NET_TOKEN_ID          tokenID);


//
// ProcessNetTokenInhibit(...)
//
UINT ProcessNetTokenInhibit(POM_PRIMARY          pomPrimary,
                                           POM_DOMAIN         pDomain,
                                           NET_RESULT             result);

//
// CreateObManControl(...)
//
UINT ObManControlInit(POM_PRIMARY   pomPrimary,
                                     POM_DOMAIN  pDomain);


//
// WSGDiscard(...)
//
void WSGDiscard(POM_PRIMARY pomPrimary,
                             POM_DOMAIN  pDomain,
                             POM_WSGROUP     pWSGroup,
                            BOOL fExit);


//
// IssueSendReq(...)
//
UINT IssueSendReq(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_WSGROUP        pWSGroup,
                                 NET_UID            remoteNode);


//
// GenerateUnlockMessage(...)
//
UINT GenerateUnlockMessage(POM_PRIMARY          pomPrimary,
                                          POM_DOMAIN         pDomain,
                                          OM_WSGROUP_ID          wsGroupID,
                                          OM_WORKSET_ID          worksetID,
                                          POMNET_LOCK_PKT *  ppUnlockPkt);


//
// ProcessWSGRegister(...)
//
void ProcessWSGRegister(POM_PRIMARY  pomPrimary, POM_WSGROUP_REG_CB pRegCB);


//
// LockObManControl(...)
//
void LockObManControl(POM_PRIMARY         pomPrimary,
                                   POM_DOMAIN        pDomain,
                                   OM_CORRELATOR    *  pLockCorrelator);


//
//
// MaybeUnlockObManControl(...)
//
// If the LOCKED_OMC flag is set in the registration CB, then unlock the
// Obman Control workset and clear the LOCKED_OMC flag.
//
//

void MaybeUnlockObManControl(POM_PRIMARY      pomPrimary,
                                          POM_WSGROUP_REG_CB pRegistrationCB);


//
// WSGRecordCreate(...)
//
UINT WSGRecordCreate(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN     pDomain,
                                    OMWSG          wsg,
                                    OMFP           fpHandler,
                                    POM_WSGROUP *  ppWSGroup);


//
//
// WorksetDiscard(...)
//
// This function is called by WSGDiscard to discard the individual worksets
// of a workset group when the last local Client deregisters.  It discards
// the contents of the workset, frees the workset record itself and clears
// the worksets's entry in the workset group record.
//
// It is not called when a workset is closed, since closing a workset does
// not discard its contents.
//
//

void WorksetDiscard(POM_WSGROUP pWSGroup, POM_WORKSET * pWorkset, BOOL fExit);


//
// ProcessLockNotify(...)
//
void ProcessLockNotify(POM_PRIMARY pomPrimary,
                                    POM_DOMAIN      pDomain,
                                    POM_WSGROUP         pWSGroup,
                                    POM_WORKSET        pWorkset,
                                    NET_UID             owner);


//
// SendMessagePkt(...)
//
UINT SendMessagePkt(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_SEND_INST      pSendInst);


//
// SendMoreData(...)
//
UINT SendMoreData(POM_PRIMARY      pomPrimary,
                                 POM_DOMAIN     pDomain,
                                 POM_SEND_INST      pSendInst);


//
// StartReceive(...)
//
UINT StartReceive(POM_PRIMARY     pomPrimary,
                                 POM_DOMAIN    pDomain,
                                 POMNET_OPERATION_PKT pHeaderPkt,
                                 POM_WSGROUP       pWSGroup,
                                 POM_WORKSET      pWorkset,
                                 POM_OBJECT   pObj);


//
// ProcessMessage(...)
//
// This function takes a receive control block (generated by ReceiveData)
// and tries to process it as an ObMan message.  If the message can not be
// processed at this time, it is put on the bounce list.  If the message is
// an "enabling" message (one which might enable previously bounced
// messages to be processed now) the bounce queue is flushed.
//
// Since this function is also called to process bounced messages, and
// since we want to prevent deep recursion as one bounced "enabling"
// message prompts re-examination of the bounce queue etc., we use the
// <whatNext> parameter to determine whether the bounce list should be
// examined.
//
//

UINT ProcessMessage(POM_PRIMARY        pomPrimary,
                                   POM_RECEIVE_CB       pReceiveCB,
                                   UINT             whatNext);

#define OK_TO_RETRY_BOUNCE_LIST     1
#define DONT_RETRY_BOUNCE_LIST      2

//
// ReceiveData(...)
//
UINT ReceiveData(POM_PRIMARY        pomPrimary,
                                POM_DOMAIN       pDomain,
                                PNET_SEND_IND_EVENT  pNetSendInd,
                                POMNET_OPERATION_PKT pNetMessage);


//
// TryToSpoilOp
//
UINT TryToSpoilOp(POM_SEND_INST pSendInst);


//
// DecideTransferSize(...)
//
void DecideTransferSize(POM_SEND_INST  pSendInst,
                                     UINT *        pTransferSize,
                                     UINT *        pDataTransferSize);


//
// CreateReceiveCB(...)
//
UINT CreateReceiveCB(POM_DOMAIN       pDomain,
                                    PNET_SEND_IND_EVENT  pNetSendInd,
                                    POMNET_OPERATION_PKT pNetMessage,
                                    POM_RECEIVE_CB * ppReceiveCB);


//
// FindReceiveCB(...)
//
UINT FindReceiveCB(POM_DOMAIN        pDomain,
                                  PNET_SEND_IND_EVENT   pNetSendInd,
                                  POMNET_OPERATION_PKT  pDataPkt,
                                  POM_RECEIVE_CB *  ppReceiveCB);

//
// WSGRegisterAbort(...)
//
void WSGRegisterAbort(POM_PRIMARY      pomPrimary,
                                   POM_DOMAIN     pDomain,
                                   POM_WSGROUP_REG_CB pRegistrationCB);


//
//
// BounceMessage(...)
//
// cmf
//
//

void BounceMessage(POM_DOMAIN        pDomain,
                                POM_RECEIVE_CB        pReceiveCB);


//
//
// NewDomainRecord(...)
//
//

UINT NewDomainRecord(POM_PRIMARY pomPrimary, UINT callID, POM_DOMAIN * ppDomain);

void FreeDomainRecord(POM_DOMAIN * ppDomain);


//
// ProcessBouncedMessages(...)
//
void ProcessBouncedMessages(POM_PRIMARY      pomPrimary,
                                         POM_DOMAIN     pDomain);


void WSGResetBytesUnacked(POM_WSGROUP            pWSGroup);

//
// NewHelperCB()
// FreeHelperCB()
//
BOOL NewHelperCB(POM_DOMAIN        pDomain,
                                POM_WSGROUP           pWSGroup,
                                NET_UID               lateJoiner,
                                OM_CORRELATOR            remoteCorrelator,
                                POM_HELPER_CB   * ppHelperCB);

void FreeHelperCB(POM_HELPER_CB   * ppHelperCB);


void PurgePendingOps(POM_WORKSET pWorkset, POM_OBJECT pObj);



OMFP    OMMapNameToFP(LPCSTR szName);
LPCSTR  OMMapFPToName(OMFP fp);

OMWSG   OMMapNameToWSG(LPCSTR szName);
LPCSTR  OMMapWSGToName(OMWSG wsg);


#endif // _H_OM

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\pm.h ===
//
// Palette Manager
//

#ifndef _H_PM
#define _H_PM



//
//
// CONSTANTS
//
//


//
// The number of true greys we want a true color system to deliver from a
// GetDIBits call. To vary this (number of greys and/or grey RGBs)
// -  alter the number defined for PM_GREY_COUNT below
// -  define suitable values for the grey RGBs below (PM_LIGHT_GREY, etc)
// -  change the initialisers for pmOurGreyRGB in wpmdata.c
// -  recompile the entire PM component.
//
#define PM_GREY_COUNT 5

//
// Grey RGBs passed into the true color display driver for conversion to
// a driver representation via an 8bpp GetDIBits.
//
#define PM_GREY1      0x00C0C0C0
#define PM_GREY2      0x00808080
#define PM_GREY3      0x006a6a6a
#define PM_GREY4      0x00555555
#define PM_GREY5      0x00333333



#define PM_NUM_1BPP_PAL_ENTRIES         2
#define PM_NUM_4BPP_PAL_ENTRIES         16
#define PM_NUM_8BPP_PAL_ENTRIES         256
#define PM_NUM_TRUECOLOR_PAL_ENTRIES    0


//
// The color table cache structure
//
typedef struct tagCOLORTABLECACHE
{
    BOOL    inUse;
    UINT    cColors;
    TSHR_RGBQUAD colors[256];
}
COLORTABLECACHE;
typedef COLORTABLECACHE * PCOLORTABLECACHE;



#endif // _H_PM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\oe2.h ===
//
// Order Encoder 2nd Level
//

#ifndef _H_OE2
#define _H_OE2


//
//
// TYPEDEFS
//
//

//
// The party order data structure contains all the data that is used by
// either the 2nd level encoder or decoder to store info on a party.
//
// The encoder contains just 1 instance of this structure, for the local
// party.
//
// The decoder contains 1 instance of the structure per remote party.
//
typedef struct _PARTYORDERDATA
{
    STRUCTURE_STAMP

    //
    // A copy of the last order of each type.
    // These are stored as byte array because we dont have a structure
    // defined that has the header and the particular order defined.
    //
    BYTE LastDstblt[sizeof(COM_ORDER_HEADER)+sizeof(DSTBLT_ORDER)];
    BYTE LastPatblt[sizeof(COM_ORDER_HEADER)+sizeof(PATBLT_ORDER)];
    BYTE LastScrblt[sizeof(COM_ORDER_HEADER)+sizeof(SCRBLT_ORDER)];
    BYTE LastMemblt[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_ORDER)];
    BYTE LastMem3blt[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_ORDER)];
    BYTE LastRectangle[sizeof(COM_ORDER_HEADER)+sizeof(RECTANGLE_ORDER)];
    BYTE LastLineTo[sizeof(COM_ORDER_HEADER)+sizeof(LINETO_ORDER)];
    BYTE LastTextOut[sizeof(COM_ORDER_HEADER)+sizeof(TEXTOUT_ORDER)];
    BYTE LastExtTextOut[sizeof(COM_ORDER_HEADER)+sizeof(EXTTEXTOUT_ORDER)];
    BYTE LastOpaqueRect[sizeof(COM_ORDER_HEADER)+sizeof(OPAQUERECT_ORDER)];
    BYTE LastSaveBitmap[sizeof(COM_ORDER_HEADER)+sizeof(SAVEBITMAP_ORDER)];
    BYTE LastDeskScroll[sizeof(COM_ORDER_HEADER)+sizeof(DESKSCROLL_ORDER)];
    BYTE LastMembltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEMBLT_R2_ORDER)];
    BYTE LastMem3bltR2[sizeof(COM_ORDER_HEADER)+sizeof(MEM3BLT_R2_ORDER)];
    BYTE LastPolygon[sizeof(COM_ORDER_HEADER)+sizeof(POLYGON_ORDER)];
    BYTE LastPie[sizeof(COM_ORDER_HEADER)+sizeof(PIE_ORDER)];
    BYTE LastEllipse[sizeof(COM_ORDER_HEADER)+sizeof(ELLIPSE_ORDER)];
    BYTE LastArc[sizeof(COM_ORDER_HEADER)+sizeof(ARC_ORDER)];
    BYTE LastChord[sizeof(COM_ORDER_HEADER)+sizeof(CHORD_ORDER)];
    BYTE LastPolyBezier[sizeof(COM_ORDER_HEADER)+sizeof(POLYBEZIER_ORDER)];
    BYTE LastRoundRect[sizeof(COM_ORDER_HEADER)+sizeof(ROUNDRECT_ORDER)];

    //
    // The type and a pointer to the last order
    //
    BYTE     LastOrderType;
    LPCOM_ORDER  pLastOrder;

    //
    // Details of the last font that was used
    //
    HFONT     LastHFONT;
    UINT      LastCodePage;
    UINT      LastFontWidth;
    UINT      LastFontHeight;
    UINT      LastFontWeight;
    UINT      LastFontFlags;
    UINT      LastFontFaceLen;
    char      LastFaceName[FH_FACESIZE];

    //
    // The last bounds that were used.
    //
    TSHR_RECT16    LastBounds;

    //
    // Font metrics, currently unused by the encoder.
    //
    TEXTMETRIC      LastFontMetrics;

    //
    // An array of pointers to the last orders of each type.
    //
    void *     LastOrder[OE2_NUM_TYPES];
}
PARTYORDERDATA, * PPARTYORDERDATA, * * PPPARTYORDERDATA;


//
//  This structure contains information for a single field in an ORDER
//  structure
//
//  FieldPos          - The byte offset into the order structure to the
//                      start of the field.
//
//  FieldUnencodedLen - The length in bytes of the unencoded field.
//
//  FieldEncodedLen   - The length in bytes of the encoded field.  This
//                      should always be <= to FieldUnencodedLen.
//
//  FieldSigned       - Does this field contain a signed or unsigned value?
//
//  FieldType         - A description of the type of the field - this
//                      is used to determine how to encode / decode the
//                      field.
//
//
typedef struct tagOE2ETFIELD
{
    UINT      FieldPos;
    UINT      FieldUnencodedLen;
    UINT      FieldEncodedLen;
    BOOL      FieldSigned;
    UINT      FieldType;
}OE2ETFIELD;

typedef OE2ETFIELD const FAR * POE2ETFIELD;

//
// Array of pointers to the entries in the encoding table
//
typedef POE2ETFIELD  OE2ETTYPE[OE2_NUM_TYPES];

//
//  This structure contains information allowing an ORDER structure to be
//  encoded or decoded into a DCEO2ORDER structure.
//  The order table comprises
//
//      - an array of POE2ETFIELD pointers, indexed by the encoded type
//         index:
//
//              typedef OE2ETTYPE POE2ETFIELD[OE2_NUM_TYPES]
//
//      - one array of OE2ETFIELD structures for each of the 7 order
//         types (each order type has a different number of fields).
//         Note that there may not be more than 24 entries for a single
//         ORDER type.  The entries for an order type are terminated
//         by an entry with the FieldPos field set to 0.  The first
//         FieldPos is non-zero since it is the offset to the second
//         field of the order (type is ignored).
//
//  pFields - an array of POE2ETFIELD pointers, indexed by the encoded
//             type index.  This is used to identify the entry in this
//             table for an ORDER type.
//
//  NumFields - an array of bytes containing the number of fields in each
//              order structure for each order.
//
//  DstBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the DSTBLT_ORDER
//
//  PatBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the PATBLT_ORDER
//
//  ScrBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the SCRBLT_ORDER
//
//  MemBltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEMBLT_ORDER
//
//  Mem3BltFields - array of OE2ETFIELD structures (one for each field)
//                     for the MEM3BLT_ORDER
//
//  TextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the TEXTOUT_ORDER
//
//  ExtTextOutFields - array of OE2ETFIELD structures (one for each field)
//                     for the EXTTEXTOUT_ORDER
//
//  RectangleFields - array of OE2ETFIELD structures (one for each field)
//                     for the RECTANGLE_ORDER
//
//  LineToFields - array of OE2ETFIELD structures (one for each field)
//                    for the LINETO_ORDER
//
//  OpaqueRectFields - array of OE2ETFIELD structures (one for each field)
//                    for the OPQAUERECT_ORDER
//
//  SaveBitmapFields - array of OE2ETFIELD structures (one for each field)
//                    for the SAVEBITMAP_ORDER
//
//  DeskScrollFields - array of OE2ETFIELD structures (one for each field)
//                    for the DESKSCROLL_ORDER
//  etc.
//
//
typedef struct tagOE2ETTABLE
{
        POE2ETFIELD pFields           [OE2_NUM_TYPES];
        BYTE     NumFields         [OE2_NUM_TYPES];
        OE2ETFIELD  DstBltFields      [OE2_NUM_DSTBLT_FIELDS];
        OE2ETFIELD  PatBltFields      [OE2_NUM_PATBLT_FIELDS];
        OE2ETFIELD  ScrBltFields      [OE2_NUM_SCRBLT_FIELDS];
        OE2ETFIELD  MemBltFields      [OE2_NUM_MEMBLT_FIELDS];
        OE2ETFIELD  Mem3BltFields     [OE2_NUM_MEM3BLT_FIELDS];
        OE2ETFIELD  TextOutFields     [OE2_NUM_TEXTOUT_FIELDS];
        OE2ETFIELD  ExtTextOutFields  [OE2_NUM_EXTTEXTOUT_FIELDS];
        OE2ETFIELD  RectangleFields   [OE2_NUM_RECTANGLE_FIELDS];
        OE2ETFIELD  LineToFields      [OE2_NUM_LINETO_FIELDS];
        OE2ETFIELD  OpaqueRectFields  [OE2_NUM_OPAQUERECT_FIELDS];
        OE2ETFIELD  SaveBitmapFields  [OE2_NUM_SAVEBITMAP_FIELDS];
        OE2ETFIELD  DeskScrollFields  [OE2_NUM_DESKSCROLL_FIELDS];
        OE2ETFIELD  MemBltR2Fields    [OE2_NUM_MEMBLT_R2_FIELDS];
        OE2ETFIELD  Mem3BltR2Fields   [OE2_NUM_MEM3BLT_R2_FIELDS];
        OE2ETFIELD  PolygonFields     [OE2_NUM_POLYGON_FIELDS];
        OE2ETFIELD  PieFields         [OE2_NUM_PIE_FIELDS];
        OE2ETFIELD  EllipseFields     [OE2_NUM_ELLIPSE_FIELDS];
        OE2ETFIELD  ArcFields         [OE2_NUM_ARC_FIELDS];
        OE2ETFIELD  ChordFields       [OE2_NUM_CHORD_FIELDS];
        OE2ETFIELD  PolyBezierFields  [OE2_NUM_POLYBEZIER_FIELDS];
        OE2ETFIELD  RoundRectFields   [OE2_NUM_ROUNDRECT_FIELDS];
} OE2ETTABLE;

//
//
// MACROS
//
//
//
// #define used to check that there is enough room left in the buffer
// for the encoded data which is about to be copied in.
//
#define ENOUGH_BUFFER(bend, start, datalen)   \
                  ( ((LPBYTE)(start)+(datalen)) <= (bend) )


//
// FUNCTION: OE2GetOrderType
//
// DESCRIPTION:
//
// This function converts the two byte flag used in an ORDER to record the
// type of order into an internal single byte value
//
// PARAMETERS:
//
//  pOrder    -  A pointer to the order
//
// RETURNS:
//
//  The type of the order (internal single byte value - see above)
//
//
BYTE OE2GetOrderType(LPCOM_ORDER  pOrder);

BOOL OE2CanUseDeltaCoords(void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);

void OE2CopyToDeltaCoords(LPTSHR_INT8* ppDestination,
                                       void *  pNewCoords,
                                       void *  pOldCoords,
                                       UINT   fieldLength,
                                       BOOL   signedValue,
                                       UINT   numElements);


//
// FUNCTION: OE2EncodeField
//
// DESCRIPTION:
//
// Convert a field which is an array of 1 or more elements, from its
// encoded form to its decoded form.
//
// PARAMETERS:
//
// pSrc            - Array of source values.
// ppDest          - Array of destination values.
// srcFieldLength  - The size of each of the elements in the source array.
// destFieldLength - The size of each of the elements in the destination
//                   array.
// signedValue     - Is the element a signed value ?
// numElements     - The number of elements in the arrays.
//
// RETURNS:
//
// None.
//
//
void OE2EncodeField(void *    pSrc,
                                 PBYTE*  ppDest,
                                 UINT     srcFieldLength,
                                 UINT     destFieldLength,
                                 BOOL     signedValue,
                                 UINT     numElements);


#endif // _H_OE2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\rbc.h ===
//
// Received Bitmap Cache
//

#ifndef _H_RBC
#define _H_RBC


//
// Number of RGB entries in the colour tables.
//
#define RBC_MAX_PALETTE_ENTRIES 256


//
// Information stored for each remote host.
//
typedef struct tagRBC_HOST_INFO
{
    STRUCTURE_STAMP

    BMC_DIB_CACHE   bitmapCache[NUM_BMP_CACHES];
}
RBC_HOST_INFO;

typedef RBC_HOST_INFO  * PRBC_HOST_INFO;



#endif // _H_RBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\oe.h ===
//
// Order Encoder
//

#ifndef _H_OE
#define _H_OE



//
// Required headers
//
#include <oa.h>
#include <shm.h>
#include <fh.h>



//
// Specific values for OSI escape codes
//
#define OE_ESC(code)            (OSI_OE_ESC_FIRST + code)

#define OE_ESC_NEW_FONTS        OE_ESC(0)
#define OE_ESC_NEW_CAPABILITIES OE_ESC(1)


//
// Structure: OE_NEW_FONTS
//
// Description:
//
// Structure to pass new font data down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_FONTS
{
    OSI_ESCAPE_HEADER header;           // Common header
    WORD                fontCaps;       // R11 font capabilities
    WORD                countFonts;     // Number of fonts in data block

    LPLOCALFONT         fontData;       // Local font table, containing
                                        // FH_MAX_FONTS entries

    LPWORD              fontIndex;      // Font table index, containing
                                        // FH_LOCAL_INDEX_SIZE entries

} OE_NEW_FONTS;
typedef OE_NEW_FONTS FAR * LPOE_NEW_FONTS;


//
// Structure: OE_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagOE_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendOrders;       // Are we allowed to send any
                                        // orders?

    DWORD           textEnabled;      // Are we allowed to send text
                                        // orders?

    DWORD           baselineTextEnabled;
                                        // Flag to indicate if we should
                                        //   encode text orders using
                                        //   baseline alignment.

    LPBYTE          orderSupported;     // Array of BYTE-sized booleans
}
OE_NEW_CAPABILITIES;
typedef OE_NEW_CAPABILITIES FAR * LPOE_NEW_CAPABILITIES;



//
// Flag to indicate support of second level order encoding.  This is used
// as a bitwise flag so that we can easily determine when parties have
// mixed capabilities.  Allowed values are:
//
//  OE2_FLAG_UNKNOWN       - OE2 supported has not been negotiated yet
//  OE2_FLAG_SUPPORTED     - OE2 is supported by at least one person
//  OE2_FLAG_NOT_SUPPORTED - OE2 is not supported by at least one person
//  OE2_FLAG_MIXED         - Oh no!  This results when we have 2 (or more)
//                           nodes that have differing OE2 support.  In
//                           this case we must disable OE2 encoding.
//
#define OE2_FLAG_UNKNOWN            0x00
#define OE2_FLAG_SUPPORTED          0x10
#define OE2_FLAG_NOT_SUPPORTED      0x01
#define OE2_FLAG_MIXED              0x11


//
//
// PROTOTYPES
//
//
#ifdef DLL_DISP



//
// Name:    OE_DDProcessRequest
//
// Purpose: Process an OE specific request from the Share Core
//
// Returns: TRUE if processed OK, FALSE otherwise
//
// Params:  pso   - SURFOBJ associated with ther request
//          cjIn  - size of input buffer
//          pvIn  - pointer to input buffer
//          cjOut - size of output buffer
//          pvOut - pointer to output buffer
//
#ifdef IS_16

BOOL    OE_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);

BOOL    OE_DDInit(void);

void    OE_DDViewing(BOOL fStart);

#else

ULONG   OE_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

#endif // IS_16

void    OE_DDTerm(void);

void    OEDDSetNewFonts(LPOE_NEW_FONTS pDataIn);

void    OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCaps);

BOOL    OE_SendAsOrder(DWORD order);
BOOL    OE_RectIntersectsSDA(LPRECT lpRect);

#endif // ifdef DLL_DISP


//
// Function prototypes.
//

//
// OE_GetStringExtent(..)
//
// FUNCTION:
//
// Gets the extent (in logical coords) of the specified string.
// The extent returned encloses all pels of the specified string.
//
//
// PARAMETERS:
//
// hdc - DC handle
//
// pMetric - pointer to text metrics for the font for the string; if NULL,
// use the global text metrics
//
// lpszString - pointer to null terminated string
//
// cbString - number of bytes in string
//
// lpDx - pointer to character increments. If NULL, use default character
// increments
//
// pRect - pointer to rect where string extent is returned
//
// RETURNS:
//
// The amount of overhang included in the returned extent
//
//     ------------------------------------....
//     |                                  ****:
//     |                                  *   :
//     |                                 ***  :
//     |                                * |   :
//     |                               *  |   :
//     |                             **** |   :
//     ------------------------------------....
//                                            ^
//                                            :-------- bounds are wider
//                                        ^             than text extent
//                                        |             due to overhang
//                     real text extent ends here
//
//
int OE_GetStringExtent(HDC hdc,
                                TEXTMETRIC*    pMetric,
                                LPSTR       lpszString,
                                UINT         cbString,
                                LPRECT        pRect      );



//
// Macros to lock down the buffer that we want to use.
//
// NOTE: We do not have any OE specific shared memory, so we'll use the OA
// shared data as a surrogate for the lock.  Since the lock is counting, we
// have no worries.
//
#define OE_SHM_START_WRITING  OA_SHM_START_WRITING

#define OE_SHM_STOP_WRITING   OA_SHM_STOP_WRITING

//
// Number of rectangles that can make up a clip region before it is too
// complicated to send as an order.
//
#define COMPLEX_CLIP_RECT_COUNT     4

//
// Mask and valid values for TextOut flAccel flags
//
#define OE_BAD_TEXT_MASK  ( SO_VERTICAL | SO_REVERSED | SO_GLYPHINDEX_TEXTOUT )


#ifdef DLL_DISP
//
// Structure to store brushes used as BLT patterns.
//
// style     - Standard brush style (used in order to send brush type).
//
//             BS_HATCHED
//             BS_PATTERN
//             BS_SOLID
//             BS_NULL
//
// hatch     - Standard hatch definition.  Can be one of the following.
//
//             style = BS_HATCHED
//
//             HS_HORIZONTAL
//             HS_VERTICAL
//             HS_FDIAGONAL
//             HS_BDIAGONAL
//             HS_CROSS
//             HS_DIAGCROSS
//
//             style = BS_PATTERN
//
//             This field contains the first byte of the brush definition
//             from the brush bitmap.
//
// brushData - bit data for the brush.
//
// fore      - foreground color for the brush
//
// back      - background color for the brush
//
// brushData - bit data for the brush (8x8x1bpp - 1 (see above) = 7 bytes)
//
//
typedef struct tagOE_BRUSH_DATA
{
    BYTE  style;
    BYTE  hatch;
    BYTE  pad[2];
    TSHR_COLOR  fore;
    TSHR_COLOR  back;
    BYTE  brushData[7];
} OE_BRUSH_DATA, * POE_BRUSH_DATA;

#ifndef IS_16
//
// Structure allowing sufficient stack to be allocated for an ENUMRECTS
// structure containing more than one (in fact COMPLEX_CLIP_RECT_COUNT)
// rectangles.
// This holds one RECTL more than we need to allow us to determine whether
// there are too many rects for order encoding by making a single call to
// CLIPOBJ_bEnumRects.
//
typedef struct tagOE_ENUMRECTS
{
    ENUMRECTS rects;
    RECTL     extraRects[COMPLEX_CLIP_RECT_COUNT];
} OE_ENUMRECTS;
#endif // !IS_16
#endif

//
// Font Alias table structure.  The font aliases convert non-existant fonts
// to ones that Windows supports in its default installation.
//
// pszOriginalFontName - Name of the non-existant font to be aliased
//
// pszAliasFontName    - Name of the font Windows uses instead of the non
//                       existant font.
//
// charWidthAdjustment - Character adjustment to make a decent match.
//
typedef struct _FONT_ALIAS_TABLE
{
    LPBYTE          pszOriginalFontName;
    LPBYTE          pszAliasFontName;
    TSHR_UINT16     charWidthAdjustment;
}
FONT_ALIAS_TABLE;


//
// ROP4 to ROP3 conversion macros.  Note that we don't use the full Windows
// 3-way ROP code - we are only interested in the index byte.
//
#define ROP3_HIGH_FROM_ROP4(rop) ((TSHR_INT8)((rop & 0xff00) >> 8))
#define ROP3_LOW_FROM_ROP4(rop)  ((TSHR_INT8)((rop & 0x00ff)))

//
// OS specific RECTL to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
#define RECT_FROM_RECTL(dcr, rec) if (rec.right < rec.left)                \
                                    {                                        \
                                        dcr.left   = rec.right;              \
                                        dcr.right  = rec.left;               \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.left   = rec.left;               \
                                        dcr.right  = rec.right;              \
                                    }                                        \
                                    if (rec.bottom < rec.top)                \
                                    {                                        \
                                        dcr.bottom = rec.top;                \
                                        dcr.top    = rec.bottom;             \
                                    }                                        \
                                    else                                     \
                                    {                                        \
                                        dcr.top    = rec.top;                \
                                        dcr.bottom = rec.bottom;             \
                                    }

//
// OS specific RECTFX to RECT conversion macro.  Note that this macro
// guarantees to return a well-ordered rectangle.
//
// A RECTFX uses fixed point (28.4 bit) numbers so we need to truncate the
// fraction and move to the correct integer value, i.e. shift right 4 bits.
//
#define RECT_FROM_RECTFX(dcr, rec)                                         \
                                if (rec.xRight < rec.xLeft)                  \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xRight);      \
                                    dcr.right = FXTOLCEILING(rec.xLeft);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.left  = FXTOLFLOOR(rec.xLeft);       \
                                    dcr.right = FXTOLCEILING(rec.xRight);    \
                                }                                            \
                                if (rec.yBottom < rec.yTop)                  \
                                {                                            \
                                    dcr.bottom= FXTOLCEILING(rec.yTop);      \
                                    dcr.top   = FXTOLFLOOR(rec.yBottom);     \
                                }                                            \
                                else                                         \
                                {                                            \
                                    dcr.top   = FXTOLFLOOR(rec.yTop);        \
                                    dcr.bottom= FXTOLCEILING(rec.yBottom);   \
                                }

#define POINT_FROM_POINTL(dcp, pnt) dcp.x = pnt.x;                \
                                    dcp.y = pnt.y


#define POINT_FROM_POINTFIX(dcp, pnt) dcp.x = FXTOLROUND(pnt.x);  \
                                      dcp.y = FXTOLROUND(pnt.y)


//
// Macros to check for articular types of ROP code.
//
#define ROP3_NO_PATTERN(rop) ((rop & 0x0f) == (rop >> 4))

#define ROP3_NO_SOURCE(rop)  ((rop & 0x33) == ((rop & 0xCC) >> 2))

#define ROP3_NO_TARGET(rop)  ((rop & 0x55) == ((rop & 0xAA) >> 1))

//
// Checking for SRCCOPY, PATCOPY, BLACKNESS, WHITENESS
//
#define ROP3_IS_OPAQUE(rop)  ( ((rop) == 0xCC) || ((rop) == 0xF0) || \
                               ((rop) == 0x00) || ((rop) == 0xFF) )

//
// 3-way rop equating to the COPYPEN mix.
//
#define OE_COPYPEN_ROP (BYTE)0xf0



#ifdef DLL_DISP

void  OEConvertMask(ULONG  mask, LPUINT pBitDepth, LPUINT pShift);


#ifdef IS_16

//
// GDI never made defines for these, so we will.
//
#define PALETTEINDEX_FLAG   0x01000000L
#define PALETTERGB_FLAG     0x02000000L
#define COLOR_FLAGS         0x03000000L

//
// This is a GLOBAL to cut down on stack space, and is only valid during
// the life of a DDI call that is not reentrant.
//
// When we calculate something, we set the bit saying we did.  This speeds 
// up our code a lot from NM 2.0 which used to calculate the same things
// over and over again.
//

#define OESTATE_SDA_DCB         0x0001  // Send as screen data, use DCBs
#define OESTATE_SDA_SCREEN      0x0002  // Send as screen data, use screen rc
#define OESTATE_SDA_MASK        0x0003  // Send rc as screen data
#define OESTATE_SDA_FONTCOMPLEX 0x0004  // Send as screen data if font too complex
#define OESTATE_OFFBYONEHACK    0x0010  // Add one pixel onto bottom after DDI
#define OESTATE_CURPOS          0x0020  // Save curpos before DDI call
#define OESTATE_DDISTUFF        0x003F

#define OESTATE_COORDS          0x0100
#define OESTATE_PEN             0x0200
#define OESTATE_BRUSH           0x0400
#define OESTATE_REGION          0x0800
#define OESTATE_FONT            0x1000
#define OESTATE_GET_MASK        0x1F00

#define MIN_BRUSH_WIDTH         8
#define MAX_BRUSH_WIDTH         16
#define TRACKED_BRUSH_HEIGHT    8

#define TRACKED_BRUSH_SIZE      8

typedef struct tagOESTATE
{
    UINT            uFlags;
    HDC             hdc;
    LPDC            lpdc;
    RECT            rc;

    //
    // These are used when calcing the bounds is too complicated, so we 
    // let GDI do it for us, albeit slower.
    //
    UINT            uGetDCB;
    UINT            uSetDCB;
    RECT            rcDCB;

    POINT           ptCurPos;
    POINT           ptDCOrg;
    POINT           ptPolarity;
    LOGPEN          logPen;
    LOGBRUSH        logBrush;
    BYTE            logBrushExtra[TRACKED_BRUSH_SIZE];
    LOGFONT         logFont;
    int             tmAlign;
    TEXTMETRIC      tmFont;
    REAL_RGNDATA    rgnData;
} OESTATE, FAR* LPOESTATE;

void    OEGetState(UINT uFlags);
BOOL    OEBeforeDDI(DDI_PATCH ddiType, HDC hdc, UINT flags);
BOOL    OEAfterDDI(DDI_PATCH ddiType, BOOL fWeCare, BOOL fOutputHappened);


#define OECHECK_PEN         0x0001
#define OECHECK_BRUSH       0x0002
#define OECHECK_FONT        0x0004
#define OECHECK_CLIPPING    0x0010
BOOL    OECheckOrder(DWORD order, UINT flags);


LPDC    OEValidateDC(HDC hdc, BOOL fSrc);
void    OEMaybeBitmapHasChanged(LPDC lpdc);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR* lpExtraInfo);
void    OEClipAndAddScreenData(LPRECT pRect);


void    OELPtoVirtual(HDC hdc, LPPOINT aPts, UINT cPts);
void    OELRtoVirtual(HDC hdc, LPRECT aRcs, UINT cRcs);

void    OEGetPolarity(void);
void    OEPolarityAdjust(LPRECT pRects, UINT cRects);
void    OEPenWidthAdjust(LPRECT lprc, UINT divisor);
BOOL    OETwoWayRopToThree(int, LPDWORD);

BOOL    OEClippingIsSimple(void);
BOOL    OEClippingIsComplex(void);
BOOL    OECheckPenIsSimple(void);
BOOL    OECheckBrushIsSimple(void);

void    OEExpandColor(LPBYTE lpField, DWORD clrSrc, DWORD fieldMask);
void    OEConvertColor(DWORD rgb, LPTSHR_COLOR lptshrDst, BOOL fAllowDither);
void    OEGetBrushInfo(LPTSHR_COLOR pClrBack, LPTSHR_COLOR pClrFore,
    LPTSHR_UINT32 lpBrushStyle, LPTSHR_UINT32 lpBrushHatch, LPBYTE lpBrushExtra);


void    OEAddLine(POINT ptStart, POINT ptEnd);
void    OEAddBlt(DWORD rop);
void    OEAddOpaqueRect(LPRECT);
void    OEAddRgnPaint(HRGN hrgnnPaint, HBRUSH hbrPaint, UINT rop);
void    OEAddPolyline(POINT ptStart, LPPOINT apts, UINT cpts);
void    OEAddPolyBezier(POINT ptStart, LPPOINT apts, UINT cpts);


//
// Cached font width info
//
typedef struct tagFH_CACHE
{
    UINT    fontIndex;
    UINT    fontWidth;
    UINT    fontHeight;
    UINT    fontWeight;
    UINT    fontFlags;
    UINT    charWidths[256];
} FH_CACHE, FAR* LPFH_CACHE;

void    OEAddText(POINT ptDst, UINT uOptions, LPRECT lprcClip, LPSTR lpszText,
            UINT cchText, LPINT lpdxCharSpacing);
int     OEGetStringExtent(LPSTR lpszText, UINT cchText, LPINT lpdxCharSpacing, LPRECT lprcExtent);
BOOL    OECheckFontIsSupported(LPSTR lpszText, UINT cchText, LPUINT pFontHeight,
    LPUINT pFontWidth, LPUINT pFontWeight, LPUINT pFontFlags,
    LPUINT pFontIndex, LPBOOL lpfSendDeltaX);
BOOL    OEAddDeltaX(LPEXTTEXTOUT_ORDER pExtTextOut, LPSTR lpszText, UINT cchText,
    LPINT lpdxCharSpacing, BOOL fSendDeltaX, POINT ptStart);

#else

void    OELPtoVirtual(LPPOINT pPoints, UINT cPoints);
void    OELRtoVirtual(LPRECT pRects, UINT cRects);

void    OEClipAndAddOrder(LPINT_ORDER pOrder, void FAR * pExtraInfo, CLIPOBJ* pco);
void    OEClipAndAddScreenData(LPRECT pRect, CLIPOBJ* pco);

BOOL    OEClippingIsSimple(CLIPOBJ* pco);
BOOL    OEClippingIsComplex(CLIPOBJ* pco);
BOOL    OECheckBrushIsSimple(LPOSI_PDEV ppdev, BRUSHOBJ* pbo, POE_BRUSH_DATA * ppBrush);

void    OEExpandColor(LPBYTE lpField, ULONG clrSrc, ULONG mask);
void    OEConvertColor(LPOSI_PDEV ppdev, LPTSHR_COLOR pDCColor, ULONG osColor, XLATEOBJ* pxlo);
BOOL    OEAddLine(LPOSI_PDEV ppdev,
                             LPPOINT  startPoint,
                             LPPOINT  endPoint,
                             LPRECT   rectTrg,
                             UINT  rop2,
                             UINT  width,
                             UINT  color,
                             CLIPOBJ*  pco);


BOOL  OEAccumulateOutput(SURFOBJ* pso, CLIPOBJ *pco, LPRECT pRect);
BOOL  OEAccumulateOutputRect( SURFOBJ* pso, LPRECT pRect);


BOOL  OEStoreBrush(LPOSI_PDEV ppdev,
                                BRUSHOBJ* pbo,
                                BYTE   style,
                                LPBYTE  pBits,
                                XLATEOBJ* pxlo,
                                BYTE   hatch,
                                UINT  color1,
                                UINT  color2);

BOOL  OECheckFontIsSupported(FONTOBJ*  pfo, LPSTR lpszText, UINT cchText,
    LPUINT fontHeight, LPUINT pFontAscent, LPUINT pFontWidth,
    LPUINT pFontWeight, LPUINT pFontFlags, LPUINT pFontIndex,
    LPBOOL pfSendDeltaX);


void  OETileBitBltOrder(LPINT_ORDER               pOrder,
                                     LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                     CLIPOBJ*                 pco);

void  OEAddTiledBitBltOrder(LPINT_ORDER               pOrder,
                                         LPMEMBLT_ORDER_EXTRA_INFO pExtraInfo,
                                         CLIPOBJ*                 pco,
                                         int                      xTile,
                                         int                      yTile,
                                         UINT                 tileWidth,
                                         UINT                 tileHeight);

BOOL OEEncodePatBlt(LPOSI_PDEV   ppdev,
                                 BRUSHOBJ   *pbo,
                                 POINTL     *pptlBrush,
                                 BYTE       rop3,
                                 LPRECT     pBounds,
                                 LPINT_ORDER *ppOrder);

#endif // !IS_16

#endif // DLL_DISP



//
// Structures and typedefs.
//

//
// Remote font is the structure we store for each font received from a
// remote party.  It mirrors the NETWORKFONT structure, with the facename
// replaced with an index value (used to map the remote font handle to the
// correct local font handle).
//
typedef struct _OEREMOTEFONT
{
    TSHR_UINT16    rfLocalHandle;
    TSHR_UINT16    rfFontFlags;
    TSHR_UINT16    rfAveWidth;
    TSHR_UINT16    rfAveHeight;
    // lonchanc: rfAspectX and rfAspectY are used in network packet header
    // for both R11 and R20. So, keep it around!
    TSHR_UINT16    rfAspectX;          // New field for r1.1
    TSHR_UINT16    rfAspectY;          // New field for r1.1
    TSHR_UINT8     rfSigFats;          // New field for r2.0
    TSHR_UINT8     rfSigThins;         // New field for r2.0
    TSHR_UINT16    rfSigSymbol;        // New field for r2.0
    TSHR_UINT16    rfCodePage;         // New field for R2.0
    TSHR_UINT16    rfMaxAscent;        // New field for R2.0
}
OEREMOTEFONT, * POEREMOTEFONT;


void    OEMaybeEnableText(void);
BOOL    OERectIntersectsSDA(LPRECT pRectVD);

BOOL    OESendRop3AsOrder(BYTE rop3);



#endif // _H_OE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\od.h ===
//
// Order Decoder
//

#ifndef _H_OD
#define _H_OD



//
// Max # of accumulated bound rects we'll save in the total invalid
// region before simplifying it.
//
#define MAX_UPDATE_REGION_ORDERS 300


//
// Constants used by ODAdjustVGAColor (qv)
//
enum
{
    OD_BACK_COLOR   = 0,
    OD_FORE_COLOR   = 1,
    OD_PEN_COLOR    = 2,
    // number of the above colors.
    OD_NUM_COLORS   = 3
};


COLORREF __inline ODCustomRGB(BYTE r, BYTE g, BYTE b, BOOL fPaletteRGB)
{
    if (fPaletteRGB)
    {
        return(PALETTERGB(r, g, b));
    }
    else
    {
        return(RGB(r, g, b));
    }
}


//
// Structure used by ODAdjustVGAColor (qv)
//
typedef struct tagOD_ADJUST_VGA_STRUCT
{
    COLORREF    color;
    UINT        addMask;
    UINT        andMask;
    UINT        testMask;
    TSHR_COLOR  result;
}
OD_ADJUST_VGA_STRUCT;


//
// This internal routine is implemented as a macro rather than a function.
//
UINT __inline ODConvertToWindowsROP(UINT bRop)
{
    extern const UINT s_odWindowsROPs[256];

    ASSERT(bRop < 256);
    return(s_odWindowsROPs[bRop]);
}



#endif // _H_OD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\osi.h ===
//
// OS Isolation (BOGUS!)
//

#ifndef _H_OSI
#define _H_OSI


//
// Control for shared code
//


//
// Maximum number of entries in a palette.
//
#define OSI_MAX_PALETTE             256


// Structure: OSI_ESCAPE_HEADER
//
// Description: Structure common to all display driver requests.  These
// fields are checked before the Display Driver will attempt to process the
// request.
//
typedef struct tagOSI_ESCAPE_HEADER
{
    DWORD       padding;        // For faulty drivers
    DWORD       identifier;     // Unique identifier for all our requests.
    DWORD       escapeFn;       // Function to be processed.  In the case
                                // of ESC_QUERYSUPPORT, this is the ID
                                // of the function to be queried.
    DWORD       version;        // Version #
}
OSI_ESCAPE_HEADER;
typedef OSI_ESCAPE_HEADER FAR * LPOSI_ESCAPE_HEADER;


//
// Unique identifier for all our requests
//
#define OSI_ESCAPE_IDENTIFIER   0xDC123BED


//
// Unique escape code for all our DC-Share specific requests.
//
#define OSI_ESC_CODE            31170


//
// Internal Windows NT Escape Function WNDOBJ_SETUP.  This is the Escape
// code that must be called in order for the Display Driver to be allowed
// to call EngCreateWindow.  Unfortunately, it is defined in winddi.h,
// which can't be included in User-mode compilations.
//
// I define it here: if it changes in winddi.h, this line will fail to
// compile in a Display Driver compilation.
//
#define WNDOBJ_SETUP    4354        // for live video ExtEscape


//
// Allowed ranges of escape functions
//
#define OSI_ESC_FIRST           0
#define OSI_ESC_LAST            0xFF

#define OSI_OE_ESC_FIRST        0x100
#define OSI_OE_ESC_LAST         0x1FF

#define OSI_HET_ESC_FIRST       0x200
#define OSI_HET_ESC_LAST        0x2FF

#define OSI_SBC_ESC_FIRST       0x400
#define OSI_SBC_ESC_LAST        0x4FF

#define OSI_HET_WO_ESC_FIRST    0x500
#define OSI_HET_WO_ESC_LAST     0x5FF

#define OSI_SSI_ESC_FIRST       0x600
#define OSI_SSI_ESC_LAST        0x6FF

#define OSI_CM_ESC_FIRST        0x700
#define OSI_CM_ESC_LAST         0x7FF

#define OSI_OA_ESC_FIRST        0x800
#define OSI_OA_ESC_LAST         0x8FF

#define OSI_BA_ESC_FIRST        0x900
#define OSI_BA_ESC_LAST         0x9FF


//
// Specific values for OSI escape codes
//
#define OSI_ESC(code)                   (OSI_ESC_FIRST + code)

#define OSI_ESC_INIT                    OSI_ESC(0)
#define OSI_ESC_TERM                    OSI_ESC(1)
#define OSI_ESC_SYNC_NOW                OSI_ESC(2)



//
// Used to determine if our driver is around, hosting is possible, and to
// returned mapped shared memory if so after initializing.
//

#define SHM_SIZE_USED   (sizeof(SHM_SHARED_MEMORY) + 2*sizeof(OA_SHARED_DATA))

#define SHM_MEDIUM_TILE_INDEX       0
#define SHM_LARGE_TILE_INDEX        1
#define SHM_NUM_TILE_SIZES          2

typedef struct tagOSI_INIT_REQUEST
{
    OSI_ESCAPE_HEADER   header;
    DWORD               result;
    LPVOID              pSharedMemory;
    LPVOID              poaData[2];

    DWORD               sbcEnabled;
    LPVOID              psbcTileData[SHM_NUM_TILE_SIZES];
    DWORD               aBitmasks[3];
} OSI_INIT_REQUEST;
typedef OSI_INIT_REQUEST FAR* LPOSI_INIT_REQUEST;


//
// Used when shutting down to cleanup any allocated objects and memory
//
typedef struct tagOSI_TERM_REQUEST
{
    OSI_ESCAPE_HEADER   header;
} OSI_TERM_REQUEST;
typedef OSI_TERM_REQUEST FAR* LPOSI_TERM_REQUEST;



#ifdef DLL_DISP


#ifndef IS_16
//
// We have a circular structure dependency, so prototype the necessary data
// here.
//
typedef struct tagOSI_DSURF OSI_DSURF;



//
// Tag used to identify all memory allocated by the display driver.
//
#define OSI_ALLOC_TAG     'DDCD'


// Structure: OSI_PDEV
//
// Description:
//
// Contents of our private data pointer; GDI always passes this to us on
// each call to the display driver. This structure is initialized in
// DrvEnablePDEV handling.
//
typedef struct  tagOSI_PDEV
{
    //
    // Rendering extensions colour information.
    //
    HANDLE      hDriver;                // Handle to \Device\Screen
    HDEV        hdevEng;                // Engine's handle to PDEV
    HSURF       hsurfScreen;            // Engine's handle to screen
    OSI_DSURF*  pdsurfScreen;           // Our private DSURF for the screen

    LONG        cxScreen;               // Visible screen width
    LONG        cyScreen;               // Visible screen height
    LONG        cBitsPerPel;            // Bits per pel (8,15,16,24,32,etc)
        // This is only 8 or 24 on NT 5.0!

    //
    // Color/pixel format
    //
    ULONG       iBitmapFormat;          // Current colour depth as defined
    FLONG       flRed;                  // Red mask for bitmask modes
    FLONG       flGreen;                // Green mask for bitmask modes
    FLONG       flBlue;                 // Blue mask for bitmask modes                                        // by the BMF_xBPP flags.

    //
    // Palette stuff
    //
    HPALETTE    hpalCreated;            // For NT 5.0 we have to return a palette
    PALETTEENTRY* pPal;                 // The palette if palette managed
    BOOL        paletteChanged;         // Set whenever the palette is
                                        //   changed.
}
OSI_PDEV;
typedef OSI_PDEV FAR * LPOSI_PDEV;


// Structure: OSI_DSURF
//
// Description:
//
// Surface specific information.  We need this structure to pass on to
// EngCreateSurface() during initializtion.  We ignore it subsequently.
//
typedef struct tagOSI_DSURF
{
    SIZEL     sizl;         // Size of the original bitmap
    LPOSI_PDEV ppdev;        // Pointer to the assocaited PDEV

}
OSI_DSURF;
typedef OSI_DSURF FAR * LPOSI_DSURF;



void OSI_DDInit(LPOSI_PDEV, LPOSI_INIT_REQUEST);
void OSI_DDTerm(LPOSI_PDEV);
#else
void OSI_DDTerm(void);
#endif // !IS_16

#else

//
// Used for other desktops thread.
//
enum
{
    OSI_WM_SETGUIEFFECTS = WM_USER,
    OSI_WM_DESKTOPREPAINT,
    OSI_WM_DESKTOPSWITCH,
    OSI_WM_MOUSEINJECT,
    OSI_WM_KEYBDINJECT,
    OSI_WM_INJECTSAS
};

#endif // DLL_DISP


//
// OSI_Load()
// Called when nmas.dll is first loaded.
//
void    OSI_Load(void);


//
// OSI_Unload()
// Called when nmas.dll is unloaded.
//
void    OSI_Unload(void);




//
// OSI_Init()
// Called when app sharing initializes in its service thread.  We determine
// if we can host, and get hold of buffers, data structures, etc. needed
// for hosting if so.
//
// Returns FALSE on severe failure.  The display driver on NT not being
// present isn't failure.  The graphic patches on Win95 not being safe isn't
// failure either.  In those two cases, AS will simply mark itself as
// unable to host, but can view fine.
//
void    OSI_Init(void);

//
// OSI_Term()
// Called when app sharing deinitializes in its service thread.
//
void    OSI_Term(void);


//
// OSI_FunctionRequest()
// Used to communicate with the display driver piece, the part which tracks
// graphical output in shared apps on the screen.
//
BOOL    OSI_FunctionRequest(DWORD functionId, LPOSI_ESCAPE_HEADER pRequest, DWORD requestLen);


// NT only!
void OSI_InitDriver50(BOOL fInit);

// NT only!
void OSI_RepaintDesktop(void);

// NT only!
void OSI_SetGUIEffects(BOOL fOff);

// NT only!
void WINAPI OSI_SetDriverName(LPCSTR szDriverName);


#ifdef DLL_DISP


#ifdef IS_16
BOOL    OSI_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult,
                DWORD cbResult);
#else
ULONG   OSI_DDProcessRequest(SURFOBJ* pso, UINT cjIn, void* pvIn, UINT cjOut, void* pvOut);

BOOL    OSIInitializeMode(const GDIINFO* pGdiRequested, const DEVMODEW* pdmRequested,
    LPOSI_PDEV ppdev, GDIINFO* pgdiReturn, DEVINFO* pdiReturn);    

#endif // !IS_16



#endif // DLL_DISP

#endif // _H_OSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\resource.h ===
//
// Resource header
//


//
// Menus
//
#define IDM_FRAME                       100
    #define IDSM_CONTROL                  0
    #define IDSM_VIEW                     1
    #define IDSM_WINDOW                   2
    #define IDSM_HELP                     3
    
  

//
// Commands
//

// CONTROL
#define POS_CONTROLCMD                    0
#define POS_FORWARDCONTROLCMD             1

#define CMD_TOPMOST                     100
#define CMD_TAKECONTROL                 101
#define CMD_RELEASECONTROL              102
#define CMD_CANCELCONTROL               103
#define CMD_CTRLALTDEL                  104
#define CMD_VIEWSTATUSBAR               105
#define CMD_VIEWWINDOWBAR               106
#define CMD_VIEWFULLSCREEN              107
#define CMD_HELPTOPICS                  108
#define CMD_HELPABOUT                   109



// WINDOW
#define CMD_APPSTART                   1000
#define CMD_APPMAX                     5000

#define CMD_FORWARDCONTROLSTART        5000
#define CMD_FORWARDCONTROLMAX         10000



//
// STRINGS
// CVRTRES can't handle enum types, what a pain.
//

#define IDS_ABOUT                         1     // NO REAL STRING
#define IDS_RESTORE                       2

#define IDS_FONT_CURSORTAG              100

#define IDS_TITLE_SHAREDPROGRAMS        101
#define IDS_TITLE_SHAREDDESKTOP         102
#define IDS_TITLE_CONTROLLABLE          103
#define IDS_TITLE_INCONTROL             104

#define IDS_CMD_CTRLALTDEL              110
#define IDS_CMD_TAKECONTROL             111
#define IDS_CMD_CANCELCONTROL           112
#define IDS_CMD_RELEASECONTROL          113
#define IDS_CMD_BLANKPROGRAM            114

#define IDS_HIDDEN_WINDOW               115
#define IDS_NOTHING                     116
#define IDS_DESKTOP                     117
#define IDS_DESKTOP_LOWER               118
#define IDS_PROGRAMS                    119
#define IDS_PROGRAMS_LOWER              120
#define IDS_NOTINCALL                   121
#define IDS_SHARING_FORMAT              122
#define IDS_TOPMOST                     123

#define IDS_ALLOWCONTROL                124
#define IDS_PREVENTCONTROL              125
#define IDS_MSG_TOPREVENTCONTROL        126
#define IDS_MSG_TOALLOWCONTROL          127

#define IDS_STATUS_NONE                   0
#define IDS_STATUS_WAITINGFORCONTROL    150
#define IDS_STATUS_CONTROLPAUSED        151

//
// Inform dialog 
// NOTE:  Keep these in same order as CARESULT_ values
//
#define IDS_TITLE_TAKECONTROL_FAILED            200
#define IDS_ERR_TAKECONTROL_MIN                 200
#define IDS_ERR_TAKECONTROL_FIRST               202
#define IDS_ERR_TAKECONTROL_FAILED_BUSY         202
#define IDS_ERR_TAKECONTROL_FAILED_USER         203
#define IDS_ERR_TAKECONTROL_FAILED_WRONGSTATE   204
#define IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT     205
#define IDS_ERR_TAKECONTROL_LAST                IDS_ERR_TAKECONTROL_FAILED_TIMEDOUT


//
// Query dialogs
//
#define IDS_TITLE_QUERY_TAKECONTROL             250
#define IDS_MSG_QUERY_TAKECONTROL               251
#define IDS_TITLE_QUERY_GIVECONTROL             252
#define IDS_MSG_QUERY_GIVECONTROL               253
#define IDS_TITLE_QUERY_FORWARDCONTROL          254
#define IDS_MSG_QUERY_FORWARDCONTROL            255
#define IDS_TITLE_QUERY_YIELDCONTROL            256
#define IDS_MSG_QUERY_YIELDCONTROL              257


//
// Add this to CMD id above & get status bar string
// SO KEEP THESE IN THE SAME ORDER AS THE CMD_ IDs ABOVE
//
#define IDS_STATUS_MENU_CONTROL                 400
#define IDS_STATUS_MENU_VIEW                    401
#define IDS_STATUS_MENU_WINDOW                  402
#define IDS_STATUS_MENU_HELP                    403
#define IDS_STATUS_MENU_FORWARDCONTROL          404
#define IDS_STATUS_CMDS_APP                     405
#define IDS_STATUS_CMDS_FORWARD                 406

#define IDS_STATUS_CMD_START                    500
#define IDS_STATUS_CMD_TOPMOST                  600
#define IDS_STATUS_CMD_TAKECONTROL              601
#define IDS_STATUS_CMD_RELEASECONTROL           602
#define IDS_STATUS_CMD_CANCELCONTROL            603
#define IDS_STATUS_CMD_CTRLALTDEL               604
#define IDS_STATUS_CMD_VIEWSTATUSBAR            605
#define IDS_STATUS_CMD_VIEWWINDOWBAR            606
#define IDS_STATUS_CMD_VIEWFULLSCREEN           607
#define IDS_STATUS_CMD_HELPTOPICS               608
#define IDS_STATUS_CMD_HELPABOUT                609


//
// DIALOGS
//

#define IDD_HOSTUI                          100
    #define CTRL_PROGRAM_LIST               50
    #define CTRL_SHARE_BTN                  51
    #define CTRL_UNSHARE_BTN                52
    #define CTRL_UNSHAREALL_BTN             53
    #define CTRL_ENABLETRUECOLOR_CHECK      54
    #define CTRL_CONTROL_MSG                55
    #define CTRL_ALLOWCONTROL_BTN           56
    #define CTRL_PREVENTCONTROL_BTN         57
    #define CTRL_AUTOACCEPTCONTROL_CHECK    58
    #define CTRL_TEMPREJECTCONTROL_CHECK    59

#define IDD_INFORM                      101
    #define CTRL_INFORM                  50
#define IDD_QUERY                       102
    #define CTRL_QUERY                   50
#define IDD_ABOUT                       103
    #define CTRL_ABOUTVERSION            50

//
// BITMAPS
//

#define IDB_HATCH32X32                  100
#define IDB_OBSCURED                    101


//
// ICONS
//
#define IDI_SHAREICON                   101
#define IDI_DESKTOPICON                 102
#define IDI_CANCELFULLSCREEN            103
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\sc.h ===
//
// Share Controller
//

#ifndef _H_SC
#define _H_SC


//
//
// CONSTANTS
//
//

//
// Values for compression support array
// - PR_UNKNOWN - don't know (yet) what level this party supports
// - PR_LEVEL1  - Only PKZIP compression is supported.  Compressed packets
//                are identified by the top bit of the compressionType
//                field.  All other bits of compressionType are meaningless
// - PR_LEVEL2  - Multiple compression types are supported.  The compression
//                used for each packet is identified by the compressionType
//                field.
//
#define PR_UNKNOWN  0
#define PR_LEVEL1   1
#define PR_LEVEL2   2




//
// STATES
//
//


enum
{
    SCS_TERM            = 0,
    SCS_INIT,
    SCS_SHAREENDING,
    SCS_SHAREPENDING,
    SCS_SHARING,
    SCS_NUM_STATES
};

//
// Number of supported streams 
// THIS MUST MATCH PROT_STR values!
//
#define SC_STREAM_LOW      1
#define SC_STREAM_HIGH     4
#define SC_STREAM_COUNT    4



//
// Sync status constants
//
#define SC_NOT_SYNCED      0
#define SC_SYNCED          1




//
// PROTOTYPES
//


//
// SC_Init()
// SC_Term()
//
// Init and term routines
//
BOOL SC_Init(void);
void SC_Term(void);



UINT SC_Callback(UINT eventType, MCSID mcsID, UINT cbData1, UINT cbData2, UINT cbData3);

BOOL SC_Start(UINT mcsIDLocal);
void SC_End(void);

//
// SC_CreateShare(): S20_CREATE or S20_JOIN
//
BOOL SC_CreateShare(UINT what);
//
// SC_EndShare()
//
void SC_EndShare(void);


void SCCheckForCMCall(void);

#endif // _H_SC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\s20.h ===
//
// Share 2.0 Interface
//

#ifndef _H_S20
#define _H_S20


BOOL S20_Init(void);
void S20_Term(void);


//
// We can send to one person or broadcast to everyone listening to the
// app sharing channel.  The userID for one person is the mcsID, we get it
// in S20 create/join/respond packets along with name + caps.
//

PS20DATAPACKET S20_AllocDataPkt(UINT streamID, UINT_PTR nodeID, UINT_PTR len);
void S20_FreeDataPkt(PS20DATAPACKET pPacket);
void S20_SendDataPkt(UINT streamID, UINT_PTR nodeID, PS20DATAPACKET pPacket);


//
// API FUNCTION: S20_UTEventProc
//
// DESCRIPTION:
//
// Handles NET_EVENTS
//
// PARAMETERS: standard UT event handler
//
// RETURNS: standard UT event handler
//
BOOL CALLBACK S20_UTEventProc(LPVOID userData, UINT event, UINT_PTR data1, UINT_PTR data2);


//
//
// CONSTANTS
//
//


//
// States
//
typedef enum
{
    S20_TERM                = 0,
    S20_INIT,
    S20_ATTACH_PEND,
    S20_JOIN_PEND,
    S20_NO_SHARE,
    S20_SHARE_PEND,
    S20_SHARE_STARTING,
    S20_IN_SHARE,
    S20_NUM_STATES
}
S20_STATE;


#define S20_MAX_QUEUED_CONTROL_PACKETS             20

//
// These pool sizes and latencies control how DC Share T120 flow control
// behaves.  They are tuned for performance so you had better understand
// what you are doing if you change them!
//
// For example, can you explain why any setting other than 0 for the medium
// priority will break DC Share?  If not then go and read/understand
// amgcflo.c and then look at how DC-Share will interact with it.
//
// To summarize:
//
// We don't control the top priority or medium priority pools because they
// carry non-spoilable data that must therefore flow at a lower bandwidth
// than the transport.  In fact, applying back pressure to these streams
// will cause DC-Share to fail in some cases.
//
// Low priority is where flow control really takes effect, since we want
// the pipe to open right up (to 200K per ping) over fast transports but
// to throttle back (to 1K per second possibly!) over slow transports.
//
//
#define S20_LATENCY_TOP_PRIORITY                    0
#define S20_LATENCY_HIGH_PRIORITY                   0
#define S20_LATENCY_MEDIUM_PRIORITY                 0
#define S20_LATENCY_LOW_PRIORITY                 7000

#define S20_SIZE_TOP_PRIORITY                       0
#define S20_SIZE_HIGH_PRIORITY                      0
#define S20_SIZE_MEDIUM_PRIORITY                    0
#define S20_SIZE_LOW_PRIORITY                   99000


//
//
// MACROS
//
//

#define S20_GET_CREATOR(A) ((TSHR_UINT16)(A & 0xFFFF))


//
//
// TYPEDEFS
//
//
typedef struct tagS20CONTROLPACKETQENTRY
{
    UINT            what;
    TSHR_UINT32     correlator;
    UINT            who;
    UINT            priority;
}
S20CONTROLPACKETQENTRY;

typedef S20CONTROLPACKETQENTRY * PS20CONTROLPACKETQENTRY;

//
//
// PROTOTYPES
//
//

BOOL S20CreateOrJoinShare(
    UINT    what,
    UINT_PTR    callID);

void S20LeaveOrEndShare(void);

UINT S20MakeControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    PS20PACKETHEADER * ppPacket,
    LPUINT     pLength,
    UINT      priority);

UINT S20FlushSendOrQueueControlPacket(
    UINT      what,
    UINT      correlator,
    UINT      who,
    UINT      priority);

UINT S20FlushAndSendControlPacket(
    UINT      what,
    UINT    correlator,
    UINT      who,
    UINT      priority);

UINT S20SendControlPacket(
    PS20PACKETHEADER  pPacket,
    UINT      length,
    UINT      priority);

UINT S20SendQueuedControlPackets(void);

void S20AttachConfirm(NET_UID userID, NET_RESULT result, UINT callID);
void S20DetachIndication(NET_UID userID, UINT callID);
void S20LeaveIndication(NET_CHANNEL_ID channelID, UINT callID);

void S20JoinConfirm(PNET_JOIN_CNF_EVENT pEvent);
void S20SendIndication(PNET_SEND_IND_EVENT pEvent);

void S20Flow(UINT priority, UINT newBufferSize);


void S20CreateMsg(PS20CREATEPACKET  pS20Packet);
void S20JoinMsg(PS20JOINPACKET  pS20Packet);
void S20RespondMsg(PS20RESPONDPACKET  pS20Packet);
void S20DeleteMsg(PS20DELETEPACKET  pS20Packet);
void S20LeaveMsg(PS20LEAVEPACKET  pS20Packet);
void S20EndMsg(PS20ENDPACKET  pS20Packet);
void S20DataMsg(PS20DATAPACKET  pS20Packet);
void S20CollisionMsg(PS20COLLISIONPACKET pS20Packet);

BOOL S20MaybeAddNewParty(MCSID mcsID,
    UINT      lenCaps,
    UINT      lenName,
    LPBYTE    pData);

void S20MaybeIssuePersonDelete(MCSID mcsID);

UINT S20NewCorrelator(void);

NET_PRIORITY S20StreamToS20Priority(UINT  streamID);


#endif // _H_S20

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ssi.h ===
//
// SaveScreenbits Interceptor
//

#ifndef _H_SSI
#define _H_SSI


//
// CONSTANTS
//
#define ST_FAILED_TO_SAVE           0
#define ST_SAVED_BY_DISPLAY_DRIVER  1
#define ST_SAVED_BY_BMP_SIMULATION  2


//
// Maximum depth of save bitmaps we can handle.
//
#define SSB_MAX_SAVE_LEVEL  6

//
// Define the values that can be passed in the flags field of
// SaveScreenBits.
//
// These should be defined in a Windows header - but they are not. In any
// case they are referred to in generic code, so need to be defined here.
//

//
// There are the display driver's SaveBits routine command values, and we
// use them also in our protocol.
//
#define ONBOARD_SAVE        0x0000
#define ONBOARD_RESTORE     0x0001
#define ONBOARD_DISCARD     0x0002


//
//
// MACROS
//
//

//
// Macro that makes it easier (more readable) to access the current
// local SSB state.
//
#define CURRENT_LOCAL_SSB_STATE \
  g_ssiLocalSSBState.saveState[g_ssiLocalSSBState.saveLevel]


#define ROUNDUP(val, granularity) \
  ((val+(granularity-1)) / granularity * granularity)


//
// Specific values for OSI escape codes
//
#define SSI_ESC(code)                   (OSI_SSI_ESC_FIRST + code)

#define SSI_ESC_RESET_LEVEL             SSI_ESC(0)
#define SSI_ESC_NEW_CAPABILITIES        SSI_ESC(1)


//
//
// TYPES
//
//

//
// Local SaveScreenBitmap state structures.
//
typedef struct tagSAVE_STATE
{
    int         saveType;           // ST_xxxx
    HBITMAP     hbmpSave;           // SPB bitmap from USER
    BOOL        fSavedRemotely;
    DWORD       remoteSavedPosition;// valid if (fSavedRemotely == TRUE)
    DWORD       remotePelsRequired; // valid if (fSavedRemotely == TRUE)
    RECT        rect;
} SAVE_STATE, FAR * LPSAVE_STATE;

typedef struct tagLOCAL_SSB_STATE
{
    WORD        xGranularity;
    WORD        yGranularity;
    int         saveLevel;
    SAVE_STATE  saveState[SSB_MAX_SAVE_LEVEL];
} LOCAL_SSB_STATE, FAR* LPLOCAL_SSB_STATE;

//
// Remote SaveScreenBitmap structures.
//
typedef struct tagREMOTE_SSB_STATE
{
    DWORD           pelsSaved;
}
REMOTE_SSB_STATE, FAR* LPREMOTE_SSB_STATE;


//
// SSI_RESET_LEVEL
//
// Resets saved level
//
typedef struct tagSSI_RESET_LEVEL
{
    OSI_ESCAPE_HEADER   header;
}
SSI_RESET_LEVEL;
typedef SSI_RESET_LEVEL FAR * LPSSI_RESET_LEVEL;


//
// Structure: SSI_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSSI_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;           // Common header

    DWORD           sendSaveBitmapSize;  // Size of the save screen bitmap

    WORD            xGranularity;     // X granularity for SSB

    WORD            yGranularity;     // Y granularity for SSB

}
SSI_NEW_CAPABILITIES;
typedef SSI_NEW_CAPABILITIES FAR * LPSSI_NEW_CAPABILITIES;



//
// FUNCTION: SSI_SaveScreenBitmap
//
//
// DESCRIPTION:
//
// The main SaveScreenBitmap function, called by the SaveScreenBitmap
// Interceptor (SSI).
//
// Saves, restores and discards the specified bits using the Display Driver
// and/or our own SaveScreenBitmap simulation.
//
// Sends the SaveScreenBitmap function as an order if possible.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords).
//
// wCommand - SaveScreenBitmap command (SSB_SAVEBITS, SSB_RESTOREBITS,
// SSB_DISCARDBITS).
//
//
// RETURNS:
//
// TRUE if operation succeeded.  FALSE if operation failed.
//
//
BOOL SSI_SaveScreenBitmap(LPRECT lpRect, UINT wCommand);


#ifdef DLL_DISP
//
// FUNCTION:      SSI_DDProcessRequest
//
// DESCRIPTION:
//
// Called by the display driver to process an SSI specific request
//
// PARAMETERS:    pso   - pointer to surface object
//                cjIn  - (IN)  size of request block
//                pvIn  - (IN)  pointer to request block
//                cjOut - (IN)  size of response block
//                pvOut - (OUT) pointer to response block
//
// RETURNS:       None
//
//
BOOL    SSI_DDProcessRequest(UINT escapeFn, LPOSI_ESCAPE_HEADER pRequest, DWORD cbResult);

BOOL SSI_DDInit(void);
void SSI_DDTerm(void);

#ifdef IS_16

void SSI_DDViewing(BOOL);

void SSISaveBits(HBITMAP, LPRECT);
BOOL SSIRestoreBits(HBITMAP);
BOOL SSIDiscardBits(HBITMAP);
BOOL SSIFindSlotAndDiscardAbove(HBITMAP);

#else

BOOL SSISaveBits(LPRECT lpRect);
BOOL SSIRestoreBits(LPRECT lpRect);
BOOL SSIDiscardBits(LPRECT lpRect);
BOOL SSIFindSlotAndDiscardAbove(LPRECT lpRect);

#endif // IS_16

#endif // DLL_DISP


void SSIResetSaveScreenBitmap(void);


BOOL SSISendSaveBitmapOrder( LPRECT lpRect, UINT  wCommand );

void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pssiNew);

DWORD SSIRemotePelsRequired(LPRECT lpRect);

     
#endif // _H_SSI
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\swl.h ===
//
// Shared Window List
//

#ifndef _H_SWL
#define _H_SWL


//
// Max # of entries we can send in SWL packet; backwards compat thing.
// Also, we keep a bunch of static arrays around so we know if stuff has
// changed.
//
#define SWL_MAX_WINDOWS             100


//
// Return codes.
//

#define SWL_RC_ERROR    0
#define SWL_RC_SENT     1
#define SWL_RC_NOT_SENT 2




//
// CONSTANTS
//

//
// Window property flags
//
#define SWL_PROP_INVALID        0x00000000
#define SWL_PROP_COUNTDOWN_MASK 0x00000003
#define SWL_PROP_INITIAL        0x00000004
#define SWL_PROP_TAGGABLE       0x00000020
#define SWL_PROP_TASKBAR        0x00000040
#define SWL_PROP_SHADOW         0x00000100
#define SWL_PROP_IGNORE         0x00000200
#define SWL_PROP_HOSTED         0x00000400
#define SWL_PROP_TRANSPARENT    0x00000800
#define SWL_PROP_SAVEBITS       0x00001000


//
// We still need this SWL token stuff for backwards compatibility (<= NM 2.1)
// Those systems treat the shared apps from all the different participants
// in a global fashion.
//
// Even so, back level systems may not be able to keep up if a lot of NM 3.0
// systems are sharing--but that happens even among an all 2.1 conference.
// With collisions, zordering, etc. a sharer may back off or drop packets.
//
#define SWL_SAME_ZORDER_INC             1
#define SWL_NEW_ZORDER_INC              2
#define SWL_NEW_ZORDER_ACTIVE_INC       3
#define SWL_NEW_ZORDER_FAKE_WINDOW_INC  4
#define SWL_EXIT_INC                    5

#define SWL_MAKE_TOKEN(index, inc)  (TSHR_UINT16)(((index) << 4) | (inc))

#define SWL_GET_INDEX(token)            ((token) >> 4)
#define SWL_MAX_TOKEN_INDEX             0x0FFF

#define SWL_GET_INCREMENT(token)        ((token) & 0x000F)




//
// This is the number of times we must consecutively see a window as
// invisible before we believe it is - see comments in aswlint.c explaining
// why we must do this.
//
#define SWL_BELIEVE_INVISIBLE_COUNT   2


//
// Name of the SWL Global Atom
//
#define SWL_ATOM_NAME               "AS_StateInfo"


//
// For each sharer in the conference, we remember the last shared list
// they sent us--the HWNDs (on their machine, no meaning on ours), the
// state information, and the position.  
//
// We use this for several purposes:
// (1) 2.x compatibility
//      2.x sharers, when they send SWL lists, do not fill in the position
// of shadows representing other remote app windows.  Those will appear
// in the list if they obscure parts of shared windows on the 2.x host.  The
// old 2.x code would look up the last position info in the global shared
// list, and use that.  We need the position info to accurately compute
// the obscured regions for a particular host.  3.0 sharers don't have
// shadows, they never send incomplete info.
//
// (2) For better UI in the host view
//      We can remember where the window on top is, where the active window
// is (if a 3.0 host), if a window is minimized, etc.  Since we don't have
// independent fake windows floating with tray buttons you can manipulate
// on a remote to manipulate the host, minimized windows will disappear.
// Only Alt-Tabbing (when controlling) can activate and restore them.
//


//
// DESKTOP types
//
enum
{
    DESKTOP_OURS = 0,
    DESKTOP_WINLOGON,
    DESKTOP_SCREENSAVER,
    DESKTOP_OTHER
};

#define NAME_DESKTOP_WINLOGON       "Winlogon"
#define NAME_DESKTOP_SCREENSAVER    "Screen-saver"
#define NAME_DESKTOP_DEFAULT        "Default"

#define SWL_DESKTOPNAME_MAX         64


#ifdef __cplusplus

// Things we need for enumeration of top level windows
typedef struct tagSWLENUMSTRUCT
{
    class ASHost *   pHost;
    BOOL        fBailOut;
    UINT        transparentCount;
    UINT        count;
    LPSTR       newWinNames;
    PSWLWINATTRIBUTES   newFullWinStruct;
}
SWLENUMSTRUCT, * PSWLENUMSTRUCT;

#endif // __cplusplus


BOOL CALLBACK SWLDestroyWindowProperty(HWND, LPARAM);


BOOL CALLBACK SWLEnumProc(HWND hwnd, LPARAM lParam);


#endif // _H_SWL
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\shm.h ===
//
// Shared Memory Manager
//

#ifndef _H_SHM
#define _H_SHM


#include <oa.h>
#include <ba.h>
#include <osi.h>
#include <sbc.h>
#include <cm.h>


//
// List of component IDs for the data blocks passed around using shared
// memory.
//
#define SHM_OA_DATA                     0
#define SHM_OA_FAST                     1
#define SHM_BA_FAST                     2
#define SHM_CM_FAST                     3

//
// Number of components (actual number of entries in the above list).
//
#define SHM_NUM_COMPONENTS              4

//
// Structure to keep track of the buffer being used to pass data between
// the display driver and the share core.
//
// busyFlag      - indicates whether the display driver is using the memory
//
// newBuffer     - index for which buffer the display driver should next
//                 use to access the memory.
//
// currentBuffer - index for the buffer in use by the display driver if
//                 busyFlag is set.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// indexCount    - count of how many times we have recursed into accessing
//                 the buffer.  The busyFlag and currentBuffer should only
//                 be updated if indexCount was set to or changed from 0.
//                 THIS FIELD IS USED ONLY BY THE DISPLAY DRIVER
//
// bufferBusy    - indicates whether a particular buffer is being used
//                 by the display driver.
//
//
typedef struct tagBUFFER_CONTROL
{
    long    busyFlag;
    long    newBuffer;
    long    currentBuffer;
    long    indexCount;
    long    bufferBusy[2];
} BUFFER_CONTROL;
typedef BUFFER_CONTROL FAR * LPBUFFER_CONTROL;


//
// Shared memory as used by the display driver and share core to
// communicate.
//
// On Win95, we can not easily address memory that isn't in a 64K segment
// So on both platforms, when we map the shared memory, we also return pointers
// to the CM_FAST_DATA structures anda the OA_FAST_DATA structures, each of
// which lives in its own segment.
//
// On NT, the CM_FAST_DATA blocks come right after this one, then the 
// OA_SHARED_DATA blocks.
//
//
//  GENERAL
//  =======
//
// dataChanged   - flags to indicate if a data block has been altered
//                 (only used by the share core)
//
//  FAST PATH DATA
//  ==============
//
// fastPath      - buffer controls
//
// oaFast        - OA fast changing data
//
// baFast        - BA fast changing data
//
//  DISPLAY DRIVER -> SHARE CORE
//  ============================
//
// displayToCore - buffer controls
//
//
typedef struct tagSHM_SHARED_MEMORY
{
    //
    // Flag set by display driver when the display is in full screen mode.
    // (e.g. DOS full screen).
    //
    DWORD           fullScreen;

    //
    // Flag set by display driver or core when system palette has altered
    //
    LONG            pmPaletteChanged;

    //
    // Flag set by display driver when the cursor is hidden.
    //
    LONG            cmCursorHidden;

    //
    // Data passed from the Display Driver up to the Share Core.
    //
    BUFFER_CONTROL  displayToCore;


    long            dataChanged[SHM_NUM_COMPONENTS];

    //
    // Data passed regularly from the Display Driver to the Share Core.
    //
    // This buffer is switched on each periodic processing by the share
    // core.  If the criteria for reading are satisfied, the main DD->SHCO
    // buffer is switched.
    //
    BUFFER_CONTROL  fastPath;

    BA_FAST_DATA    baFast[2];

    OA_FAST_DATA    oaFast[2];

    CM_FAST_DATA    cmFast[2];

    //
    // DO NOT BUMP SHARED MEMORY SIZE PAST 64K
    // 16-bit display driver puts each oaData in a 64K block
    // The SHM_ESC_MAP_MEMORY request returns back the pointers
    // to each oaData in addition to the shared memory block.  In the
    // the case of the 32-bit NT display driver, the memory allocated is
    // in fact contiguous, so there's no waste in that case.
    //
} SHM_SHARED_MEMORY;
typedef SHM_SHARED_MEMORY FAR * LPSHM_SHARED_MEMORY;



//
// Macros to access the shared memory
//
//
//  OVERVIEW
//  ~~~~~~~~
//
// Note the following sets of macros are split into two parts - one for
// accessing memory from the NT kernel and one for the Share Core.  This
// code plays a significant role in the synchronization of the shared
// memory, so make sure you know how it works...
//
// The shared memory is double buffered, so that the kernel mode display
// driver can come in at any point and is NEVER blocked by the share core
// for access.  The data is split into two major blocks - one to pass data
// from the kernel to the Share Core and the other to pass the data back.
//
// The macros assume a certain structure to the shared memory which is
// described below.
//
// NO VALIDATION OF POINTERS IS DONE IN THESE MACROS.
//
//
//  DISPLAY DRIVER ACCESS
//  ~~~~~~~~~~~~~~~~~~~~~
//
//                    
//                     Shared Memory                
//                     ~~~~~~~~~~~~~                
//                                                  
//                        
//                                              
//                      kernel       fast path  
//                       -> SHCO                
//                                              
//                                              
//                      (details                
//                         below)               
//                                              
//                        
//                    
//
//
//
//        
//         Kernel to share core data block                     
//         ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                     
//                           
//                            busyFlag                     
//           Share Core           1        Display Driver  
//                                                         
//           (read buffer)    newBuffer    (write buffer)  
//                                                        
//                         <>                 
//           bufferBusy                    bufferBusy      
//               0                             1           
//                          currentBuffer                  
//                                                        
//                                >                 
//                                                         
//                                                         
//                           indexCount                    
//                                5                        
//                           
//                                                             
//                                                             
//        
//
// The entire major block has a busyFlag, which indicates if the display
// driver is accessing any of its shared memory.  This flag is set as soon
// as the display driver needs access to the shared memory (i.e.  on entry
// to the display driver graphics functions).
//
// The display driver then reads the index (newBuffer in the above drawing)
// to decide which buffer to use.  This is stored in the currentBuffer
// index to use until the display driver releases the shared memory.  The
// secondary bufferBusy is now set for the buffer in use.
//
// The indexCount is maintained of the number of times the display driver
// has started access to a block of memory so that (both) busyFlag and
// bufferBusy can be released when the display driver has truly finished
// with the memory.
//
//
//  SHARE CORE ACCESS
//  ~~~~~~~~~~~~~~~~~
//
// To access the shared memory, the share core just pulls out the data from
// the buffer that the Share Core is not using (ie.  the buffer pointed to
// by NOT newBuffer).
//
// The synchronization between the two processes comes from the buffer
// switch.
//
//
//  BUFFER SWITCHING (AND SYNCHRONIZATION)
//  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
//
// Buffer switching is determined by the Share Core.  Data is accumulated
// by the Share Core and sent on the periodic timing events.  For full
// details on the swapping method, refer to NSHMINT.C
//
// Data (such as window tracking) can be passed down at the meoment it is
// generated by using the OSI functions.
//
// The Share Core also determines when it wants to get the latest set of
// orders and screen data area and forces the switch.  This is detailed in
// NSHMINT.C
//
//
//  THE MACROS!
//  ~~~~~~~~~~~
//
// So, now we know a bit about the shared memory, what macros do we have to
// access the shared memory?  Here goes...
//
//
//  SHM_SYNC_READ      - Force a sync of the read buffer between the tasks.
//                       This should be called only by the Share Core.
//
//  SHM_SYNC_FAST      - Force a sync of the fast path buffer.
//                       This should be called only by the Share Core.
//
//
#ifdef DLL_DISP

LPVOID  SHM_StartAccess(int block);

void    SHM_StopAccess(int block);


//
// Macro to check any pointers that we are going to dereference.
//
#ifdef _DEBUG
void    SHM_CheckPointer(LPVOID ptr);
#else
#define SHM_CheckPointer(ptr)
#endif // _DEBUG


#else // !DLL_DISP

void  SHM_SwitchReadBuffer(void);

void  SHM_SwitchFastBuffer(void);

#endif // DLL_DISP


#endif // _H_SHM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\sbc.h ===
//
// Sent Bitmap Cache
//

#ifndef _H_SBC
#define _H_SBC


#include <oa.h>
#include <shm.h>
#include <osi.h>
#include <ch.h>
#include <bmc.h>


//
//
// Constants
//
//



#define SBC_NUM_THRASHERS   8       // The number of bitmaps we monitor for
                                    // "thrashiness" at any given time.

#define SBC_THRASH_INTERVAL 50      // The interval (in centi-seconds) at
                                    // which bitmaps have to change in
                                    // order to be classified as thrashers


//
// Eviction categories
//
#define SBC_NUM_CATEGORIES        3


//
// Specific values for OSI escape codes
//
#define SBC_ESC(code)                   (OSI_SBC_ESC_FIRST + code)

#define SBC_ESC_NEW_CAPABILITIES        SBC_ESC(0)



//
// Value indicating that a bitmap should not be fast pathed
//
#define SBC_DONT_FASTPATH       0xffffffff


//
// Index into sbcTileWorkInfo at which the data for various tile sizes is
// stored.
//
#define SBC_MEDIUM_TILE_INDEX       SHM_MEDIUM_TILE_INDEX
#define SBC_LARGE_TILE_INDEX        SHM_LARGE_TILE_INDEX
#define SBC_NUM_TILE_SIZES          SHM_NUM_TILE_SIZES





//
//
// Macros
//
//

//
// Calculate the number of bytes required for a tile entry of the given
// dimensions.
//
#define SBC_BYTES_PER_TILE(WIDTH, HEIGHT, BPP)              \
            (BYTES_IN_BITMAP((WIDTH), (HEIGHT), (BPP))      \
                + sizeof(SBC_TILE_DATA))                    \



//
// SBC_TILE_TYPE
//
// Given an SBC tile Id, return the tile type.
//
// Returns one of:
//      SBC_SMALL_TILE
//      SBC_LARGE_TILE
//
// The top bit of the Id is clear for small tiles, and set for large tiles.
//
#define SBC_TILE_TYPE(TILEID)  \
    (((TILEID) & 0x8000) ? SBC_LARGE_TILE_INDEX : SBC_MEDIUM_TILE_INDEX)





//
//
// Structures
//
//

//
// Structure: SBC_SHM_CACHE_INFO
//
// Description: Structure which is used to pass information about a bitmap
// cache from the share core to the display driver.
//
//
typedef struct tagSBC_SHM_CACHE_INFO
{
    WORD    cEntries;       // The number of entries in this cache.
    WORD    cCellSize;      // The maximum bytes available for each cache entry.
}
SBC_SHM_CACHE_INFO;
typedef SBC_SHM_CACHE_INFO FAR * LPSBC_SHM_CACHE_INFO;


//
// Structure: SBC_TILE_DATA
//
// Description: Structure used to pass the DIB bits for tile in a MEMBLT
// order from the driver to the share core.  There is an array of these
// structures in each SBC shunt buffer.
//
// Notes: The inUse field should only be set to TRUE by the driver when it
// has finished filling in the entry, and to FALSE by the share core when
// it has finished processing the data held in the entry.  When inUse is
// FALSE, the remaining data is not valid, and should not be accessed by
// the share core.
//
// The width and height fields give the dimensions of the data which is
// held in the bitData field.  If the tile is set up to hold a maximum
// of 32x32, the scanlines in bitData will always be 32 even if width is
// set to less than 32 - there will just be unused data at the end of each
// scanline.
//
//
typedef struct tagSBC_TILE_DATA
{
    WORD        inUse;              // Is this entry in use?
    WORD        tileId;             // An identifier for this entry.  This
                                    //   matches an ID stored in the
                                    //   cacheId field of a MEMBLT order
                                    //   passed from the driver to the
                                    //   share core in the order buffer.

    DWORD       bytesUsed;          // The number of bytes of data in
                                    //   bitData which is actually used for
                                    //   this entry.

    WORD        srcX;               // The source coordinates of the Mem(3)Blt
    WORD        srcY;

    WORD        width;              // The dimensions of the data in bitData
    WORD        height;

    WORD        tilingWidth;        // The dimensions at which tiling was
    WORD        tilingHeight;       //   carried out.  This is not
                                    //   necessarily the same as the
                                    //   dimensions of the tiles in this
                                    //   shunt buffer.

    DWORD_PTR   majorCacheInfo;     // Information which the share core can
    DWORD       minorCacheInfo;     //   use to optimize cache handling.
                                    //   A value of SBC_DONT_FASTPATH for
                                    //   majorCacheInfo indicates that the
                                    //   optimization should not be used.
                                    //

    DWORD_PTR   majorPalette;       // Palette information for the fast
    DWORD       minorPalette;       //   pathing.  These two fields
                                    //   uniquely identify the colour
                                    //   conversion object associated with
                                    //   the bitmap.

    BYTE        bitData[4];         // Start of the bit data.  The total
                                    //   number of bits is given by the
                                    //   numBits field of the
                                    //   SBC_SHUNT_BUFFER structure at the
                                    //   head of the shunt buffer which
                                    //   this entry is placed in.
} SBC_TILE_DATA;
typedef SBC_TILE_DATA FAR * LPSBC_TILE_DATA;



//
// Structure: SBC_SHUNT_BUFFER
//
// Description: Structure placed at the head of a shunt buffer used to pass
// bit data from the driver to the share core.  It is followed by an array
// of SBC_TILE_DATA structures.
//
// Note: The SBC_TILE_DATA structures are all the same size, but the size
// is not fixed at compile time (there are a variable number of bits), so
// do not use array notation to reference them.
//
//
typedef struct tagSBC_SHUNT_BUFFER
{
    DWORD           numBytes;       // The number of bytes in the bitData
                                    //   fields of the SBC_TILE_DATA stryct
    DWORD           structureSize;  // The total size of each SBC_TILE_DATA
                                    //   structure
    DWORD           numEntries;     // The number of SBC_TILE_DATA
                                    //   structures in the shunt buffer
    SBC_TILE_DATA   firstEntry;     // The first SBC_TILE_DATA entry

} SBC_SHUNT_BUFFER;
typedef SBC_SHUNT_BUFFER FAR * LPSBC_SHUNT_BUFFER;



//
// Structure: SBC_NEW_CAPABILITIES
//
// Description:
//
// Structure to pass new capabilities down to the display driver from the
// Share Core.
//
//
typedef struct tagSBC_NEW_CAPABILITIES
{
    OSI_ESCAPE_HEADER header;               // Common header

    DWORD               sendingBpp;         // Bpp at which bitmaps are sent

    LPSBC_SHM_CACHE_INFO cacheInfo;         // Caching details

} SBC_NEW_CAPABILITIES;
typedef SBC_NEW_CAPABILITIES FAR * LPSBC_NEW_CAPABILITIES;


//
// Structure: SBC_ORDER_INFO
//
// Description: This structure holds all the information SBC needs about
// the two internal orders which it stores to hold data color table and bit
// data for a MEMBLT order.
//
// pColorTableOrder is allocated with enough color table entries for
// usrSendingbpp bitmaps.
//
// pBitmapBitsOrder is allocated with enough room for the maximum tile size
// which we will send out at usrSendingbpp.
//
// If sentColorTable is TRUE, the data in pColorTableOrder may not be
// valid.
//
// If sentBitmapBits is TRUE, the data in pBitmapBitsOrder may not be
// valid.
//
//
typedef struct tagSBC_ORDER_INFO
{
    LPINT_ORDER  pColorTableOrder;       // Pointer to a color table order.
    LPINT_ORDER  pBitmapBitsOrder;       // Pointer to a bitmap bits order.
    DWORD        bitmapBitsDataSize;     // The number of bytes allocated
                                        //   for the data field of the
                                        //   bitmap bits order.
    LPINT_ORDER  pOrder;                 // Pointer to the MEMBLT order for
                                        //   which we currently hold data.
                                        //   DO NOT DEREFERENCE THIS - IT
                                        //   IS FOR NUMERICAL COMPARISON
                                        //   ONLY
    DWORD       validData;              // Do we have valid data for
                                        //   pOrder ?
    DWORD       sentColorTable;         // Has the color table been sent
                                        //   over the wire ?
    DWORD       sentBitmapBits;         // Have the bitmap bits been sent
                                        //   over the wire ?
    DWORD       sentMemBlt;             // Has the MEMBLT order itself been
                                        //   sent over the wire ?

}
SBC_ORDER_INFO, FAR * LPSBC_ORDER_INFO;



//
// Structure: SBC_TILE_WORK_INFO
//
// Description: This structure contains all the elements required for
// manipulating tiles of a given size.  There should be an array of these
// structures - one per tile size.
//
//
typedef struct tagSBC_TILE_WORK_INFO
{
    LPSBC_SHUNT_BUFFER   pShuntBuffer;   // Pointer to the shunt buffer to
                                        //   containing tiles of this tile
                                        //   size.
    UINT            mruIndex;       // The last entry accessed in
                                        //   the shunt buffer pointed to by
                                        //   pShuntBuffer.
    HBITMAP         workBitmap;     // The bitmap to use for processing
                                        //   this tile size.  This is
                                        //   tileWidth x tileHeight at
                                        //   native bpp.
#ifndef DLL_DISP
    LPBYTE          pWorkBitmapBits;// Pointer to the start of the bits
#endif // DLL_DISP
                                        //   in the bitmap.
    UINT            tileWidth;      // The width of workBitmap.
    UINT            tileHeight;     // The height of workBitmap.
} SBC_TILE_WORK_INFO, FAR * LPSBC_TILE_WORK_INFO;



//
// Structure: SBC_FASTPATH_ENTRY
//
// Description: Structure holding one entry in the SBC fast path.
//
//
typedef struct tagSBC_FASTPATH_ENTRY
{
    BASEDLIST      list;           // Offsets to the next / prev entries in
                                //   the fast path
    DWORD_PTR   majorInfo;      // Major cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD       minorInfo;      // Minor cache info field passed up in the
                                //   shunt buffer for this cache entry
    DWORD_PTR   majorPalette;   // Major palette info from the shunt buffer
                                //   This is the pointer to the XLATEOBJ
    DWORD       minorPalette;   // Minor palette info from the shunt buffer
                                //   This is the iUniq of the XLATEOBJ

    LONG        srcX;           // The coordinate in the source bitmap of
    LONG        srcY;           //   the source of the MemBlt
    DWORD       width;          // The width / height of the entry in the
    DWORD       height;         //   cache.

    WORD        cache;          // The cache and index at which the bitmap
    WORD        cacheIndex;     //   stored.
    WORD        colorIndex;
    WORD        pad;

} SBC_FASTPATH_ENTRY, FAR * LPSBC_FASTPATH_ENTRY;


//
// Structure: SBC_FASTPATH
//
// Description: Structure holding the SBC fast pathing information.
//
//

#define SBC_FASTPATH_ENTRIES    100

typedef struct tagSBC_FASTPATH
{
    STRUCTURE_STAMP

    BASEDLIST              usedList;   // Offsets to the first / last used
                                    //   entries in the fast path.
    BASEDLIST              freeList;   // Offsets to the first / last free
                                    //   entries in the fast path.
    SBC_FASTPATH_ENTRY      entry[SBC_FASTPATH_ENTRIES];
}
SBC_FASTPATH;
typedef SBC_FASTPATH FAR * LPSBC_FASTPATH;


#ifdef DLL_DISP

// Structure: SBC_THRASHERS
//
// Description: Structure which is used to hold information about when a
// source surface (bitmap) last changed, in order to determine whether the
// surface will cause thrashing in the bitmap cache.
//

typedef struct tagSBC_THRASHERS
{
#ifdef IS_16
    HBITMAP     hsurf;
#else
    HSURF       hsurf;          // The hsurf of the surface object being
                                //   monitored.
    DWORD       iUniq;          // The last noted iUniq field from the
                                //   surface object being monitored.
#endif // IS_16
    DWORD       tickCount;      // The system tick count (in centi-seconds)
                                //   at which we last saw this surface
                                //   change
} SBC_THRASHERS;
typedef SBC_THRASHERS FAR * LPSBC_THRASHERS;


//
//
// Function prototypes
//
//


void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pRequest);

BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData);

DWORD SBCDDGetTickCount(void);

#ifdef IS_16
BOOL SBCDDCreateShuntBuffers(void);
#else
BOOL SBCDDCreateShuntBuffers(LPOSI_PDEV ppDev, LPBYTE psbcMem, DWORD sbcMem);
#endif

#ifndef IS_16
BOOL SBCDDIsBitmapThrasher(SURFOBJ * pSurfObj);
#endif // !IS_16


#endif // DLL_DISP


//
// SBC_TILE_PTR_FROM_INDEX
//
// Given a pointer to a shunt buffer and a tile index, return a pointer to
// the tile at the given index.
//
// Get a pointer to the first entry in the shunt buffer, and add INDEX
// times the size of each entry.
//
__inline LPSBC_TILE_DATA SBCTilePtrFromIndex(LPSBC_SHUNT_BUFFER pBuffer, UINT index)
{
    LPSBC_TILE_DATA lpsbc;

    lpsbc = (LPSBC_TILE_DATA)((LPBYTE)&pBuffer->firstEntry +
        index * pBuffer->structureSize);
    return(lpsbc);
}




#ifdef DLL_DISP

//
//
// Typedefs
//
//

#ifdef IS_16

typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    HDC             hdcSrc;
    UINT            fuColorUse;
    LPVOID          lpBits;
    LPBITMAPINFO    lpbmi;
    HPALETTE        hpalDst;
    UINT            uPad;
} MEMBLT_ORDER_EXTRA_INFO, FAR* LPMEMBLT_ORDER_EXTRA_INFO;

#else
//
// Structure: MEMBLT_ORDER_EXTRA_INFO
//
// Description: Extra information required by SBC to process a MEMBLT
// order.
//
//
typedef struct tagMEMBLT_ORDER_EXTRA_INFO
{
    SURFOBJ*    pSource;        // Pointer to the source surface of the
                                //   MemBlt
    SURFOBJ*    pDest;          // Pointer to the destination surface of
                                //   the MemBlt
    XLATEOBJ*   pXlateObj;      // Pointer to the XlateObj used in the
                                //   MemBlt
} MEMBLT_ORDER_EXTRA_INFO, FAR * LPMEMBLT_ORDER_EXTRA_INFO;
#endif // !IS_16


//
// Name:      SBC_DDProcessRequest
//
// Purpose:   Process a request from the share core
//
// Returns:   TRUE if the request is processed successfully,
//            FALSE otherwise.
//
// Params:    IN     pso   - Pointer to surface object for our driver
//            IN     cjIn  - Size of the input data
//            IN     pvIn  - Pointer to the input data
//            IN     cjOut - Size of the output data
//            IN/OUT pvOut - Pointer to the output data
//
#ifdef IS_16
BOOL  SBC_DDProcessRequest(UINT fnEscape, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
void  SBC_DDTossFromCache(HBITMAP);
#else
BOOL  SBC_DDProcessRequest(SURFOBJ*  pso, DWORD fnEscape,
            LPOSI_ESCAPE_HEADER pRequest, LPOSI_ESCAPE_HEADER pResult, DWORD cbResult);
#endif


//
// Name:      SBC_DDInit
//
// Purpose:   Initialize the device driver SBC specific "stuff".
//
#ifdef IS_16
BOOL SBC_DDInit(HDC hdc, LPDWORD ppShuntBuffers, LPDWORD pBitmasks);
#else
BOOL SBC_DDInit(LPOSI_PDEV ppDev, LPBYTE pRestOfMemory, DWORD cbRestOfMemory,
    LPOSI_INIT_REQUEST pResult);
#endif


//
// Name:      SBC_DDTerm
//
// Purpose:   Terminate the device driver SBC specific "stuff"
//
// Returns:   Nothing
//
// Params:    None
//
void SBC_DDTerm(void);


//
// Name:       SBC_DDIsMemScreenBltCachable
//
// Purpose:    Check to see whether a MemBlt is cachable.
//
// Returns:    TRUE if the MemBlt is cachable, FALSE otherwise.
//
// Params:     IN  pMemBltInfo - Info about the MEMBLT to be cached.
//
// Operation:  Note that if this function returns TRUE, it DOES NOT
//             guarantee that SBC_DDCacheMemScreenBlt will succeed.
//             However, a FALSE return code does guarantee that
//             SBC_DDCacheMemScreenBlt would fail.
//
BOOL SBC_DDIsMemScreenBltCachable(LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);


//
// Name:      SBC_DDCacheMemScreenBlt
//
// Purpose:   Try to cache a memory to screen blt operation
//
// Returns:   TRUE if the memory to screen blt was handled as an order
//            (i.e. the src bitmap could be cached)
//
//            FALSE if the memory to screen blt could not be handled as an
//            order.  In this case the caller should add the destination
//            rectangle of the blt into the Screen Data Area.
//
// Params:    IN  pOrder      - Pointer to either a MEMBLT order or a
//                              MEM3BLT order.  This order must be
//                              initialized before calling this function.
//            IN  pMemBltInfo - Extra info about the MEMBLT to be cached.
//
// Operation: Before calling this function, the caller should call
//            SBC_DDMaybeQueueColorTable() to queue a color table for the
//            MemBlt (if required).
//
BOOL SBC_DDCacheMemScreenBlt(LPINT_ORDER pOrder, LPMEMBLT_ORDER_EXTRA_INFO pMemBltInfo);

//
// THIS CAN GO WHEN 2.x COMPAT DOES -- the SEND TILE SIZES WON'T BE
// NEGOTIATED.
//
BOOL SBC_DDQueryBitmapTileSize(UINT bmpWidth, UINT bmpHeight,
            UINT * pTileWidth, UINT * pTileHeight);


//
// Name:      SBC_DDSyncUpdatesNow
//
// Purpose:   Discard any pending orders.
//
// Returns:   Nothing
//
// Params:    IN  ppDev - Pointer to our device PDEV
//
// Operation: This function will mark all entries in the shunt buffers as
//            being free.  It is vital that this operation is synched with
//            the share core operation of removing all orders from the
//            order buffer to ensure that there are no MemBlt orders left
//            which refer to freed shunt buffer entries.
//
#ifdef IS_16
void SBC_DDSyncUpdatesNow(void);
#else
void SBC_DDSyncUpdatesNow(LPOSI_PDEV ppDev);
#endif // IS_16


//
// Name:      SBC_DDOrderSpoiltNotification
//
// Purpose:   Called to notify SBC that a Mem(3)Blt order has been spoilt
//            before being passed to the share core.  This function marks
//            the corresponding shunt buffer entry as being free.
//
// Returns:   Nothing
//
// Params:    IN  pOrder - Pointer to the Mem(3)Blt order being spoilt.
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder);


//
// Name:      SBC_DDMaybeQueueColorTable
//
// Purpose:   If our device palette has changed since the last time we
//            queued a color table order to the share core, queue a new
//            color table order with details of the new palette.
//
// Returns:   TRUE if the color table was queued, or no color table was
//            required.
//
//            FALSE if a color table is required, but could not be queued.
//
// Params:    IN ppDev - a pointer to our device PDEV
//
// Operation: This function should be called before SBC_DDCacheMemScreenBlt
//            to queue the color table used for the Mem(3)Blt.  If this
//            function fails (returns FALSE), the caller should not call
//            SBC_DDCacheMemScreenBlt, but add the area covered by the
//            Mem(3)Blt to the screen data area instead.
//
//            This function is required to work round a limitation in the
//            order heap which means that we cannot have more than one
//            OA_AllocOrderMem outstanding waiting for an OA_AddOrder.
//
//            i.e. We cannot queue the color table order from
//            SBC_DDCacheMemScreenBlt because this gives the following
//            sequence of calls.
//
//              OA_AllocOrderMem for Mem(3)Blt
//              OA_AllocOrderMem for color table
//              OA_AddOrder for color table
//              OA_AddOrder for Mem(3)Blt
//
#ifdef IS_16
BOOL SBC_DDMaybeQueueColorTable(void);
#else
BOOL SBC_DDMaybeQueueColorTable(LPOSI_PDEV ppDev);
#endif


#endif // DLL_DISP



#endif // _H_SBC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\sch.h ===
//
// Scheduler
//

#ifndef _H_SCH
#define _H_SCH


//
//
// CONSTANTS
//
//
#define SCH_MODE_ASLEEP  0
#define SCH_MODE_NORMAL  1
#define SCH_MODE_TURBO   2


//
// All of the following values are times in milliseconds.
//
#define SCH_PERIOD_NORMAL        200
#define SCH_PERIOD_TURBO         100
#define SCH_TURBO_MODE_DURATION 1000


#define SCH_EVENT_NAME "DCS_SCHEDULE_EVENT"



//
//
// PROTOTYPES
//
//
// Name:      SCH_Init
//
// Purpose:   Scheduler initialization function.
//
// Params:    None.
//
BOOL SCH_Init(void);

// Name:      SCH_Term
//
// Purpose:   Scheduler termination function.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_Term(void);

// Name:      SCH_ContinueScheduling
//
// Purpose:   Called by components when they want periodic scheduling to
//            continue.  They are guaranteed to get at least one more
//            periodic callback following a call to this function.
//            If they want further callbacks then they must call this
//            function again during their periodic processing.
//
// Returns:   Nothing.
//
// Params:    schedulingMode - either SCH_MODE_NORMAL or SCH_MODE_TURBO
//
// Operation:
//            SCH_MODE_NORMAL triggers periodic processing at 200ms
//            intervals (5 times a second)
//
//            SCH_MODE_TURBO triggers periodic processing at 100ms
//            intervals (10 times a second)
//
//            The scheduler automatically drops from SCH_MODE_TURBO back
//            to SCH_MODE_NORMAL after 1 second of turbo mode processing.
//
//            SCH_MODE_TURBO overrides SCH_MODE_NORMAL, so if calls to
//            this function are made with SCH_MODE_NORMAL when the
//            scheduler is in TURBO mode, TURBO mode continues.
//
//            If this function is not called during processing of a
//            scheduler callback message then the scheduler enters
//            SLEEP mode - and will not generate any more periodic
//            callbacks until it is woken by another call to
//            this function, or until the output accumulation code
//            signals the scheduler's event.
//
void SCH_ContinueScheduling(UINT schedulingMode);

// Name:      SCH_SchedulingMessageProcessed
//
// Purpose:   A feedback function called by the Share Core to signal that
//            a scheduler message has been received.  This ensures that
//            that the scheduler only ever has one scheduler message
//            outstanding at a time.
//
// Returns:   Nothing.
//
// Params:    None.
//
void SCH_SchedulingMessageProcessed(void);

// Name:      SCH_PacingProcessor
//
// Purpose:   The main function executed by the scheduling thread.
//
// Returns:   Zero.
//
// Params:    syncObject - object to pass back to COM_SignalThreadStarted
//
// Operation: The thread enters a main loop which continues while the
//            scheduler is initialized.
//
//            The thread sets its priority to TIME_CRITICAL in order
//            that it runs as soon as possible when ready.
//
//            The thread waits on an event (schEvent) with a timeout that
//            is set according to the current scheduler mode.
//
//            The thread runs due to either:
//              - the timeout expiring, which is the normal periodic
//                scheduler behavior, or
//              - schEvent being signalled, which is how the scheduler is
//                woken from ASLEEP mode.
//
//            The thread then posts a scheduler message the the Share Core
//            (if there is not one already outstanding) and loops back
//            to wait on schEvent.
//
//            Changes in the scheduler mode are caused by calls to
//            SCH_ContinueScheduling updating variables accessed in this
//            routine, or by calculations made within the main loop of
//            this routine (e.g. TURBO mode timeout).
//
DWORD WINAPI SCH_PacingProcessor(LPVOID lpParam);



void SCHSetMode(UINT newMode);
void SCHPostSchedulingMessage(void);


#endif // _H_SCH
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\t_share.h ===
//
// T.SHARE protocol
//

#ifndef _H_T_SHARE
#define _H_T_SHARE


//
// TSHARE PROTOCOL STRUCTURES
// These are defined in a way that keeps the offsets and total sizes the 
// same, regardless of whether this header is included in 32-bit code, 
// 16-bit code, big-endian code, etc.
//
// We make special types to avoid inadvertenly altering something else and
// breaking the structure.  The TSHR_ prefix helps make this clear.
//


////////////////////////////////
//
// BASIC TYPES
//
////////////////////////////////

typedef char                                  TSHR_CHAR;
typedef TSHR_CHAR           FAR*            LPTSHR_CHAR;
typedef TSHR_CHAR UNALIGNED FAR*            LPTSHR_CHAR_UA;


typedef signed char                           TSHR_INT8;
typedef TSHR_INT8           FAR*            LPTSHR_INT8;
typedef TSHR_INT8 UNALIGNED FAR*            LPTSHR_INT8_UA;

typedef BYTE                                  TSHR_UINT8;
typedef TSHR_UINT8          FAR*            LPTSHR_UINT8;  
typedef TSHR_UINT8 UNALIGNED FAR *          LPTSHR_UINT8_UA;


typedef short                                 TSHR_INT16;
typedef TSHR_INT16          FAR*            LPTSHR_INT16;
typedef TSHR_INT16 UNALIGNED FAR *          LPTSHR_INT16_UA;

typedef unsigned short                        TSHR_UINT16;
typedef TSHR_UINT16         FAR*            LPTSHR_UINT16;
typedef TSHR_UINT16 UNALIGNED FAR *         LPTSHR_UINT16_UA;


typedef long                                  TSHR_INT32;
typedef TSHR_INT32          FAR*            LPTSHR_INT32;
typedef TSHR_INT32  UNALIGNED FAR *         LPTSHR_INT32_UA;

typedef unsigned long                         TSHR_UINT32;
typedef TSHR_UINT32         FAR*            LPTSHR_UINT32;
typedef TSHR_UINT32 UNALIGNED FAR *         LPTSHR_UINT32_UA;

// TSHR_PERSONID
typedef TSHR_UINT32         TSHR_PERSONID;
typedef TSHR_PERSONID *     LPTSHR_PERSONID;



// TSHR_POINT16 -- POINT with WORD fields

typedef struct tagTSHR_POINT16
{
    TSHR_INT16      x;
    TSHR_INT16      y;
}
TSHR_POINT16;
typedef TSHR_POINT16 FAR * LPTSHR_POINT16;



// TSHR_POINT32 -- POINT with DWORD fields

typedef struct tagTSHR_POINT32
{
    TSHR_INT32      x;
    TSHR_INT32      y;
}
TSHR_POINT32;
typedef TSHR_POINT32 FAR * LPTSHR_POINT32;



// Conversion Macros
_inline void TSHR_POINT16_FROM_POINT(LPTSHR_POINT16 pPt16, POINT pt)
{
    pPt16->x = (TSHR_INT16)pt.x;
    pPt16->y = (TSHR_INT16)pt.y;
}

_inline void POINT_FROM_TSHR_POINT16(LPPOINT pPt, TSHR_POINT16 pt16)
{
    pPt->x = pt16.x;
    pPt->y = pt16.y;
}



// TSHR_RECT16 -- RECT with WORD fields

typedef struct tagTSHR_RECT16
{
    TSHR_INT16      left;
    TSHR_INT16      top;
    TSHR_INT16      right;
    TSHR_INT16      bottom;
}
TSHR_RECT16;
typedef TSHR_RECT16 FAR *   LPTSHR_RECT16;


// TSHR_RECT32 -- RECT with DWORD fields

typedef struct tagTSHR_RECT32
{
    TSHR_INT32      left;
    TSHR_INT32      top;
    TSHR_INT32      right;
    TSHR_INT32      bottom;
}
TSHR_RECT32;
typedef TSHR_RECT32 FAR *   LPTSHR_RECT32;



// Conversion Macros
#ifdef IS_16
#define TSHR_RECT16_FROM_RECT(lprcTshr, rc) \
    CopyRect((LPRECT)lprcTshr, &rc)

#define RECT_FROM_TSHR_RECT16(lprc, tshrrc) \
    CopyRect(lprc, (LPRECT)&tshrrc)

#else
_inline void TSHR_RECT16_FROM_RECT(LPTSHR_RECT16 pRect16, RECT rect)
{
    pRect16->left   = (TSHR_INT16)rect.left;
    pRect16->top    = (TSHR_INT16)rect.top;
    pRect16->right  = (TSHR_INT16)rect.right;
    pRect16->bottom = (TSHR_INT16)rect.bottom;
}

__inline void RECT_FROM_TSHR_RECT16(LPRECT pRect, TSHR_RECT16 rect16)
{
    pRect->left   = rect16.left;
    pRect->top    = rect16.top;
    pRect->right  = rect16.right;
    pRect->bottom = rect16.bottom;
}
#endif // IS_16



//
// TSHR_RGBQUAD
// =======
// rgbBlue         : blue value.
// rgbGreen        : green value.
//
// rgbRed          : red value.
// rgbReserved     : reserved.
//
typedef struct tagTSHR_RGBQUAD
{
    TSHR_UINT8   rgbBlue;
    TSHR_UINT8   rgbGreen;
    TSHR_UINT8   rgbRed;
    TSHR_UINT8   rgbReserved;
}
TSHR_RGBQUAD;
typedef TSHR_RGBQUAD FAR * LPTSHR_RGBQUAD;


//
// TSHR_COLOR
// =======
// red             : red value.
// green           : green value.
// blue            : blue value.
//
typedef struct tagTSHR_COLOR
{
    TSHR_UINT8   red;
    TSHR_UINT8   green;
    TSHR_UINT8   blue;
}
TSHR_COLOR;
typedef TSHR_COLOR FAR * LPTSHR_COLOR;


//
// TSHR_COLORS
// ========
// fg              : foreground color.
// bg              : background color.
//
typedef struct tagTSHR_COLORS
{
    TSHR_COLOR fg;
    TSHR_COLOR bg;
}
TSHR_COLORS;
typedef TSHR_COLORS FAR * LPTSHR_COLORS;


//
// BITMAPINFO_ours                                                         
// ===============                                                         
// bmiHeader       :                                                       
// bmiColors       :                                                       
//
typedef struct tagBITMAPINFO_ours
{
    BITMAPINFOHEADER   bmiHeader;
    TSHR_RGBQUAD          bmiColors[256];
}
BITMAPINFO_ours;



#define TSHR_RGBQUAD_TO_TSHR_COLOR(TshrRGBQuad, TshrColor)  \
        TshrColor.red = TshrRGBQuad.rgbRed;           \
        TshrColor.green = TshrRGBQuad.rgbGreen;       \
        TshrColor.blue = TshrRGBQuad.rgbBlue

#define TSHR_COLOR_TO_PALETTEENTRY(TshrColor, pe) \
        pe.peGreen = TshrColor.green;          \
        pe.peRed = TshrColor.red;              \
        pe.peBlue = TshrColor.blue;            \
        pe.peFlags = 0

#define TSHR_RGBQUAD_TO_PALETTEENTRY(TshrRGBQuad, pe) \
        pe.peRed   = TshrRGBQuad.rgbRed;           \
        pe.peGreen = TshrRGBQuad.rgbGreen;         \
        pe.peBlue  = TshrRGBQuad.rgbBlue;          \
        pe.peFlags = 0





//
// DATE
// =======
// day             : day of the month (1-31).
// month           : month (1-12).
// year            : year (e.g. 1996).
//
typedef struct tagTSHR_DATE
{
    TSHR_UINT8   day;
    TSHR_UINT8   month;
    TSHR_UINT16 year;
} TSHR_DATE;
typedef TSHR_DATE FAR * LPTSHR_DATE;


//
// TSHR_TIME
// =======
// hour            : hour (0-23).
// min             : minute (0-59).
// sec             : seconds (0-59).
// hundredths      : hundredths of a second (0-99).
//
typedef struct tagTSHR_TIME
{
    TSHR_UINT8   hour;
    TSHR_UINT8   min;
    TSHR_UINT8   sec;
    TSHR_UINT8   hundredths;
}
TSHR_TIME;
typedef TSHR_TIME FAR * LPTSHR_TIME;



//
// Maximum length of a person name                                         
//
#define TSHR_MAX_PERSON_NAME_LEN     48



//
// Common person information:  This is an ObMan object
//
typedef struct tagTSHR_PERSON_DATA
{
    char                personName[TSHR_MAX_PERSON_NAME_LEN];
    TSHR_PERSONID       personHandle;     // Call manager ID
}
TSHR_PERSON_DATA;
typedef TSHR_PERSON_DATA *  PTSHR_PERSON_DATA;




////////////////////////////////
//
// CAPABILITIES
//
////////////////////////////////


//
// Version numbers.
//
#define CAPS_VERSION_20         0x0200          // NM 2.x
#define CAPS_VERSION_30         0x0300          // NM 3.0
#define CAPS_VERSION_OLDEST_SUPPORTED   CAPS_VERSION_20
#define CAPS_VERSION_CURRENT            CAPS_VERSION_30

//
// Operating system and operating system version numbers.
//
#define CAPS_WINDOWS            0x0001

#define CAPS_WINDOWS_31         0x0001
#define CAPS_WINDOWS_95         0x0002
#define CAPS_WINDOWS_NT         0x0003

//
// Logical capabilities field values.
//
#define CAPS_UNDEFINED          0
#define CAPS_SUPPORTED          1
#define CAPS_UNSUPPORTED        2

//
// Number of order fields in the orders array.  This must never change
// because the fields within the capabilities structure must never move.
// If more orders fields are required then they must be added to the end of
// the capabilities structure.
//
#define CAPS_MAX_NUM_ORDERS     32

//
// String length of the driver name field in the capabilities structure.
// This allows for an 8.3 driver name (eg VGA.DRV), a NULL, and padding.
//
#define CAPS_DRIVER_NAME_LENGTH  16

//
// Capabilities (group structures) IDs currently defined.  Each ID
// corresponds to a different PROTCAPS structure. (See below).
//
#define CAPS_ID_GENERAL      1
#define CAPS_ID_SCREEN       2
#define CAPS_ID_ORDERS       3
#define CAPS_ID_BITMAPCACHE  4
#define CAPS_UNUSED_HCA      5
#define CAPS_UNUSED_FE       6
#define CAPS_UNUSED_AWC      7
#define CAPS_ID_CM           8
#define CAPS_ID_SC           9
#define CAPS_ID_PM          10
#define CAPS_UNUSED_SWL     11      // Used to be for regional window stuff




//
// Capabilities structure header.
//
typedef struct tagPROTCAPSHEADER
{
    TSHR_UINT16         capID;
    TSHR_UINT16         capSize;
}
PROTCAPSHEADER;


//
// Structure passed to CPC_RegisterCapabilities and returned by
// CPC_EnumerateCapabilities. The data field is of variable length (but
// always ends dword aligned).
//
typedef struct tagPROTCAPS
{
    PROTCAPSHEADER      header;
    TSHR_UINT32         data[1];
}
PROTCAPS;
typedef PROTCAPS *PPROTCAPS;



//
// Structure returned by CPC_GetCombinedCapabilities and as part of a
// NET_EV_PERSON_ADD event.
//
typedef struct tagPROTCOMBINEDCAPS_HEADER
{
    TSHR_UINT16         numCapabilities;
    TSHR_UINT16         pad1;
}
PROTCOMBINEDCAPS_HEADER;
typedef PROTCOMBINEDCAPS_HEADER * PPROTCOMBINEDCAPS_HEADER;

typedef struct tagPROTCOMBINEDCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS            capabilities[1];
}
PROTCOMBINEDCAPS;
typedef PROTCOMBINEDCAPS * PPROTCOMBINEDCAPS;
typedef PPROTCOMBINEDCAPS * PPPROTCOMBINEDCAPS;




//
//
// Curent capabilities structure (corresponding to the generic structures
// defined above)....
//
// Note that these must be DWORD padded in size for the current code to
// work correctly on all platforms.
//
//


//
// AS type flags
//
#define AS_SERVICE      0x0001
#define AS_UNATTENDED   0x0002

//
// General capabilities.
//
typedef struct tagPROTCAPS_GENERAL
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         OS;                         
    TSHR_UINT16         OSVersion;                  
    TSHR_UINT16         version;                    
    TSHR_UINT16         supportsDOS6Compression;    // OBSOLETE
    TSHR_UINT16         genCompressionType;         // OBSOLETE
    TSHR_UINT16         typeFlags;                  // NEW FOR 3.0
    TSHR_UINT16         supportsCapsUpdate;         // almost OBSOLETE
    TSHR_UINT16         supportsRemoteUnshare;      // OBSOLETE

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16         genCompressionLevel;
    TSHR_UINT16         pad1;
}
PROTCAPS_GENERAL;
typedef PROTCAPS_GENERAL *PPROTCAPS_GENERAL;

#define PROTCAPS_GENERAL_SIZE_NM20      FIELD_OFFSET(PROTCAPS_GENERAL, genCompressionLevel)


//
// Values for genCompressionLevel
//
// Level 0 : Only GDC_PKZIP compression is allowed in entire share session
//           (genCompressionType indicates if a node supports it)
//           Bit 15 (PT_COMPRESSED) of packetType field is used to
//           indicate if a packet is compressed.
//
// Level 1 : Each nodes genCompressionType indicates which compression
//           algorithms it can use to DECOMPRESS packets.
//           A node can compress a packet with any compression algorithm
//           that the receiving node(s) can decompress with.
//           The top byte of packetType indicates which compression
//           algorithm a packet ahs been compressed with.
//
// If the genCompressionLevel field is not present in a nodes GENERAL
// capabilities then that node is assumed to be use level 0.
//
#define CAPS_GEN_COMPRESSION_LEVEL_0    ((TSHR_UINT16)0x0000)
#define CAPS_GEN_COMPRESSION_LEVEL_1    ((TSHR_UINT16)0x0001)

//
// Bitmap capabilities.
//
typedef struct tagPROTCAPS_SCREEN
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsBPP;
    TSHR_UINT16         capsSupports1BPP;           // OBSOLETE 3.0
    TSHR_UINT16         capsSupports4BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsSupports8BPP;           // Almost OBSOLETE
    TSHR_UINT16         capsScreenWidth;
    TSHR_UINT16         capsScreenHeight;

    //
    // Need to keep this field unused for NM 2.0 interop.  
    // Can be reused when only care about NM 2.1 and above.
    //
    TSHR_UINT16         capsSupportsV1Compression;      // OBSOLETE

    TSHR_UINT16         capsSupportsDesktopResize;
    TSHR_UINT16         capsSupportsV2Compression;      // OBSOLETE

    //
    // NM 2.1 and earlier did NOT zero-init the caps structures.  Therefore
    // old pad fields can't be recovered until we only care about NM 3.0
    // compatibility and above.
    //
    TSHR_UINT16         pad1;

    // NEW FOR NM 3.0
    TSHR_UINT16         capsSupports24BPP;
    TSHR_UINT16         pad2;               // INIT THIS TO 0 ALWAYS; THEN IT CAN BE USED IN THE FUTURE
}
PROTCAPS_SCREEN;
typedef PROTCAPS_SCREEN *PPROTCAPS_SCREEN;

#define PROTCAPS_SCREEN_SIZE_NM21       FIELD_OFFSET(PROTCAPS_SCREEN, capsSupportsTrueColor)



//
// Orders capabilities.
//
typedef struct tagPROTCAPS_ORDERS
{
    PROTCAPSHEADER     header;
    TSHR_CHAR          capsDisplayDriver[CAPS_DRIVER_NAME_LENGTH];  // OBSOLETE
    TSHR_UINT32        capsSaveBitmapSize;
    TSHR_UINT16        capsSaveBitmapXGranularity;
    TSHR_UINT16        capsSaveBitmapYGranularity;
    TSHR_UINT16        capsSaveBitmapMaxSaveLevel;                  // OBSOLETE
    TSHR_UINT16        capsMaxOrderlevel;
    TSHR_UINT16        capsNumFonts;                                // OBSOLETE
    TSHR_UINT16        capsEncodingLevel;  // See below
    BYTE               capsOrders[CAPS_MAX_NUM_ORDERS];
    TSHR_UINT16        capsfFonts;         // only introduced at r1.1
    TSHR_UINT16        pad1;           // For DWORD alignment

    //
    // The size of the SSI save bitmap.
    //
    TSHR_UINT32        capsSendSaveBitmapSize;          // OBSOLETE
    //
    // The size of the SSI receive bitmap.
    //
    TSHR_UINT32        capsReceiveSaveBitmapSize;       // OBSOLETE
    TSHR_UINT16        capsfSendScroll;                 // OBSOLETE

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16        pad2;
}
PROTCAPS_ORDERS;
typedef PROTCAPS_ORDERS *PPROTCAPS_ORDERS;

#define PROTCAPS_ORDERS_SIZE_NM20       FIELD_OFFSET(PROTCAPS_ORDERS, pad2)



//
// Define the size of the bitmap used for the SaveBitmap order.            
// These dimensions must be multiples of the granularity values below.     
//
#define     TSHR_SSI_BITMAP_WIDTH           400
#define     TSHR_SSI_BITMAP_HEIGHT          400
#define     TSHR_SSI_BITMAP_SIZE            (TSHR_SSI_BITMAP_WIDTH * TSHR_SSI_BITMAP_HEIGHT)

#define     TSHR_SSI_BITMAP_X_GRANULARITY   1
#define     TSHR_SSI_BITMAP_Y_GRANULARITY   20


//
//
// These flags can be set in the capsfFonts fields. See also the defines
// below related to these flags (which must be updated when a new flag
// is defined).
//
#define CAPS_FONT_ASPECT            0x0001
#define CAPS_FONT_SIGNATURE         0x0002
#define CAPS_FONT_CODEPAGE          0x0004
#define CAPS_FONT_RESERVED1         0x0008      // Reserved for future BiDi support
#define CAPS_FONT_OLD_NEED_X        0x0010
#define CAPS_FONT_NEED_X_SOMETIMES  0x0020
#define CAPS_FONT_NEED_X_ALWAYS     0x0040
#define CAPS_FONT_R20_SIGNATURE     0x0080
#define CAPS_FONT_EM_HEIGHT         0x0100
#define CAPS_FONT_ALLOW_BASELINE    0x0200

//
// How the CAPS_FONT_XXX flags should be combined when adding a person to
// the share.
//
    //
    // AND these flags... the capability is relevant only if ALL parties
    // have it
    //
#define CAPS_FONT_AND_FLAGS     ( CAPS_FONT_ASPECT           \
                                | CAPS_FONT_SIGNATURE        \
                                | CAPS_FONT_R20_SIGNATURE    \
                                | CAPS_FONT_EM_HEIGHT        \
                                | CAPS_FONT_CODEPAGE         \
                                | CAPS_FONT_RESERVED1        \
                                | CAPS_FONT_ALLOW_BASELINE )
    //
    // OR these flags... the capability is relevant if ANY ONE party
    // requires it.
    //
#define CAPS_FONT_OR_FLAGS      ( CAPS_FONT_OLD_NEED_X       \
                                | CAPS_FONT_NEED_X_SOMETIMES \
                                | CAPS_FONT_NEED_X_ALWAYS    )

//
// Which of the CAPS_FONT_XXX flags should be switched on/off in the
// combined received capabilities when a person joins the call who does not
// have the capsfFonts field.
//
#define CAPS_FONT_OFF_FLAGS     ( CAPS_FONT_ASPECT    \
                                | CAPS_FONT_SIGNATURE \
                                | CAPS_FONT_CODEPAGE  \
                                | CAPS_FONT_RESERVED1 \
                                | CAPS_FONT_ALLOW_BASELINE )
#define CAPS_FONT_ON_FLAGS      ( 0                   )

#ifdef _DEBUG // for assertion
#define CAPS_FONT_R11_TEST_FLAGS    ( CAPS_FONT_ASPECT    \
                                    | CAPS_FONT_SIGNATURE \
                                    | CAPS_FONT_CODEPAGE  \
                                    | CAPS_FONT_RESERVED1 )
#endif

#define CAPS_FONT_R20_TEST_FLAGS    ( CAPS_FONT_R20_SIGNATURE \
                                    | CAPS_FONT_EM_HEIGHT )

//
// Level of order encoding support (capsEncodingLevel)
//
// These flags specify the types of order encoding and the level of
// negotiation supported.  The flags and their meanings are as follows.
//
// CAPS_ENCODING_BASE_OE
// - The base OE protocol is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_NEGOTIABLE
// - We can negotiate whether OE2 is supported.  R1.1 does not support this.
// CAPS_ENCODING_OE2_DISABLED
// - OE2 is disabled on this machine.  This flag is apparently upside down
// so that we can support R1,1, which will set it to 0 (because the
// capability didn;t exist in R1.1).
// CAPS_ENCODING_ALIGNED_OE
// - The aligned OE protocol is supported.  R1.1 does not support this.
//
//
#define CAPS_ENCODING_BASE_OE               0x0001
#define CAPS_ENCODING_OE2_NEGOTIABLE        0x0002
#define CAPS_ENCODING_OE2_DISABLED          0x0004
#define CAPS_ENCODING_ALIGNED_OE            0x0008

//
// Encoding level
//
#define CAPS_ENCODING_DCGC20    ( CAPS_ENCODING_BASE_OE \
                                | CAPS_ENCODING_OE2_NEGOTIABLE)
//
// Encoding level supported by Millennium codebase
//
#define CAPS_ENCODING_DEFAULT   ( CAPS_ENCODING_OE2_NEGOTIABLE )

//
// Bitmap Cache capabilities.
//
typedef struct tagPROTCAPS_BITMAPCACHE_DETAILS
{
    TSHR_UINT16         capsSmallCacheNumEntries;
    TSHR_UINT16         capsSmallCacheCellSize;
    TSHR_UINT16         capsMediumCacheNumEntries;
    TSHR_UINT16         capsMediumCacheCellSize;
    TSHR_UINT16         capsLargeCacheNumEntries;
    TSHR_UINT16         capsLargeCacheCellSize;
}
PROTCAPS_BITMAPCACHE_DETAILS;

typedef struct tagPROTCAPS_BITMAPCACHE
{
    PROTCAPSHEADER  header;

    //
    // The following fields (which MUST immediately follow the header) are
    // used by the point to point R1.1 implementation only {
    //
    PROTCAPS_BITMAPCACHE_DETAILS r11Obsolete;       // OBSOLETE

    //
    // } end of fields used by point to point implementation only.
    //
    // The rest of this structure is only used by the multi-party code.
    //

    PROTCAPS_BITMAPCACHE_DETAILS sender;
    PROTCAPS_BITMAPCACHE_DETAILS receiver;          // OBSOLETE
}
PROTCAPS_BITMAPCACHE;
typedef PROTCAPS_BITMAPCACHE *PPROTCAPS_BITMAPCACHE;




//
// CM capabilities.
//
typedef struct tagPROTCAPS_CM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsSupportsColorCursors;
    TSHR_UINT16         capsCursorCacheSize;
}
PROTCAPS_CM;
typedef PROTCAPS_CM * PPROTCAPS_CM;

#define TSHR_CM_CACHE_ENTRIES   25




//
// PM capabilities.
//
typedef struct tagPROTCAPS_PM
{
    PROTCAPSHEADER      header;
    TSHR_UINT16         capsColorTableCacheSize;

    // NEW FOR NM 2.0 NT && NM 2.1 WIN95
    TSHR_UINT16         pad1;
}
PROTCAPS_PM;
typedef PROTCAPS_PM * PPROTCAPS_PM;

#define PROTCAPS_PM_SIZE_NM20   FIELD_OFFSET(PROTCAPS_PM, pad1)


#define TSHR_PM_CACHE_ENTRIES       6




//
// SC capabilities.
//
typedef struct tagPROTCAPS_SC
{
    PROTCAPSHEADER      header;
    TSHR_PERSONID       gccID;
}
PROTCAPS_SC;
typedef PROTCAPS_SC * PPROTCAPS_SC;




// If you add a PROTCAPS_ strcuture to CPCALLCAPS, update the count
#define PROTCAPS_COUNT      7

typedef struct tagCPCALLCAPS
{
    PROTCOMBINEDCAPS_HEADER header;
    PROTCAPS_GENERAL        general;
    PROTCAPS_SCREEN         screen;
    PROTCAPS_ORDERS         orders;
    PROTCAPS_BITMAPCACHE    bitmaps;
    PROTCAPS_CM             cursor;
    PROTCAPS_PM             palette;
    PROTCAPS_SC             share;
}
CPCALLCAPS;
typedef CPCALLCAPS * PCPCALLCAPS;



#if 0
//
// New 3.0 CAPS.  We've accumulated a lot of obsolete or garbage caps.  This
// is a condensed new basic set.  Note that orders is separated from general
// since it is the most likely one to be periodically added to.
//      * General
//      * Orders
//      * Hosting
//

#define ASCAPS_GENERAL          0
#define ASCAPS_ORDERS           1
#define ASCAPS_HOSTING          2

typedef struct tagTSHRCAPS_GENERAL
{
    PROTCAPSHEADER      header;

    TSHR_UINT16         protVersion;
    TSHR_UINT16         asMode;             // Unattended, streaming, service, no host, no view, etc.
    
    TSHR_UINT16         gccPersonID;        // GCC node ID;
    TSHR_UINT16         pktCompression;     // None, PKZIP, PersistPKZIP

    TSHR_UINT16         protBPPs;           // Color depths supported (4, 8, 24)
    TSHR_UINT16         screenBPP;
    TSHR_UINT16         screenWidth;
    TSHR_UINT16         screenHeight;
}
TSHRCAPS_GENERAL;
typedef TSHRCAPS_GENERAL * PTSHRCAPS_GENERAL;


typedef struct tagTSHRCAPS_ORDERS
{
    PROTCAPSHEADER      header;

}
TSHRCAPS_ORDERS;
typedef TSHRCAPS_ORDERS * PTSHRCAPS_ORDERS;



typedef struct tagTSHRCAPS_HOSTING
{
    PROTCAPSHEADER      header;

    //
    // These are zero if the host doesn't have such a thing, and viewers
    // should not therefore allocate memory for the caches.
    //
    TSHR_UINT32         ssiSaveBitsPixels;
    TSHR_UINT16         ssiSaveBitsXGranularity;
    TSHR_UINT16         ssiSaveBitsYGranularity;

    TSHR_UINT16         cmCursorCacheEntries;
    TSHR_UINT16         fhGlyphSetCacheEntries;
    TSHR_UINT16         pmPaletteCacheEntries;
    TSHR_UINT16         pad1;

    TSHR_UINT16         sbcSmallBmpCacheEntries;
    TSHR_UINT16         sbcSmallBmpCacheBytes;
    TSHR_UINT16         sbcMediumBmpCacheEntries;
    TSHR_UINT16         sbcMediumBmpCacheEntries;
    TSHR_UINT16         sbcLargeBmpCacheEntries;
    TSHR_UINT16         sbcLargeBmpCacheBytes;
}
TSHRCAPS_HOSTING;
typedef TSHRCAPS_HOSTING * PTSHRCAPS_HOSTING;


typedef struct tagTSHRCAPS_ORDERS
{
    PROTCAPSHEADER      header;

    TSHR_UINT16         ordCompression;     // Encoding types

    TSHR_UINT16         fhFontMatching;     // Font matching
    TSHR_UINT32         localeID;
    TSHR_UINT16         fhInternational;    // International text stuff

    TSHR_UINT16         ordNumOrders;       // Size of orders array
    TSHR_UINT8          ordOrders[CAPS_MAX_NUM_ORDERS];
}
TSHRCAPS_ORDERS;
typedef TSHRCAPS_ORDERS * PTSHRCAPS_ORDERS;

#endif

////////////////////////////////
//
// ORDERS
//
////////////////////////////////


//
//
// COM_ORDER_HEADER
//
// Any orders supplied to the accumulation functions must have
// the following fields filled in:
//
// cbOrderDataLength
//   The length in bytes of the order data (i.e. EXCLUDING the
//   header - which is always a fixed size).
//
// fOrderFlags
//   This can hold a combination of the following flags:
//
//   OF_SPOILER - the order can spoil earlier SPOILABLE ones that it
//                overlaps
//
//   OF_SPOILABLE - the order can be spoilt by SPOILER orders that overlap
//                  it
//
//   OF_BLOCKER - no orders before this one may be spoilt
//
//   OF_PRIVATE - a private order (used by bitmap caching code)
//
//   OF_NOTCLIPPED - this flag is set by OD2 on the DECODING side of the
//                   order processing to indicate that the order is not
//                   clipped. ie the rectangle is the bounding rectangle
//                   but does not result in any clipping taking place.
//                   THIS FLAG IS NOT TRANSMITTED ACROSS THE NETWORK.
//
//   OF_INTERNAL - the order is an internal order, and should not be sent
//                 over the wire.  An internal order is used to pass data
//                 from the device driver to the share core.
//
//   OF_DESTROP - the order has a ROP which relies on the contents of the
//                destination (relies on what is already on the screen).
//
// rcsDst
//   The bounding rectangle of the order in INCLUSIVE screen (pel) coords.
//
//
typedef struct tagCOM_ORDER_HEADER
{
    TSHR_UINT16         cbOrderDataLength;
    TSHR_UINT16         fOrderFlags;
    TSHR_RECT16         rcsDst;
}
COM_ORDER_HEADER;
typedef COM_ORDER_HEADER FAR * LPCOM_ORDER_HEADER;


//
// COM_ORDER_HEADER fOrderFlags values
//
#define OF_SPOILER          0x0001
#define OF_SPOILABLE        0x0002
#define OF_BLOCKER          0x0004
#define OF_PRIVATE          0x0008
#define OF_NOTCLIPPED       0x0010
#define OF_SPOILT           0x0020
#define OF_INTERNAL         0x0040
#define OF_DESTROP          0x0080


//
// Each type of order's structure is the bytes in abOrderData[].
//
typedef struct tagCOM_ORDER
{
    COM_ORDER_HEADER    OrderHeader;
    BYTE                abOrderData[1];
}
COM_ORDER;
typedef COM_ORDER           FAR * LPCOM_ORDER;
typedef COM_ORDER UNALIGNED FAR * LPCOM_ORDER_UA;


//
// Macro to calculate a basic common order size (including the Order
// Header).
//
#define COM_ORDER_SIZE(pOrder) \
    (pOrder->OrderHeader.cbOrderDataLength + sizeof(COM_ORDER_HEADER))




//
// The various drawing order structures have the following design objectives
//
//      the first field - type - is common to all orders.
//      field ordering is kept as regular as possible amongst similar
//          orders so that compression may find more regular sequences
//      fields are naturally aligned (dwords on dword boundaries etc)
//      fields are reordered so to preserve alignment rather than add
//          padding
//      padding is added as a last resort.
//      variable sized data comes at the end of the structure.
//
// All rectangles are inclusive of start and end points.
//
// All points are in screen coordinates, with (0,0) at top left.
//
// Interpretation of individual field values is as in Windows
//      in particular pens, brushes and font are as defined for Windows 3.1
//



//
// Orders - the high word is used as an index into a table
//        - the low word is a 2 character ASCII type descriptor and is the
//          only part actually passed in the order.
//
#define ORD_DSTBLT_INDEX        0x0000
#define ORD_PATBLT_INDEX        0x0001
#define ORD_SCRBLT_INDEX        0x0002
#define ORD_MEMBLT_INDEX        0x0003
#define ORD_MEM3BLT_INDEX       0x0004
#define ORD_TEXTOUT_INDEX       0x0005
#define ORD_EXTTEXTOUT_INDEX    0x0006
#define ORD_RECTANGLE_INDEX     0x0007
#define ORD_LINETO_INDEX        0x0008
#define ORD_UNUSED_INDEX        0x0009
#define ORD_OPAQUERECT_INDEX    0x000A
#define ORD_SAVEBITMAP_INDEX    0x000B
#define ORD_RESERVED_INDEX      0x000C
#define ORD_MEMBLT_R2_INDEX     0x000D
#define ORD_MEM3BLT_R2_INDEX    0x000E
#define ORD_POLYGON_INDEX       0x000F
#define ORD_PIE_INDEX           0x0010
#define ORD_ELLIPSE_INDEX       0x0011
#define ORD_ARC_INDEX           0x0012
#define ORD_CHORD_INDEX         0x0013
#define ORD_POLYBEZIER_INDEX    0x0014
#define ORD_ROUNDRECT_INDEX     0x0015
//
// It IS OK to use order 000C!  These numbers don't clash with OE2_* in
// aoe2int.h.  Replace ORD_RESERVED_INDEX (0xC) for the next new order.
//
// NOTE: When you use this index, OE_GetLocalOrderSupport must be updated
// to allow the order.
//

#define ORD_DSTBLT_TYPE         0x4244      // "DB"
#define ORD_PATBLT_TYPE         0x4250      // "PB"
#define ORD_SCRBLT_TYPE         0x4253      // "SB"
#define ORD_MEMBLT_TYPE         0x424d      // "MB"
#define ORD_MEM3BLT_TYPE        0x4233      // "3B"
#define ORD_TEXTOUT_TYPE        0x4f54      // "TO"
#define ORD_EXTTEXTOUT_TYPE     0x5445      // "ET"
#define ORD_RECTANGLE_TYPE      0x5452      // "RT"
#define ORD_LINETO_TYPE         0x544c      // "LT"
#define ORD_OPAQUERECT_TYPE     0x524f      // "OR"
#define ORD_SAVEBITMAP_TYPE     0x5653      // "SV"
#define ORD_MEMBLT_R2_TYPE      0x434d      // "MC"
#define ORD_MEM3BLT_R2_TYPE     0x4333      // "3C"
#define ORD_POLYGON_TYPE        0x4750      // "PG"
#define ORD_PIE_TYPE            0x4950      // "PI"
#define ORD_ELLIPSE_TYPE        0x4c45      // "EL"
#define ORD_ARC_TYPE            0x5241      // "AR"
#define ORD_CHORD_TYPE          0x4443      // "CD"
#define ORD_POLYBEZIER_TYPE     0x5A50      // "PZ"
#define ORD_ROUNDRECT_TYPE      0x5252      // "RR"


#define ORD_DSTBLT          MAKELONG(ORD_DSTBLT_TYPE, ORD_DSTBLT_INDEX)
#define ORD_PATBLT          MAKELONG(ORD_PATBLT_TYPE, ORD_PATBLT_INDEX)
#define ORD_SCRBLT          MAKELONG(ORD_SCRBLT_TYPE, ORD_SCRBLT_INDEX)
#define ORD_MEMBLT          MAKELONG(ORD_MEMBLT_TYPE, ORD_MEMBLT_INDEX)
#define ORD_MEM3BLT         MAKELONG(ORD_MEM3BLT_TYPE, ORD_MEM3BLT_INDEX)
#define ORD_TEXTOUT         MAKELONG(ORD_TEXTOUT_TYPE, ORD_TEXTOUT_INDEX)
#define ORD_EXTTEXTOUT      MAKELONG(ORD_EXTTEXTOUT_TYPE, ORD_EXTTEXTOUT_INDEX)
#define ORD_RECTANGLE       MAKELONG(ORD_RECTANGLE_TYPE, ORD_RECTANGLE_INDEX)
#define ORD_LINETO          MAKELONG(ORD_LINETO_TYPE, ORD_LINETO_INDEX)
#define ORD_OPAQUERECT      MAKELONG(ORD_OPAQUERECT_TYPE, ORD_OPAQUERECT_INDEX)
#define ORD_SAVEBITMAP      MAKELONG(ORD_SAVEBITMAP_TYPE, ORD_SAVEBITMAP_INDEX)
#define ORD_MEMBLT_R2       MAKELONG(ORD_MEMBLT_R2_TYPE, ORD_MEMBLT_R2_INDEX)
#define ORD_MEM3BLT_R2      MAKELONG(ORD_MEM3BLT_R2_TYPE, ORD_MEM3BLT_R2_INDEX)
#define ORD_POLYGON         MAKELONG(ORD_POLYGON_TYPE, ORD_POLYGON_INDEX)
#define ORD_PIE             MAKELONG(ORD_PIE_TYPE, ORD_PIE_INDEX)
#define ORD_ELLIPSE         MAKELONG(ORD_ELLIPSE_TYPE, ORD_ELLIPSE_INDEX)
#define ORD_ARC             MAKELONG(ORD_ARC_TYPE, ORD_ARC_INDEX)
#define ORD_CHORD           MAKELONG(ORD_CHORD_TYPE, ORD_CHORD_INDEX)
#define ORD_POLYBEZIER      MAKELONG(ORD_POLYBEZIER_TYPE, ORD_POLYBEZIER_INDEX)
#define ORD_ROUNDRECT       MAKELONG(ORD_ROUNDRECT_TYPE, ORD_ROUNDRECT_INDEX)


//
// The following order is special - support is not negotiated by the
// capsOrders field in the orders capabilities structure.
// The high words start at 32, ie after CAPS_MAX_NUM_ORDERS.
//
// ORD_NUM_INTERNAL_ORDERS is the number of orders we use internally - this
// include all CAPS_MAX_NUM_ORDERS, plus any of these special orders.
//
#define ORD_DESKSCROLL_INDEX    0x0020
#define ORD_DESKSCROLL_TYPE     0x5344      // "DS"
#define ORD_DESKSCROLL          MAKELONG(ORD_DESKSCROLL_TYPE, ORD_DESKSCROLL_INDEX)

#define INTORD_COLORTABLE_INDEX 0x000C
#define INTORD_COLORTABLE_TYPE  0x5443      // "CT"
#define INTORD_COLORTABLE       MAKELONG(INTORD_COLORTABLE_TYPE, INTORD_COLORTABLE_INDEX)

#define ORD_NUM_INTERNAL_ORDERS 33
#define ORD_NUM_LEVEL_1_ORDERS  22

#define ORD_LEVEL_1_ORDERS      1

//
// The maximum length of string which we will send as an order (either as
// TextOut or ExtTextOut) when a delta X array is supplied or not.
//
//
// NOTE:  THESE MUST TOTAL LESS THAN 256 BECAUSE THE TOTAL ENCODED SIZE 
// MUST FIT IN ONE BYTE.
//
//      STRING_LEN_WITHOUT_DELTAS       --  1 byte per char
//      STRING_LEN_WITH_DELTAS          --  1 byte per char + 1 byte per delta
//      ORD_MAX_POLYGON_POINTS          --  4 bytes per point (2 each coord)
//      ORD_MAX_POLYBEZIER_POINTS       --  4 bytes per point (2 each coord)
//
#define ORD_MAX_STRING_LEN_WITHOUT_DELTAS   255
#define ORD_MAX_STRING_LEN_WITH_DELTAS      127
#define ORD_MAX_POLYGON_POINTS              63
#define ORD_MAX_POLYBEZIER_POINTS           63

//
// Direction codes for arc drawing orders (pie, arc, chord).
// Specifies direction that pie, arc, and chord figures are drawn.
//
#define     ORD_ARC_COUNTERCLOCKWISE            1
#define     ORD_ARC_CLOCKWISE                   2

//
// Fill-mode codes for polygon drawing.
//
// Alternate fills area between odd-numbered and even-numbered polygon
// sides on each scan line.
//
// Winding fills any region with a nonzero winding value.
//
#define     ORD_FILLMODE_ALTERNATE              1
#define     ORD_FILLMODE_WINDING                2

//
// DstBlt (Destination only Screen Blt)
//
typedef struct _DSTBLT_ORDER
{
    TSHR_UINT16     type;           // holds "DB" - ORD_DSTBLT
    TSHR_INT16      pad1;

    TSHR_INT32      nLeftRect;      // x upper left
    TSHR_INT32      nTopRect;       // y upper left
    TSHR_INT32      nWidth;         // dest width
    TSHR_INT32      nHeight;        // dest height

    TSHR_UINT8      bRop;           // ROP
    TSHR_UINT8      pad2[3];
} DSTBLT_ORDER, FAR * LPDSTBLT_ORDER;

//
// PatBlt (Pattern to Screen Blt)
//
typedef struct _PATBLT_ORDER
{
    TSHR_UINT16    type;           // holds "PB" - ORD_PATBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_COLOR         BackColor;
    TSHR_UINT8      pad2;
    TSHR_COLOR         ForeColor;
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

} PATBLT_ORDER, FAR * LPPATBLT_ORDER;

//
// ScrBlt (Screen to Screen Blt)
//
typedef struct _SCRBLT_ORDER
{
    TSHR_UINT16    type;           // holds "SB" - ORD_SCRBLT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

} SCRBLT_ORDER, FAR * LPSCRBLT_ORDER;

//
// @@@ The common parts of MEMBLT_ORDER / MEMBLT_R2_ORDER and MEM3BLT_ORDER
// / MEM3BLT_R2_ORDER should be merged into a single structure.  There is
// code which assumes that the common fields have the same types which goes
// wrong if these are not the same.
//


//
// Define the structure for Bitmap Cache Orders.
// These are sent in Order Packets as "private" orders.
//

//
// Define the possible Bitmap Cache Packet Types.
//
#define BMC_PT_BITMAP_BITS_UNCOMPRESSED   0
#define BMC_PT_COLOR_TABLE                1
#define BMC_PT_BITMAP_BITS_COMPRESSED     2


//
// NOTE: avoid unions to get structure size / alignment correct.
//


// Structure: BMC_BITMAP_BITS_DATA
//
// Description: This is the part of the bitmap bits order which is common
// to both R1 and R2 protocols.
//
typedef struct tagBMC_BITMAP_BITS_DATA
{
    TSHR_UINT8      bmcPacketType;      // One of:
                                    //   BMC_PT_BITMAP_BITS_COMPRESSED
                                    //   BMC_PT_BITMAP_BITS_UNCOMPRESSED
    TSHR_UINT8      cacheID;            // Cache ID
    // lonchanc: do not remove iCacheEntryR1 for backward compatibility
    TSHR_UINT8      iCacheEntryR1;      // Cache index (only used for R1
                                    //   protocol
    TSHR_UINT8      cxSubBitmapWidth;   // Bitmap width
    TSHR_UINT8      cySubBitmapHeight;  // Bitmap height
    TSHR_UINT8      bpp;                // Number of bits per pel of bitmap
    TSHR_UINT16     cbBitmapBits;       // Number of bytes of data required to
                                    //   send the bits.
}
BMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA           FAR  * PBMC_BITMAP_BITS_DATA;
typedef BMC_BITMAP_BITS_DATA UNALIGNED FAR * PBMC_BITMAP_BITS_DATA_UA;




// Structure: BMC_BITMAP_BITS_ORDER_R2
//
// Description: The data which is sent across the wire for an R2 bitmap
// bits order.  The data field is the start of an array of bytes of length
// header.cbBitmapBits
//
// We need a 16 bit cache index in R2.  We could add another 8 bit entry
// and merge with the R1 field, but in the interests of protocol
// cleanliness we should add a whole 16 bit field and make the R1 index
// "reserved" in the protocol documentation.
//
//
typedef struct tagBMC_BITMAP_BITS_ORDER_R2
{
    BMC_BITMAP_BITS_DATA    header;         // Common header information
    TSHR_UINT16             iCacheEntryR2;  // R2 cache index.  The high
                                            //   byte is a color table
                                            //   index, and the low byte
                                            //   is the bitmap bits cache
                                            //   index.
    TSHR_UINT8              data[2];        // Start of the bitmap bits.
}
BMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 FAR           * PBMC_BITMAP_BITS_ORDER_R2;
typedef BMC_BITMAP_BITS_ORDER_R2 UNALIGNED FAR * PBMC_BITMAP_BITS_ORDER_R2_UA;


//
// Structure sent for color data.  The data field is the first entry in an
// array of colorTableSize entries.
//
typedef struct tagBMC_COLOR_TABLE_ORDER
{
    TSHR_UINT8         bmcPacketType;      // BMC_PT_COLORTABLE
    TSHR_UINT8         index;              // Color table cache index
    TSHR_UINT16        colorTableSize;     // Number of entries in the
                                        //   color table being sent.
    TSHR_RGBQUAD       data[1];            // Start of an array of color table
                                        //   entries.
}
BMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER FAR            * PBMC_COLOR_TABLE_ORDER;
typedef BMC_COLOR_TABLE_ORDER UNALIGNED FAR * PBMC_COLOR_TABLE_ORDER_UA;



//
// MemBlt (Memory to Screen Blt)
// R1 protocol
//
typedef struct _MEMBLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

}
MEMBLT_ORDER, FAR * LPMEMBLT_ORDER;


//
// MemBltR2 (Memory to Screen Blt for R2 protocol)
// Added cache index
//
typedef struct _MEMBLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MC" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_UINT16    cacheIndex;

} MEMBLT_R2_ORDER, FAR * LPMEMBLT_R2_ORDER;


//
// Mem3Blt (Memory Pattern to Screen 3 way ROP Blt)
//
typedef struct _MEM3BLT_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

} MEM3BLT_ORDER, FAR * LPMEM3BLT_ORDER;

//
// Mem3Blt (Memory to Screen Blt) for R2 (multipoint) protocols
// Add a cache index field rather than using nXSrc.
//
typedef struct _MEM3BLT_R2_ORDER
{
    TSHR_UINT16    type;           // holds "MB" - ORD_MEMBLT

    TSHR_UINT16    cacheId;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_UINT32    bRop;           // ROP

    TSHR_INT32     nXSrc;
    TSHR_INT32     nYSrc;

    TSHR_COLOR     BackColor;
    TSHR_UINT8      pad1;
    TSHR_COLOR     ForeColor;
    TSHR_UINT8      pad2;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad3;

    TSHR_UINT16    cacheIndex;

} MEM3BLT_R2_ORDER, FAR * LPMEM3BLT_R2_ORDER;

//
// Variable length text structure as used by TextOut and ExtTextOut orders
//
typedef struct tagVARIABLE_STRING
{
    TSHR_UINT32    len;
    TSHR_CHAR   string[ORD_MAX_STRING_LEN_WITHOUT_DELTAS];
    TSHR_UINT8        pad;
} VARIABLE_STRING;

//
// Variable length position deltas as used by ExtTextOut.
//
typedef struct tagVARIABLE_DELTAX
{
    TSHR_UINT32    len;
    TSHR_INT32     deltaX[ORD_MAX_STRING_LEN_WITH_DELTAS];
} VARIABLE_DELTAX, FAR * LPVARIABLE_DELTAX;

//
// Variable length point array used by Polygon.
//
typedef struct tagVARIABLE_POINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYGON_POINTS];
} VARIABLE_POINTS, FAR * LPVARIABLE_POINTS;

//
// Variable length point array used by PolyBezier.
//
typedef struct tagVARIABLE_BEZIERPOINTS
{
    TSHR_UINT32    len;   // byte count of point array
    TSHR_POINT16   aPoints[ORD_MAX_POLYBEZIER_POINTS];
} VARIABLE_BEZIERPOINTS, FAR * LPVARIABLE_BEZIERPOINTS;

//
// The common part of the TEXTOUT and EXTTEXTOUT orders
//
typedef struct tagCOMMON_TEXTORDER
{
    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // X location of string
    TSHR_INT32     nYStart;        // Y location of string

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     CharExtra;      // extra character spacing
    TSHR_INT32     BreakExtra;     // justification break amount
    TSHR_INT32     BreakCount;     // justification break count

    TSHR_INT32     FontHeight;
    TSHR_INT32     FontWidth;
    TSHR_UINT32    FontWeight;
    TSHR_UINT32    FontFlags;
    TSHR_UINT32    FontIndex;
} COMMON_TEXTORDER, FAR * LPCOMMON_TEXTORDER;

//
// TextOut
//
typedef struct _TEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "TO" - ORD_TEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    //
    // The following variable data occurs here.  (Remember to change the
    // code in OD2CalculateTextOutBounds if you change these).
    //
    VARIABLE_STRING variableString;

} TEXTOUT_ORDER, FAR * LPTEXTOUT_ORDER;


//
// ExtTextOut
//
typedef struct _EXTTEXTOUT_ORDER
{
    TSHR_UINT16    type;           // holds "ET" - ORD_EXTTEXTOUT
    TSHR_INT16     pad1;

    COMMON_TEXTORDER common;

    TSHR_UINT16        fuOptions;      // option flags
    TSHR_UINT16        pad4;

    TSHR_RECT32     rectangle;

    //
    // The following variable data occurs here.
    //
    //      char[cbString]  - the string of chars to be output
    //      TSHR_INT32[cbString] - X deltas for the string
    //
    // (Remember to change the code in OD2CalculateExtTextOutBounds if you
    // change these).
    //
    VARIABLE_STRING variableString;

    VARIABLE_DELTAX variableDeltaX;

} EXTTEXTOUT_ORDER, FAR * LPEXTTEXTOUT_ORDER;

//
// Rectangle
//
typedef struct _RECTANGLE_ORDER
{
    TSHR_UINT16    type;           // holds "RT" - ORD_RECTANGLE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} RECTANGLE_ORDER, FAR * LPRECTANGLE_ORDER;

//
// LineTo
//
typedef struct _LINETO_ORDER
{
    TSHR_UINT16    type;           // holds "LT" - ORD_LINETO
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nXStart;        // x line start
    TSHR_INT32     nYStart;        // y line start
    TSHR_INT32     nXEnd;          // x line end
    TSHR_INT32     nYEnd;          // y line end

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;
} LINETO_ORDER, FAR * LPLINETO_ORDER;

//
// OpaqueRect
//
typedef struct _OPAQUE_RECT
{
    TSHR_UINT16    type;           // holds "OR" - ORD_OPAQUERECT
    TSHR_INT16     pad1;

    TSHR_INT32     nLeftRect;      // x upper left
    TSHR_INT32     nTopRect;       // y upper left
    TSHR_INT32     nWidth;         // dest width
    TSHR_INT32     nHeight;        // dest height

    TSHR_COLOR     Color;          // opaque color
    TSHR_UINT8      pad2;
} OPAQUERECT_ORDER, FAR * LPOPAQUERECT_ORDER;

//
// SaveBitmap (incorporating RestoreBitmap)
//
#define SV_SAVEBITS      0
#define SV_RESTOREBITS   1

typedef struct _SAVEBITMAP_ORDER
{
    TSHR_UINT16    type;           // holds "SV" - ORD_SAVEBITMAP
    TSHR_INT16     pad1;

    TSHR_UINT32    SavedBitmapPosition;

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_UINT32    Operation;      // SV_xxxxxxxx
} SAVEBITMAP_ORDER, FAR * LPSAVEBITMAP_ORDER;

//
// Desktop scroll order
//
// The desktop order is special - it is a non-private order which is second
// level encoded, BUT support is not negotiated via its own entry in the
// capsOrdesr array in the orders capabilities.
//
// (Sending support is determined via a number of factors - at r2.x receive
// support for ORD_SCRBLT implies support for ORD_DESKSCROLL as well).
//
//
typedef struct _DESKSCROLL_ORDER
{
    TSHR_UINT16    type;           // holds "DS" - ORD_DESKSCROLL
    TSHR_INT16     pad1;

    TSHR_INT32     xOrigin;
    TSHR_INT32     yOrigin;
} DESKSCROLL_ORDER, FAR * LPDESKSCROLL_ORDER;


//
// Polygon
//
typedef struct _POLYGON_ORDER
{
    TSHR_UINT16    type;           // holds "PG" - ORD_POLYGON
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    FillMode;       // ORD_FILLMODE_ALTERNATE or
                                // ORD_FILLMODE_WINDING

    //
    // The following variable data occurs here.
    //
    VARIABLE_POINTS variablePoints;

} POLYGON_ORDER, FAR * LPPOLYGON_ORDER;


//
// Pie
//
typedef struct _PIE_ORDER
{
    TSHR_UINT16    type;           // holds "PI" - ORD_PIE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;


    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // ORD_ARC_COUNTERCLOCKWISE or
                                // ORD_ARC_CLOCKWISE
} PIE_ORDER, FAR * LPPIE_ORDER;


//
// Ellipse
//
typedef struct _ELLIPSE_ORDER
{
    TSHR_UINT16    type;           // holds "EL" - ORD_ELLIPSE
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
} ELLIPSE_ORDER, FAR * LPELLIPSE_ORDER;


//
// Arc
//
typedef struct _ARC_ORDER
{
    TSHR_UINT16    type;           // holds "AR" - ORD_ARC
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad3;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AS_CLOCKWISE
} ARC_ORDER, FAR * LPARC_ORDER;


//
// Chord
//
typedef struct _CHORD_ORDER
{
    TSHR_UINT16    type;           // holds "CD" - ORD_CHORD
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left of bounding box
    TSHR_INT32     nTopRect;       // y top of bounding box
    TSHR_INT32     nRightRect;     // x right of bounding box
    TSHR_INT32     nBottomRect;    // y bottom of bounding box
    TSHR_INT32     nXStart;        // x of starting point
    TSHR_INT32     nYStart;        // y of starting point
    TSHR_INT32     nXEnd;          // x of ending point
    TSHR_INT32     nYEnd;          // y of ending point

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;

    TSHR_UINT32    ArcDirection;   // AD_COUNTERCLOCKWISE or AD_CLOCKWISE
} CHORD_ORDER, FAR * LPCHORD_ORDER;


//
// PolyBezier
//
typedef struct _POLYBEZIER_ORDER
{
    TSHR_UINT16    type;           // holds "PZ" - ORD_POLYBEZIER
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;

    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad4;

    //
    // The following variable data occurs here.
    //
    VARIABLE_BEZIERPOINTS variablePoints;

} POLYBEZIER_ORDER, FAR * LPPOLYBEZIER_ORDER;


//
// RoundRect
//
typedef struct _ROUNDRECT_ORDER
{
    TSHR_UINT16    type;           // holds "RR" - ORD_ROUNDRECT
    TSHR_INT16     pad1;

    TSHR_INT32     BackMode;       // background mix mode

    TSHR_INT32     nLeftRect;      // x left
    TSHR_INT32     nTopRect;       // y top
    TSHR_INT32     nRightRect;     // x right
    TSHR_INT32     nBottomRect;    // y bottom

    TSHR_INT32     nEllipseWidth;  // ellipse width
    TSHR_INT32     nEllipseHeight; // ellipse height

    TSHR_COLOR     BackColor;      // background color
    TSHR_UINT8      pad2;
    TSHR_COLOR     ForeColor;      // foreground color
    TSHR_UINT8      pad3;

    TSHR_INT32     BrushOrgX;
    TSHR_INT32     BrushOrgY;
    TSHR_UINT32    BrushStyle;
    TSHR_UINT32    BrushHatch;
    TSHR_UINT8     BrushExtra[7];
    TSHR_UINT8      pad4;

    TSHR_UINT32    ROP2;           // drawing mode

    TSHR_UINT32    PenStyle;
    TSHR_UINT32    PenWidth;       // always 1 - field retained for
                                // backwards compatibility
    TSHR_COLOR     PenColor;
    TSHR_UINT8      pad5;
}
ROUNDRECT_ORDER, FAR * LPROUNDRECT_ORDER;



////////////////////////////////
//
// ORDER ENCODING
//
////////////////////////////////


//
// Overview of Second Order Encoding
//
// Second order encoding works by only sending over the network the fields
// in an order which have changed since the last time the order was sent.
// A copy of the last example of each order sent is maintained at the
// encoding end and at the decoding end.  Whilst encoding, the fields in
// the order being encoded are checked against the fields in the copy of
// the last order of this type encoded.  The data in the field is only
// encoded if it has changed. The decoding end then only needs to copy the
// changed fields into its copy of the order.
//


//
// Encoded Order types.
//
// Note that most of these agree with the ORD_XXXXX defines, but not all,
// which is probably a mistake.  However it doesn't matter since the code
// does not assume equivalence.  It is unfortunately too late to change
// since the the shipping code uses the 2 sets of numbers:
//
//     - the OE2 protocol uses these numbers
//     - the capabilities structure uses the ORD_XXXXX numbers.
//
// Since this split exists, the DESKTOP SCROLL order, whose highword places
// it outside the CAPS_MAX_NUM_ORDERS range, is also mapped to a different
// number, so that the OE2 values have no gaps.
//
#define OE2_DSTBLT_ORDER      (HIWORD(ORD_DSTBLT))
#define OE2_PATBLT_ORDER      (HIWORD(ORD_PATBLT))
#define OE2_SCRBLT_ORDER      (HIWORD(ORD_SCRBLT))
#define OE2_MEMBLT_ORDER      (HIWORD(ORD_MEMBLT))
#define OE2_MEM3BLT_ORDER     (HIWORD(ORD_MEM3BLT))
#define OE2_TEXTOUT_ORDER     (HIWORD(ORD_TEXTOUT))
#define OE2_EXTTEXTOUT_ORDER  (HIWORD(ORD_EXTTEXTOUT))
// 0x07 was FastFrame, which is no longer supported.
#define OE2_RECTANGLE_ORDER   0x08
#define OE2_LINETO_ORDER      0x09
#define OE2_OPAQUERECT_ORDER  (HIWORD(ORD_OPAQUERECT))
#define OE2_SAVEBITMAP_ORDER  (HIWORD(ORD_SAVEBITMAP))
#define OE2_DESKSCROLL_ORDER  0x0c
#define OE2_MEMBLT_R2_ORDER   (HIWORD(ORD_MEMBLT_R2))
#define OE2_MEM3BLT_R2_ORDER  (HIWORD(ORD_MEM3BLT_R2))
#define OE2_POLYGON_ORDER     (HIWORD(ORD_POLYGON))
#define OE2_PIE_ORDER         (HIWORD(ORD_PIE))
#define OE2_ELLIPSE_ORDER     (HIWORD(ORD_ELLIPSE))
#define OE2_ARC_ORDER         (HIWORD(ORD_ARC))
#define OE2_CHORD_ORDER       (HIWORD(ORD_CHORD))
#define OE2_POLYBEZIER_ORDER  (HIWORD(ORD_POLYBEZIER))
#define OE2_ROUNDRECT_ORDER   (HIWORD(ORD_ROUNDRECT))
#define OE2_UNKNOWN_ORDER     0xFF


//
// #defines used to extract fields from a pointer to one of the text orders
//
#define TEXTFIELD(order)   ((TEXTOUT_ORDER*)(order->abOrderData))
#define EXTTEXTFIELD(order)   ((EXTTEXTOUT_ORDER*)(order->abOrderData))

//
// Number of order types.
//
#define OE2_NUM_TYPES  22

//
// Constants defining the number of changeable fields in an ORDER
// (including the "type" field which is always a word at the beginning of
// each order)
//
#define    OE2_NUM_DSTBLT_FIELDS       6
#define    OE2_NUM_PATBLT_FIELDS       13
#define    OE2_NUM_SCRBLT_FIELDS       8
#define    OE2_NUM_MEMBLT_FIELDS       9
#define    OE2_NUM_MEM3BLT_FIELDS      16
#define    OE2_NUM_TEXTOUT_FIELDS      15
#define    OE2_NUM_EXTTEXTOUT_FIELDS   22
#define    OE2_NUM_RECTANGLE_FIELDS    17
#define    OE2_NUM_LINETO_FIELDS       11
#define    OE2_NUM_OPAQUERECT_FIELDS   6
#define    OE2_NUM_SAVEBITMAP_FIELDS   7
#define    OE2_NUM_DESKSCROLL_FIELDS   3
#define    OE2_NUM_MEMBLT_R2_FIELDS    10
#define    OE2_NUM_MEM3BLT_R2_FIELDS   17
#define    OE2_NUM_POLYGON_FIELDS      15
#define    OE2_NUM_PIE_FIELDS          22
#define    OE2_NUM_ELLIPSE_FIELDS      17
#define    OE2_NUM_ARC_FIELDS          16
#define    OE2_NUM_CHORD_FIELDS        22
#define    OE2_NUM_POLYBEZIER_FIELDS   9
#define    OE2_NUM_ROUNDRECT_FIELDS    19


//
// ControlFlags:
//
// Information about how the order is encoded.  (See OE2_CF_XXX flags
// description).
//
// EncodedOrder:
//
// Contains N bytes of flags followed by an array of bytes containing the
// fields which have changed since this order was last encoded.  (If there
// are M fields in the order then N is M/8).  The position of each bit set
// in the flags gives the relative position of the entry for a field in the
// encoding table (if the first bit is set, then the entry is the first one
// in the encoding table etc.)
//
//
typedef struct tagDCEO2ORDER
{
    BYTE     ControlFlags;
    BYTE     EncodedOrder[1];
}
DCEO2ORDER;
typedef DCEO2ORDER FAR * PDCEO2ORDER;



//
// FLAGS USED INTERNALLY BY OE2
//
//  The encoded order (DCEO2ORDER) Flags field contains information
//  about which fields in the ORDER HEADER need updating
//  These control bits are the same for all orders and have the following
//  values:
//
#define OE2_CF_STANDARD_ENC     0x01U // standard encoding follows...
#define OE2_CF_UNENCODED        0x02U // not encoded
#define OE2_CF_BOUNDS           0x04U // bounding (clip) rectangle supplied
#define OE2_CF_TYPE_CHANGE      0x08U // type of order different from previous
#define OE2_CF_DELTACOORDS      0x10U // coords are TSHR_INT8 deltas from previous
#define OE2_CF_RESERVED1        0x20U //
#define OE2_CF_RESERVED2        0x40U //
#define OE2_CF_RESERVED3        0x80U //


//
// Flags use by OE2EncodeBounds and OE2DecodeBounds to indicate how the
// four coordinates in the bounding rectangle were encoded relative the the
// previous bounding rectangle.  The encoding used is a byte of flags
// followed by a variable number of 16bit coordinate values and 8bit delta
// coordinate values (which may be interleaved).  See functions for more
// information.
//
#define OE2_BCF_LEFT            0x01
#define OE2_BCF_TOP             0x02
#define OE2_BCF_RIGHT           0x04
#define OE2_BCF_BOTTOM          0x08
#define OE2_BCF_DELTA_LEFT      0x10
#define OE2_BCF_DELTA_TOP       0x20
#define OE2_BCF_DELTA_RIGHT     0x40
#define OE2_BCF_DELTA_BOTTOM    0x80

//
// OE2ETFIELD entry flag types.
//
#define OE2_ETF_FIXED           0x01
#define OE2_ETF_VARIABLE        0x02
#define OE2_ETF_COORDINATES     0x04
#define OE2_ETF_DATA            0x08

//
// Define the maximum sizes of fields within encoded orders.
//
#define  OE2_CONTROL_FLAGS_FIELD_SIZE       1
#define  OE2_TYPE_FIELD_SIZE                1
#define  OE2_MAX_FIELD_FLAG_BYTES           4
#define  OE2_MAX_ADDITIONAL_BOUNDS_BYTES    1




//////////////////////////////////////////
//
// T.SHARE PACKETS, FLOW CONTROL
//
//////////////////////////////////////////

//
// Maximum size of application packets (bytes).
// NOTE:
// Packet size can not just change.  There are no caps for it currently.
// Moreover, even though theoretically the field size is a WORD, flow
// control uses the high bit to determine flow packets.
//


//
// HEADER in front of TSHR_FLO_CONTROL/S20PACKETs
//

typedef struct tagTSHR_NET_PKT_HEADER
{
    TSHR_UINT16         pktLength;
}
TSHR_NET_PKT_HEADER;
typedef TSHR_NET_PKT_HEADER * PTSHR_NET_PKT_HEADER;


//
// Packet types:                                                           
// S20 packets have pktLength <  TSHR_PKT_FLOW            
// FLO packets have pktLength == TSHR_PKT_FLOW
//
#define TSHR_PKT_FLOW                                 0x8000


// WE'RE STUCK WITH THIS OUTGOING VALUE BECAUSE OF FLOW CONTROL!  IT ASSUMES
// PACKETS of size > MG_PKT_FLOW are flow control packets.  Back level dudes
// are hosted because of it...

#define TSHR_MAX_SEND_PKT         32000



typedef struct TSHR_FLO_CONTROL
{
    TSHR_UINT16             packetType;
    TSHR_UINT8              stream;
    TSHR_UINT8              pingPongID;
    TSHR_UINT16             userID;
}
TSHR_FLO_CONTROL;
typedef TSHR_FLO_CONTROL * PTSHR_FLO_CONTROL;


//
// TSHR_FLO_CONTROL packetType values
//
#define PACKET_TYPE_NOPING   0x0040
#define PACKET_TYPE_PING     0x0041
#define PACKET_TYPE_PONG     0x0042
#define PACKET_TYPE_PANG     0x0043




//////////////////////////////////////////
//
// T.SHARE CONTROL PACKETS
//
//////////////////////////////////////////

//
// CORRELATORS
//
// Most S20 messsages contain a correlator field.  This field is used
// to identify which share the message belongs to and is used to
// resolve races at share start up and discard stale messages received.
//
// A correlator is a 32 bit number which contains two parts.  The first
// 16 bits (the low word in Intel format) contains the user ID of the
// party which created the share.  The second 16 bits contains a count
// supplied by the party which created the share (ie the first share
// they create is 1 the second 2 etc).  This should ensure unique
// correlators for every share created for a long enough period to
// ensure no stale data is left.
//
// A new correlator is always present on a create message.  All
// respond, delete and leave messages must contain the correct
// correlator for the share.  A join message does not contain a
// correlator.  A party which issues a join message will find out the
// share's correlator on the first respond message they receive.
//
// Respond messages also contain the user ID of the party which sent
// out the original create or join to which they are responding.  There
// is one exception when a `sweep-up' respond is sent which contains
// zero in the originator field.  This respond is sent by a party which
// is joining a share as soon as they receive the first response (and
// therefore know the share correlator).  This sweep-up respond handles
// simultaneous joiners where a party was joining when it too received
// a join message.  When this happens the party ignores the join and
// will later receive a sweep-up respond message which they will
// process.
//


typedef struct tagS20PACKETHEADER
{
    TSHR_UINT16     packetType;
    TSHR_UINT16     user;
}
S20PACKETHEADER;
typedef S20PACKETHEADER * PS20PACKETHEADER;


//
// S20PACKETHEADER packetType values
//
// A single bit means that this version will only interoperate
// with itself.  More than one bit indicates cross version
// interoperability.
//
// IN NM 4.0, GET RID OF S20_2X_VERSION SUPPORT!
//
#define S20_PACKET_TYPE_MASK    0x000F
#define S20_2X_VERSION          0x0010
#define S20_30_VERSION          0x0020

#define S20_CURRENT_VERSION     S20_30_VERSION
#define S20_ALL_VERSIONS        (S20_2X_VERSION | S20_30_VERSION)

#define S20_CREATE              1
#define S20_JOIN                2
#define S20_RESPOND             3
#define S20_DELETE              4
#define S20_LEAVE               5
#define S20_END                 6
#define S20_DATA                7
#define S20_COLLISION           8



//
// To create the share
//
typedef struct tagS20CREATEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20CREATEPACKET;
typedef S20CREATEPACKET * PS20CREATEPACKET;



//
// To join a share created by somebody else
//
typedef struct tagS20JOINPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20JOINPACKET;
typedef S20JOINPACKET * PS20JOINPACKET;




//
// To respond to a create packet
//
typedef struct tagS20RESPONDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     originator;
    TSHR_UINT16     lenName;
    TSHR_UINT16     lenCaps;
    TSHR_UINT8      data[1];         // Name & Caps
}
S20RESPONDPACKET;
typedef S20RESPONDPACKET * PS20RESPONDPACKET;




//
// To remove a person from a share (if the creator can't join the person in)
//
typedef struct tagS20DELETEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     target;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20DELETEPACKET;
typedef S20DELETEPACKET * PS20DELETEPACKET;



//
// To leave a share yourself
//
typedef struct tagS20LEAVEPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
}
S20LEAVEPACKET;
typedef S20LEAVEPACKET * PS20LEAVEPACKET;




//
// To end a share you created
//
typedef struct tagS20ENDPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT16     lenName;         // OBSOLETE - no name/caps at end
    TSHR_UINT8      data[1];
}
S20ENDPACKET;
typedef S20ENDPACKET * PS20ENDPACKET;


//
// To tell somebody creating a share that one already exists
//
typedef struct tagS20COLLISIONPACKET
{
    S20PACKETHEADER     header;
    TSHR_UINT32         correlator;
}
S20COLLISIONPACKET;
typedef S20COLLISIONPACKET * PS20COLLISIONPACKET;





/////////////////////////////////
//
// T.SHARE DATA PACKETS
//
/////////////////////////////////


//
// Data sent when in share (this structure is followed by the different
// packets described below)
//
typedef struct tagDATAPACKETHEADER
{
    TSHR_UINT8      dataType;             // DT_ identifier
    TSHR_UINT8      compressionType;
    TSHR_UINT16     compressedLength;
}
DATAPACKETHEADER;
typedef DATAPACKETHEADER * PDATAPACKETHEADER;


//
// DATAPACKETHEADER dataType values
//

#define DT_UP                   0x02
#define DT_UNUSED_USR_FH_10     0x09    // OBSOLETE
#define DT_UNUSED_USR_FH_11     0x0A    // OBSOLETE
#define DT_FH                   0x0B

#define DT_CA                   0x14    // OLD (2.x)
#define DT_CA30                 0x15    // NEW (3.0)
#define DT_HET30                0x16    // NEW (3.0)
#define DT_AWC                  0x17
#define DT_SWL                  0x18
#define DT_HET                  0x19    // OLD (2.x)
#define DT_UNUSED_DS            0x1A    // OBSOLETE
#define DT_CM                   0x1B
#define DT_IM                   0x1C    
#define DT_UNUSED_HCA           0x1D    // OBSOLETE
#define DT_UNUSED_SC            0x1E    // OBSOLETE
#define DT_SNI                  0x1F
#define DT_CPC                  0x20


//
// DATAPACKETHEADER compressionType values
//
// There are two formats for this field.
//
// If all nodes participating in the share session have the capability
// genCompressionLevel >= 1 then the compressionType is a one of the
// following 8bit integers.
//
// Otherwise the the packet is compressed with GCT_PKZIP if the top bit is
// set and the packet is not compressed if it is not set.  The remaining
// bits are undefined (and will NOT be all zero)
//
//
// Note: Each of these values has a GCT_... value associated with it.
//       These values indicate which bit of the GCT_... values this
//       compression type represents.  Eg. a value of 5 here pairs with the
//       value 0x0010 (ie bit 5 set)
//
#define     CT_NONE                 0
#define     CT_PKZIP                1
#define     CT_PERSIST_PKZIP        2
#define     CT_OLD_COMPRESSED       0x80




typedef struct tagS20DATAPACKET
{
    S20PACKETHEADER header;

    TSHR_UINT32     correlator;
    TSHR_UINT8      ackID;                  // OBSOLETE
    TSHR_UINT8      stream;
    TSHR_UINT16     dataLength;

    DATAPACKETHEADER    data;
    // data specific to DT_ type follows here
}
S20DATAPACKET;
typedef S20DATAPACKET * PS20DATAPACKET;


//
// S20DATAPACKET stream values
//
//
// The streams and priotities used by AppSharing
//
#define PROT_STR_INVALID                0          
#define PROT_STR_UPDATES                1       // SNI_STREAM_LOW
#define PROT_STR_MISC                   2          
#define PROT_STR_UNUSED                 3       // NOT USED!    
#define PROT_STR_INPUT                  4
#define NUM_PROT_STR                    5





//
// DT_AWC
// Active Window packets
//

typedef struct tagAWCPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         token;          // OBSOLETE
    UINT_PTR            data1;
    UINT_PTR            data2;
}
AWCPACKET;
typedef AWCPACKET *PAWCPACKET;




//
// AWCPACKET msg values
//
#define AWC_MSG_INVALID                         0x0000
#define AWC_MSG_ACTIVE_CHANGE_LOCAL             0x0001
#define AWC_MSG_ACTIVE_CHANGE_SHARED            0x0002
#define AWC_MSG_ACTIVE_CHANGE_INVISIBLE         0x0003  
#define AWC_MSG_ACTIVE_CHANGE_CAPTURED          0x0004  // OBSOLETE
#define AWC_MSG_ACTIVATE_WINDOW                 0x8001
#define AWC_MSG_CLOSE_WINDOW                    0x8002  // OBSOLETE
#define AWC_MSG_RESTORE_WINDOW                  0x8003
#define AWC_MSG_TASKBAR_RBUTTON                 0x8004  // OBSOLETE
#define AWC_MSG_SAS                             0x8005
#define AWC_MSG_SYSCOMMAND_HELPKEYS             0x8011  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPINDEX            0x8012  // OBSOLETE
#define AWC_MSG_SYSCOMMAND_HELPEXTENDED         0x8013  // OBSOLETE



//
// DT_CA
// OLD Control Arbitration packets
//

typedef struct tagCAPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         data1;
    UINT_PTR            data2;
}
CAPACKET;
typedef CAPACKET *PCAPACKET;





//
// CAPACKET msg values, 2.x
// These are all broadcasted, control is global
//
#define CA_MSG_NOTIFY_STATE         0       // NEW FOR NM 3.0
#define CA_OLDMSG_REQUEST_CONTROL   1       // NM 2.x
#define CA_OLDMSG_GRANTED_CONTROL   2       // NM 2.x
#define CA_OLDMSG_DETACH            3       // NM 2.x
#define CA_OLDMSG_COOPERATE         4       // NM 2.x


//
// Notification (broadcast) packet
//
typedef struct tagCANOTPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         state;
    UINT_PTR            controllerID;
}
CANOTPACKET;
typedef CANOTPACKET * PCANOTPACKET;

//
// CA_MSG_NOTIFY_STATE
//  state               - controllable or not
//  controllerID        - controller net ID or 0 if nobody
//

// state flags:
#define CASTATE_ALLOWCONTROL        0x0001




//
// CA_OLDMSG_REQUEST_CONTROL
// Broadcasted to request taking of global control
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_GRANTED_CONTROL
// Broadcasted by node(s) who think they own the control token, when they
// grant the control token to node who asked for it via REQUEST.
//      data1   -   netID of person given control
//      data2   -   control token generation
//

//
// CA_OLDMSG_DETACH
// Broadcasted when node stops collaborating
//      data1   -   unused
//      data2   -   unused
//

//
// CA_OLDMSG_COOPERATE
// Broadcasted when node starts collaborating
//      data1   -   unused
//      data2   -   unused
//




//
// DT_CA30
// NEW Control packets
//


//
// These are PRIVATE SEND packets, on PROT_STR_INPUT, from one node to another.
// They go out in order, and are queued if not able to send for retry later.
//

//
// Common header for CA30 packets.
//
typedef struct tagCA30PACKETHEADER
{
    S20DATAPACKET       header;
    TSHR_UINT32         msg;
}
CA30PACKETHEADER;
typedef CA30PACKETHEADER * PCA30PACKETHEADER;


//
// CA30PACKETHEADER msg values
//
#define CA_REQUEST_TAKECONTROL          1       // From viewer to host
#define CA_REPLY_REQUEST_TAKECONTROL    2       // From host to viewer
#define CA_REQUEST_GIVECONTROL          3       // From host to viewer
#define CA_REPLY_REQUEST_GIVECONTROL    4       // From viewer to host
#define CA_PREFER_PASSCONTROL           5       // From controller to host

#define CA_INFORM_RELEASEDCONTROL       0x8001  // From controller to host
#define CA_INFORM_REVOKEDCONTROL        0x8002  // From host to controller
#define CA_INFORM_PAUSEDCONTROL         0x8003  // From host to controller
#define CA_INFORM_UNPAUSEDCONTROL       0x8004  // From host to controller


//
// REPLY packet result values
//
#define CARESULT_CONFIRMED                      0
#define CARESULT_DENIED                         1
#define CARESULT_DENIED_BUSY                    2
#define CARESULT_DENIED_USER                    3
#define CARESULT_DENIED_WRONGSTATE              4
#define CARESULT_DENIED_TIMEDOUT                5



//
// ALL packets also have a CA30PACKETHEADER in front of them.
//


//
// CA_REQUEST_TAKECONTROL
//  Sender      is viewer
//  Receiver    is host
//      viewerControlID -   unique viewer request ID
//
// Receiver should reply with CA_REPLY_REQUEST_TAKECONTROL
// Sender should cancel with CA_INFORM_RELEASEDCONTROL
//
typedef struct tagCA_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
}
CA_RTC_PACKET;
typedef CA_RTC_PACKET * PCA_RTC_PACKET;



//
// CA_REPLY_REQUEST_TAKECONTROL
//  Sender      is host
//  Receiver    is viewer, who sent original TAKECONTROL request
//      viewerControlID -   viewer request ID from TAKECONTROL request
//      hostControlID   -   unique host request ID
//      result          -   CARESULT value, success or failure
//
typedef struct tagCA_REPLY_RTC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         result;
    TSHR_UINT32         hostControlID;
}
CA_REPLY_RTC_PACKET;
typedef CA_REPLY_RTC_PACKET * PCA_REPLY_RTC_PACKET;




//
// CA_PREFER_PASSCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   controller request ID from take operation
//      hostControlID   -   host request ID from reply to take operation.
//      mcsPassTo       -   MCS ID of viewer to pass to
//
// No reply is required
// Sender is not in control when this gets out
// Receiver can then, if he chooses, turn around and ask 3rd party to control
//
typedef struct tagCA_PPC_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
    UINT_PTR            mcsPassTo;
}
CA_PPC_PACKET;
typedef CA_PPC_PACKET * PCA_PPC_PACKET;




//
// CA_REQUEST_GIVECONTROL
//  Sender      is host
//  Receiver    is viewer
//      hostControlID   -   unique host request ID
//      mcsPassFrom     -   person passing control, zero if none
//
// Receiver should reply with CA_REPLY_REQUEST_GIVECONTROL
// Sender should cancel with CA_INFORM_REVOKEDCONTROL
//
typedef struct tagCA_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    UINT_PTR            mcsPassFrom;
}
CA_RGC_PACKET;
typedef CA_RGC_PACKET * PCA_RGC_PACKET;



//
// CA_REPLY_REQUEST_GIVECONTROL
//  Sender      is viewer
//  Receiver    is host, who sent original TAKECONTROL invite
//      hostControlID   -   host request ID from TAKECONTROL invite
//      mcsPassFrom     -   person passing us control, 0 if none
//      result          -   CARESULT value, success or failure
//      viewerControlID -   unique viewer request ID
//
typedef struct tagCA_REPLY_RGC_PACKET
{
    TSHR_UINT32         hostControlID;
    TSHR_UINT32         mcsPassFrom;
    TSHR_UINT32         result;
    TSHR_UINT32         viewerControlID;
}
CA_REPLY_RGC_PACKET;
typedef CA_REPLY_RGC_PACKET * PCA_REPLY_RGC_PACKET;




//
// INFORM packets
// These are sent to cancel a REQUEST packet, or after the control
// operation has completed, to terminate it.  If cancelling, then the 
// other party's controlID will be zero since we won't have heard back from
// them yet to get it.
//
typedef struct tagCA_INFORM_PACKET
{
    TSHR_UINT32         viewerControlID;
    TSHR_UINT32         hostControlID;
}
CA_INFORM_PACKET;
typedef CA_INFORM_PACKET * PCA_INFORM_PACKET;


//
// CA_INFORM_RELEASEDCONTROL
//  Sender      is controller
//  Receiver    is host
//      viewerControlID -   viewer request ID from 
//          REQUEST_TAKECONTROL 
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If viewer is cancelling REQUEST_TAKECONTROL then hostControlID is 0
//

//
// CA_INFORM_REVOKEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//
// If host is cancelling REQUEST_GIVECONTROL then viewerControlID is 0
//

//
// CA_INFORM_PAUSEDCONTROL
// CA_INFORM_UNPAUSEDCONTROL
//  Sender      is host
//  Receiver    is controller
//      viewerControlID -   viewer request ID from
//          REQUEST_TAKECONTROL
//          REPLY_REQUEST_GIVECONTROL
//      hostControlID   -   host request ID from
//          REPLY_REQUEST_TAKECONTROL
//          REQUEST_GIVECONTROL
//



//
// DT_CM
// Cursor shape/position packets
//      There are three types of shape packets: mono bitmaps, color cached,
//      constant IDs
//


typedef struct tagCMPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         type;
    TSHR_UINT16         flags;
}
CMPACKETHEADER;
typedef CMPACKETHEADER * PCMPACKETHEADER;




//
// CMPACKETHEADER type values
//
#define CM_CURSOR_ID                        1
#define CM_CURSOR_MONO_BITMAP               2
#define CM_CURSOR_MOVE                      3
#define CM_CURSOR_BITMAP_COMPRESSED         4   // OBSOLETE
#define CM_CURSOR_COLORTABLE                5   // OBSOLETE
#define CM_CURSOR_COLOR_BITMAP              6
#define CM_CURSOR_COLOR_CACHE               7


//
// CMPACKETHEADER sync flag values
//
#define CM_SYNC_CURSORPOS                   0x0001
    //
    // This will be set if, when we played back input, the cursor
    // didn't end up where it was asked to go.  This could happen if an
    // app clips the cursor or snaps it.  As such, we mark this field
    // when we send a notification of our current pos so that the controller
    // knows to move his cursor to be in line with ours.
    //



//
// type CM_CURSOR_ID
//
// This packet is sent when the cursor has changed and it is now one of
// the system cursors.
//
typedef struct tagCMPACKETID
{
    CMPACKETHEADER      header;

    TSHR_UINT32         idc;
}
CMPACKETID;
typedef CMPACKETID * PCMPACKETID;




//
// CMPACKETID idc values
//
#define CM_IDC_NULL         0
#define CM_IDC_ARROW        32512


//
// type CM_CURSOR_MONO_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined mono cursor.
//
// The cursor size cannot be greater than 32x32.
typedef struct tagCMPACKETMONOBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     width;
    TSHR_UINT16     height;
    TSHR_UINT16     cbBits;
    BYTE            aBits[1];
}
CMPACKETMONOBITMAP;
typedef CMPACKETMONOBITMAP * PCMPACKETMONOBITMAP;





//
// type CM_CURSOR_COLOR_BITMAP
//
// This packet is sent when the cursor has changed and it is now an
// application defined color cursor.
//
typedef struct tagCMPACKETCOLORBITMAP
{
    CMPACKETHEADER  header;

    TSHR_UINT16     cacheIndex;
    TSHR_UINT16     xHotSpot;
    TSHR_UINT16     yHotSpot;
    TSHR_UINT16     cxWidth;
    TSHR_UINT16     cyHeight;
    TSHR_UINT16     cbANDMask;
    TSHR_UINT16     cbXORBitmap;
    BYTE            aBits[1];
}
CMPACKETCOLORBITMAP;
typedef CMPACKETCOLORBITMAP * PCMPACKETCOLORBITMAP;





//
// type CM_CURSOR_COLOR_CACHE
//
// This packet is sent out when the cursor changes and the new
// definition resides in the cache.
//
//
typedef struct tagCMPACKETCOLORCACHE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         cacheIndex;
}
CMPACKETCOLORCACHE;
typedef CMPACKETCOLORCACHE * PCMPACKETCOLORCACHE;






//
// type CM_CURSOR_MOVE
//
// This packet is sent whenever the CM is told that the application has
// moved the cursor.
//
typedef struct tagCMPACKETMOVE
{
    CMPACKETHEADER      header;

    TSHR_UINT16         xPos;
    TSHR_UINT16         yPos;
}
CMPACKETMOVE;
typedef CMPACKETMOVE * PCMPACKETMOVE;





//
// DT_CPC
// Capabilities change packet
//
typedef struct tagCPCPACKET
{
    S20DATAPACKET       header;

    PROTCAPS            caps;
}
CPCPACKET;
typedef CPCPACKET * PCPCPACKET;




//
// DT_FH
// Supported local font list packet
//



//
// The NETWORKFONT is the font description which is sent across the network
// when negotiating font support.
//

//
// Flags for the nfFontFlags field
//
#define NF_FIXED_PITCH      0x0001
#define NF_FIXED_SIZE       0x0002
#define NF_ITALIC           0x0004
#define NF_UNDERLINE        0x0008
#define NF_STRIKEOUT        0x0010

#define NF_OEM_CHARSET      0x0020
#define NF_RESERVED1        0x0040      // Reserved for future BiDi support
#define NF_TRUE_TYPE        0x0080
#define NF_BASELINE         0x0100

#define NF_PRE_R11      (NF_FIXED_PITCH | NF_FIXED_SIZE | \
                         NF_ITALIC | NF_UNDERLINE | NF_STRIKEOUT)

//
// Mask for local-only font flags - that must not flow on the wire.
//
#define NF_LOCAL            (NF_OEM_CHARSET | NF_TRUE_TYPE)

//
// A special value for the signature field which means no signature.
//
#define NF_NO_SIGNATURE 0

//
// The FH_FACESIZE is equal to the Windows specific constant LF_FACESIZE.
//
#define FH_FACESIZE 32


//
// SFRFONT
// Let us define these things more fully...
// nfFaceName   font face name (not family name, not style)
// nfFontFlags  see above
// nfAveWidth   in Windows set to tmAveCharWidth
// nfAveHeight  NOT THE AVERAGE HEIGHT but the height of a character with
//              full ascender (but no accent) AND descender.  There is no
//              such character but never mind.
//              Windows: set to tmHeight - tmInternalLeading
// nfAspectX
// nfAspectY
// nfSignature: in R11 set to an obscure checksum
//              in R20 set to two one-byte values and one two byte value.
//              Based on the widths of the actual text for fixed width
//              fonts and on 16x16 scalable fonts.  .
//              (The 16x16 is effectively part of the protocol)
//              nfSigFats   the sum of the widths (in pels) of the chars
//                          0-9,@-Z,$,%,&. divided by two: the fat chars
//              nfSigThins  the sum of the widths (in pels) of the chars
//                          0x20->0x7F EXCLUDING those summed in nfSigFats.
//                          Again - divided by two.  The thin chars.
//              nfSigSymbol The sum of the widths (in pels) of the chars
//                          x80->xFF.
// nfCodePage:  new use in R20: code page (not charset)
//              This field is set to 0 for ANSI (meaning WINDOWS ANSI)
//                         is set to 255 for OEM (meaning Windows OEM font)
//                         is set to the defined codepage if known
//                         is set to 0xFFFF when not known.
//
// nfMaxAscent:     The height of a character with no descender, plus any
//              internal leading.
//              = tmAscent in windows
//              For fixed size fonts we send the values you would expect.
//              For scalable fonts, we get the tmAscent (or equivalent) for
//              a very large font (say height-by-width of 100x100).  The
//              size selected must be the same on ALL platforms so is
//              effectively part of the protocol - hence is defined in
//              this file as NF_MAXASCENT_HEIGHT and .._WIDTH.
//
//
#define NF_CP_WIN_ANSI      0
#define NF_CP_WIN_SYMBOL    2
#define NF_CP_WIN_OEM       255
#define NF_CP_UNKNOWN       0xFFFF

//
// Define the start and end point of the ASCII sub-range
//
#define NF_ASCII_FIRST       0x20
#define NF_ASCII_LAST        0x7F
#define NF_ASCII_ZERO        0x30
#define NF_ASCII_Z           0x5B
#define NF_ASCII_DOLLAR      0x24
#define NF_ASCII_PERCENT     0x25
#define NF_ASCII_AMPERSAND   0x26


//
// The height/width of the font to ask for when getting the metrics info
// for scalable fonts.
// These (in particular the height) are CHARACTER SIZES not CELL sizes.
// This is because the font protocol exchanges character sizes not cell
// sizes.  (The char height is the cell height minus any internal leading.)
//
#define NF_METRICS_HEIGHT 100
#define NF_METRICS_WIDTH  100

//
// The wire-format font information structure
//
typedef struct tagNETWORKFONT
{
    TSHR_CHAR      nfFaceName[FH_FACESIZE];
    TSHR_UINT16    nfFontFlags;
    TSHR_UINT16    nfAveWidth;
    TSHR_UINT16    nfAveHeight;
    TSHR_UINT16    nfAspectX;          // New field for r1.1
    TSHR_UINT16    nfAspectY;          // New field for r1.1
    TSHR_UINT8     nfSigFats;          // New field for r2.0
    TSHR_UINT8     nfSigThins;         // New field for r2.0
    TSHR_UINT16    nfSigSymbol;        // New field for r2.0
    TSHR_UINT16    nfCodePage;         // New field for R2.0
    TSHR_UINT16    nfMaxAscent;        // New field for R2.0
}
NETWORKFONT;
typedef NETWORKFONT * LPNETWORKFONT;


typedef struct tagFHPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         cFonts;
    TSHR_UINT16         cbFontSize;
    NETWORKFONT         aFonts[1];
}
FHPACKET;
typedef FHPACKET * PFHPACKET;




//
// DT_HET
// Hosting state (nothing, apps, desktop)
//

typedef struct tagHETPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;
    TSHR_UINT16         hostState;  // ONLY ONE VALUE FOR MSG; IF MORE MAKE MORE STRUCTS
}
HETPACKET;
typedef HETPACKET * PHETPACKET;



//
// HETPACKET msg values
//
#define HET_MSG_NUMHOSTED           1


//
// HETPACKET hostState values
//
#define HET_NOTHOSTING              0
#define HET_APPSSHARED              0x0001      // Packet only
#define HET_DESKTOPSHARED           0xFFFF      // Packet and per-person data



//
// DT_IM
// Input events
//

//
// This is the base keyboard event (IM_TYPE_ASCII, IM_TYPE_VK1,
// IM_TYPE_VK2).  Future keyboard events may append extra fields.  The
// flags defined in the base keyboard event must be set to reasonable
// values in all future keyboard events.
//
// flags:
//
//  bit 0-6: unused (available for future keyboard events)
//  bit 7: Secondary key (unused).
//  bit 8: SET - extended key, RESET - normal key
//  bit 9-11: unused (available for future keyboard events)
//  bit 12: SET - when replayed this key stroke should NOT cause
// anything to happen
//  bit 13: reserved - this flag is not part of the protocol and is
// never sent.  It is used internally by IEM when processing received
// packets.
//  bit 14: SET - previously down, RESET previously up
//  bit 15: SET - key release, RESET key press
//
//
typedef struct tagIMKEYBOARD
{
    TSHR_UINT16     flags;
    TSHR_UINT16     keyCode;
}
IMKEYBOARD;
typedef IMKEYBOARD * PIMKEYBOARD;


//
// IMKEYBOARD flags values
//
#define IM_FLAG_KEYBOARD_RIGHT              0x0001
#define IM_FLAG_KEYBOARD_UPDATESTATE        0x0002  // not sent; just internal
#define IM_FLAG_KEYBOARD_SECONDARY          0x0080
#define IM_FLAG_KEYBOARD_EXTENDED           0x0100
#define IM_FLAG_KEYBOARD_QUIET              0x1000
#define IM_FLAG_KEYBOARD_ALT_DOWN           0x2000
#define IM_FLAG_KEYBOARD_DOWN               0x4000
#define IM_FLAG_KEYBOARD_RELEASE            0x8000

//
// This is the base mouse event (IM_TYPE_3BUTTON).  Future mouse events
// may append extra fields but they must include all the fields in the
// base mouse event and these must be set to reasonable values.
//
// flags:
//
//  bit 0-8: ignored by old systems
//           new systems: signed wheel rotation amount if bit 9 set
//  bit 9:   ignored by old systems
//           new systems: SET - wheel rotate, RESET - other event
//                          (takes precedent over bit 11 - mouse move)
//
//  bit 10:  SET - double click, RESET - single click
//  bit 11:  SET - mouse move (ignore bits 9,10, 12-15), RESET - mouse
//           action
//  bit 12:  SET - button 1 (left button)
//  bit 13:  SET - button 2 (right button)
//  bit 14:  SET - button 3 (middle button)
//  bit 15:  SET - button press, RESET - button release
//
//
typedef struct tagIMMOUSE
{
    TSHR_UINT16    flags;
    TSHR_INT16     x;
    TSHR_INT16     y;
}
IMMOUSE;
typedef IMMOUSE * PIMMOUSE;


//
// IMMOUSE flags values
//
#define IM_FLAG_MOUSE_WHEEL             0x0200
#define IM_FLAG_MOUSE_DIRECTION         0x0100
#define IM_FLAG_MOUSE_ROTATION_MASK     0x01FF
#define IM_FLAG_MOUSE_DOUBLE            0x0400
#define IM_FLAG_MOUSE_MOVE              0x0800
#define IM_FLAG_MOUSE_BUTTON1           0x1000
#define IM_FLAG_MOUSE_BUTTON2           0x2000
#define IM_FLAG_MOUSE_BUTTON3           0x4000
#define IM_FLAG_MOUSE_DOWN              0x8000


typedef struct tagIMEVENT
{
    TSHR_UINT32     timeMS;
    TSHR_UINT16     type;
    union
    {
        IMKEYBOARD      keyboard;
        IMMOUSE         mouse;
    }
    data;
}
IMEVENT;
typedef IMEVENT *     PIMEVENT;
typedef IMEVENT FAR * LPIMEVENT;


//
// IMEVENT type values
//
#define IM_TYPE_SYNC            0x0000          // OBSOLETE 2.X
#define IM_TYPE_ASCII           0x0001
#define IM_TYPE_VK1             0x0002
#define IM_TYPE_VK2             0x0003
#define IM_TYPE_3BUTTON         0x8001


typedef struct tagIMPACKET
{
    S20DATAPACKET   header;

    TSHR_UINT16     numEvents;
    TSHR_UINT16     padding;
    IMEVENT         aEvents[1];
}
IMPACKET;
typedef IMPACKET *     PIMPACKET;
typedef IMPACKET FAR * LPIMPACKET;




//
// DT_UP
// Update packet (orders, screen data, palettes)
//


typedef struct tagUPPACKETHEADER
{
    S20DATAPACKET       header;

    TSHR_UINT16         updateType;
    TSHR_UINT16         padding;
}
UPPACKETHEADER;
typedef UPPACKETHEADER * PUPPACKETHEADER;




//
// UPPACKETHEADER updateType values
//
#define UPD_ORDERS       0
#define UPD_SCREEN_DATA  1
#define UPD_PALETTE      2
#define UPD_SYNC         3


//
// UPD_ORDERS
//
typedef struct tagORDPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT16         cOrders;
    TSHR_UINT16         sendBPP;
    BYTE                data[1];
}
ORDPACKET;
typedef ORDPACKET * PORDPACKET;




//
// UPD_SCREEN_DATA
//
// Bitmap packet contains bitmap image of window changes made by a shared
// application.  These packets are sent when a screen update occurs that
// can not be sent as an order. The structure contains the following
// fields:
//
//  winID - window handle of the shared window from which the update came
//  position - virtual desktop position of the update
//  realWidth - width of update bitmap
//  realHeight - height of update bitmap
//  format - bits per pel of update bitmap
//  dataSize - size in bytes of following bitmap data
//  firstData - first byte in array of bytes that contains the bitmap
//
// Note that the realWidth is not always the same as the width of the
// update as given by the position field rectangle. This is because a
// number of fixed size cached bitmaps are used for speed when generating
// the update packets. The bitmap data (firstData onwards) should be
// set into a bitmap of realWidth, realHeight dimensions by the receiver
// and then the appropriate portion blted to the desired destination
// determined by the position rectangle. The valid portion of the bitmap
// always starts 0,0 within the bitmap.
//
typedef struct tagSDPACKET
{
    UPPACKETHEADER      header;

    TSHR_RECT16         position;
    TSHR_UINT16         realWidth;
    TSHR_UINT16         realHeight;
    TSHR_UINT16         format;
    TSHR_UINT16         compressed;
    TSHR_UINT16         dataSize;
    BYTE                data[1];
}
SDPACKET;
typedef SDPACKET * PSDPACKET;




//
// UPD_PALETTE
//
// Palette packet.  This is sent before any SDPACKETS to define the
// colors in the bitmap data.  The fields are as follows:
//
//  numColors - the number of colors in the palette
//  firstColor - the first entry in an array of TSHR_COLORs
//
// The TSHR_COLOR structures are 3 bytes long (r,g,b) and are NOT padded.
//
//
typedef struct tagPMPACKET
{
    UPPACKETHEADER      header;

    TSHR_UINT32         numColors;
    TSHR_COLOR          aColors[1];
}
PMPACKET;
typedef PMPACKET * PPMPACKET;



//
// UPD_SYNC
//
typedef struct tagUPSPACKET
{
    UPPACKETHEADER      header;
}
UPSPACKET;
typedef UPSPACKET * PUPSPACKET;




//
// DT_SNI
// Share controller packet
//

typedef struct tagSNIPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         message;
    TSHR_UINT16         destination;
}
SNIPACKET;
typedef SNIPACKET * PSNIPACKET;



//
// SNIPACKET message values
//
#define SNI_MSG_SYNC    1

//
// For a SNI_MSG_SYNC,
// The network ID of the destination (all syncs are broadcast
// and discarded at the destination if they are not for the
// destination).
//




//
// DT_SWL
// Shared window list packet
//

#define SWL_MAX_WINDOW_TITLE_SEND       50
#define SWL_MAX_NONRECT_SIZE            10240

//
// Structures used to define the window structure (Z-order and
// position).  
//
typedef struct tagSWLWINATTRIBUTES
{
    UINT_PTR    winID;
            //
            // The window ID for shared windows - otherwise 0.  Note that
            // this is the window ID on the machine hosting the application
            // even for view frames.
            //
    TSHR_UINT32    extra;
            //
            // Extra information for the window.  The contents depend on
            // the flags.
            //
            // For SWL_FLAG_WINDOW_HOSTED this contains the appID of the
            // application which owns the window.
            //
            // For SWL_FLAG_WINDOW_SHADOW this contains the person ID of
            // the party which is hosting the app
            //
            // For SWL_FLAG_WINDOW_LOCAL this entry is 0.
            //
    TSHR_UINT32    ownerWinID;
            //
            // The window ID of the owner of this window.  Only valid for
            // shared, hosted windows.  NULL is a valid owner ID.
            //
    TSHR_UINT32    flags;
            //
            // Flags describing window
            //
            //  SWL_FLAG_WINDOW_MINIMIZED
            //  SWL_FLAG_WINDOW_TAGGABLE
            //  SWL_FLAG_WINDOW_HOSTED
            //  SWL_FLAG_WINDOW_SHADOW
            //  SWL_FLAG_WINDOW_LOCAL
            //  SWL_FLAG_WINDOW_TOPMOST
            //
            //  SWL_FLAG_WINDOW_TASKBAR - window appears on Win95 task bar
            //  SWL_FLAG_WINDOW_NOTASKBAR - window not on Win95 task bar
            //
            //  (SWL_FLAG_WINDOW_TRANSPARENT - this is not sent but is used
            //  during the creation of the packet)
            //
            #define SWL_FLAG_WINDOW_MINIMIZED    0x00000001
            #define SWL_FLAG_WINDOW_TAGGABLE     0x00000002
            #define SWL_FLAG_WINDOW_HOSTED       0x00000004
            #define SWL_FLAG_WINDOW_LOCAL        0x00000010
            #define SWL_FLAG_WINDOW_TOPMOST      0x00000020

            //
            // New for NM 1.0, non-R11
            //
            #define SWL_FLAG_WINDOW_TASKBAR      0x00010000
            #define SWL_FLAG_WINDOW_NOTASKBAR    0x00020000
            #define SWL_FLAG_WINDOW_TRANSPARENT  0x40000000

            //
            // New for NM 2.0
            //
            #define SWL_FLAG_WINDOW_NONRECTANGLE 0x00040000

            //
            // Obsolete in NM 3.0
            // These were used at some point in backlevel versions.
            // If you reuse these bits, DO A LOT OF INTEROP TESTING.
            //
            #define SWL_FLAG_WINDOW_SHADOW       0x00000008
            #define SWL_FLAG_WINDOW_DESKTOP      0x00080000
            #define SWL_FLAG_WINDOW_REQD         0x80000000

            //
            // NM 3.0 INTERNAL only; not transmitted
            //
            #define SWL_FLAG_INTERNAL_SEEN      0x000001000

            //
            // These are valid to SEND in a packet or PROCESS when RECEIVED
            //
            #define SWL_FLAGS_VALIDPACKET           \
                (SWL_FLAG_WINDOW_MINIMIZED      |   \
                 SWL_FLAG_WINDOW_TAGGABLE       |   \
                 SWL_FLAG_WINDOW_HOSTED         |   \
                 SWL_FLAG_WINDOW_TOPMOST        |   \
                 SWL_FLAG_WINDOW_TASKBAR        |   \
                 SWL_FLAG_WINDOW_NONRECTANGLE   |   \
                 SWL_FLAG_WINDOW_SHADOW)

    TSHR_RECT16    position;
            //
            // The bounding rectangle of the window in inclusive virtual
            // desktop coordinates.
            //
}
SWLWINATTRIBUTES;
typedef SWLWINATTRIBUTES *PSWLWINATTRIBUTES;


//
// The SWL packet consists of an array of SWLWINATTRIBUTES structures,
// followed by some variable length string data (the window titles)
// followed by zero or more, word aligned, additional chunks of data.
//
// The only currently defined chunk is for the non-rectangular window
// data.
//
typedef struct
{
    TSHR_UINT16    size;
            //
            // Total size in bytes of this chunk
            //
    TSHR_UINT16    idChunk;
            //
            // An identifier for the contents of this chunk.
            //
            #define SWL_PACKET_ID_NONRECT   0x524e  // "NR"
}
SWLPACKETCHUNK;
typedef SWLPACKETCHUNK * PSWLPACKETCHUNK;



typedef struct tagSWLPACKET
{
    S20DATAPACKET       header;

    TSHR_UINT16         msg;        // ONLY ONE VALUE FOR MSG; MAKE MORE STRUCTS IF ADDED
    TSHR_UINT16         flags;
    TSHR_UINT16         numWindows;
    TSHR_UINT16         tick;
    TSHR_UINT16         token;
    TSHR_UINT16         reserved;
    SWLWINATTRIBUTES    aWindows[1];

    //
    // The last SWLWINATTRIBUTES structure is followed by the
    // window title data.  This is made up as follows.
    //
    // For each window which is a window from a shared, hosted
    // application (ie winID and appID are non-zero) #either -
    //
    //  (char)0xFF - not a `task window' - give it a NULL title
    //  or -
    //  a null terminated string up to MAX_WINDOW_TITLE_SEND
    // characters
    //
    // The titles appear in the same order as the corresponding
    // windows in the SWLWINSTRUCTURE.
    //
    
    //
    // The last TITLE is followed by the regional data,
    // SWLPACKETCHUNK, if there is any.  One for each NONRECT window in 
    // the list.
    //
}
SWLPACKET;
typedef SWLPACKET *PSWLPACKET;




//
// SWLPACKET msg values
//
#define SWL_MSG_WINSTRUCT   1


//
// SWLPACKET flags values
//
#define SWL_FLAG_STATE_SYNCING      0x0001


#endif // _H_T_SHARE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\ut.h ===
//
// Utilities
//

#ifndef _H_UT
#define _H_UT

#define SIZEOF_ARRAY(ar)            (sizeof(ar)/sizeof((ar)[0]))


//
// Data types stored in the profile information.
//
#define COM_PROFTYPE_STRING     1L
#define COM_PROFTYPE_INT        2L
#define COM_PROFTYPE_BOOL       3L
#define COM_PROFTYPE_UNKNOWN    4L


#define COM_MAX_SUBKEY         256
#define COM_MAX_BOOL_STRING    5



//
//
// TYPEDEFS
//
//


//
// Priorities for UT_RegisterEventProc()
//
// Event procedures are registered with a priority that affects the order
// that the event procedures are called in.
//
// All event procedures of a given priority are called before event
// procedures of a numerically lower priority.
//
// The priority can be any number between 0 and UT_MAX_PRIORITY
//
// The following values have been defined for specific uses:
//  UT_PRIORITY_OBMAN :     Used by OBMAN so its client event procedures
//                            are called before those of the client
//  UT_PRIORITY_APPSHARE    : Used by the DCShare Core to ensure it sees
//                            events before 'Normal' event procs.
//  UT_PRIORITY_NORMAL      : For all cases where the order of callling is
//                            not important.
//  UT_PRIORITY_NETWORK     : Used by the Network Layer to free any
//                            unprocessed network buffers.
//  UT_PRIORITY_LAST        : Used by the Utility Services to get the
//                            default event procedure called last
//
//
typedef enum
{
    UT_PRIORITY_LAST = 0,
    UT_PRIORITY_NETWORK,
    UT_PRIORITY_NORMAL,
    UT_PRIORITY_APPSHARING,
    UT_PRIORITY_OBMAN,
    UT_PRIORITY_MAX
} UT_PRIORITY;
typedef UT_PRIORITY * PUT_PRIORITY;



//
// SYSTEM LIMITS
//

//
// Maximum number of event handlers for each task
//
#define UTEVENT_HANDLERS_MAX            4

//
// Maximum number of exit procedures
//
#define UTEXIT_PROCS_MAX                4


//
// The groupware critsects, identified by constant
//
#define UTLOCK_FIRST        0
typedef enum
{
    UTLOCK_UT = UTLOCK_FIRST,
    UTLOCK_OM,              // obman
    UTLOCK_AL,              // app loader
    UTLOCK_T120,            // gcc/mcs
    UTLOCK_AS,              // app sharing
    UTLOCK_MAX
}
UTLOCK;


// Event message
#define WM_UTTRIGGER_MSG    (WM_APP)


//
// BASEDLIST
//
// This is a list structure with based offsets
//
// next            : the next item in the list
// prev            : the previous item in the list
//
//
typedef struct tagBASEDLIST
{
    DWORD       next;
    DWORD       prev;
}
BASEDLIST;
typedef BASEDLIST FAR * PBASEDLIST;


typedef struct
{
    BASEDLIST  chain;
    void FAR *pData;
}
SIMPLE_LIST, FAR * PSIMPLE_LIST;



//
//
// MACROS
//
//
//
// List handling
// =============
// The common functions support the concept of a doubly linked list of
// objects.  Objects can be inserted and removed from specified locations
// in the list.
//
// At start of day the calling application must call COM_BasedListInit with a
// pointer to a private piece of memory for a BASEDLIST structure.  The list
// handling will initialise this structure.  The application must not
// release this memory while the list is active.  (Nor must it release any
// object while it is in a list!)
//
// The list functions can only manage a single list, however the app
// can load objects with multiple lists.  Each call to the common list
// functions takes a BASEDLIST pointer as the object handle and if the
// application defines multiple BASEDLIST structures within an object then it
// may manage them through the list functions.
//
//
// List chaining
// =============
// For normal list chaining, we have something like
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = pointer->next;
//   }
//
// When using lists whose elements contain offsets (in this case, relative
// offsets) to the next element, we have to cast to a 32-bit integer before
// we can add the offset.  This macro encapsulates this, and the example
// above would be modified as follows to use it:
//
//   while (pointer != NULL)
//   {
//     do something;
//     pointer = (TYPE) COM_BasedNextListField(pointer);
//   }
//
// Note also that the value returned by the macro is a pointer to a generic
// list object i.e.  a PBASEDLIST, and so must be cast back to the
// appropriate type.
//
//

//
// List traversing macros
// ======================
// These macros make use of DC_NEXT and DC_PREV, but also take the type of
// list being traversed in order to return the start pointer of the chained
// structure.
//
// The LIST_FIND macro supports the searching of a list, matching a key
// value to a selected structure element.
//
// The parameters to the macros are as follows:
//
//   pHead (type: PBASEDLIST)
//   -----
//      a pointer the root of the list
//
//   pEntry (type: STRUCT FAR * FAR *)
//   ------
//      a pointer to pointer to structure to chain from
//
//   STRUCT (a type name)
//   ------
//      the type of **pEntry
//
//   chain (a field name)
//   -----
//      the text name of the field in STRUCT which is the link along which
//      you wish to traverse
//
//   field (a field name)
//   -----
//      when FINDing, the text name of the field in STRUCT against which
//      you wish to match
//
//   key (a value, of the same type as STRUCT.field)
//   ---
//      when FINDing, the value to match against STRUCT.field against
//
//



//
// Offset arithmetic
// =================
// Using offsets within memory blocks, rather than pointers, to refer to
// objects in shared memory (as necessitated by the DC-Groupware shared
// memory architecture) presents certain difficulties.  Pointer arithmetic
// in C assumes that addition/subtraction operations involve objects of the
// same type and the offsets are presented as number of units of that
// particular type, rather than number of bytes.
//
// Therefore, pointers must be cast to integers before performing
// arithmetic on them (note that casting the pointers to byte pointers is
// not enough since on segmented architectures C performs bounds checking
// when doing pointer arithmetic which we don't want).
//
// Since this would make for cumbersome code if repeated everywhere, we
// define some useful macros to convert
//
// - an (offset, base) pair to a pointer (OFFSETBASE_TO_PTR)
//
// - a (pointer, base) pair to an offset (PTRBASE_TO_OFFSET)
//
// - a NULL pointer value to an offset(NULLBASE_TO_OFFSET)
//
// The offset calculated is the offset of the first parameter from the
// second.  As described above, the pointers passed in must be cast to
// 32-bit unsigned integers first, subtracted to get the offset, and then
// cast to 32-bit signed.
//
// The NULLBASE_TO_OFFSET value gives an offset that after translation back
// to a pointer gives a NULL.  This is NOT the same as a NULL offset, since
// this translates back to the base pointer (which is a perfectly valid
// address).
//
//
#define PTRBASE_TO_OFFSET(pObject, pBase)                               \
      (LONG)(((DWORD_PTR)(pObject)) - ((DWORD_PTR)(pBase)))

#define OFFSETBASE_TO_PTR(offset, pBase)                                \
      ((void FAR *) ((DWORD_PTR)(pBase) + (LONG)(offset)))

#define NULLBASE_TO_OFFSET(pBase)                                       \
      ((DWORD_PTR) (0L - (LONG_PTR)(pBase)))


__inline BOOL COM_BasedListIsEmpty ( PBASEDLIST pHead )
{
    ASSERT((pHead->next == 0 && pHead->prev == 0) ||
           (pHead->next != 0 && pHead->prev != 0));
    return (pHead->next == 0);
}

__inline void FAR * COM_BasedFieldToStruct ( PBASEDLIST pField, UINT nOffset )
{
    return (void FAR *) ((DWORD_PTR)pField - nOffset);
}

__inline PBASEDLIST COM_BasedStructToField ( void FAR * pStruct, UINT nOffset )
{
    return (PBASEDLIST) ((DWORD_PTR) pStruct + nOffset);
}

__inline PBASEDLIST COM_BasedNextListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->next, p);
}

__inline PBASEDLIST COM_BasedPrevListField ( PBASEDLIST p )
{
    return (PBASEDLIST) OFFSETBASE_TO_PTR(p->prev, p);
}

void FAR * COM_BasedListNext ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset );
void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset );
void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset );

typedef enum
{
    LIST_FIND_FROM_FIRST,
    LIST_FIND_FROM_NEXT
}
LIST_FIND_TYPE;

void COM_BasedListFind ( LIST_FIND_TYPE   eType,
                           PBASEDLIST          pHead,
                           void FAR * FAR*  ppEntry,
                           UINT           nOffset,
                           int           nOffsetKey,
                           DWORD_PTR     Key,
                           int           cbKeySize );


PSIMPLE_LIST COM_SimpleListAppend ( PBASEDLIST pHead, void FAR * pData );
void FAR *   COM_SimpleListRemoveHead ( PBASEDLIST pHead );

//
//
// FUNCTION PROTOTYPES
//
//

//
// API FUNCTION: COM_Rect16sIntersect(...)
//
// DESCRIPTION:
// ============
// Checks whether two TSHR_RECT16s rectangles intersect.  Rectangles are
// defined to be inclusive of all edges.
//
// PARAMETERS:
// ===========
// pRect1          : pointer to a TSHR_RECT16 rectangle.
// pRect2          : pointer to a TSHR_RECT16 rectangle.
//
// RETURNS:
// ========
// TRUE - if the rectangles intersect
// FALSE - otherwise.
//
//
__inline BOOL COM_Rect16sIntersect(LPTSHR_RECT16 pRect1, LPTSHR_RECT16 pRect2)
{
    if ((pRect1->left > pRect2->right) ||
        (pRect1->right < pRect2->left) ||
        (pRect1->top > pRect2->bottom) ||
        (pRect1->bottom < pRect2->top))
    {
        return(FALSE);
    }
    else
    {
        return(TRUE);
    }
}


//
// API FUNCTION: COM_BasedListInit(...)
//
// DESCRIPTION:
// ============
// Initialise a list root.
//
// PARAMETERS:
// ===========
// pListRoot       : pointer to the list root.
//
// RETURNS:
// ========
// Nothing.
//
//
__inline void COM_BasedListInit(PBASEDLIST pListRoot)
{
    //
    // The <next> and <prev> items in a list are the offsets, from the list
    // item, of the next and previous list items.
    //
    // In an empty list, the next item after the root is the root itself,
    // so the <next> offset is zero.  Likewise for <prev>.
    //
    pListRoot->next = 0;
    pListRoot->prev = 0;
}


//
// API FUNCTION: COM_BasedListInsertBefore(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
void COM_BasedListInsertBefore(PBASEDLIST pListLink, PBASEDLIST pNewLink);


//
// API FUNCTION: COM_BasedListInsertAfter(...)
// Inserts an item into a list.  To insert an item at the start of a list,
// specify the list root as the <pListLink> parameter.
//
//
void COM_BasedListInsertAfter(PBASEDLIST pListLink,  PBASEDLIST pNewLink);

//
// API FUNCTION: COM_BasedListRemove(...)
//
// DESCRIPTION:
// ============
// This function removes an item from a list.  The item to be removed is
// specified by a pointer to the BASEDLIST structure within the item.
//
// PARAMETERS:
// ===========
// pListLink       : pointer to link of the item to be removed.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_BasedListRemove(PBASEDLIST pListLink);


//
// API FUNCTION: COM_ReadProfInt(...)
//
// DESCRIPTION:
// ============
// This reads a private profile integer from the registry.
//
// PARAMETERS:
// ===========
// pSection        : section containing the entry to read.
// pEntry          : entry name of integer to retrieve.
// defaultValue    : default value to return
// pValue          : buffer to return the entry in.
//
// RETURNS:
// ========
// Nothing.
//
//
void COM_ReadProfInt(LPSTR pSection, LPSTR pEntry, int defValue, int * pValue);

//
// API FUNCTION: COM_GetSiteName(...)
//
// DESCRIPTION:
// ============
// Reads the site name out of the system registry.
//
// PARAMETERS:
// ===========
// siteName        : pointer to string to fill in with the site name.
// siteNameLen     : length of this string.
//
// RETURNS:
// ========
// None
//
//
void COM_GetSiteName(LPSTR siteName, UINT  siteNameLen);


#ifndef DLL_DISP
//
// API FUNCTION: DCS_StartThread(...)
//
// DESCRIPTION:
// ============
// Start a new thread of execution
//
// PARAMETERS:
// ===========
// entryFunction   : A pointer to the thread entry point.
//
//
BOOL DCS_StartThread(LPTHREAD_START_ROUTINE entryFunction);
#endif // DLL_DISP



#ifndef DLL_DISP
BOOL COMReadEntry(HKEY    topLevelKey,
                                 LPSTR pSection,
                                 LPSTR pEntry,
                                 LPSTR pBuffer,
                                 int  bufferSize,
                                 ULONG expectedDataType);
#endif // DLL_DISP





#define MAKE_SUBALLOC_PTR(pPool, chunkOffset)   OFFSETBASE_TO_PTR(chunkOffset, pPool)

#define MAKE_SUBALLOC_OFFSET(pPool, pChunk)     PTRBASE_TO_OFFSET(pChunk, pPool)


//
//
// Return codes - all offset from UT_BASE_RC
//
//

enum
{
    UT_RC_OK                    = UT_BASE_RC,
    UT_RC_NO_MEM
};


//
// The maximum number of UT events which we try to process without yielding
//
#define MAX_EVENTS_TO_PROCESS    10


//
//
// Types
//
//

//
// Utility Functions Interface handle
//
typedef struct tagUT_CLIENT *    PUT_CLIENT;


#define UTTASK_FIRST        0
typedef enum
{
    UTTASK_UI = UTTASK_FIRST,
    UTTASK_CMG,
    UTTASK_OM,
    UTTASK_AL,
    UTTASK_DCS,
    UTTASK_WB,
    UTTASK_MAX
}
UT_TASK;


//
// Event procedure registered by UT_RegisterEvent().
//
// Takes event handler registered data, event number and 2 parameters
//      Returns TRUE if event processed
//      Returns FALSE if not and event should be passed on to next handler
//
//
typedef BOOL (CALLBACK * UTEVENT_PROC)(LPVOID, UINT, UINT_PTR, UINT_PTR);

//
// Exit procedure
//
typedef void (CALLBACK * UTEXIT_PROC)( LPVOID exitData );

//
// The name of the class used to create UT windows
//
#define UT_WINDOW_CLASS     "DCUTWindowClass"

//
// The ID of the timer to use for trigger events.
//
#define UT_DELAYED_TIMER_ID 0x10101010


//
//
// Prototypes
//
//

//
//
// Task routines
//
//   UT_WndProc()              Subclassing window procedure
//   UT_InitTask()             Initialise a task
//   UT_TermTask()             Terminate a task
//   UT_RegisterEvent()        Register an event handler
//   UT_DeregisterEvent()      Deregisters an event handler
//   UT_RegisterExit()         Register an exit routine
//   UT_DeregisterExit()       Deregister an exit routine
//   UT_PostEvent()            Send an event to a task
//
//

LRESULT CALLBACK  UT_WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam);

BOOL UT_InitTask(UT_TASK task, PUT_CLIENT * pputTask);

//
//
// Overview:
//   This registers a task and assigns it a handle.
//   All other Utility Functions require this handle to be passed to them.
//
//   If a task has already been registered with the same process ID, the
//   utilities handle that has already been allocated is returned.
//   This is to allows the Utility Functions to be used in the context of
//   tasks that DC-SHARE has intercepted the graphics calls for.
//
//   Each task is identified by a name.
//
// Parameters:
//
//   task
//     Unique it for identifying task
//
//   pUtHandle (returned)
//     Utility Services handle to be used for all calls to the Utility
//     Services by this task
//
//


void UT_TermTask(PUT_CLIENT * pputTask);
//
//
// Overview:
//   This de-registers a task
//   All task resources are freed and the utHandle is released
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//

void UT_RegisterEvent(PUT_CLIENT      putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID       eventData,
                                UT_PRIORITY  priority);

void UT_DeregisterEvent(PUT_CLIENT  putTask,
                                UTEVENT_PROC eventProc,
                                LPVOID      eventData);

void UT_PostEvent(PUT_CLIENT putTaskFrom,
                                     PUT_CLIENT putTaskTo,
                                     UINT    delay,
                                     UINT    eventNo,
                                     UINT_PTR param1,
                                     UINT_PTR param2);

#define NO_DELAY        0

//
//
// Overview:
//   This posts an event to another task.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
//   toHandle
//     Utility Functions TASK handle of task to post event to
//
//   delay
//     Delay (in milliseconds) before event is posted
//
//   eventNo
//     event to be posted (see autevt.h for details of events)
//
//   param1
//     parameter 1 for event (meaning depends on event)
//
//   param2
//     parameter 2 for event (meaning depends on event)
//
//
// NOTES:
//
//   1)  The delay time is in milliseconds.  This may not be supported by
//       underlying OS but the setting and checking of the pop time value
//       is OS specific.
//
//   2)  The posting of events is asynchronous, the delay is simply
//       the time before the event is posted.  The task the event is
//       posted to will receive the event NOT BEFRE this time is up.
//
//   3)  If an event is posted with a delay specified, the sending task
//       must continue to process messages for the event to be posted
//

void UT_RegisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);
void UT_DeregisterExit(PUT_CLIENT putTask, UTEXIT_PROC exitProc, LPVOID exitData);



//
// Memory routines
//      UT_MallocRefCount
//      UT_BumpUpRefCount
//      UT_FreeRefCount
//


void *  UT_MallocRefCount(UINT cbSizeMem, BOOL fZeroMem);
void    UT_BumpUpRefCount(void * pMemory);
void    UT_FreeRefCount(void ** ppMemory, BOOL fNullOnlyWhenFreed);


// Ref count allocs
typedef struct tagUTREFCOUNTHEADER
{
    STRUCTURE_STAMP
    UINT    refCount;
}
UTREFCOUNTHEADER;
typedef UTREFCOUNTHEADER * PUTREFCOUNTHEADER;



//
// UT_MoveMemory()
// Replacement for CRT memmove(); handles overlapping
//
void *  UT_MoveMemory(void * dst, const void * src, size_t count);



//
// Locks
// - UT_Lock()       - Locks a lock
// - UT_Unlock()     - Unlocks a lock
//

#ifndef DLL_DISP
extern CRITICAL_SECTION g_utLocks[UTLOCK_MAX];

__inline void UT_Lock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    EnterCriticalSection(&g_utLocks[lock]);
}

__inline void UT_Unlock(UTLOCK lock)
{
    ASSERT(lock >= UTLOCK_FIRST);
    ASSERT(lock < UTLOCK_MAX);

    LeaveCriticalSection(&g_utLocks[lock]);
}

#endif // DLL_DISP


//
// Tasks
// UT_HandleProcessStart()
// UT_HandleProcessEnd()
// UT_HandleThreadEnd()
//

BOOL UT_HandleProcessStart(HINSTANCE hInstance);

void UT_HandleProcessEnd(void);

void UT_HandleThreadEnd(void);



//
// Structure for holding an event.  The first two fields allow the event to
// be held on the delayed event Q to be scheduled later.
//
typedef struct tagUTEVENT_INFO
{
    STRUCTURE_STAMP

    BASEDLIST       chain;

    // Params
    UINT            event;
    UINT_PTR        param1;
    UINT_PTR        param2;

    PUT_CLIENT      putTo;
    UINT            popTime;
}
UTEVENT_INFO;
typedef UTEVENT_INFO  * PUTEVENT_INFO;


#ifndef DLL_DISP
void __inline ValidateEventInfo(PUTEVENT_INFO pEventInfo)
{
    ASSERT(!IsBadWritePtr(pEventInfo, sizeof(UTEVENT_INFO)));
}
#endif // DLL_DISP


//
// Information held about each exit procedure
//
typedef struct tagUTEXIT_PROC_INFO
{
    UTEXIT_PROC     exitProc;
    LPVOID          exitData;
} UTEXIT_PROC_INFO;
typedef UTEXIT_PROC_INFO * PUTEXIT_PROC_INFO;

//
// Information held about each event procedure
//
typedef struct tagUTEVENT_PROC_INFO
{
    UTEVENT_PROC    eventProc;
    LPVOID          eventData;
    UT_PRIORITY     priority;
}
UTEVENT_PROC_INFO;
typedef UTEVENT_PROC_INFO * PUTEVENT_PROC_INFO;


//
//
// UT_CLIENT
//
// Information stored about each Utilities registered task.  A pointer to
// this structure is returned as the UT Handle from UT_InitTask(), and is
// passed in as a parameter to subsequent calls to UT.
//
// This structure is allocated in the shared memory bank.
//
// This should be a multiple of 4 bytes to ensure DWORD alignment of the
// allocated memory
//
//
typedef struct tagUT_CLIENT
{
    DWORD               dwThreadId;
    HWND                utHwnd;         // Window to post UT events to

    UTEXIT_PROC_INFO    exitProcs[UTEXIT_PROCS_MAX];
                                         // Exit procedures registered for
                                         //   this task.
    UTEVENT_PROC_INFO   eventHandlers[UTEVENT_HANDLERS_MAX];
                                         // Event procedures registered for
                                         //   this task.

    BASEDLIST           pendingEvents;   // List of events for this task
                                         //   which are ready to be
                                         //   processed.
    BASEDLIST           delayedEvents;   // List of delayed events destined
                                         //   for this task.
}
UT_CLIENT;


#ifndef DLL_DISP
void __inline ValidateUTClient(PUT_CLIENT putTask)
{
    extern UT_CLIENT    g_autTasks[UTTASK_MAX];

    ASSERT(putTask >= &(g_autTasks[UTTASK_FIRST]));
    ASSERT(putTask < &(g_autTasks[UTTASK_MAX]));
    ASSERT(putTask->dwThreadId);
}
#endif // DLL_DISP


//
//
// UTTaskEnd(...)
//
//   This routine frees all resources associated with the task and
//   releases the handle
//
// Parameters:
//
//   pTaskData - The Utility Functions handle for the task that is ending
//
//
void UTTaskEnd(PUT_CLIENT putTask);



//
//
// Overview:
// This routine is called to check the status of delayed events and to post
// them to the target process if required.
//
// Parameters:
//
//   utHandle
//     Utility Functions handle of invoking task
//
// NOTES:
//
// 1) This routine is called periodically or whenever the application
//       believes a delayed event has popped.
//
// Return codes: None
//
//
void UTCheckEvents(PUT_CLIENT putTask);
void UTCheckDelayedEvents(PUT_CLIENT putTask);


//
//
// UTProcessEvent(...)
//
// Overview:
//   This process an event for the current task
//
//
// Parameters:
//
//   utHandle
//     Utility Functions Handle
//
//   event
//     The event to process
//
//   param1
//     The 1st parameter for the event
//
//   param2
//     The 2nd parameter for the event
//
//
void UTProcessEvent(PUT_CLIENT putTask, UINT event, UINT_PTR param1, UINT_PTR param2);


//
//
// UTProcessDelayedEvent(...)
//
// A delayed event destined for the current task is ready to be processed.
//
//   pTaskData   - The current tasks data.
//   eventOffset - Offset into the shared memory bank at which the event
//                 is stored.
//
//
void UTProcessDelayedEvent(PUT_CLIENT putTask, DWORD eventOffset);



//
//
// UTPostImmediateEvt(...)
//
// This function adds an event to a task's pending event queue, and posts
// a trigger event if required.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostImmediateEvt(PUT_CLIENT          putTaskFrom,
                        PUT_CLIENT          putTaskTo,
                        UINT                event,
                        UINT_PTR            param1,
                        UINT_PTR            param2);


//
//
// UTPostDelayedEvt(...)
//
// This function adds an event to a task's delayed event queue, and starts
// a timer (on the destination's task) to get that task to process the
// event when the timer ticks.
//
//   pSrcTaskData    - originating tasks data
//   pDestTaskData   - destination tasks data
//   delay           - the delay (in milliseconds)
//   event           - event data
//   param1          - parm1
//   param2          - parm2
//
//
void UTPostDelayedEvt(PUT_CLIENT            putTaskFrom,
                                    PUT_CLIENT  putTaskTo,
                                   UINT         delay,
                                   UINT         event,
                                   UINT_PTR     param1,
                                   UINT_PTR     param2);

//
//
// Overview:
//   This posts a event to another task
//
// Parameters:
//
//   pSrcTaskInfo  - task data for the source task
//   pDestTaskInfo - task data for the dest task
//
void UTTriggerEvt(PUT_CLIENT putTaskFrom, PUT_CLIENT putTaskTo);


//
//
// Overview:
//   This starts a delayed-event timer for a task.
//
// Parameters:
//   pTaskData
//     The task data for the task
//
//   popTime
//     The target time for the timer to pop - this is an OS specific value
//     in the same format as that returned by UTPopTime().
//
//
void UTStartDelayedEventTimer(PUT_CLIENT putTask, UINT popTime);


#ifdef __cplusplus

#include <mappedfile.h>


// --------------------------------------------------------------------------
//
// Shared Variables are in the GLOBALDATA structure
//
// --------------------------------------------------------------------------
typedef struct tagGLOBALDATA {
    HWND		g_asMainWindow;
    ATOM		g_asHostProp;
    HHOOK	g_imMouseHook;
    char		g_osiDriverName[CCHDEVICENAME];
}GLOBALDATA;


// pointer to shared global data
extern GLOBALDATA *g_pGlobalData;
      
// pointer to mem mapped file handle
extern CMemMappedFile *g_CMappedFile;                       
                    
// size of global data memory mapped file
const int c_cbGlobalData =  sizeof(GLOBALDATA);
          
// name of memory mapped file
const TCHAR c_szMappedFileName[] = TEXT("AppshareHookShared");

// mutex to access mem mapped file and wait time
const TCHAR c_szMutex[] = TEXT("AppshareHookMutex");
const int c_nMutexWait = 5000;

__inline BOOL CreateMappedFile()
{
    g_CMappedFile = new CMemMappedFile;
    if (g_CMappedFile)
    {
        if (g_CMappedFile->Open(c_szMappedFileName, c_cbGlobalData))
        {
            CScopeMutex csMutex;
            if (csMutex.Create(c_szMutex, c_nMutexWait))
            {
                g_CMappedFile->AccessMem((void **)&g_pGlobalData);
                if (g_CMappedFile->FirstOpen())
                {
                    memset(g_pGlobalData, 0, c_cbGlobalData);
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}
__inline void CloseMappedFile()
{
    if (g_CMappedFile)
    {
        g_CMappedFile->Close();
        delete g_CMappedFile;
        g_CMappedFile = 0;
    }
}


__inline HWND   GetAsMainWindow()
{
	if(g_pGlobalData)
	{
		return g_pGlobalData->g_asMainWindow;
	}
	else
	{
		return NULL;
	}
}

__inline BOOL  SetAsMainWindow(HWND hwnd)
{
	if(g_pGlobalData)
	{
		g_pGlobalData->g_asMainWindow = hwnd;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


__inline ATOM  GetAsHostProp()
{
	if(g_pGlobalData)
	{
		return g_pGlobalData->g_asHostProp;
	}
	else
	{
		return NULL;
	}
}

__inline BOOL  SetAsHostProp(ATOM atom)
{
	if(g_pGlobalData)
	{
		g_pGlobalData->g_asHostProp = atom;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


__inline const char *  GetOsiDriverName()
{
	if(g_pGlobalData)
	{
		return g_pGlobalData->g_osiDriverName;
	}
	else
	{
		return NULL;
	}
}

__inline BOOL  SetOsiDriverName(LPCSTR szDriverName)
{
	if(g_pGlobalData &&
		szDriverName &&
		(lstrlen(szDriverName) <= SIZEOF_ARRAY(g_pGlobalData->g_osiDriverName)))
	{
		lstrcpy(g_pGlobalData->g_osiDriverName,szDriverName);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}



__inline HHOOK  GetImMouseHook()
{
	if(g_pGlobalData)
	{
		return g_pGlobalData->g_imMouseHook;
	}
	else
	{
		return NULL;
	}
}

__inline BOOL  SetImMouseHook(HHOOK hook)
{
	if(g_pGlobalData)
	{
		g_pGlobalData->g_imMouseHook = hook;
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

#endif // __cplusplus

#endif // _H_UT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\globals.cpp ===
//
// GLOBALS.CPP
// Global Variable Storage
//
// Copyright(c) Microsoft 1997-
//

#include "precomp.h"


#include <datainit.h>
#include "globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\usr.h ===
//
// Update Shared Regions
//

#ifndef _H_USR
#define _H_USR

//
//                                                                         
// CONSTANTS                                                               
//                                                                         
//

//
// Drawing order support constants.                                        
//
#define MAX_X_SIZE               128
#define MEGA_X_SIZE              256
#define MEGA_WIDE_X_SIZE        1024




//
// Used for bitmap and cache hatching.
//
#define USR_HATCH_COLOR_RED  1
#define USR_HATCH_COLOR_BLUE 2



//
// Default order packet sizes.                                             
//                                                                         
// Note that this is the size of the initially allocated packet.  After the
// packet has been processed by the General Data Compressor (GDC) the      
// transmitted packet size may well be smaller than the specified value.   
//                                                                         
// Also note that (in general) the smaller the order packets are, the worse
// the GDC compression ratio will be (it prefers to compress big packets). 
//                                                                         
//

#define SMALL_ORDER_PACKET_SIZE  0x0C00
#define LARGE_ORDER_PACKET_SIZE  0x7800




//
//                                                                         
// PROTOTYPES                                                              
//                                                                         
//


//
//
// Force the window to redraw along with all its children.  (Need to use   
// RDW_ERASENOW flag because otherwise RedrawWindow makes the mistake of  
// posting the WM_PAINT before the WM_ERASE.  BeginPaint call will validate
// all of the window so the WM_ERASE will have a null update region).      
//
#if defined(DLL_CORE) || defined(DLL_HOOK)
 
void __inline USR_RepaintWindow(HWND hwnd)
{
    UINT    flags = RDW_FRAME | RDW_INVALIDATE | RDW_ERASE | RDW_ALLCHILDREN;

    if (hwnd)
    {
        //
        // Only erasenow/updatenow for top level windows.  The desktop's
        // children are all on different threads, this would cause out-of-
        // order results.
        //
        flags |= RDW_ERASENOW | RDW_UPDATENOW;
    }

    RedrawWindow(hwnd, NULL, NULL, flags);
}

#endif // DLL_CORE or DLL_HOOK




#endif // _H_USR
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\precomp.h ===
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\view.h ===
//
// View UI to present shared applications/desktop of a remote host
//

#ifndef _H_VIEW
#define _H_VIEW


//
//
// CONSTANTS
//
//

//
// The class name of the frame containing the view of shared applications
// from a particular user.
//
#define VIEW_FRAME_CLASS_NAME           "AS_Frame"
#define VIEW_CLIENT_CLASS_NAME          "AS_Client"
#define VIEW_WINDOWBAR_CLASS_NAME       "AS_WindowBar"
#define VIEW_WINDOWBARITEMS_CLASS_NAME  "AS_WindowBarItems"
#define VIEW_FULLEXIT_CLASS_NAME        "AS_FullExit"


//
// Metrics
//

//
// LAURABU:  For international, consider making this larger (i.e, German,
// Slavic, and DBCS systems)
//
#define VIEW_MAX_ITEM_CHARS             20

//
// IDs
//
#define IDVIEW_ITEMS         1      // Window bar item list
#define IDVIEW_SCROLL        2      // Window bar scroll
#define IDT_AUTOSCROLL      50      // Period is DoubleClick time metric


//
// WindowBar ITEM struct
//
typedef struct tagWNDBAR_ITEM
{
    STRUCTURE_STAMP

    BASEDLIST           chain;

    UINT_PTR            winIDRemote;
    TSHR_UINT32         flags;
    char                szText[SWL_MAX_WINDOW_TITLE_SEND + 1];
}
WNDBAR_ITEM;
typedef WNDBAR_ITEM *   PWNDBAR_ITEM;


//
// Init/Term
//
BOOL VIEW_Init(void);
void VIEW_Term(void);


//
// Frame
//
LRESULT CALLBACK VIEWFrameWindowProc(HWND, UINT, WPARAM, LPARAM);


//
// View
//
LRESULT CALLBACK VIEWClientWindowProc(HWND, UINT, WPARAM, LPARAM);

//
// WindowBar
//
LRESULT CALLBACK VIEWWindowBarProc(HWND, UINT, WPARAM, LPARAM);

//
// WindowBar Items
//
LRESULT CALLBACK VIEWWindowBarItemsProc(HWND, UINT, WPARAM, LPARAM);

//
// FullScreen Exit
//
LRESULT CALLBACK VIEWFullScreenExitProc(HWND, UINT, WPARAM, LPARAM);

//
// Informational dialog
//
INT_PTR    CALLBACK VIEWDlgProc(HWND, UINT, WPARAM, LPARAM);

#endif // _H_VIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\h\wb.hpp ===
//
// Whiteboard Applet Functions
//

#ifndef _HPP_WB
#define _HPP_WB


extern "C"
{
    #include <al.h>
}


//
// Page in use flag for page state structure
//
#define PAGE_IN_USE                         1
#define PAGE_NOT_IN_USE                     2

//
// Page sub-states used during add and delete of pages.  Different actions
// are required depending on whether the page is being added/deleted
// locally or remotely.
//
#define PAGE_STATE_EMPTY                    1
#define PAGE_STATE_LOCAL_OPEN_CONFIRM       2
#define PAGE_STATE_EXTERNAL_OPEN_CONFIRM    3
#define PAGE_STATE_READY                    4
#define PAGE_STATE_EXTERNAL_ADD             5

#define PAGE_STATE_LOCAL_DELETE             6
#define PAGE_STATE_LOCAL_DELETE_CONFIRM     7
#define PAGE_STATE_EXTERNAL_DELETE          8
#define PAGE_STATE_EXTERNAL_DELETE_CONFIRM  9

//
// Page manipulation values
//
#define OPEN_LOCAL                          1
#define OPEN_EXTERNAL                       2

#define PAGE_FIRST                          1
#define PAGE_LAST                           2
#define PAGE_BEFORE                         3
#define PAGE_AFTER                          4

//
// Workset Ids
//
#define USER_INFORMATION_WORKSET            0
#define PAGE_CONTROL_WORKSET                1
#define SYNC_CONTROL_WORKSET                2

#define FIRST_PAGE_WORKSET                  5

//
// Number of pages to initialize during registration.  During registration
// the number of pages defined here will have worksets opened for them and
// will be ready to be allocated through WBP_PageAdd calls.
//
#define PREINITIALIZE_PAGES               10

//
// Object types for Page Control Workset objects
//
#define TYPE_CONTROL_PAGE_ORDER            1
#define TYPE_CONTROL_LOCK                  2

//
// Registration state table
//
// The following table shows the transitions made during registration.
//
// S0    = STATE_ERROR
// S1    = STATE_REG_START
// S2    = STATE_REG_PENDING_WSGROUP_CON
// S3    = STATE_REG_PENDING_WORKSET_OPEN
// S4    = STATE_REG_PENDING_LOCK
// S5    = STATE_REG_PENDING_PAGE_CONTROL
// S6    = STATE_REG_PENDING_UNLOCK
// SIDLE = STATE_IDLE
//
//                          S0    S1    S2    S3    S4    S5    S6    SIDLE
//
// WBP_Start                -     A1    AE    AE    AE    AE    AE    AE
// OM_WSGROUP_REGISTER_CON  i     i     A2    e     e     e     e     e
// OM_WORKSET_OPEN_CON      i     i     e     A3    e     e     e     *
// OM_WORKSET_LOCK_CON      i     i     e     e     A4    e     e     e
// OM_OBJECT_ADD_IND        i     i     i     i     i     A5    e     *
// OM_WORKSET_UNLOCK_IND    i     i     i     i     i     i     A6    *
// OM_NETWORK_LOST_IND      A7    i     A7    A7    A7    A7    A7    A7
// OM_OUT_OF_RESOURCES_IND  i     i     AR1   AR1   AR2   AR2   AR1   AR1
// WBP_Stop                 AD0   AN    AD0   AD0   AD2   AD2   AD0   AD0
//
// WBP_... called           AE    AN    AN    AN    AN    AN    AN    *
//
// Actions:
//
// e    Error - log unexpected event and ignore
// i    Ignore
// *    Not described in this table
//
// AN   Return a "Not registered" error to caller
//      (No state change)
//
// AE   Return an "Out of resources" error to caller
//      (No state change)
//
// A1   Call OM_Register
//      Call OM_WSGroupRegister
//      Move to S2
//
// A2   Open all worksets (0, 1, 2, and 5-254)
//      If error perform AD0
//      Else move to S3
//
// A3   If all worksets open
//          If Page Control Object exists
//              Move to SIDLE
//          Else
//              Request lock
//              Move to S4
//          Endif
//      Endif
//
// A4   If lock acquired OK
//          Add Page Control Object
//          Move to S5
//      Else
//          If locked by another person
//              Move to S5
//          Else
//              Perform AD
//          Endif
//      Endif
//
// A5   If add is for Page Control Object
//          If we have the Page Control Workset lock
//              Release the lock
//          Else
//              Perform A6
//          Endif
//      Endif
//
// A6   Post WBP_EVENT_REGISTERED to client
//      If a lock is present
//          Post lock notification to client
//      Endif
//      Move to SIDLE
//
// A7   Post WBP_EVENT_NETWORK_LOST to client
//      (No state change.)
//
// AD2  Unlock Page Control Workset
// AD0  Deregister from ObMan
//      Post WBP_EVENT_DEREGISTERED to client
//      Move to S1
//
//

//
// Major states occupied by a client
//
#define STATE_EMPTY                     0
#define STATE_STARTING                  1
#define STATE_STARTED                   2
#define STATE_REGISTERING               3
#define STATE_IDLE                      4

//
// Sub-states occupied during start-up
//
#define STATE_START_START                    1
#define STATE_START_REGISTERED_EVENT         2
#define STATE_START_REGISTERED_OM            3
#define STATE_START_REGISTERED_EXIT          4

//
// Sub-states occupied after start-up, but before joining a call.
//
#define STATE_STARTED_START                  5

//
// Sub-states occupied during registration.  These must be defined to
// increase monotonically as we step through the registration process.
//
#define STATE_REG_START                      6
#define STATE_REG_PENDING_WSGROUP_CON        7
#define STATE_REG_PENDING_USER_WORKSET       8
#define STATE_REG_PENDING_WORKSET_OPEN       9
#define STATE_REG_USER_OBJECT_ADDED         10
#define STATE_REG_PENDING_LOCK              11
#define STATE_REG_PENDING_PAGE_CONTROL      12
#define STATE_REG_PENDING_SYNC_CONTROL      13
#define STATE_REG_PENDING_UNLOCK            14
#define STATE_REG_PENDING_PAGE_ORDER        15
#define STATE_REG_PENDING_READY_PAGES       16
#define STATE_REG_END                       17

#define STATE_REG_PENDING_WSGROUP_MOVE      18
#define STATE_REG_PENDING_NEW_USER_OBJECT   19

//
// Error states
//
#define ERROR_STATE_EMPTY               0
#define ERROR_STATE_FATAL               1

//
// Lock states
//
typedef enum
{
    LOCK_STATE_EMPTY    = 0,
    LOCK_STATE_PENDING_LOCK,
    LOCK_STATE_PENDING_ADD,
    LOCK_STATE_GOT_LOCK,
    LOCK_STATE_PENDING_DELETE,
    LOCK_STATE_LOCKED_OUT,
    LOCK_STATE_CANCEL_LOCK
}
WB_LOCK_STATE;

//
// Load states
//
#define LOAD_STATE_EMPTY                0
#define LOAD_STATE_PENDING_CLEAR        1
#define LOAD_STATE_PENDING_DELETE       2
#define LOAD_STATE_LOADING              3
#define LOAD_STATE_PENDING_NEW_PAGE     4


//
// Call id for local calls
//
#define WB_NO_CALL OM_NO_CALL

//
// Limit defines
//
// Maximum number of pages allowed in the Whiteboard
//
#define WB_MAX_PAGES               250

//
// Length of font face (must be a multiple of 4)
//
#define WB_FACENAME_LEN              32

//
// Lock type definitions
//
typedef enum
{
    WB_LOCK_TYPE_NONE = 0,
    WB_LOCK_TYPE_PAGE_ORDER,
    WB_LOCK_TYPE_CONTENTS
}
WB_LOCK_TYPE;

//
// Graphic lock definitions
//
typedef enum
{
    WB_GRAPHIC_LOCK_NONE = 0,
    WB_GRAPHIC_LOCK_LOCAL,
    WB_GRAPHIC_LOCK_REMOTE
}
WB_GRAPHIC_LOCK_TYPE;


//
// Return codes
//

enum
{
    WB_RC_NOT_LOCKED = WB_BASE_RC,
    WB_RC_LOCKED,
    WB_RC_BAD_FILE_FORMAT,
    WB_RC_WRITE_FAILED,
    WB_RC_BAD_PAGE_HANDLE,
    WB_RC_BAD_PAGE_NUMBER,
    WB_RC_CHANGED,
    WB_RC_NOT_CHANGED,
    WB_RC_NO_SUCH_PAGE,
    WB_RC_NO_SUCH_GRAPHIC,
    WB_RC_NO_SUCH_PERSON,
    WB_RC_TOO_MANY_PAGES,
    WB_RC_ALREADY_LOADING,
    WB_RC_BUSY,
    WB_RC_GRAPHIC_LOCKED,
    WB_RC_GRAPHIC_NOT_LOCKED,
    WB_RC_NOT_LOADING,
    WB_RC_CREATE_FAILED,
    WB_RC_READ_FAILED
};


//
// Events
//

enum
{
    WBPI_EVENT_LOAD_NEXT                = WB_BASE_EVENT,
    WBP_EVENT_JOIN_CALL_OK,
    WBP_EVENT_JOIN_CALL_FAILED,
    WBP_EVENT_NETWORK_LOST,
    WBP_EVENT_ERROR,
    WBP_EVENT_CONTENTS_LOCKED,
    WBP_EVENT_UNLOCKED,
    WBP_EVENT_LOCK_FAILED,
    WBP_EVENT_PAGE_CLEAR_IND,
    WBP_EVENT_PAGE_ORDER_UPDATED,
    WBP_EVENT_PAGE_DELETE_IND,
    WBP_EVENT_PAGE_ORDER_LOCKED,
    WBP_EVENT_GRAPHIC_ADDED,
    WBP_EVENT_GRAPHIC_MOVED,
    WBP_EVENT_GRAPHIC_UPDATE_IND,
    WBP_EVENT_GRAPHIC_REPLACE_IND,
    WBP_EVENT_GRAPHIC_DELETE_IND,
    WBP_EVENT_PERSON_JOINED,
    WBP_EVENT_PERSON_LEFT,
    WBP_EVENT_PERSON_UPDATE,
    WBP_EVENT_PERSON_REPLACE,
    WBP_EVENT_LOAD_FAILED,
    WBP_EVENT_INSERT_OBJECTS,
    WBP_EVENT_INSERT_NEXT,
    WBP_EVENT_SYNC_POSITION_UPDATED,
    WBP_EVENT_LOAD_COMPLETE
};


//
// Type declarations
//


//
// Page handle.  This is actually an index into the array of pages.
//
typedef OM_WORKSET_ID               WB_PAGE_HANDLE;
typedef WB_PAGE_HANDLE *        PWB_PAGE_HANDLE;
typedef PWB_PAGE_HANDLE *       PPWB_PAGE_HANDLE;

#define WB_PAGE_HANDLE_NULL         ((WB_PAGE_HANDLE) 0)

//
// Graphic handle.  These are handles to graphic objects in the various
// page worksets.
//
typedef POM_OBJECT           WB_GRAPHIC_HANDLE;
typedef WB_GRAPHIC_HANDLE *     PWB_GRAPHIC_HANDLE;
typedef PWB_GRAPHIC_HANDLE *    PPWB_GRAPHIC_HANDLE;


//
// Workset type constants
//
#define TYPE_FILE_HEADER                  0
#define TYPE_END_OF_PAGE                  1
#define TYPE_END_OF_FILE                  2

//
// Graphic type constants
//
#define TYPE_GRAPHIC_FREEHAND             3
#define TYPE_GRAPHIC_LINE                 4
#define TYPE_GRAPHIC_RECTANGLE            5
#define TYPE_GRAPHIC_FILLED_RECTANGLE     6
#define TYPE_GRAPHIC_ELLIPSE              7
#define TYPE_GRAPHIC_FILLED_ELLIPSE       8
#define TYPE_GRAPHIC_TEXT                 9
#define TYPE_GRAPHIC_DIB                 10


//
// Objects used in the Page Control and Lock worksets are used only by the
// API functions.  They are never passed back to the Client.
//

//
// Structure used to build the Page Control Object kept in the Page Control
// Workset.  This object contains a list of workset IDs in page order (i.e.
// the ID for page 1 comes first).
//
// The structure allows for the maximum number of pages.  When it is
// written to the Page Control Object only as many entries as are in use
// are written.
//
// Note that the generation number field has been split into a hiword and
// a loword - this is because the original definition had an unaligned
// TSHR_UINT32 which caused the compiler to insert padding into the structure,
// thus breaking backwards compatibility.
//
typedef struct tagWB_PAGE_ORDER
{
  TSHR_UINT16       objectType;            // Object type = TYPE_CONTROL_PAGES
  TSHR_UINT16       generationLo;          // Generation number of object
  TSHR_UINT16       generationHi;
  TSHR_UINT16       countPages;            // Number of active pages
  OM_WORKSET_ID  pages[WB_MAX_PAGES];   // List of worksets (in page order)
} WB_PAGE_ORDER;

typedef WB_PAGE_ORDER  *        PWB_PAGE_ORDER;
typedef PWB_PAGE_ORDER *        PPWB_PAGE_ORDER;

//
// Lock object - kept in the Page Control Workset indicating the type and
// owner of the current lock.
//
typedef struct tagWB_LOCK
{
  TSHR_UINT16       objectType;            // Object type = TYPE_CONTROL_LOCK
  TSHR_UINT16       lockType;              // Type of lock
                                        // WB_LOCK_TYPE_NONE
                                        // WB_LOCK_TYPE_PAGE_ORDER
                                        // WB_LOCK_TYPE_CONTENTS
  OM_OBJECT_ID   personID;              // Id of person holding lock
} WB_LOCK;

typedef WB_LOCK *               PWB_LOCK;
typedef PWB_LOCK *              PPWB_LOCK;


//
// Graphic object header.
//

//
// WB Tool Types (not type; toolType)
//
#define WBTOOL_PEN          1
#define WBTOOL_TEXT         3

typedef struct tagWB_GRAPHIC
{
  //
  // All graphic and file objects must start with these three fields
  //
  TSHR_UINT32  length;                 // Total length of structure
  TSHR_UINT16  type;                   // Type of object
  TSHR_UINT16  dataOffset;             // Offset to graphic data from start

  //
  // All graphic objects have these fields
  //
  TSHR_RECT16  rectBounds;          // Bounding rectangle
  TSHR_COLOR   color;                  // Pen color (3 bytes)
  TSHR_UINT8   locked;                 // Flag indicating a person is editing
  TSHR_UINT16  penWidth;               // Pen width
  TSHR_UINT16  penStyle;               // Pen style
  TSHR_RECT16  rect;                   // Rectangle used for defining object
  OM_OBJECT_ID lockPersonID;        // ID of locking person. This field is
                                    // maintained by the core and should not
                                    // be altered by clients.
  TSHR_UINT16  rasterOp;               // Drawing mode
  TSHR_UINT8   smoothed;               // Use curve smoothing algorithm
  TSHR_UINT8   toolType;               // Type of tool used
  TSHR_UINT16  loadedFromFile;         // Was this object loaded from file?
  NET_UID   loadingClientID;        // ID of the client which loaded this
                                    // object from file (only used if the
                                    // loadedFromFile field is set).
                                    // (This is defined as a TSHR_UINT16).
  TSHR_UINT32  reserved1;              // Extra space for later additions
  TSHR_UINT32  reserved2;              // Extra space for later additions
} WB_GRAPHIC;

typedef WB_GRAPHIC *           PWB_GRAPHIC;
typedef PWB_GRAPHIC *          PPWB_GRAPHIC;

//
// Freehand line
//
typedef struct tagWB_GRAPHIC_FREEHAND
{
  WB_GRAPHIC header;                // Basic information
  TSHR_UINT16   pointCount;            // Number of points in the polyline
  TSHR_POINT16  points[1];             // Array of points
} WB_GRAPHIC_FREEHAND;

typedef WB_GRAPHIC_FREEHAND *   PWB_GRAPHIC_FREEHAND;
typedef PWB_GRAPHIC_FREEHAND *  PPWB_GRAPHIC_FREEHAND;

//
// Text
//
typedef struct tagWB_GRAPHIC_TEXT
{
    WB_GRAPHIC header;                // Basic information
    TSHR_INT16    charHeight;            // Character height
    TSHR_UINT16   averageCharWidth;      // Average character width
    TSHR_UINT16   strokeWeight;          // Stroke weight (normal, bold)
    TSHR_UINT8    italic;                // Italic flag
    TSHR_UINT8    underline;             // Underline flag
    TSHR_UINT8    strikeout;             // Strikeout flag
    TSHR_UINT8    pitch;                 // Fixed/variable pitch
    TSHR_CHAR     faceName[WB_FACENAME_LEN]; // Font face name
    TSHR_UINT16   codePage;              // Font code page
    TSHR_UINT16   stringCount;           // Number of lines of text
    TSHR_CHAR  text[1];               // Null-terminated text strings
}
WB_GRAPHIC_TEXT;

typedef WB_GRAPHIC_TEXT  *      PWB_GRAPHIC_TEXT;
typedef PWB_GRAPHIC_TEXT *      PPWB_GRAPHIC_TEXT;

//
// Bitmap image
//
typedef struct tagWB_GRAPHIC_DIB
{
  WB_GRAPHIC header;                // Basic information
                                    // Data bytes follow this structure
} WB_GRAPHIC_DIB;

typedef WB_GRAPHIC_DIB  *       PWB_GRAPHIC_DIB;
typedef PWB_GRAPHIC_DIB *       PPWB_GRAPHIC_DIB;

//
// Person object
//
typedef struct tagWB_PERSON
{
    TSHR_CHAR       personName[TSHR_MAX_PERSON_NAME_LEN]; // Person name
    TSHR_UINT16       colorId;               // Color identifier for the person
    TSHR_UINT8        synced;                // Sync flag
    WB_PAGE_HANDLE    currentPage;           // Handle of current page
    TSHR_RECT16    visibleRect;           // Area person can see in window
    TSHR_UINT8       pointerActive;         // Remote pointer in use flag
    WB_PAGE_HANDLE pointerPage;           // Page for remote pointer
    TSHR_POINT16      pointerPos;            // Position of pointer in page
    TSHR_PERSONID cmgPersonID;           // Call Manager personID.
    TSHR_UINT32       reserved1;             // Reserved for future use.
    TSHR_UINT32       reserved2;             // Reserved for future use.
}
WB_PERSON;

typedef WB_PERSON  *              PWB_PERSON;
typedef PWB_PERSON *              PPWB_PERSON;

//
// size used by core to update the user object - front ends should only
// replace user objects via the WBP_SetLocalPersonData API function.
//
#define WB_PERSON_OBJECT_UPDATE_SIZE   (FIELD_OFFSET(WB_PERSON, synced))

//
// Sync object
//
typedef struct tagWB_SYNC
{
    TSHR_UINT32       length;                // Length of the structure
    TSHR_UINT16       dataOffset;            // Offset to data from start
    WB_PAGE_HANDLE currentPage;           // Handle of current page
    TSHR_UINT8        pad;                   // Pad
    TSHR_RECT16    visibleRect;           // Area visible in person's window
    TSHR_UINT16       zoomed;                // Zoom sync participants
}
WB_SYNC;

typedef WB_SYNC  *              PWB_SYNC;
typedef PWB_SYNC *              PPWB_SYNC;


//
// Constant to use instead of sizeof(WB_SYNC).
//
// The WB_SYNC structure was not defined correctly in previous versions
// of Groupware (it was not padded correctly to a multiple of 4 bytes).
// Some compilers (e.g. on NT) insert padding, so the structure is not the
// same size as on Win95 for example.  This results in an assert from
// Obman...  So we define a constant which is the same whatever compiler we
// use.
//
#define WB_SYNC_SIZE    18


//
// File header for Whiteboard format files
//
typedef struct tagWB_FILE_HEADER
{
  TSHR_UINT32 length;                  // Total length of object
  TSHR_UINT16 type;                    // Type of file object
  TSHR_UINT16 dataOffset;              // Not used (but must be here)
  char   functionProfile[OM_MAX_FP_NAME_LEN];
} WB_FILE_HEADER;

typedef WB_FILE_HEADER *        PWB_FILE_HEADER;
typedef PWB_FILE_HEADER *       PPWB_FILE_HEADER;

//
// End-of-page object for writing to file
//
typedef struct tagWB_END_OF_PAGE
{
  TSHR_UINT32 length;                  // Total length of object
  TSHR_UINT16 type;                    // Type of file object
  TSHR_UINT16 dataOffset;              // Not used (but must be here)
} WB_END_OF_PAGE;

typedef WB_END_OF_PAGE *        PWB_END_OF_PAGE;
typedef PWB_END_OF_PAGE *       PPWB_END_OF_PAGE;

//
// End-of-file object
//
typedef WB_END_OF_PAGE              WB_END_OF_FILE;
typedef WB_END_OF_FILE *        PWB_END_OF_FILE;
typedef PWB_END_OF_FILE *       PPWB_END_OF_FILE;



//
// Structure used for determining the current sync page
//
typedef struct tagWB_SYNC_CONTROL
{
  OM_OBJECT_ID personID;                // ID of person who wrote object
  WB_SYNC      sync;                    // Sync position details
} WB_SYNC_CONTROL;

typedef WB_SYNC_CONTROL  *      PWB_SYNC_CONTROL;
typedef PWB_SYNC_CONTROL *      PPWB_SYNC_CONTROL;

//
// Constant to use instead of sizeof(WB_SYNC_CONTROL).
//
// The WB_SYNC structure was not defined correctly in previous versions
// of Groupware (it was not padded correctly to a multiple of 4 bytes).
// Some compilers (e.g. on NT) insert padding, so the structure is not the
// same size as on Win95 for example.  This results in an assert from
// Obman...  So we define a constant which is the same whatever compiler we
// use.
//
#define WB_SYNC_CONTROL_SIZE (sizeof(OM_OBJECT_ID) + WB_SYNC_SIZE)


//
// Structures used for maintaining and accessing the page list internally.
// The page state structure combine the internal and external page state.
//
typedef struct tagWB_PAGE_STATE
{
    TSHR_UINT16 state;                       // Page in use flag
    TSHR_UINT16 subState;                    // Page state
    OM_CORRELATOR   worksetOpenCorrelator;
}
WB_PAGE_STATE;

typedef WB_PAGE_STATE  *         PWB_PAGE_STATE;
typedef PWB_PAGE_STATE *         PPWB_PAGE_STATE;

//
// Secondary shared memory structure.
//
// Although we are adding objects, not pages, since each objects can be
// placed on a new page, this structure is limited to the max number of
// pages.
//
#define WB_MAX_INSERTS  250

#if WB_MAX_PAGES > WB_MAX_INSERTS
#error Number of pages is now greater than number of insertable objects
#endif // WB_MAX_PAGES > WB_MAX_INSERTS



//
// Values for changedFlagAction
//
#define  RESET_CHANGED_FLAG      0
#define  DONT_RESET_CHANGED_FLAG  1


//
// Convert between page handles, workset IDs and indices into the page list
// array of pages.
//
#define PAGE_HANDLE_TO_INDEX(hPage) \
                          ((TSHR_UINT16) ((hPage) - FIRST_PAGE_WORKSET))

#define PAGE_INDEX_TO_HANDLE(index) \
                          ((WB_PAGE_HANDLE) ((index) + FIRST_PAGE_WORKSET))

#define PAGE_WORKSET_ID_TO_INDEX(worksetID) \
                          ((TSHR_UINT16) ((worksetID) - FIRST_PAGE_WORKSET))

#define PAGE_INDEX_TO_WORKSET_ID(index) \
                          ((OM_WORKSET_ID) ((index) + FIRST_PAGE_WORKSET))



//
// Client interface
//
#undef INTERFACE
#define INTERFACE   IWbClient

DECLARE_INTERFACE(IWbClient)
{
    STDMETHOD_(void, WBP_Stop)(THIS_ UTEVENT_PROC) PURE;
    STDMETHOD_(void, WBP_PostEvent)(THIS_ UINT delay, UINT event, UINT_PTR param1, UINT_PTR param2) PURE;
    STDMETHOD_(UINT, WBP_JoinCall)(THIS_ BOOL keep, UINT callID) PURE;

    STDMETHOD_(UINT, WBP_ValidateFile)(THIS_ LPCSTR fileName, HANDLE * phFile) PURE;
    STDMETHOD_(UINT, WBP_CancelLoad)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_ContentsLoad)(THIS_ LPCSTR fileName) PURE;
    STDMETHOD_(UINT, WBP_ContentsSave)(THIS_ LPCSTR fileName) PURE;
    STDMETHOD_(UINT, WBP_ContentsDelete)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_ContentsCountPages)(THIS_) PURE;
    STDMETHOD_(BOOL, WBP_ContentsChanged)(THIS_) PURE;
    STDMETHOD_(void, WBP_ContentsLock)(THIS_) PURE;

    STDMETHOD_(void, WBP_PageOrderLock)(THIS_) PURE;
    STDMETHOD_(void, WBP_Unlock)(THIS_) PURE;
    STDMETHOD_(WB_LOCK_TYPE, WBP_LockStatus)(THIS_ POM_OBJECT * ppObjPersonLock) PURE;

    STDMETHOD_(UINT, WBP_PageClear)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(void, WBP_PageClearConfirm)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageAddBefore)(THIS_ WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageAddAfter)(THIS_ WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageHandle)(THIS_ WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPageResult) PURE;
    STDMETHOD_(UINT, WBP_PageHandleFromNumber)(THIS_ UINT pageNumber, PWB_PAGE_HANDLE phPage) PURE;
    STDMETHOD_(UINT, WBP_PageNumberFromHandle)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageDelete)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(void, WBP_PageDeleteConfirm)(THIS_ WB_PAGE_HANDLE hPage) PURE;
    STDMETHOD_(UINT, WBP_PageMove)(THIS_ WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where) PURE;
    STDMETHOD_(UINT, WBP_PageCountGraphics)(THIS_ WB_PAGE_HANDLE hPage) PURE;

    STDMETHOD_(UINT, WBP_GraphicAllocate)(THIS_ WB_PAGE_HANDLE hPage, UINT length, PPWB_GRAPHIC ppGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicAddLast)(THIS_ WB_PAGE_HANDLE hPage, PWB_GRAPHIC pGraphic, PWB_GRAPHIC_HANDLE phGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicUpdateRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicUpdateConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicReplaceRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicReplaceConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicDeleteRequest)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicDeleteConfirm)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicMove)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, UINT where) PURE;
    STDMETHOD_(UINT, WBP_GraphicSelect)(THIS_ WB_PAGE_HANDLE hPage, POINT pt, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicGet)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PPWB_GRAPHIC ppGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicRelease)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic) PURE;
    STDMETHOD_(void, WBP_GraphicUnlock)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic) PURE;
    STDMETHOD_(UINT, WBP_GraphicHandle)(THIS_ WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic) PURE;

    STDMETHOD_(void, WBP_PersonHandleFirst)(THIS_ POM_OBJECT * ppObjUser) PURE;
    STDMETHOD_(UINT, WBP_PersonHandleNext)(THIS_ POM_OBJECT pObj, POM_OBJECT * ppObjNext) PURE;
    STDMETHOD_(void, WBP_PersonHandleLocal)(THIS_ POM_OBJECT * ppObjLocal) PURE;
    STDMETHOD_(UINT, WBP_PersonCountInCall)(THIS_) PURE;
    STDMETHOD_(UINT, WBP_GetPersonData)(THIS_ POM_OBJECT pObjPerson, PWB_PERSON pPerson) PURE;
    STDMETHOD_(UINT, WBP_SetLocalPersonData)(THIS_ PWB_PERSON pPerson) PURE;
    STDMETHOD_(void, WBP_PersonUpdateConfirm)(THIS_ POM_OBJECT pObj) PURE;
    STDMETHOD_(void, WBP_PersonReplaceConfirm)(THIS_ POM_OBJECT pObj) PURE;
    STDMETHOD_(void, WBP_PersonLeftConfirm)(THIS_ POM_OBJECT pObj) PURE;

    STDMETHOD_(UINT, WBP_SyncPositionGet)(THIS_ PWB_SYNC pSync) PURE;
    STDMETHOD_(UINT, WBP_SyncPositionUpdate)(THIS_ PWB_SYNC pSync) PURE;
};

class WbClient : public IWbClient
{
public:
// IWbClient interface
    STDMETHODIMP_(void) WBP_Stop(UTEVENT_PROC eventProc);
    STDMETHODIMP_(void) WBP_PostEvent(UINT delay, UINT event, UINT_PTR param1, UINT_PTR param2);
    STDMETHODIMP_(UINT) WBP_JoinCall(BOOL keep, UINT callID);

    STDMETHODIMP_(UINT) WBP_ValidateFile(LPCSTR fileName, HANDLE * phFile);
    STDMETHODIMP_(UINT) WBP_CancelLoad(void);
    STDMETHODIMP_(UINT) WBP_ContentsLoad(LPCSTR fileName);
    STDMETHODIMP_(UINT) WBP_ContentsSave(LPCSTR fileName);
    STDMETHODIMP_(UINT) WBP_ContentsDelete(void);
    STDMETHODIMP_(UINT) WBP_ContentsCountPages(void);
    STDMETHODIMP_(BOOL) WBP_ContentsChanged(void);
    STDMETHODIMP_(void) WBP_ContentsLock(void);

    STDMETHODIMP_(void) WBP_PageOrderLock(void);
    STDMETHODIMP_(void) WBP_Unlock(void);
    STDMETHODIMP_(WB_LOCK_TYPE) WBP_LockStatus(POM_OBJECT * ppObjPersonLock);

    STDMETHODIMP_(UINT) WBP_PageClear(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(void) WBP_PageClearConfirm(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageAddBefore(WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageAddAfter(WB_PAGE_HANDLE hRefPage, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageHandle(WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPageResult);
    STDMETHODIMP_(UINT) WBP_PageHandleFromNumber(UINT pageNumber, PWB_PAGE_HANDLE phPage);
    STDMETHODIMP_(UINT) WBP_PageNumberFromHandle(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageDelete(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(void) WBP_PageDeleteConfirm(WB_PAGE_HANDLE hPage);
    STDMETHODIMP_(UINT) WBP_PageMove(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    STDMETHODIMP_(UINT) WBP_PageCountGraphics(WB_PAGE_HANDLE hPage);

    STDMETHODIMP_(UINT) WBP_GraphicAllocate(WB_PAGE_HANDLE hPage, UINT length, PPWB_GRAPHIC ppGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicAddLast(WB_PAGE_HANDLE hPage, PWB_GRAPHIC pGraphic, PWB_GRAPHIC_HANDLE phGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicUpdateRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicUpdateConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicReplaceRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicReplaceConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicDeleteRequest(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(void) WBP_GraphicDeleteConfirm(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicMove(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, UINT where);
    STDMETHODIMP_(UINT) WBP_GraphicSelect(WB_PAGE_HANDLE hPage, POINT pt, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicGet(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PPWB_GRAPHIC ppGraphic);
    STDMETHODIMP_(void) WBP_GraphicRelease(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC pGraphic);
    STDMETHODIMP_(void) WBP_GraphicUnlock(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic);
    STDMETHODIMP_(UINT) WBP_GraphicHandle(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hRefGraphic, UINT where, PWB_GRAPHIC_HANDLE phGraphic);

    STDMETHODIMP_(void) WBP_PersonHandleFirst(POM_OBJECT * ppObjUser);
    STDMETHODIMP_(UINT) WBP_PersonHandleNext(POM_OBJECT pObj, POM_OBJECT * ppObjNext);
    STDMETHODIMP_(void) WBP_PersonHandleLocal(POM_OBJECT * ppObjLocal);
    STDMETHODIMP_(UINT) WBP_PersonCountInCall(void);
    STDMETHODIMP_(UINT) WBP_GetPersonData(POM_OBJECT pObjPerson, PWB_PERSON pPerson);
    STDMETHODIMP_(UINT) WBP_SetLocalPersonData(PWB_PERSON pPerson);
    STDMETHODIMP_(void) WBP_PersonUpdateConfirm(POM_OBJECT pObj);
    STDMETHODIMP_(void) WBP_PersonReplaceConfirm(POM_OBJECT pObj);
    STDMETHODIMP_(void) WBP_PersonLeftConfirm(POM_OBJECT pObj);

    STDMETHODIMP_(UINT) WBP_SyncPositionGet(PWB_SYNC pSync);
    STDMETHODIMP_(UINT) WBP_SyncPositionUpdate(PWB_SYNC pSync);

    BOOL    WbInit(PUT_CLIENT putClient, UTEVENT_PROC eventProc);

protected:
// Internal functions
    PWB_PAGE_STATE GetPageState(WB_PAGE_HANDLE hPage)
    {
        ASSERT((hPage >= FIRST_PAGE_WORKSET) && (hPage <= FIRST_PAGE_WORKSET + WB_MAX_PAGES - 1));
        return(&((m_pageStates)[PAGE_HANDLE_TO_INDEX(hPage)]));
    }

    void    wbContentsDelete(UINT changedFlagAction);
    UINT    wbLock(WB_LOCK_TYPE lockType);
    void    wbUnlock(void);
    UINT    wbPageHandle(WB_PAGE_HANDLE hPage, UINT where, PWB_PAGE_HANDLE phPage);
    UINT    wbPageHandleFromNumber(UINT pageNumber, PWB_PAGE_HANDLE phPage);
    UINT    wbPageClear(WB_PAGE_HANDLE hPage, UINT changedFlagAction);
    void    wbPageClearConfirm(WB_PAGE_HANDLE hPage);
    UINT    wbPageAdd(WB_PAGE_HANDLE hRefPage, UINT where, PWB_PAGE_HANDLE phPage, UINT changedFlagAction);
    BOOL    wbGetNetUserID(void);
    UINT    wbPageMove(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    UINT    wbPersonGet(POM_OBJECT pObjPerson, PWB_PERSON pPerson);
    UINT    wbWriteSyncControl(PWB_SYNC pSync, BOOL create);
    BOOL    wbGraphicLocked(WB_PAGE_HANDLE hPage, WB_GRAPHIC_HANDLE hGraphic, POM_OBJECT* ppObjPersonLock);
    UINT    wbGraphicSelectPrevious(WB_PAGE_HANDLE hPage, LPPOINT pPoint, WB_GRAPHIC_HANDLE hGraphic, PWB_GRAPHIC_HANDLE phGraphic);

    void    wbError(void);
    void    wbJoinCallError(void);
    UINT    wbAddLocalUserObject(void);
    UINT    wbPersonUpdate(PWB_PERSON pUser);

    WB_PAGE_HANDLE  wbGetEmptyPageHandle(void);
    WB_PAGE_HANDLE  wbGetReadyPageHandle(void);
    PWB_PAGE_STATE  wbPageState(WB_PAGE_HANDLE hPage);
    void    wbPagesPageAdd(WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    UINT    wbPageOrderPageNumber(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hPage);
    void    wbPageOrderPageAdd(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hRefPage, WB_PAGE_HANDLE hPage, UINT where);
    void    wbPageOrderPageDelete(PWB_PAGE_ORDER pPageOrder, WB_PAGE_HANDLE hPage);

    friend BOOL CALLBACK wbCoreEventHandler(LPVOID clientData, UINT event, UINT_PTR param1, UINT_PTR param2);
    BOOL    wbEventHandler(UINT event, UINT_PTR param1, UINT_PTR param2);

    friend void CALLBACK wbCoreExitHandler(LPVOID clientData);
    void    wbExitHandler(void);

    BOOL    wbOnWsGroupRegisterCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWsGroupMoveCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWsGroupMoveInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    void    wbOnControlWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnPageWorksetOpenCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetLockCon(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetUnlockInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnWorksetClearInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnObjectAddInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectMoveInd(UINT_PTR param1, UINT_PTR param2);
    BOOL    wbOnObjectDeleteInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectUpdateInd(UINT_PTR param1, POM_OBJECT pObj);
    BOOL    wbOnObjectReplaceInd(UINT_PTR param1, POM_OBJECT pObj);

    void    wbOnControlWorksetsReady(void);
    void    wbProcessLockNotification(void);
    void    wbCompleteRegistration(void);
    void    wbLeaveCall(void);

    void    wbOnGraphicObjectAddInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectUpdateInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectReplaceInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectMoveInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);
    void    wbOnGraphicObjectDeleteInd(OM_WORKSET_ID worksetID, POM_OBJECT pObj);

    UINT    wbPageWorksetOpen(WB_PAGE_HANDLE hPage, UINT localOrExternal);
    BOOL    wbOnWBPPageClearInd(WB_PAGE_HANDLE hPage);
    void    wbOnPageDelete(void);
    UINT    wbPageSave(WB_PAGE_HANDLE hPage, HANDLE hFile);
    UINT    wbObjectSave(HANDLE hFile, LPBYTE pData, UINT length);
    void    wbStartContentsLoad(void);
    void    wbPageLoad(void);
    UINT    wbObjectLoad(HANDLE hFile, WB_PAGE_HANDLE hPage, PPWB_GRAPHIC ppGraphic);

    UINT    wbGetPageObjectType(POM_OBJECT pObj, UINT * pObjectType);
    void    wbOnPageObjectAddInd(POM_OBJECT pObj);
    void    wbOnPageControlObjectAddInd(POM_OBJECT pObj);
    void    wbOnPageObjectReplaceInd(POM_OBJECT pObj);
    void    wbOnPageObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnLockControlObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnPageControlObjectReplaceInd(void);

    void    wbProcessPageControlChanges(void);
    UINT    wbWriteLock(void);
    void    wbReadLock(void);
    void    wbSendLockNotification(void);
    UINT    wbWritePageControl(BOOL create);

    UINT    wbCreateSyncControl(void);
    void    wbOnSyncObjectAddInd(POM_OBJECT pObj);
    void    wbOnSyncObjectReplaceInd(POM_OBJECT pObj);

    void    wbOnUserObjectAddInd(POM_OBJECT pObj);
    void    wbOnUserObjectDeleteInd(POM_OBJECT pObj);
    void    wbOnUserObjectUpdateInd(POM_OBJECT pObj);
    void    wbOnUserObjectReplaceInd(POM_OBJECT pObj);

    UINT    wbSelectPersonColor(void);
    void    wbCheckPersonColor(POM_OBJECT hCheckObject);

    BOOL    wbOnWBPLock(void);
    BOOL    wbOnWBPLockFailed(void);
    BOOL    wbOnWBPUnlocked(void);
    BOOL    wbOnWBPPageOrderUpdated(void);
    void    wbProcessInsertObjects(void);
    UINT    wbDiscardInsertObjects(UINT cObject);

    void    wbClientReset(void);
    BOOL    wbCheckReadyPages(void);


// Data
    PUT_CLIENT      m_putTask;            // Task handle
    POM_CLIENT      m_pomClient;          // ObMan handle
    PCM_CLIENT      m_pcmClient;          // Call Manager secondary handle.

    OM_WSGROUP_HANDLE   m_hWSGroup;
    BYTE            m_changed;
    NET_UID         m_clientNetID;        // Net ID of local person

    UINT            m_state;              // Major state
    UINT            m_subState;           // Sub-state of major state

    UINT            m_errorState;         // Fatal error indicator

    OM_CORRELATOR   m_wsgroupCorrelator;
    OM_CORRELATOR   m_worksetOpenCorrelator;

    POM_OBJECT      m_pObjPageControl;
    POM_OBJECT      m_pObjSyncControl;

    POM_OBJECT      m_pObjLocal;       // Ptr to local person
    OM_OBJECT_ID    m_personID;           // OM ID of local person
                                        // adding clientNetID field

    WB_LOCK_STATE   m_lockState;          // Lock state
    OM_CORRELATOR   m_lockCorrelator;     // Correlator for locking
    WORD            m_lockRequestType;    // Type of lock request
    WB_LOCK_TYPE    m_lockType;           // Current lock type

    POM_OBJECT      m_pObjLock;        // Handle of the lock object
    POM_OBJECT      m_pObjPersonLock;  // Person who has lock.

    UINT            m_loadState;          // Load state
    HANDLE          m_hLoadFile;          // File handle (used during loading)
    WB_PAGE_HANDLE  m_loadPageHandle;     // Page handle (used during loading)

    UINT            m_colorId;            // Color id for the local person
    UINT            m_countReadyPages;    // Number of page worksets ready
                                        // for use.
    WB_PAGE_ORDER   m_pageOrder;          // List of active pages
    WB_PAGE_STATE   m_pageStates[WB_MAX_PAGES]; // List of page state flags
};



//
//
// Name:    CreateWBObject()
//
// Purpose: Register the caller with the Whiteboard Core.  This function
//          gives the core the ability to inform the front-end of events
//          caused by other call participants.
//
//          The front-end should follow this call by a call to WBP_JoinCall.
//
//
BOOL WINAPI CreateWBObject(UTEVENT_PROC eventProc, IWbClient** ppwbClient);


//
// Convert between ObMan object pointers and core graphic pointers
//
PWB_GRAPHIC __inline GraphicPtrFromObjectData(POM_OBJECTDATA pData)
{
    return((PWB_GRAPHIC)&(pData->data));
}

POM_OBJECTDATA  __inline ObjectDataPtrFromGraphic(PWB_GRAPHIC pGraphic)
{
    return((POM_OBJECTDATA)((LPBYTE)pGraphic - offsetof(OM_OBJECTDATA, data)));
}


//
// QUIT_LOCKED
//
// Leave the function if another person has the contents or page order
// lock.
//
//
#define QUIT_LOCKED(result)                                         \
    if (m_lockState == LOCK_STATE_LOCKED_OUT)                         \
    {                                                                        \
      result = WB_RC_LOCKED;                                                 \
      DC_QUIT;                                                               \
    }

//
// QUIT_IF_CANCELLING_LOCK
//
// Leave the function if we are processing a lock-cancel request
//
//
#define QUIT_IF_CANCELLING_LOCK(result, errCode)                    \
    if (m_lockState == LOCK_STATE_CANCEL_LOCK)                        \
    {                                                                        \
        TRACE_OUT(("Already cancelling lock"));                            \
        result = errCode;                                                    \
        DC_QUIT;                                                             \
    }

//
// QUIT_CONTENTS_LOCKED
//
// Leave the function if another person has the contents lock.
//
//
#define QUIT_CONTENTS_LOCKED(result)                                \
    if (  (m_lockState == LOCK_STATE_LOCKED_OUT)                                        \
        && (m_lockType == WB_LOCK_TYPE_CONTENTS))                     \
    {                                                                        \
      result = WB_RC_LOCKED;                                                 \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_GOT_LOCK
//
// Leave the function if the client does not have a lock.
//
//
#define QUIT_NOT_GOT_LOCK(result)                                   \
    if (m_lockState != LOCK_STATE_GOT_LOCK)                          \
    {                                                                        \
      result = WB_RC_NOT_LOCKED;                                             \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_PROCESSING_LOCK
//
// Leave the function if the client has not previoulsy requested a lock.
//
//
#define QUIT_NOT_PROCESSING_LOCK(result)                            \
    if ( (m_lockState != LOCK_STATE_GOT_LOCK    ) &&                  \
         (m_lockState != LOCK_STATE_PENDING_LOCK) &&                  \
         (m_lockState != LOCK_STATE_PENDING_ADD) )                    \
    {                                                                        \
        TRACE_OUT((                                                          \
                   "Not locked: Client lock state %d", m_lockState)); \
        result = WB_RC_NOT_LOCKED;                                           \
        DC_QUIT;                                                             \
    }

//
// QUIT_NOT_GOT_CONTENTS_LOCK
//
// Leave the function if the client does not have the contents lock.
//
//
#define QUIT_NOT_GOT_CONTENTS_LOCK(result)                          \
                                                                             \
    QUIT_NOT_GOT_LOCK(result);                                      \
                                                                             \
    if (m_lockType != WB_LOCK_TYPE_CONTENTS)                          \
    {                                                                        \
      result = WB_RC_NOT_LOCKED;                                             \
      DC_QUIT;                                                               \
    }

//
// QUIT_NOT_GOT_PAGE_ORDER_LOCK
//
// This is currently the same as QUIT_NOT_GOT_LOCK as there are only the
// page order and contents locks.  The contents lock is considered to
// include the page order lock.
//
//
#define QUIT_NOT_GOT_PAGE_ORDER_LOCK(result)                        \
    QUIT_NOT_GOT_LOCK(result)

//
// QUIT_GRAPHIC_LOCKED
//
// Leave the function if another person has the graphic locked.
//
//
#define QUIT_GRAPHIC_LOCKED(hPage, hGraphic, result)                \
  {                                                                          \
    POM_OBJECT pObjPerson;                                              \
    if (wbGraphicLocked(hPage, hGraphic, &pObjPerson))    \
    {                                                                        \
      if (pObjPerson != m_pObjLocal)                             \
      {                                                                      \
          result = WB_RC_GRAPHIC_LOCKED;                                     \
          DC_QUIT;                                                           \
      }                                                                      \
    }                                                                        \
  }


//
// QUIT_GRAPHIC_NOT_LOCKED
//
// Leave the function if the local user does not have the graphic locked.
//
//
#define QUIT_GRAPHIC_NOT_LOCKED(pGraphic, result)                            \
    if (pGraphic->locked != WB_GRAPHIC_LOCK_LOCAL)                           \
    {                                                                        \
      result = WB_RC_GRAPHIC_NOT_LOCKED;                                     \
      DC_QUIT;                                                               \
    }




//
//
// Name:    WBP_JoinCall
//
// Purpose: Join a call.  This function registers with the Whiteboard
//          workset group.  It is asynchronous giving one of the following
//          events as a result:
//
//          WBP_EVENT_JOIN_CALL_OK
//          WBP_EVENT_JOIN_CALL_FAILED.
//
//          No other WBP_... functions should be called until the call
//          has been successfully joined.
//
// Returns: 0 if successful
//          OM_RC_...     - in case of workset registration/move failure:
//                          see om.h
//
//

//
//
// Name:    WBP_ContentsLoad
//
// Purpose: Load a new file from disc into the Whiteboard worksets.  The
//          caller must hold the Whiteboard page order lock before calling
//          this function. This function is asynchronous; when it returns,
//          the file will not be completely loaded. The front-end will
//          receive a WBP_EVENT_LOAD_COMPLETE when the load completes, or
//          a WBP_EVENT_LOAD_FAILED if an asynchronous error occurs
//
// Returns: 0 if successful
//          WB_RC_LOCKED          - the whiteboard is locked by another user
//          WB_RC_NOT_LOCKED      - the caller doesnt have the contents lock
//          WB_RC_NO_FILE         - the specified file could not be found
//          WB_RC_BAD_FILE_FORMAT - the file is not of the correct format
//
//

//
//
// Name:    WBP_ContentsSave
//
// Purpose: Save the current Whiteboard contents to disc.  The Whiteboard
//          contents can be updated by other users while this function is
//          processing.  To prevent this acquire the Whiteboard contents
//          lock before calling it.
//
// Returns: 0 if successful
//          WB_RC_DISK_FULL       - not enough space on disk
//          WB_RC_PATH_NOT_FOUND  - the specified path does not exist
//          WB_RC_WRITE_FAILED    - writing to the file failed - the file is
//                                  read-only.
//
//


//
//
// Name:    WBP_ContentsDelete
//
// Purpose: Delete all the Whiteboard pages (leaving only an empty page 1).
//          The caller must hold the Whiteboard contents or page order lock
//          before calling this function.
//
//          For each page to be deleted, each person in the call receives
//          the following event:
//
//          WBP_EVENT_PAGE_DELETE_IND
//
// Returns: 0 if successful
//          WB_RC_LOCKED     - another person has the contents lock
//          WB_RC_NOT_LOCKED - the local person does not hold the page order
//                             lock.
//
//


//
//
// Name:    WBP_ContentsChanged
//
// Purpose: Returns an indication of whether the contents of the Whiteboard
//          have changed since WBP_ContentsSave) WBP_ContentsLoad or
//          WBP_ContentsDelete was last called.
//
//


//
//
// Name:    WBP_ContentsLock
//
// Purpose: Lock the Whiteboard contents.  This is an asynchronous function
//          generating one of the following events:
//
//          WBP_EVENT_CONTENTS_LOCKED
//          WBP_EVENT_LOCK_FAILED.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageOrderLock
//
// Purpose: Lock the Whiteboard page order.  This is an asynchronous
//          function generating one of the following events:
//
//          WBP_EVENT_PAGES_LOCKED
//          WBP_EVENT_LOCK_FAILED.
//
//
// Returns: none
//
//


//
//
// Name:    WBP_Unlock
//
// Purpose: Unlock the Whiteboard.  This is an asynchronous function
//          generating the following event:
//
//          WBP_EVENT_UNLOCKED
//
//          This function may be called anytine after a call to WBP_Lock -
//          an application does not need to wait for a WBP_EVENT_LOCKED
//          event after calling WBP_Lock before calling WBP_Unlock.
//
//


//
//
// Name:    WBP_LockStatus
//
// Purpose: Return the current state of the available locks
//
//
// Returns: None (always succeeds)
//
//


//
//
// Name:    WBP_ContentsCountPages
//
// Purpose: Return the number of pages in the Whiteboard.
//
// Returns: None
//
//


//
//
// Name:    WBP_PageClear
//
// Purpose: Clear the page (deleting all graphic objects on it).  This is
//          an asynchronous function generating the following event:
//
//          WBP_EVENT_PAGE_CLEARED
//
//          No objects are actually deleted until the WBP_PageClearConfirm
//          function is called in response to the event.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE   - the specified page handle is bad
//          WB_RC_LOCKED            - another user has a lock on the white-
//                                    board contents.
//
//


//
//
// Name:    WBP_PageClearConfirm
//
// Purpose: Confirm the clearing of a page.  All graphic objects on the page
//          will be removed.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageAddBefore
//
// Purpose: Add a new page before a specified page.  This
//          function requires that the caller hold the Whiteboard contents
//          or page order lock before it is called. The following event is
//          generated for each user in the call:
//
//          WBP_EVENT_PAGE_ORDER_UPDATED
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the hRefPage handle is invalid
//          WB_RC_LOCKED          - the whiteboard is locked by another
//                                  user
//          WB_RC_NOT_LOCKED      - the local user does not hold the page
//                                  order lock
//          WB_RC_TOO_MANY_PAGES  - the maximum number of pages has been
//                                  reached.
//
//


//
//
// Name:    WBP_PageAddAfter
//
// Purpose: Add a new page after a specified page.  This
//          function requires that the caller hold the Whiteboard contents
//          or page order lock before it is called. The following event is
//          generated for each user in the call:
//
//          WBP_EVENT_PAGE_ORDER_UPDATED
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the hRefPage handle is invalid
//          WB_RC_LOCKED          - the whiteboard is locked by another user
//          WB_RC_NOT_LOCKED      - the local user does not hold the page
//                                  order lock
//          WB_RC_TOO_MANY_PAGES  - the maximum number of pages has been
//                                  reached.
//
//


//
//
// Name:    WBP_PageHandle
//
// Purpose: Return the handle of another page in the Whiteboard.
//
// Returns: 0 if successful
//
//


//
//
// Name:    WBP_PageHandleFromNumber
//
// Purpose: Return the handle of the page specified by page number
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_NUMBER - pageNumber is not a valid page number
//
//


//
//
// Name:    WBP_PageNumberFromHandle
//
// Purpose: Return the number of the page specified by handle
//
//


//
//
// Name:    WBP_PageDelete
//
// Purpose: Delete the specified page. The local user must have the white-
//          board contents or page order lock before calling this function.
//          This call gives rise to two events:
//
//          WBP_EVENT_PAGE_CLEARED_IND - indicating that all the objects in
//                                 the page have been deleted. The front-end
//                                 must respond by calling
//                                 WBP_PageClearConFirm - no graphic objects
//                                 will be deleted until this is done.
//
//          WBP_EVENT_PAGE_ORDER_UPDATED - informing the front-end that the
//                                 list of pages has changed
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//          WB_RC_LOCKED          - another client has the contents locked
//          WB_RC_NOT_LOCKED      - the local user does not have the page
//                                  order lock.
//
//


//
//
// Name:    WBP_PageDeleteConfirm
//
// Purpose: Confirm the deletion of a page.
//
// Returns: none
//
//


//
//
// Name:    WBP_PageMove
//
// Purpose: Moves one page after or before another.  The user must hold
//          the Whiteboard contents or page order lock before calling this
//          function.  If successful this function will result in a
//          WBP_EVENT_PAGE_ORDER_UPDATED event.
//
// Returns: 0 if successful
//          WB_RC_LOCKED          - another client has the contents locked
//          WB_RC_NOT_LOCKED      - the local user does not have the page
//                                  order lock.
//          WB_RC_BAD_PAGE_HANDLE - either hRefPage or hPage is not a valid
//                                  page handle
//
//


//
//
// Name:    WBP_PageCountGraphics
//
// Purpose: Return the number of graphics on the page
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicAllocate
//
// Purpose: Allocate memory for a graphic object. Note: All memory used for
//          graphics passed to the Whiteboard core must be allocated using
//          the function described here.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//          WB_RC_OUT_OF_MEMORY   - could not allocate the amount of memory
//                                  requested.
//
//


//
//
// Name:    WBP_GraphicAddLast
//
// Purpose: Add a graphic object to the Whiteboard contents.  The graphic
//          must previously have been allocated using WBP_GraphicAllocate.
//          It is added to the end (topmost Z-Order) of the specified page.
//          The following event is generated:
//
//          WBP_EVENT_GRAPHIC_ADDED.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE - the specified page handle is invalid
//
//


//
//
// Name:    WBP_GraphicUpdateRequest
//
// Purpose: Update a graphic object in the Whiteboard contents.  This call
//          allows only the WB_GRAPHIC header part of the graphic object
//          to be altered.
//
//          This call only starts the process of updating a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_UPDATE_IND event
//          will be posted to the caller.  The caller must then call
//          WBP_GraphicUpdateConfirm.
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//
//


//
//
// Name:    WBP_GraphicUpdateConfirm
//
// Purpose: Complete the process of updating a graphic object.
//          (See WBP_GraphicUpdateRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicReplaceRequest
//
// Purpose: Replace a graphic object in the Whiteboard contents.  This call
//          allows the entire object to be replaced with another object.
//
//          This call only starts the process of replacing a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_REPLACE_IND
//          event will be posted to the caller.  The caller must then call
//          WBP_GraphicReplaceConfirm.
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//


//
//
// Name:    WBP_GraphicReplaceConfirm
//
// Purpose: Complete the process of replacing a graphic object.
//          (See WBP_GraphicReplaceRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicDeleteRequest
//
// Purpose: Delete a graphic object in the Whiteboard contents.
//
//          This call only starts the process of deleting a graphic.  If
//          this function is successful a WBP_EVENT_GRAPHIC_DELETE_IND event
//          will be posted to the caller.  The caller must then call
//          WBP_GraphicDeleteConfirm.
//
// Returns: 0 if successful
//
//          WB_RC_LOCKED             - another client has the whiteboard
//                                     contents locked
//          WB_RC_OBJECT_LOCKED      - another client has the specified
//                                     graphic object locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//


//
//
// Name:    WBP_GraphicDeleteConfirm
//
// Purpose: Complete the process of deleting a graphic object.
//          (See WBP_UpdateGraphicRequest.)
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicMove
//
// Purpose: Move a graphic to the end of the page (topmost Z-order).
//          On successful completion, the following event is generated:
//
//          WBP_EVENT_GRAPHIC_MOVED
//
// Returns: 0 if successful
//          WB_RC_LOCKED             - another user has the whiteboard
//                                     contents locked.
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_GRAPHIC_HANDLE - the specified graphic handle is
//                                     invalid
//
//


//
//
// Name:    WBP_GraphicSelect
//
// Purpose: Retrieve the handle of the topmost Z-order graphic whose
//          bounding rectangle contains the specified point.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_NO_SUCH_GRAPHIC    - there is no graphic at the point
//                                     specified.
//
//


//
//
// Name:    WBP_GraphicGet
//
// Purpose: Retrieve a graphic object.  After this graphic has been
//          retrieved it will remain in memory until explicitly released
//          by a call to WBP_ReleaseGraphic.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//          WB_RC_BAD_OBJECT_HANDLE  - the specified graphic handle is
//                                     invalid.
//
//


//
//
// Name:    WBP_GraphicRelease
//
// Purpose: Release a previously retrieved graphic.
//
// Returns: none
//
//


//
//
// Name:    WBP_GraphicUnlock
//
// Purpose: Unlock a graphic. This function succeeds even if the contents
//          are locked.
//
// Returns: none
//
//



//
//
// Name:    WBP_GraphicHandle
//
// Purpose: Return the handle of the first graphic in the specified page.
//
// Returns: 0 if successful
//          WB_RC_BAD_PAGE_HANDLE    - the specified page handle is invalid
//
//


//
//
// Name:    WBP_PersonHandleFirst
//
// Purpose: Return the handle of the first user in the call
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonHandleNext
//
// Purpose: Return the handle of the next user in the call
//
// Returns: 0 if successful
//          WB_RC_BAD_USER_HANDLE    - the specified user handle is invalid
//          WB_RC_NO_SUCH_USER       - there is no next user: hRefUser is
//                                     the last in the users workset.
//
//

//
//
// Name:    WBP_PersonHandleLocal
//
// Purpose: Return the handle of the local user
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonCountInCall
//
// Purpose: Retrieves information about the global state of the Whiteboard
//          FP in the call.
//
//


//
//
// Name:    WBP_GetPersonData
//
// Purpose: Retrieve the person object specified by <hPerson>.
//
// Returns: 0 if successful
//          OM_RC_...
//          WB_RC_BAD_PERSON_HANDLE - the specified person handle is invalid
//
//

//
//
// Name:    WBP_SetLocalPersonData
//
// Purpose: Sets the data for the local person.
//
// Returns: 0 if successful
//          OM_RC_...
//          WB_RC_BAD_PERSON_HANDLE - the specified person handle is invalid
//
//



//
//
// Name:    WBP_PersonUpdateConfirm
//
// Purpose: Complete the process of updating a user object.
//
// Returns: None
//
//


//
//
// Name:    WBP_PersonReplaceConfirm
//
// Purpose: Complete the process of replacing a user object.
//
// Returns: None
//
//

//
//
// Name:    WBP_PersonLeftConfirm
//
// Purpose: Complete the process of updating a user object.
//
// Returns: None
//
//


//
//
// Name:    WBP_SyncPositionGet
//
// Purpose: Retrieve the details of the current sync position.
//
// Returns: 0 if successful
//
//


//
//
// Name:    WBP_SyncPositionUpdate
//
// Purpose: Set the current sync details
//
// Returns: 0 if successful
//
//

//
//
// Name:    WBP_CancelLoad
//
// Purpose: Cancel a load in progress
//
// Returns: 0 if successful
//          WB_RC_NOT_LOADING   if a load is not in progress
//
//


//
//
// Name:    WBP_ValidateFile
//
// Purpose: Validate a whiteboard file
//
// Returns: 0 if successful
//          Error if not
//
//



//
//
// Event Descriptions
//
// The following event are generated during core processing.
//
//
//

//
//
// Name:    WBP_EVENT_JOIN_CALL_OK
//
// Purpose: Inform the client that the call was joined successfully.
//          This is the very first event that the client will receive
//          after successful registration and joining of a call.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_JOIN_CALL_FAILED
//
// Purpose: Inform the client that joining of the call failed. The core is
//          not in any call. The next call made to it should be one of
//          WBP_JoinCall and WBP_Stop.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_NETWORK_LOST
//
// Purpose: Inform the client that communication with other clients
//          is no longer possible. The contents of the core are still
//          available. Any locks held by remote people have been released.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_ERROR
//
// Purpose: Inform the client that a fatal error has occurred in the core.
//          The client should deregister (WBP_ContentsSave can be called
//          before the application quits but may not be successful).
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_CONTENTS_LOCKED
//          WBP_EVENT_PAGE_ORDER_LOCKED
//
// Purpose: Inform the client that the contents are now locked. This event
//          is be generated both when remote clients get the lock and when
//          the local client acquires it. The parameter indicates who now
//          has the lock. Note that this should always be tested even if
//          this event arrives when the local client is waiting for lock
//          confirmation: it may indicate that the remote client got in
//          just before the local.
//
//          These events can indicate a change in lock status rather than a
//          lock being acquired. For example a client which holds the
//          Page Order Lock can upgrade that lock to a Contents Lock by
//          calling WBP_ContentsLock. All other clients will then receive
//          WBP_EVENT_CONTENTS_LOCKED events informing them of the change.
//
// Params:  param16 reserved
//          param32 Handle of person who has acquired the lock
//
//

//
//
// Name:    WBP_EVENT_UNLOCKED
//
// Purpose: Inform the client that the contents are no longer locked. This
//          event is only received when a remote client releases the lock.
//          Local clients call the synchronous WBP_Unlock - the lock is
//          released on return from the function.
//
// Params:  param16 reserved
//          param32 Handle of person who has released the lock
//
//

//
//
// Name:    WBP_EVENT_LOCK_FAILED
//
// Purpose: Inform the client that the lock request issued previously has
//          failed. This will usually be because another person has acquired
//          the lock.
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_PAGE_CLEAR_IND
//
// Purpose: Inform the client that a page clear has been requested. The
//          client should call WBP_PageClearConfirm as soon as possible.
//
// Params:  param16 Handle of the page to be cleared
//
//

//
//
// Name:    WBP_EVENT_PAGE_ORDER_UPDATED
//
// Purpose: Inform the client that the order of pages has changed. This
//          event is generated by WBP_PageMove... and WBP_PageAdd...
//          functions (from both the local and remote clients).
//
// Params:  None
//
//

//
//
// Name:    WBP_EVENT_PAGE_DELETE_IND
//
// Purpose: Inform the client that a delete request has been issued for
//          a page. The client should call WBP_PageDeleteConfirm as soon
//          as possible.
//
// Params:  param16 Handle of the page being deleted
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_ADDED
//
// Purpose: Inform the client that a new graphic object has been added to
//          a page. This event is generated for all object adds including
//          those originating with the client.
//
// Params:  param16 Handle of the page to which the object has been added
//          param32 Handle of the object which has been added
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_MOVED
//
// Purpose: Inform the client that a graphic object has been moved within
//          a page. This event is generated for all object moves including
//          those originating with the client.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_UPDATE_IND
//
// Purpose: Inform the client that a request to update a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicUpdateConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_REPLACE_IND
//
// Purpose: Inform the client that a request to replace a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicReplaceConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_GRAPHIC_DELETE_IND
//
// Purpose: Inform the client that a request to delete a graphic object has
//          been issued. No changes have yet been made to the graphic.
//          The client should call WBP_GraphicDeleteConfirm as soon as
//          possible.
//
// Params:  param16 Handle of the page affected
//          param32 Handle of the object affected
//
//

//
//
// Name:    WBP_EVENT_PERSON_JOINED
//
// Purpose: Inform the client that a new person has joined the call.
//
// Params:  param16 reserved
//          param32 Handle of the person that has just joined
//
//

//
//
// Name:    WBP_EVENT_PERSON_LEFT
//
// Purpose: Inform the client that a person has left the call.
//
// Params:  param16 reserved
//          param32 Handle of the person that has just left
//
//

//
//
// Name:    WBP_EVENT_PERSON_UPDATED
//
// Purpose: Inform the client that the some person information has changed.
//
// Params:  param16 reserved
//          param32 Handle of the person affected
//
//

//
//
// Name:    WBP_EVENT_LOAD_COMPLETE
//
// Purpose: Inform the client that an attempt to load a Whiteboard file
//          has completed successfully.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_LOAD_FAILED
//
// Purpose: Inform the client that an attempt to load a page from a
//          whiteboard file has failed. The load is cancelled at the point
//          the error occurred, but any objects/pages which were
//          successfully read in will remain.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_INSERT_OBJECTS
//
// Purpose: Inform the client that objects created by the secondary api
//          client may be inserted. This event is posted when the whiteboard
//          lock has been released.
//
// Params:  none
//
//

//
//
// Name:    WBP_EVENT_INSERT_NEXT
//
// Purpose: Inform the client that the next secondary api object may be
//          inserted.
//
// Params:  param16 index of the object to be inserted
//          param32 reserved
//
//

//
//
// Name:    WBP_EVENT_SYNC_POSITION_UPDATED
//
// Purpose: Inform the client that the sync position information has been
//          updated.
//
// Params:  param16 reserved
//          param32 reserved
//
//





#endif // _HPP_WB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\het.cpp ===
#include "precomp.h"


//
// HET.CPP
// Window, task tracking hooks
//
// Copyright(c) Microsoft 1997-
//



//
// Entry Point
//
int APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    //
    // DONT ADD ANY TRACING TO THIS FUNCTION OR ANY FUNCTIONS CALLED FROM
    // HERE - WE CANNOT GUARANTEE THAT THE TRACE DLL IS IN A FIT STATE TO
    // DO ANYTHING FROM HERE.
    //

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            InitDebugModule(TEXT("MNMHOOK"));
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            HOOK_Load(hInstance);
        }
        break;

        case DLL_PROCESS_DETACH:
        {
            TRACE_OUT(("HOOK unloaded for app %s", GetCommandLine()));

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            //
            // NULL this out in debug to see if our hooks get called on
            // this process while we are exiting.
            //
            g_hookInstance = NULL;

            ExitDebugModule();
#endif
        }
        break;

        case DLL_THREAD_ATTACH:
        {
            HOOK_NewThread();
        }
        break;
    }

    return(TRUE);
}


//
// HOOK_Load()
// This saves our instance handle and gets hold of various routines we
// need for window tracking.  We can not link to these functions directly
// since some of them only exist in NT 4.0 SP-3, but we want you to be able
// to view and control without it.
//
void    HOOK_Load(HINSTANCE hInst)
{
    DWORD   dwExeType;
    LPSTR   lpT;
    LPSTR   lpNext;
    LPSTR   lpLastPart;
    char    szExeName[MAX_PATH+1];

    DebugEntry(HOOK_Load);

    //
    // Save our instance
    //
    g_hookInstance = hInst;

    //
    // (1) NtQueryInformationProcess() in NTDLL
    // (2) SetWinEventHook() in           USER32
    // (3) UnhookWinEventHook() in        USER32
    //

    // Get hold of NtQueryInformationProcess
    hInst = GetModuleHandle(NTDLL_DLL);
    g_hetNtQIP = (NTQIP) GetProcAddress(hInst, "NtQueryInformationProcess");

    // Get hold of the WinEvent routines
    hInst = GetModuleHandle(TEXT("USER32.DLL"));
    g_hetSetWinEventHook = (SETWINEVENTHOOK)GetProcAddress(hInst, "SetWinEventHook");
    g_hetUnhookWinEvent = (UNHOOKWINEVENT)GetProcAddress(hInst, "UnhookWinEvent");

    //
    // Figure out what type of app we are.  We want to treat separate groupware
    // process applets and WOW16 apps specially.
    //
    GetModuleFileName(NULL, szExeName, sizeof(szExeName)-1);
    szExeName[sizeof(szExeName) -1] = 0;
    ASSERT(*szExeName);

    TRACE_OUT(("HOOK loaded for app %s", szExeName));

    //
    // Start at the beginning, and work our way to the last part after the
    // last slash, if there is one.  We know the path is fully qualified.
    //
    lpT = szExeName;
    lpLastPart = szExeName;

    while (*lpT)
    {
        lpNext = AnsiNext(lpT);

        if (*lpT == '\\')
        {
            //
            // This points to the next character AFTER the backwhack.
            // If we're at the end of the string somehow, *lpLastPart will
            // be zero, and worst that can happen is that our lstrcmpis fail.
            //
            lpLastPart = lpNext;
        }

        lpT = lpNext;
    }

    ASSERT(*lpLastPart);

    //
    // NOTE:
    // GetModuleFileName() dies sometimes for a WOW app--it doesn't always
    // NULL terminate.  So we will do this on our own.
    //
    lpT = lpLastPart;

    //
    // Get to the '.' part of the 8.3 final file name
    //
    while (*lpT && (*lpT != '.'))
    {
        lpT = AnsiNext(lpT);
    }

    //
    // Skip past the next three chars
    //
    if (*lpT == '.')
    {
        lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);
        if (lpT && *lpT)
            lpT = AnsiNext(lpT);

        //
        // And null terminate after the 3rd char past the '.' extension.
        // This isn't great, but it covers .COM, .DLL, etc. dudes.  The
        // worst that will happen is GetBinaryType() will fail and we won't
        // recognize a WOW app with some strange extension (not 3 chars)
        // starting up.
        //
        if (lpT)
        {
            if (*lpT != 0)
            {
                WARNING_OUT(("WOW GetModuleFileName() bug--didn't NULL terminate string"));
            }

            *lpT = 0;
        }
    }

    if (!lstrcmpi(lpLastPart, "WOWEXEC.EXE"))
    {
        TRACE_OUT(("New WOW VDM starting up"));

        //
        // A new WOW VDM is starting up.  We don't want to share anything
        // in the first thread, the WOW service thread, because those windows
        // never go away.
        //
        g_appType = HET_WOWVDM_APP;
    }
    else if (!GetBinaryType(szExeName, &dwExeType))
    {
        ERROR_OUT(("Unable to determine binary type for %s", szExeName));
    }
    else if (dwExeType == SCS_WOW_BINARY)
    {
        TRACE_OUT(("New WOW APP in existing VDM starting up"));

        //
        // A new 16-bit app thread is starting in an existing WOW vdm.
        //
        g_idWOWApp = GetCurrentThreadId();
        g_fShareWOWApp = (BOOL)HET_GetHosting(GetForegroundWindow());

        TRACE_OUT(("For new WOW app %08ld, foreground is %s",
            g_idWOWApp, (g_fShareWOWApp ? "SHARED" : "not SHARED")));

        //
        // Remember who was really active when this WOW dude was started
        // up.  On the first window create, we'll share him based on the
        // status of it.
        //
    }

    DebugExitVOID(HOOK_ProcessAttach);
}



//
// HOOK_NewThread()
// For WOW apps, each app is really a thread.  The first thread created
// in NTVDM is the WOW service thread.  We don't want to share any windows
// in it.  Unfortunately, the first window created is a console window, so
// that happens in CONF's context and we can't get any info.  The next window
// created in this thread is a WOW window (WOWEXEC.EXE).  When that happens,
// we want to go back and unshare the console window.
//
// If the WOW VDM is already running when another 16-bit app starts up,
// we don't have these troubles.
//
void HOOK_NewThread(void)
{
    DebugEntry(HOOK_NewThread);

    TRACE_OUT(("App thread %08ld starting", GetCurrentThreadId()));

    if (g_appType == HET_WOWVDM_APP)
    {
        TRACE_OUT(("Unsharing WOW service thread windows"));

        //
        // We want to go unshare the previously created WOW windows.  We
        // never want to keep shared the dudes in the WOW service thread.
        //
        g_appType = 0;
        EnumWindows(HETUnshareWOWServiceWnds, GetCurrentProcessId());
    }

    // Update our "share windows on this thread" state.
    g_idWOWApp = GetCurrentThreadId();
    g_fShareWOWApp = (BOOL)HET_GetHosting(GetForegroundWindow());

    TRACE_OUT(("For new app thread %08ld, foreground is %s",
        g_idWOWApp, (g_fShareWOWApp ? "SHARED" : "not SHARED")));

    DebugExitVOID(HOOK_NewThread);
}




//
// HETUnshareWOWServiceWnds()
// This unshares any windows that accidentally got shared in the first
// service thread in a WOW VDM.  This can happen if a WOW app is launched
// by a 32-bit app, and it's the first WOW app ever.  The first window
// created is a console window, and the notification happens in CONF's
// process without the right styles that tell us it's in a WOW process.
//
BOOL CALLBACK HETUnshareWOWServiceWnds(HWND hwnd, LPARAM lParam)
{
    DWORD   idProcess;

    DebugEntry(HETUnshareWOWServiceWnds);

    if (GetWindowThreadProcessId(hwnd, &idProcess) &&
        (idProcess == (DWORD)lParam))
    {
        TRACE_OUT(("Unsharing WOW service window %08lx", hwnd));
        OSI_UnshareWindow(hwnd, TRUE);
    }

    DebugExitVOID(HETUnshareWOWServiceWnds);
    return(TRUE);
}




//
// HOOK_Init()
// This saves away the core window and atom used in the high level input
// hooks and when sharing.
//
void WINAPI HOOK_Init(HWND hwndCore, ATOM atomTrack)
{
    DebugEntry(HOOK_Init);

    g_asMainWindow = hwndCore;
    g_asHostProp   = atomTrack;

    DebugExitVOID(HOOK_Init);
}



//
// OSI_StartWindowTracking()
// This installs our WinEvent hook so we can watch windows coming and going.
//
BOOL WINAPI OSI_StartWindowTracking(void)
{
    BOOL        rc = FALSE;

    DebugEntry(OSI_StartWindowTracking);

    ASSERT(!g_hetTrackHook);

    //
    // If we can't find the NTDLL + 2 USER32 routines we need, we can't
    // let you share.
    //
    if (!g_hetNtQIP || !g_hetSetWinEventHook || !g_hetUnhookWinEvent)
    {
        ERROR_OUT(("Wrong version of NT; missing NTDLL and USER32 routines needed to share"));
        DC_QUIT;
    }


    //
    // Install our hook.
    //
    g_hetTrackHook = g_hetSetWinEventHook(HET_MIN_WINEVENT, HET_MAX_WINEVENT,
            g_hookInstance, HETTrackProc, 0, 0,
            WINEVENT_INCONTEXT | WINEVENT_SKIPOWNPROCESS);

    if (!g_hetTrackHook)
    {
        ERROR_OUT(("SetWinEventHook failed"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_StartWindowTracking, rc);
    return(rc);
}



//
// OSI_StopWindowTracking()
// Removes our hooks for window/task spying, if installed.
//
void WINAPI OSI_StopWindowTracking(void)
{
    DebugEntry(OSI_StopWindowTracking);

    if (g_hetTrackHook)
    {
        // Uninstall the WinEvent hook
        ASSERT((g_hetUnhookWinEvent != NULL));
        g_hetUnhookWinEvent(g_hetTrackHook);

        g_hetTrackHook = NULL;

    }

    DebugExitVOID(OSI_StopWindowTracking);
}



//
// OSI_IsWindowScreenSaver()
//
// On NT the screensaver runs in a different desktop.  We'll never get
// an HWND for it.
//
BOOL WINAPI OSI_IsWindowScreenSaver(HWND hwnd)
{
#ifdef _DEBUG
    char className[HET_CLASS_NAME_SIZE];

    if (GetClassName(hwnd, className, sizeof(className)) > 0)
    {
        ASSERT(lstrcmp(className, HET_SCREEN_SAVER_CLASS));
    }
#endif // _DEBUG

    return(FALSE);
}



//
// OSI_IsWOWWindow()
// Returns TRUE if the window is from a WOW (emulated 16-bit) application
//
BOOL WINAPI OSI_IsWOWWindow(HWND hwnd)
{
    BOOL    rc = FALSE;
    DWORD_PTR*  pWOWWords;

    DebugEntry(OSI_IsWOWWindow);

    //
    // Get a pointer to the potential WOW words.  We make use of an
    // undocumented field which is only valid for NT4.0.
    //
    pWOWWords = (DWORD_PTR*) GetClassLongPtr(hwnd, GCL_WOWWORDS);

    //
    // Check that we can use this as a pointer.
    //
    if (!pWOWWords || IsBadReadPtr(pWOWWords, sizeof(DWORD)))
    {
        DC_QUIT;
    }

    //
    // This is a valid pointer so try to dereference it.
    //
    if (0 == *pWOWWords)
    {
        DC_QUIT;
    }

    //
    // The value pointed at by <pWOWWords> is non-zero so this must be a
    // WOW app.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Let the world know what we've found.
    //
    TRACE_OUT(( "Window %#x is a %s window", hwnd, rc ? "WOW" : "Win32"));

    DebugExitBOOL(OSI_IsWOWWindow, rc);
    return(rc);
}



//
// HETTrackProc()
// Used to spy on window events
//      CREATE
//      DESTROY
//      SHOW
//      HIDE
//
void CALLBACK HETTrackProc
(
    HWINEVENTHOOK   hEvent,
    DWORD           eventNotification,
    HWND            hwnd,
    LONG            idObject,
    LONG            idChild,
    DWORD           dwThreadId,
    DWORD           dwmsEventTime
)
{
    DebugEntry(HETTrackProc);

    if ((idObject != OBJID_WINDOW) || (idChild != 0))
    {
        DC_QUIT;
    }

    //
    // Work around a bug in SP3 with ring transition callbacks, where this
    // proc gets called before the LoadLibrary is completed.
    //
    if (!g_hookInstance)
    {
        ERROR_OUT(( "WinEvent hook called before LoadLibrary completed!"));
        DC_QUIT;
    }

    switch (eventNotification)
    {
        case EVENT_OBJECT_CREATE:
            HETHandleCreate(hwnd);
            break;

        case EVENT_OBJECT_DESTROY:
            OSI_UnshareWindow(hwnd, TRUE);
            break;

        case EVENT_OBJECT_SHOW:
            // Only if this is a console window do we want to force a repaint.
            //
            // Only console apps cause events to occur in CONF's process (the one
            // that installed the hook)
            //
            HETHandleShow(hwnd, (g_hetTrackHook != NULL));
            break;

        case EVENT_OBJECT_HIDE:
            HETHandleHide(hwnd);
            break;

        case EVENT_OBJECT_PARENTCHANGE:
            HETCheckParentChange(hwnd);
            break;
    }

DC_EXIT_POINT:
    DebugExitVOID(HETTrackProc);
}

//
// HETHandleCreate()
//
// If the window isn't a real top level dude (not CHILD style or parent is
// desktop) or is a menu, ignore it.
//
// Otherwise enum the top level windows and decide what to do:
//      * If at least one other in the thread/process is shared in a perm.
//      way, mark this the same
//
//      * If this is the only one in the process, follow the ancestor chain
//      up.
//
void HETHandleCreate(HWND hwnd)
{
    HET_TRACK_INFO  hti;
    UINT            hostType;
#ifdef _DEBUG
    char            szClass[HET_CLASS_NAME_SIZE];

    GetClassName(hwnd, szClass, sizeof(szClass));
#endif

    DebugEntry(HETHandleCreate);

    //
    // Ignore child windows
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx create", hwnd));
            DC_QUIT;
        }
    }

    hti.idThread = GetWindowThreadProcessId(hwnd, &hti.idProcess);
    if (!hti.idThread)
    {
        TRACE_OUT(("Window %08lx gone", hwnd));
        DC_QUIT;
    }

    //
    // Ignore special threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %08lx create", hwnd));
        DC_QUIT;
    }

    //
    // We don't need to ignore menus.  Only when first shared do we skip
    // menus.  The cached one we never want to share.  The others will
    // go away almost immediately.  From now on, we treat them the same
    // as other windows.
    //

    //
    // Figure out what to do.
    // NOTE:
    // We don't want to inadvertently share the other windows WOW creates.
    // The first thread in the WOW process has special classes, which aren't
    // WOW wrappers.
    //
    hti.hwndUs      = hwnd;
    hti.fWOW        = OSI_IsWOWWindow(hwnd);
    hti.cWndsApp    = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    TRACE_OUT(("Create for %s window %08lx class %s process %08ld thread %08ld",
        (hti.fWOW ? "WOW" : "32-bit"), hwnd, szClass, hti.idProcess, hti.idThread));

UpOneLevel:
    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    if (hti.cWndsSharedThread)
    {
        TRACE_OUT(("Sharing window %08lx class %s by thread %08ld in process %08ld",
                hwnd, szClass, hti.idThread, hti.idProcess));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else if (hti.cWndsSharedProcess)
    {
        TRACE_OUT(("Sharing window %08lx class %s by process %08ld in thread %08ld",
                hwnd, szClass, hti.idProcess, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYPROCESS;
    }
    else if (hti.cWndsApp)
    {
        //
        // There's another window in our app, but none are shared.  So don't
        // share us either.
        //
        TRACE_OUT(("Not sharing window %08lx class %s; other unshared windows in thread %08ld process %08ld",
                hwnd, szClass, hti.idThread, hti.idProcess));
        DC_QUIT;
    }
    else if (hti.fWOW)
    {
        //
        // Task tracking code for WOW apps, which are really threads.
        //
        BOOL    fShare;

        //
        // WOW apps are different.  They are threads in the NTVDM process.
        // Therefore parent/child relationships aren't useful.  Instead,
        // the best thing we can come up with is to use the status of the
        // foreground window.  We assume that the currently active app at
        // the time the WOW app started up is the one that launched us.
        //
        // We can't just call GetForegroundWindow() here, because it is too
        // late.
        //
        if (hti.idThread == g_idWOWApp)
        {
            fShare = g_fShareWOWApp;

            g_fShareWOWApp = FALSE;
            g_idWOWApp = 0;
        }
        else
        {
            fShare = FALSE;
        }

        if (!fShare)
        {
            TRACE_OUT(("THREAD window %08lx class %s in thread %08ld not shared",
                    hwnd, szClass, hti.idThread));
            DC_QUIT;
        }

        TRACE_OUT(("First window %08lx class %s of WOW app %08ld, shared since foreground is",
            hwnd, szClass, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else
    {
        //
        // Task tracking code for 32-bit apps.
        //
        DWORD   idParentProcess;

        //
        // First window of a WIN32 app.
        //

        // Loop through our ancestor processes (no thread info at this point)
        HETGetParentProcessID(hti.idProcess, &idParentProcess);

        if (!idParentProcess)
        {
            TRACE_OUT(("Can't get parent of process %08ld", hti.idProcess));
            DC_QUIT;
        }

        //
        // We know if we got here that all our favorite fields are still
        // zero.  So just loop!  But NULL out idThread to avoid matching
        // anything while we look at our parent.
        //
        TRACE_OUT(("First window %08lx class %s in process %08ld %s, checking parent %08ld",
            hwnd, szClass, hti.idProcess, GetCommandLine(), idParentProcess));

        hti.idThread    = 0;
        hti.idProcess   = idParentProcess;
        goto UpOneLevel;
    }

    //
    // OK, we are going to share this.  We do have to repaint console
    // windows--we get the notifications asynchronously.  If the window isn't
    // visible yet, redrawing will do nothing.  After this, the property is
    // set, and we will catch all ouput.  If it has already become visible,
    // invalidating it now will still work, and we will ignore the queued
    // up show notification because the property is set.
    //
    OSI_ShareWindow(hwnd, hostType, (g_hetTrackHook != NULL), TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleCreate);
}




//
// HETHandleShow()
//
void HETHandleShow
(
    HWND    hwnd,
    BOOL    fForceRepaint
)
{
    UINT    hostType;
    HET_TRACK_INFO  hti;

    DebugEntry(HETHandleShow);

    hostType = (UINT)HET_GetHosting(hwnd);

    //
    // If this window is a real child, clear the hosting property. Usually
    // one isn't there.  But in the case of a top level window becoming
    // a child of another, we want to wipe out junk.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx show", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from SHOW", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
            DC_QUIT;
        }
    }

    //
    // Is this window already shared?  Nothing to do if so.  If it's a
    // console guy, we've seen it already on create.
    //
    if (hostType)
    {
        TRACE_OUT(("Window %08lx already shared, ignoring show", hwnd));
        DC_QUIT;
    }

    //
    // Here's where we also enumerate the top level windows and find a
    // match.  But we DO not track across processes in this case.  Instead
    // we look at the owner if there is one.
    //
    // This solves the create-as-a-child then change to a top level
    // window problem, like combo dropdowns.
    //

    hti.idThread = GetWindowThreadProcessId(hwnd, &hti.idProcess);
    if (!hti.idThread)
    {
        TRACE_OUT(("Window %08lx gone", hwnd));
        DC_QUIT;
    }

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %08lx show", hwnd));
        DC_QUIT;
    }

    hti.hwndUs      = hwnd;
    hti.fWOW        = OSI_IsWOWWindow(hwnd);
    hti.cWndsApp    = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    //
    // These kinds of windows are always only temp shared.  They don't
    // start out as top level windows that we saw from the beginning or
    // watched created.  These are SetParent() or menu kinds of dudes, so
    // for a lot of reasons we're plain safer sharing these babies only
    // temporarily
    //

    //
    // Anything else shared on this thread/process, the decision is easy.
    // Otherwise, we look at the ownership trail.
    //
    if (!hti.cWndsSharedThread && !hti.cWndsSharedProcess)
    {
        HWND    hwndOwner;

        //
        // Does it have an owner that is shared?
        //
        hwndOwner = hwnd;
        while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
        {
            if (HET_GetHosting(hwndOwner))
            {
                TRACE_OUT(("Found shared owner %08lx of window %08lx", hwndOwner, hwnd));
                break;
            }
        }

        if (!hwndOwner)
        {
            DC_QUIT;
        }
    }

    //
    // For console apps, we get notifications asynchronously posted to us,
    // in NM's process.  The window may have painted already without our
    // seeing it.  So force it to repaint just in case.  The g_hetTrackHook
    // variable is only around when this is NM.
    //
    TRACE_OUT(("Sharing temporary window %08lx", hwnd));

    OSI_ShareWindow(hwnd, HET_HOSTED_BYWINDOW | HET_HOSTED_TEMPORARY,
        fForceRepaint, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleShow);
}




//
// HETHandleHide()
// This handles a window being hidden.  If it was temporary, it is unshared.
// If it is permanent, it is marked as hidden.
//
void HETHandleHide(HWND hwnd)
{
    UINT    hostType;

    DebugEntry(HETHandleHide);

    hostType = (UINT)HET_GetHosting(hwnd);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %08lx hide", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from HIDE", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
            DC_QUIT;
        }
    }

    if (!hostType)
    {
        //
        // Console apps give us notifications out of context.  Make
        // sure the count is up to date.
        //
        if (g_hetTrackHook)
        {
            HETNewTopLevelCount();
        }
        else
        {
            TRACE_OUT(("Window %08lx not shared, ignoring hide", hwnd));
        }
    }
    else if (hostType & HET_HOSTED_TEMPORARY)
    {
        //
        // Temporarily shared window are only shared when visible.
        //
        TRACE_OUT(("Unsharing temporary window %08lx", hwnd));
        OSI_UnshareWindow(hwnd, TRUE);
    }
    else
    {
        ASSERT(hostType & HET_HOSTED_PERMANENT);

        // Nothing to do.
        TRACE_OUT(("Window %08lx permanently shared, ignoring hide", hwnd));
    }


DC_EXIT_POINT:
    DebugExitVOID(HETHandleHide);
}


//
// HETCheckParentChange()
//
// PARENTCHANGE is 100% reliable, compared to Win9x stuff.
//
void HETCheckParentChange(HWND hwnd)
{
    DebugEntry(HETCheckParentChange);

    WARNING_OUT(("Got PARENTCHANGE for hwnd 0x%08x", hwnd));

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            UINT    hostType;

            hostType = (UINT)HET_GetHosting(hwnd);
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%08x from MOVE", hwnd));
                OSI_UnshareWindow(hwnd, TRUE);
            }
        }
    }

    DebugExitVOID(HETCheckParentChange);
}




//
// OSI_ShareWindow
// This shares a window, calling the display driver to add it to the visrgn
// list.  It is called when
//      * An app is shared
//      * A new window in a shared app is created
//      * A temporary window with a relationship to a shared window is shown
//
// This returns TRUE if it shared a window.
//
BOOL OSI_ShareWindow
(
    HWND    hwnd,
    UINT    hostType,
    BOOL    fRepaint,
    BOOL    fUpdateCount
)
{
    BOOL                rc = FALSE;
    HET_SHARE_WINDOW    req;

    DebugEntry(OSI_ShareWindow);

    //
    // Set the property
    //
    if (!HET_SetHosting(hwnd, hostType))
    {
        ERROR_OUT(("Couldn't set shared property on window %08lx", hwnd));
        DC_QUIT;
    }

    //
    // Tell the display driver
    //
    req.winID       = HandleToUlong(hwnd);
    req.result      = 0;
    if (!OSI_FunctionRequest(HET_ESC_SHARE_WINDOW, (LPOSI_ESCAPE_HEADER)&req,
            sizeof(req)) ||
        !req.result)
    {
        ERROR_OUT(("Driver couldn't add window %08lx to list", hwnd));

        HET_ClearHosting(hwnd);
        DC_QUIT;
    }

    TRACE_OUT(("Shared window %08lx of type %08lx", hwnd, hostType));

    //
    // Repaint it
    //
    if (fRepaint)
    {
        USR_RepaintWindow(hwnd);
    }

    if (fUpdateCount)
    {
        PostMessage(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, TRUE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_ShareWindow, rc);
    return(rc);
}



//
// OSI_UnshareWindow()
// This unshares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// It returns TRUE if a shared window has been unshared.
//
BOOL OSI_UnshareWindow
(
    HWND    hwnd,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;
    UINT    hostType;
    HET_UNSHARE_WINDOW req;

    DebugEntry(OSI_UnshareWindow);

    //
    // This gets the old property and clears it in one step.
    //
    hostType = (UINT)HET_ClearHosting(hwnd);
    if (!hostType)
    {
        if (fUpdateCount && g_hetTrackHook)
        {
            //
            // We always get async notifications for console apps.  In that
            // case, the window is really gone before this comes to us.
            // So redetermine the count now.
            //
            HETNewTopLevelCount();
        }

        DC_QUIT;
    }

    //
    // OK, stuff to do.
    //
    TRACE_OUT(("Unsharing window %08lx of type %08lx", hwnd, hostType));

    //
    // Tell the display driver
    //
    req.winID = HandleToUlong(hwnd);
    OSI_FunctionRequest(HET_ESC_UNSHARE_WINDOW, (LPOSI_ESCAPE_HEADER)&req, sizeof(req));

    //
    // Update the top level count
    //
    if (fUpdateCount)
    {
        PostMessage(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, FALSE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_UnshareWindow, rc);
    return(rc);
}



//
//  HETShareEnum()
//
//  This is the EnumWindows() callback.  We stop when we find the first
//  matching shared window (thread or process).  We keep a running tally
//  of the count of all top level windows in our process (not shared by
//  thread or process) at the same time.  This lets us do tracking.
//
BOOL CALLBACK HETShareEnum(HWND hwnd, LPARAM lParam)
{
    LPHET_TRACK_INFO    lphti = (LPHET_TRACK_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    BOOL                rc = TRUE;

    DebugEntry(HETShareEnum);

    // Skip ourself.
    if (hwnd == lphti->hwndUs)
    {
        DC_QUIT;
    }

    // Skip if window is gone.
    idThread = GetWindowThreadProcessId(hwnd, &idProcess);
    if (!idThread)
    {
        DC_QUIT;
    }

    //
    // Do the apps match?  If not, ignore this window.
    //
    if ((idProcess != lphti->idProcess) ||
        ((lphti->fWOW) && (idThread != lphti->idThread)))
    {
        DC_QUIT;
    }

    lphti->cWndsApp++;

    hostType = (UINT)HET_GetHosting(hwnd);
    if (!hostType)
    {
        DC_QUIT;
    }

    //
    // Now, if this window is shared by thread or process, do the right
    // thing.
    //
    if (hostType & HET_HOSTED_BYPROCESS)
    {
        // We have a match.  We can return immediately.
        lphti->cWndsSharedProcess++;
        rc = FALSE;
    }
    else if (hostType & HET_HOSTED_BYTHREAD)
    {
        //
        // For WOW apps, we don't want this one, if in a separate thread, to
        // count.  No matter what.
        //
        if (idThread == lphti->idThread)
        {
            lphti->cWndsSharedThread++;
            rc = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitBOOL(HETShareEnum, rc);
    return(rc);
}


//
// HETNewTopLevelCount()
// This does a quick new tally of the shared top level visible count
//
void HETNewTopLevelCount(void)
{
    UINT    newCount;

    DebugEntry(HETNewTopLevelCount);

    newCount = 0;
    EnumWindows(HETCountTopLevel, (LPARAM)&newCount);

    PostMessage(g_asMainWindow, DCS_RECOUNTTOPLEVEL_MSG, newCount, 0);

    DebugExitVOID(HETNewTopLevelCount);
}



//
// HETCountTopLevel()
// This counts shared windows
//
BOOL CALLBACK HETCountTopLevel(HWND hwnd, LPARAM lParam)
{
    DebugEntry(HETCountTopLevel);

    if (HET_GetHosting(hwnd))
    {
        (*(LPUINT)lParam)++;
    }

    DebugExitBOOL(HETCountTopLevel, TRUE);
    return(TRUE);
}



//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == GetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == GetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// HET_WindowIsHosted()
// This is called by the high level mouse hook.  Unlike the version in
// MNMCPI32, it doesn't check (or know) if the whole desktop is shared.
//
// LAURABU BOGUS
// Note that this may need to be revised.  The high level hooks are handy
// in desktop sharing also.  For the keyboard, we track the toggle key
// states.  For the mouse, we block messages to non-shared windows.
//
BOOL  HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(HET_WindowIsHosted);

    if (!hwnd)
        DC_QUIT;

    //
    // Walk up to the top level window this one is inside of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = (BOOL)HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(HET_WindowIsHosted, rc);
    return(rc);
}



//
// HETGetParentProcessID()
// This gets the ID of the process which created the passed in one.  Used
// for task tracking
//
void HETGetParentProcessID
(
    DWORD       processID,
    LPDWORD     pParentProcessID
)
{
    HANDLE                      hProcess;
    UINT                        intRC;
    PROCESS_BASIC_INFORMATION   basicInfo;

    DebugEntry(HETGetParentProcessID);

    *pParentProcessID = 0;

    //
    // Open a handle to the process.  If we don't have security privileges,
    // or it is gone, this will fail.
    //
    hProcess = OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,
            FALSE, processID);
    if (NULL == hProcess)
    {
        WARNING_OUT(("Can't get process handle for ID %08lx", processID));
        DC_QUIT;
    }

    //
    // Get back an information block for this process, one item of which is
    // the parent.
    //
    ASSERT(g_hetNtQIP);

    intRC = g_hetNtQIP(hProcess, ProcessBasicInformation, &basicInfo,
        sizeof(basicInfo),  NULL);

    if (!NT_SUCCESS(intRC))
    {
        ERROR_OUT(("Can't get info for process ID %08lx, handle %08lx -- error %u",
            processID, hProcess, intRC));
    }
    else
    {
        *pParentProcessID = basicInfo.InheritedFromUniqueProcessId;
    }

    //
    // Close the process handle
    //
    CloseHandle(hProcess);

DC_EXIT_POINT:
    DebugExitVOID(HETGetParentProcessID);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\globals.h ===
//
// GLOBALS.H
// Global Variable Declaration
//
// NOTE:
// Variables in .sdata, shared segment, MUST HAVE INITIALIZED VALUES.
// Otherwise, the linker will just stick them silently into .data.
//


#include <host.h>
#include <usr.h>
#include <im.h>


//
// Per process data
//

// These are meaningful in all processes
DC_DATA(HINSTANCE,          g_hookInstance);
DC_DATA(NTQIP,              g_hetNtQIP);
DC_DATA(UINT,               g_appType);
DC_DATA(BOOL,               g_fLeftDownOnShared);

// These are meaningful only in WOW apps
DC_DATA(DWORD,              g_idWOWApp);
DC_DATA(BOOL,               g_fShareWOWApp);

// These are set in CONF's process and NULL in others
DC_DATA(SETWINEVENTHOOK,    g_hetSetWinEventHook);
DC_DATA(UNHOOKWINEVENT,     g_hetUnhookWinEvent);
DC_DATA(HWINEVENTHOOK,      g_hetTrackHook);


//
// Shared data, accessible in all processes
//
#ifdef DC_DEFINE_DATA
#pragma data_seg("SHARED")
#endif


DC_DATA_VAL(HWND,           g_asMainWindow,    NULL);
DC_DATA_VAL(ATOM,           g_asHostProp,      0);
DC_DATA_VAL(HHOOK,          g_imMouseHook,      NULL);
DC_DATA_VAL(char,           g_osiDriverName[CCHDEVICENAME], "");
DC_DATA_VAL(char,           s_osiDisplayName[8], "DISPLAY");

#ifdef DC_DEFINE_DATA
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\thk\fltthk.inc ===
; File: fltthk.inc
;
;   Support macros and routines for the flat thunk mode of the thunk
;   compiler.
;
;   Included in *.asm files generated using the 
;   "flatthunks = true" semantic.
;





; Macro: FAPILOG16. Prints out a log message at the start of each thunk.
; Debug only.
FAPILOG16	macro	dwOffset
ifdef DEBUG
	pushd	offset FT_ThunkLogNames + dwOffset
	call	FAPILOG16_Hlp
endif ;DEBUG
endm ;FAPILOG16




ifdef DEBUG

LogApiThkLSF	proto	near stdcall, psz:dword

FAPILOG16_Hlp:
	push	ebp
	mov	ebp,[esp+8]

	invoke	LogApiThkLSF, ebp

	pop	ebp
	ret	4

endif ;DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\osi.cpp ===
#include "precomp.h"


//
// OSI.CPP
// OS Isolation layer, NT version in HOOK
//
// Copyright(c) Microsoft 1997-
//

#include <osi.h>
#include <version.h>
#include <ndcgver.h>


//
// OSI_SetDriverName()
// This saves or clears the driver name so in OSI_FunctionRequest we can
// create a DC to communicate with our display driver.  On NT4.x this is a 
// display DC; on NT5 this is a direct DC to our driver.
//
void OSI_SetDriverName(LPCSTR szDriverName)
{
    DebugEntry(OSI_SetDriverName);

    if (!szDriverName)
    {
        // Clear it
        g_osiDriverName[0] = 0;
    }
    else
    {
        // Set it
        ASSERT(!g_osiDriverName[0]);
        lstrcpy(g_osiDriverName, szDriverName);
    }

    DebugExitVOID(OSI_SetDriverName);
}



//
// OSI_FunctionRequest - see osi.h
//
BOOL OSI_FunctionRequest
(
    DWORD escapeFn,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD requestLen
)
{
    BOOL            rc = FALSE;
    ULONG           iEsc;
    HDC             hdc;    

    DebugEntry(OSI_FunctionRequest);

    if (!g_osiDriverName[0])
    {
        // NT 4.x case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
            s_osiDisplayName));
        hdc = CreateDC(s_osiDisplayName, NULL, NULL, NULL);
    }
    else
    {
        // NT 5 case
        TRACE_OUT(("OSI_FunctionRequest:  Creating %s driver DC",
                g_osiDriverName));
        hdc = CreateDC(NULL, g_osiDriverName, NULL, NULL);
    }

    if (!hdc)
    {
        ERROR_OUT(("Failed to create DC to talk to driver '%s'", g_osiDriverName));
        DC_QUIT;
    }

    TRACE_OUT(("OSI_FunctionRequest:  Created %s driver DC %08x",
            g_osiDriverName, hdc));

    //
    // Pass the request on to the display driver.
    //
    pRequest->padding    = 0;
    pRequest->identifier = OSI_ESCAPE_IDENTIFIER;
    pRequest->escapeFn   = escapeFn;
    pRequest->version    = DCS_MAKE_VERSION();

    if ((escapeFn >= OSI_HET_WO_ESC_FIRST) && (escapeFn <= OSI_HET_WO_ESC_LAST))
    {
        iEsc = WNDOBJ_SETUP;
    }
    else
    {
        iEsc = OSI_ESC_CODE;
    }

    if (0 >= ExtEscape(hdc, iEsc, requestLen, (LPCSTR)pRequest,
            requestLen, (LPSTR)pRequest))
    {
        WARNING_OUT(("ExtEscape %x code %d failed", iEsc, escapeFn));
    }
    else
    {
        rc = TRUE;
    }

DC_EXIT_POINT:
    if (hdc)
    {
        DeleteDC(hdc);
    }

    DebugExitDWORD(OSI_FunctionRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\hook\im.cpp ===
#include "precomp.h"


//
// IM.CPP
// Input Manager (controlling) Code
//
// Copyright(c) Microsoft 1997-
//


//
// FUNCTION: OSI_InstallHighLevelMouseHook
//
// DESCRIPTION:
//
// This function installs the IM high level mouse hook.  The mouse hook is
// used to block remote mouse input to non-hosted apps.
//
// PARAMETERS: None.
//
//
BOOL WINAPI OSI_InstallHighLevelMouseHook(BOOL fEnable)
{
    BOOL    rc = TRUE;

    DebugEntry(OSI_InstallHighLevelMouseHook);

    if (fEnable)
    {
        //
        // Check the hook is already installed.  This is quite possible.
        //
        if (g_imMouseHook)
        {
            TRACE_OUT(( "Mouse hook installed already"));
        }
        else
        {
            //
            // Install the mouse hook
            //
            g_imMouseHook = SetWindowsHookEx(WH_MOUSE, IMMouseHookProc,
                g_hookInstance, 0);

            if (!g_imMouseHook)
            {
                ERROR_OUT(("Failed to install mouse hook"));
                rc = FALSE;
            }
        }
    }
    else
    {
        //
        // Check the hook is already removed.  This is quite possible.
        //
        if (!g_imMouseHook)
        {
            TRACE_OUT(("Mouse hook not installed"));
        }
        else
        {
            //
            // Remove the mouse hook
            //
            UnhookWindowsHookEx(g_imMouseHook);
            g_imMouseHook = NULL;
        }
    }

    DebugExitBOOL(OSI_InstallHighLevelMouseHook, rc);
    return(rc);
}





//
// FUNCTION: IMMouseHookProc
//
// DESCRIPTION:
//
//
// PARAMETERS:
//
// See MouseProc documentation
//
// RETURNS:
//
// See MouseProc documentation (FALSE - allow event through, TRUE - discard
// event)
//
//
LRESULT CALLBACK IMMouseHookProc(int    code,
                                 WPARAM wParam,
                                 LPARAM lParam)
{
    LRESULT             rc;
    BOOL                block          = FALSE;
    BOOL                fShared;
    PMOUSEHOOKSTRUCT    lpMseHook    = (PMOUSEHOOKSTRUCT) lParam;

    DebugEntry(IMMouseHookProc);

    if (code < 0)
    {
        //
        // Pass the hook on if the code is negative (Windows hooking
        // protocol).
        //
        DC_QUIT;
    }

    //
    // Now decide if we should block this event.  We will block this event
    // if it is not destined for a hosted window.
    //
    // Note that on NT screensavers run in a different desktop.  We do not
    // journalrecord (and can't for winlogon/security reasons) on that
    // desktop and therefore never will see an HWND that is a screensaver.
    //
    fShared = HET_WindowIsHosted(lpMseHook->hwnd);

    if (wParam == WM_LBUTTONDOWN)
        g_fLeftDownOnShared = fShared;

    //
    // If this is some kind of mouse message to a window that isn't shared,
    // check if the window is the OLE32 dragdrop dude.
    //
    if (!fShared && g_fLeftDownOnShared)
    {
        TCHAR   szName[HET_CLASS_NAME_SIZE];

        if (::GetClassName(lpMseHook->hwnd, szName, CCHMAX(szName)) &&
            !lstrcmpi(szName, HET_OLEDRAGDROP_CLASS) &&
            (::GetCapture() == lpMseHook->hwnd))
        {
            //
            // Note side-effect of this:
            // Mouse moves over non-shared areas when in OLE drag drop mode
            // WILL be passed on to non-shared window.
            //
            // But that's way better than it not working at all.
            //
            WARNING_OUT(("NMASNT: Hacking OLE drag drop; left click down on shared window then OLE took capture"));
            fShared = TRUE;
        }
    }

    block  = !fShared;

    TRACE_OUT(("MOUSEHOOK: hwnd %08lx -> block: %s",
             lpMseHook->hwnd,
             block ? "YES" : "NO"));

DC_EXIT_POINT:
    //
    // Call the next hook.
    //
    rc = CallNextHookEx(g_imMouseHook, code, wParam, lParam);

    if (block)
    {
        //
        // We want to block this event so return a non-zero value.
        //
        rc = 1;
    }

    DebugExitDWORD(IMMouseHookProc, (DWORD)rc);
    return(rc);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\thk\asthkls.inc ===
; File: asthkls.inc
;
; Nothing here
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api.h ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information				
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.				
 *									
 *   This listing is supplied under the terms of a license agreement	
 *   with INTEL Corporation and may not be used, copied, nor disclosed	
 *   except in accordance with the terms of that agreement.		
 *
 *****************************************************************************/

/******************************************************************************
 *									
 *  $Workfile:   api.h  $
 *  $Revision:   1.5  $
 *  $Modtime:   06 Jun 1996 17:10:36  $
 *  $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/api.h_v  $	
 *
 *    Rev 1.5   06 Jun 1996 18:43:08   EHOWARDX
 * Unnested tracker structure and eliminated PLOCK macros.
 *
 *    Rev 1.4   29 May 1996 15:20:40   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.3   20 May 1996 14:31:54   EHOWARDX
 * Got rid of asynchronous EndSession/Shutdown stuff.
 *
 *    Rev 1.2   16 May 1996 15:55:56   EHOWARDX
 * Replaced LocalSequenceNum with LocalCapDescIdNum.
 *
 *    Rev 1.1   13 May 1996 23:15:46   EHOWARDX
 * Fixed remote termcap handling.
 *
 *    Rev 1.0   09 May 1996 21:04:42   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.17   09 May 1996 19:38:20   EHOWARDX
 * Redesigned locking logic and added new functionality.
 *
 *    Rev 1.16   15 Apr 1996 15:58:14   cjutzi
 *
 * - added phase2 back
 *
 *    Rev 1.15   15 Apr 1996 13:59:42   cjutzi
 *
 * - added conflict resolution
 *  needed to change the api data structure to keep track of the
 *   outstanding data type..
 *
 *
 *    Rev 1.13   01 Apr 1996 16:50:48   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.12   26 Mar 1996 09:49:08   cjutzi
 *
 * - ok.. Added Enter&Leave&Init&Delete Critical Sections for Ring 0
 *
 *    Rev 1.11   13 Mar 1996 14:11:38   cjutzi
 *
 * - removed trace message from PLOCK and VLOCK
 * d
 *
 *    Rev 1.10   13 Mar 1996 09:14:06   cjutzi
 * - changed LPCRITICAL SECTION to CRITICAL_SECITON *
 *
 *    Rev 1.9   12 Mar 1996 15:49:08   cjutzi
 *
 * - added locking
 *
 *    Rev 1.8   08 Mar 1996 14:08:02   cjutzi
 *
 * - added MuxCapsSet and MuxTable stuff for tracking..
 *
 *    Rev 1.7   05 Mar 1996 09:55:08   cjutzi
 *
 * - added mux table stuff
 *
 *    Rev 1.6   01 Mar 1996 13:47:26   cjutzi
 *
 * - added a state to Tracker for release indications from fsm
 *
 *    Rev 1.5   15 Feb 1996 10:48:00   cjutzi
 * - added some structs to API
 * - added some defines for API
 *
 *    Rev 1.4   09 Feb 1996 16:43:06   cjutzi
 *
 * - added some states
 * - added some tracker types
 *  $Ident$
 *
 *****************************************************************************/

#ifndef _API_H
#define _API_H

/********************************************************/
/*		api Decl				*/
/********************************************************/
#include <h245api.h>		/* Instance and TypeDefs  */
#include <h245sys.x>		/* critical section stuff */
#include <h245asn1.h>		/* for TermCaps		  */

/* STATES */


#define TRANSMIT 		0
#define RECEIVE			1

#define H245_LOCAL 		2
#define H245_REMOTE		3

/* from api_util.c */
HRESULT api_init   (struct InstanceStruct *pInstance);
HRESULT api_deinit (struct InstanceStruct *pInstance);

typedef struct H245_LINK_T
{
  struct H245_LINK_T 	*p_next;
} H245_LINK_T;

typedef
enum {
  API_TERMCAP_T = 0,
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  API_MSTSLV_T,
  API_SEND_MUX_T,
  API_RECV_MUX_T,

} API_TRACKER_T;


typedef
enum {
  API_ST_WAIT_RMTACK = 0x10,		/* waiting for remote ask	*/
  API_ST_WAIT_LCLACK,			/* waiting for local ack 	*/
  API_ST_WAIT_LCLACK_CANCEL,		/* request was canceled.. 	*/
  API_ST_WAIT_CONF,			/* waiting for open confirm (bi only) */
  API_ST_IDLE				/* for open only 		*/

} API_TRACKER_STATE_T;


typedef
enum {
  API_CH_ALLOC_UNDEF = 0x20,
  API_CH_ALLOC_LCL,
  API_CH_ALLOC_RMT
} API_TRACKER_CH_ALLOC_T;

typedef
enum {
  API_CH_TYPE_UNDEF = 0x030,
  API_CH_TYPE_UNI,
  API_CH_TYPE_BI
} API_TRACKER_CH_T;


/* Tracker Structure */
typedef struct
{
  API_TRACKER_CH_ALLOC_T  ChannelAlloc;	/* who allocated the channel 	   */
  API_TRACKER_CH_T	  ChannelType; 	/* either bi or uni 		   */
  DWORD			  TxChannel;	/* for bi&uni-directional channel  */
  DWORD			  RxChannel;	/* for bi-directional channel only */
  H245_CLIENT_T		  DataType;	/* data type used for conflict     */
    					/* detection 			   */
} TrackerChannelStruct;

typedef union
{
  /*
  API_OPEN_CHANNEL_T,
  API_CLOSE_CHANNEL_T,
  */
  TrackerChannelStruct  Channel;

  /*
  API_SEND_MUX_T,
  API_RECV_MUX_T,
  */
  DWORD			MuxEntryCount;

  /* don't care */
  /*
  API_MSTSLV_T,
  API_TERMCAP_T
  */
} TrackerUnion;

typedef struct TrackerStruct
{
  struct TrackerStruct 	*p_next;
  struct TrackerStruct	*p_prev;
  DWORD_PTR 		TransId;
  API_TRACKER_STATE_T	State;
  API_TRACKER_T		TrackerType;
  TrackerUnion          u;
} Tracker_T;

/* API Structure */
typedef struct
{
  enum {
    APIMS_Undef,
    APIMS_InProcess,
    APIMS_Master,
    APIMS_Slave
  }				 MasterSlave;	 /* master or slave or inprocess */
  enum {
    APIST_Undef,
    APIST_Inited,
    APIST_Connecting,
    APIST_Connected,
    APIST_Disconnected
  }				 SystemState;	 /* */

  DWORD				 MuxCapsSet;
  DWORD_PTR  		 dwPreserved;
  H245_CONF_IND_CALLBACK_T	 ConfIndCallBack;/* callback for H245 Client	*/

  H245_CAPID_T                   LocalCapIdNum;
  H245_CAPDESCID_T      	 LocalCapDescIdNum;

  MltmdSystmCntrlMssg		 PDU_LocalTermCap;
  MltmdSystmCntrlMssg		 PDU_RemoteTermCap;
#define TERMCAPSET u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet
  Tracker_T			*pTracker;
} API_STRUCT_T;

#endif // _API_H_



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\as\thk\asthk.h ===
// --------------------------------------------------------------------------
//
//  ASTHK.H
//
//  Declarations of 32->16 thunk APIs
//
//  Copyright(c) Microsoft, 1996-
//
//
//  On non x86 platforms, these APIs are #defined instead of implemented,
//  since thunks are in .ASM and that is only x86.  We'll clean this W95-NT
//  stuff up later.
//
// --------------------------------------------------------------------------
#ifndef _H_ASTHK
#define _H_ASTHK


//
// MAIN functions
//

//
// Prototypes for secret KERNEL32 functions
//
BOOL        WINAPI  FT_thkConnectToFlatThkPeer(LPSTR pszDll16, LPSTR pszDll32);
UINT        WINAPI  FreeLibrary16(UINT hmod16);

//
// NMNASWIN.DLL functions
//

// General
void        WINAPI  OSILoad16(LPDWORD lphInst);
BOOL        WINAPI  OSIInit16(DWORD version, HWND hwnd, ATOM atom, LPDWORD ppdcsShared,
    LPDWORD ppoaShared, LPDWORD ppimShared, LPDWORD psbcEnabled,
    LPDWORD pShuntBuffers, LPDWORD pBitmasks);
void        WINAPI  OSITerm16(BOOL fUnloading);
BOOL        WINAPI  OSIFunctionRequest16(DWORD escape, void FAR* lpvEscInfo, DWORD cbEscInfo);

// HET
BOOL        WINAPI  OSIStartWindowTracking16(void);
void        WINAPI  OSIStopWindowTracking16(void);
BOOL        WINAPI  OSIIsWindowScreenSaver16(HWND hwnd);
BOOL        WINAPI  OSIShareWindow16(HWND, UINT, BOOL, BOOL);
BOOL        WINAPI  OSIUnshareWindow16(HWND, BOOL);

// IM
BOOL        WINAPI  OSIInstallControlledHooks16(BOOL fEnable, BOOL fDesktop);
void        WINAPI  OSIInjectMouseEvent16(UINT flags, int x, int y, UINT mouseData, DWORD dwExtraInfo);
void        WINAPI  OSIInjectKeyboardEvent16(UINT flags, WORD vkCode, WORD scanCode, DWORD dwExtraInfo);

#endif // _H_ASTHK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api_debu.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_Debu.c  $
 *  $Revision:   1.4  $
 *  $Modtime:   10 Jun 1996 12:36:08  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_Debu.c_v  $
 * 
 *    Rev 1.4   10 Jun 1996 16:53:06   EHOWARDX
 * Eliminated #include "h245init.x"
 * 
 *    Rev 1.3   06 Jun 1996 18:51:14   EHOWARDX
 * Made tracker dump more aesthetically pleasing.
 *
 *    Rev 1.2   28 May 1996 14:25:36   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.1   20 May 1996 14:34:42   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.7   09 May 1996 19:30:24   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.6   02 Apr 1996 10:14:08   cjutzi
 * - changed tracker structure
 *
 *    Rev 1.5   11 Mar 1996 14:28:48   cjutzi
 *
 * - removed oil debug include
 * d
 *
 *    Rev 1.4   06 Mar 1996 12:33:46   cjutzi
 * - renamed API_MUX_T to API_SEND_MUX_T
 *
 *    Rev 1.3   16 Feb 1996 13:00:30   cjutzi
 *
 * - added tracker dumper
 *
 *    Rev 1.2   15 Feb 1996 15:42:52   cjutzi
 *
 * - std.h and wtypes.h modified.. al'a Loren..
 *
 *    Rev 1.1   09 Feb 1996 16:58:08   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *  $Ident$
 *
 *****************************************************************************/

#ifndef STRICT 
#define STRICT 
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dump_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/

void
dump_tracker(struct InstanceStruct *pInstance)
{
  register Tracker_T *p_tracker;
  register char      *p_str;

  ASSERT (pInstance != NULL);
  H245TRACE(pInstance->dwInst, 0, "************ TRACKER DUMP START ********");

  for (p_tracker = pInstance->API.pTracker; p_tracker; p_tracker = p_tracker->p_next)
    {
      if (p_tracker != pInstance->API.pTracker)
        H245TRACE(pInstance->dwInst, 0, "");
      H245TRACE(pInstance->dwInst, 0, "TransId           %04d(0x%04x)",p_tracker->TransId,p_tracker->TransId);
      switch (p_tracker->TrackerType)
        {
        case API_TERMCAP_T:             p_str="API_TERMCAP_T";      break;
        case API_OPEN_CHANNEL_T:        p_str="API_OPEN_CHANNEL_T"; break;
        case API_CLOSE_CHANNEL_T:       p_str="API_CLOSE_CHANNEL_T";break;
        case API_MSTSLV_T:              p_str="API_MSTSLV_T";       break;
        case API_SEND_MUX_T:            p_str="API_SEND_MUX_T";     break;
        case API_RECV_MUX_T:            p_str="API_RECV_MUX_T";     break;
        default:        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 0, "Tracker Type      %s",p_str);
      switch (p_tracker->State)
        {
        case API_ST_WAIT_RMTACK:        p_str="API_ST_WAIT_RMTACK"; break;
        case API_ST_WAIT_LCLACK:        p_str="API_ST_WAIT_LCLACK"; break;
        case API_ST_WAIT_LCLACK_CANCEL: p_str="API_ST_WAIT_LCLACK_CANCEL"; break;
        case API_ST_WAIT_CONF:          p_str="API_ST_WAIT_CONF";   break;
        case API_ST_IDLE:               p_str="API_ST_IDLE";        break;
        default:                        p_str="<<UNKNOWN>>";        break;
        }
      H245TRACE(pInstance->dwInst, 0, "Tracker State     %s",p_str);

      if (p_tracker->TrackerType == API_OPEN_CHANNEL_T ||
          p_tracker->TrackerType == API_CLOSE_CHANNEL_T)
        {
          switch (p_tracker->u.Channel.ChannelAlloc)
            {
            case API_CH_ALLOC_UNDEF:    p_str="API_CH_ALLOC_UNDEF"; break;
            case API_CH_ALLOC_LCL:      p_str="API_CH_ALLOC_LCL";   break;
            case API_CH_ALLOC_RMT:      p_str="API_CH_ALLOC_RMT";   break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 0, "Channel Alloc     %s",p_str);
          switch (p_tracker->u.Channel.ChannelType)
            {
            case API_CH_TYPE_UNDEF:     p_str="API_CH_TYPE_UNDEF";  break;
            case API_CH_TYPE_UNI:       p_str="API_CH_TYPE_UNI";    break;
            case API_CH_TYPE_BI:        p_str="API_CH_TYPE_BI";     break;
            default:                    p_str="<<UNKNOWN>>";        break;
            }
          H245TRACE(pInstance->dwInst, 0, "Channel Type      %s",p_str);
          if (p_tracker->u.Channel.RxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 0, "Channel Rx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 0, "Channel Rx        %d",p_tracker->u.Channel.RxChannel);
          if (p_tracker->u.Channel.TxChannel == H245_INVALID_CHANNEL)
            H245TRACE(pInstance->dwInst, 0, "Channel Tx        H245_INVALID_CHANNEL");
          else
            H245TRACE(pInstance->dwInst, 0, "Channel Tx        %d",p_tracker->u.Channel.TxChannel);
        }
      else if (p_tracker->TrackerType == API_SEND_MUX_T ||
               p_tracker->TrackerType == API_RECV_MUX_T)
        {
          H245TRACE(pInstance->dwInst, 0, "MuxEntryCount     %d",p_tracker->u.MuxEntryCount);
        }
    }

  H245TRACE(pInstance->dwInst, 0, "************ TRACKER DUMP END **********");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api_up.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  $Workfile:   api_up.c  $
 *  $Revision:   1.33  $
 *  $Modtime:   06 Feb 1997 14:37:24  $
 *  $Log:   S:\sturgeon\src\h245\src\vcs\api_up.c_v  $
 *
 *    Rev 1.33   06 Feb 1997 18:14:22   SBELL1
 * took out ossDecoding of returnFunction in FunctionNotSupported PDU.
 *
 *    Rev 1.32   05 Feb 1997 16:46:42   EHOWARDX
 * Was allocating nLength bytes, not WCHARS, for UserInputIndication
 * ASCII to Unicode conversion. Changed to allocate nLength WCHARs.
 *
 *    Rev 1.31   06 Jan 1997 20:38:18   EHOWARDX
 *
 * Changed H245_CONF_CLOSE and H245_CONF_REQ_CLOSE to fill in
 * AccRej with H245_REJ for any errors.
 *
 *    Rev 1.30   19 Dec 1996 21:00:56   EHOWARDX
 * Oops! H245_IND_OPEN_CONF can occur from T103 timeout (it's unique among
 * indications; it's the only one that can happen in response to a timeout!)
 *
 *    Rev 1.29   19 Dec 1996 17:18:22   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 *
 *    Rev 1.28   18 Dec 1996 16:33:18   EHOWARDX
 *
 * Fixed bug in Master Slave Determination Kludge.
 *
 *    Rev 1.27   17 Dec 1996 17:13:20   EHOWARDX
 * Added pSeparateStack to IND_OPEN_T.
 *
 *    Rev 1.26   12 Dec 1996 15:57:12   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.25   21 Oct 1996 16:07:38   EHOWARDX
 * Modified to make sure H245_INDETERMINATE is returned and Master/Slave
 * status if determination fails.
 *
 *    Rev 1.24   17 Oct 1996 18:17:14   EHOWARDX
 * Changed general string to always be Unicode.
 *
 *    Rev 1.23   14 Oct 1996 14:01:12   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.22   27 Aug 1996 10:54:16   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.22   27 Aug 1996 10:52:28   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.22   27 Aug 1996 09:54:12   unknown
 * Deleted redundant lines.
 *
 *    Rev 1.21   26 Aug 1996 14:19:18   EHOWARDX
 * Added code to send FunctionNotUnderstood indication to remote peer
 * if receive callback returns H245_ERROR_NOSUP.
 *
 *    Rev 1.20   20 Aug 1996 14:44:40   EHOWARDX
 * Changed H245_IND_COMM_MODE_RESPONSE and H245_IND_COMM_MODE_COMMAND
 * callbacks to fill in DataType field in Cap as per Mike Andrews' request.
 *
 *    Rev 1.19   15 Aug 1996 15:20:24   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.18   15 Aug 1996 09:34:20   EHOWARDX
 * Made TOTCAP and MUX structure in process_open_ind static since we are
 * accessing pointers to them after return from the function.
 *
 *    Rev 1.17   29 Jul 1996 19:33:00   EHOWARDX
 *
 * Fixed bug in flow control - missing break in restriction switch statement.
 *
 *    Rev 1.16   19 Jul 1996 14:11:26   EHOWARDX
 *
 * Added indication callback structure for CommunicationModeResponse
 * and CommunicationModeCommand.
 *
 *    Rev 1.15   19 Jul 1996 12:48:00   EHOWARDX
 *
 * Multipoint clean-up.
 *
 *    Rev 1.14   09 Jul 1996 17:09:28   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.13   01 Jul 1996 22:13:04   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.12   18 Jun 1996 14:50:28   EHOWARDX
 *
 * Changed MLSE confirm handling.
 *
 *    Rev 1.11   14 Jun 1996 18:57:52   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.10   10 Jun 1996 16:55:34   EHOWARDX
 * Removed #include "h245init.x"
 *
 *    Rev 1.9   06 Jun 1996 18:45:52   EHOWARDX
 * Added check for null dwTransId to Tracker routines; changed to use
 * tracker routines instead of PLOCK macros.
 *
 *    Rev 1.8   04 Jun 1996 13:56:46   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.7   30 May 1996 23:39:00   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.6   29 May 1996 15:20:06   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.5   28 May 1996 14:22:58   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.4   20 May 1996 22:17:58   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.3   16 May 1996 19:40:46   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.2   16 May 1996 15:59:24   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.1   13 May 1996 23:16:26   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.0   09 May 1996 21:06:08   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.23.1.11   09 May 1996 19:31:30   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.23.1.10   01 May 1996 19:30:32   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.23.1.9   29 Apr 1996 16:02:58   EHOWARDX
 * Changed callback to give second parameters as pointer to specific message
 * instead of pointer to general PDU structure.
 *
 *    Rev 1.23.1.8   27 Apr 1996 21:09:40   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.23.1.7   26 Apr 1996 15:54:34   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 *
 *    Rev 1.23.1.6   24 Apr 1996 20:53:56   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.23.1.5   23 Apr 1996 14:45:28   EHOWARDX
 * Disabled Curt's "Conflict Resolution".
 *
 *    Rev 1.23.1.4   19 Apr 1996 12:55:10   EHOWARDX
 * Updated to 1.29
 *
 *    Rev 1.23.1.3   17 Apr 1996 14:37:38   unknown
 * Added load_H222_param(), load_VGMUX_param(), and load_H2250_param() and
 * modified process_open_ind() to use them.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:10:32   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:15:00   EHOWARDX
 * No change.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:04   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.23   01 Apr 1996 16:46:20   cjutzi
 *
 * - changed tracker structure
 * - Completed ENdConnection, and made asynch.. rather
 * than sync.. as before
 * Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.22   29 Mar 1996 14:54:28   cjutzi
 * - added UserInput,
 *
 *    Rev 1.21   28 Mar 1996 15:57:46   cjutzi
 * - removed ASSERT line 1290.. close can occur on any channel at any time
 *
 *    Rev 1.20   27 Mar 1996 08:36:40   cjutzi
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.19   26 Mar 1996 13:48:30   cjutzi
 *
 * - dwPreserved in the callback routine was uninitialized..
 *
 *    Rev 1.18   18 Mar 1996 15:23:30   cjutzi
 *
 *
 *
 *    Rev 1.17   13 Mar 1996 14:14:02   cjutzi
 *
 * - clean up and added ASSERTs ..
 *
 *    Rev 1.16   13 Mar 1996 12:06:12   cjutzi
 *
 * - fixed .. CONFIRM open.. for hani.. It released the tracker..
 *     was supposed to simply update the state to IDLE..
 *
 *    Rev 1.15   13 Mar 1996 09:22:12   cjutzi
 *
 * - removed CRITICAL SECTIONS
 *
 *    Rev 1.14   12 Mar 1996 15:52:32   cjutzi
 *
 * - fixed master slave (forgot a break)
 * - fixed callback bug w/ cleanup on termcaps.
 * - implemented End Session
 * - fixed shutdown
 * - Implemented Locking (big changes here.. )
 *
 *    Rev 1.13   08 Mar 1996 14:04:18   cjutzi
 *
 * - implemented the upcall for mux table entries..
 * - implemented capabillity descriptor callback
 *
 *    Rev 1.12   05 Mar 1996 17:36:28   cjutzi
 *
 * - added MasterSlave indication message
 * - remove bzero/bcopy and changed free call
 * - implemented Mux Table down.. (not up)
 *
 *    Rev 1.11   01 Mar 1996 14:16:08   cjutzi
 *
 * - added hani's error messages.. MasterSlave_FAILED.. oppss.. Forgot..
 *
 *    Rev 1.10   01 Mar 1996 13:47:58   cjutzi
 *
 * - added hani's new fsm id's
 *
 *    Rev 1.9   29 Feb 1996 17:26:16   cjutzi
 * - bi-directional channel open working
 *
 *    Rev 1.8   27 Feb 1996 14:56:30   cjutzi
 *
 * - fixed termcap_ack.. pdu was not being zero'd out..
 * - cleaned up the code alittle..
 *
 *    Rev 1.7   26 Feb 1996 17:22:40   cjutzi
 *
 * - Misc Command Indication added
 *
 *    Rev 1.6   26 Feb 1996 11:05:48   cjutzi
 *
 * - lot's o-changes.. (sorry)
 *
 *    Rev 1.5   16 Feb 1996 13:01:54   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.4   15 Feb 1996 14:11:46   cjutzi
 *
 * - added muxt table to incoming open..
 *
 *    Rev 1.3   15 Feb 1996 10:51:56   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback for IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDSRSP
 * - cleaned up the open.
 * - modified H223 stuff
 *
 *    Rev 1.2   09 Feb 1996 16:58:28   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "h245asn1.h"
#include "fsmexpor.h"
#include "api_util.x"
#include "pdu.x"



HRESULT
LoadUnicastAddress  (H245_TRANSPORT_ADDRESS_T *pOut,
                     UnicastAddress           *pIn)
{
  switch (pIn->choice)
  {
  case UnicastAddress_iPAddress_chosen:
    pOut->type = H245_IP_UNICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.UnicastAddress_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.UnicastAddress_iPAddress.tsapIdentifier;
    break;

  case iPXAddress_chosen:
    pOut->type = H245_IPX_UNICAST;
    memcpy(pOut->u.ipx.node,
           pIn->u.iPXAddress.node.value,
           6);
    memcpy(pOut->u.ipx.netnum,
           pIn->u.iPXAddress.netnum.value,
           4);
    memcpy(pOut->u.ipx.tsapIdentifier,
           pIn->u.iPXAddress.tsapIdentifier.value,
           2);
    break;

  case UncstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_UNICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.UncstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.UncstAddrss_iP6Address.tsapIdentifier;
    break;

  case netBios_chosen:
    pOut->type = H245_NETBIOS_UNICAST;
    memcpy(pOut->u.netBios, pIn->u.netBios.value, 16);
    break;

  case iPSourceRouteAddress_chosen:
    switch (pIn->u.iPSourceRouteAddress.routing.choice)
    {
    case strict_chosen:
      pOut->type = H245_IPSSR_UNICAST;
      break;

    case loose_chosen:
      pOut->type = H245_IPLSR_UNICAST;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
    memcpy(pOut->u.ipSourceRoute.network,
           pIn->u.iPSourceRouteAddress.network.value,
           4);
    pOut->u.ipSourceRoute.tsapIdentifier = pIn->u.iPSourceRouteAddress.tsapIdentifier;
    // TBD - handle route
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadUnicastAddress()



HRESULT
LoadMulticastAddress(H245_TRANSPORT_ADDRESS_T *pOut,
                     MulticastAddress         *pIn)
{
  switch (pIn->choice)
  {
  case MltcstAddrss_iPAddress_chosen:
    pOut->type = H245_IP_MULTICAST;
    memcpy(pOut->u.ip.network,
           pIn->u.MltcstAddrss_iPAddress.network.value,
           4);
    pOut->u.ip.tsapIdentifier = pIn->u.MltcstAddrss_iPAddress.tsapIdentifier;
    break;

  case MltcstAddrss_iP6Address_chosen:
    pOut->type = H245_IP6_MULTICAST;
    memcpy(pOut->u.ip6.network,
           pIn->u.MltcstAddrss_iP6Address.network.value,
           16);
    pOut->u.ip6.tsapIdentifier = pIn->u.MltcstAddrss_iP6Address.tsapIdentifier;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
  return H245_ERROR_OK;
} // LoadMulticastAddress()



HRESULT
LoadTransportAddress(H245_TRANSPORT_ADDRESS_T  *pOut,
                     H245TransportAddress          *pIn)
{
  switch (pIn->choice)
  {
  case unicastAddress_chosen:
    return LoadUnicastAddress  (pOut, &pIn->u.unicastAddress);

  case multicastAddress_chosen:
    return LoadMulticastAddress(pOut, &pIn->u.multicastAddress);

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch
} // LoadTransportAddress()



HRESULT
LoadCommModeEntry(H245_COMM_MODE_ENTRY_T       *pOut,
                  CommunicationModeTableEntry  *pIn)
{
  HRESULT   lResult;

  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & CMTEy_nnStndrd_present)
  {
    pOut->pNonStandard = pIn->CMTEy_nnStndrd;
  }

  pOut->sessionID = (unsigned char)pIn->sessionID;

  if (pIn->bit_mask & CMTEy_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->CMTEy_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & CommunicationModeTableEntry_terminalLabel_present)
  {
    pOut->terminalLabel = pIn->terminalLabel;
    pOut->terminalLabelPresent = TRUE;
  }

  pOut->pSessionDescription       = pIn->sessionDescription.value;
  pOut->wSessionDescriptionLength = (WORD) pIn->sessionDescription.length;

  switch (pIn->dataType.choice)
  {
  case dataType_videoData_chosen:
    pOut->dataType.DataType = H245_DATA_VIDEO;
    break;

  case dataType_audioData_chosen:
    pOut->dataType.DataType = H245_DATA_AUDIO;
    break;

  case dataType_data_chosen:
    pOut->dataType.DataType = H245_DATA_DATA;
    break;

  default:
    return H245_ERROR_INVALID_DATA_FORMAT;
  } // switch

  lResult = build_totcap_cap_n_client_from_capability ((struct Capability *)&pIn->dataType,
                                                       pOut->dataType.DataType,
                                                       pIn->dataType.u.dataType_videoData.choice,
                                                       &pOut->dataType);
  if (lResult != H245_ERROR_OK)
    return lResult;

  if (pIn->bit_mask & CMTEy_mdChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaChannel, &pIn->CMTEy_mdChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->CMTEy_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlChnnl_present)
  {
    lResult = LoadTransportAddress(&pOut->mediaControlChannel, &pIn->CMTEy_mdCntrlChnnl);
    if (lResult != H245_ERROR_OK)
      return lResult;
    pOut->mediaControlChannelPresent = TRUE;
  }

  if (pIn->bit_mask & CMTEy_mdCntrlGrntdDlvry_present)
  {
    pOut->mediaControlGuaranteed = pIn->CMTEy_mdCntrlGrntdDlvry;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  return H245_ERROR_OK;
} // LoadCommModeEntry()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   load_H222_param
 *              load_H223_param
 *              load_VGMUX_param
 *              load_H2250_param
 *              load_H2250ACK_param
 *
 * DESCRIPTION
 *
 *              This routine builds local API-style Logical Parameters out of ASN.1
 *              structure passed to it
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
load_H222_param (H245_H222_LOGICAL_PARAM_T *    pOut,   /* output */
                 H222LogicalChannelParameters * pIn)    /* input  */
{
  /* See setup_H220_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->resourceID   = pIn->resourceID;
  pOut->subChannelID = pIn->subChannelID;
  if (pIn->bit_mask & pcr_pid_present)
  {
    pOut->pcr_pidPresent = TRUE;
    pOut->pcr_pid = pIn->pcr_pid;
  }
  if (pIn->bit_mask & programDescriptors_present)
  {
    pOut->programDescriptors.length = pIn->programDescriptors.length;
    pOut->programDescriptors.value  = pIn->programDescriptors.value;
  }
  if (pIn->bit_mask & streamDescriptors_present)
  {
    pOut->streamDescriptors.length = pIn->streamDescriptors.length;
    pOut->streamDescriptors.value  = pIn->streamDescriptors.value;
  }
  return H245_ERROR_OK;
} // load_H222_param()

static HRESULT
load_H223_param (H245_H223_LOGICAL_PARAM_T *    pOut,   /* output */
                 H223LogicalChannelParameters * pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H223_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->SegmentFlag = pIn->segmentableFlag;

  switch (pIn->adaptationLayerType.choice)
    {
    case H223LCPs_aLTp_nnStndrd_chosen:
      lError = CopyNonStandardParameter(&pOut->H223_NONSTD,
                                         &pIn->adaptationLayerType.u.H223LCPs_aLTp_nnStndrd);
      pOut->AlType = H245_H223_AL_NONSTD;
      break;
    case H223LCPs_aLTp_al1Frmd_chosen:
      pOut->AlType = H245_H223_AL_AL1FRAMED;
      break;
    case H223LCPs_aLTp_al1NtFrmd_chosen:
      pOut->AlType = H245_H223_AL_AL1NOTFRAMED;
      break;
    case H223LCPs_aLTp_a2WSNs_1_chosen:
      pOut->AlType = H245_H223_AL_AL2NOSEQ;
      break;
    case H223LCPs_aLTp_a2WSNs_2_chosen:
      pOut->AlType = H245_H223_AL_AL2SEQ;
      break;
    case H223LCPs_aLTp_al3_chosen:
      pOut->AlType = H245_H223_AL_AL3;
      pOut->CtlFldOctet = (unsigned char)pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.controlFieldOctets;
      pOut->SndBufSize  = pIn->adaptationLayerType.u.H223LCPs_aLTp_al3.sendBufferSize;
      break;
    } /* switch */

  return lError;
} // load_H223_param()

static HRESULT
load_VGMUX_param(H245_VGMUX_LOGICAL_PARAM_T  *pOut,   /* output */
                 V76LogicalChannelParameters *pIn)    /* input  */
{
  /* See setup_VGMUX_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  pOut->crcLength             = pIn->hdlcParameters.crcLength.choice;
  pOut->n401                  = pIn->hdlcParameters.n401;
  pOut->loopbackTestProcedure = pIn->hdlcParameters.loopbackTestProcedure;
  pOut->suspendResume         = pIn->suspendResume.choice;
  pOut->uIH                   = pIn->uIH;
  pOut->mode                  = pIn->mode.choice;
  switch (pIn->mode.choice)
  {
  case eRM_chosen:
    pOut->windowSize          = pIn->mode.u.eRM.windowSize;
    pOut->recovery            = pIn->mode.u.eRM.recovery.choice;
    break;
  } // switch
  pOut->audioHeaderPresent    = pIn->v75Parameters.audioHeaderPresent;
  return H245_ERROR_OK;
} // load_VGMUX_param()

static HRESULT
load_H2250_param(H245_H2250_LOGICAL_PARAM_T *   pOut,   /* output */
                 H2250LogicalChannelParameters *pIn)    /* input  */
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCPs_nnStndrd;
  }

  pOut->sessionID = (unsigned char) pIn->sessionID;

  if (pIn->bit_mask & H2250LCPs_assctdSssnID_present)
  {
    pOut->associatedSessionID = (unsigned char)pIn->H2250LCPs_assctdSssnID;
    pOut->associatedSessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                           &pIn->H2250LCPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mdGrntdDlvry_present)
  {
    pOut->mediaGuaranteed = pIn->H2250LCPs_mdGrntdDlvry;
    pOut->mediaGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                    &pIn->H2250LCPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCPs_mCGDy_present)
  {
    pOut->mediaControlGuaranteed = pIn->H2250LCPs_mCGDy;
    pOut->mediaControlGuaranteedPresent = TRUE;
  }

  if (pIn->bit_mask & silenceSuppression_present)
  {
    pOut->silenceSuppression = pIn->silenceSuppression;
    pOut->silenceSuppressionPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LogicalChannelParameters_destination_present)
  {
    pOut->destination = pIn->destination;
    pOut->destinationPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  if (pIn->bit_mask & mediaPacketization_present)
  {
    switch (pIn->mediaPacketization.choice)
    {
    case h261aVideoPacketization_chosen:
      pOut->h261aVideoPacketization = TRUE;
      break;

    default:
      return H245_ERROR_INVALID_DATA_FORMAT;
    } // switch
  }

  return lError;
} // load_H2250_param()

static HRESULT
load_H2250ACK_param(H245_H2250ACK_LOGICAL_PARAM_T *     pOut,
                    H2250LgclChnnlAckPrmtrs *           pIn)
{
  HRESULT                lError = H245_ERROR_OK;

  /* See setup_H2250ACK_mux() for inverse function */
  memset(pOut, 0, sizeof(*pOut));

  if (pIn->bit_mask & H2250LCAPs_nnStndrd_present)
  {
    pOut->nonStandardList = pIn->H2250LCAPs_nnStndrd;
  }

  if (pIn->bit_mask & sessionID_present)
  {
    pOut->sessionID = (unsigned char) pIn->sessionID;
    pOut->sessionIDPresent = TRUE;
  }

  if (pIn->bit_mask & H2250LCAPs_mdChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaChannel,
                                    &pIn->H2250LCAPs_mdChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_mdCntrlChnnl_present)
  {
    if (lError == H245_ERROR_OK)
    {
      lError = LoadTransportAddress(&pOut->mediaControlChannel,
                                     &pIn->H2250LCAPs_mdCntrlChnnl);
      if (lError == H245_ERROR_OK)
      {
        pOut->mediaControlChannelPresent = TRUE;
      }
    }
  }

  if (pIn->bit_mask & H2250LCAPs_dRTPPTp_present)
  {
    pOut->dynamicRTPPayloadType = (unsigned char)pIn->H2250LCAPs_dRTPPTp;
    pOut->dynamicRTPPayloadTypePresent = TRUE;
  }

  return lError;
} // load_H2250ACK_param()



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_element_list_from_mux -
 *
 * DESCRIPTION
 *              recursively build H245_MUX_ENTRY_ELEMENT_T list from
 *              ASN1 mux table descriptor entrys.
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_ENTRY_ELEMENT_T *
build_element_list_from_mux (MultiplexElement *p_ASN_mux_el,
                             H245_ACC_REJ_T   *p_acc_rej)
{
  DWORD                     ii;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;
  H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;

  if (!(p_mux_el = (H245_MUX_ENTRY_ELEMENT_T *)MemAlloc(sizeof(H245_MUX_ENTRY_ELEMENT_T))))
    {
      /* too complicated.. ran out of memory */
      H245TRACE(0,1,"build_element_list_from_mux : H245_ERROR_NOMEM");
      *p_acc_rej = H245_REJ_MUX_COMPLICATED;
      return NULL;
    }

  /* zero it out */
  memset (p_mux_el, 0, sizeof(H245_MUX_ENTRY_ELEMENT_T));

  switch (p_ASN_mux_el->type.choice)
    {
    case typ_logicalChannelNumber_chosen:
      /* assign as a logical channel */
      p_mux_el->Kind = H245_MUX_LOGICAL_CHANNEL;
      p_mux_el->u.Channel = p_ASN_mux_el->type.u.typ_logicalChannelNumber;
      break;
    case subElementList_chosen:
      {
        /* if the sub element list doesn't exist .. no go           */
        /* if the sub element list has less than 2 entries.. no go. */
        if ((!p_ASN_mux_el->type.u.subElementList) ||
            (p_ASN_mux_el->type.u.subElementList->count < 2))
          {
            /* invalid Element list.. */
            H245TRACE(0,1,"build_element_list_from_mux : << ERROR >> Element Count < 2");
            *p_acc_rej = H245_REJ;
            free_mux_el_list (p_mux_el);
            return NULL;
          }

        /* assign as entry element */
        p_mux_el->Kind = H245_MUX_ENTRY_ELEMENT;

        /* ok.. for every sub element in the list */
        for (ii=0;ii<p_ASN_mux_el->type.u.subElementList->count;ii++)
          {
            if (!(p_mux_el_tmp = build_element_list_from_mux (&p_ASN_mux_el->type.u.subElementList->value[ii], p_acc_rej)))
              {
                /* *p_acc_rej is set from below */
                free_mux_el_list (p_mux_el);
                return NULL;
              }

            /* if first on the down sub element list.. assign to sub    */
            /* element  portion of mux_el                               */

            if (!p_mux_el_lst)
              p_mux_el->u.pMuxTblEntryElem = p_mux_el_tmp;
            /* otherwise.. just a list.. add it on.. */
            else
              p_mux_el_lst->pNext = p_mux_el_tmp;

            p_mux_el_lst = p_mux_el_tmp;
          }
      }
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'type.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
    }

  switch (p_ASN_mux_el->repeatCount.choice)
    {
    case repeatCount_finite_chosen:
      p_mux_el->RepeatCount = p_ASN_mux_el->repeatCount.u.repeatCount_finite;
      break;
    case untilClosingFlag_chosen:
      p_mux_el->RepeatCount = 0;
      break;
    default:
      /* Un supported structure */
      H245TRACE(0,1,"build_element_list_from_mux : INVALID MUX TABLE ENTRY PDU 'repeatCount.choice' unknown");
      *p_acc_rej = H245_REJ;
      free_mux_el_list (p_mux_el);
      return NULL;
      break;
    }

  return p_mux_el;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_mux_table_ind
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/
static H245_MUX_TABLE_T *
process_mux_table_ind (MltmdSystmCntrlMssg      *p_pdu_ind,
                       unsigned short           *p_seq,
                       H245_ACC_REJ_MUX_T       rej_mux,
                       DWORD                    *p_rej_cnt,
                       DWORD                    *p_acc_cnt)
{
  UINT                          ii;                     /* generic counter */
  MultiplexEntrySend           *p_ASN_mux;              /* ans1 mux entry  */
  MultiplexEntryDescriptorLink  p_ASN_med_desc_lnk;     /* asn1 mux entry descriptor */
  int                           mux_entry;              /* current mux entry descc   */
  H245_MUX_TABLE_T             *p_mux_table_list = NULL;

  ASSERT(p_pdu_ind->choice == MltmdSystmCntrlMssg_rqst_chosen);
  ASSERT(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);

  /* initialize rej_mux */
  for (ii=0;ii<15;ii++)
    {
      rej_mux[ii].AccRej = H245_ACC;
      rej_mux[ii].MuxEntryId = 0;
    }
  *p_rej_cnt = 0;
  *p_acc_cnt = 0;

  p_ASN_mux = &(p_pdu_ind->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend);

  /* get sequence number */
  *p_seq = p_ASN_mux->sequenceNumber;

  /* this should never happen.. */
  if (!(p_ASN_mux->multiplexEntryDescriptors))
    return NULL;

  /* for each descriptor.. ie mux table entry  */
  for (p_ASN_med_desc_lnk = p_ASN_mux->multiplexEntryDescriptors, mux_entry=0;
       p_ASN_med_desc_lnk;
       p_ASN_med_desc_lnk = p_ASN_med_desc_lnk->next, mux_entry++)
    {
      /* remove descriptor from table */
      H245_MUX_TABLE_T  *p_mux_table;
      H245_MUX_TABLE_T  *p_mux_table_lst = NULL;

      if (!(p_mux_table = (H245_MUX_TABLE_T *)MemAlloc(sizeof(H245_MUX_TABLE_T))))
        {
          /* houston.. we have a problem !!!!!!!! */
          /* rejet this one..                     */
          /* and move on..                        */

          rej_mux[mux_entry].MuxEntryId = p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;
          rej_mux[mux_entry].AccRej  = H245_REJ;
          (*p_rej_cnt)++;
          continue;
        }

      /* zero it out */
      memset (p_mux_table, 0, sizeof(H245_MUX_TABLE_T));

      /* assign mux table entry */
      rej_mux[mux_entry].MuxEntryId = (DWORD)
        p_mux_table->MuxEntryId =
          p_ASN_med_desc_lnk->value.multiplexTableEntryNumber;

      /* if element is not present */
      if (p_ASN_med_desc_lnk->value.bit_mask != elementList_present)
        {
          p_mux_table->pMuxTblEntryElem = NULL;
          rej_mux[mux_entry].AccRej = H245_ACC;
          (*p_acc_cnt)++;
        }
      /* if element list present */
      else
        {
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_lst = NULL;
          H245_MUX_ENTRY_ELEMENT_T *p_mux_el_tmp = NULL;

          /* start if off.. w/ ok */
          rej_mux[mux_entry].AccRej = H245_ACC;

          /* for each element in the element list..    */
          /* build the subelements.. if error .. free  */
          /* what youve done so far.. and break out    */
          for (ii=0;
               ii < p_ASN_med_desc_lnk->value.elementList.count;
               ii++)
            {
              /* if any of the elements fail.. flag the entry w/ reject reason  */
              /*        (this is done inside the build_element_list..)          */
              /*   and break out.. continue on with the next descriptor         */
              if (!(p_mux_el_tmp = build_element_list_from_mux (&(p_ASN_med_desc_lnk->value.elementList.value[ii]),&(rej_mux[mux_entry].AccRej))))
                {
                  /* free the list.. */
                  free_mux_el_list (p_mux_table->pMuxTblEntryElem);
                  break;
                }

              /* ***************************** */
              /* LINK IN THE MUX ENTRY ELEMENT */
              /* ***************************** */

              /* if first time through         */
              if (!p_mux_el_lst)
                p_mux_table->pMuxTblEntryElem = p_mux_el_tmp;
              /* otherwize .. just tag on the end */
              else
                p_mux_el_lst->pNext = p_mux_el_tmp;

              p_mux_el_lst = p_mux_el_tmp;

            } /* for each element in descriptor list */

        } /* if element list present */

      /* if you've accepted the mux table entry descriptor */
      if (rej_mux[mux_entry].AccRej == H245_ACC)
        {
          /* indicate an accept */
          (*p_acc_cnt)++;

          /* ******************************** */
          /* LINK IN THE MUX TABLE DESCRIPTOR */
          /* ******************************** */

          /* first table entry on the list.. (first time through) */
          if (!p_mux_table_list)
            p_mux_table_list = p_mux_table;
          else
            p_mux_table_lst->pNext = p_mux_table;

          p_mux_table_lst = p_mux_table;
        }
      else
        {
          /* indicate a reject */
          (*p_rej_cnt)++;

          /* otherwise.. free it and move on to something better */
          MemFree(p_mux_table);
        }

    } /* for each desriptor in the list */

  return p_mux_table_list;

} /* procedure */

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_table
 *
 * DESCRIPTION  allocates a new cap link and copies the capabiliites.
 *              links into the tiven capabilityTableLink, and if
 *              Parameters are NONSTANDARD does some gymnastics to copy
 *              data so it can be used..
 *
 *              NOTE: Copied data must be freed when capability is deleted.
 *                    see where the capability is deleted for exceptions
 *                    for "NONSTD" parameter sets .. (this is not pretty)
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_table ( struct InstanceStruct        *pInstance,
                                      struct TerminalCapabilitySet *pTermCapSet,
                                      CapabilityTableLink           pCapLink,
                                      MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T                 totcap;
  CapabilityTableLink           pNewLink;
  HRESULT                       lError;

  while (pCapLink)
  {
    if (build_totcap_from_captbl (&totcap,
                                  pCapLink,
                                  H245_REMOTE) == H245_ERROR_OK)
    {
      /* ok.. assume the CapId is set.. find it in the remote table  */
      /* if it exists, delete it so we can add new one in it's place */
      pNewLink = find_capid_by_entrynumber( pTermCapSet, totcap.CapId);
      if (pNewLink)
      {
        del_cap_link ( pTermCapSet, pNewLink );
      }

      /* ok.. if you've deleted the cap.. now see if there is a new one to take it's place */
      if (pCapLink->value.bit_mask & capability_present)
      {
        /* load and link into remote table entry */
        pNewLink = alloc_link_cap_entry (pTermCapSet);
        if (!pNewLink)
        {
          return H245_ERROR_NORESOURCE;
        }

        /* copy the cap over to the remote entry */
        pNewLink->value = pCapLink->value;

        // If it's nonstandard, the above didn't work, so fix it up...
        lError = H245_ERROR_OK;
        switch (pCapLink->value.capability.choice)
        {
        case Capability_nonStandard_chosen:
          lError = CopyNonStandardParameter(&pNewLink->value.capability.u.Capability_nonStandard,
                                             &pCapLink->value.capability.u.Capability_nonStandard);
          break;

        case receiveVideoCapability_chosen:
        case transmitVideoCapability_chosen:
        case rcvAndTrnsmtVdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard);
          }
          break;

        case receiveAudioCapability_chosen:
        case transmitAudioCapability_chosen:
        case rcvAndTrnsmtAdCpblty_chosen:
          if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                               &pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard);
          }
          break;

        case rcvDtApplctnCpblty_chosen:
        case trnsmtDtApplctnCpblty_chosen:
        case rATDACy_chosen :
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
          {
            lError = CopyNonStandardParameter(&pNewLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                               &pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd);
          }
          break;

        } // switch
        if (lError != H245_ERROR_OK)
          return lError;
      } /* if capability_present */
    } /* if build_totcap_from_captbl succeeded */

    pCapLink = pCapLink->next;
  } /* for all entries in link */

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__cap_desc
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static HRESULT
process_term_cap_set_ind__cap_desc (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    CapabilityDescriptor         *pReqCapDesc,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  unsigned int                  uCapDescNumber;
  CapabilityDescriptor         *pCapDesc;
  unsigned int                  uCapDesc;
  SmltnsCpbltsLink              pSimCap;
  SmltnsCpbltsLink              pReqSimCap;
  CapabilityDescriptor          TempCapDesc;
  unsigned int                  uSimCount;
  unsigned int                  uReqAltCount;
  unsigned int                  uReqAltCap;
  unsigned int                  uAltCap;
  HRESULT                        lError = H245_ERROR_OK;

  uCapDescNumber = pReqCapDesc->capabilityDescriptorNumber & 255;
  H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - Remote Capability Descriptor #%d", uCapDescNumber);

  // Find corresponding capability descriptor
  pCapDesc = NULL;
  for (uCapDesc = 0; uCapDesc < pTermCapSet->capabilityDescriptors.count; ++uCapDesc)
  {
    if (pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber == uCapDescNumber)
    {
      // Deallocate old simultaneous capabilities
      pCapDesc = &pTermCapSet->capabilityDescriptors.value[uCapDesc];
      if (pCapDesc->smltnsCpblts)
        dealloc_simultaneous_cap(pCapDesc);
      break;
    } // if
  } // for

  if (pCapDesc == NULL)
  {
    // Allocate a new terminal capability descriptor
    ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    pCapDesc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count++];
  }

  ASSERT(pCapDesc->smltnsCpblts == NULL);
  if (!(pReqCapDesc->bit_mask & smltnsCpblts_present))
  {
    // Delete the terminal capability descriptor
    pTermCapSet->capabilityDescriptors.count--;
    *pCapDesc = pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    return H245_ERROR_OK;
  }

  // Make a copy of the (volatile) new capability descriptor
  pCapDesc->bit_mask                   = 0;
  pCapDesc->capabilityDescriptorNumber = (CapabilityDescriptorNumber)uCapDescNumber;
  pCapDesc->smltnsCpblts               = NULL;

  // We copy the linked list to a temporary so that it
  // gets reversed twice and ends up in same order
  TempCapDesc.smltnsCpblts = NULL;
  uSimCount = 0;
  pReqSimCap = pReqCapDesc->smltnsCpblts;
  while (pReqSimCap)
  {
    // Allocate a new simultaneous capability list element
    pSimCap = MemAlloc(sizeof(*pSimCap));
    if (pSimCap == NULL)
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind: malloc failed");
      lError = H245_ERROR_NOMEM;
      break;
    }

    // Verify that each alternative capability in the request
    // simultaneous capability is valid
    // if so, copy it
    uAltCap = 0;
    uReqAltCount  = pReqSimCap->value.count;
    for (uReqAltCap = 0; uReqAltCap < uReqAltCount; ++uReqAltCap)
    {
      // Is the Capability in the remote Capability Table?
      if (find_capid_by_entrynumber (pTermCapSet, pReqSimCap->value.value[uReqAltCap]) == NULL)
      {
        // can't find the Capability
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - Remote Capability Table Entry #%d not found",
                  pReqSimCap->value.value[uReqAltCap]);
        lError = H245_ERROR_UNKNOWN;
      }
      else if (uAltCap >= H245_MAX_ALTCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst,1,
                  "API:process_term_cap_set_ind - Too many alternative capabilities (%d)",
                  uAltCap);
        lError = H245_ERROR_NORESOURCE;
        break;
      }
      else
      {
        // Copy the capability number
        pSimCap->value.value[uAltCap++] = pReqSimCap->value.value[uReqAltCap];
      }
    } /* for alternative capbilities */

    if (uAltCap)
    {
      // Verify that we have not exceeded arbitrary limit
      if (++uSimCount > H245_MAX_SIMCAPS)
      {
        // Exceeded arbitrary limit
        H245TRACE(pInstance->dwInst, 1,
                  "API:process_term_cap_set_ind - Too many simultaneous capabilities (%d)",
                  uSimCount);
        MemFree(pSimCap);
        lError = H245_ERROR_NORESOURCE;
      }
      else
      {
        // Add new simultaneous capability to the temporary list
        pSimCap->value.count = (unsigned short)uAltCap;
        pSimCap->next = TempCapDesc.smltnsCpblts;
        TempCapDesc.smltnsCpblts = pSimCap;
      }
    }
    else
    {
      H245TRACE(pInstance->dwInst, 1,
                "API:process_term_cap_set_ind - No valid alternative capabilities found");
      MemFree(pSimCap);
      lError = H245_ERROR_UNKNOWN;
    }

    pReqSimCap = pReqSimCap->next;
  } // while

  while (TempCapDesc.smltnsCpblts)
  {
    // Move elements from temporary to final linked list
    pSimCap = TempCapDesc.smltnsCpblts;
    TempCapDesc.smltnsCpblts = pSimCap->next;
    pSimCap->next = pCapDesc->smltnsCpblts;
    pCapDesc->smltnsCpblts = pSimCap;
  }

  // Error if no simultaneous capabilities found
  if (pCapDesc->smltnsCpblts)
  {
    pCapDesc->bit_mask |= smltnsCpblts_present;
  }
  else
  {
    H245TRACE(pInstance->dwInst, 1,
              "API:process_term_cap_set_ind - No simultaneous capabilities found");
    lError = H245_ERROR_UNKNOWN;
  }

  return lError;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind__mux_cap
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 * NOTES:
 *  We do a copy to set up a capability structure, then do another copy via
 *  H245CopyCap() to create a copy of the capability because the structure
 *  given to us by the ASN.1 decoded may contain pointers to data which will
 *  be deallocated upon return.
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind__mux_cap  (struct InstanceStruct        *pInstance,
                                    struct TerminalCapabilitySet *pTermCapSet,
                                    MultiplexCapability *        pReqMuxCap,
                                    MltmdSystmCntrlMssg          *p_pdu_rsp)
{
  H245_TOTCAP_T         TotCap;

  // Initialize temporary capability structure
  memset(&TotCap, 0, sizeof(TotCap));
  TotCap.Dir      = H245_CAPDIR_RMTRXTX;
  TotCap.DataType = H245_DATA_MUX;

  // Get rid of old remote multiplex capability, if any
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    del_mux_cap(pTermCapSet);
  }

  switch (pReqMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_NONSTD = pReqMuxCap->u.MltplxCpblty_nonStandard;
    TotCap.ClientType = H245_CLIENT_MUX_NONSTD;
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - Nonstandard Mux not yet supported");
    break;

  case h222Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H222 = pReqMuxCap->u.h222Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H223 = pReqMuxCap->u.h223Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_VGMUX = pReqMuxCap->u.v76Capability;
    TotCap.ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    // Save a copy of the multiplex capability
    TotCap.Cap.H245Mux_H2250 = pReqMuxCap->u.h2250Capability;
    TotCap.ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind__mux_cap - invalid mux cap type %d",
              &pReqMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  return set_mux_cap(pInstance, pTermCapSet, &TotCap);
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_term_cap_set_ind
 *
 * DESCRIPTION
 *
 **************************************************************
 *
 * (TBD) .. this module will ack all terminal capbilities
 *            need to build reject.. (maybe later??)
 *
 * THIS IS A BIG TBD
 *
 **************************************************************
 *
 * RETURN:
 *
 *****************************************************************************/
static HRESULT
process_term_cap_set_ind (struct InstanceStruct *pInstance,
                          MltmdSystmCntrlMssg   *p_pdu_req,
                          MltmdSystmCntrlMssg   *p_pdu_rsp)
{
  HRESULT                   lError = H245_ERROR_OK;
  TerminalCapabilitySet   *pTermCapSet;

  ASSERT (p_pdu_req->choice == MltmdSystmCntrlMssg_rqst_chosen);
  ASSERT (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind <-");

  /* build ack response */
  p_pdu_rsp->choice = MSCMg_rspns_chosen;
  p_pdu_rsp->u.MSCMg_rspns.choice = terminalCapabilitySetAck_chosen;
  p_pdu_rsp->u.MSCMg_rspns.u.terminalCapabilitySetAck.sequenceNumber =
    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.sequenceNumber;

  pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  //***************************
  // Deal with Capability Table
  //***************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityTable_present)
  {
	CapabilityTableLink pCapTable = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
	if (pCapTable->value.capability.choice == Capability_nonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == h221NonStandard_chosen &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 == 0xB5 &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 == 0x42 &&
        pCapTable->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode == 0x8080)
    {
	  pInstance->bMasterSlaveKludge = TRUE;
	  pCapTable = pCapTable->next;
    }
    lError = process_term_cap_set_ind__cap_table(pInstance,
                                                  pTermCapSet,
                                                  pCapTable,
                                                  p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap table error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  } /* if Capability Table Present */

  //**************************************
  // Deal with Capability Descriptor Table
  // i.e. simultaneous capabilities
  // NOTE: these are not held in the remote terminal capbility set
  //**************************************
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & capabilityDescriptors_present)
  {
    int des_cnt;
    int ii;

    des_cnt = p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityDescriptors.count;
    H245TRACE(pInstance->dwInst,20,"API:process_term_cap_set_ind - %d Simultaneous Capabilities",des_cnt);
    for (ii = 0; ii < des_cnt; ++ii)
    {
      lError = process_term_cap_set_ind__cap_desc (pInstance,
                                                    pTermCapSet,
                                                    &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                      terminalCapabilitySet.capabilityDescriptors.value[ii],
                                                    p_pdu_rsp);
      if (lError != H245_ERROR_OK)
      {
        H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - cap desc error %s",map_api_error(lError));
        /* (TBC) need to reject somehow */
      }
    } /* for each descriptor */
  } /* if capability descriptor present */

  /**************************************/
  /* Deal with Multiplex Capability set */
  /**************************************/
  /* NOTE: these are not held in the remote terminal capability set */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.bit_mask & multiplexCapability_present)
  {
    /* send up the indication to the client for each new entry */
    lError = process_term_cap_set_ind__mux_cap(pInstance,
                                                pTermCapSet,
                                                &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.
                                                  terminalCapabilitySet.multiplexCapability,
                                                p_pdu_rsp);
    if (lError != H245_ERROR_OK)
    {
      H245TRACE(pInstance->dwInst,1,"API:process_term_cap_set_ind - mux cap error %s",map_api_error(lError));
      /* (TBC) need to reject somehow */
    }
  }

  H245TRACE(pInstance->dwInst,10,"API:process_term_cap_set_ind -> OK");
  return H245_ERROR_OK;
}



/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_open_ind
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

static HRESULT
process_open_ind (struct InstanceStruct *pInstance,
                  MltmdSystmCntrlMssg   *p_pdu_req,
                  unsigned short        *p_FwdChan,     /* for return on error */
                  H245_ACC_REJ_T        *p_AccRej,      /* for return error */
                  H245_CONF_IND_T       *p_conf_ind)    /* out */
{
  static H245_TOTCAP_T          rx_totcap;      /* for receive caps */
  static H245_TOTCAP_T          tx_totcap;      /* for transmit caps */
  static H245_MUX_T             RxMux;
  static H245_MUX_T             TxMux;
  unsigned short                choice;         /* tmp for type of cap to routine */
  HRESULT                       lError;
  Tracker_T                     *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind <-");

  *p_AccRej = H245_ACC;

  /********************************/
  /* check for forward parameters */
  /********************************/

  /* get forward Rx channel id */
  p_conf_ind->u.Indication.u.IndOpen.RxChannel =
    *p_FwdChan =
      p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelNumber;

  H245TRACE(pInstance->dwInst,20,"API:process_open_ind - channel = %d",p_conf_ind->u.Indication.u.IndOpen.RxChannel);

  /* get port number */
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
        u.openLogicalChannel.forwardLogicalChannelParameters.bit_mask & fLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.RxPort =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.fLCPs_prtNmbr;
    }
  else
    p_conf_ind->u.Indication.u.IndOpen.RxPort = H245_INVALID_PORT_NUMBER;

  /* ok.. forward data type selection */
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.dataType.choice)
    {
    case DataType_nonStandard_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nonStandard");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
    case nullData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx nullData");
      /* (TBD) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    case DataType_videoData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx videoData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_VIDEO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_videoData.choice;
      break;
    case DataType_audioData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx audioData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_AUDIO;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_audioData.choice;
      break;
    case DataType_data_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx dataData");
      p_conf_ind->u.Indication.u.IndOpen.RxDataType = H245_DATA_DATA;
      choice =
        p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.dataType.
            u.DataType_data.application.choice;
      break;
    case encryptionData_chosen:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Rx encryptionData");
      /* (TBC) what do I do here ?? */
      *p_AccRej = H245_REJ_TYPE_UNKNOWN;
      return H245_ERROR_NOSUP;
      break;
    }

  /* load the tot cap's capability and client from capability                   */
  /* this will give us the client type and the Capability for the indication    */
  if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                          &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                            u.openLogicalChannel.forwardLogicalChannelParameters.dataType),
                          p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                          choice,
                          &rx_totcap)) != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
      return lError;
    }

  /* load it from the totcap you just built.. then toss it aside.. like an empty can of soda.. */
  p_conf_ind->u.Indication.u.IndOpen.RxClientType = rx_totcap.ClientType;
  p_conf_ind->u.Indication.u.IndOpen.pRxCap = &(rx_totcap.Cap);

  /* H.223/H.222 Mux table parameters for forward channel */
  p_conf_ind->u.Indication.u.IndOpen.pRxMux = &RxMux;
  switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.choice)
    {
    case fLCPs_mPs_h223LCPs_chosen:
      /* H.223 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H223;
      lError = load_H223_param(&RxMux.u.H223,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h223LCPs);
      if (lError != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_AL_COMB;
          return lError;
        }
      break;

    case fLCPs_mPs_h222LCPs_chosen:
      /* H.222 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H222;
      lError = load_H222_param(&RxMux.u.H222,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h222LCPs);
      break;

    case fLCPs_mPs_v76LCPs_chosen:
      /* VGMUX Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_VGMUX;
      lError =load_VGMUX_param(&RxMux.u.VGMUX,
                              &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_v76LCPs);
      break;

    case fLCPs_mPs_h2250LCPs_chosen:
      /* H.225.0 Logical Parameters */
      p_conf_ind->u.Indication.u.IndOpen.pRxMux->Kind = H245_H2250;
      lError = load_H2250_param(&RxMux.u.H2250,
                               &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.forwardLogicalChannelParameters.multiplexParameters.u.fLCPs_mPs_h2250LCPs);
      break;

    default:
      lError = H245_ERROR_NOSUP;
    } // switch
  if (lError != H245_ERROR_OK)
    {
      *p_AccRej = H245_REJ;
      return lError;
    }

  /********************************/
  /* check for reverse parameters */
  /********************************/
  if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)
    {
      switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice)
        {
        case DataType_nonStandard_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nonStandard");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;

        case nullData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx nullData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        case DataType_videoData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx videoData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_VIDEO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_videoData.choice;
          break;

        case DataType_audioData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx audioData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_AUDIO;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_audioData.choice;
          break;

        case DataType_data_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx dataData");
          p_conf_ind->u.Indication.u.IndOpen.TxDataType = H245_DATA_DATA;
          choice =
            p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.u.DataType_data.application.choice;
          break;

        case encryptionData_chosen:
          H245TRACE(pInstance->dwInst,20,"API:process_open_ind - Tx encryptionData");
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return H245_ERROR_NOSUP;
          break;

        default:
          /* (TBC) what do I do here ?? */
          *p_AccRej = H245_REJ_TYPE_UNKNOWN;
          H245TRACE(pInstance->dwInst,1,"API:process_open_ind - unknown choice %d",
                    p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OLCl_rLCPs.dataType.choice);
          return H245_ERROR_NOSUP;
        }

      /* load the tot cap's capability and client from capability */
      if ((lError = build_totcap_cap_n_client_from_capability ((struct Capability *)
                                      &(p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                        u.openLogicalChannel.OLCl_rLCPs.dataType),
                                      p_conf_ind->u.Indication.u.IndOpen.TxDataType,
                                      choice,
                                      &tx_totcap)) != H245_ERROR_OK)
        {
          *p_AccRej = H245_REJ_TYPE_NOTSUPPORT;
          return lError;
        }

      p_conf_ind->u.Indication.u.IndOpen.TxClientType = tx_totcap.ClientType;
      p_conf_ind->u.Indication.u.IndOpen.pTxCap = &(tx_totcap.Cap);

      /* if H223/H222 Mux table parameters for reverse channel availalbe */
      if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
          u.openLogicalChannel.OLCl_rLCPs.bit_mask & OLCl_rLCPs_mltplxPrmtrs_present)
        {
          switch (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                  u.openLogicalChannel.OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.choice)
            {
            case rLCPs_mPs_h223LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H223;
              lError = load_H223_param(&TxMux.u.H223,
                                      &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                        OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h223LCPs);
              if (lError != H245_ERROR_OK)
                {
                  *p_AccRej = H245_REJ_AL_COMB;
                  return H245_ERROR_NOSUP;
                }
              break;

            case rLCPs_mPs_v76LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_VGMUX;
              lError = load_VGMUX_param(&TxMux.u.VGMUX,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_v76LCPs);
              break;

            case rLCPs_mPs_h2250LCPs_chosen:
              p_conf_ind->u.Indication.u.IndOpen.pTxMux = &TxMux;
              p_conf_ind->u.Indication.u.IndOpen.pTxMux->Kind = H245_H2250;
              lError = load_H2250_param(&TxMux.u.H2250,
                                       &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.
                                         OLCl_rLCPs.OLCl_rLCPs_mltplxPrmtrs.u.rLCPs_mPs_h2250LCPs);
              break;

            default:
              lError = H245_ERROR_NOSUP;
            }
            if (lError != H245_ERROR_OK)
              {
                *p_AccRej = H245_REJ;
                return lError;
              }
        } /* if H223/H222 mux table reverse parameters */

    } /* if reverse parameters present */

    if (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.bit_mask & OpnLgclChnnl_sprtStck_present)
    {
      p_conf_ind->u.Indication.u.IndOpen.pSeparateStack =
        &p_pdu_req->u.MltmdSystmCntrlMssg_rqst.u.openLogicalChannel.OpnLgclChnnl_sprtStck;
    }


  /* conflict resolution .. just do it now.. */
  /* only on opens.. of same data type ..    */

#if 0
#ifndef LOOPBACK
  /* if master */
  if (pInstance->API.MasterSlave == APIMS_Master)
    {
      p_tracker = NULL;
      while (p_tracker = find_tracker_by_type (dwInst, API_OPEN_CHANNEL_T, p_tracker))
        {
          /* if allocated locally .. and incoming */
          /* data type == outstanding incoming    */
          /* there is a conflict                      */

          if ((p_tracker->u.Channel.ChannelAlloc == API_CH_ALLOC_LCL) &&
              (p_tracker->u.Channel.DataType == p_conf_ind->u.Indication.u.IndOpen.RxDataType))
            {
              *p_AccRej = H245_REJ;
              return H245_ERROR_INVALID_OP;

            } /* if conflict */

        } /* while */

    } /* if master */

#endif /* LOOPBACK */
#endif
  /* setup a tracker for this guy. */
  p_tracker = alloc_link_tracker (pInstance,
                                  API_OPEN_CHANNEL_T,
                                  0,
                                  API_ST_WAIT_LCLACK,
                                  API_CH_ALLOC_RMT,
                                  (p_pdu_req->u.MltmdSystmCntrlMssg_rqst.
                                   u.openLogicalChannel.bit_mask & OLCl_rLCPs_present)?API_CH_TYPE_BI:API_CH_TYPE_UNI,
                                  p_conf_ind->u.Indication.u.IndOpen.RxDataType,
                                  H245_INVALID_CHANNEL,
                                  p_conf_ind->u.Indication.u.IndOpen.RxChannel,
                                  0);

  if (!(p_tracker))
    {
      H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
      *p_AccRej = H245_REJ;
      return H245_ERROR_NOMEM;
    }

  H245TRACE(pInstance->dwInst,10,"API:process_open_ind -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   process_bi_open_rsp
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 * ASSUME:
 *              Callback must happen inside this routine since the
 *              datastructures passed back to the application are allocated
 *              in this moudle.
 *
 *              Application will <<<COPY>>> the needed data structures when
 *              callback occurs..
 *
 *****************************************************************************/

static HRESULT
process_bi_open_rsp (struct InstanceStruct *     pInstance,     /* in */
                     MltmdSystmCntrlMssg        *p_pdu_rsp,     /* in */
                     H245_MUX_T                 *p_RxMux,       /* in  */
                     DWORD                      *p_RxChannel,   /* out */
                     H245_CONF_IND_T            *p_conf_ind     /* out */
                     )
{
  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp <-");

  p_conf_ind->u.Confirm.Error = H245_ERROR_OK;

  // Get Reverse Logical Channel Number
  *p_RxChannel =
    p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxChannel =
      p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.reverseLogicalChannelNumber;

  // Get Reverse Port Number
  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & rLCPs_prtNmbr_present)
    {
      p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.RxPort =
        p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.rLCPs_prtNmbr;
    }

  if (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.bit_mask & OLCAk_rLCPs_mPs_present)
    {
      // Get Reverse Logical Channel ACK Parameters
      switch (p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice)
       {
       case rLCPs_mPs_h222LCPs_chosen:
         p_RxMux->Kind = H245_H222;
         p_conf_ind->u.Confirm.Error = load_H222_param(&p_RxMux->u.H222,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u.rLCPs_mPs_h222LCPs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       case mPs_h2250LgclChnnlPrmtrs_chosen:
         p_RxMux->Kind = H245_H2250ACK;
         p_conf_ind->u.Confirm.Error = load_H2250_param(&p_RxMux->u.H2250,
           &p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.u. mPs_h2250LgclChnnlPrmtrs);
         p_conf_ind->u.Confirm.u.ConfOpenNeedRsp.pRxMux = p_RxMux;
         break;

       default:
          H245TRACE(pInstance->dwInst,1,"API:process_bi_open_rsp - unknown choice %d",
                    p_pdu_rsp->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_rLCPs.OLCAk_rLCPs_mPs.choice);
          p_conf_ind->u.Confirm.Error = H245_ERROR_NOSUP;
       } // switch
    }

  H245TRACE(pInstance->dwInst,10,"API:process_bi_open_rsp -> OK");
  return H245_ERROR_OK;
}

WORD awObject[64];

unsigned int ArrayFromObject(WORD *pwObject, unsigned uSize, POBJECTID pObject)
{
  register unsigned int uLength = 0;
  while (pObject)
  {
    if (uLength >= uSize)
    {
           H245TRACE(0,1,"API:ArrayFromObject Object ID too long");
      return uLength;
    }
    pwObject[uLength++] = (WORD) pObject->value;
    pObject = pObject->next;
  }
  return uLength;
} // ArrayFromObject()

/*****************************************************************************
 *
 * TYPE:        Callback
 *
 * PROCEDURE:
 *
 * DESCRIPTION
 *
 *
 * RETURN:
 *
 *****************************************************************************/

static Tracker_T *
TrackerValidate(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:ValidateTracker -> Tracker Not Found");
    return NULL;
  }

  return pTracker;
}

static DWORD_PTR
TranslateTransId(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateTransId -> Tracker Not Found");
    return 0;
  }

  return pTracker->TransId;
}

static void
TrackerFree(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerFree -> Tracker Not Found");
    return;
  }
  unlink_dealloc_tracker (pInstance, pTracker);
}

static DWORD_PTR
TranslateAndFree(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TranslateAndFree -> Tracker Not Found");
    return 0;
  }
  dwTransId = pTracker->TransId;
  unlink_dealloc_tracker (pInstance, pTracker);
  return dwTransId;
}

static void
TrackerNewState(struct InstanceStruct *pInstance, DWORD_PTR dwTransId, int nNewState)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> NULL Tracker");
    return;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:TrackerNewState -> Tracker Not Found");
    return;
  }
  pTracker->State = nNewState;
}

static WORD
GetRxChannel(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetRxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.RxChannel;
}

static WORD
GetTxChannel(struct InstanceStruct *pInstance, DWORD_PTR dwTransId)
{
  register Tracker_T   *pTracker = (Tracker_T *)dwTransId;
  if (pTracker == NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> NULL Tracker");
    return 0;
  }
  if (find_tracker_by_pointer (pInstance, pTracker) != pTracker)
  {
    H245TRACE(pInstance->dwInst,1,"API:GetTxChannel -> Tracker Not Found");
    return 0;
  }

  return (WORD)pTracker->u.Channel.TxChannel;
}

HRESULT
H245FunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_T *pPdu)
{
    HRESULT hr = H245_ERROR_OK;
    MltmdSystmCntrlMssg *pMmPdu = NULL;

    pMmPdu = (MltmdSystmCntrlMssg *) MemAlloc(sizeof(MltmdSystmCntrlMssg));
    if(NULL == pMmPdu)
    {
        return H245_ERROR_NOMEM;
    }
    memset(pMmPdu, 0, sizeof(MltmdSystmCntrlMssg));

    pMmPdu->choice = indication_chosen;
    pMmPdu->u.indication.choice = functionNotUnderstood_chosen;
    pMmPdu->u.indication.u.functionNotUnderstood.choice = pPdu->choice;
    switch (pPdu->choice)
    {
    case FnctnNtUndrstd_request_chosen:
        pMmPdu->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
        pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case FnctnNtUndrstd_response_chosen:
        pMmPdu->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
        pPdu->u.MSCMg_rspns;
        break;

    case FnctnNtUndrstd_command_chosen:
        pMmPdu->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
        pPdu->u.MSCMg_cmmnd;
    default:
        MemFree(pMmPdu);
        return H245_ERROR_OK;
    }

    hr = sendPDU(pInstance, pMmPdu);
    MemFree(pMmPdu);
    return hr;
} // H245FunctionNotUnderstood()

HRESULT
H245FsmConfirm    (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD_PTR                dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  H245_MUX_T                    TxMux;
  H245_MUX_T                    RxMux;
  HRESULT                       lResult = H245_ERROR_OK;

  ASSERT(pInstance != NULL);
  ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmConfirm <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_CONF;
  ConfInd.u.Confirm.Confirm = dwEvent;
  ConfInd.u.Confirm.dwPreserved = pInstance->API.dwPreserved;
  ConfInd.u.Confirm.dwTransId = dwTransId;
  ConfInd.u.Confirm.Error = lError;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_CONF_INIT_MSTSLV:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);
        pInstance->API.SystemState     = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
          {
            pInstance->API.MasterSlave = APIMS_Master;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_MASTER;
          }
        else
          {
            pInstance->API.MasterSlave = APIMS_Slave;
            ConfInd.u.Confirm.u.ConfMstSlv = H245_SLAVE;
          }
        break;

      case REJECT:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Reject");
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
//      case MS_FAILED:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Master Slave Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfMstSlv = H245_INDETERMINATE;
        break;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange confirm */
    /*                                      */
    /****************************************/
  case  H245_CONF_SEND_TERMCAP:
    ConfInd.u.Confirm.dwTransId = TranslateAndFree(pInstance, dwTransId);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == terminalCapabilitySetAck_chosen);
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_ACC;
        clean_cap_table(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfSndTcap.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Term Cap Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        break;
      }
    break;

    /***************************************/
    /*                                     */
    /* unidirectional logical channel open */
    /*                                     */
    /***************************************/
  case  H245_CONF_OPEN:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.TxChannel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfOpen.RxPort = H245_INVALID_PORT_NUMBER;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
        ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) == 0);

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
        {
          ConfInd.u.Confirm.u.ConfOpen.pSeparateStack =
            &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
        }

        if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
        {
          switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
            {
            case h2250LgclChnnlAckPrmtrs_chosen:
              TxMux.Kind = H245_H2250ACK;
              load_H2250ACK_param(&TxMux.u.H2250ACK,
                                  &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
              ConfInd.u.Confirm.u.ConfOpen.pTxMux = &TxMux;
              break;

            } // switch
        }

        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_ACC;
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        break;

      case REJECT:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelReject_chosen);

        ConfInd.u.Confirm.Error             = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfOpen.AccRej =
          pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
        TrackerFree(pInstance,dwTransId);
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
        ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
        TrackerFree(pInstance,dwTransId);
      }
    break;

    /***********************************************/
    /*                                             */
    /* bidirectional logical channel open (TBD)??? */
    /*                                             */
    /***********************************************/
  case  H245_CONF_NEEDRSP_OPEN:
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
      ConfInd.u.Confirm.u.ConfOpenNeedRsp.RxPort = H245_INVALID_PORT_NUMBER;

      /* determine errors */
      switch (lError)
        {
        case H245_ERROR_OK:
          ASSERT(pPdu != NULL);
          ASSERT(pPdu->choice == MSCMg_rspns_chosen);
          ASSERT(pPdu->u.MSCMg_rspns.choice == openLogicalChannelAck_chosen);
          ASSERT((pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_rLCPs_present) != 0);

          ConfInd.u.Confirm.u.ConfOpenNeedRsp.AccRej = H245_ACC;

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & OLCAk_sprtStck_present)
          {
            ConfInd.u.Confirm.u.ConfOpenNeedRsp.pSeparateStack =
              &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.OLCAk_sprtStck;
          }

          if (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.bit_mask & frwrdMltplxAckPrmtrs_present)
          {
            switch (pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.choice)
              {
              case h2250LgclChnnlAckPrmtrs_chosen:
                TxMux.Kind = H245_H2250ACK;
                load_H2250ACK_param(&TxMux.u.H2250ACK,
                                    &pPdu->u.MSCMg_rspns.u.openLogicalChannelAck.frwrdMltplxAckPrmtrs.u.h2250LgclChnnlAckPrmtrs);
                ConfInd.u.Confirm.u.ConfOpenNeedRsp.pTxMux = &TxMux;
                break;

              } // switch
          }

          /* NOTE Receive Channel is assigned  in this call */
          process_bi_open_rsp (pInstance,
                          pPdu,
                          &RxMux,
                          &(pTracker->u.Channel.RxChannel),
                          &ConfInd);

          /* NOTE: this is a special case since we have to assign   */
          /* the receive channel to the tracker.. otherwise we      */
          /* will not be able to find it later..                    */
          /* Here we have to update both the state, and the channel */
          pTracker->State = API_ST_WAIT_CONF;
          break;

        case REJECT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_OK;
          ConfInd.u.Confirm.u.ConfOpen.AccRej =
            pPdu->u.MSCMg_rspns.u.openLogicalChannelReject.cause.choice;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

        case TIMER_EXPIRY:
        case ERROR_D_TIMEOUT:
        case ERROR_F_TIMEOUT:
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_TIMEOUT;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
          break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
        default:
          H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Open Channel Error %d", lError);
          ConfInd.u.Confirm.Confirm = H245_CONF_OPEN;
          ConfInd.u.Confirm.u.ConfOpen.TxChannel = (WORD)pTracker->u.Channel.TxChannel;
          ConfInd.u.Confirm.Error             = H245_ERROR_UNKNOWN;
          ConfInd.u.Confirm.u.ConfOpen.AccRej = H245_REJ;
          unlink_dealloc_tracker (pInstance, pTracker);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirection logical channel close            */
    /*                                              */
    /************************************************/
  case  H245_CONF_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.Channel = GetTxChannel(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == closeLogicalChannelAck_chosen);
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_ACC;
        TrackerFree(pInstance,dwTransId);
        break;

      case REJECT:
        /* should never be rejected */
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Rejected");
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Close Channel Error %d", lError);
        TrackerNewState(pInstance,dwTransId,API_ST_IDLE);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfClose.AccRej = H245_REJ;
      }
    break;

    /***************************/
    /*                         */
    /* request channel close   */
    /*                         */
    /***************************/
  case  H245_CONF_REQ_CLOSE:
    ConfInd.u.Confirm.dwTransId = TranslateTransId(pInstance, dwTransId);
    ConfInd.u.Confirm.u.ConfReqClose.Channel = GetRxChannel(pInstance, dwTransId);
    TrackerNewState(pInstance,dwTransId,API_ST_IDLE);

    /* determine errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == requestChannelCloseAck_chosen);
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_ACC;
        break;

      case REJECT:
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Request Channel Close Error %d", lError);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
        ConfInd.u.Confirm.u.ConfReqClose.AccRej = H245_REJ;
      }
    break;

    /*******************/
    /*                 */
    /* mux table entry */
    /*                 */
    /*******************/
  case  H245_CONF_MUXTBL_SND:
    {
      UINT ii;
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      ConfInd.u.Confirm.dwTransId = pTracker->TransId;

      switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendAck_chosen);
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.count;
             ii ++)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck.multiplexTableEntryNumber.value[ii];
          ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_ACC;

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendAck) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case REJECT:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == multiplexEntrySendReject_chosen);
        ConfInd.u.Confirm.Error = H245_ERROR_OK;
        for (ii = 0;
             ii < pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.count;
             ++ii)
        {
          pTracker->u.MuxEntryCount--;
          ConfInd.u.Confirm.u.ConfMuxSnd.MuxEntryId =
            pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].multiplexTableEntryNumber;

          switch (pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject.rejectionDescriptions.value[ii].cause.choice)
          {
          default:
            H245PANIC();
          case MERDs_cs_unspcfdCs_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ; /* unspecified */
            break;
          case descriptorTooComplex_chosen:
            ConfInd.u.Confirm.u.ConfMuxSnd.AccRej = H245_REJ_MUX_COMPLICATED;
            break;
          }

          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u.multiplexEntrySendReject) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          pTracker = TrackerValidate(pInstance, dwTransId);
          if (pTracker == NULL)
            return H245_ERROR_OK;
        }
        if (pTracker->u.MuxEntryCount == 0)
        {
          unlink_dealloc_tracker (pInstance, pTracker);
        }
        pPdu = NULL;                    // Don't do callback again!
        break;

      case TIMER_EXPIRY:
      case ERROR_D_TIMEOUT:
      case ERROR_F_TIMEOUT:
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_TIMEOUT;
        break;

//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245TRACE(pInstance->dwInst,1,"H245FsmConfirm - Mux Table Send Error %d", lError);
        unlink_dealloc_tracker (pInstance, pTracker);
        ConfInd.u.Confirm.Error = H245_ERROR_UNKNOWN;
      } // switch
    }
    break;

  case  H245_CONF_RMESE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestMultiplexEntryAck_chosen);
    ConfInd.u.Confirm.u.ConfRmese.dwCount =
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_CONF_RMESE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == rqstMltplxEntryRjct_chosen);
    ConfInd.u.Confirm.u.ConfRmeseReject.dwCount =
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Confirm.u.ConfRmeseReject.dwCount; ++dwIndex)
    {
      ConfInd.u.Confirm.u.ConfRmeseReject.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber;
    }
    break;

  case  H245_CONF_RMESE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MRSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeAck_chosen);
    ConfInd.u.Confirm.u.ConfMrse =
      pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice;
    break;

  case  H245_CONF_MRSE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == requestModeReject_chosen);
    ConfInd.u.Confirm.u.ConfMrseReject =
      pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice;
    break;

  case  H245_CONF_MRSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_MLSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopAck_chosen);
    ConfInd.u.Confirm.u.ConfMlse.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlse.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Ack type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_REJECT:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == maintenanceLoopReject_chosen);
    ConfInd.u.Confirm.u.ConfMlseReject.LoopType =
      pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice;
    switch (pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice)
    {
    case systemLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel = 0;
      break;

    case mediaLoop_chosen:
    case logicalChannelLoop_chosen:
      ConfInd.u.Confirm.u.ConfMlseReject.Channel =
        pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmConfirm: Invalid Maintenance Loop Reject type %d",
                pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_CONF_MLSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  case  H245_CONF_RTDSE:
    ASSERT(pPdu != NULL);
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == roundTripDelayResponse_chosen);
    break;

  case  H245_CONF_RTDSE_EXPIRED:
    ASSERT(pPdu == NULL);
    break;

  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmConfirm -> Invalid Confirm Event %d",
              dwEvent);
    return H245_ERROR_SUBSYS;
  } // switch

  if (lResult == H245_ERROR_OK)
  {
    if (pPdu)
    {
      if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MSCMg_rspns.u) == H245_ERROR_NOSUP)
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
    }
    else
    {
      (*pInstance->API.ConfIndCallBack)(&ConfInd, NULL);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmConfirm -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmConfirm -> %s", map_api_error(lResult));
  }
  return lResult;
} // H245FsmConfirm()



HRESULT
H245FsmIndication (PDU_t *                  pPdu,
                   DWORD                    dwEvent,
                   struct InstanceStruct *  pInstance,
                   DWORD_PTR                dwTransId,
                   HRESULT                  lError)
{
  H245_CONF_IND_T               ConfInd;
  DWORD                         dwIndex;
  MltmdSystmCntrlMssg          *pRsp;
  HRESULT                       lResult = H245_ERROR_OK;
#if 1
  int                           nLength;
  WCHAR *                       pwchar = NULL;
#endif

  ASSERT(dwEvent == H245_IND_OPEN_CONF || pPdu != NULL);
  ASSERT(pInstance != NULL);
  ASSERT(pInstance->API.ConfIndCallBack != NULL);
  H245TRACE(pInstance->dwInst,4,"H245FsmIndication <- Event=%s (%d)",
            map_fsm_event(dwEvent),dwEvent);

  memset (&ConfInd, 0, sizeof(ConfInd));
  ConfInd.Kind = H245_IND;
  ConfInd.u.Indication.Indicator = dwEvent;
  ConfInd.u.Indication.dwPreserved = pInstance->API.dwPreserved;

  switch (dwEvent)
  {
    /******************************/
    /*                            */
    /* master slave determination */
    /*                            */
    /******************************/
  case  H245_IND_MSTSLV:

    /* handle errors */
    switch (lError)
      {
      case H245_ERROR_OK:
        ASSERT(pPdu != NULL);
        ASSERT(pPdu->choice == MSCMg_rspns_chosen);
        ASSERT(pPdu->u.MSCMg_rspns.choice == mstrSlvDtrmntnAck_chosen);

        pInstance->API.SystemState = APIST_Connected;
        if (pPdu->u.MSCMg_rspns.u.mstrSlvDtrmntnAck.decision.choice == master_chosen)
        {
          pInstance->API.MasterSlave = APIMS_Master;
          ConfInd.u.Indication.u.IndMstSlv = H245_MASTER;
        }
        else
        {
          pInstance->API.MasterSlave = APIMS_Slave;
          ConfInd.u.Indication.u.IndMstSlv = H245_SLAVE;
        }
        break;

      case MS_FAILED:
      case REJECT:
      case TIMER_EXPIRY:
        ConfInd.u.Indication.u.IndMstSlv = H245_INDETERMINATE;
        break;

//      case ERROR_D_TIMEOUT:
//      case ERROR_F_TIMEOUT:
//      case FUNCT_NOT_SUP:
//      case ERROR_A_INAPPROPRIATE:
//      case ERROR_B_INAPPROPRIATE:
//      case ERROR_C_INAPPROPRIATE:
      default:
        H245PANIC();
        /* (TBC) */
        return H245_ERROR_OK;
      }
    break;

    /****************************************/
    /*                                      */
    /* Terminal Capability exchange         */
    /*                                      */
    /****************************************/
    /* decode_termcapset breaks the termcap set up and sends up     */
    /* a single indication to the client */
  case  H245_IND_CAP:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == terminalCapabilitySet_chosen);
    pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
    if (pRsp == NULL)
    {
      H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
      return H245_ERROR_NOMEM;
    }
    memset(pRsp, 0, sizeof(*pRsp));
    process_term_cap_set_ind (pInstance, pPdu, pRsp);
    FsmOutgoing(pInstance, pRsp, 0);
    MemFree (pRsp);
    break;

  case  H245_IND_CESE_RELEASE:
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel open          */
    /*                                              */
    /* bidirectional  logical channel open          */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == openLogicalChannel_chosen);
    {
      unsigned short  forward_channel;
      H245_ACC_REJ_T  acc_rej;

      /* if error, process_open_ind will tell us what to send for reject */
      if (process_open_ind(pInstance,pPdu,&forward_channel,&acc_rej,&ConfInd) != H245_ERROR_OK)
      {
        // Reject the open
        pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
        if (pRsp == NULL)
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication TermCap: no memory for response");
          return H245_ERROR_NOMEM;
        }
        memset(pRsp, 0, sizeof(*pRsp));
        pdu_rsp_open_logical_channel_rej(pRsp, forward_channel, (WORD)acc_rej);
        FsmOutgoing(pInstance, pRsp, 0);
        MemFree (pRsp);
      }
    }
    break;

    /************************************************/
    /*                                              */
    /* Confirm bi-directional open                  */
    /*                                              */
    /************************************************/
  case  H245_IND_OPEN_CONF:
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      ASSERT(pPdu != NULL);
      ASSERT(pPdu->choice == indication_chosen);
      ASSERT(pPdu->u.indication.choice == opnLgclChnnlCnfrm_chosen);
    }
#endif
    {
      Tracker_T *pTracker;

      pTracker = TrackerValidate(pInstance, dwTransId);
      if (pTracker == NULL)
        return H245_ERROR_OK;

      /* confirm processing */
      ASSERT(pTracker->State == API_ST_WAIT_CONF);
      ASSERT(pTracker->TrackerType == API_OPEN_CHANNEL_T);
      ASSERT(pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);
      ASSERT(pTracker->u.Channel.ChannelType == API_CH_TYPE_BI);

      ConfInd.u.Indication.u.IndOpenConf.RxChannel = (WORD)pTracker->u.Channel.RxChannel;
      ConfInd.u.Indication.u.IndOpenConf.TxChannel = (WORD)pTracker->u.Channel.TxChannel;

      pTracker->State = API_ST_IDLE;
    }
    break;

    /************************************************/
    /*                                              */
    /* unidirectional logical channel close         */
    /*                                              */
    /* bidirectional  logical channel close         */
    /*                                              */
    /************************************************/
  case  H245_IND_CLOSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == closeLogicalChannel_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndClose.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.forwardLogicalChannelNumber;
      ConfInd.u.Indication.u.IndClose.Reason =
        (pPdu->u.MltmdSystmCntrlMssg_rqst.u.closeLogicalChannel.source.choice==user_chosen)?H245_USER:H245_LCSE;

      /* find the tracker */
      pTracker = find_tracker_by_rxchannel (pInstance,
                                           ConfInd.u.Indication.u.IndClose.Channel,
                                           API_CH_ALLOC_RMT);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> close indication - Tracker not found");
          return H245_ERROR_OK;
        }

      unlink_dealloc_tracker (pInstance, pTracker);
    }
    break;

    /************************************************/
    /*                                              */
    /* request channel close                        */
    /*                                              */
    /************************************************/
  case  H245_IND_REQ_CLOSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestChannelClose_chosen);
    {
      Tracker_T *pTracker;

      ConfInd.u.Indication.u.IndReqClose =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestChannelClose.forwardLogicalChannelNumber;

      /* find the tracker */
      pTracker = find_tracker_by_txchannel (pInstance,
                                           ConfInd.u.Indication.u.IndReqClose,
                                           API_CH_ALLOC_LCL);
      if (!pTracker)
        {
          H245TRACE(pInstance->dwInst,4,"H245FsmIndication Request Channel Close: Tracker not found");

          pRsp = (PDU_t *)MemAlloc(sizeof(*pPdu));
          if (pRsp == NULL)
          {
            H245TRACE(pInstance->dwInst,1,"H245FsmIndication Request Channel Close: no memory for response");
            return H245_ERROR_NOMEM;
          }
          memset(pRsp, 0, sizeof(*pRsp));

          /* can't find it.. must be closed.. respond anyway */
          pdu_rsp_request_channel_close_rej(pRsp, (WORD)ConfInd.u.Indication.u.IndReqClose,H245_REJ);
          FsmOutgoing(pInstance, pRsp, 0);
          MemFree(pRsp);
          /* Possible Error.. could have been removed from list or    */
          /* could have been allocated remotely... and this is a protocol */
          /* error                                                    */
          return H245_ERROR_OK;
        }

      ASSERT(pTracker->State == API_ST_IDLE);
      pTracker->State = API_ST_WAIT_LCLACK;
      pTracker->TrackerType = API_CLOSE_CHANNEL_T;
    }
    break;

    /************************************************/
    /*                                              */
    /* Release Close Request                        */
    /*                                              */
    /************************************************/
  case  H245_IND_CLCSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == rqstChnnlClsRls_chosen);
    {
      Tracker_T *pTracker;

      /* find tracker.. and set to LCLACK_CANCEL */
      /* this will tell api to notify user       */

      pTracker = find_tracker_by_txchannel (pInstance,
                                           pPdu->u.indication.u.rqstChnnlClsRls.forwardLogicalChannelNumber,
                                           API_CH_ALLOC_LCL);
      if (pTracker)
        {
          if (pTracker->State != API_ST_WAIT_LCLACK)
            {
              return H245_ERROR_INVALID_INST;
            }

          pTracker->State = API_ST_WAIT_LCLACK_CANCEL;
        }
      else
        {
          H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> IND_REL_CLSE: Cancel.. NO TRACKER FOUND");
        }
    }
    break;

    /************************************************/
    /*                                              */
    /* mux table entry                              */
    /*                                              */
    /************************************************/
  case  H245_IND_MUX_TBL:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == multiplexEntrySend_chosen);
    {
      unsigned short          seq_num;
      H245_ACC_REJ_MUX_T      rej_mux;
      H245_MUX_TABLE_T       *p_mux_tbl;
      DWORD                   rej_cnt;
      DWORD                   acc_cnt;
      Tracker_T              *pTracker;

      /* process the mux table entry */
      p_mux_tbl = process_mux_table_ind(pPdu,&seq_num,rej_mux,&rej_cnt,&acc_cnt);

      if (rej_cnt)
        {
          /* build the reject pdu from the rej_mux table */
          if (!(pRsp = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
            return H245_ERROR_NOMEM;
          memset(pRsp, 0, sizeof(MltmdSystmCntrlMssg));

          pdu_rsp_mux_table_rej (pRsp,seq_num,rej_mux,(rej_cnt+acc_cnt));
          FsmOutgoing(pInstance, pRsp, 0);
          MemFree(pRsp);
        }

      /* if there are any left to send up. */
      if (p_mux_tbl)
        {
          if (!(pTracker = alloc_link_tracker (pInstance,
                                                API_RECV_MUX_T,
                                                /* use the TransId.. for the sequence number */
                                                seq_num,
                                                API_ST_WAIT_LCLACK,
                                                API_CH_ALLOC_UNDEF,
                                                API_CH_TYPE_UNDEF,
                                                0,
                                                H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                                0)))
            {
              free_mux_table_list (p_mux_tbl);
              H245TRACE(pInstance->dwInst,1,"API:process_open_ind -> %s",map_api_error(H245_ERROR_NOMEM));
              /* (TBC) this should be a fatal error */
              H245PANIC();
              break;
            }

          pTracker->u.MuxEntryCount = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.Count   = acc_cnt;
          ConfInd.u.Indication.u.IndMuxTbl.pMuxTbl = p_mux_tbl;
          if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
          {
            H245FunctionNotUnderstood(pInstance, pPdu);
          }
          free_mux_table_list (p_mux_tbl);
          return H245_ERROR_OK;
        }
    }
    break;

  case  H245_IND_MTSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == mltplxEntrySndRls_chosen);
    break;

  case  H245_IND_RMESE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMultiplexEntry_chosen);
    ConfInd.u.Indication.u.IndRmese.dwCount =
       pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count;
    for (dwIndex = 0; dwIndex < ConfInd.u.Indication.u.IndRmese.dwCount; ++dwIndex)
    {
      ConfInd.u.Indication.u.IndRmese.awMultiplexTableEntryNumbers[dwIndex] =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex];
    }
    break;

  case  H245_IND_RMESE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == rqstMltplxEntryRls_chosen);
    break;

  case  H245_IND_MRSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == requestMode_chosen);
    ConfInd.u.Indication.u.IndMrse.pRequestedModes =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes;
    break;

  case  H245_IND_MRSE_RELEASE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == requestModeRelease_chosen);
    break;

  case  H245_IND_MLSE:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == maintenanceLoopRequest_chosen);
    ConfInd.u.Indication.u.IndMlse.LoopType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice;
    if (ConfInd.u.Indication.u.IndMlse.LoopType == systemLoop_chosen)
      ConfInd.u.Indication.u.IndMlse.Channel = 0;
    else
      ConfInd.u.Indication.u.IndMlse.Channel =
        pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop;
    break;

  case  H245_IND_MLSE_RELEASE:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == mntnncLpOffCmmnd_chosen);
    break;

  case  H245_IND_NONSTANDARD_REQUEST:
  case  H245_IND_NONSTANDARD_RESPONSE:
  case  H245_IND_NONSTANDARD_COMMAND:
  case  H245_IND_NONSTANDARD:
    ConfInd.u.Indication.u.IndNonstandard.pData        = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value;
    ConfInd.u.Indication.u.IndNonstandard.dwDataLength = pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length;
    switch (pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice)
    {
    case object_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = awObject;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  =
        ArrayFromObject(&awObject[0], sizeof(awObject)/sizeof(awObject[0]),
          pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object);
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = 0;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = 0;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode = 0;
      break;

    case h221NonStandard_chosen:
      ConfInd.u.Indication.u.IndNonstandard.pwObjectId        = NULL;
      ConfInd.u.Indication.u.IndNonstandard.dwObjectIdLength  = 0;
      ConfInd.u.Indication.u.IndNonstandard.byCountryCode     = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode;
      ConfInd.u.Indication.u.IndNonstandard.byExtension       = (BYTE)
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension;
      ConfInd.u.Indication.u.IndNonstandard.wManufacturerCode =
        pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode;
      break;

    default:
      H245TRACE(pInstance->dwInst,1,
                "H245FsmIndication: unrecognized nonstandard identifier type %d",
                pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_MISC_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice  == miscellaneousCommand_chosen);
    break;

  case  H245_IND_MISC:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == miscellaneousIndication_chosen);
    break;

  case  H245_IND_COMM_MODE_REQUEST:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == communicationModeRequest_chosen);
    break;

  case  H245_IND_COMM_MODE_RESPONSE:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == cmmnctnMdRspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice == communicationModeTable_chosen);
    {
      unsigned int                uCount;
      CommunicationModeTableLink  pLink;
      H245_COMM_MODE_ENTRY_T *    pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = MemAlloc(uCount * sizeof(*pTable));
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommRsp.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommRsp.byTableCount = (BYTE)uCount;
        pLink = pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            MemFree(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        MemFree(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_COMM_MODE_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == communicationModeCommand_chosen);
    {
      unsigned int                  uCount;
      CommunicationModeCommandLink  pLink;
      H245_COMM_MODE_ENTRY_T *      pTable;

      uCount = 0;
      pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
      while (pLink)
      {
        ++uCount;
        pLink = pLink->next;
      }

      pTable = MemAlloc(uCount * sizeof(*pTable));
      if (pTable)
      {
        ConfInd.u.Indication.u.IndCommCmd.pTable       = pTable;
        ConfInd.u.Indication.u.IndCommCmd.byTableCount = (BYTE)uCount;
        pLink = pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable;
        while (pLink)
        {
          lResult = LoadCommModeEntry(pTable, &pLink->value);
          if (lResult != H245_ERROR_OK)
          {
            MemFree(pTable);
            return lResult;
          }
          ++pTable;
          pLink = pLink->next;
        }
      {
        H245FunctionNotUnderstood(pInstance, pPdu);
      }
        if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
        {
          H245FunctionNotUnderstood(pInstance, pPdu);
        }
        MemFree(pTable);
        H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
        return H245_ERROR_OK;
      }

      lResult = H245_ERROR_NOMEM;
    }
    break;

  case  H245_IND_CONFERENCE_REQUEST:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == conferenceRequest_chosen);
    ConfInd.u.Indication.u.IndConferReq.RequestType =
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice;
    ConfInd.u.Indication.u.IndConferReq.byMcuNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber;
    ConfInd.u.Indication.u.IndConferReq.byTerminalNumber = (BYTE)
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber;
    break;

  case  H245_IND_CONFERENCE_RESPONSE:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == conferenceResponse_chosen);
    ConfInd.u.Indication.u.IndConferRsp.ResponseType =
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice;
    switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.choice)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.byMcuNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber;
      ConfInd.u.Indication.u.IndConferRsp.byTerminalNumber = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber;
      ConfInd.u.Indication.u.IndConferRsp.pOctetString =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value;
      ConfInd.u.Indication.u.IndConferRsp.byOctetStringLength = (BYTE)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length;
      break;

    case terminalListResponse_chosen:
      ConfInd.u.Indication.u.IndConferRsp.pTerminalList =
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value;
      ConfInd.u.Indication.u.IndConferRsp.wTerminalListCount = (WORD)
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count;
      break;

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      break;

    case makeMeChairResponse_chosen:
      switch (pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice)
      {
      case grantedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_GRANTED_CHAIR_TOKEN;
        break;

      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid make me chair response %d",
                  pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice);

      // Fall-through to next case

      case deniedChairToken_chosen:
        ConfInd.u.Indication.u.IndConferRsp.ResponseType = H245_RSP_DENIED_CHAIR_TOKEN;
      } // switch
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Conference Response type %d",
                pPdu->u.MSCMg_rspns.u.conferenceResponse.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_CONFERENCE_COMMAND:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == conferenceCommand_chosen);
    ConfInd.u.Indication.u.IndConferCmd.CommandType =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice;
    ConfInd.u.Indication.u.IndConferCmd.Channel =
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl;
    ConfInd.u.Indication.u.IndConferCmd.byMcuNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.mcuNumber;
    ConfInd.u.Indication.u.IndConferCmd.byTerminalNumber = (BYTE)
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.sendThisSource.terminalNumber;
    break;

  case  H245_IND_CONFERENCE:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == conferenceIndication_chosen);
    ConfInd.u.Indication.u.IndConfer.IndicationType =
      pPdu->u.indication.u.conferenceIndication.choice;
    ConfInd.u.Indication.u.IndConfer.bySbeNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber;
    ConfInd.u.Indication.u.IndConfer.byMcuNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber;
    ConfInd.u.Indication.u.IndConfer.byTerminalNumber = (BYTE)
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber;
    break;

  case  H245_IND_SEND_TERMCAP:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == sndTrmnlCpbltySt_chosen);
    break;

  case  H245_IND_ENCRYPTION:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == encryptionCommand_chosen);
    break;

  case  H245_IND_FLOW_CONTROL:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice == flowControlCommand_chosen);
    ConfInd.u.Indication.u.IndFlowControl.Scope =
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice;
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      ConfInd.u.Indication.u.IndFlowControl.Channel =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr;
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      ConfInd.u.Indication.u.IndFlowControl.wResourceID =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID;
      break;

    case FCCd_scp_whlMltplx_chosen:
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    switch (pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice)
    {
    case maximumBitRate_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction =
        pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate;
      break;

    case noRestriction_chosen:
      ConfInd.u.Indication.u.IndFlowControl.dwRestriction = H245_NO_RESTRICTION;
      break;

    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid Flow Control restriction %d",
                pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_ENDSESSION:
    ASSERT(pPdu->choice == MSCMg_cmmnd_chosen);
    ASSERT(pPdu->u.MSCMg_cmmnd.choice  == endSessionCommand_chosen);
    ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_DISCONNECT;
    switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice)
    {
    case EndSssnCmmnd_nonStandard_chosen:
     ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_NONSTD,
     ConfInd.u.Indication.u.IndEndSession.SessionNonStd =
       pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.EndSssnCmmnd_nonStandard;
      break;
    case disconnect_chosen:
      break;
    case gstnOptions_chosen:
      switch (pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice)
      {
      case EndSessionCommand_gstnOptions_telephonyMode_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_TELEPHONY;
        break;
      case v8bis_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V8BIS;
        break;
      case v34DSVD_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DSVD;
        break;
      case v34DuplexFAX_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34DUPFAX;
        break;
      case v34H324_chosen:
        ConfInd.u.Indication.u.IndEndSession.SessionMode = H245_ENDSESSION_V34H324;
        break;
      default:
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: Invalid End Session GSTN options %d",
                  pPdu->u.MSCMg_cmmnd.u.endSessionCommand.u.gstnOptions.choice);
      } // switch
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: Invalid End Session type %d",
                pPdu->u.MSCMg_cmmnd.u.endSessionCommand.choice);
    } // switch
    break;

  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == functionNotUnderstood_chosen);
    break;

  case  H245_IND_JITTER:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == jitterIndication_chosen);
    break;

  case  H245_IND_H223_SKEW:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == h223SkewIndication_chosen);
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH223Skew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH223Skew.wSkew =
      pPdu->u.indication.u.h223SkewIndication.skew;
    break;

  case  H245_IND_NEW_ATM_VC:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == newATMVCIndication_chosen);
    break;

  case  H245_IND_USERINPUT:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == userInput_chosen);
    ConfInd.u.Indication.u.IndUserInput.Kind =
      pPdu->u.indication.u.userInput.choice;
    switch (pPdu->u.indication.u.userInput.choice)
    {
    case UsrInptIndctn_nnStndrd_chosen:
      ConfInd.u.Indication.u.IndUserInput.u.NonStd =
        pPdu->u.indication.u.userInput.u.UsrInptIndctn_nnStndrd;
      break;
    case alphanumeric_chosen:
#if 1
      nLength = MultiByteToWideChar(CP_ACP,             // code page
                                    0,                  // dwFlags
                                    pPdu->u.indication.u.userInput.u.alphanumeric,
                                    -1,                 // ASCII string length (in bytes)
                                    NULL,               // Unicode string
                                    0);                 // max Unicode string length
      pwchar = MemAlloc(nLength * sizeof(WCHAR));
      if (pwchar == NULL)
      {
        H245TRACE(pInstance->dwInst, 1,
                  "H245FsmIndication: no memory for user input", 0);
        lResult = H245_ERROR_NOMEM;
      }
      else
      {
        nLength = MultiByteToWideChar(CP_ACP,             // code page
                                      0,                  // dwFlags
                                      pPdu->u.indication.u.userInput.u.alphanumeric,
                                      -1,                 // ASCII string length (in bytes)
                                      pwchar,             // Unicode string
                                      nLength);           // max Unicode string length
        ConfInd.u.Indication.u.IndUserInput.u.pGenString = pwchar;
      }
#else
      ConfInd.u.Indication.u.IndUserInput.u.pGenString =
        pPdu->u.indication.u.userInput.u.alphanumeric;
#endif
      break;
    default:
      H245TRACE(pInstance->dwInst, 1,
                "H245FsmIndication: unrecognized user input type %d",
                pPdu->u.indication.u.userInput.choice);
      lResult = H245_ERROR_NOSUP;
    } // switch
    break;

  case  H245_IND_H2250_MAX_SKEW:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == h2250MxmmSkwIndctn_chosen);
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber1 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1;
    ConfInd.u.Indication.u.IndH2250MaxSkew.LogicalChannelNumber2 =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2;
    ConfInd.u.Indication.u.IndH2250MaxSkew.wSkew =
      pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew;
    break;

  case  H245_IND_MC_LOCATION:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == mcLocationIndication_chosen);
    lResult = LoadTransportAddress(&ConfInd.u.Indication.u.IndMcLocation,
                                  &pPdu->u.indication.u.mcLocationIndication.signalAddress);
    break;

  case  H245_IND_VENDOR_ID:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == vendorIdentification_chosen);
    ConfInd.u.Indication.u.IndVendorId.Identifier =
      pPdu->u.indication.u.vendorIdentification.vendor;
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & productNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pProductNumber =
        pPdu->u.indication.u.vendorIdentification.productNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byProductNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.productNumber.length;
    }
    if (pPdu->u.indication.u.vendorIdentification.bit_mask & versionNumber_present)
    {
      ConfInd.u.Indication.u.IndVendorId.pVersionNumber =
        pPdu->u.indication.u.vendorIdentification.versionNumber.value;
      ConfInd.u.Indication.u.IndVendorId.byVersionNumberLength = (BYTE)
        pPdu->u.indication.u.vendorIdentification.versionNumber.length;
    }
    break;

  case  H245_IND_FUNCTION_NOT_SUPPORTED:
    ASSERT(pPdu->choice == indication_chosen);
    ASSERT(pPdu->u.indication.choice == IndicationMessage_functionNotSupported_chosen);
    ConfInd.u.Indication.u.IndFns.Cause =
      pPdu->u.indication.u.functionNotSupported.cause.choice;
    ConfInd.u.Indication.u.IndFns.Type = UNKNOWN;

    /*if (pPdu->u.indication.u.functionNotSupported.bit_mask & returnedFunction_present)
    {
      int                  pduNum = MltmdSystmCntrlMssg_PDU;
      OssBuf               ossBuf;
      MltmdSystmCntrlMssg *pPduReturned;
      ossBuf.value  = pPdu->u.indication.u.functionNotSupported.returnedFunction.value;
      ossBuf.length = pPdu->u.indication.u.functionNotSupported.returnedFunction.length;
      if (ossDecode(pInstance->p_ossWorld,
                    &pduNum,
                    &ossBuf,
                    (void * *)&pPduReturned) == PDU_DECODED)
      {
        switch (pPduReturned->choice)
        {
        case MltmdSystmCntrlMssg_rqst_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MltmdSystmCntrlMssg_rqst.choice -
            RqstMssg_nonStandard_chosen + REQ_NONSTANDARD;
          break;
        case MSCMg_rspns_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_rspns.choice -
            RspnsMssg_nonStandard_chosen + RSP_NONSTANDARD;
          break;
        case MSCMg_cmmnd_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.MSCMg_cmmnd.choice -
            CmmndMssg_nonStandard_chosen + CMD_NONSTANDARD;
          break;
        case indication_chosen:
          ConfInd.u.Indication.u.IndFns.Type =
            pPduReturned->u.indication.choice -
            IndctnMssg_nonStandard_chosen + IND_NONSTANDARD;
          break;
        default:
          H245TRACE(pInstance->dwInst, 1,
                    "H245FsmIndication: unrecognized FunctionNotSupported message type %d",
                    pPduReturned->choice);
          lResult = H245_ERROR_NOSUP;
        } // switch
        // Free the PDU
        if (ossFreePDU(pInstance->p_ossWorld, pduNum, pPduReturned))
        {
          H245TRACE(pInstance->dwInst, 1, "H245FsmIndication: FREE FAILURE");
        }
      }
    }
    */
    break;
#if(0) // this isn't in H245 Version 3. and this code did nothing with it anyway
  case  H245_IND_H223_RECONFIG:
    ASSERT(pPdu->choice == MltmdSystmCntrlMssg_rqst_chosen);
    ASSERT(pPdu->u.MltmdSystmCntrlMssg_rqst.choice == h223AnnxARcnfgrtn_chosen);
    break;

  case  H245_IND_H223_RECONFIG_ACK:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnAck_chosen);
    break;

  case  H245_IND_H223_RECONFIG_REJECT:
    ASSERT(pPdu->choice == MSCMg_rspns_chosen);
    ASSERT(pPdu->u.MSCMg_rspns.choice == h223AnnxARcnfgrtnRjct_chosen);
    break;
#endif // if(0)
  default:
    /* Possible Error */
    H245TRACE(pInstance->dwInst, 1,
              "H245FsmIndication -> Invalid Indication Event %d", dwEvent);
    lResult = H245_ERROR_SUBSYS;
  } // switch

#if 1
  if (pwchar)
    MemFree(pwchar);
#endif

  if (lResult == H245_ERROR_OK)
  {
    if ((*pInstance->API.ConfIndCallBack)(&ConfInd, &pPdu->u.MltmdSystmCntrlMssg_rqst.u) == H245_ERROR_NOSUP)
    {
      H245FunctionNotUnderstood(pInstance, pPdu);
    }
    H245TRACE(pInstance->dwInst,4,"H245FsmIndication -> OK");
  }
  else
  {
    H245TRACE(pInstance->dwInst,1,"H245FsmIndication -> %s", map_api_error(lResult));
  }
  return lResult;
} // H245FsmIndication()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api_vers.h ===
#define API_VERSION "CJ006"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\av_asn1.h ===
#ifndef _MS_AV_ASN1_H_
#define _MS_AV_ASN1_H_

#include "nmasn1.h"

#ifdef __cplusplus
extern "C" {
#endif

// lonchanc: copied from ossdll.h
#define DLL_ENTRY       WINAPI
#define DLL_ENTRY_FDEF  WINAPI
#define DLL_ENTRY_FPTR  WINAPI


extern ASN1module_t     H225ASN_Module;

#define q931asn         H225ASN_Module
#define ObjectID_       ASN1objectidentifier_s

typedef ASN1bool_t      ASN1_BOOL;


typedef struct
{
    ASN1encoding_t  pEncInfo;
    ASN1decoding_t  pDecInfo;
}
    ASN1_CODER_INFO;

typedef struct
{
    ULONG           length;
    PBYTE           value;
}
    ASN1_BUF;

int H225_InitModule(void);
int H225_TermModule(void);

int Q931_InitWorld(ASN1_CODER_INFO *pWorld);
int Q931_TermWorld(ASN1_CODER_INFO *pWorld);
int Q931_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, BYTE **ppEncoded, DWORD *pcbEncodedSize);
int Q931_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, BYTE *pEncoded, DWORD cbEncodedSize);

int H245_InitModule(void);
int H245_TermModule(void);
int H245_InitWorld(ASN1_CODER_INFO *pWorld);
int H245_TermWorld(ASN1_CODER_INFO *pWorld);
int H245_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int H245_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);




__inline int freePDU(ASN1_CODER_INFO *pWorld, int nPDU, void *pDecoded, ASN1module_t pModule)
{
    ASN1_FreeDecoded(pWorld->pDecInfo, pDecoded, nPDU);
    return ASN1_SUCCESS;
}


#ifdef __cplusplus
}
#endif

#endif // _MS_AV_ASN1_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callcont.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcont.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.208  $
 *	$Date:   03 Mar 1997 19:40:58  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#define CALL_CONTROL_EXPORT

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#ifdef FORCE_SERIALIZE_CALL_CONTROL
    #include "cclock.h"
#endif  // FORCE_SERIALIZE_CALL_CONTROL
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"


#ifdef    GATEKEEPER
HRESULT InitGkiManager(void);
void    DeInitGkiManager(void);
extern HRESULT GkiRegister(void);
extern HRESULT GkiListenAddr(SOCKADDR_IN* psin);
extern HRESULT GkiUnregister(void);
extern VOID GKI_SetGKAddress(PSOCKADDR_IN pAddr);
extern BOOL fGKEnabled;
extern RASNOTIFYPROC gpRasNotifyProc;

#define GKI_MAX_BANDWIDTH       (0xFFFFFFFF / 100)
#endif // GATEKEEPER
VOID InitCallControl();

CALL_CONTROL_STATE		CallControlState = INITIALIZING_STATE;
BOOL					bISDMLoaded = FALSE;
static HRESULT			InitStatus;
// NumThreads counts the number of threads which are executing code within this DLL.
// NumThreads must be incremented at each DLL entry point (which includes each API
// call, the Q931 callback location and the H245 callback location).
// NumThreads must be decremented upon DLL exit.  The macro LeaveCallControlTop()
// is used to facilitate this operation.  Note that LeaveCallControlTop may accept
// a function call as a parameter; we must call the function first, save its return
// value, then decrement NumThreads, and finally return the saved value.
THREADCOUNT				ThreadCount;
extern CC_CONFERENCEID	InvalidConferenceID;

#define _Unicode(x) L ## x
#define Unicode(x) _Unicode(x)

WORD  ADDRToInetPort(CC_ADDR *pAddr);
DWORD ADDRToInetAddr(CC_ADDR *pAddr);

#ifdef _DEBUG

static const PSTR c_apszDbgZones[] =
{
    "CallCont",
    DEFAULT_ZONES
};

#endif // _DEBUG



BOOL WINAPI DllMain(				HINSTANCE				hInstDll,
									DWORD					fdwReason,
									LPVOID					lpvReserved)
{
	switch (fdwReason) {
		case DLL_PROCESS_ATTACH:
			// The DLL is being mapped into the process's address space
			
			ASSERT(CallControlState == INITIALIZING_STATE);
			ASSERT(CC_OK == CS_OK);
			ASSERT(CC_OK == H245_ERROR_OK);

#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif
            DBG_INIT_MEMORY_TRACKING(hInstDll);

			InitializeLock(&ThreadCount.Lock);
			ThreadCount.wNumThreads = 0;
// 6/25/98            InitCallControl();
            H245_InitModule();
			break;

		case DLL_THREAD_ATTACH:
			// A thread is being created
			break;

		case DLL_THREAD_DETACH:
			// A thread is exiting cleanly
			break;

		case DLL_PROCESS_DETACH:
			// The DLL is being unmapped from the process's address space

            H245_TermModule();
			DeleteLock(&ThreadCount.Lock);

            DBG_CHECK_MEMORY_TRACKING(hInstDll);
#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif
			break;
	}

	return TRUE;
}

VOID InitCallControl()
{
#ifdef FORCE_SERIALIZE_CALL_CONTROL	
    InitStatus = InitializeCCLock();
    if (InitStatus != CC_OK)
		return;
#endif

    InitStatus = H225Init();
    if (InitStatus != CC_OK)
		return;
		
#ifdef    GATEKEEPER			
	InitStatus = InitGkiManager();
//  an error return is OK for now.  Run totally gatekeeper-less
//	if (InitStatus != CC_OK)
//	
#endif // GATEKEEPER

	InitStatus = InitConferenceManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = InitCallManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitChannelManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitH245Manager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitListenManager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitQ931Manager();
	if (InitStatus != CC_OK)
		return;
	
	InitStatus = InitUserManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = InitHangupManager();
	if (InitStatus != CC_OK)
		return;

	InitStatus = Q931Init();
	if (InitStatus != CS_OK)
		return;

	CallControlState = OPERATIONAL_STATE;
}

CC_API
HRESULT CC_Initialize()
{
    if (CallControlState == OPERATIONAL_STATE)
    {
        return (CC_OK);
    }
    else if((CallControlState == INITIALIZING_STATE) || (CallControlState == SHUTDOWN_STATE))
    {
        InitCallControl();
    }
    return (InitStatus);
}


CC_API
HRESULT CC_AcceptCall(				CC_HCONFERENCE			hConference,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									CC_HCALL				hCall,
                                    DWORD                   dwBandwidth,
									DWORD_PTR				dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HQ931CALL		hQ931Call;
WORD			wNumCalls;
CC_ADDR			AlternateAddr;
PCC_ADDR		pAlternateAddr;
BOOL			bAccept = FALSE;
BYTE			bRejectReason = CC_REJECT_UNDEFINED_REASON;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	ASSERT(pCall->hConference == CC_INVALID_HANDLE);

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;

	status = AddLocalNonStandardDataToCall(pCall, pNonStandardData);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	status = AddLocalDisplayToCall(pCall, pszDisplay);
	if (status != CC_OK) {
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}

	UnlockCall(pCall);
	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status == CC_OK) {
		status = LockCall(hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	} else
		LeaveCallControlTop(status);

	if ((pCall->bCallerIsMC == TRUE) &&
		((pConference->tsMultipointController == TS_TRUE) ||
		 (pConference->bMultipointCapable == FALSE))) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		if (pConference->bMultipointCapable == FALSE) {
			LeaveCallControlTop(CC_BAD_PARAM);
		} else {
			LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if ((wNumCalls > 0) &&
		(pConference->bMultipointCapable == FALSE)) {
		FreeCall(pCall);
		UnlockConference(pConference);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		LeaveCallControlTop(CC_NOT_MULTIPOINT_CAPABLE);
	}

	pAlternateAddr = NULL;

	if (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)) {
		if (wNumCalls > 0) {
			if (pConference->tsMultipointController == TS_TRUE) {
				// Accept Call
				status = CC_OK;
				bAccept = TRUE;
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr != NULL) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		} else { // wNumCalls == 0
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		}
	} else { // pCall->ConferenceID != pConference->ConferenceID
		if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
			// Accept Call
			status = CC_OK;
			bAccept = TRUE;
		} else { // pConferenceID != InvalidConferenceID
			if (pConference->tsMultipointController == TS_TRUE) {
				// Reject Call - route to MC
				status = CC_OK;
				bAccept = FALSE;
				bRejectReason = CC_REJECT_ROUTE_TO_MC;
				pAlternateAddr = &AlternateAddr;
				if (GetLastListenAddress(pAlternateAddr) != CC_OK) {
					pAlternateAddr = NULL;
					bRejectReason = CC_REJECT_UNDEFINED_REASON;
				}
			} else { // we're not the MC
				if (pConference->bMultipointCapable) {
					if (pConference->pMultipointControllerAddr) {
						// Reject Call - route to MC
						status = CC_OK;
						bAccept = FALSE;
						bRejectReason = CC_REJECT_ROUTE_TO_MC;
						AlternateAddr = *pConference->pMultipointControllerAddr;
						pAlternateAddr = &AlternateAddr;
					} else { // we don't have the MC's address
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						// Error - no MC
						status = CC_NOT_MULTIPOINT_CAPABLE;
					}
				} else { // we're not multipoint capable
					// Error - bad param
					status = CC_BAD_PARAM;
				}
			}
		}
	}

	if (status != CC_OK) {
		FreeCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept) {
		pCall->dwUserToken = dwUserToken;

#ifdef    GATEKEEPER
        if(GKIExists())
        {
    		pCall->hConference = hConference;

    		// Fill in Gatekeeper Call fields
    		memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));
    		pCall->GkiCall.pCall            = pCall;
    		pCall->GkiCall.hCall            = hCall;
            pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
    		pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
    		pCall->GkiCall.bAnswerCall      = TRUE;
    		
    		if(pCall->pSourceCallSignalAddress)
    		{
    			pCall->GkiCall.dwIpAddress      = ADDRToInetAddr(pCall->pSourceCallSignalAddress);
    		    pCall->GkiCall.wPort            = pCall->pSourceCallSignalAddress->Addr.IP_Binary.wPort;
    		}
    		else
    		{
        		pCall->GkiCall.dwIpAddress      = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
        		pCall->GkiCall.wPort            = pCall->pQ931PeerConnectAddr->Addr.IP_Binary.wPort;
    		}
    		pCall->GkiCall.CallIdentifier   = pCall->CallIdentifier;
    		
    		if (pConference->bMultipointCapable)
    			pCall->GkiCall.CallType = MANY_TO_MANY;
    		else
    			pCall->GkiCall.CallType = POINT_TO_POINT;
            pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;
    		status = GkiOpenCall(&pCall->GkiCall, pConference);

            // GkiOpenCall may or may not have called AcceptCall, which unlocks
            // call and conference and may or may not free the call
    	    if (ValidateCall(hCall) == CC_OK)
    			if (status == CC_OK)
    				UnlockCall(pCall);
    			else
    				FreeCall(pCall);
    	    if (ValidateConference(hConference) == CC_OK)
    		    UnlockConference(pConference);

            if (status != CC_OK)
            {
    		    Q931RejectCall( hQ931Call,				        // Q931 call handle
    		  			        CC_REJECT_GATEKEEPER_RESOURCES, // reject reason
    		  			        &ConferenceID,
    		    		        NULL,          			        // alternate address
    		  			        pNonStandardData);		        // non-standard data
            }
        }
        else
        {
            status = AcceptCall(pCall, pConference);
        }
#else  // GATEKEEPER
		status = AcceptCall(pCall, pConference);
#endif // GATEKEEPER

		LeaveCallControlTop(status);
	} else { // bAccept == FALSE
		FreeCall(pCall);
		if (bRejectReason == CC_REJECT_ROUTE_TO_MC) {
			ASSERT(pAlternateAddr != NULL);
			ConferenceID = pConference->ConferenceID;
		} else
			pAlternateAddr = NULL;

		UnlockConference(pConference);
		status = Q931RejectCall(hQ931Call,				// Q931 call handle
								bRejectReason,			// reject reason
								&ConferenceID,
				   				pAlternateAddr,			// alternate address
								pNonStandardData);		// non-standard data
		LeaveCallControlTop(status);
	}
}



CC_API
HRESULT CC_AcceptChannel(			CC_HCHANNEL				hChannel,
									PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									DWORD					dwChannelBitRate)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
//#ifndef    GATEKEEPER
H245_MUX_T		H245MuxTable;
WORD			i;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
CC_HCONFERENCE hConference;
//#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pRTCPAddr != NULL)
		if ((pRTCPAddr->nAddrType != CC_IP_BINARY) ||
			(pRTCPAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);


	// Make sure that hChannel is a receive or proxy channel that
	// hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pChannel->bMultipointChannel) {
		if ((pRTPAddr != NULL) || (pRTCPAddr != NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
	} else
		if ((pRTPAddr == NULL) || (pRTCPAddr == NULL)) {
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hCall = pChannel->hCall;
	status = LockCall(hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pChannel->bMultipointChannel == FALSE) {
		status = AddLocalAddrPairToChannel(pRTPAddr, pRTCPAddr, pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockChannel(pChannel);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pChannel->dwChannelBitRate = dwChannelBitRate;
    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
    	status = GkiOpenChannel(&pCall->GkiCall, dwChannelBitRate, hChannel, RX);
    	if (ValidateCall(hCall) == CC_OK)
    		UnlockCall(pCall);
	}
	else
	{
        if (pChannel->wNumOutstandingRequests != 0)
        {
    		if ((pChannel->bMultipointChannel) &&
    			(pConference->tsMultipointController == TS_TRUE))
    		{
    			// Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
    			if (pConference->pSessionTable != NULL) {
    				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
    					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
    						pChannel->bSessionID) {
    						pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
    						pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
    						break;
    					}
    				}
    			}
    		}

    		H245MuxTable.Kind = H245_H2250ACK;
    		H245MuxTable.u.H2250ACK.nonStandardList = NULL;

    		if (pRTPAddr != NULL) {
    			if (pRTPAddr->bMulticast)
    				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
    			else
    				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
    			H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
    				pRTPAddr->Addr.IP_Binary.wPort;
    			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
    								pRTPAddr->Addr.IP_Binary.dwAddr);
    			H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
    		} else
    			H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

    		if (pRTCPAddr != NULL) {
    			if (pRTCPAddr->bMulticast)
    				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
    			else
    				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
    			H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
    				pRTCPAddr->Addr.IP_Binary.wPort;
    			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
    								pRTCPAddr->Addr.IP_Binary.dwAddr);
    			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
    		} else
    			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

    		H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
    		H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
    		H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
    		
    		status = H245OpenChannelAccept(pCall->H245Instance,
    									   0,					// dwTransId
    									   pChannel->wRemoteChannelNumber, // Rx channel
    									   &H245MuxTable,
    									   0,						// Tx channel
    									   NULL,					// Tx mux
    									   H245_INVALID_PORT_NUMBER,// Port
    									   pChannel->pSeparateStack);
    		if (status == CC_OK)
    			pChannel->wNumOutstandingRequests = 0;
    		else
    			--(pChannel->wNumOutstandingRequests);
    	}

    	pChannel->tsAccepted = TS_TRUE;

        Params.hChannel = hChannel;
        if (status == CC_OK)
            UnlockChannel(pChannel);
        else
            FreeChannel(pChannel);
        UnlockCall(pCall);

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_ACCEPT_CHANNEL_INDICATION,
                                     status,
                                     &Params);
    	if (ValidateConference(hConference) == CC_OK)
    		UnlockConference(pConference);
	}
#else  // GATEKEEPER
	if (pChannel->wNumOutstandingRequests != 0) {
		if ((pChannel->bMultipointChannel) &&
			(pConference->tsMultipointController == TS_TRUE)) {
			// Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
			if (pConference->pSessionTable != NULL) {
				for (i = 0; i < pConference->pSessionTable->wLength; i++) {
					if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
						pChannel->bSessionID) {
						pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
						break;
					}
				}
			}
		}

		H245MuxTable.Kind = H245_H2250ACK;
		H245MuxTable.u.H2250ACK.nonStandardList = NULL;

		if (pRTPAddr != NULL) {
			if (pRTPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
				pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
								pRTPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

		if (pRTCPAddr != NULL) {
			if (pRTCPAddr->bMulticast)
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
			else
				H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
			H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
				pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
								pRTCPAddr->Addr.IP_Binary.dwAddr);
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
		} else
			H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

		H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
		H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
		H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;
		
		status = H245OpenChannelAccept(pCall->H245Instance,
									   0,					// dwTransId
									   pChannel->wRemoteChannelNumber, // Rx channel
									   &H245MuxTable,
									   0,						// Tx channel
									   NULL,					// Tx mux
									   H245_INVALID_PORT_NUMBER,// Port
									   pChannel->pSeparateStack);
		if (status == CC_OK)
			pChannel->wNumOutstandingRequests = 0;
		else
			--(pChannel->wNumOutstandingRequests);
	}

	pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_AcceptT120Channel(		CC_HCHANNEL				hChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr)
{
HRESULT			status;
PCHANNEL		pChannel;
PCALL			pCall;
PCONFERENCE		pConference;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
H245_MUX_T		H245MuxTable;
WORD			i;
WORD			wNumCalls;
PCC_HCALL		CallList;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
			(pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a bidirectional channel that was
	// not opened locally and hasn't already been accepted or rejected
	if ((pChannel->bChannelType != TXRX_CHANNEL) ||
		(pChannel->tsAccepted != TS_UNKNOWN) ||
		(pChannel->bLocallyOpened == TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// If the remote endpoint specified a channel address, it will
	// be contained in the SeparateStack field, and we are not
	// allowed to specify another address in pAddr;
	// if the remote endpoint did not specify a channel address,
	// we must specify one now
	if (((pChannel->pSeparateStack == NULL) && (pAddr == NULL)) ||
	    ((pChannel->pSeparateStack != NULL) && (pAddr != NULL))) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Add the SeparateStack field to the channel, if necessary
	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
		AddSeparateStackToChannel(pSeparateStack, pChannel);
	} else
		pSeparateStack = NULL;

    // Send an ACK to the endpoint which requested the channel
	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	H245MuxTable.Kind = H245_H2250ACK;
	H245MuxTable.u.H2250ACK.nonStandardList = NULL;
	H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250ACK.sessionIDPresent = FALSE;

	status = H245OpenChannelAccept(pCall->H245Instance,	// dwInst
								   0,					// dwTransId
								   pChannel->wRemoteChannelNumber, // remote channel
								   &H245MuxTable,			// Rx Mux
								   pChannel->wLocalChannelNumber,	// local channel
								   NULL,					// Tx mux
								   H245_INVALID_PORT_NUMBER,// Port
								   pSeparateStack);
	if (status != CC_OK) {
 		FreeChannel(pChannel);
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}
	pChannel->tsAccepted = TS_TRUE;
	--(pChannel->wNumOutstandingRequests);
	UnlockCall(pCall);

	// If we're the MC in a multipoint conference, forward the
	// open T.120 channel request to all other endpoints in the conference
	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (CallList[i] != pChannel->hCall) {
				if (LockCall(CallList[i], &pCall) == CC_OK) {
					status = H245OpenChannel(pCall->H245Instance,		// H245 instance
											 pChannel->hChannel,		// dwTransId
											 pChannel->wLocalChannelNumber,
											 pChannel->pTxH245TermCap,	// TxMode
											 pChannel->pTxMuxTable,		// TxMux
											 H245_INVALID_PORT_NUMBER,	// TxPort
											 pChannel->pRxH245TermCap,	// RxMode
											 pChannel->pRxMuxTable,		// RxMux
											 pChannel->pSeparateStack);
					UnlockCall(pCall);
				}
			}
		}
		MemFree(CallList);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}


				
CC_API
HRESULT CC_CallListen(				PCC_HLISTEN				phListen,
									PCC_ADDR				pListenAddr,
									PCC_ALIASNAMES			pLocalAliasNames,
									DWORD_PTR				dwListenToken,
									CC_LISTEN_CALLBACK		ListenCallback)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phListen == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phListen now, in case we encounter an error
	*phListen = CC_INVALID_HANDLE;

	if (pListenAddr == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pListenAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	if (ListenCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = SetQ931Port(pListenAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = AllocAndLockListen(phListen,
								pListenAddr,
								0,				// hQ931Listen
								pLocalAliasNames,
								dwListenToken,
								ListenCallback,
								&pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

	status = Q931Listen(&hQ931Listen, pListenAddr,
						(DWORD)*phListen, (Q931_CALLBACK)Q931Callback);
	if (status != CS_OK) {
		if (LockListen(*phListen, &pListen) == CC_OK)
			FreeListen(pListen);
		*phListen = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = LockListen(*phListen, &pListen);
	if (status != CC_OK) {
		Q931CancelListen(hQ931Listen);
		LeaveCallControlTop(status);
	}

	ASSERT(pListenAddr != NULL);
	ASSERT(pListenAddr->nAddrType == CC_IP_BINARY);

	pListen->hQ931Listen = hQ931Listen;
	// Copy the binary form of the listen address into the listen object
	pListen->ListenAddr = *pListenAddr;

#ifdef    GATEKEEPER

    if (GkiOpenListen(*phListen,
					   pLocalAliasNames,
					   pListenAddr->Addr.IP_Binary.dwAddr,
					   pListenAddr->Addr.IP_Binary.wPort) != NOERROR)
    {
        WARNING_OUT(("CC_CallListen - Gatekeeper init failed (GkiOpenListen), but still support H.323 calls"));
    }

    UnlockListen(pListen);
   
#else
	status = UnlockListen(pListen);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_EnableGKRegistration(
    BOOL fEnable,
    PSOCKADDR_IN pAddr,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc)
{
    HRESULT			status = CC_OK;
    if(!pRasNotifyProc)
       	return CC_BAD_PARAM;
       	
    gpRasNotifyProc = pRasNotifyProc;

   	EnterCallControlTop();
    if(fEnable)
    {
        ASSERT(pLocalAliasNames && pAddr && pVendorInfo);
        if(!pLocalAliasNames || !pAddr)
       		LeaveCallControlTop(CC_BAD_PARAM);
       		
        status = GkiSetRegistrationAliases(pLocalAliasNames);
        if(status != CC_OK)
		    LeaveCallControlTop(status);
		
        status = GkiSetVendorConfig(pVendorInfo, dwMultipointConfiguration);
        if(status != CC_OK)
		    LeaveCallControlTop(status);		
		
		GKI_SetGKAddress(pAddr);
        GkiListenAddr(pAddr);
        status = GkiRegister();
        fGKEnabled = TRUE;
    }
    else
    {
        status = GkiUnregister();
        fGKEnabled = FALSE;
        GkiSetRegistrationAliases(NULL);
        GkiSetVendorConfig(NULL, 0);
    }
	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_CancelCall(				CC_HCALL				hCall)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
HRESULT			SaveStatus;
H245_INST_T		H245Instance;
HQ931CALL		hQ931Call;
WORD			wNumCalls;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pCall->CallState != ENQUEUED) &&
		(pCall->CallState != PLACED) &&
		(pCall->CallState != RINGING) &&
		(pCall->CallState != TERMCAP)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pCall->GkiCall.uGkiCallState != 0)
    	{
	    	GkiCloseCall(&pCall->GkiCall);
    	}
    }
#endif // GATEKEEPER

	H245Instance = pCall->H245Instance;
	hQ931Call = pCall->hQ931Call;
	FreeCall(pCall);

	if (H245Instance != H245_INVALID_ID)
		SaveStatus = H245ShutDown(H245Instance);
	else
		SaveStatus = H245_ERROR_OK;
	
	if (hQ931Call != 0) {
		if (SaveStatus == H245_ERROR_OK) {
			SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (SaveStatus == CS_BAD_PARAM)
				SaveStatus = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
	}

	for ( ; ; ) {
		// Start up an enqueued call, if one exists
		status = RemoveEnqueuedCallFromConference(pConference, &hCall);
		if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
			break;

		status = LockCall(hCall, &pCall);
		if (status == CC_OK) {
			pCall->CallState = PLACED;

			status = PlaceCall(pCall, pConference);
			UnlockCall(pCall);
			if (status == CC_OK)
				break;
		}
	}

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls == 0) {
		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
				(pConference->tsMultipointController != TS_TRUE))
				ReInitializeConference(pConference);
			UnlockConference(pConference);
		}
	} else {
		UnlockConference(pConference);
	}
	if (SaveStatus != CC_OK)
		status = SaveStatus;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CancelListen(			CC_HLISTEN				hListen)
{
HRESULT		status;
PLISTEN		pListen;
HQ931LISTEN	hQ931Listen;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hListen == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockListen(hListen, &pListen);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	hQ931Listen = pListen->hQ931Listen;

	// Unlock the listen object to prevent deadlock when calling Q931
	UnlockListen(pListen);

#ifdef    GATEKEEPER
   	status = GkiCloseListen(hListen);
#endif // GATEKEEPER

	status = Q931CancelListen(hQ931Listen);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		LeaveCallControlTop(FreeListen(pListen));
	} else
		LeaveCallControlTop(status);
}



CC_API
HRESULT CC_CloseChannel(			CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus = CC_OK;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
BOOL		bChannelCloseRequest;
CC_HCALL	hCall;
#ifdef    GATEKEEPER
unsigned    uBandwidth = 0;
#endif // GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->tsAccepted != TS_TRUE) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	if ((pChannel->bChannelType == RX_CHANNEL) ||
		(pChannel->bChannelType == PROXY_CHANNEL) ||
		((pChannel->bChannelType == TXRX_CHANNEL) &&
		 (pChannel->bLocallyOpened == FALSE))) {
		// Generate a channel close request
		bChannelCloseRequest = TRUE;
	} else {
		bChannelCloseRequest = FALSE;
		while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
			if (LockCall(hCall, &pCall) == CC_OK) {
				H245CloseChannelReqResp(pCall->H245Instance,
										H245_ACC,
										pChannel->wLocalChannelNumber);
				UnlockCall(pCall);
			}
		}
#ifdef    GATEKEEPER
        if(GKIExists())
        {
            if (pChannel->bChannelType != TXRX_CHANNEL)
            {
                if (pChannel->bMultipointChannel)
                {
                    // Multicast channel bandwidth is assigned to arbitrary call
    	            uBandwidth = pChannel->dwChannelBitRate / 100;
                }
                else
                {
                    // Channel bandwidth is assigned to a specific call
                    ASSERT(pChannel->hCall != CC_INVALID_HANDLE);
    		        if (LockCall(pChannel->hCall, &pCall) == CC_OK)
    		        {
    			        SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel);
    			        UnlockCall(pCall);
                    }
                }
            }
        }
#endif // GATEKEEPER
	}

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			if (bChannelCloseRequest) {
				if ((pChannel->bChannelType != PROXY_CHANNEL) ||
					(pChannel->hCall == pCall->hCall)) {
					// Note that dwTransID is set to the call handle of
					// the peer who initiated the close channel request.
					// When the close channel response is received,
					// the dwTransID gives us back the call handle to which
					// the response must be forwarded. In this case,
					// the local endpoint initiated the close channel request,
					// so we'll use CC_INVALID_HANDLE as the dwTransId
					// to note this fact.
					status = H245CloseChannelReq(pCall->H245Instance,	// H245 instance
												 CC_INVALID_HANDLE,		// dwTransId
												 pChannel->wRemoteChannelNumber);
				}
			} else {
				status = H245CloseChannel(pCall->H245Instance,	// H245 instance
										  0,					// dwTransId
										  pChannel->wLocalChannelNumber);
#ifdef    GATEKEEPER
                if(GKIExists())
                {
                    if (uBandwidth && uBandwidth <= pCall->GkiCall.uBandwidthUsed)
                    {
                        // Since the bandwidth is multicast, only subtract it from
                        // a single call (does not really matter which one)
    				    SaveStatus = GkiCloseChannel(&pCall->GkiCall, pChannel->dwChannelBitRate, hChannel);
    				    if (SaveStatus == CC_OK)
    				        uBandwidth = 0;
                    }
                }
#endif // GATEKEEPER
			}
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	if (pChannel->bChannelType == PROXY_CHANNEL) {
		// If this is a PROXY channel, keep the channel object around
		// until the channel owner closes it
		pChannel->tsAccepted = TS_FALSE;
		UnlockChannel(pChannel);
	} else {
		// FreeChannel(pChannel);
		// this is asynchronously released in _ConfClose(), in h245man.c
	}
	UnlockConference(pConference);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_CloseChannelResponse(	CC_HCHANNEL				hChannel,
									BOOL					bWillCloseChannel)
{
HRESULT			status;
PCHANNEL		pChannel;
PCONFERENCE		pConference;
CC_HCALL		hCall;
PCALL			pCall;
H245_ACC_REJ_T	AccRej;
WORD			wNumRequests;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (((pChannel->bChannelType != TX_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
	     (pChannel->bLocallyOpened == FALSE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (bWillCloseChannel)
		AccRej = H245_ACC;
	else
		AccRej = H245_REJ;

	wNumRequests = 0;
	while (DequeueRequest(&pChannel->pCloseRequests, &hCall) == CC_OK) {
		wNumRequests++;
		if (LockCall(hCall, &pCall) == CC_OK) {
			H245CloseChannelReqResp(pCall->H245Instance,
									AccRej,
									pChannel->wLocalChannelNumber);
			UnlockCall(pCall);
		}
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);

	if (wNumRequests == 0)
		status = CC_BAD_PARAM;
	else
		status = CC_OK;

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_ChangeConferenceCapabilities(
									CC_HCONFERENCE			hConference,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
HRESULT		status;
PCONFERENCE	pConference;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
BOOL		bConferenceTermCapsChanged;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached == DETACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pLocalH245TermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);
	status = CopyH245TermCapList(&pConference->pLocalH245TermCapList,
								 pTermCapList);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pLocalH245TermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);
	// create a new descriptor list if one was not supplied
	if (pTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
													 pConference->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors,
											pTermCapDescriptors);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = TRUE;

	if (bConferenceTermCapsChanged) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				SendTermCaps(pCall, pConference);
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_CreateConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									DWORD					dwConferenceConfiguration,
									PCC_TERMCAPLIST			pTermCapList,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR				dwConferenceToken,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_SESSIONTABLE_CONSTRUCTOR	SessionTableConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback)
{
PCONFERENCE				pConference;
HRESULT					status;
BOOL					bMultipointCapable;
BOOL					bForceMultipointController;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phConference == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	bMultipointCapable =
		(dwConferenceConfiguration & CC_CONFIGURE_MULTIPOINT_CAPABLE) != 0 ? TRUE : FALSE;
	bForceMultipointController =
		(dwConferenceConfiguration & CC_CONFIGURE_FORCE_MC) != 0 ? TRUE : FALSE;

	if ((bMultipointCapable == FALSE) &&
		(bForceMultipointController == TRUE))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pTermCapList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateTermCapList(pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTermCapDescriptors(pTermCapDescriptors, pTermCapList);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVendorInfo == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateVendorInfo(pVendorInfo);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (ConferenceCallback == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (SessionTableConstructor == NULL)
		SessionTableConstructor = DefaultSessionTableConstructor;

	if (TermCapConstructor == NULL)
		TermCapConstructor = DefaultTermCapConstructor;

	status = AllocAndLockConference(phConference,
									pConferenceID,
									bMultipointCapable,
									bForceMultipointController,
									pTermCapList,
									pTermCapDescriptors,
									pVendorInfo,
									pTerminalID,
									dwConferenceToken,
									SessionTableConstructor,
									TermCapConstructor,
									ConferenceCallback,
									&pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	LeaveCallControlTop(UnlockConference(pConference));
}



CC_API
HRESULT CC_DestroyConference(		CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT					status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = AsynchronousDestroyConference(hConference, bAutoAccept);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_EnumerateConferences(	PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
HRESULT	status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = EnumerateConferences(pwNumConferences, ConferenceList);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_FlowControl(				CC_HCHANNEL				hChannel,
									DWORD					dwRate)
{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL)) ||
		(pChannel->tsAccepted != TS_TRUE)) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCall(pChannel->hCall, &pCall);
	if (status != CC_OK) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = H245FlowControl(pCall->H245Instance,
							 H245_SCOPE_CHANNEL_NUMBER,
							 pChannel->wRemoteChannelNumber,
							 0,			// wResourceID, not used here
							 dwRate);	// H245_NO_RESTRICTION if no restriction

	UnlockCall(pCall);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}


CC_API
HRESULT CC_GetCallControlVersion(	WORD					wArraySize,
									PWSTR					pszVersion)
{
WCHAR	pszCCversion[256];
WCHAR	pszQ931version[256];

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (wArraySize == 0)
		LeaveCallControlTop(CC_BAD_PARAM);
	if (pszVersion == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	wcscpy(pszCCversion, L"Call Control ");
	wcscat(pszCCversion, Unicode(__DATE__));
	wcscat(pszCCversion, L" ");
	wcscat(pszCCversion, Unicode(__TIME__));
	wcscat(pszCCversion, L"\n");
	Q931GetVersion(sizeof(pszQ931version)/sizeof(WCHAR), pszQ931version);
	wcscat(pszCCversion, pszQ931version);

	if (wcslen(pszCCversion) >= wArraySize) {
		memcpy(pszVersion, pszCCversion, (wArraySize-1)*sizeof(WCHAR));
		pszVersion[wArraySize-1] = L'\0';
		LeaveCallControlTop(CC_BAD_SIZE);
	}

	wcscpy(pszVersion, pszCCversion);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_GetConferenceAttributes(	CC_HCONFERENCE				hConference,
									PCC_CONFERENCEATTRIBUTES	pConferenceAttributes)
{
HRESULT		status;
PCONFERENCE	pConference;
WORD		wNumCalls;
BOOL		bLocallyAttached;
PCC_HCALL	CallList;
PCALL		pCall;
WORD		wLimit;
WORD		wIndex;
WORD		wOctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pConferenceAttributes == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	pConferenceAttributes->bMaster =
		(pConference->tsMaster == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointController =
		(pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	pConferenceAttributes->bMultipointConference =
		(pConference->ConferenceMode == MULTIPOINT_MODE ? TRUE : FALSE);
	pConferenceAttributes->ConferenceID = pConference->ConferenceID;
	pConferenceAttributes->LocalTerminalLabel = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
	if (pConference->LocalEndpointAttached == ATTACHED)
		bLocallyAttached = TRUE;
	else
		bLocallyAttached = FALSE;
	if ((pConference->tsMultipointController == TS_TRUE) ||
		(pConference->ConferenceMode == POINT_TO_POINT_MODE))
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	else
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	pConferenceAttributes->dwConferenceToken = pConference->dwConferenceToken;
	UnlockConference(pConference);
	if (bLocallyAttached)
		pConferenceAttributes->wNumCalls = (WORD)(wNumCalls + 1);
	else
		pConferenceAttributes->wNumCalls = wNumCalls;

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pConferenceAttributes->dwBandwidthAllocated = 0;
    	pConferenceAttributes->dwBandwidthUsed      = 0;
    	for (wIndex = 0; wIndex < wNumCalls; ++wIndex) {
    		if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
    			pConferenceAttributes->dwBandwidthAllocated += pCall->GkiCall.uBandwidthAllocated;
    			if (pConferenceAttributes->dwBandwidthAllocated > GKI_MAX_BANDWIDTH)
    				pConferenceAttributes->dwBandwidthAllocated = GKI_MAX_BANDWIDTH;
    			pConferenceAttributes->dwBandwidthUsed += pCall->GkiCall.uBandwidthUsed;
    			if (pConferenceAttributes->dwBandwidthUsed > GKI_MAX_BANDWIDTH)
    				pConferenceAttributes->dwBandwidthUsed = GKI_MAX_BANDWIDTH;
    			UnlockCall(pCall);
    		}
    	}
        pConferenceAttributes->dwBandwidthAllocated *= 100;
        pConferenceAttributes->dwBandwidthUsed      *= 100;
    }
#endif // GATEKEEPER

	if (pConferenceAttributes->pParticipantList != NULL) {
		wLimit = pConferenceAttributes->pParticipantList->wLength;
		pConferenceAttributes->pParticipantList->wLength = 0;
		for (wIndex = 0; wIndex < wNumCalls; wIndex++) {
			if (LockCall(CallList[wIndex], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
							pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
						if ((pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
							(pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL) &&
							(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
							if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							    pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength) {
								wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
							} else {
								wOctetStringLength = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.wOctetStringLength;
								pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
							}
							memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
								   pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString,
								   wOctetStringLength);
						} else {
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;								
						}
					}
					pConferenceAttributes->pParticipantList->wLength++;
				}
				UnlockCall(pCall);
			}
		}
		if (bLocallyAttached) {
			if (LockConference(hConference, &pConference) == CC_OK) {
				if (pConferenceAttributes->pParticipantList->wLength < wLimit) {
					pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalLabel =
						pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel;
					if ((pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength != 0) &&
						(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL) &&
						(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString != NULL)) {
						if (pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength <
							pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength) {
							wOctetStringLength = pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength;
						} else {
							wOctetStringLength = pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength;
							pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength =	wOctetStringLength;
						}
						memcpy(pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString,
							   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
							   wOctetStringLength);
					} else {
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.wOctetStringLength = 0;
						pConferenceAttributes->pParticipantList->ParticipantInfoArray[pConferenceAttributes->pParticipantList->wLength].TerminalID.pOctetString = NULL;								
					}
				}
				pConferenceAttributes->pParticipantList->wLength++;
				UnlockConference(pConference);
			}
		}
	}
	
	if (CallList != NULL)
		MemFree(CallList);

	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_H245ConferenceRequest(	CC_HCALL				hCall,
									H245_CONFER_REQ_ENUM_T	RequestType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((RequestType != H245_REQ_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_CANCEL_MAKE_ME_CHAIR) &&
		(RequestType != H245_REQ_DROP_TERMINAL) &&
		(RequestType != H245_REQ_ENTER_H243_TERMINAL_ID) &&
		(RequestType != H245_REQ_ENTER_H243_CONFERENCE_ID))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceRequest(pCall->H245Instance,
								   RequestType,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceResponse(	CC_HCALL				hCall,
									H245_CONFER_RSP_ENUM_T	ResponseType,
									CC_TERMINAL_LABEL		CC_TerminalLabel,
									PCC_OCTETSTRING			pOctetString,
									CC_TERMINAL_LABEL		*pCC_TerminalList,
									WORD					wTerminalListCount)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
WORD			i;
TerminalLabel	*pH245TerminalList;
BYTE			*pH245OctetString;
BYTE			bH245OctetStringLength;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((ResponseType != H245_RSP_CONFERENCE_ID) &&
		(ResponseType != H245_RSP_PASSWORD) &&
		(ResponseType != H245_RSP_VIDEO_COMMAND_REJECT) &&
		(ResponseType != H245_RSP_TERMINAL_DROP_REJECT) &&
		(ResponseType != H245_RSP_DENIED_CHAIR_TOKEN) &&
		(ResponseType != H245_RSP_GRANTED_CHAIR_TOKEN))
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wTerminalListCount != 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pCC_TerminalList == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pOctetString);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pOctetString != NULL)
		if (pOctetString->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (wTerminalListCount == 0) {
		pH245TerminalList = NULL;
	} else {
		pH245TerminalList = (TerminalLabel *)MemAlloc(sizeof(TerminalLabel) * wTerminalListCount);
		if (pH245TerminalList == NULL) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(CC_NO_MEMORY);
		}

		for (i = 0; i < wTerminalListCount; i++) {
			pH245TerminalList[i].mcuNumber = pCC_TerminalList[i].bMCUNumber;
			pH245TerminalList[i].terminalNumber = pCC_TerminalList[i].bTerminalNumber;
		}
	}

	if (pOctetString == NULL) {
		pH245OctetString = NULL;
		bH245OctetStringLength = 0;
	} else {
		pH245OctetString = pOctetString->pOctetString;
		bH245OctetStringLength = (BYTE)pOctetString->wOctetStringLength;
	}

	status = H245ConferenceResponse(pCall->H245Instance,
									ResponseType,
									CC_TerminalLabel.bMCUNumber,
									CC_TerminalLabel.bTerminalNumber,
									pH245OctetString,
									bH245OctetStringLength,
									pH245TerminalList,
									wTerminalListCount);

	if (pH245TerminalList != NULL)
		MemFree(pH245TerminalList);
	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceCommand(	CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									H245_CONFER_CMD_ENUM_T	CommandType,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((CommandType != H245_CMD_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_CANCEL_BROADCAST_CHANNEL) &&
		(CommandType != H245_CMD_BROADCASTER) &&
		(CommandType != H245_CMD_CANCEL_BROADCASTER) &&
		(CommandType != H245_CMD_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_CANCEL_SEND_THIS_SOURCE) &&
		(CommandType != H245_CMD_DROP_CONFERENCE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	status = H245ConferenceCommand(pCall->H245Instance,
								   CommandType,
								   wChannelNumber,
								   TerminalLabel.bMCUNumber,
								   TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245ConferenceIndication(CC_HCALL				hCall,
									H245_CONFER_IND_ENUM_T	IndicationType,
									BYTE					bSBENumber,
									CC_TERMINAL_LABEL		TerminalLabel)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((IndicationType != H245_IND_SBE_NUMBER) &&
		(IndicationType != H245_IND_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ONE_OTHER) &&
		(IndicationType != H245_IND_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_CANCEL_SEEN_BY_ALL) &&
		(IndicationType != H245_IND_TERMINAL_YOU_ARE_SEEING) &&
		(IndicationType != H245_IND_REQUEST_FOR_FLOOR))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245ConferenceIndication(pCall->H245Instance,
									  IndicationType,
									  bSBENumber,
									  TerminalLabel.bMCUNumber,
									  TerminalLabel.bTerminalNumber);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousCommand(CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousCommand	*pMiscellaneousCommand)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousCommand == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousCommand->type.choice == multipointModeCommand_chosen) ||
		(pMiscellaneousCommand->type.choice == cnclMltpntMdCmmnd_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous command
	Pdu.choice = MSCMg_cmmnd_chosen;
	Pdu.u.MSCMg_cmmnd.choice = miscellaneousCommand_chosen;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand = *pMiscellaneousCommand;
	Pdu.u.MSCMg_cmmnd.u.miscellaneousCommand.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_H245MiscellaneousIndication(
									CC_HCALL				hCall,
									CC_HCHANNEL				hChannel,
									MiscellaneousIndication	*pMiscellaneousIndication)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
WORD		wChannelNumber;
PDU_T		Pdu;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pMiscellaneousIndication == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((pMiscellaneousIndication->type.choice == logicalChannelActive_chosen) ||
		(pMiscellaneousIndication->type.choice == logicalChannelInactive_chosen))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (hChannel == CC_INVALID_HANDLE) {
		wChannelNumber = 1;
	} else {
		status = LockChannel(hChannel, &pChannel);
		if (status != CC_OK) {
			UnlockCall(pCall);
			UnlockConference(pConference);
			LeaveCallControlTop(status);
		}
		switch (pChannel->bChannelType) {
			case TX_CHANNEL:
				wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			case RX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case TXRX_CHANNEL:
				wChannelNumber = pChannel->wRemoteChannelNumber;
				break;

			case PROXY_CHANNEL:
				if (pChannel->hCall == hCall)
					wChannelNumber = pChannel->wRemoteChannelNumber;
				else
					wChannelNumber = pChannel->wLocalChannelNumber;
				break;

			default:
				ASSERT(0);
				break;
		}
		UnlockChannel(pChannel);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication = *pMiscellaneousIndication;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber = wChannelNumber;

	status = H245SendPDU(pCall->H245Instance,	// H245 instance
						 &Pdu);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_Hangup(					CC_HCONFERENCE			hConference,
									BOOL					bTerminateConference,
									DWORD_PTR				dwUserToken)
{
HRESULT						status;
HRESULT						SaveStatus;
HHANGUP						hHangup;
PHANGUP						pHangup;
PCHANNEL					pChannel;
PCALL						pCall;
PCONFERENCE					pConference;
CC_HANGUP_CALLBACK_PARAMS	HangupCallbackParams;
HQ931CALL					hQ931Call;
WORD						wNumChannels;
PCC_HCHANNEL				ChannelList;
WORD						wNumCalls;
PCC_HCALL					CallList;
WORD						i;
H245_INST_T					H245Instance;
CALLSTATE					CallState;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// If the local endpoint is not attached, we will only allow a hangup if
	// the local endpoint is the MC in a multipoint conference and
	// conference termination is being requested
	if ((pConference->LocalEndpointAttached != ATTACHED) &&
		((bTerminateConference == FALSE) ||
		 (pConference->ConferenceMode != MULTIPOINT_MODE) ||
		 (pConference->tsMultipointController != TS_TRUE))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	HangupCallbackParams.dwUserToken = dwUserToken;

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE) &&
		(bTerminateConference == FALSE)) {

		// Send TerminalLeftConference (this call) to all established calls
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				H245ConferenceIndication(pCall->H245Instance,
										 H245_IND_TERMINAL_LEFT,	// Indication Type
										 0,							// SBE number; ignored here
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,		 // MCU number
										 pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber); // terminal number
				UnlockCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);

		// Delete all TX, RX and bi-directional channels on this conference
		// Leave PROXY_CHANNELs intact
		EnumerateChannelsInConference(&wNumChannels,
									  &ChannelList,
									  pConference,
									  TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL);
		for (i = 0; i < wNumChannels; i++) {
			if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
				// Notice that since we're going to hangup, we don't need to
				// close any channels
				FreeChannel(pChannel);	
		}
		if (ChannelList != NULL)
			MemFree(ChannelList);

		if (pConference->bDeferredDelete)
        {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		}
        else
        {
            //
            // Set DETACHED _before_ callback; that will call
            // CC_DestroyConference, which will call AsynchronousDestroyConference,
            // which will not do anything if we are still sttached.
            //
            if (pConference->LocalEndpointAttached != DETACHED)
            {
                pConference->LocalEndpointAttached = DETACHED;
                if (pConference->ConferenceCallback)
                {
                    pConference->ConferenceCallback(CC_HANGUP_INDICATION, CC_OK,
                        pConference->hConference, pConference->dwConferenceToken,
                        &HangupCallbackParams);
                }
            }

            if (ValidateConference(hConference) == CC_OK)
            {
	   			UnlockConference(pConference);
        	}
		}
		LeaveCallControlTop(CC_OK);
	}

	status = EnumerateChannelsInConference(&wNumChannels,
										   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);	
	}
	if (ChannelList != NULL)
		MemFree(ChannelList);

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_FALSE) &&
		(bTerminateConference == TRUE)) {
		ASSERT(wNumCalls == 1);
		
		if (LockCall(CallList[0], &pCall) == CC_OK) {
			// Send DropConference command to MC
			H245ConferenceCommand   (
						 pCall->H245Instance,
						 H245_CMD_DROP_CONFERENCE, // Command type
						 1,			// Channel
						 0,			// byMcuNumber
						 0);		// byTerminalNumber
			UnlockCall(pCall);
		}
	}

	status = AllocAndLockHangup(&hHangup,
								hConference,
								dwUserToken,
								&pHangup);
	if (status != CC_OK) {
	    if (CallList != NULL)
		    MemFree(CallList);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Now close all calls
	SaveStatus = H245_ERROR_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			H245Instance = pCall->H245Instance;
			hQ931Call = pCall->hQ931Call;
			CallState = pCall->CallState;
			FreeCall(pCall);
			if (CallState != ENQUEUED) {
				if (H245Instance != H245_INVALID_ID) {
					status = H245ShutDown(H245Instance);
					if (status == H245_ERROR_OK)
						pHangup->wNumCalls++;
					else
						// The link may already be shut down; if so, don't return an error
						if (status != LINK_INVALID_STATE)
							SaveStatus = status;
				}
				if (SaveStatus == H245_ERROR_OK) {
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						SaveStatus = Q931RejectCall(hQ931Call,
													CC_REJECT_UNDEFINED_REASON,
													&pConference->ConferenceID,
													NULL,	// alternate address
													NULL);	// pNonStandardData
					else
						SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
					// Q931Hangup may legitimately return CS_BAD_PARAM or LINK_INVALID_STATE,
					// because the Q.931 call object may have been deleted at this point
					if ((SaveStatus == CS_BAD_PARAM) ||
						(SaveStatus == LINK_INVALID_STATE))
						SaveStatus = CC_OK;
				} else
					if ((CallState == PLACED) ||
						(CallState == RINGING))
						Q931RejectCall(hQ931Call,
									   CC_REJECT_UNDEFINED_REASON,
									   &pConference->ConferenceID,
									   NULL,	// alternate address
									   NULL);	// pNonStandardData
					else
						Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			}
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	// Need to validate the conference object; H245ShutDown may cause us to re-enter
	// Call Control, which may result in deletion of the conference object
	if (ValidateConference(hConference) != CC_OK)
		LeaveCallControlTop(SaveStatus);

	// Delete the virtual calls (if any)
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			FreeCall(pCall);
		}

	if (CallList != NULL)
		MemFree(CallList);

	// XXX -- for sync 2, H245ShutDown() is synchronous, so change wNumCalls
	// to cause the user callback and associated cleanup to occur synchronously
	pHangup->wNumCalls = 0;

	if (pHangup->wNumCalls == 0)
    {
		if (pConference->bDeferredDelete)
        {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		}
        else
        {
            //
            // Set DETACHED _before_ callback; that will call
            // CC_DestroyConference, which will call AsynchronousDestroyConference,
            // which will not do anything if we are still sttached.
            //
            if (pConference->LocalEndpointAttached != DETACHED)
            {
                pConference->LocalEndpointAttached = DETACHED;

                if (pConference->ConferenceCallback)
                {
                    pConference->ConferenceCallback(CC_HANGUP_INDICATION, SaveStatus,
                        pConference->hConference, pConference->dwConferenceToken,
                        &HangupCallbackParams);
                }
            }

  			if (ValidateConference(hConference) == CC_OK)
            {
	    		ReInitializeConference(pConference);
		    	UnlockConference(pConference);
    		}

		}

		if (ValidateHangup(hHangup) == CC_OK)
			FreeHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	} else {
		UnlockHangup(pHangup);
		LeaveCallControlTop(SaveStatus);
	}
}



CC_API
HRESULT CC_MaximumAudioVideoSkew(	CC_HCHANNEL				hChannelAudio,
									CC_HCHANNEL				hChannelVideo,
									WORD					wMaximumSkew)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
PCHANNEL	pChannelAudio;
PCHANNEL	pChannelVideo;
PCC_HCALL	CallList;
WORD		wNumCalls;
WORD		i;
WORD		wNumSuccesses;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if ((hChannelAudio == CC_INVALID_HANDLE) || (hChannelVideo == CC_INVALID_HANDLE))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannelAudio, &pChannelAudio, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockChannel(hChannelVideo, &pChannelVideo);
	if (status != CC_OK) {
		UnlockChannel(pChannelAudio);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if ((pChannelAudio->hConference != pChannelVideo->hConference) ||
		(pChannelAudio->bChannelType != TX_CHANNEL) ||
		(pChannelAudio->wNumOutstandingRequests != 0) ||
		(pChannelVideo->bChannelType != TX_CHANNEL) ||
		(pChannelVideo->wNumOutstandingRequests != 0)) {
		UnlockChannel(pChannelAudio);
		UnlockChannel(pChannelVideo);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	wNumSuccesses = 0;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245H2250MaximumSkewIndication(pCall->H245Instance,
											        pChannelAudio->wLocalChannelNumber,
											        pChannelVideo->wLocalChannelNumber,
											        wMaximumSkew);
			UnlockCall(pCall);
			if (status == H245_ERROR_OK)
				wNumSuccesses++;
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockChannel(pChannelAudio);
	UnlockChannel(pChannelVideo);
	UnlockConference(pConference);
	if (wNumSuccesses == 0) {
		LeaveCallControlTop(status);
	} else {
		LeaveCallControlTop(CC_OK);
	}
}



CC_API
HRESULT CC_Mute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only mute transmit channels
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel inactive"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelInactive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_OpenChannel(				CC_HCONFERENCE			hConference,
									PCC_HCHANNEL			phChannel,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									BOOL					bSilenceSuppression,
									PCC_TERMCAP				pTermCap,
									PCC_ADDR				pLocalRTCPAddr,
									BYTE					bDynamicRTPPayloadType,
									DWORD					dwChannelBitRate,
									DWORD_PTR				dwUserToken)
{
HRESULT		status;
PCONFERENCE	pConference;
PCHANNEL	pChannel;
CC_HCALL	hCall;
PCALL		pCall;
H245_MUX_T	H245MuxTable;
WORD		i;
PCC_ADDR	pLocalRTPAddr;
PCC_ADDR	pPeerRTPAddr;
PCC_ADDR	pPeerRTCPAddr;
BOOL		bFoundSession;
WORD		wNumCalls;
PCC_HCALL	CallList;
//#ifndef GATEKEEPER
HRESULT		SaveStatus;
//#endif // !GATEKEEPER

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phChannel == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;
	
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pLocalRTCPAddr != NULL)
		if (pLocalRTCPAddr->nAddrType != CC_IP_BINARY)
			LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pTermCap == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((bDynamicRTPPayloadType != 0) &&
		((bDynamicRTPPayloadType < 96) || (bDynamicRTPPayloadType > 127)))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// XXX -- we may eventually want to support dynamic session generation
	if (bSessionID == 0)
		if ((pConference->tsMaster == TS_TRUE) ||
			(pConference->ConferenceMode == MULTIPOINT_MODE)) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}

	if (((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pLocalRTCPAddr != NULL)) ||
		((pConference->ConferenceMode != MULTIPOINT_MODE) &&
		(pLocalRTCPAddr == NULL))) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->ConferenceMode == MULTIPOINT_MODE) {
		// XXX -- We should be able to dynamically create a new session if needed
		// Validate session ID
		pLocalRTPAddr = NULL;
		pLocalRTCPAddr = NULL;
		bFoundSession = FALSE;
		if (pConference->pSessionTable != NULL) {
			for (i = 0; i < pConference->pSessionTable->wLength; i++) {
				if (bSessionID == pConference->pSessionTable->SessionInfoArray[i].bSessionID) {
					bFoundSession = TRUE;
					if (pConference->tsMultipointController == TS_TRUE) {
						pLocalRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
						pLocalRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
					}
					break;
				}
			}
		}
		if (bFoundSession == FALSE) {
			UnlockConference(pConference);
			LeaveCallControlTop(CC_BAD_PARAM);
		}
		pPeerRTPAddr = pLocalRTPAddr;
		pPeerRTCPAddr = pLocalRTCPAddr;
	} else {
		pLocalRTPAddr = NULL;
		pPeerRTPAddr = NULL;
		pPeerRTCPAddr = NULL;
	}

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	if (pLocalRTPAddr != NULL) {
		if (pLocalRTPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaChannel.u.ip.tsapIdentifier =
			pLocalRTPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaChannel.u.ip.network,
							pLocalRTPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	if (pLocalRTCPAddr != NULL) {
		if (pLocalRTCPAddr->bMulticast)
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_MULTICAST;
		else
			H245MuxTable.u.H2250.mediaControlChannel.type = H245_IP_UNICAST;
		H245MuxTable.u.H2250.mediaControlChannel.u.ip.tsapIdentifier =
			pLocalRTCPAddr->Addr.IP_Binary.wPort;
		HostToH245IPNetwork(H245MuxTable.u.H2250.mediaControlChannel.u.ip.network,
							pLocalRTCPAddr->Addr.IP_Binary.dwAddr);
		H245MuxTable.u.H2250.mediaControlChannelPresent = TRUE;
	} else
		H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;

	if (bDynamicRTPPayloadType == 0)
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	else {
		H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = TRUE;
		H245MuxTable.u.H2250.dynamicRTPPayloadType = bDynamicRTPPayloadType;
	}
	H245MuxTable.u.H2250.sessionID = bSessionID;
	if (bAssociatedSessionID == 0)
		H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	else {
		H245MuxTable.u.H2250.associatedSessionIDPresent = TRUE;
		H245MuxTable.u.H2250.associatedSessionID = bAssociatedSessionID;
	}
	H245MuxTable.u.H2250.mediaGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = TRUE;
	H245MuxTable.u.H2250.mediaControlGuaranteed = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = TRUE;
	// The silence suppression field must be present if and only if
	// the channel is an audio channel
	if (pTermCap->DataType == H245_DATA_AUDIO) {
		H245MuxTable.u.H2250.silenceSuppressionPresent = TRUE;
		H245MuxTable.u.H2250.silenceSuppression = (char) bSilenceSuppression;
	} else
		H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;

	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}

	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	// Set hCall in the channel object to indicate which call object
	// the channel is being opened to; if we're in multipoint mode,
	// the channel may be opened to multiple calls, to set hCall
	// to CC_INVALID_HANDLE. If the channel is opened in point-to-point
	// mode, and we later switch to multipoint mode and this peer hangs
	// up, hCall will be used to determine whether this call object
	// should be deleted
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)	{
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT(wNumCalls == 1);
		hCall = CallList[0];
		MemFree(CallList);
	} else {
		hCall = CC_INVALID_HANDLE;
	}

	status = AllocAndLockChannel(phChannel,
								 pConference,
								 hCall,				// hCall
								 pTermCap,			// Tx term cap
								 NULL,				// Rx term cap
								 &H245MuxTable,		// Tx mux table
								 NULL,				// Rx mux table
								 NULL,				// separate stack
								 dwUserToken,
								 TX_CHANNEL,
								 bSessionID,
								 bAssociatedSessionID,
								 0,					// remote channel number
								 pLocalRTPAddr,
								 pLocalRTCPAddr,
								 pPeerRTPAddr,
								 pPeerRTCPAddr,
								 TRUE,				// locally opened
								 &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	pChannel->dwChannelBitRate = dwChannelBitRate;
    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
        // If point-to-point mode, than wNumCalls == 1 and CallList[0] == hCall
        // If multipoint, choice of which channel to assign TX bandwidth to
        // is arbitrary. Either way, CallList[0] works.
    	status = LockCall(CallList[0], &pCall);
    	if (status == CC_OK)
    	{
    		status = GkiOpenChannel(&pCall->GkiCall, dwChannelBitRate, *phChannel, TX);
        	if (ValidateCall(CallList[0]) == CC_OK)
    	    	UnlockCall(pCall);
    	}
    	MemFree(CallList);
    	LeaveCallControlTop(status);
    }
    else
    {
        SaveStatus = CC_OK;
    	for (i = 0; i < wNumCalls; i++)
    	{
    		if (LockCall(CallList[i], &pCall) == CC_OK)
    		{
    			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
    									 pChannel->hChannel,		// dwTransId
    									 pChannel->wLocalChannelNumber,
    									 pChannel->pTxH245TermCap,	// TxMode
    									 pChannel->pTxMuxTable,		// TxMux
    									 H245_INVALID_PORT_NUMBER,	// TxPort
    									 pChannel->pRxH245TermCap,	// RxMode
    									 pChannel->pRxMuxTable,		// RxMux
    									 pChannel->pSeparateStack);
    			if (status == H245_ERROR_OK)
    				(pChannel->wNumOutstandingRequests)++;
    			else
    				SaveStatus = status;
    			UnlockCall(pCall);
    		}
    	}
    	
    	if (CallList != NULL)
    		MemFree(CallList);
    		
    	if (pChannel->wNumOutstandingRequests == 0)
    	{
    		// all open channel requests failed
    		FreeChannel(pChannel);
    		UnlockConference(pConference);
    		*phChannel = CC_INVALID_HANDLE;
    		LeaveCallControlTop(SaveStatus);
    	}

    	UnlockChannel(pChannel);
    	UnlockConference(pConference);
    	LeaveCallControlTop(CC_OK);
    }
#else  // GATEKEEPER
	// Open a logical channel for each established call
	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	if (pChannel->wNumOutstandingRequests == 0) {
		// all open channel requests failed
		FreeChannel(pChannel);
		UnlockConference(pConference);
		*phChannel = CC_INVALID_HANDLE;
		LeaveCallControlTop(SaveStatus);
	}

	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
#endif // GATEKEEPER

}



HRESULT CC_OpenT120Channel(			CC_HCONFERENCE			hConference,
                           			PCC_HCHANNEL			phChannel,
									BOOL					bAssociateConference,
									PCC_OCTETSTRING			pExternalReference,
									PCC_ADDR				pAddr,
									DWORD					dwChannelBitRate,
									DWORD_PTR				dwUserToken)
{
HRESULT			status;
PCALL			pCall;
PCONFERENCE		pConference;
PCHANNEL		pChannel;
H245_MUX_T		H245MuxTable;
CC_TERMCAP		TermCap;
H245_ACCESS_T	SeparateStack;
H245_ACCESS_T	*pSeparateStack;
BYTE			bSessionID;
WORD			wNumCalls;
PCC_HCALL		CallList;
HRESULT			SaveStatus;
int				i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	if (pAddr != NULL)
		if ((pAddr->nAddrType != CC_IP_BINARY) ||
            (pAddr->bMulticast == TRUE))
			LeaveCallControlTop(CC_BAD_PARAM);

	if (pExternalReference != NULL)
		if (pExternalReference->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Assume that T.120 channels are always opened with a session ID of 0
	bSessionID = 0;

	H245MuxTable.Kind = H245_H2250;
	H245MuxTable.u.H2250.nonStandardList = NULL;
	H245MuxTable.u.H2250.mediaChannelPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlChannelPresent = FALSE;
	H245MuxTable.u.H2250.dynamicRTPPayloadTypePresent = FALSE;
	H245MuxTable.u.H2250.sessionID = bSessionID;
	H245MuxTable.u.H2250.associatedSessionIDPresent = FALSE;
	H245MuxTable.u.H2250.mediaGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.mediaControlGuaranteedPresent = FALSE;
	H245MuxTable.u.H2250.silenceSuppressionPresent = FALSE;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		H245MuxTable.u.H2250.destinationPresent = FALSE;
	else {
		H245MuxTable.u.H2250.destinationPresent = TRUE;
		H245MuxTable.u.H2250.destination.mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		H245MuxTable.u.H2250.destination.terminalNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber;
	}
	H245MuxTable.u.H2250.h261aVideoPacketization = FALSE;

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_DATA;
	TermCap.ClientType = H245_CLIENT_DAT_T120;
	TermCap.CapId = 0;
	TermCap.Cap.H245Dat_T120.maxBitRate = dwChannelBitRate;
	TermCap.Cap.H245Dat_T120.application.choice = DACy_applctn_t120_chosen;
	TermCap.Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice = separateLANStack_chosen;

	if (pAddr != NULL) {
		SeparateStack.bit_mask = distribution_present;
		SeparateStack.distribution.choice = unicast_chosen;
		if (pExternalReference != NULL)	{
			SeparateStack.bit_mask |= externalReference_present;
			SeparateStack.externalReference.length = pExternalReference->wOctetStringLength;
			memcpy(SeparateStack.externalReference.value,
				   pExternalReference->pOctetString,
				   pExternalReference->wOctetStringLength);
		}
		SeparateStack.networkAddress.choice = localAreaAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.choice = unicastAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.choice = UnicastAddress_iPAddress_chosen;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.tsapIdentifier =
			pAddr->Addr.IP_Binary.wPort;
		SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.length = 4;
		HostToH245IPNetwork(SeparateStack.networkAddress.u.localAreaAddress.u.unicastAddress.u.UnicastAddress_iPAddress.network.value,
							pAddr->Addr.IP_Binary.dwAddr);
		SeparateStack.associateConference = (char) bAssociateConference;
		pSeparateStack = &SeparateStack;
	} else {
		pSeparateStack = NULL;
	}
	
    status = AllocAndLockChannel(phChannel,
						         pConference,
						         CC_INVALID_HANDLE,	// hCall
						         &TermCap,			// Tx term cap
						         &TermCap,			// Rx term cap
						         &H245MuxTable,		// Tx mux table
						         &H245MuxTable,		// Rx mux table
						         pSeparateStack,	// separate stack
						         dwUserToken,
						         TXRX_CHANNEL,
						         bSessionID,
						         0,					// associated session ID
						         0,					// remote channel
								 NULL,				// local RTP addr
						         NULL,				// local RTCP addr
						         NULL,				// peer RTP addr
						         NULL,				// peer RTCP addr
								 TRUE,				// locally opened
						         &pChannel);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	pChannel->tsAccepted = TS_TRUE;

	status = AddChannelToConference(pChannel, pConference);
	if (status != CC_OK) {
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245OpenChannel(pCall->H245Instance,		// H245 instance
									 pChannel->hChannel,		// dwTransId
									 pChannel->wLocalChannelNumber,
									 pChannel->pTxH245TermCap,	// TxMode
									 pChannel->pTxMuxTable,		// TxMux
									 H245_INVALID_PORT_NUMBER,	// TxPort
									 pChannel->pRxH245TermCap,	// RxMode
									 pChannel->pRxMuxTable,		// RxMux
									 pChannel->pSeparateStack);
			if (status == H245_ERROR_OK)
				(pChannel->wNumOutstandingRequests)++;
			else
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}
	MemFree(CallList);
	if (pChannel->wNumOutstandingRequests == 0) {
		// All open channel requests failed
		FreeChannel(pChannel);
		status = SaveStatus;
	} else {
		UnlockChannel(pChannel);
		status = CC_OK;
	}
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



HRESULT CC_Ping(					CC_HCALL				hCall,
									DWORD					dwTimeout)
{
PCALL			pCall;
HRESULT			status;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if ((pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	// Set the T105 timeout value as specified by the user;
	// note that the previous timeout value is returned in this parameter
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	status = H245RoundTripDelayRequest(pCall->H245Instance,
									   0); // dwTransId

	// Reset the T105 timeout value to its original setting
	H245SystemControl(0, H245_SYSCON_SET_FSM_T105, &dwTimeout);

	UnlockCall(pCall);
	LeaveCallControlTop(status);
}


	
CC_API
HRESULT CC_PlaceCall(				CC_HCONFERENCE			hConference,
									PCC_HCALL				phCall,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pCalleeAliasNames,
									PCC_ALIASNAMES			pCalleeExtraAliasNames,
									PCC_ALIASITEM			pCalleeExtension,
									PCC_NONSTANDARDDATA		pNonStandardData,
									PWSTR					pszDisplay,
									PCC_ADDR				pDestinationAddr,
									PCC_ADDR				pConnectAddr,
                                    DWORD                   dwBandwidth,
									DWORD_PTR				dwUserToken)
{
PCALL				pCall;
CC_HCALL            hCall;
PCONFERENCE			pConference;
HRESULT				status;
CALLTYPE			CallType = CALLER;
CALLSTATE			CallState = PLACED;
WORD				wNumCalls;
BOOL				bCallerIsMC;
GUID                CallIdent;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (phCall == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	// set hCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = Q931ValidateAliasNames(pLocalAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasNames(pCalleeExtraAliasNames);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = Q931ValidateAliasItem(pCalleeExtension);
	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateDisplay(pszDisplay);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pDestinationAddr == NULL) &&
		(pConnectAddr == NULL) &&
		(pCalleeAliasNames == NULL))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateAddr(pDestinationAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateAddr(pConnectAddr);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pDestinationAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = SetQ931Port(pConnectAddr);
 	if (status != CS_OK)
		LeaveCallControlTop(status);

	status = LockConferenceEx(hConference,
							  &pConference,
							  TS_FALSE);	// bDeferredDelete
	if (status != CC_OK)
		LeaveCallControlTop(status);

	EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);

	if (wNumCalls > 0) {
		if (pConference->tsMultipointController == TS_TRUE) {
			// Place Call directly to callee
			status = CC_OK;
			ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
			CallType = CALLER;
			CallState = PLACED;
		} else { // we're not the MC
			if (pConference->bMultipointCapable) {
				if (pConference->pMultipointControllerAddr != NULL) {
					// Place Call to MC
					status = CC_OK;
					if (pDestinationAddr == NULL)
						pDestinationAddr = pConnectAddr;
					pConnectAddr = pConference->pMultipointControllerAddr;
					ASSERT(!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
					CallType = THIRD_PARTY_INVITOR;
					CallState = PLACED;
				} else { // we don't have an MC address
					if (pConference->tsMaster == TS_UNKNOWN) {
						ASSERT(pConference->tsMultipointController == TS_UNKNOWN);
						status = CC_OK;
						CallType = CALLER;
						CallState = ENQUEUED;
					} else {
						ASSERT(pConference->tsMultipointController == TS_FALSE);
						// Error, no MC
						// XXX -- we may eventually want to enqueue the request
						// and set an expiration timer
						status = CC_NOT_MULTIPOINT_CAPABLE;
						CallType = THIRD_PARTY_INVITOR;
						CallState = ENQUEUED;
					}
				}
			} else { // we're not multipoint capable
				// Error - bad param
				ASSERT(wNumCalls == 1);
				status = CC_BAD_PARAM;
			}
		}
	} else { // wNumCalls == 0
		// Place Call directly to callee
		status = CC_OK;
		CallType = CALLER;
		CallState = PLACED;
	}
	
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (pConference->tsMultipointController == TS_TRUE)
		bCallerIsMC = TRUE;
	else
		bCallerIsMC = FALSE;


    // generate CallIdentifier
   	status = CoCreateGuid(&CallIdent);
    if(status != S_OK)
    {
        // forget what MSDN and other MS documentation says about this
        // -- If there is no net card, some rev's of OS return an error
        // in cases where a reasonable GUID is generated, but not GUARANTEED
        // to be GLOBALLY unique.
        // if that's not good enough, then just use the uninitialized
        // value of CallIdent - whatever was on the stack is our GUID!!
        // But I want to know in debug builds
        ASSERT(0);
    }
	status = AllocAndLockCall(&hCall,
							  hConference,
							  CC_INVALID_HANDLE,	// hQ931Call
							  CC_INVALID_HANDLE,	// hQ931CallInvitor
							  pLocalAliasNames,     // local alias names
							  pCalleeAliasNames,	// remote alias names
							  pCalleeExtraAliasNames,// remote extra alias names
							  pCalleeExtension,		// remote extension
							  pNonStandardData,		// local non-standard data
							  NULL,					// remote non-standard data
							  pszDisplay,			// local display
							  NULL,					// remote display
							  NULL,					// remote vendor info
							  NULL,					// local connect address
							  pConnectAddr,			// peer connect address
							  pDestinationAddr,		// peer destination address
                              NULL,                 // pSourceCallSignalAddress,
							  CallType,				// call type
							  bCallerIsMC,
							  dwUserToken,			// user token
							  CallState,			// call state
							  &CallIdent,           // H225 CallIdentifier
							  &pConference->ConferenceID,
							  &pCall);
	if (status != CC_OK) {
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	// Fill in Gatekeeper Call fields
    	memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));

    	if (pCalleeAliasNames != NULL) {
    		// make a local copy of the peer alias names
    		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeAliasNames, pCalleeAliasNames);
    		if (status != CS_OK) {
    			FreeCall(pCall);
    			UnlockConference(pConference);
    			LeaveCallControlTop(status);
    		}
    	}

    	if (pCalleeExtraAliasNames != NULL) {
    		// make a local copy of the peer alias names
    		status = Q931CopyAliasNames(&pCall->GkiCall.pCalleeExtraAliasNames,
    									pCalleeExtraAliasNames);
    		if (status != CS_OK) {
    			FreeCall(pCall);
    			UnlockConference(pConference);
    			LeaveCallControlTop(status);
    		}
    	}

    	pCall->GkiCall.pCall            = pCall;
    	pCall->GkiCall.hCall            = hCall;
        pCall->GkiCall.pConferenceId    = pCall->ConferenceID.buffer;
    	pCall->GkiCall.bActiveMC        = pCall->bCallerIsMC;
    	pCall->GkiCall.bAnswerCall      = FALSE;
   		pCall->GkiCall.CallIdentifier   = pCall->CallIdentifier;
   		
    	if (pCall->pQ931PeerConnectAddr) {
    		pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931PeerConnectAddr);
    		pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931PeerConnectAddr);
    	} else if (pCall->pQ931DestinationAddr) {
    		pCall->GkiCall.dwIpAddress = ADDRToInetAddr(pCall->pQ931DestinationAddr);
    		pCall->GkiCall.wPort       = ADDRToInetPort(pCall->pQ931DestinationAddr);
    	}
        if (pCall->GkiCall.wPort == 0)
            pCall->GkiCall.wPort = CC_H323_HOST_CALL;
    	pCall->GkiCall.wPort = (WORD)((pCall->GkiCall.wPort<<8)|(pCall->GkiCall.wPort>>8));

    	if (pConference->bMultipointCapable)
    		pCall->GkiCall.CallType = MANY_TO_MANY;
    	else
    		pCall->GkiCall.CallType = POINT_TO_POINT;
        pCall->GkiCall.uBandwidthRequested = dwBandwidth / 100;

    	status = GkiOpenCall(&pCall->GkiCall, pConference);
        if (ValidateCall(hCall) == CC_OK) {
            if (status == CC_OK) {
    		    UnlockCall(pCall);
                *phCall = hCall;
            } else {
    		    FreeCall(pCall);
            }
    	}

    	if (ValidateConference(hConference) == CC_OK)
    	    UnlockConference(pConference);
    }
    else
    {
        // clean GkiCall structure just to be safe.
        memset(&pCall->GkiCall, 0, sizeof(pCall->GkiCall));
    	status = PlaceCall(pCall, pConference);
    	if (status == CC_OK)
    	{
    		UnlockCall(pCall);
            *phCall = hCall;
    	}
    	else
    	{
    		FreeCall(pCall);
	    }
	    UnlockConference(pConference);
    }
#else  // GATEKEEPER
	status = PlaceCall(pCall, pConference);
	if (status == CC_OK) {
		UnlockCall(pCall);
        *phCall = hCall;
	} else {
		FreeCall(pCall);
	}

	UnlockConference(pConference);
#endif // GATEKEEPER

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RejectCall(				BYTE					bRejectReason,
									PCC_NONSTANDARDDATA		pNonStandardData,
									CC_HCALL				hCall)
{
HRESULT			status;
HRESULT			SaveStatus;
PCALL			pCall;
HQ931CALL		hQ931Call;
CC_CONFERENCEID	ConferenceID;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	SaveStatus = CC_OK;

	// validate parameters
	if ((bRejectReason != CC_REJECT_IN_CONF) &&
		(bRejectReason != CC_REJECT_UNDEFINED_REASON) &&
		(bRejectReason != CC_REJECT_DESTINATION_REJECTION) &&
		(bRejectReason != CC_REJECT_NO_ANSWER) &&
		(bRejectReason != CC_REJECT_NOT_IMPLEMENTED) &&
		(bRejectReason != CC_REJECT_SECURITY_DENIED) &&
		(bRejectReason != CC_REJECT_USER_BUSY)) {
		bRejectReason = CC_REJECT_UNDEFINED_REASON;
		SaveStatus = CC_BAD_PARAM;
	}

	status = ValidateNonStandardData(pNonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCall(hCall, &pCall);
	if (status != CC_OK)
		// note that we can't even tell Q931 to reject the call
		LeaveCallControlTop(status);

	if (pCall->CallState != INCOMING) {
		UnlockCall(pCall);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	FreeCall(pCall);
	Q931RejectCall(hQ931Call,			// Q931 call handle
				   bRejectReason,		// reject reason
				   &ConferenceID,
				   NULL,				// alternate address
				   pNonStandardData);	// non-standard data
	LeaveCallControlTop(SaveStatus);
}



CC_API
HRESULT CC_RejectChannel(			CC_HCHANNEL				hChannel,
									DWORD					dwRejectReason)

{
HRESULT		status;
PCHANNEL	pChannel;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if ((dwRejectReason != H245_REJ) &&
		(dwRejectReason != H245_REJ_TYPE_NOTSUPPORT) &&
		(dwRejectReason != H245_REJ_TYPE_NOTAVAIL) &&
		(dwRejectReason != H245_REJ_TYPE_UNKNOWN) &&
		(dwRejectReason != H245_REJ_AL_COMB) &&
		(dwRejectReason != H245_REJ_MULTICAST) &&
		(dwRejectReason != H245_REJ_SESSION_ID) &&
		(dwRejectReason != H245_REJ_MASTER_SLAVE_CONFLICT))
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	// Make sure that hChannel is a receive, proxy or bi-directional
	// channel that hasn't already been accepted
	if (((pChannel->bChannelType != RX_CHANNEL) &&
		 (pChannel->bChannelType != PROXY_CHANNEL) &&
		 (pChannel->bChannelType != TXRX_CHANNEL)) ||
		 (pChannel->tsAccepted != TS_UNKNOWN)) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	pChannel->tsAccepted = TS_FALSE;

	if (pChannel->wNumOutstandingRequests == 0) {
		ASSERT(pChannel->bMultipointChannel == TRUE);
		ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
		ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
		ASSERT(pConference->tsMultipointController == TS_TRUE);
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_OK);
	}

	(pChannel->wNumOutstandingRequests)--;

	if (pChannel->wNumOutstandingRequests == 0) {
		status = LockCall(pChannel->hCall, &pCall);
		if (status != CC_OK) {
			UnlockConference(pConference);
			FreeChannel(pChannel);
			LeaveCallControlTop(status);
		}

		status = H245OpenChannelReject(pCall->H245Instance,
									   pChannel->wRemoteChannelNumber,	// Rx channel
									   (WORD)dwRejectReason);			// rejection reason
		UnlockCall(pCall);
		FreeChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	// Don't free the channel; it is a PROXY_CHANNEL and we're the MC,
	// so we need to keep the channel object around until the peer that
	// opened it closes it.
	ASSERT(pChannel->bMultipointChannel == TRUE);
	ASSERT(pChannel->bChannelType == PROXY_CHANNEL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	UnlockChannel(pChannel);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestMode(				CC_HCALL				hCall,
									WORD					wNumModeDescriptions,
									ModeDescription			ModeDescriptions[])
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wNumModeDescriptions == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (ModeDescriptions == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245RequestMode(pCall->H245Instance,
							 pCall->H245Instance,	// trans ID
							 ModeDescriptions,
							 wNumModeDescriptions);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_RequestModeResponse(		CC_HCALL				hCall,
									CC_REQUEST_MODE_RESPONSE RequestModeResponse)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;
BOOL		bAccept;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	switch (RequestModeResponse) {
		case CC_WILL_TRANSMIT_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtMstPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_WILL_TRANSMIT_LESS_PREFERRED_MODE:
			RequestModeResponse = wllTrnsmtLssPrfrrdMd_chosen;
			bAccept = TRUE;
			break;
		case CC_MODE_UNAVAILABLE:
			RequestModeResponse = H245_REJ_UNAVAILABLE;
			bAccept = FALSE;
			break;
		case CC_MULTIPOINT_CONSTRAINT:
			RequestModeResponse = H245_REJ_MULTIPOINT;
			bAccept = FALSE;
			break;
		case CC_REQUEST_DENIED:
			RequestModeResponse = H245_REJ_DENIED;
			bAccept = FALSE;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = DequeueSpecificRequest(&pConference->pEnqueuedRequestModeCalls,
									hCall);
	if (status != CC_OK) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(status);
	}

	if (bAccept == TRUE) {
		status = H245RequestModeAck(pCall->H245Instance,
									(WORD)RequestModeResponse);
	} else {
		status = H245RequestModeReject(pCall->H245Instance,
									   (WORD)RequestModeResponse);
	}

	UnlockCall(pCall);
	UnlockConference(pConference);
	
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendNonStandardMessage(	CC_HCALL				hCall,
									BYTE					bH245MessageType,
									CC_NONSTANDARDDATA		NonStandardData)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
H245_MESSAGE_TYPE_T		H245MessageType;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	switch (bH245MessageType) {
		case CC_H245_MESSAGE_REQUEST:
			H245MessageType = H245_MESSAGE_REQUEST;
			break;
		case CC_H245_MESSAGE_RESPONSE:
			H245MessageType = H245_MESSAGE_RESPONSE;
			break;
		case CC_H245_MESSAGE_COMMAND:
			H245MessageType = H245_MESSAGE_COMMAND;
			break;
		case CC_H245_MESSAGE_INDICATION:
			H245MessageType = H245_MESSAGE_INDICATION;
			break;
		default:
			LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = ValidateNonStandardData(&NonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245NonStandardH221(pCall->H245Instance,
								 H245MessageType,
								 NonStandardData.sData.pOctetString,
								 NonStandardData.sData.wOctetStringLength,
								 NonStandardData.bCountryCode,
								 NonStandardData.bExtension,
								 NonStandardData.wManufacturerCode);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SendVendorID(			CC_HCALL				hCall,
									CC_NONSTANDARDDATA		NonStandardData,
									PCC_OCTETSTRING			pProductNumber,
									PCC_OCTETSTRING			pVersionNumber)
{
HRESULT					status;
PCALL					pCall;
PCONFERENCE				pConference;
BYTE					*pH245ProductNumber;
BYTE					bProductNumberLength;
BYTE					*pH245VersionNumber;
BYTE					bVersionNumberLength;
H245_NONSTANDID_T		H245Identifier;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateNonStandardData(&NonStandardData);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = ValidateOctetString(pProductNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pProductNumber != NULL)
		if (pProductNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = ValidateOctetString(pVersionNumber);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pVersionNumber != NULL)
		if (pVersionNumber->wOctetStringLength > 255)
			LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall,
								   &pCall,
								   &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	H245Identifier.choice = h221NonStandard_chosen;
	H245Identifier.u.h221NonStandard.t35CountryCode = NonStandardData.bCountryCode;
	H245Identifier.u.h221NonStandard.t35Extension = NonStandardData.bExtension;
	H245Identifier.u.h221NonStandard.manufacturerCode = NonStandardData.wManufacturerCode;

	if (pProductNumber == NULL) {
		pH245ProductNumber = NULL;
		bProductNumberLength = 0;
	} else {
		pH245ProductNumber = pProductNumber->pOctetString;
		bProductNumberLength = (BYTE)pProductNumber->wOctetStringLength;
	}

	if (pVersionNumber == NULL) {
		pH245VersionNumber = NULL;
		bVersionNumberLength = 0;
	} else {
		pH245VersionNumber = pVersionNumber->pOctetString;
		bVersionNumberLength = (BYTE)pVersionNumber->wOctetStringLength;
	}

	status = H245VendorIdentification(pCall->H245Instance,
									  &H245Identifier,
									  pH245ProductNumber,
									  bProductNumberLength,
									  pH245VersionNumber,
									  bVersionNumberLength);

	UnlockCall(pCall);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetCallControlTimeout(	WORD					wType,
									DWORD					dwDuration)
{
HRESULT	status;
DWORD	dwRequest;
DWORD	dwSaveDuration;

	EnterCallControlTop();

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	status = CC_OK;

	switch (wType) {
		case CC_Q931_ALERTING_TIMEOUT:
			status = Q931SetAlertingTimeout(dwDuration);
			break;
		case CC_H245_RETRY_COUNT:
			status = H245SystemControl(0, H245_SYSCON_SET_FSM_N100, &dwDuration);
			break;
		case CC_H245_TIMEOUT:
			dwRequest = H245_SYSCON_SET_FSM_T101;
			dwSaveDuration = dwDuration;
			while ((dwRequest <= H245_SYSCON_SET_FSM_T109) && (status == CC_OK)) {
				dwDuration = dwSaveDuration;
				// Note -- the following call resets dwDuration
				status = H245SystemControl(0, dwRequest, &dwDuration);
				dwRequest += (H245_SYSCON_SET_FSM_T102 - H245_SYSCON_SET_FSM_T101);
			}
			break;
		default :
			LeaveCallControlTop(CC_BAD_PARAM);
			break;
	}

	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_SetTerminalID(			CC_HCONFERENCE			hConference,
									PCC_OCTETSTRING			pTerminalID)
{
HRESULT		status;
PCONFERENCE	pConference;
CC_HCALL	hCall;
PCALL		pCall;

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	// validate parameters
	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);
	
	status = ValidateTerminalID(pTerminalID);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);
	
	if (pConference->LocalParticipantInfo.TerminalIDState == TERMINAL_ID_VALID) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}

	if ((pTerminalID == NULL) ||
		(pTerminalID->pOctetString == NULL) ||
		(pTerminalID->wOctetStringLength == 0)) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_OK);
	}

	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
		(BYTE *)MemAlloc(pTerminalID->wOctetStringLength);
	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
		UnlockConference(pConference);
 		LeaveCallControlTop(CC_NO_MEMORY);
	}

	memcpy(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
		   pTerminalID->pOctetString,
		   pTerminalID->wOctetStringLength);
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
		pTerminalID->wOctetStringLength;
	pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;

	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID,
						  &hCall) == CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK) {
   			H245ConferenceResponse(pCall->H245Instance,
								   H245_RSP_TERMINAL_ID,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber,
								   pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
								   (BYTE)pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength,
								   NULL,					// terminal list
								   0);						// terminal list count
			UnlockCall(pCall);
		}
	}

	UnlockConference(pConference);
	LeaveCallControlTop(CC_OK);
}



CC_API
HRESULT CC_Shutdown()
{

	if (InitStatus != CC_OK)
		return InitStatus;
	if (CallControlState != OPERATIONAL_STATE)
		return CC_BAD_PARAM;
		
	// Don't allow any additional threads to enter this DLL
	CallControlState = SHUTDOWN_STATE;

	Q931DeInit();
	DeInitHangupManager();
	DeInitUserManager();
	DeInitQ931Manager();
	DeInitListenManager();
	DeInitH245Manager();
	DeInitChannelManager();
	DeInitCallManager();
	DeInitConferenceManager();
#ifdef    GATEKEEPER
	DeInitGkiManager();
#endif // GATEKEEPER
  	H225DeInit();
#ifdef FORCE_SERIALIZE_CALL_CONTROL	
    UnInitializeCCLock();
#endif
	return CC_OK;
}



CC_API
HRESULT CC_UnMute(					CC_HCHANNEL				hChannel)
{
HRESULT		status;
HRESULT		SaveStatus;
PCHANNEL	pChannel;
PCONFERENCE	pConference;
PCALL		pCall;
PDU_T		Pdu;
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hChannel == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockChannelAndConference(hChannel, &pChannel, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if (pChannel->bChannelType != TX_CHANNEL) {
		// can only unmute transmit channels
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->LocalEndpointAttached != ATTACHED) {
		UnlockChannel(pChannel);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (status != CC_OK) {
		UnlockConference(pConference);
		UnlockChannel(pChannel);
		LeaveCallControlTop(status);
	}

	// Construct an H.245 PDU to hold a miscellaneous indication
	// of "logical channel active"
	Pdu.choice = indication_chosen;
	Pdu.u.indication.choice = miscellaneousIndication_chosen;
	Pdu.u.indication.u.miscellaneousIndication.logicalChannelNumber =
		pChannel->wLocalChannelNumber;
	Pdu.u.indication.u.miscellaneousIndication.type.choice = logicalChannelActive_chosen;

	SaveStatus = CC_OK;
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			status = H245SendPDU(pCall->H245Instance,	// H245 instance
								 &Pdu);
			// Note that this channel may not have been accepted on all of the calls,
			// so we could get an H245_ERROR_INVALID_CHANNEL error
			if ((status != H245_ERROR_OK) && (status != H245_ERROR_INVALID_CHANNEL))
				SaveStatus = status;
			UnlockCall(pCall);
		}
	}

	if (CallList != NULL)
		MemFree(CallList);

	UnlockConference(pConference);
	UnlockChannel(pChannel);
	LeaveCallControlTop(SaveStatus);
}


CC_API
HRESULT CC_UpdatePeerList(			CC_HCONFERENCE			hConference)
{
HRESULT						status;
PCONFERENCE					pConference;
PCALL						pCall;
WORD						wNumCalls;
WORD						i;
PCC_HCALL					CallList;
CC_PEER_ADD_CALLBACK_PARAMS	PeerAddCallbackParams;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hConference == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->ConferenceMode != MULTIPOINT_MODE) ||
		(pConference->LocalEndpointAttached != ATTACHED)) {
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	if (pConference->tsMultipointController == TS_TRUE) {
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				if (pCall->pPeerParticipantInfo != NULL) {
					PeerAddCallbackParams.hCall = pCall->hCall;
					PeerAddCallbackParams.TerminalLabel =
						pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
					if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
						PeerAddCallbackParams.pPeerTerminalID =
							&pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
					else
						PeerAddCallbackParams.pPeerTerminalID = NULL;
					InvokeUserConferenceCallback(pConference,
												 CC_PEER_ADD_INDICATION,
												 CC_OK,
												 &PeerAddCallbackParams);
					if (ValidateCall(CallList[i]) == CC_OK)
						UnlockCall(pCall);
					if (ValidateConference(hConference) != CC_OK) {
						MemFree(CallList);
						LeaveCallControlTop(CC_OK);
					}
				} else // pCall->pPeerParticipantInfo == NULL
					UnlockCall(pCall);
			}
		}
		status = CC_OK;
	} else { // pConference->tsMultipointController != TS_TRUE
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
		for (i = 0; i < wNumCalls; i++) {
			if (LockCall(CallList[i], &pCall) == CC_OK) {
				FreeCall(pCall);
			}
		}
		if (CallList != NULL)
			MemFree(CallList);
		EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
		ASSERT((wNumCalls == 0) || (wNumCalls == 1));
		if (wNumCalls == 1) {
			if (LockCall(CallList[0], &pCall) == CC_OK) {
				// Send TerminalListRequest
				status = H245ConferenceRequest(pCall->H245Instance,
									  H245_REQ_TERMINAL_LIST,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber,
									  pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber);
				UnlockCall(pCall);
			}
		}
	}

	if (CallList != NULL)
		MemFree(CallList);
	UnlockConference(pConference);
	LeaveCallControlTop(status);
}



CC_API
HRESULT CC_UserInput(				CC_HCALL				hCall,
									PWSTR					pszUserInput)
{
HRESULT		status;
PCALL		pCall;
PCONFERENCE	pConference;

	EnterCallControlTop();

	if (InitStatus != CC_OK)
		LeaveCallControlTop(InitStatus);

	if (CallControlState != OPERATIONAL_STATE)
		LeaveCallControlTop(CC_INTERNAL_ERROR);

	if (hCall == CC_INVALID_HANDLE)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (pszUserInput == NULL)
		LeaveCallControlTop(CC_BAD_PARAM);

	if (wcslen(pszUserInput) == 0)
		LeaveCallControlTop(CC_BAD_PARAM);

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		LeaveCallControlTop(status);

	if ((pConference->LocalEndpointAttached != ATTACHED) ||
		(pCall->CallState != CALL_COMPLETE) ||
		(pCall->CallType == VIRTUAL_CALL)) {
		UnlockCall(pCall);
		UnlockConference(pConference);
		LeaveCallControlTop(CC_BAD_PARAM);
	}

	status = H245UserInput(pCall->H245Instance,
						   pszUserInput,
						   NULL);

	UnlockCall(pCall);
	UnlockConference(pConference);

	LeaveCallControlTop(status);
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callcont.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/callcont.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.102  $
 *      $Date:   13 Feb 1997 21:28:38  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CALLCONT_H
#define CALLCONT_H

#include "iras.h"

#if defined(CALL_CONTROL_EXPORT)
#define CC_API __declspec (dllexport)
#else // CALL_CONTROL_IMPORT
#define CC_API __declspec (dllimport)
#endif

#pragma pack(push,8)

#ifndef H245API_H
#include "h245api.h"
#endif H245API_H

#ifndef CCERROR_H
#include "ccerror.h"
#endif  CCERROR_H

#ifdef __cplusplus
extern "C" {
#endif

// Indication codes
#define CC_RINGING_INDICATION						1
#define CC_CONNECT_INDICATION						2
#define CC_TX_CHANNEL_OPEN_INDICATION				3
#define CC_RX_CHANNEL_REQUEST_INDICATION			4
#define CC_RX_CHANNEL_CLOSE_INDICATION				5
#define CC_MUTE_INDICATION							6
#define CC_UNMUTE_INDICATION						7
#define CC_PEER_ADD_INDICATION						8
#define CC_PEER_DROP_INDICATION						9
#define CC_PEER_CHANGE_CAP_INDICATION				10
#define CC_CONFERENCE_TERMINATION_INDICATION		11
#define CC_HANGUP_INDICATION						12
#define CC_RX_NONSTANDARD_MESSAGE_INDICATION		13
#define CC_MULTIPOINT_INDICATION					14
#define CC_PEER_UPDATE_INDICATION					15
#define CC_H245_MISCELLANEOUS_COMMAND_INDICATION	16
#define CC_H245_MISCELLANEOUS_INDICATION_INDICATION	17
#define CC_H245_CONFERENCE_REQUEST_INDICATION		18
#define CC_H245_CONFERENCE_RESPONSE_INDICATION		19
#define CC_H245_CONFERENCE_COMMAND_INDICATION		20
#define CC_H245_CONFERENCE_INDICATION_INDICATION	21
#define CC_FLOW_CONTROL_INDICATION					22
#define CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION		23
#define CC_REQUEST_MODE_INDICATION					24
#define CC_REQUEST_MODE_RESPONSE_INDICATION			25
#define CC_VENDOR_ID_INDICATION						26
#define CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION		27
#define CC_T120_CHANNEL_REQUEST_INDICATION			28
#define CC_T120_CHANNEL_OPEN_INDICATION				29
#define CC_BANDWIDTH_CHANGED_INDICATION             30
#define CC_ACCEPT_CHANNEL_INDICATION                31
#define CC_TERMINAL_ID_REQUEST_INDICATION           32
#define CC_PING_RESPONSE_INDICATION					33
#define CC_TERMINAL_NUMBER_INDICATION               34

// Conference configuration values; these are bit mask values
#define CC_CONFIGURE_MULTIPOINT_CAPABLE				0x0001
#define CC_CONFIGURE_FORCE_MC						0x0002

// Timeout type codes
#define CC_Q931_ALERTING_TIMEOUT					1
#define CC_H245_RETRY_COUNT							2
#define CC_H245_TIMEOUT								3

// Conference termination reasons
#define CC_PEER_HANGUP								0
#define CC_GATEKEEPER_HANGUP						1

typedef enum {
	CC_WILL_TRANSMIT_PREFERRED_MODE,
	CC_WILL_TRANSMIT_LESS_PREFERRED_MODE,
	CC_MODE_UNAVAILABLE,
	CC_MULTIPOINT_CONSTRAINT,
	CC_REQUEST_DENIED
} CC_REQUEST_MODE_RESPONSE;

typedef H245_TOTCAP_T   CC_TERMCAP, *PCC_TERMCAP, **PPCC_TERMCAP;

typedef struct {
	WORD					wLength;
	PPCC_TERMCAP			pTermCapArray;
} CC_TERMCAPLIST, *PCC_TERMCAPLIST;

typedef struct {
	WORD					wLength;
	H245_TOTCAPDESC_T		**pTermCapDescriptorArray;
} CC_TERMCAPDESCRIPTORS, *PCC_TERMCAPDESCRIPTORS;

typedef struct {
	BYTE					bMCUNumber;
	BYTE					bTerminalNumber;
} CC_TERMINAL_LABEL, *PCC_TERMINAL_LABEL;

typedef struct {
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_OCTETSTRING			TerminalID;
} CC_PARTICIPANTINFO, *PCC_PARTICIPANTINFO;

typedef struct {
	WORD					wLength;
	PCC_PARTICIPANTINFO		ParticipantInfoArray;
} CC_PARTICIPANTLIST, *PCC_PARTICIPANTLIST;

typedef struct
{
	BOOL					bMaster;
	BOOL					bMultipointController;
	BOOL					bMultipointConference;
	CC_CONFERENCEID			ConferenceID;
	CC_TERMINAL_LABEL		LocalTerminalLabel;
	WORD					wNumCalls;
	PCC_PARTICIPANTLIST		pParticipantList;
	DWORD_PTR				dwConferenceToken;
    DWORD                   dwBandwidthAllocated;
    DWORD                   dwBandwidthUsed;
} CC_CONFERENCEATTRIBUTES, *PCC_CONFERENCEATTRIBUTES;

typedef struct {
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	CC_OCTETSTRING			SessionDescription;
	PCC_TERMCAP				pTermCap;
	PCC_ADDR				pRTPAddr;
	PCC_ADDR				pRTCPAddr;
} CC_SESSIONINFO, *PCC_SESSIONINFO;

typedef struct {
	WORD					wLength;
	PCC_SESSIONINFO			SessionInfoArray;
} CC_SESSIONTABLE, *PCC_SESSIONTABLE;

typedef struct
{
	CC_HCALL				hCall;
	PCC_ALIASNAMES			pCallerAliasNames;
	PCC_ALIASNAMES			pCalleeAliasNames;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszDisplay;
	PCC_VENDORINFO			pVendorInfo;
	WORD					wGoal;
	CC_CONFERENCEID			ConferenceID;
	PCC_ADDR				pCallerAddr;
	PCC_ADDR				pCalleeAddr;
	DWORD_PTR				dwListenToken;
} CC_LISTEN_CALLBACK_PARAMS, *PCC_LISTEN_CALLBACK_PARAMS;

typedef void *  PCC_CONFERENCE_CALLBACK_PARAMS;


// CC_RINGING_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	DWORD_PTR				dwUserToken;
} CC_RINGING_CALLBACK_PARAMS, *PCC_RINGING_CALLBACK_PARAMS;

// CC_CONNECT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_NONSTANDARDDATA		pNonStandardData;
	PWSTR					pszPeerDisplay;
	BYTE					bRejectReason;
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
	PCC_ADDR				pLocalAddr;
	PCC_ADDR				pPeerAddr;
	PCC_VENDORINFO			pVendorInfo;
	BOOL					bMultipointConference;
	PCC_CONFERENCEID		pConferenceID;
	PCC_ADDR				pMCAddress;
	PCC_ADDR				pAlternateAddress;
	DWORD_PTR				dwUserToken;
} CC_CONNECT_CALLBACK_PARAMS, *PCC_CONNECT_CALLBACK_PARAMS;

// CC_TX_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD					dwRejectReason;
	DWORD_PTR				dwUserToken;
} CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_TX_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_RX_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
	PCC_TERMCAP				pChannelCapability;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	PCC_ADDR	            pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	BYTE					bRTPPayloadType;
	BOOL					bSilenceSuppression;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_RX_CHANNEL_REQUEST_CALLBACK_PARAMS;

// CC_RX_CHANNEL_CLOSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS, *PCC_RX_CHANNEL_CLOSE_CALLBACK_PARAMS;

// CC_MUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_MUTE_CALLBACK_PARAMS, *PCC_MUTE_CALLBACK_PARAMS;

// CC_UNMUTE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_UNMUTE_CALLBACK_PARAMS, *PCC_UNMUTE_CALLBACK_PARAMS;

// CC_PEER_ADD_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_ADD_CALLBACK_PARAMS, *PCC_PEER_ADD_CALLBACK_PARAMS;

// CC_PEER_DROP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_DROP_CALLBACK_PARAMS, *PCC_PEER_DROP_CALLBACK_PARAMS;

// CC_PEER_CHANGE_CAP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	PCC_TERMCAPLIST			pTermCapList;
	PCC_TERMCAP				pH2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;
} CC_PEER_CHANGE_CAP_CALLBACK_PARAMS, *PCC_PEER_CHANGE_CAP_CALLBACK_PARAMS;

// CC_CONFERENCE_TERMINATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	DWORD					dwReason;
} CC_CONFERENCE_TERMINATION_CALLBACK_PARAMS, *PCC_CONFERENCE_TERMINATION_CALLBACK_PARAMS;

// CC_HANGUP_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	DWORD_PTR				dwUserToken;
} CC_HANGUP_CALLBACK_PARAMS, *PCC_HANGUP_CALLBACK_PARAMS;

// CC_RX_NONSTANDARD_MESSAGE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	BYTE					bH245MessageType;
	CC_NONSTANDARDDATA		NonStandardData;
} CC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS, *PCC_RX_NONSTANDARD_MESSAGE_CALLBACK_PARAMS;

// CC_MULTIPOINT_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	PCC_PARTICIPANTINFO		pTerminalInfo;
	PCC_SESSIONTABLE		pSessionTable;
} CC_MULTIPOINT_CALLBACK_PARAMS, *PCC_MULTIPOINT_CALLBACK_PARAMS;

// CC_PEER_UPDATE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pPeerTerminalID;
} CC_PEER_UPDATE_CALLBACK_PARAMS, *PCC_PEER_UPDATE_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	BOOL					bH323ActionRequired;
	MiscellaneousCommand	*pMiscellaneousCommand;
} CC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_COMMAND_CALLBACK_PARAMS;

// CC_H245_MISCELLANEOUS_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	MiscellaneousIndication	*pMiscellaneousIndication;
} CC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS, *PCC_H245_MISCELLANEOUS_INDICATION_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_REQ_ENUM_T	RequestType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_REQUEST_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_RSP_ENUM_T	ResponseType;
	CC_TERMINAL_LABEL		TerminalLabel;
	PCC_OCTETSTRING			pOctetString;
	CC_TERMINAL_LABEL		*pTerminalList;
	WORD					wTerminalListCount;
} CC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_RESPONSE_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_COMMAND_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	CC_HCHANNEL				hChannel;
	H245_CONFER_CMD_ENUM_T	CommandType;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_COMMAND_CALLBACK_PARAMS;

// CC_H245_CONFERENCE_INDICATION_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	H245_CONFER_IND_ENUM_T	IndicationType;
	BYTE					bSBENumber;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS, *PCC_H245_CONFERENCE_INDICATION_CALLBACK_PARAMS;

// CC_FLOW_CONTROL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	DWORD					dwRate;
} CC_FLOW_CONTROL_CALLBACK_PARAMS, *PCC_FLOW_CONTROL_CALLBACK_PARAMS;

// CC_TX_CHANNEL_CLOSE_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
} CC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS, *PCC_TX_CHANNEL_CLOSE_REQUEST_CALLBACK_PARAMS;

// CC_REQUEST_MODE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	RequestedModesLink		pRequestedModes;
} CC_REQUEST_MODE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_CALLBACK_PARAMS;

// CC_REQUEST_MODE_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	CC_REQUEST_MODE_RESPONSE RequestModeResponse;
} CC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS, *PCC_REQUEST_MODE_RESPONSE_CALLBACK_PARAMS;

// CC_VENDOR_ID_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		InitiatorTerminalLabel;
	PCC_NONSTANDARDDATA		pNonStandardData;
	PCC_OCTETSTRING			pProductNumber;
	PCC_OCTETSTRING			pVersionNumber;
} CC_VENDOR_ID_CALLBACK_PARAMS, *PCC_VENDOR_ID_CALLBACK_PARAMS;

// CC_MAXIMUM_AUDIO_VIDEO_SKEW_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel1;
	CC_HCHANNEL				hChannel2;
	WORD					wMaximumSkew;
} CC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS, *PCC_MAXIMUM_AUDIO_VIDEO_SKEW_CALLBACK_PARAMS;

// CC_T120_CHANNEL_OPEN_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	CC_HCALL				hCall;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	DWORD					dwRejectReason;
	DWORD_PTR				dwUserToken;
} CC_T120_CHANNEL_OPEN_CALLBACK_PARAMS, *PCC_T120_CHANNEL_OPEN_CALLBACK_PARAMS;

// CC_T120_CHANNEL_REQUEST_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct {
	CC_HCHANNEL				hChannel;
	BOOL					bAssociateConference;
	PCC_OCTETSTRING			pExternalReference;
	PCC_ADDR				pAddr;
	BOOL					bMultipointController;
	CC_TERMINAL_LABEL		TerminalLabel;
} CC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS, *PCC_T120_CHANNEL_REQUEST_CALLBACK_PARAMS;

typedef struct {
	CC_HCALL	            hCall;
	DWORD		            dwBandwidthTotal;
    long                    lBandwidthChange;
} CC_BANDWIDTH_CALLBACK_PARAMS, *PCC_BANDWIDTH_CALLBACK_PARAMS;

// CC_ACCEPT_CHANNEL_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCHANNEL             hChannel;
} CC_ACCEPT_CHANNEL_CALLBACK_PARAMS, *PCC_ACCEPT_CHANNEL_CALLBACK_PARAMS;

// CC_PING_RESPONSE_INDICATION callback parameters (pConferenceCallbackParams)
typedef struct
{
	CC_HCALL				hCall;
	CC_TERMINAL_LABEL		TerminalLabel;
	BOOL					bResponse;
} CC_PING_RESPONSE_CALLBACK_PARAMS, *PCC_PING_RESPONSE_CALLBACK_PARAMS;

#ifndef NO_APIS

typedef void (*CC_LISTEN_CALLBACK)(		HRESULT							hStatus,
										PCC_LISTEN_CALLBACK_PARAMS		ListenCallbackParams);

typedef HRESULT (*CC_CONFERENCE_CALLBACK)(
										BYTE							bIndication,
										HRESULT							hStatus,
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										PCC_CONFERENCE_CALLBACK_PARAMS	pConferenceCallbackParams);

typedef HRESULT (*CC_SESSIONTABLE_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbSessionTableChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors[],
										PCC_SESSIONTABLE				*ppSessionTable);

typedef HRESULT (*CC_TERMCAP_CONSTRUCTOR)(
										CC_HCONFERENCE					hConference,
										DWORD_PTR						dwConferenceToken,
										BOOL							bCreate,
										BOOL							*pbTermCapsChanged,
										WORD							wListCount,
										PCC_TERMCAPLIST					pInTermCapList[],
										PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
										PCC_TERMCAPLIST					*ppOutTermCapList,
										PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

CC_API
HRESULT CC_AcceptCall(					CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_ACCEPTCALL)(		CC_HCONFERENCE					hConference,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										CC_HCALL						hCall,
                                        DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_AcceptChannel(				CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);
									
typedef HRESULT (*CC_ACCEPTCHANNEL) (	CC_HCHANNEL						hChannel,
										PCC_ADDR						pRTPAddr,
										PCC_ADDR						pRTCPAddr,
										DWORD							dwChannelBitRate);

CC_API
HRESULT CC_AcceptT120Channel(			CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
typedef HRESULT (*CC_ACCEPTT120CHANNEL)(CC_HCHANNEL						hChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr);
									
CC_API
HRESULT CC_CallListen(					PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD_PTR						dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);

typedef HRESULT (*CC_CALLLISTEN)(		PCC_HLISTEN						phListen,
										PCC_ADDR						pListenAddr,
										PCC_ALIASNAMES					pLocalAliasNames,
										DWORD_PTR						dwListenToken,
										CC_LISTEN_CALLBACK				ListenCallback);


CC_API
HRESULT CC_CancelCall(					CC_HCALL						hCall);

typedef HRESULT (*CC_CANCELCALL)(		CC_HCALL						hCall);


CC_API
HRESULT CC_CancelListen(				CC_HLISTEN						hListen);

typedef HRESULT (*CC_CANCELLISTEN)(		CC_HLISTEN						hListen);

CC_API
HRESULT CC_ChangeConferenceCapabilities(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

typedef HRESULT (*CC_CHANGECONFERENCECAPABILITIES)(
										CC_HCONFERENCE					hConference,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors);

CC_API
HRESULT CC_CloseChannel(				CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_CLOSECHANNEL)(		CC_HCHANNEL						hChannel);


CC_API
HRESULT CC_CloseChannelResponse(		CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

typedef HRESULT (*CC_CLOSECHANNELRESPONSE)(
										CC_HCHANNEL						hChannel,
										BOOL							bWillCloseChannel);

CC_API
HRESULT CC_CreateConference(			PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD_PTR						dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

typedef HRESULT	(*CC_CREATECONFERENCE) (PCC_HCONFERENCE					phConference,
										PCC_CONFERENCEID				pConferenceID,
										DWORD							dwConferenceConfiguration,
										PCC_TERMCAPLIST					pTermCapList,
										PCC_TERMCAPDESCRIPTORS			pTermCapDescriptors,
										PCC_VENDORINFO					pVendorInfo,
										PCC_OCTETSTRING					pTerminalID,
										DWORD_PTR						dwConferenceToken,
										CC_TERMCAP_CONSTRUCTOR			TermCapConstructor,
										CC_SESSIONTABLE_CONSTRUCTOR		SessionTableConstructor,
										CC_CONFERENCE_CALLBACK			ConferenceCallback);

CC_API
HRESULT CC_DestroyConference(			CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

typedef HRESULT (*CC_DESTROYCONFERENCE)(CC_HCONFERENCE					hConference,
										BOOL							bAutoAccept);

CC_API
HRESULT CC_EnumerateConferences(		PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

typedef HRESULT (*CC_ENUMERATECONFERENCES)(
										PWORD							pwNumConferences,
										CC_HCONFERENCE					ConferenceList[]);

CC_API
HRESULT CC_FlowControl(					CC_HCHANNEL						hChannel,
										DWORD							dwRate);

typedef HRESULT (*CC_FLOWCONTROL)(		CC_HCHANNEL						hChannel,
										DWORD							dwRate);

CC_API
HRESULT CC_GetCallControlVersion(		WORD							wArraySize,
										PWSTR							pszVersion);

typedef HRESULT (*CC_GETCALLCONTROLVERSION)
									   (WORD							wArraySize,
										PWSTR							pszVersion);

CC_API
HRESULT CC_GetConferenceAttributes(		CC_HCONFERENCE					hConference,
										PCC_CONFERENCEATTRIBUTES		pConferenceAttributes);

typedef HRESULT (*CC_GETCONFERENCEATTRIBUTES)
									   (CC_HCONFERENCE                  hConference,
									    PCC_CONFERENCEATTRIBUTES        pConferenceAttributes);

CC_API
HRESULT CC_H245ConferenceRequest(		CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEREQUEST)(
										CC_HCALL						hCall,
										H245_CONFER_REQ_ENUM_T			RequestType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceResponse(		CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

typedef HRESULT (*CC_H245CONFERENCERESPONSE)(
										CC_HCALL						hCall,
										H245_CONFER_RSP_ENUM_T			ResponseType,
										CC_TERMINAL_LABEL				TerminalLabel,
										PCC_OCTETSTRING					pOctetString,
										CC_TERMINAL_LABEL				*pTerminalList,
										WORD							wTerminalListCount);

CC_API
HRESULT CC_H245ConferenceCommand(		CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCECOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										H245_CONFER_CMD_ENUM_T			CommandType,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245ConferenceIndication(	CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

typedef HRESULT (*CC_H245CONFERENCEINDICATION)(
										CC_HCALL						hCall,
										H245_CONFER_IND_ENUM_T			IndicationType,
										BYTE							bSBENumber,
										CC_TERMINAL_LABEL				TerminalLabel);

CC_API
HRESULT CC_H245MiscellaneousCommand(	CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

typedef HRESULT (*CC_H245MISCELLANEOUSCOMMAND)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousCommand			*pMiscellaneousCommand);

CC_API
HRESULT CC_H245MiscellaneousIndication(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

typedef HRESULT (*CC_H245MISCELLANEOUSINDICATION)(
										CC_HCALL						hCall,
										CC_HCHANNEL						hChannel,
										MiscellaneousIndication			*pMiscellaneousIndication);

CC_API
HRESULT CC_Hangup(						CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD_PTR   					dwUserToken);

typedef HRESULT (*CC_HANGUP)(			CC_HCONFERENCE					hConference,
										BOOL							bTerminateConference,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_MaximumAudioVideoSkew(		CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

typedef HRESULT (*CC_MAXIMUMAUDIOVIDEOSKEW)(
										CC_HCHANNEL						hChannelAudio,
										CC_HCHANNEL						hChannelVideo,
										WORD							wMaximumSkew);

CC_API
HRESULT CC_Mute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_MUTE)(				CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_OpenChannel(					CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_OPENCHANNEL)(		CC_HCONFERENCE					hConference,
										PCC_HCHANNEL					phChannel,
										BYTE							bSessionID,
										BYTE							bAssociatedSessionID,
										BOOL							bSilenceSuppression,
										PCC_TERMCAP						pTermCap,
										PCC_ADDR						pLocalRTCPAddr,
										BYTE							bDynamicRTPPayloadType,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_OpenT120Channel(				CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_OPENT120CHANNEL)(	CC_HCONFERENCE					hConference,
                                        PCC_HCHANNEL                    phChannel,
										BOOL							bAssociateConference,
										PCC_OCTETSTRING					pExternalReference,
										PCC_ADDR						pAddr,
										DWORD							dwChannelBitRate,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_Ping(						CC_HCALL						hCall,
										DWORD							dwTimeout);

typedef HRESULT (*CC_PING)(				CC_HCALL						hCall,
										DWORD							dwTimeout);

CC_API
HRESULT CC_PlaceCall(					CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

typedef HRESULT (*CC_PLACECALL)(		CC_HCONFERENCE					hConference,
										PCC_HCALL						phCall,
										PCC_ALIASNAMES					pLocalAliasNames,
										PCC_ALIASNAMES					pCalleeAliasNames,
										PCC_ALIASNAMES					pCalleeExtraAliasNames,
										PCC_ALIASITEM					pCalleeExtension,
										PCC_NONSTANDARDDATA				pNonStandardData,
										PWSTR							pszDisplay,
										PCC_ADDR						pDestinationAddr,
										PCC_ADDR						pConnectAddr,
										DWORD                           dwBandwidth,
										DWORD_PTR						dwUserToken);

CC_API
HRESULT CC_RejectCall(					BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

typedef HRESULT (*CC_REJECTCALL)(		BYTE							bRejectReason,
										PCC_NONSTANDARDDATA				pNonStandardData,
										CC_HCALL						hCall);

CC_API
HRESULT CC_RejectChannel(				CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

typedef HRESULT (*CC_REJECTCHANNEL)(	CC_HCHANNEL						hChannel,
										DWORD							dwRejectReason);

CC_API
HRESULT CC_RequestMode(					CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

typedef HRESULT (*CC_REQUESTMODE)(		CC_HCALL						hCall,
										WORD							wNumModeDescriptions,
										ModeDescription					ModeDescriptions[]);

CC_API
HRESULT CC_RequestModeResponse(			CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

typedef HRESULT (*CC_REQUESTMODERESPONSE)(
										CC_HCALL						hCall,
										CC_REQUEST_MODE_RESPONSE		RequestModeResponse);

CC_API
HRESULT CC_SendNonStandardMessage(		CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

typedef HRESULT (*CC_SENDNONSTANDARDMESSAGE)(
										CC_HCALL						hCall,
										BYTE							bMessageType,
										CC_NONSTANDARDDATA				NonStandardData);

CC_API
HRESULT CC_SendVendorID(				CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);

typedef HRESULT (*CC_SENDVENDORID)(		CC_HCALL						hCall,
										CC_NONSTANDARDDATA				NonStandardData,
										PCC_OCTETSTRING					pProductNumber,
										PCC_OCTETSTRING					pVersionNumber);
CC_API
HRESULT CC_SetCallControlTimeout(		WORD							wType,
										DWORD							dwDuration);

typedef HRESULT (*CC_SETCALLCONTROLTIMEOUT)
									   (WORD							wType,
										DWORD							dwDuration);

CC_API
HRESULT CC_SetTerminalID(				CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

typedef HRESULT (*CC_SETTERMINALID)(	CC_HCONFERENCE					hConference,
										PCC_OCTETSTRING					pTerminalID);

CC_API
HRESULT CC_Shutdown();
CC_API
HRESULT CC_Initialize();

typedef HRESULT (*CC_SHUTDOWN)();
typedef HRESULT (*CC_INITIALIZE)();

CC_API
HRESULT CC_UnMute(						CC_HCHANNEL						hChannel);

typedef HRESULT (*CC_UNMUTE)(			CC_HCHANNEL						hChannel);

CC_API
HRESULT CC_UpdatePeerList(				CC_HCONFERENCE					hConference);

typedef HRESULT (*CC_UPDATEPEERLIST)(	CC_HCONFERENCE					hConference);

CC_API
HRESULT CC_UserInput(					CC_HCALL						hCall,
										PWSTR							pszUserInput);

typedef HRESULT (*CC_USERINPUT)(		CC_HCALL						hCall,
										PWSTR							pszUserInput);

CC_API
HRESULT CC_EnableGKRegistration(
    BOOL fEnable,
    PSOCKADDR_IN pAddr,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc);


typedef HRESULT (*CC_ENABLEGKREGISTRATION)(
    BOOL fEnable,
    PCC_ALIASNAMES pLocalAliasNames,
    PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration,
    RASNOTIFYPROC pRasNotifyProc);


#endif


#ifdef __cplusplus
}
#endif

#pragma pack(pop)

#endif CALLCONT_H

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callcon2.c ===
/****************************************************************************
 *
 * $Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callcon2.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.35  $
 * $Date:   03 Mar 1997 09:08:16  $
 * $Author:   MANDREWS  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "listman.h"
#include "q931man.h"
#include "h245man.h"
#include "callman.h"
#include "userman.h"
#include "chanman.h"
#include "hangman.h"
#include "linkapi.h"
#include "h245api.h"
#include "ccutils.h"
#include "callman2.h"

#define HResultLeave(x) return x


extern CC_CONFERENCEID	InvalidConferenceID;


//
// Complete CC_xxx Operations
//

HRESULT ListenReject     (CC_HLISTEN hListen, HRESULT Reason)
{
HRESULT						status;
PLISTEN						pListen;
CC_LISTEN_CALLBACK_PARAMS   ListenCallbackParams;
    ASSERT(GKIExists());
	status = LockListen(hListen, &pListen);
	if (status == CC_OK) {
		ListenCallbackParams.hCall = CC_INVALID_HANDLE;
		ListenCallbackParams.pCallerAliasNames = NULL;
		ListenCallbackParams.pCalleeAliasNames = NULL;
		ListenCallbackParams.pNonStandardData = NULL;
		ListenCallbackParams.pszDisplay = NULL;
		ListenCallbackParams.pVendorInfo = NULL;
		ListenCallbackParams.ConferenceID = InvalidConferenceID;
		ListenCallbackParams.pCallerAddr = NULL;
		ListenCallbackParams.pCalleeAddr = NULL;
		ListenCallbackParams.dwListenToken = pListen->dwListenToken;

	    // Invoke the user callback -- the listen object is locked during the callback,
	    // but the associated call object is unlocked (to prevent deadlock if
	    // CC_AcceptCall() or CC_RejectCall() is called during the callback from a
	    // different thread, and the callback thread blocks pending completion of
	    // CC_AcceptCall() or CC_RejectCall())
	    InvokeUserListenCallback(pListen,
							     Reason,
							     &ListenCallbackParams);

	    // Need to validate the listen handle; the associated object may have been
	    // deleted during the user callback by this thread
	    if (ValidateListen(hListen) == CC_OK) {
	        HQ931LISTEN hQ931Listen = pListen->hQ931Listen;
		    UnlockListen(pListen);
	        status = Q931CancelListen(hQ931Listen);
	        if (LockListen(hListen, &pListen) == CC_OK) {
                FreeListen(pListen);
            }
        }
    }

    HResultLeave(status);
} // ListenReject()



HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid)
{
    register PCALL          pCall = (PCALL) pCallVoid;
    HRESULT                 status;
    ASSERT(GKIExists());
    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    if (pCall->pQ931PeerConnectAddr == NULL) {
        pCall->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
        if (pCall->pQ931PeerConnectAddr == NULL)
            return PlaceCallReject(pCallVoid, pConferenceVoid, CC_NO_MEMORY);
    }

    pCall->pQ931PeerConnectAddr->nAddrType             = CC_IP_BINARY;
    pCall->pQ931PeerConnectAddr->bMulticast            = FALSE;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.wPort  = pCall->GkiCall.wPort;
    pCall->pQ931PeerConnectAddr->Addr.IP_Binary.dwAddr = ntohl(pCall->GkiCall.dwIpAddress);

    status = PlaceCall(pCall, (PCONFERENCE)pConferenceVoid);
    if (status != CC_OK)
      PlaceCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // PlaceCallConfirm()



HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
CC_HCONFERENCE			hConference;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};
CC_HCALL                hCall;
PCALL                   pCall2;
    ASSERT(GKIExists());
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

    // Free Alias lists
    if (pCall->GkiCall.pCalleeAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeAliasNames);
        pCall->GkiCall.pCalleeAliasNames = NULL;
    }
    if (pCall->GkiCall.pCalleeExtraAliasNames != NULL) {
        Q931FreeAliasNames(pCall->GkiCall.pCalleeExtraAliasNames);
        pCall->GkiCall.pCalleeExtraAliasNames = NULL;
    }

    // Inform Call Control client of failure
    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;
	hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    if (ValidateConference(hConference) == CC_OK) {
		// Start up an enqueued call, if one exists
		for ( ; ; ) {
			status = RemoveEnqueuedCallFromConference(pConference, &hCall);
			if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
				break;

			status = LockCall(hCall, &pCall2);
			if (status == CC_OK) {
				pCall2->CallState = PLACED;

				status = PlaceCall(pCall2, pConference);
				UnlockCall(pCall2);
				if (status == CC_OK)
					break;
			}
		}
    }

    HResultLeave(status);
} // PlaceCallReject()



HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
CC_HCALL        hCall       = ((PCALL)pCallVoid)->hCall;
CC_HCONFERENCE  hConference = ((PCONFERENCE)pConferenceVoid)->hConference;
HRESULT         status;
    ASSERT(GKIExists());
    status = AcceptCall((PCALL)pCallVoid, (PCONFERENCE)pConferenceVoid);
    LockConference(hConference, (PPCONFERENCE)&pConferenceVoid);
    LockCall(hCall, (PPCALL)&pCallVoid);
    if (status != CC_OK && pCallVoid != NULL && pConferenceVoid != NULL)
      AcceptCallReject(pCallVoid, pConferenceVoid, status);
    return status;
} // AcceptCallConfirm()



HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason)
{
register PCALL          pCall = (PCALL) pCallVoid;
register PCONFERENCE    pConference = (PCONFERENCE) pConferenceVoid;
HRESULT                 status = CC_OK;
CC_CONNECT_CALLBACK_PARAMS ConnectCallbackParams = {0};
    ASSERT(GKIExists());
    status = Q931RejectCall(pCall->hQ931Call,       // Q931 call handle
                            CC_REJECT_GATEKEEPER_RESOURCES,
                            &pCall->ConferenceID,   // Conference Identifier
                            NULL,                   // alternate address
                            pCall->pLocalNonStandardData);

    ConnectCallbackParams.pNonStandardData     = pCall->pPeerNonStandardData;
    ConnectCallbackParams.pszPeerDisplay       = pCall->pszPeerDisplay;
    ConnectCallbackParams.bRejectReason        = 0;
    ConnectCallbackParams.pTermCapList         = pCall->pPeerH245TermCapList;
    ConnectCallbackParams.pH2250MuxCapability  = pCall->pPeerH245H2250MuxCapability;
    ConnectCallbackParams.pTermCapDescriptors  = pCall->pPeerH245TermCapDescriptors;
    ConnectCallbackParams.pLocalAddr           = pCall->pQ931LocalConnectAddr;
 	if (pCall->pQ931DestinationAddr == NULL)
		ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
	else
		ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
    if (pConference->ConferenceMode == MULTIPOINT_MODE)
        ConnectCallbackParams.bMultipointConference = TRUE;
    else
        ConnectCallbackParams.bMultipointConference = FALSE;
    ConnectCallbackParams.pVendorInfo          = pCall->pPeerVendorInfo;
    ConnectCallbackParams.pConferenceID        = &pConference->ConferenceID;
    ConnectCallbackParams.pMCAddress           = pConference->pMultipointControllerAddr;
	ConnectCallbackParams.pAlternateAddress	= NULL;
    ConnectCallbackParams.dwUserToken          = pCall->dwUserToken;

    InvokeUserConferenceCallback(pConference,
                                 CC_CONNECT_INDICATION,
                                 Reason,
                                 &ConnectCallbackParams);

    HResultLeave(status);
} // AcceptCallReject()



#if 0

HRESULT CancelCallConfirm   (void *pCallVoid, void *pConferenceVoid)
{
PCALL               pCall = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE) pConferenceVoid;
HRESULT             status;
H245_INST_T         H245Instance;
HQ931CALL           hQ931Call;
CC_HCONFERENCE      hConference;
HRESULT             SaveStatus;
CC_HCALL            hCall;
    ASSERT(GKIExists());
    H245Instance = pCall->H245Instance;
    hQ931Call    = pCall->hQ931Call;
    hConference  = pCall->hConference;
    FreeCall(pCall);

    if (H245Instance != H245_INVALID_ID)
        SaveStatus = H245ShutDown(H245Instance);
    else
        SaveStatus = H245_ERROR_OK;

    if (SaveStatus == H245_ERROR_OK) {
        SaveStatus = Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
        // Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
        // may have been deleted at this point
        if (SaveStatus == CS_BAD_PARAM)
            SaveStatus = CC_OK;
    } else
        Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

    // Start up an enqueued call, if one exists
    for ( ; ; ) {
        status = RemoveEnqueuedCallFromConference(pConference, &hCall);
        if ((status != CC_OK) || (hCall == CC_INVALID_HANDLE))
            break;

        status = LockCall(hCall, &pCall);
        if (status == CC_OK) {
            pCall->CallState = PLACED;

            status = PlaceCall(pCall, pConference);
            UnlockCall(pCall);
            if (status == CC_OK)
                break;
        }
    }
    UnlockConference(pConference);

    if (SaveStatus != CC_OK)
        status = SaveStatus;
    HResultLeave(status);
} // CancelCallConfirm()



HRESULT CancelCallReject    (void *pCallVoid, void *pConferenceVoid)
{
    // I don't care what the Gatekeeper says; I'm shutting down the call!
    return CancelCallConfirm(pCallVoid, pConferenceVoid);
} // CancelCallReject()

#endif



HRESULT OpenChannelConfirm  (CC_HCHANNEL hChannel)
{
HRESULT             status;
PCHANNEL            pChannel;
PCONFERENCE         pConference;
WORD                wNumCalls;
PCC_HCALL           CallList;
HRESULT             SaveStatus;
unsigned            i;
PCALL               pCall;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Open a logical channel for each established call
        status = EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
        if (status == CC_OK) {
            SaveStatus = CC_OK;
            for (i = 0; i < wNumCalls; ++i) {
                if (LockCall(CallList[i], &pCall) == CC_OK) {
                    status = H245OpenChannel(pCall->H245Instance,       // H245 instance
                                             pChannel->hChannel,        // dwTransId
                                             pChannel->wLocalChannelNumber,
                                             pChannel->pTxH245TermCap,  // TxMode
                                             pChannel->pTxMuxTable,     // TxMux
                                             H245_INVALID_PORT_NUMBER,  // TxPort
                                             pChannel->pRxH245TermCap,  // RxMode
                                             pChannel->pRxMuxTable,     // RxMux
                                             pChannel->pSeparateStack);
                    if (status == H245_ERROR_OK)
                        (pChannel->wNumOutstandingRequests)++;
                    else
                        SaveStatus = status;
                    UnlockCall(pCall);
                }
            }

            if (CallList != NULL)
                MemFree(CallList);

            if (pChannel->wNumOutstandingRequests == 0) {
                // all open channel requests failed
                FreeChannel(pChannel);
            }
            else {
                UnlockChannel(pChannel);
            }

            if (SaveStatus != CC_OK)
                status = SaveStatus;
        }
        else {
            FreeChannel(pChannel);
        }
        UnlockConference(pConference);
    }


    HResultLeave(status);
} // OpenChannelConfirm()



HRESULT OpenChannelReject   (CC_HCHANNEL hChannel, HRESULT Reason)
{
PCHANNEL            pChannel;
PCONFERENCE         pConference;
CC_HCONFERENCE      hConference;
HRESULT             status;
CC_TX_CHANNEL_OPEN_CALLBACK_PARAMS Params = {0};
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        // Inform Call Control client of failure
        Params.hChannel         = hChannel;
        Params.pPeerRTPAddr     = pChannel->pPeerRTPAddr;
        Params.pPeerRTCPAddr    = pChannel->pPeerRTCPAddr;
        Params.dwRejectReason   = 0;
        Params.dwUserToken      = pChannel->dwUserToken;

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_TX_CHANNEL_OPEN_INDICATION,
                                     Reason,
                                     &Params);

        if (ValidateChannel(hChannel) == CC_OK)
            FreeChannel(pChannel);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // OpenChannelReject()



HRESULT AcceptChannelConfirm(CC_HCHANNEL hChannel)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
PCALL           pCall;
unsigned        i;
H245_MUX_T      H245MuxTable;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status != CC_OK)
        HResultLeave(status);

    status = LockCall(pChannel->hCall, &pCall);
    if (status != CC_OK) {
        UnlockChannel(pChannel);
        UnlockConference(pConference);
        HResultLeave(status);
    }

    if (pChannel->wNumOutstandingRequests != 0) {
        PCC_ADDR pRTPAddr  = pChannel->pLocalRTPAddr;
        PCC_ADDR pRTCPAddr = pChannel->pLocalRTCPAddr;
        if ((pChannel->bMultipointChannel) &&
            (pConference->tsMultipointController == TS_TRUE)) {
            // Supply the RTP and RTCP addresses in the OpenLogicalChannelAck
            if (pConference->pSessionTable != NULL) {
                for (i = 0; i < pConference->pSessionTable->wLength; ++i) {
                    if (pConference->pSessionTable->SessionInfoArray[i].bSessionID ==
                        pChannel->bSessionID) {
                        pRTPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTPAddr;
                        pRTCPAddr = pConference->pSessionTable->SessionInfoArray[i].pRTCPAddr;
                        break;
                    }
                }
            }
        }

        H245MuxTable.Kind = H245_H2250ACK;
        H245MuxTable.u.H2250ACK.nonStandardList = NULL;

        if (pRTPAddr != NULL) {
            if (pRTPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaChannel.u.ip.tsapIdentifier =
                pRTPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaChannel.u.ip.network,
                                pRTPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaChannelPresent = FALSE;

        if (pRTCPAddr != NULL) {
            if (pRTCPAddr->bMulticast)
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_MULTICAST;
            else
                H245MuxTable.u.H2250ACK.mediaControlChannel.type = H245_IP_UNICAST;
            H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.tsapIdentifier =
                pRTCPAddr->Addr.IP_Binary.wPort;
            HostToH245IPNetwork(H245MuxTable.u.H2250ACK.mediaControlChannel.u.ip.network,
                                pRTCPAddr->Addr.IP_Binary.dwAddr);
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = TRUE;
        } else
            H245MuxTable.u.H2250ACK.mediaControlChannelPresent = FALSE;

        H245MuxTable.u.H2250ACK.dynamicRTPPayloadTypePresent = FALSE;
        H245MuxTable.u.H2250ACK.sessionIDPresent = TRUE;
        H245MuxTable.u.H2250ACK.sessionID = pChannel->bSessionID;

        status = H245OpenChannelAccept(pCall->H245Instance,
                                       0,                   // dwTransId
                                       pChannel->wRemoteChannelNumber, // Rx channel
                                       &H245MuxTable,
                                       0,                       // Tx channel
                                       NULL,                    // Tx mux
                                       H245_INVALID_PORT_NUMBER,// Port
                                       pChannel->pSeparateStack);
        if (status == CC_OK)
            pChannel->wNumOutstandingRequests = 0;
        else
            --(pChannel->wNumOutstandingRequests);
    }

    pChannel->tsAccepted = TS_TRUE;

    Params.hChannel = hChannel;
    if (status == CC_OK)
        UnlockChannel(pChannel);
    else
        FreeChannel(pChannel);
    UnlockCall(pCall);

    hConference = pConference->hConference;
    InvokeUserConferenceCallback(pConference,
                                 CC_ACCEPT_CHANNEL_INDICATION,
                                 status,
                                 &Params);
    if (ValidateConference(hConference) == CC_OK)
        UnlockConference(pConference);

    HResultLeave(status);
} // AcceptChannelConfirm(void()



HRESULT AcceptChannelReject (CC_HCHANNEL hChannel, HRESULT Reason)
{
HRESULT         status;
PCHANNEL        pChannel;
PCONFERENCE     pConference;
CC_HCONFERENCE  hConference;
CC_ACCEPT_CHANNEL_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    status = LockChannelAndConference(hChannel, &pChannel, &pConference);
    if (status == CC_OK) {
        Params.hChannel = hChannel;
        FreeChannel(pChannel);

        hConference = pConference->hConference;
        InvokeUserConferenceCallback(pConference,
                                     CC_ACCEPT_CHANNEL_INDICATION,
                                     Reason,
                                     &Params);
        if (ValidateConference(hConference) == CC_OK)
            UnlockConference(pConference);
    }

    HResultLeave(status);
} // AcceptChannelReject()



//
// Handle gratuitous messages from Gatekeeper
//

// Note: pCall assumed locked when called!

HRESULT Disengage(void *pCallVoid)
{
CC_HCALL            hCall        = ((PCALL)pCallVoid)->hCall;
HRESULT             status;
    UnlockCall((PCALL)pCallVoid);
    status = ProcessRemoteHangup(hCall, CC_INVALID_HANDLE, CC_REJECT_GATEKEEPER_TERMINATED);
    HResultLeave(status);
} // Disengage()



// Note: pCall assumed locked when called!

HRESULT BandwidthShrunk(void *pCallVoid,
                        void *pConferenceVoid,
                        unsigned uBandwidthAllocated,
                        long lBandwidthChange)
{
PCALL               pCall       = (PCALL) pCallVoid;
PCONFERENCE         pConference = (PCONFERENCE)pConferenceVoid;
CC_BANDWIDTH_CALLBACK_PARAMS Params;
    ASSERT(GKIExists());
    Params.hCall = pCall->hCall;
    Params.dwBandwidthTotal  = uBandwidthAllocated;
    Params.lBandwidthChange  = lBandwidthChange;
    InvokeUserConferenceCallback(pConference,
                                 CC_BANDWIDTH_CHANGED_INDICATION,
                                 CC_OK,
                                 &Params);

    HResultLeave(CC_OK);
} // BandwidthShrunk()

#else  // GATEKEEPER
static char ch; // Kludge around warning C4206: nonstandard extension used : translation unit is empty
#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.27  $
 *	$Date:   22 Jan 1997 17:25:38  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/


HRESULT InitCallManager();

HRESULT DeInitCallManager();

HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR                pSourceCallSignalAddress,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD_PTR				dwUserToken,
									CALLSTATE				InitialCallState,
									LPGUID                  pCallIdentifier,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall);

HRESULT FreeCall(					PCALL					pCall);

HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall);

HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall);

HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT MarkCallForDeletion(		PCALL					pCall);

HRESULT ValidateCall(				CC_HCALL				hCall);

HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall);

HRESULT UnlockCall(					PCALL					pCall);

HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData);

HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay);

HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo);

HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callman2.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman2.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.7  $
 *	$Date:   03 Jan 1997 16:28:04  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef CALLMAN2_H
#define CALLMAN2_H

#include "gkiman.h"

typedef HRESULT (*PGKICALLFUN)(PGKICALL pGkiCall, void *pConference);

// Additions to CALLMAN.C functionality
HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PPGKICALL 				ppGkiCall,
									void * *				ppConference,
									PCC_HCALL				phCall,
									PCC_HCONFERENCE			phConference);
HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									CC_HCALL				hCall,
									CC_HCONFERENCE			hConference);
HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall);
HRESULT UnlockGkiCall(PGKICALL pGkiCall);

HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun);

// Complete CC_xxx Operations
HRESULT ListenReject        (CC_HLISTEN hListen, HRESULT Reason);
HRESULT PlaceCallConfirm    (void *pCallVoid, void *pConferenceVoid);
HRESULT PlaceCallReject     (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);
HRESULT AcceptCallConfirm   (void *pCallVoid, void *pConferenceVoid);
HRESULT AcceptCallReject    (void *pCallVoid, void *pConferenceVoid, HRESULT Reason);

HRESULT OpenChannelConfirm  (CC_HCHANNEL hChannel);
HRESULT OpenChannelReject   (CC_HCHANNEL hChannel, HRESULT Reason);
HRESULT AcceptChannelConfirm(CC_HCHANNEL hChannel);
HRESULT AcceptChannelReject (CC_HCHANNEL hChannel, HRESULT Reason);

// Handle gratuitous messages from Gatekeeper
HRESULT Disengage           (void *pCallVoid);
HRESULT BandwidthShrunk     (void *pCallVoid,
                             void *pConferenceVoid,
                             unsigned uBandwidthAllocated,
                             long lBandwidthChange);

#endif // CALLMAN2_H

#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\ccerror.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/ccerror.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   16 Dec 1996 18:59:34  $
 *      $Author:   EHOWARDX  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCERROR_H
#define CCERROR_H

#include "apierror.h"

#ifdef __cplusplus
extern "C" {
#endif

// Status codes
#define CC_OK							NOERROR
#define CC_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_OUTOFMEMORY)
#define CC_PEER_REJECT					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 1)
#define CC_BAD_PARAM					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 2)
#define CC_BAD_SIZE						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 3)
#define CC_ACTIVE_CONNECTIONS			MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 4)
#define CC_INTERNAL_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 5)
#define CC_NOT_IMPLEMENTED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 6)
#define CC_DUPLICATE_CONFERENCE_ID		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 7)
#define CC_ILLEGAL_IN_MULTIPOINT		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 8)
#define CC_NOT_MULTIPOINT_CAPABLE		MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 9)
#define CC_PEER_CANCEL					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 10)
#define CC_GKI_STATE                    MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 21)
#define CC_GKI_CALL_STATE               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 22)
#define CC_GKI_LISTEN_NOT_FOUND         MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 23)
#define CC_GATEKEEPER_REFUSED           MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 24)
#define CC_INVALID_WITHOUT_GATEKEEPER   MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 25)
#define CC_GKI_IP_ADDRESS               MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 26)
#define CC_GKI_LOAD                     MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_CALLCONTROL,ERROR_LOCAL_BASE_ID + 27)


#ifdef __cplusplus
}
#endif

#endif CCERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\cclock.h ===
/****************************************************************************
 *
 *      $Archive:   S:/STURGEON/SRC/INCLUDE/VCS/cclock.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *      Copyright (c) 1993-1994 Intel Corporation.
 *
 *      $Revision:   1.0  $
 *      $Date:   31 Jan 1997 12:36:14  $
 *      $Author:   MANDREWS  $
 *
 *      Deliverable:
 *
 *      Abstract:
 *              
 *
 *      Notes:
 *
 ***************************************************************************/


#ifndef CCLOCK_H
#define CCLOCK_H

#ifdef __cplusplus
extern "C" {
#endif

VOID CCLOCK_AcquireLock();
VOID CCLOCK_RelinquishLock();

HRESULT InitializeCCLock(VOID);
VOID UnInitializeCCLock();

#ifdef __cplusplus
}
#endif


#endif CCLOCK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\callman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/callman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.69  $
 *	$Date:   24 Jan 1997 19:02:08  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "h245man.h"
#include "confman.h"
#include "callman.h"
#include "ccutils.h"
#include "callman2.h"


static BOOL		bCallInited = FALSE;

#define HASH_TABLE_SIZE	11

static struct {
	PCALL				pHead[HASH_TABLE_SIZE];
	LOCK				Lock;
} CallTable;

static struct {
	CC_HCALL			hCall;
	LOCK				Lock;
} CallHandle;

HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference);

HRESULT InitCallManager()
{
int		i;

	ASSERT(bCallInited == FALSE);

	for (i = 0; i < HASH_TABLE_SIZE; i++)
		CallTable.pHead[i] = NULL;
	InitializeLock(&CallTable.Lock);

	CallHandle.hCall = CC_INVALID_HANDLE + 1;
	InitializeLock(&CallHandle.Lock);

	bCallInited = TRUE;
	return CC_OK;
}



HRESULT DeInitCallManager()
{
HRESULT		status;
HRESULT		SaveStatus;
int			i;
PCALL		pCall;
PCALL		pNextCall;
H245_INST_T	H245Instance;

	if (bCallInited == FALSE)
		return CC_OK;

	SaveStatus = CC_OK;
	for (i = 0; i < HASH_TABLE_SIZE; i++) {
		pCall = CallTable.pHead[i];
		while (pCall != NULL) {
			AcquireLock(&pCall->Lock);
			pNextCall = pCall->pNextInTable;
			H245Instance = pCall->H245Instance;
			FreeCall(pCall);
#if(0)
The whole H.245 subsystem should be already be shut down and released
at this point.  Calling H245ShutDown() will attempt to lock a nonexistent H.245
instance struct via a critical section that has been deleted. It might also be a
good idea to fix InstanceLock to avoid the EnterCriticalSection if the instance is
obviously already nonexistent


			if (H245Instance != H245_INVALID_ID) {
				status = H245ShutDown(H245Instance);
				if (status != H245_ERROR_OK)
					SaveStatus = status;
			}
#endif
			pCall = pNextCall;
		}
	}

	DeleteLock(&CallHandle.Lock);
	DeleteLock(&CallTable.Lock);
	bCallInited = FALSE;
	return SaveStatus;
}



#define _Hash(hCall) ((DWORD)((hCall) % HASH_TABLE_SIZE))



HRESULT _AddCallToTable(			PCALL					pCall)
{
int	index;

	ASSERT(pCall != NULL);
	ASSERT(pCall->hCall != CC_INVALID_HANDLE);
	ASSERT(pCall->bInTable == FALSE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(pCall->hCall);
	pCall->pNextInTable = CallTable.pHead[index];
	pCall->pPrevInTable = NULL;
	if (CallTable.pHead[index] != NULL)
		CallTable.pHead[index]->pPrevInTable = pCall;
	CallTable.pHead[index] = pCall;

	pCall->bInTable = TRUE;

	RelinquishLock(&CallTable.Lock);
	return CC_OK;
}



HRESULT _RemoveCallFromTable(		PCALL					pCall)
{
CC_HCALL	hCall;
int			index;
BOOL		bTimedOut;

	ASSERT(pCall != NULL);
	ASSERT(pCall->bInTable == TRUE);

	// Caller must have a lock on the call object;
	// in order to avoid deadlock, we must:
	//   1. unlock the Call object,
	//   2. lock the CallTable,
	//   3. locate the call object in the CallTable (note that
	//      after step 2, the call object may be deleted from the
	//      CallTable by another thread),
	//   4. lock the Call object (someone else may have the lock)
	//   5. remove the call object from the CallTable,
	//   6. unlock the CallTable
	//
	// The caller can now safely unlock and destroy the call object,
	// since no other thread will be able to find the object (its been
	// removed from the CallTable), and therefore no other thread will
	// be able to lock it.

	// Save the call handle; its the only way to look up
	// the call object in the CallTable. Note that we
	// can't use pCall to find the call object, since
	// pCall may be free'd up, and another call object
	// allocated at the same address
	hCall = pCall->hCall;

	// step 1
	RelinquishLock(&pCall->Lock);

step2:
	// step 2
	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	// step 3
	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL) {
		// step 4
		AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step2;
		}

		// step 5
		if (pCall->pPrevInTable == NULL)
			CallTable.pHead[index] = pCall->pNextInTable;
		else
			pCall->pPrevInTable->pNextInTable = pCall->pNextInTable;

		if (pCall->pNextInTable != NULL)
			pCall->pNextInTable->pPrevInTable = pCall->pPrevInTable;

		pCall->pNextInTable = NULL;
		pCall->pPrevInTable = NULL;
		pCall->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeCallHandle(			PCC_HCALL				phCall)
{
	AcquireLock(&CallHandle.Lock);
	*phCall = CallHandle.hCall++;
	RelinquishLock(&CallHandle.Lock);
	return CC_OK;
}



HRESULT AllocAndLockCall(			PCC_HCALL				phCall,
									CC_HCONFERENCE			hConference,
									HQ931CALL				hQ931Call,
									HQ931CALL				hQ931CallInvitor,
									PCC_ALIASNAMES			pLocalAliasNames,
									PCC_ALIASNAMES			pPeerAliasNames,
									PCC_ALIASNAMES			pPeerExtraAliasNames,
									PCC_ALIASITEM			pPeerExtension,
									PCC_NONSTANDARDDATA		pLocalNonStandardData,
									PCC_NONSTANDARDDATA		pPeerNonStandardData,
									PWSTR					pszLocalDisplay,
									PWSTR					pszPeerDisplay,
									PCC_VENDORINFO			pPeerVendorInfo,
									PCC_ADDR				pQ931LocalConnectAddr,
									PCC_ADDR				pQ931PeerConnectAddr,
									PCC_ADDR				pQ931DestinationAddr,
									PCC_ADDR                pSourceCallSignalAddress,
									CALLTYPE				CallType,
									BOOL					bCallerIsMC,
									DWORD_PTR				dwUserToken,
									CALLSTATE				InitialCallState,
									LPGUID                  pCallIdentifier,
									PCC_CONFERENCEID		pConferenceID,
									PPCALL					ppCall)
{
HRESULT		status;
	
	ASSERT(bCallInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phCall != NULL);
	ASSERT(ppCall != NULL);
	ASSERT(pConferenceID != NULL);

	// set phCall now, in case we encounter an error
	*phCall = CC_INVALID_HANDLE;

	*ppCall = (PCALL)MemAlloc(sizeof(CALL));
	if (*ppCall == NULL)
		return CC_NO_MEMORY;

   memset(*ppCall, 0, sizeof(CALL));
	(*ppCall)->bInTable = FALSE;
	(*ppCall)->hConference = hConference;
	(*ppCall)->hQ931Call = hQ931Call;
	(*ppCall)->hQ931CallInvitor = hQ931CallInvitor;
	(*ppCall)->pPeerParticipantInfo = NULL;
	(*ppCall)->bMarkedForDeletion = FALSE;
	(*ppCall)->H245Instance = H245_INVALID_ID;
	(*ppCall)->dwH245PhysicalID = 0;
	(*ppCall)->dwUserToken = dwUserToken;
	(*ppCall)->pLocalNonStandardData = NULL;
	(*ppCall)->pPeerNonStandardData = NULL;
	(*ppCall)->pQ931LocalConnectAddr = NULL;
	(*ppCall)->pQ931PeerConnectAddr = NULL;
	(*ppCall)->pQ931DestinationAddr = NULL;
	(*ppCall)->pSourceCallSignalAddress = NULL;
	(*ppCall)->pszLocalDisplay = NULL;
	(*ppCall)->pszPeerDisplay = NULL;
	(*ppCall)->pPeerVendorInfo = NULL;
	(*ppCall)->pLocalAliasNames = NULL;
	(*ppCall)->pPeerAliasNames = NULL;
	(*ppCall)->pPeerExtraAliasNames = NULL;
	(*ppCall)->pPeerExtension = NULL;
	(*ppCall)->OutgoingTermCapState = NEED_TO_SEND_TERMCAP;
	(*ppCall)->IncomingTermCapState = AWAITING_TERMCAP;
	(*ppCall)->MasterSlaveState = MASTER_SLAVE_NOT_STARTED;
	(*ppCall)->pPeerH245TermCapList = NULL;
	(*ppCall)->pPeerH245H2250MuxCapability = NULL;
	(*ppCall)->pPeerH245TermCapDescriptors = NULL;
	(*ppCall)->CallState = InitialCallState;
	(*ppCall)->ConferenceID = *pConferenceID;
	(*ppCall)->CallType = CallType;
	(*ppCall)->bCallerIsMC = bCallerIsMC;
	(*ppCall)->bLinkEstablished = FALSE;
	(*ppCall)->pNext = NULL;
	(*ppCall)->pPrev = NULL;
	(*ppCall)->pNextInTable = NULL;
	(*ppCall)->pPrevInTable = NULL;
	
    if(pCallIdentifier)
    {
        (*ppCall)->CallIdentifier = *pCallIdentifier;
    }

	InitializeLock(&(*ppCall)->Lock);
	AcquireLock(&(*ppCall)->Lock);

	status = _MakeCallHandle(&(*ppCall)->hCall);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the local non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pLocalNonStandardData,
		                         pLocalNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a local copy of the peer's non-standard data, if supplied
	status = CopyNonStandardData(&(*ppCall)->pPeerNonStandardData,
		                         pPeerNonStandardData);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}
	
	// make a copy of the local connect address, if supplied
	if (pQ931LocalConnectAddr != NULL) {
		(*ppCall)->pQ931LocalConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931LocalConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931LocalConnectAddr = *pQ931LocalConnectAddr;
	}

	// make a copy of the peer's connect address, if supplied
	if (pQ931PeerConnectAddr != NULL) {
		(*ppCall)->pQ931PeerConnectAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931PeerConnectAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931PeerConnectAddr = *pQ931PeerConnectAddr;
	}

	// make a copy of the destination address, if supplied
	if (pQ931DestinationAddr != NULL) {
		(*ppCall)->pQ931DestinationAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pQ931DestinationAddr == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pQ931DestinationAddr = *pQ931DestinationAddr;
	}

    // make a copy of the source call signal address, if supplied
	if (pSourceCallSignalAddress != NULL) {
		(*ppCall)->pSourceCallSignalAddress = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppCall)->pSourceCallSignalAddress == NULL) {
			FreeCall(*ppCall);
			return CC_NO_MEMORY;
		}
		*(*ppCall)->pSourceCallSignalAddress = *pSourceCallSignalAddress;
	}

	// make a local copy of the local alias names
	status = Q931CopyAliasNames(&((*ppCall)->pLocalAliasNames), pLocalAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerAliasNames), pPeerAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extra alias names
	status = Q931CopyAliasNames(&((*ppCall)->pPeerExtraAliasNames),
								pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	// make a local copy of the peer extension
	status = Q931CopyAliasItem(&((*ppCall)->pPeerExtension),
							   pPeerExtension);
	if (status != CS_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszLocalDisplay, pszLocalDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyDisplay(&(*ppCall)->pszPeerDisplay, pszPeerDisplay);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	status = CopyVendorInfo(&(*ppCall)->pPeerVendorInfo, pPeerVendorInfo);
	if (status != CC_OK) {
		FreeCall(*ppCall);
		return status;
	}

	*phCall = (*ppCall)->hCall;

	// add the Call to the Call table
	status = _AddCallToTable(*ppCall);
	if (status != CC_OK)
		FreeCall(*ppCall);
	
	return status;
}



// Caller must have a lock on the Call object
HRESULT FreeCall(					PCALL					pCall)
{
HRESULT		status;
CC_HCALL	hCall;
PCONFERENCE	pConference;

	ASSERT(pCall != NULL);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
	    if (pCall->GkiCall.uGkiCallState != 0)
		    GkiCloseCall(&pCall->GkiCall);
    }
#endif // GATEKEEPER

	// caller must have a lock on the Call object,
	// so there's no need to re-lock it
	
	hCall = pCall->hCall;
	if (pCall->hConference != CC_INVALID_HANDLE) {
		UnlockCall(pCall);
		status = _LockCallAndConferenceMarkedForDeletion(hCall, &pCall, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pCall->bInTable == TRUE)
		if (_RemoveCallFromTable(pCall) == CC_BAD_PARAM)
			// the Call object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pCall->pPeerParticipantInfo != NULL) {
		if (pCall->CallType == VIRTUAL_CALL)
			FreePeerParticipantInfo(NULL, pCall->pPeerParticipantInfo);
		else
			FreePeerParticipantInfo(pConference, pCall->pPeerParticipantInfo);
	}

	// If the call object is associated with a conference object, deassociate it.
	if (pCall->hConference != CC_INVALID_HANDLE) {
		RemoveCallFromConference(pCall, pConference);
		UnlockConference(pConference);
	}

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);

	if (pCall->pPeerNonStandardData != NULL)
		FreeNonStandardData(pCall->pPeerNonStandardData);

	if (pCall->pQ931LocalConnectAddr != NULL)
		MemFree(pCall->pQ931LocalConnectAddr);

	if (pCall->pQ931PeerConnectAddr != NULL)
		MemFree(pCall->pQ931PeerConnectAddr);

	if (pCall->pQ931DestinationAddr != NULL)
		MemFree(pCall->pQ931DestinationAddr);
		
	if (pCall->pSourceCallSignalAddress != NULL)
		MemFree(pCall->pSourceCallSignalAddress);

	if (pCall->pPeerH245TermCapList != NULL)
		DestroyH245TermCapList(&(pCall->pPeerH245TermCapList));

	if (pCall->pPeerH245H2250MuxCapability != NULL)
		DestroyH245TermCap(&(pCall->pPeerH245H2250MuxCapability));

	if (pCall->pPeerH245TermCapDescriptors != NULL)
		DestroyH245TermCapDescriptors(&(pCall->pPeerH245TermCapDescriptors));

	if (pCall->pLocalAliasNames != NULL)
		Q931FreeAliasNames(pCall->pLocalAliasNames);

	if (pCall->pPeerAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerAliasNames);

	if (pCall->pPeerExtraAliasNames != NULL)
		Q931FreeAliasNames(pCall->pPeerExtraAliasNames);
	
	if (pCall->pPeerExtension != NULL)
		Q931FreeAliasItem(pCall->pPeerExtension);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);

	if (pCall->pszPeerDisplay != NULL)
		FreeDisplay(pCall->pszPeerDisplay);

	if (pCall->pPeerVendorInfo != NULL)
		FreeVendorInfo(pCall->pPeerVendorInfo);

#ifdef    GATEKEEPER
    if(GKIExists())
    {
    	if (pCall->GkiCall.uGkiCallState != 0)
	    	GkiFreeCall(&pCall->GkiCall);
	}
#endif // GATEKEEPER

	// Since the call object has been removed from the CallTable,
	// no other thread will be able to find the call object and obtain
	// a lock, so its safe to unlock the call object and delete it here
	RelinquishLock(&pCall->Lock);
	DeleteLock(&pCall->Lock);
	MemFree(pCall);
	return CC_OK;
}



HRESULT _LockQ931CallMarkedForDeletion(
									CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
int		index;
BOOL	bTimedOut;

	// If hCall != CC_INVALID_HANDLE, the search is based on hCall;
	// otherwise, the search is based on hQ931Call

	ASSERT(ppCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	if (hCall != CC_INVALID_HANDLE) {
		index = _Hash(hCall);

		*ppCall = CallTable.pHead[index];
		while ((*ppCall != NULL) && ((*ppCall)->hCall != hCall))
			*ppCall = (*ppCall)->pNextInTable;
	} else {
		// Perform an exhaustive search based on hQ931Call
		for (index = 0; index < HASH_TABLE_SIZE; index++) {
			*ppCall = CallTable.pHead[index];
			while ((*ppCall != NULL) && ((*ppCall)->hQ931Call != hQ931Call))
				*ppCall = (*ppCall)->pNextInTable;
			if (*ppCall != NULL)
				break;
		}
	}

	if (*ppCall != NULL) {
		AcquireTimedLock(&(*ppCall)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&CallTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&CallTable.Lock);

	if (*ppCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockQ931Call(				CC_HCALL				hCall,
									HQ931CALL				hQ931Call,
									PPCALL					ppCall)
{
HRESULT	status;

	status = _LockQ931CallMarkedForDeletion(hCall, hQ931Call, ppCall);
	if (status != CC_OK)
		return status;
	if ((*ppCall)->bMarkedForDeletion) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT LockCall(					CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return LockQ931Call(hCall,	// Call Control call handle (used in this call)
		                0,		// Q931 call handle (ignored in this call)
						ppCall);
}



HRESULT _LockCallMarkedForDeletion(	CC_HCALL				hCall,
									PPCALL					ppCall)
{
	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);

	return _LockQ931CallMarkedForDeletion(hCall,	// Call Control call handle (used in this call)
										  0,		// Q931 call handle (ignored in this call)
										  ppCall);
}



HRESULT LockCallAndConference(		CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = LockCall(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockCall(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT _LockCallAndConferenceMarkedForDeletion(
									CC_HCALL				hCall,
									PPCALL					ppCall,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hCall != CC_INVALID_HANDLE);
	ASSERT(ppCall != NULL);
	ASSERT(ppConference != NULL);

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK)
		return status;
	
	if ((*ppCall)->hConference == CC_INVALID_HANDLE) {
		UnlockCall(*ppCall);
		return CC_BAD_PARAM;
	}

	hConference = (*ppCall)->hConference;
	UnlockCall(*ppCall);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = _LockCallMarkedForDeletion(hCall, ppCall);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT MarkCallForDeletion(		PCALL					pCall)
{
	ASSERT(pCall != NULL);
	ASSERT(pCall->bMarkedForDeletion == FALSE);

	pCall->bMarkedForDeletion = TRUE;
	return CC_OK;
}



HRESULT ValidateCall(				CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	if (pCall != NULL)
		if (pCall->bMarkedForDeletion == TRUE)
			pCall = NULL;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateCallMarkedForDeletion(
									CC_HCALL				hCall)
{
PCALL	pCall;
int		index;

	ASSERT(hCall != CC_INVALID_HANDLE);

	AcquireLock(&CallTable.Lock);

	index = _Hash(hCall);

	pCall = CallTable.pHead[index];
	while ((pCall != NULL) && (pCall->hCall != hCall))
		pCall = pCall->pNextInTable;

	RelinquishLock(&CallTable.Lock);

	if (pCall == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockCall(					PCALL					pCall)
{
	ASSERT(pCall != NULL);

	RelinquishLock(&pCall->Lock);
	return CC_OK;
}



HRESULT AddLocalNonStandardDataToCall(
									PCALL					pCall,
									PCC_NONSTANDARDDATA		pLocalNonStandardData)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pLocalNonStandardData != NULL)
		FreeNonStandardData(pCall->pLocalNonStandardData);
	status = CopyNonStandardData(&pCall->pLocalNonStandardData, pLocalNonStandardData);
	return status;
}



HRESULT AddLocalDisplayToCall(		PCALL					pCall,
									PWSTR					pszLocalDisplay)
{
HRESULT	status;

	ASSERT(pCall != NULL);

	if (pCall->pszLocalDisplay != NULL)
		FreeDisplay(pCall->pszLocalDisplay);
	status = CopyDisplay(&pCall->pszLocalDisplay, pszLocalDisplay);
	return status;
}



HRESULT AllocatePeerParticipantInfo(PCONFERENCE				pConference,
									PPARTICIPANTINFO		*ppPeerParticipantInfo)
{
HRESULT					status;
H245_TERMINAL_LABEL_T	H245TerminalLabel;

	ASSERT(ppPeerParticipantInfo != NULL);

	if (pConference == NULL) {
		H245TerminalLabel.mcuNumber = 0;
		H245TerminalLabel.terminalNumber = 0;
	} else {
		status = AllocateTerminalNumber(pConference, &H245TerminalLabel);
		if (status != CC_OK) {
			*ppPeerParticipantInfo = NULL;
			return status;
		}
	}

	*ppPeerParticipantInfo = (PPARTICIPANTINFO)MemAlloc(sizeof(PARTICIPANTINFO));
	if (*ppPeerParticipantInfo == NULL)
		return CC_NO_MEMORY;

	(*ppPeerParticipantInfo)->TerminalIDState = TERMINAL_ID_INVALID;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bMCUNumber = (BYTE)H245TerminalLabel.mcuNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalLabel.bTerminalNumber = (BYTE)H245TerminalLabel.terminalNumber;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppPeerParticipantInfo)->ParticipantInfo.TerminalID.wOctetStringLength = 0;
	(*ppPeerParticipantInfo)->pEnqueuedRequestsForTerminalID = NULL;

	return CC_OK;
}



HRESULT FreePeerParticipantInfo(	PCONFERENCE				pConference,
									PPARTICIPANTINFO		pPeerParticipantInfo)
{
HRESULT				status = CC_OK;

	ASSERT(pPeerParticipantInfo != NULL);

	if (pConference != NULL)
		status = FreeTerminalNumber(pConference,
							        pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);

	while (DequeueRequest(&pPeerParticipantInfo->pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	if (pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString != NULL)
		MemFree(pPeerParticipantInfo->ParticipantInfo.TerminalID.pOctetString);
	MemFree(pPeerParticipantInfo);
	return status;
}



#ifdef GATEKEEPER

HRESULT LockGkiCallAndConference(	HANDLE					hGkiCall,
									PGKICALL *				ppGkiCall,
									void * *				ppConference,
									DWORD_PTR * 			phCall,
									DWORD_PTR *				phConference)
{
unsigned int	uIndex;
PCALL			pCall;
PCONFERENCE		pConference;
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;
				
	ASSERT(hGkiCall     != 0);
	ASSERT(ppGkiCall    != NULL);
	ASSERT(ppConference != NULL);
	ASSERT(phCall       != NULL);
	ASSERT(phConference != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				hConference = pCall->hConference;
				if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
				{
					RelinquishLock(&pCall->Lock);
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) != CC_OK)
				{
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				AcquireLock(&pCall->Lock);
				*ppGkiCall    = &pCall->GkiCall;
				*ppConference = (void *)pConference;
				*phCall		  = pCall->hCall;
				*phConference = pCall->hConference;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCallAndConference()



HRESULT UnlockGkiCallAndConference(	PGKICALL				pGkiCall,
									void *					pConference,
									DWORD_PTR				hCall,
									DWORD_PTR				hConference)
{
	if (ValidateConference(hConference) == CC_OK)
		UnlockConference((PCONFERENCE)pConference);
	if (ValidateCall(hCall) == CC_OK)
		UnlockCall(pGkiCall->pCall);
	return NOERROR;
} // UnlockGkiCallAndConference()



HRESULT LockGkiCall(HANDLE hGkiCall, PPGKICALL ppGkiCall)
{
unsigned int	uIndex;
PCALL			pCall;
BOOL			bTimedOut;

	ASSERT(hGkiCall != 0);
	ASSERT(ppGkiCall != NULL);

step1:
	AcquireLock(&CallTable.Lock);

	// Perform an exhaustive search based on hGkiCall
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			if (pCall->GkiCall.hGkiCall == hGkiCall)
			{
				AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
				if (bTimedOut) {
					RelinquishLock(&CallTable.Lock);
					Sleep(0);
					goto step1;
				}
				if (pCall->bMarkedForDeletion)
				{
					RelinquishLock(&pCall->Lock);
					*ppGkiCall = NULL;
					RelinquishLock(&CallTable.Lock);
					return CC_BAD_PARAM;
				}
				*ppGkiCall = &pCall->GkiCall;
				RelinquishLock(&CallTable.Lock);
				return NOERROR;
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	*ppGkiCall = NULL;
	RelinquishLock(&CallTable.Lock);
	return CC_BAD_PARAM;
} // LockGkiCall()



HRESULT UnlockGkiCall(PGKICALL pGkiCall)
{
	return UnlockCall(pGkiCall->pCall);
} // UnlockGkiCall()



HRESULT ApplyToAllCalls(PGKICALLFUN pGkiCallFun)
{
unsigned	uIndex;
PCALL		pCall;
DWORD_PTR	hCall;
PCONFERENCE	pConference;
DWORD_PTR	hConference;
HRESULT     status;
BOOL		bTimedOut;

step1:
	AcquireLock(&CallTable.Lock);

	// Apply pGkiCallFun to all calls in table
	for (uIndex = 0; uIndex < HASH_TABLE_SIZE; ++uIndex)
	{
		pCall = CallTable.pHead[uIndex];
		while (pCall)
		{
			AcquireTimedLock(&pCall->Lock,10,&bTimedOut);
			if (bTimedOut) {
				RelinquishLock(&CallTable.Lock);
				Sleep(0);
				goto step1;
			}
			hConference = pCall->hConference;
			if (pCall->bMarkedForDeletion || hConference == CC_INVALID_HANDLE)
			{
				RelinquishLock(&pCall->Lock);
			}
			else
			{
				RelinquishLock(&pCall->Lock);
				if (LockConference(hConference, &pConference) == CC_OK)
				{
					AcquireLock(&pCall->Lock);
					hCall = pCall->hCall;
					status = pGkiCallFun(&pCall->GkiCall, pConference);
					if (ValidateConference(hConference) == NOERROR)
						UnlockConference(pConference);
					if (ValidateCall(hCall) != NOERROR)
					{
						// Call was deleted
						RelinquishLock(&CallTable.Lock);
						if (status != NOERROR)
							return status;
						// Start all over again
						goto step1;
					}
					RelinquishLock(&pCall->Lock);
					if (status != NOERROR)
					{
						RelinquishLock(&CallTable.Lock);
						return status;
					}
				}
			}
			pCall = pCall->pNextInTable;
		} // while
	}

	RelinquishLock(&CallTable.Lock);
	return NOERROR;
} // ApplyToAllCalls()

#endif // GATEKEEPER


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\ccmain.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccmain.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.81  $
 *	$Date:   31 Jan 1997 13:13:50  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include <winerror.h>
#ifdef GATEKEEPER
#include "gkiman.h"
#endif // GATEKEEPER


#define MASTER_SLAVE_RETRY_MAX 10

typedef struct {
#ifdef _DEBUG
	CRITICAL_SECTION	LockInfoLock;
	WORD				wLockCount;
	WORD				wNumQueuedThreads;
	HANDLE				hOwningThread;
#endif
	HANDLE				Lock;
} LOCK, *PLOCK;

typedef struct {
	LOCK				Lock;
	WORD				wNumThreads;
} THREADCOUNT;

typedef enum {
	INITIALIZING_STATE,
	OPERATIONAL_STATE,
	SHUTDOWN_STATE
} CALL_CONTROL_STATE;

// The following typedef is not in callcont.h because it is only used internally
typedef DWORD	HHANGUP, *PHHANGUP;

typedef enum {
	TS_FALSE,
	TS_TRUE,
	TS_UNKNOWN
} TRISTATE;

typedef enum {
	UNCONNECTED_MODE,
	POINT_TO_POINT_MODE,
	MULTIPOINT_MODE
} CONFMODE;

typedef enum {
	NEVER_ATTACHED,	// Endpoint has never been attached to the conference
	ATTACHED,		// Endpoint is currently attached to the conference
	DETACHED		// Endpoint was once attached to the conference, but is now detached
} ATTACHSTATE;

typedef struct CallQueue_t {
	CC_HCALL			hCall;
	struct CallQueue_t	*pNext;
	struct CallQueue_t	*pPrev;
} CALL_QUEUE, *PCALL_QUEUE;

#define NUM_TERMINAL_ALLOCATION_SLOTS	24		// 24*sizeof(BYTE) = 192 = max. terminal number
#define NUM_CHANNEL_ALLOCATION_SLOTS	32		// 32*sizeof(BYTE) = 256 = max. channel number

typedef enum {
	TERMINAL_ID_INVALID,
	TERMINAL_ID_REQUESTED,
	TERMINAL_ID_VALID
} TERMINALIDSTATE;

typedef struct {
	TERMINALIDSTATE			TerminalIDState;
	CC_PARTICIPANTINFO		ParticipantInfo;
	PCALL_QUEUE				pEnqueuedRequestsForTerminalID; // list of calls waiting to get this peer's terminal ID
} PARTICIPANTINFO, *PPARTICIPANTINFO;


typedef struct Conference_t {
	CC_HCONFERENCE			hConference;		// handle for this conference object
	CC_CONFERENCEID			ConferenceID;		// conference ID (0 => conference ID has not
												//   been established)
	PARTICIPANTINFO			LocalParticipantInfo;
	BYTE					TerminalNumberAllocation[NUM_TERMINAL_ALLOCATION_SLOTS];
	BYTE					ChannelNumberAllocation[NUM_CHANNEL_ALLOCATION_SLOTS];
	BOOL					bDeferredDelete;
	BOOL					bMultipointCapable;
	BOOL					bForceMC;
	BOOL					bAutoAccept;
	ATTACHSTATE				LocalEndpointAttached;
	BOOL					bDynamicConferenceID;
	BOOL					bDynamicTerminalID;
	PCC_TERMCAP				pLocalH245H2250MuxCapability;
	PCC_TERMCAPLIST			pLocalH245TermCapList;			// terminal capabilities
	PCC_TERMCAPDESCRIPTORS	pLocalH245TermCapDescriptors;	// terminal capability descriptors
	BOOL					bSessionTableInternallyConstructed;  // TRUE => session table must be
												// deallocated by Call Control; FALSE => must be
												// deallocated by SessionTableConstructor
	PCC_SESSIONTABLE		pSessionTable;
	PCC_TERMCAP				pConferenceH245H2250MuxCapability;
	PCC_TERMCAPLIST			pConferenceTermCapList;
	PCC_TERMCAPDESCRIPTORS	pConferenceTermCapDescriptors;
	DWORD_PTR				dwConferenceToken;	// conference token specified by user in
												//   CreateConference()
	CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor;
	CC_TERMCAP_CONSTRUCTOR	TermCapConstructor;
	CC_CONFERENCE_CALLBACK	ConferenceCallback;	// conference callback location
	CC_CONFERENCE_CALLBACK	SaveConferenceCallback;	// saved copy of the conference callback location
	struct Call_t			*pEnqueuedCalls;
	struct Call_t			*pPlacedCalls;
	struct Call_t			*pEstablishedCalls;
	struct Call_t			*pVirtualCalls;
	struct Channel_t		*pChannels;
	TRISTATE				tsMultipointController;
	TRISTATE				tsMaster;
	CONFMODE				ConferenceMode;
	PCC_ADDR				pMultipointControllerAddr;
	PCC_VENDORINFO			pVendorInfo;
	PCALL_QUEUE				pEnqueuedRequestModeCalls;
	BOOL					bInTable;
	struct Conference_t		*pNextInTable;
	struct Conference_t		*pPrevInTable;
	LOCK					Lock;
} CONFERENCE, *PCONFERENCE, **PPCONFERENCE;

// State of call object
typedef enum {
	INCOMING,		// incoming call request has been received,
					//   but not yet accepted or rejected
	ENQUEUED,		// call has been enqueued on conference for later placement
	PLACED,			// call has been placed, awaiting RINGING, CONNECT or RELEASECOMPLETE
	RINGING,		// RINGING received, awaiting CONNECT or RELEASECOMPLETE
	TERMCAP,		// CONNECT received or incoming call accepted,
					//   awaiting completion of terminal capability exchange
	CALL_COMPLETE	// call placement complete (either success or failure)
} CALLSTATE;

typedef enum {
	NEED_TO_SEND_TERMCAP,
	AWAITING_TERMCAP,
	AWAITING_ACK,
	TERMCAP_COMPLETE
} TERMCAPSTATE;

typedef enum {
	MASTER_SLAVE_NOT_STARTED,
	MASTER_SLAVE_IN_PROGRESS,
	MASTER_SLAVE_COMPLETE
} MASTERSLAVESTATE;

typedef enum {
	CALLER,
	CALLEE,
	VIRTUAL,
	THIRD_PARTY_INVITOR,
	THIRD_PARTY_INTERMEDIARY	// we're the MC in a third party invite
} CALLTYPE;

typedef struct Call_t {
	CC_HCALL				hCall;
	CC_HCONFERENCE			hConference;
	HQ931CALL				hQ931Call;
	HQ931CALL				hQ931CallInvitor;		// Invitor in third party invite
	PPARTICIPANTINFO		pPeerParticipantInfo;
	BOOL					bMarkedForDeletion;
	PCC_NONSTANDARDDATA		pLocalNonStandardData;
	PCC_NONSTANDARDDATA		pPeerNonStandardData;
	PCC_ADDR				pQ931LocalConnectAddr;
	PCC_ADDR				pQ931PeerConnectAddr;
	PCC_ADDR				pQ931DestinationAddr;
	PCC_ADDR				pSourceCallSignalAddress;
	PCC_TERMCAPLIST			pPeerH245TermCapList;
	PCC_TERMCAP				pPeerH245H2250MuxCapability;
	PCC_TERMCAPDESCRIPTORS	pPeerH245TermCapDescriptors;
	PCC_ALIASNAMES			pLocalAliasNames;
	PCC_ALIASNAMES			pPeerAliasNames;
	PCC_ALIASNAMES			pPeerExtraAliasNames;
	PCC_ALIASITEM			pPeerExtension;
	PWSTR					pszLocalDisplay;
	PWSTR					pszPeerDisplay;
	PCC_VENDORINFO			pPeerVendorInfo;
	DWORD_PTR				dwUserToken;
	TERMCAPSTATE			OutgoingTermCapState;	// NEED_TO_SEND_TERMCAP, AWAITING_ACK, or
													// TERMCAP_COMPLETE
	TERMCAPSTATE			IncomingTermCapState;	// AWAITING_TERMCAP or TERMCAP_COMPLETE
	MASTERSLAVESTATE		MasterSlaveState;
	struct Call_t			*pNext;
	struct Call_t			*pPrev;
	CALLSTATE				CallState;
	CALLTYPE				CallType;
	BOOL					bCallerIsMC;
	CC_CONFERENCEID			ConferenceID;
	BOOL					bLinkEstablished;
	H245_INST_T				H245Instance;
	DWORD					dwH245PhysicalID;
	WORD					wMasterSlaveRetry;
	GUID                    CallIdentifier;
#ifdef GATEKEEPER
   GKICALL           GkiCall;
#endif // GATEKEEPER
	BOOL					bInTable;
	struct Call_t			*pNextInTable;
	struct Call_t			*pPrevInTable;
	LOCK					Lock;
} CALL, *PCALL, **PPCALL;

// Channel types must be bit maps
#define TX_CHANNEL			0x01
#define RX_CHANNEL			0x02
#define TXRX_CHANNEL		0x04	// bi-directional channel
#define PROXY_CHANNEL		0x08
#define ALL_CHANNELS		(TX_CHANNEL | RX_CHANNEL | TXRX_CHANNEL | PROXY_CHANNEL)

typedef struct Channel_t {
	CC_HCHANNEL				hChannel;
	CC_HCONFERENCE			hConference;
	DWORD_PTR				dwUserToken;
	BYTE					bSessionID;
	BYTE					bAssociatedSessionID;
	WORD					wLocalChannelNumber;
	WORD					wRemoteChannelNumber;
	BOOL					bMultipointChannel;
	WORD					wNumOutstandingRequests;
	PCC_TERMCAP				pTxH245TermCap;
	PCC_TERMCAP				pRxH245TermCap;
	H245_MUX_T				*pTxMuxTable;
	H245_MUX_T				*pRxMuxTable;
	H245_ACCESS_T			*pSeparateStack;
	CC_HCALL				hCall;
	BYTE					bChannelType;
	BOOL					bCallbackInvoked;
	TRISTATE				tsAccepted;
	PCALL_QUEUE				pCloseRequests;
	PCC_ADDR				pLocalRTPAddr;
	PCC_ADDR				pLocalRTCPAddr;
	PCC_ADDR				pPeerRTPAddr;
	PCC_ADDR				pPeerRTCPAddr;
	DWORD                   dwChannelBitRate;
	BOOL					bLocallyOpened;
	struct Channel_t		*pNext;
	struct Channel_t		*pPrev;
	BOOL					bInTable;
	struct Channel_t		*pNextInTable;
	struct Channel_t		*pPrevInTable;
	LOCK					Lock;
} CHANNEL, *PCHANNEL, **PPCHANNEL;

typedef struct Listen_t {
	CC_HLISTEN				hListen;
	CC_ADDR					ListenAddr;
	DWORD_PTR				dwListenToken;
	CC_LISTEN_CALLBACK		ListenCallback;
	HQ931LISTEN				hQ931Listen;
	PCC_ALIASNAMES			pLocalAliasNames;	// local alias names
	BOOL					bInTable;
	struct Listen_t			*pNextInTable;
	struct Listen_t			*pPrevInTable;
	LOCK					Lock;
} LISTEN, *PLISTEN, **PPLISTEN;

typedef struct Hangup_t {
	HHANGUP					hHangup;
	CC_HCONFERENCE			hConference;
	DWORD_PTR				dwUserToken;
	WORD					wNumCalls;
	BOOL					bInTable;
	struct Hangup_t			*pNextInTable;
	struct Hangup_t			*pPrevInTable;
	LOCK					Lock;
} HANGUP, *PHANGUP, **PPHANGUP;

#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock();}

#define LeaveCallControlTop(f)     {CCLOCK_RelinquishLock(); \
                                    return f;}
#define EnterCallControl()
#define HResultLeaveCallControl(f) {return f;}
#define DWLeaveCallControl(f)      {return f;}

#else
#define EnterCallControlTop()  EnterCallControl()
#define LeaveCallControlTop(f) HResultLeaveCallControl(f)

#define EnterCallControl()         {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads++; \
									RelinquishLock(&ThreadCount.Lock);}

#define NullLeaveCallControl()     {AcquireLock(&ThreadCount.Lock); \
									ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return;}

#define HResultLeaveCallControl(f) {HRESULT stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}

#define DWLeaveCallControl(f)      {DWORD	stat; \
	                                stat = f; \
									AcquireLock(&ThreadCount.Lock); \
				                    ThreadCount.wNumThreads--; \
									RelinquishLock(&ThreadCount.Lock); \
                                    return stat;}
#endif



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\ccutils.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.107  $
 *	$Date:   04 Mar 1997 17:34:44  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "apierror.h"
#include "ccmain.h"
#include "chanman.h"
#include "confman.h"
#include "callman.h"
#include "q931man.h"
#include "userman.h"
#include "ccutils.h"
#include "linkapi.h"
#include "h245man.h"

extern CC_CONFERENCEID	InvalidConferenceID;



HANDLE ghCCLock = NULL;
HRESULT InitializeCCLock(VOID)
{
    ASSERT(ghCCLock == NULL);
    ghCCLock = CreateMutex(NULL, FALSE, NULL);	
    if(ghCCLock == NULL)
    {
        return CC_INTERNAL_ERROR;
	}
	else
	{
		return CC_OK;
    }
}
VOID UnInitializeCCLock()
{
    ASSERT(ghCCLock);
    if(ghCCLock)
    {
        CloseHandle(ghCCLock);
    }
}

VOID CCLOCK_AcquireLock()
{
    DWORD dwStatus;
    ASSERT(ghCCLock);
    dwStatus = WaitForSingleObject(ghCCLock, INFINITE);

  	if ((dwStatus != WAIT_OBJECT_0) && (dwStatus != WAIT_TIMEOUT))
  	{
		ASSERT(0);
	}
}

VOID CCLOCK_RelinquishLock()
{
    ASSERT(ghCCLock);
    ReleaseMutex(ghCCLock);
}

HRESULT InitializeLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	InitializeCriticalSection(&pLock->LockInfoLock);
	pLock->wLockCount = 0;
	pLock->wNumQueuedThreads = 0;
	pLock->hOwningThread = 0;
#endif

        pLock->Lock = CreateMutex(NULL, // security attributes
							  FALSE,	// initial owner
							  NULL);	// name

	if (pLock->Lock == NULL) {
#ifdef _DEBUG
		DeleteCriticalSection(&pLock->LockInfoLock);
#endif
		return CC_INTERNAL_ERROR;
	} else
		return CC_OK;
}



HRESULT DeleteLock(					PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	DeleteCriticalSection(&pLock->LockInfoLock);
#endif

	if (CloseHandle(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT AcquireLock(				PLOCK					pLock)
{
HRESULT	status;

	ASSERT(pLock != NULL);
	
	status = AcquireTimedLock(pLock, INFINITE, NULL);
	return status;
}



HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut)
{
DWORD	dwStatus;

	ASSERT(pLock != NULL);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)++;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	dwStatus = WaitForSingleObject(pLock->Lock, dwTimeout);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wNumQueuedThreads)--;
	(pLock->wLockCount)++;
	pLock->hOwningThread = GetCurrentThread();
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if ((dwStatus != WAIT_OBJECT_0) && (dwStatus != WAIT_TIMEOUT))
		return CC_INTERNAL_ERROR;

	if (dwStatus == WAIT_TIMEOUT) {
		if (pbTimedOut != NULL) {
			*pbTimedOut = TRUE;
		}
	} else {
		if (pbTimedOut != NULL) {
			*pbTimedOut = FALSE;
		}
	}
	return CC_OK;
}



HRESULT RelinquishLock(				PLOCK					pLock)
{
	ASSERT(pLock != NULL);

#ifdef _DEBUG
	EnterCriticalSection(&pLock->LockInfoLock);
	(pLock->wLockCount)--;
	if (pLock->wLockCount == 0)
		pLock->hOwningThread = 0;
	LeaveCriticalSection(&pLock->LockInfoLock);
#endif

	if (ReleaseMutex(pLock->Lock) == TRUE)
		return CC_OK;
	else
		return CC_INTERNAL_ERROR;
}



HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString == NULL))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_OCTETSTRING)MemAlloc(sizeof(CC_OCTETSTRING));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	(*ppDest)->wOctetStringLength = pSource->wOctetStringLength;
	if ((pSource->wOctetStringLength == 0) ||
		(pSource->pOctetString == NULL)) {
		pSource->wOctetStringLength = 0;
		(*ppDest)->pOctetString = NULL;
	} else {
		(*ppDest)->pOctetString = (BYTE *)MemAlloc(pSource->wOctetStringLength);
		if ((*ppDest)->pOctetString == NULL) {
			MemFree(*ppDest);
			*ppDest = NULL;
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->pOctetString, pSource->pOctetString, pSource->wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString)
{
	if (pOctetString == NULL)
		return CC_OK;
	if ((pOctetString->wOctetStringLength > 0) &&
		(pOctetString->pOctetString != NULL))
		MemFree(pOctetString->pOctetString);
	MemFree(pOctetString);
	return CC_OK;
}



HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	// We currently can't handle IP source route addresses,
	// since this address format contains embedded pointers
	// that cannot simply be copied
	if ((pSource->networkAddress.choice == localAreaAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.choice == unicastAddress_chosen) &&
		(pSource->networkAddress.u.localAreaAddress.u.unicastAddress.choice == iPSourceRouteAddress_chosen))
		return CC_NOT_IMPLEMENTED;

    *ppDest = (H245_ACCESS_T *)MemAlloc(sizeof(H245_ACCESS_T));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;

	**ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack)
{
	if (pSeparateStack == NULL)
		return CC_OK;
	MemFree(pSeparateStack);
	return CC_OK;
}



HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	return ValidateOctetString(&pNonStandardData->sData);
}



HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_NONSTANDARDDATA)MemAlloc(sizeof(CC_NONSTANDARDDATA));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	if ((pSource->sData.wOctetStringLength == 0) ||
		(pSource->sData.pOctetString == NULL)) {
		(*ppDest)->sData.wOctetStringLength = 0;
		(*ppDest)->sData.pOctetString = NULL;
	} else {
		(*ppDest)->sData.pOctetString = (BYTE *)MemAlloc(pSource->sData.wOctetStringLength);
		if ((*ppDest)->sData.pOctetString == NULL) {
			MemFree(*ppDest);
			return CC_NO_MEMORY;
		}
		memcpy((*ppDest)->sData.pOctetString,
			   pSource->sData.pOctetString,
			   pSource->sData.wOctetStringLength);
	}
    return CC_OK;
}



HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData)
{
	if (pNonStandardData == NULL)
		return CC_OK;
	if ((pNonStandardData->sData.wOctetStringLength > 0) &&
		(pNonStandardData->sData.pOctetString != NULL))
		MemFree(pNonStandardData->sData.pOctetString);
	MemFree(pNonStandardData);
	return CC_OK;
}



HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo)
{
HRESULT		status;

	if (pVendorInfo == NULL)
		return CC_OK;
	status = ValidateOctetString(pVendorInfo->pProductNumber);
	if (status != CC_OK)
		return status;
	status = ValidateOctetString(pVendorInfo->pVersionNumber);
	return status;
}



HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource)
{
HRESULT		status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_VENDORINFO)MemAlloc(sizeof(CC_VENDORINFO));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	**ppDest = *pSource;
	status = CopyOctetString(&(*ppDest)->pProductNumber, pSource->pProductNumber);
	if (status != CC_OK) {
		MemFree(*ppDest);
		return status;
	}
	status = CopyOctetString(&(*ppDest)->pVersionNumber, pSource->pVersionNumber);
	if (status != CC_OK) {
		FreeOctetString((*ppDest)->pProductNumber);
		MemFree(*ppDest);
		return status;
	}
    return CC_OK;
}



HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo)
{
	if (pVendorInfo == NULL)
		return CC_OK;
	FreeOctetString(pVendorInfo->pProductNumber);
	FreeOctetString(pVendorInfo->pVersionNumber);
	MemFree(pVendorInfo);
	return CC_OK;
}



BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2)
{
	ASSERT(pConferenceID1 != NULL);
	ASSERT(pConferenceID2 != NULL);

	if (memcmp(pConferenceID1->buffer,
	           pConferenceID2->buffer,
			   sizeof(pConferenceID1->buffer)) == 0)
		return TRUE;
	else
		return FALSE;
}



BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2)
{
	ASSERT(pAddr1 != NULL);
	ASSERT(pAddr2 != NULL);

	if (pAddr1->nAddrType != pAddr2->nAddrType)
		return FALSE;

	if (pAddr1->bMulticast != pAddr2->bMulticast)
		return FALSE;

	switch (pAddr1->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if ((pAddr1->Addr.IP_DomainName.wPort == pAddr2->Addr.IP_DomainName.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_DomainName.cAddr, pAddr2->Addr.IP_DomainName.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_DOT:
			if ((pAddr1->Addr.IP_Dot.wPort == pAddr2->Addr.IP_Dot.wPort) &&
			    (wcscmp(pAddr1->Addr.IP_Dot.cAddr, pAddr2->Addr.IP_Dot.cAddr) == 0))
				return TRUE;
			else
				return FALSE;
		case CC_IP_BINARY:
			if ((pAddr1->Addr.IP_Binary.wPort == pAddr2->Addr.IP_Binary.wPort) &&
			    (pAddr1->Addr.IP_Binary.dwAddr == pAddr2->Addr.IP_Binary.dwAddr))
				return TRUE;
			else
				return FALSE;
		default:
			ASSERT(0);
			return FALSE;
	}
}



HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList)
{
unsigned    i, j;

	if (pTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapList->wLength; i++)
		if (pTermCapList->pTermCapArray[i] == NULL)
		return CC_BAD_PARAM;

	// make sure that all capability IDs are unique
	for (i = 0; i < pTermCapList->wLength; i++) {
		for (j = i + 1; j < pTermCapList->wLength; j++) {
			if (pTermCapList->pTermCapArray[i]->CapId == pTermCapList->pTermCapArray[j]->CapId)
				return CC_BAD_PARAM;
		}
		if ((pTermCapList->pTermCapArray[i]->CapId == H245_INVALID_CAPID) ||
			(pTermCapList->pTermCapArray[i]->CapId == 0))
			return CC_BAD_PARAM;
	}
	return CC_OK;
}



HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD				i, j, k, l;
H245_TOTCAPDESC_T	*pTermCapDescriptor;
H245_SIMCAP_T		*pSimCaps;

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		if ((pTermCapDescriptor->CapDescId > 255) ||
			(pTermCapDescriptor->CapDesc.Length == 0) ||
			(pTermCapDescriptor->CapDesc.Length > H245_MAX_SIMCAPS))
			return CC_BAD_PARAM;
		for (j = i + 1; j < pTermCapDescriptors->wLength; j++) {
			if (pTermCapDescriptor->CapDescId ==
				pTermCapDescriptors->pTermCapDescriptorArray[j]->CapDescId) {
				return CC_BAD_PARAM;
			}
		}
		for (j = 0; j < pTermCapDescriptor->CapDesc.Length; j++) {
			pSimCaps = &(pTermCapDescriptor->CapDesc.SimCapArray[j]);
			if ((pSimCaps->Length == 0) ||
				(pSimCaps->Length > H245_MAX_ALTCAPS))
				return CC_BAD_PARAM;
			for (k = 0; k < pSimCaps->Length; k++) {
				for (l = 0; l < pTermCapList->wLength; l++) {
					if (pSimCaps->AltCaps[k] ==
						pTermCapList->pTermCapArray[l]->CapId)
						break;
				}
				if (l == pTermCapList->wLength)
					// the capability descriptor contains a capability ID
					// which is not present in the capability table
					return CC_BAD_PARAM;
			}
		}
	}
	return CC_OK;
}



HRESULT ValidateAddr(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	if ((pAddr->nAddrType != CC_IP_DOMAIN_NAME) &&
		(pAddr->nAddrType != CC_IP_DOT) &&
		(pAddr->nAddrType != CC_IP_BINARY))
		return CC_BAD_PARAM;
	return CC_OK;
}



HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
    **ppDest = *pSource;
    return CC_OK;
}



HRESULT FreeAddr(					PCC_ADDR				pAddr)
{
    if (pAddr == NULL)
        return CC_OK;
    MemFree(pAddr);
    return CC_OK;
}



HRESULT SetQ931Port(				PCC_ADDR				pAddr)
{
	if (pAddr == NULL)
		return CC_OK;
	switch (pAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			if (pAddr->Addr.IP_DomainName.wPort == 0)
				pAddr->Addr.IP_DomainName.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_DOT:
			if (pAddr->Addr.IP_Dot.wPort == 0)
				pAddr->Addr.IP_Dot.wPort = CC_H323_HOST_CALL;
			return CC_OK;
		case CC_IP_BINARY:
			if (pAddr->Addr.IP_Binary.wPort == 0)
				pAddr->Addr.IP_Binary.wPort = CC_H323_HOST_CALL;
			return CC_OK;
	}

	ASSERT(0);
	return CC_INTERNAL_ERROR;
}



HRESULT ValidateDisplay(			PWSTR					pszDisplay)
{
	return CC_OK;
}



HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource)
{
	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }
    *ppDest = (WCHAR *)MemAlloc((wcslen(pSource)+1)*sizeof(WCHAR));
    if (*ppDest == NULL)
        return CC_NO_MEMORY;
	wcscpy(*ppDest, pSource);
    return CC_OK;
}



HRESULT FreeDisplay(				PWSTR					pszDisplay)
{
	MemFree(pszDisplay);
	return CC_OK;
}



HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID)
{
	return ValidateOctetString(pTerminalID);
}



HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource)
{
	ASSERT(ppDest != NULL);

    return CopyOctetString(ppDest, pSource);
}



HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID)
{
    return FreeOctetString(pTerminalID);
}



HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType)
{
	switch (tsMultipointController) {
		case TS_TRUE:
			*pbTerminalType = 240;
			break;
		case TS_UNKNOWN:
			*pbTerminalType = 70;
			break;
		case TS_FALSE:
			*pbTerminalType = 50;
			break;
		default:
			ASSERT(0);
			*pbTerminalType = 0;
			break;
	}
	return CC_OK;
}



HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource)
{
WORD	i;
HRESULT	status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapArray =
		(PPCC_TERMCAP)MemAlloc(sizeof(PCC_TERMCAP) * pSource->wLength);
	if ((*ppDest)->pTermCapArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapList(ppDest);
		return CC_NO_MEMORY;
	}
	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCap(&((*ppDest)->pTermCapArray[i]), pSource->pTermCapArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapList(ppDest);
			return status;
		}
	}
	return CC_OK;
}



HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource)
{
WORD		i;
HRESULT		status;

	ASSERT(ppDest != NULL);

    if (pSource == NULL) {
        *ppDest = NULL;
        return CC_OK;
    }

	(*ppDest) = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	(*ppDest)->wLength = pSource->wLength;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *) *
			                                                pSource->wLength);
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	for (i = 0; i < pSource->wLength; i++) {
		status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[i]),
									   pSource->pTermCapDescriptorArray[i]);
		if (status != H245_ERROR_OK) {
			(*ppDest)->wLength = i;
			DestroyH245TermCapDescriptors(ppDest);
			return status;	
		}
	}
	return CC_OK;
}



HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList)
{
H245_TOTCAPDESC_T	TermCapDescriptor;
WORD				i;
HRESULT				status;

	ASSERT(ppDest != NULL);

	if (pTermCapList == NULL) {
		*ppDest = NULL;
        return CC_OK;
    }

	*ppDest = (PCC_TERMCAPDESCRIPTORS)MemAlloc(sizeof(CC_TERMCAPDESCRIPTORS));
	if (*ppDest == NULL)
		return CC_NO_MEMORY;

	if (pTermCapList->wLength == 0) {
		(*ppDest)->wLength = 0;
		(*ppDest)->pTermCapDescriptorArray = NULL;
		return CC_OK;
	}

	(*ppDest)->wLength = 1;
	(*ppDest)->pTermCapDescriptorArray = (H245_TOTCAPDESC_T **)MemAlloc(sizeof(H245_TOTCAPDESC_T *));
	if ((*ppDest)->pTermCapDescriptorArray == NULL) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return CC_NO_MEMORY;
	}

	TermCapDescriptor.CapDesc.Length = pTermCapList->wLength;
	TermCapDescriptor.CapDescId = 0;

	for (i = 0; i < pTermCapList->wLength; i++) {
		TermCapDescriptor.CapDesc.SimCapArray[i].Length = 1;
		TermCapDescriptor.CapDesc.SimCapArray[i].AltCaps[0] =
			pTermCapList->pTermCapArray[i]->CapId;
	}

	status = H245CopyCapDescriptor(&((*ppDest)->pTermCapDescriptorArray[0]),
								   &TermCapDescriptor);
	if (status != H245_ERROR_OK) {
		(*ppDest)->wLength = 0;
		DestroyH245TermCapDescriptors(ppDest);
		return status;	
	}
	return CC_OK;
}



HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap)
{
	ASSERT(ppTermCap != NULL);

	if (*ppTermCap == NULL)
		return CC_OK;

	H245FreeCap(*ppTermCap);
	*ppTermCap = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapListFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapList == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapList->wLength; i++) {
		ASSERT(pTermCapList->pTermCapArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelLocalCap(pCall->H245Instance,
								         pTermCapList->pTermCapArray[i]->CapId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList)
{
WORD		i;

	ASSERT(ppTermCapList != NULL);

	if (*ppTermCapList == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapList)->wLength; i++) {
		ASSERT((*ppTermCapList)->pTermCapArray[i] != NULL);
	H245FreeCap((*ppTermCapList)->pTermCapArray[i]);
	}
	if ((*ppTermCapList)->pTermCapArray != NULL)
		MemFree((*ppTermCapList)->pTermCapArray);
	MemFree(*ppTermCapList);
	*ppTermCapList = NULL;
	return CC_OK;
}



HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors)
{
WORD		i, j;
PCALL		pCall;
PCC_HCALL	CallList;
WORD		wNumCalls;
HRESULT		status;
HRESULT		SaveStatus;

	ASSERT(pConference != NULL);

	if (pTermCapDescriptors == NULL)
		return CC_OK;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	SaveStatus = CC_OK;
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		ASSERT(pTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
		for (j = 0; j < wNumCalls; j++) {
			if (LockCall(CallList[j], &pCall) == CC_OK) {
				status = H245DelCapDescriptor(pCall->H245Instance,
									          pTermCapDescriptors->pTermCapDescriptorArray[i]->CapDescId);
				if (status != CC_OK)
					SaveStatus = status;
				UnlockCall(pCall);
			}
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	return SaveStatus;
}



HRESULT DestroyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors)
{
WORD				i;

	ASSERT(ppTermCapDescriptors != NULL);

	if (*ppTermCapDescriptors == NULL)
		return CC_OK;

	for (i = 0; i < (*ppTermCapDescriptors)->wLength; i++) {
		ASSERT((*ppTermCapDescriptors)->pTermCapDescriptorArray[i] != NULL);
		H245FreeCapDescriptor((*ppTermCapDescriptors)->pTermCapDescriptorArray[i]);
	}
	if ((*ppTermCapDescriptors)->pTermCapDescriptorArray != NULL)
		MemFree((*ppTermCapDescriptors)->pTermCapDescriptorArray);
	MemFree(*ppTermCapDescriptors);
	*ppTermCapDescriptors = NULL;
	return CC_OK;
}



HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr)
{
	if (NetworkArray == NULL) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	NetworkArray[0] = HIBYTE(HIWORD(dwAddr));
	NetworkArray[1] = LOBYTE(HIWORD(dwAddr));
	NetworkArray[2] = HIBYTE(LOWORD(dwAddr));
	NetworkArray[3] = LOBYTE(LOWORD(dwAddr));

	return CC_OK;
}



HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray)
{
	if ((pdwAddr == NULL) || (NetworkArray == NULL)) {
		ASSERT(0);
		return CC_BAD_PARAM;
	}

	*pdwAddr = NetworkArray[0] * 0x01000000 +
		       NetworkArray[1] * 0x00010000 +
			   NetworkArray[2] * 0x00000100 +
			   NetworkArray[3] * 0x00000001;

	return CC_OK;
}



HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason)
{
PCALL								pCall;
CC_HCONFERENCE						hConference;
PCONFERENCE							pConference;
HRESULT								status;
HQ931CALL							hQ931Call;
H245_INST_T							H245Instance;
PCHANNEL							pChannel;
WORD								wNumChannels;
PCC_HCHANNEL						ChannelList;
WORD								i;
WORD								wNumCalls;
PCC_HCALL							CallList;
PCALL								pOldCall;
CC_CONNECT_CALLBACK_PARAMS			ConnectCallbackParams;
CC_PEER_DROP_CALLBACK_PARAMS		PeerDropCallbackParams;
CC_PEER_CHANGE_CAP_CALLBACK_PARAMS	PeerChangeCapCallbackParams;
BOOL								bConferenceTermCapsChanged;
HRESULT								CallbackStatus;

	if (hCall == CC_INVALID_HANDLE)
		return CC_BAD_PARAM;

	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK)
		return CC_BAD_PARAM;

	hConference = pCall->hConference;
	hQ931Call = pCall->hQ931Call;
	H245Instance = pCall->H245Instance;
	PeerDropCallbackParams.hCall = pCall->hCall;
	if (pCall->pPeerParticipantInfo == NULL) {
		PeerDropCallbackParams.TerminalLabel.bMCUNumber = 255;
		PeerDropCallbackParams.TerminalLabel.bTerminalNumber = 255;
		PeerDropCallbackParams.pPeerTerminalID = NULL;
	} else {
		PeerDropCallbackParams.TerminalLabel = pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel;
		if (pCall->pPeerParticipantInfo->TerminalIDState == TERMINAL_ID_VALID)
			PeerDropCallbackParams.pPeerTerminalID = &pCall->pPeerParticipantInfo->ParticipantInfo.TerminalID;
		else
			PeerDropCallbackParams.pPeerTerminalID = NULL;
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE))
		CreateConferenceTermCaps(pConference, &bConferenceTermCapsChanged);
	else
		bConferenceTermCapsChanged = FALSE;

	// Remove all TX, RX and PROXY channels associated with this call
	EnumerateChannelsInConference(&wNumChannels,
								  &ChannelList,
								  pConference,
								  TX_CHANNEL | RX_CHANNEL | PROXY_CHANNEL);
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK) {
			if (pChannel->hCall == hCall)
				FreeChannel(pChannel);
			else
				UnlockChannel(pChannel);
		}
	}
	if (ChannelList != NULL)
		MemFree(ChannelList);

	switch (bHangupReason)
	{
	case CC_REJECT_NORMAL_CALL_CLEARING:
		CallbackStatus = CC_OK;
		break;
	case CC_REJECT_GATEKEEPER_TERMINATED:
		CallbackStatus = CC_GATEKEEPER_REFUSED;
		bHangupReason = CC_REJECT_NORMAL_CALL_CLEARING;
		break;
	default:
		CallbackStatus = CC_PEER_REJECT;
	} // switch

	if (pCall->CallType == THIRD_PARTY_INVITOR) {
		MarkCallForDeletion(pCall);

		ConnectCallbackParams.pNonStandardData = pCall->pPeerNonStandardData;
		ConnectCallbackParams.pszPeerDisplay = pCall->pszPeerDisplay;
		ConnectCallbackParams.bRejectReason = bHangupReason;
		ConnectCallbackParams.pTermCapList = pCall->pPeerH245TermCapList;
		ConnectCallbackParams.pH2250MuxCapability = pCall->pPeerH245H2250MuxCapability;
		ConnectCallbackParams.pTermCapDescriptors = pCall->pPeerH245TermCapDescriptors;
		ConnectCallbackParams.pLocalAddr = pCall->pQ931LocalConnectAddr;
 		if (pCall->pQ931DestinationAddr == NULL)
			ConnectCallbackParams.pPeerAddr = pCall->pQ931PeerConnectAddr;
		else
			ConnectCallbackParams.pPeerAddr = pCall->pQ931DestinationAddr;
		ConnectCallbackParams.pVendorInfo = pCall->pPeerVendorInfo;
		ConnectCallbackParams.bMultipointConference = TRUE;
		ConnectCallbackParams.pConferenceID = &pConference->ConferenceID;
		ConnectCallbackParams.pMCAddress = pConference->pMultipointControllerAddr;
		ConnectCallbackParams.pAlternateAddress = NULL;
		ConnectCallbackParams.dwUserToken = pCall->dwUserToken;
		InvokeUserConferenceCallback(pConference,
									 CC_CONNECT_INDICATION,
									 CallbackStatus,
									 &ConnectCallbackParams);
		// Need to validate the conference and call handles; the associated
		// objects may have been deleted during user callback on this thread
		if (ValidateConference(hConference) == CC_OK)
			UnlockConference(pConference);
		if (ValidateCallMarkedForDeletion(hCall) == CC_OK)
			FreeCall(pCall);
		Q931Hangup(hQ931Call, bHangupReason);
		return CC_OK;
	}

	if (pCall->CallType == THIRD_PARTY_INTERMEDIARY) {
		if ((hQ931Initiator == pCall->hQ931CallInvitor) &&
		    (hQ931Initiator != CC_INVALID_HANDLE)) {
			pCall->hQ931CallInvitor = CC_INVALID_HANDLE;
			UnlockCall(pCall);
			UnlockConference(pConference);
			return CC_OK;
		} else {
			if (pCall->CallState != CALL_COMPLETE) {
				if (pCall->hQ931CallInvitor != CC_INVALID_HANDLE)
					Q931Hangup(pCall->hQ931CallInvitor, CC_REJECT_UNDEFINED_REASON);
				if (ValidateCall(hCall) == CC_OK)
					Q931Hangup(pCall->hQ931Call, bHangupReason);
			}
		}
	}

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		if (pCall->pPeerParticipantInfo != NULL) {
			EnumerateCallsInConference(&wNumCalls,
									   &CallList,
									   pConference,
									   ESTABLISHED_CALL);
			for (i = 0; i < wNumCalls; i++) {
				if (CallList[i] != hCall) {
					if (LockCall(CallList[i], &pOldCall) == CC_OK) {
						if (pCall->pPeerParticipantInfo != NULL)
							H245ConferenceIndication(
											 pOldCall->H245Instance,
											 H245_IND_TERMINAL_LEFT,	// Indication Type
											 0,							// SBE number; ignored here
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber,	// MCU number
											 pCall->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber);
						if (bConferenceTermCapsChanged)
							// Send new term caps
							SendTermCaps(pOldCall, pConference);
						UnlockCall(pOldCall);
					}
				}
			}
			if (CallList != NULL)
				MemFree(CallList);
		}

		InvokeUserConferenceCallback(pConference,
						 CC_PEER_DROP_INDICATION,
						 CC_OK,
						 &PeerDropCallbackParams);
		
		if (ValidateCall(hCall) == CC_OK)
			FreeCall(pCall);

		if (ValidateConference(hConference) == CC_OK) {
			if (bConferenceTermCapsChanged) {
				// Generate CC_PEER_CHANGE_CAP callback
				PeerChangeCapCallbackParams.pTermCapList =
					pConference->pConferenceTermCapList;
				PeerChangeCapCallbackParams.pH2250MuxCapability =
					pConference->pConferenceH245H2250MuxCapability;
				PeerChangeCapCallbackParams.pTermCapDescriptors =
					pConference->pConferenceTermCapDescriptors;
				InvokeUserConferenceCallback(pConference,
											 CC_PEER_CHANGE_CAP_INDICATION,
											 CC_OK,
											 &PeerChangeCapCallbackParams);
			}
		}

		if (ValidateConference(hConference) == CC_OK) {
			if (pConference->bDeferredDelete) {
				ASSERT(pConference->LocalEndpointAttached == DETACHED);
				EnumerateCallsInConference(&wNumCalls, NULL, pConference, ALL_CALLS);
				if (wNumCalls == 0) {
					FreeConference(pConference);
					return CC_OK;
				}
			}
			UnlockConference(pConference);
		}
		return CC_OK;
	} else {
		status = EnumerateChannelsInConference(&wNumChannels,
			                                   &ChannelList,
											   pConference,
											   ALL_CHANNELS);
		if (status == CC_OK) {
			// free all the channels
			for (i = 0; i < wNumChannels; i++) {
				if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
					// Notice that since we're going to hangup, we don't need to
					// close any channels
					FreeChannel(pChannel);	
			}
			if (ChannelList != NULL)
				MemFree(ChannelList);
		}

		if (H245Instance != H245_INVALID_ID)
			status = H245ShutDown(H245Instance);
		else
			status = H245_ERROR_OK;
	
		if (status == H245_ERROR_OK) {
			status = Q931Hangup(hQ931Call, CC_REJECT_NORMAL_CALL_CLEARING);
			// Q931Hangup may legitimately return CS_BAD_PARAM, because the Q.931 call object
			// may have been deleted at this point
			if (status == CS_BAD_PARAM)
				status = CC_OK;
		} else
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);

		if (pConference->bDeferredDelete) {
			ASSERT(pConference->LocalEndpointAttached == DETACHED);
			FreeConference(pConference);
		} else {
			ReInitializeConference(pConference);

			InvokeUserConferenceCallback(pConference,
										 CC_CONFERENCE_TERMINATION_INDICATION,
										 CallbackStatus,
										 NULL);

			if (ValidateConference(hConference) == CC_OK)
				UnlockConference(pConference);
		}
		return CC_OK;
	}
	// We should never reach this point
	ASSERT(0);
}



HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD_PTR				dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD			i;
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumChannels;
PCC_HCHANNEL	ChannelList;
PCHANNEL		pChannel;
WORD			wNumCalls;
PCC_HCALL		CallList;
PCALL			pCall;
BYTE			bSessionID;
WORD			wPort;
DWORD			dwAddr;
WCHAR			szSessionDescription[100];
WCHAR			ss[10];

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppSessionTable != NULL);
	
	if (*ppSessionTable != NULL) {
		for (i = 0; i < (*ppSessionTable)->wLength; i++) {
			if ((*ppSessionTable)->SessionInfoArray[i].pTermCap != NULL)
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
			FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr);
		}
		if ((*ppSessionTable)->SessionInfoArray != NULL)
			MemFree((*ppSessionTable)->SessionInfoArray);
		MemFree(*ppSessionTable);
		*ppSessionTable = NULL;
	}

	if (bCreate == FALSE)
		return CC_OK;

	*ppSessionTable = NULL;
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if ((pConference->ConferenceMode == UNCONNECTED_MODE) ||
	    (pConference->ConferenceMode == POINT_TO_POINT_MODE)) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	// pConference->ConferenceMode == MULTIPOINT_MODE
	// Create one session entry for each open channel on this conference

	bSessionID = 1;
	wPort = 2050;

	// Set dwAddr
	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);
	if (wNumCalls == 0) {
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	status = LockCall(CallList[0], &pCall);
	if (status != CC_OK) {
		MemFree(CallList);
		UnlockConference(pConference);
		return status;
	}

	if (pCall->pQ931LocalConnectAddr == NULL) {
		MemFree(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	if (pCall->pQ931LocalConnectAddr->nAddrType != CC_IP_BINARY) {
		MemFree(CallList);
		UnlockCall(pCall);
		UnlockConference(pConference);
		return CC_INTERNAL_ERROR;
	}

	// Construct dwAddr from one of the unicast Q.931 addresses by setting the high
	// nibble of the Q.931 address to 0xE
	dwAddr = (pCall->pQ931LocalConnectAddr->Addr.IP_Binary.dwAddr & 0xEFFFFFFF) | 0xE0000000;

	UnlockCall(pCall);
	MemFree(CallList);
	
	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);
	
	*ppSessionTable = (PCC_SESSIONTABLE)MemAlloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL) {
		MemFree(ChannelList);
		UnlockConference(pConference);
		return CC_NO_MEMORY;
	}
	(*ppSessionTable)->wLength = wNumChannels;
	if (wNumChannels == 0)
		(*ppSessionTable)->SessionInfoArray = NULL;
	else {
		(*ppSessionTable)->SessionInfoArray =
			(PCC_SESSIONINFO)MemAlloc(sizeof(CC_SESSIONINFO) * wNumChannels);
		if ((*ppSessionTable)->SessionInfoArray == NULL) {
			MemFree(ChannelList);
			UnlockConference(pConference);
			(*ppSessionTable)->wLength = 0;
			DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
			return CC_NO_MEMORY;
		}
		for (i = 0; i < wNumChannels; i++) {
			(*ppSessionTable)->SessionInfoArray[i].bSessionID = bSessionID++;

			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;

			wcscpy(szSessionDescription, L"Session ");
			_itow((int)(*ppSessionTable)->SessionInfoArray[i].bSessionID,
				  ss, 10);
			wcscat(szSessionDescription, ss);
	
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
				(WORD)((wcslen(szSessionDescription)+1)*sizeof(WCHAR));
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)MemAlloc((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				    szSessionDescription,
					(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength);
			
			status = LockChannel(ChannelList[i], &pChannel);
			if (status != CC_OK) {
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
				                 pChannel->pTxH245TermCap);
			UnlockChannel(pChannel);
			if (status != H245_ERROR_OK) {
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return status;
			}
			
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr =
				(PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr = dwAddr;
			
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr =
				(PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				FreeAddr((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppSessionTable)->wLength = i;
				DefaultSessionTableConstructor(
								hConference,
								dwConferenceToken,
								FALSE,	// bCreate,
								NULL,	// pbSessionTableChanged,
								0,		// wListCount,
								NULL,	// pTermCapList[],
								NULL,	// pTermCapDescriptors[],
								ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort = wPort++;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr = dwAddr;
		}
	}

	MemFree(ChannelList);
	UnlockConference(pConference);
	if (pbSessionTableChanged != NULL)
		*pbSessionTableChanged = TRUE;

	return CC_OK;
}



HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD_PTR						dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors)
{
HRESULT				status;
PCONFERENCE			pConference;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
WORD				i;
PCHANNEL			pChannel;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppOutTermCapList != NULL);
	ASSERT(ppOutTermCapDescriptors != NULL);
	
	if (*ppOutTermCapList != NULL) {
		DestroyH245TermCapList(ppOutTermCapList);
		*ppOutTermCapList = NULL;
	}

	if (*ppOutTermCapDescriptors != NULL) {
		DestroyH245TermCapDescriptors(ppOutTermCapDescriptors);
		*ppOutTermCapDescriptors = NULL;
	}
	
	if (bCreate == FALSE)
		return CC_OK;

	*ppOutTermCapList = NULL;
	*ppOutTermCapDescriptors = NULL;
	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = FALSE;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	if (pConference->LocalEndpointAttached == NEVER_ATTACHED) {
		// Copy the local term caps to the conference term caps
		status = CopyH245TermCapList(ppOutTermCapList, pConference->pLocalH245TermCapList);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}

		// Copy the local term cap descriptors to the conference term cap descriptors
		status = CopyH245TermCapDescriptors(ppOutTermCapDescriptors, pConference->pLocalH245TermCapDescriptors);
		if (status != CC_OK) {
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
	} else { // pConference->LocalEndpointAttached != NEVER_ATTACHED
		// Create one term cap entry for each open channel on this conference
		
		EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, TX_CHANNEL);

		*ppOutTermCapList = (PCC_TERMCAPLIST)MemAlloc(sizeof(CC_TERMCAPLIST));
		if (*ppOutTermCapList == NULL) {
			MemFree(ChannelList);
			UnlockConference(pConference);
			return CC_NO_MEMORY;
		}
		(*ppOutTermCapList)->wLength = wNumChannels;
		if (wNumChannels == 0)
			(*ppOutTermCapList)->pTermCapArray = NULL;
		else {
			(*ppOutTermCapList)->pTermCapArray =
				(PPCC_TERMCAP)MemAlloc(sizeof(PCC_TERMCAP) * wNumChannels);
			if ((*ppOutTermCapList)->pTermCapArray == NULL) {
				MemFree(ChannelList);
				UnlockConference(pConference);
				(*ppOutTermCapList)->wLength = 0;
				DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
				return CC_NO_MEMORY;
			}
			for (i = 0; i < wNumChannels; i++) {
				status = LockChannel(ChannelList[i], &pChannel);
				if (status != CC_OK) {
					MemFree(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return CC_NO_MEMORY;
				}
				status = H245CopyCap(&((*ppOutTermCapList)->pTermCapArray[i]),
									 pChannel->pTxH245TermCap);
				UnlockChannel(pChannel);
				if (status != H245_ERROR_OK) {
					MemFree(ChannelList);
					UnlockConference(pConference);
					(*ppOutTermCapList)->wLength = i;
					DefaultTermCapConstructor(
										hConference,
										dwConferenceToken,
										FALSE,		// bCreate
										NULL,		// pbTermCapsChanged
										0,			// wListCount
										NULL,		// pInTermCapList[]
										NULL,		// pInTermCapDescriptors[]
										ppOutTermCapList,
										ppOutTermCapDescriptors);
					return status;
				}

				(*ppOutTermCapList)->pTermCapArray[i]->Dir = H245_CAPDIR_LCLRXTX;
				(*ppOutTermCapList)->pTermCapArray[i]->CapId = (WORD)(i+1);
			}
		}

		MemFree(ChannelList);
		UnlockConference(pConference);

		// create a new descriptor list
		status = CreateH245DefaultTermCapDescriptors(ppOutTermCapDescriptors,
													 *ppOutTermCapList);
		if (status != CC_OK) {
			DefaultTermCapConstructor(
							hConference,
							dwConferenceToken,
							FALSE,		// bCreate
							NULL,		// pbTermCapsChanged
							0,			// wListCount
							NULL,		// pInTermCapList[]
							NULL,		// pInTermCapDescriptors[]
							ppOutTermCapList,
							ppOutTermCapDescriptors);
			return CC_NO_MEMORY;
		}
	}  // pConference->LocalEndpointAttached != NEVER_ATTACHED

	if (pbTermCapsChanged != NULL)
		*pbTermCapsChanged = TRUE;

	return CC_OK;
}



HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_HCALL			hCall;
CC_HCONFERENCE		hConference;
HQ931CALL			hQ931Call;
CC_CONFERENCEID		ConferenceID;
BYTE				bTerminalType;
CC_ADDR				H245Addr;
H245_INST_T			H245Instance;
PCC_VENDORINFO		pVendorInfo;
PCC_NONSTANDARDDATA	pNonStandardData;
PWSTR				pszDisplay;
CC_ENDPOINTTYPE		DestinationEndpointType;
TRISTATE			tsMultipointController;
DWORD               dwLinkLayerPhysicalId;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	hCall = pCall->hCall;
	hConference = pConference->hConference;
	hQ931Call = pCall->hQ931Call;
	ConferenceID = pCall->ConferenceID;
	pCall->hConference = pConference->hConference;

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		return status;
	}

	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		return status;
	}

	status = MakeH245PhysicalID(&pCall->dwH245PhysicalID);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	if (pCall->bCallerIsMC) {
		ASSERT(pConference->tsMultipointController != TS_TRUE);
		ASSERT(pConference->bMultipointCapable == TRUE);
		tsMultipointController = TS_FALSE;
	} else
		tsMultipointController = pConference->tsMultipointController;

    //MULTITHREAD
    //Use a tmp ID so we don't clobber the chosen H245Id.
    //   H245Id=>
    //   <= linkLayerId
    dwLinkLayerPhysicalId = INVALID_PHYS_ID;

	SetTerminalType(tsMultipointController, &bTerminalType);
	pCall->H245Instance = H245Init(H245_CONF_H323,			// configuration
                                   pCall->dwH245PhysicalID,    // H245 physical ID
                                   &dwLinkLayerPhysicalId,     // the link layer ID is returned
								   hCall,					// dwPreserved
								   (H245_CONF_IND_CALLBACK_T)H245Callback, // callback
								   bTerminalType);			
	if (pCall->H245Instance == H245_INVALID_ID) {
		// H245 initialization failure
		UnlockConference(pConference);
		FreeCall(pCall);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return CC_INTERNAL_ERROR;
	}

	H245Instance = pCall->H245Instance;

	// Set the H.245 TCP/IP address to the same IP address on which
	// the Q.931 connection was made; this ensures that if the host
	// is multi-homed, the H.245 will be made on the same IP address
	// as the Q.931 connection.  Set the initial H.245 port to zero,
	// so that it will be dynamically determined.
	ASSERT(pCall->pQ931LocalConnectAddr != NULL);
	H245Addr = *pCall->pQ931LocalConnectAddr;

	switch (pCall->pQ931LocalConnectAddr->nAddrType) {
		case CC_IP_DOMAIN_NAME:
			H245Addr.Addr.IP_DomainName.wPort = 0;
			break;
		case CC_IP_DOT:
			H245Addr.Addr.IP_Dot.wPort = 0;
			break;
		case CC_IP_BINARY:
			H245Addr.Addr.IP_Binary.wPort = 0;
			break;
		default:
			ASSERT(0);
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931RejectCall(hQ931Call,				// Q931 call handle
						   CC_REJECT_UNDEFINED_REASON,	// reject reason
						   &ConferenceID,
						   NULL,					// alternate address
						   pNonStandardData);		// non-standard data
			FreeNonStandardData(pNonStandardData);
			FreeVendorInfo(pVendorInfo);
			FreeDisplay(pszDisplay);
			return CC_INTERNAL_ERROR;
	}

    status = linkLayerListen(&dwLinkLayerPhysicalId,
							 H245Instance,
							 &H245Addr,
							 NULL);
	if (status != NOERROR) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931RejectCall(hQ931Call,				// Q931 call handle
					   CC_REJECT_UNDEFINED_REASON,	// reject reason
					   &ConferenceID,
					   NULL,					// alternate address
					   pNonStandardData);		// non-standard data
		FreeNonStandardData(pNonStandardData);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);

	DestinationEndpointType.pVendorInfo = pVendorInfo;
	DestinationEndpointType.bIsTerminal = TRUE;
	DestinationEndpointType.bIsGateway = FALSE;

	status = Q931AcceptCall(hQ931Call,
							pszDisplay,
							pNonStandardData,	// non-standard data
							&DestinationEndpointType,
							&H245Addr,		// H245 address
							hCall);			// user token
	FreeNonStandardData(pNonStandardData);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	if (status != CS_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		return status;
	}
	
	status = LockCallAndConference(hCall, &pCall, &pConference);
	if (status != CC_OK) {
		if (LockCall(hCall, &pCall) == CC_OK)
			FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	pCall->CallState = TERMCAP;
	pConference->ConferenceID = pCall->ConferenceID;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}

	status = SendTermCaps(pCall, pConference);
	if (status != CC_OK) {
		UnlockConference(pConference);
		FreeCall(pCall);
		H245ShutDown(H245Instance);
		Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
		return status;
	}
	
	pCall->OutgoingTermCapState = AWAITING_ACK;

	if (pCall->MasterSlaveState == MASTER_SLAVE_NOT_STARTED) {
		status = H245InitMasterSlave(H245Instance,
			                         H245Instance);	// returned as dwTransId in the callback
		if (status != H245_ERROR_OK) {
			UnlockConference(pConference);
			FreeCall(pCall);
			H245ShutDown(H245Instance);
			Q931Hangup(hQ931Call, CC_REJECT_UNDEFINED_REASON);
			return status;
		}
		pCall->MasterSlaveState = MASTER_SLAVE_IN_PROGRESS;
	}

	if (pCall->bCallerIsMC) {
		pConference->tsMultipointController = TS_FALSE;
		pConference->ConferenceMode = MULTIPOINT_MODE;
	}

	UnlockConference(pConference);
	UnlockCall(pCall);
	return CC_OK;
}



HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference)
{
CC_HCALL			hCall;
HRESULT				status;
WORD				wGoal;
HQ931CALL			hQ931Call;
PCC_ALIASNAMES		pCallerAliasNames;
PCC_ALIASNAMES		pCalleeAliasNames;
PCC_ALIASNAMES		pCalleeExtraAliasNames;
PCC_ALIASITEM		pCalleeExtension;
PCC_VENDORINFO		pVendorInfo;
PWSTR				pszDisplay;
PCC_NONSTANDARDDATA	pNonStandardData;
WORD				wNumCalls;
PCC_ADDR			pConnectAddr;
PCC_ADDR			pDestinationAddr;
CC_ADDR				SourceAddr;
CC_ENDPOINTTYPE		SourceEndpointType;
BOOL				bCallerIsMC;
WORD				wCallType;

	ASSERT(pCall != NULL);

	hCall = pCall->hCall;

	if (pCall->CallState == ENQUEUED) {
		// Enqueue the call on the conference object and HResultLeaveCallControl.
		// There will be exactly one placed call for this conference,
		// which is in the process of being placed.  If this call placement
		// completes successfully, all enqueued calls will then be placed.
		// If this call placement fails or is terminated, one enqueued call
		// will be placed
		status = AddEnqueuedCallToConference(pCall, pConference);
		return status;
	}
	
	// CallState == PLACED
	EnumerateCallsInConference(&wNumCalls,
		                       NULL,
		                       pConference,
							   PLACED_CALL | ESTABLISHED_CALL);
	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID))
		wGoal = CSG_CREATE;
	else if ((wNumCalls == 0) && (pConference->tsMultipointController != TS_TRUE))
		wGoal = CSG_JOIN;
	else
		wGoal = CSG_INVITE;

	status = AddPlacedCallToConference(pCall, pConference);
	if (status != CC_OK)
		return status;

	status = CopyAddr(&pConnectAddr, pCall->pQ931PeerConnectAddr);
	if (status != CC_OK)
		return status;
	
	status = CopyAddr(&pDestinationAddr, pCall->pQ931DestinationAddr);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		return status;
	}

	status = Q931CopyAliasNames(&pCallerAliasNames, pCall->pLocalAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		return status;
	}

	status = CopyVendorInfo(&pVendorInfo, pConference->pVendorInfo);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		return status;
	}
	
	status = CopyDisplay(&pszDisplay, pCall->pszLocalDisplay);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeAliasNames, pCall->pPeerAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		return status;
	}
	
	status = Q931CopyAliasNames(&pCalleeExtraAliasNames,
							    pCall->pPeerExtraAliasNames);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		return status;
	}

	status = Q931CopyAliasItem(&pCalleeExtension,
							   pCall->pPeerExtension);
	if (status != CS_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		return status;
	}

	status = CopyNonStandardData(&pNonStandardData, pCall->pLocalNonStandardData);
	if (status != CC_OK) {
		FreeAddr(pConnectAddr);
		FreeAddr(pDestinationAddr);
		Q931FreeAliasNames(pCallerAliasNames);
		FreeVendorInfo(pVendorInfo);
		FreeDisplay(pszDisplay);
		Q931FreeAliasNames(pCalleeAliasNames);
		Q931FreeAliasNames(pCalleeExtraAliasNames);
		Q931FreeAliasItem(pCalleeExtension);
		return status;
	}

	bCallerIsMC = (pConference->tsMultipointController == TS_TRUE ? TRUE : FALSE);
	// Note that if pConference->ConferenceMode == POINT_TO_POINT_MODE, this call attempt
	// will result in a multipoint call if successful, so set the wCallType accordingly
	wCallType = (WORD)((pConference->ConferenceMode == UNCONNECTED_MODE) ? CC_CALLTYPE_PT_PT : CC_CALLTYPE_N_N);

	SourceEndpointType.pVendorInfo = pVendorInfo;
	SourceEndpointType.bIsTerminal = TRUE;
	SourceEndpointType.bIsGateway = FALSE;

	// Cause our local Q.931 connect address to be placed in the
	// Q.931 setup-UUIE sourceAddress field
	SourceAddr.nAddrType = CC_IP_BINARY;
	SourceAddr.bMulticast = FALSE;
	SourceAddr.Addr.IP_Binary.dwAddr = 0;
	SourceAddr.Addr.IP_Binary.wPort = 0;

	status = Q931PlaceCall(&hQ931Call,				// Q931 call handle
		                   pszDisplay,
	                       pCallerAliasNames,
						   pCalleeAliasNames,
                           pCalleeExtraAliasNames,	// pCalleeExtraAliasNames
                           pCalleeExtension,		// pCalleeExtension
		                   pNonStandardData,		// non-standard data
						   &SourceEndpointType,
                           NULL, // pszCalledPartyNumber
						   pConnectAddr,
						   pDestinationAddr,
						   &SourceAddr,				// source address
						   bCallerIsMC,
						   &pCall->ConferenceID,	// conference ID
						   wGoal,
						   wCallType,
						   hCall,					// user token
						   (Q931_CALLBACK)Q931Callback, 	// callback
#ifdef GATEKEEPER
                           pCall->GkiCall.usCRV,        // CRV
                           &pCall->CallIdentifier);     // H.225 CallIdentifier
#else
                           0,                           // CRV
                           &pCall->CallIdentifier);     // H.225 CallIdentifier

#endif GATEKEEPER
	FreeAddr(pConnectAddr);
	FreeAddr(pDestinationAddr);
	Q931FreeAliasNames(pCallerAliasNames);
	FreeVendorInfo(pVendorInfo);
	FreeDisplay(pszDisplay);
	Q931FreeAliasNames(pCalleeAliasNames);
	Q931FreeAliasNames(pCalleeExtraAliasNames);
	Q931FreeAliasItem(pCalleeExtension);
	FreeNonStandardData(pNonStandardData);
	if (status != CS_OK)
		return status;
	
	pCall->hQ931Call = hQ931Call;
	return CC_OK;
}



HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference)
{
HRESULT					status;
WORD					i;
H245_TOTCAPDESC_T		*pTermCapDescriptor;
PCC_TERMCAP				pH2250MuxCapability;
PCC_TERMCAPLIST			pTermCapList;
PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors;

	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if ((pConference->ConferenceMode == MULTIPOINT_MODE) &&
		(pConference->tsMultipointController == TS_TRUE)) {
		pH2250MuxCapability = pConference->pConferenceH245H2250MuxCapability;
		pTermCapList = pConference->pConferenceTermCapList;
		pTermCapDescriptors = pConference->pConferenceTermCapDescriptors;
	} else {
		pH2250MuxCapability = pConference->pLocalH245H2250MuxCapability;
		pTermCapList = pConference->pLocalH245TermCapList;
		pTermCapDescriptors = pConference->pLocalH245TermCapDescriptors;
	}

	ASSERT(pH2250MuxCapability != NULL);
	ASSERT(pTermCapList != NULL);
	ASSERT(pTermCapDescriptors != NULL);

	// First send out the H.225.0 capability
	status = H245SetLocalCap(pCall->H245Instance,
							 pH2250MuxCapability,
							 &pH2250MuxCapability->CapId);
	ASSERT(pH2250MuxCapability->CapId == 0);
	if (status != H245_ERROR_OK)
		return status;

	// Now send out the terminal capabilities
	for (i = 0; i < pTermCapList->wLength; i++) {
		status = H245SetLocalCap(pCall->H245Instance,
		                         pTermCapList->pTermCapArray[i],
							     &pTermCapList->pTermCapArray[i]->CapId);
		if (status != H245_ERROR_OK)
			return status;
	}

	// Finally send out the capability descriptors
	for (i = 0; i < pTermCapDescriptors->wLength; i++) {
		pTermCapDescriptor = pTermCapDescriptors->pTermCapDescriptorArray[i];
		status = H245SetCapDescriptor(pCall->H245Instance,
		                              &pTermCapDescriptor->CapDesc,
								      &pTermCapDescriptor->CapDescId);
		if (status != H245_ERROR_OK)
			return status;
	}

	status = H245SendTermCaps(pCall->H245Instance,
		                      pCall->H245Instance);	// returned as dwTransId in the callback
	return status;
}



HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount)
{
WORD	i, j;
WORD	wStringLength;

	ASSERT(pH245CommunicationTable != NULL);
	ASSERT(pbCommunicationTableCount != NULL);

	if ((pSessionTable == NULL) || (pSessionTable->wLength == 0)) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_OK;
	}

	if (pSessionTable->SessionInfoArray == NULL) {
		*pH245CommunicationTable = NULL;
		*pbCommunicationTableCount = 0;
		return CC_BAD_PARAM;
	}

	*pH245CommunicationTable = (H245_COMM_MODE_ENTRY_T *)MemAlloc(sizeof(H245_COMM_MODE_ENTRY_T) * pSessionTable->wLength);
	if (*pH245CommunicationTable == NULL) {
		*pbCommunicationTableCount = 0;
		return CC_NO_MEMORY;
	}

	*pbCommunicationTableCount = (BYTE)pSessionTable->wLength;

	for (i = 0; i < pSessionTable->wLength; i++) {
		(*pH245CommunicationTable)[i].pNonStandard = NULL;
		(*pH245CommunicationTable)[i].sessionID = pSessionTable->SessionInfoArray[i].bSessionID;
		if (pSessionTable->SessionInfoArray[i].bAssociatedSessionID == 0)
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = FALSE;
		else {
			(*pH245CommunicationTable)[i].associatedSessionIDPresent = TRUE;
			(*pH245CommunicationTable)[i].associatedSessionID = pSessionTable->SessionInfoArray[i].bAssociatedSessionID;
		}
		(*pH245CommunicationTable)[i].terminalLabelPresent = FALSE;
		wStringLength = pSessionTable->SessionInfoArray[i].SessionDescription.wOctetStringLength;
		if (wStringLength > 0) {
			(*pH245CommunicationTable)[i].pSessionDescription = (unsigned short *)MemAlloc(sizeof(unsigned short) * wStringLength);
			if ((*pH245CommunicationTable)[i].pSessionDescription == NULL) {
				for (j = 0; j < i; j++)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_NO_MEMORY;
			}
			memcpy((*pH245CommunicationTable)[i].pSessionDescription,
				   pSessionTable->SessionInfoArray[i].SessionDescription.pOctetString,
				   wStringLength);
		} else
			(*pH245CommunicationTable)[i].pSessionDescription = NULL;
		(*pH245CommunicationTable)[i].wSessionDescriptionLength = wStringLength;
		(*pH245CommunicationTable)[i].dataType = *pSessionTable->SessionInfoArray[i].pTermCap;
		if (pSessionTable->SessionInfoArray[i].pRTPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaChannelPresent = TRUE;
		}
		if (pSessionTable->SessionInfoArray[i].pRTCPAddr == NULL)
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = FALSE;
		else {
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->nAddrType != CC_IP_BINARY) {
			for (j = 0; j <= i; j++)
				if ((*pH245CommunicationTable)[j].pSessionDescription != NULL)
					MemFree((*pH245CommunicationTable)[j].pSessionDescription);
				MemFree(*pH245CommunicationTable);
				*pbCommunicationTableCount = 0;
				return CC_BAD_PARAM;
			}
			if (pSessionTable->SessionInfoArray[i].pRTCPAddr->bMulticast)
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_MULTICAST;
			else
				(*pH245CommunicationTable)[i].mediaControlChannel.type = H245_IP_UNICAST;
			(*pH245CommunicationTable)[i].mediaControlChannel.u.ip.tsapIdentifier =
				pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort;
			HostToH245IPNetwork((*pH245CommunicationTable)[i].mediaControlChannel.u.ip.network,
								pSessionTable->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr);
			(*pH245CommunicationTable)[i].mediaControlChannelPresent = TRUE;
		}
		(*pH245CommunicationTable)[i].mediaGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaGuaranteedPresent = TRUE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteed = FALSE;
		(*pH245CommunicationTable)[i].mediaControlGuaranteedPresent = TRUE;
	}

	return CC_OK;
}



HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable)
{
WORD	i, j;
HRESULT	status;

	ASSERT(ppSessionTable != NULL);

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0) {
			*ppSessionTable = NULL;
			return CC_OK;
		} else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	*ppSessionTable = (PCC_SESSIONTABLE)MemAlloc(sizeof(CC_SESSIONTABLE));
	if (*ppSessionTable == NULL)
		return CC_NO_MEMORY;

	(*ppSessionTable)->wLength = bCommunicationTableCount;

	(*ppSessionTable)->SessionInfoArray = (PCC_SESSIONINFO)MemAlloc(sizeof(CC_SESSIONINFO) * bCommunicationTableCount);
	if ((*ppSessionTable)->SessionInfoArray == NULL) {
		MemFree(*ppSessionTable);
		*ppSessionTable = NULL;
		return CC_NO_MEMORY;
	}

	for (i = 0; i < bCommunicationTableCount; i++) {
		(*ppSessionTable)->SessionInfoArray[i].bSessionID = H245CommunicationTable[i].sessionID;
		if (H245CommunicationTable[i].associatedSessionIDPresent)
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID =
				H245CommunicationTable[i].associatedSessionID;
		else
			(*ppSessionTable)->SessionInfoArray[i].bAssociatedSessionID = 0;
		(*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength =
			H245CommunicationTable[i].wSessionDescriptionLength;
		if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.wOctetStringLength == 0)
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString = NULL;
		else {
			(*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString =
				(BYTE *)MemAlloc(H245CommunicationTable[i].wSessionDescriptionLength);
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString == NULL) {
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			memcpy((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString,
				   H245CommunicationTable[i].pSessionDescription,
				   H245CommunicationTable[i].wSessionDescriptionLength);
		}
		status = H245CopyCap(&(*ppSessionTable)->SessionInfoArray[i].pTermCap,
							 &H245CommunicationTable[i].dataType);
		if (status != H245_ERROR_OK) {
			if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
				MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
			for (j = 0; j < i; j++) {
				H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
				if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
			}
			MemFree((*ppSessionTable)->SessionInfoArray);
			MemFree(*ppSessionTable);
			return status;
		}
		if ((H245CommunicationTable[i].mediaChannelPresent) &&
		    ((H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTPAddr = NULL;
 		if ((H245CommunicationTable[i].mediaControlChannelPresent) &&
		    ((H245CommunicationTable[i].mediaControlChannel.type == H245_IP_MULTICAST) ||
		     (H245CommunicationTable[i].mediaControlChannel.type == H245_IP_UNICAST))) {
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if ((*ppSessionTable)->SessionInfoArray[i].pRTCPAddr == NULL) {
				if ((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].SessionDescription.pOctetString);
				H245FreeCap((*ppSessionTable)->SessionInfoArray[i].pTermCap);
				if ((*ppSessionTable)->SessionInfoArray[i].pRTPAddr != NULL)
					MemFree((*ppSessionTable)->SessionInfoArray[i].pRTPAddr);
				for (j = 0; j < i; j++) {
					H245FreeCap((*ppSessionTable)->SessionInfoArray[j].pTermCap);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTPAddr);
					if ((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr != NULL)
						MemFree((*ppSessionTable)->SessionInfoArray[j].pRTCPAddr);
				}
				MemFree((*ppSessionTable)->SessionInfoArray);
				MemFree(*ppSessionTable);
				return CC_NO_MEMORY;
			}
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->nAddrType = CC_IP_BINARY;
			if (H245CommunicationTable[i].mediaChannel.type == H245_IP_MULTICAST)
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = TRUE;
			else
				(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->bMulticast = FALSE;
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.wPort =
				H245CommunicationTable[i].mediaControlChannel.u.ip.tsapIdentifier;
			H245IPNetworkToHost(&(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr->Addr.IP_Binary.dwAddr,
								H245CommunicationTable[i].mediaControlChannel.u.ip.network);
		} else
			(*ppSessionTable)->SessionInfoArray[i].pRTCPAddr = NULL;
	}
	return CC_OK;
}



HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount)
{
WORD	i;

	if (H245CommunicationTable == NULL)
		if (bCommunicationTableCount == 0)
			return CC_OK;
		else
			return CC_BAD_PARAM;
	else
		if (bCommunicationTableCount == 0)
			return CC_BAD_PARAM;

	for (i = 0; i < bCommunicationTableCount; i++)
		if (H245CommunicationTable[i].pSessionDescription != NULL)
			MemFree(H245CommunicationTable[i].pSessionDescription);
	MemFree(H245CommunicationTable);
	return CC_OK;
}



HRESULT _PrepareTermCapLists(		PCONFERENCE				pConference,
									WORD					*pwListCount,
									PCC_TERMCAPLIST			**ppTermCapList,
									PCC_TERMCAPDESCRIPTORS	**ppTermCapDescriptorList,
									PCALL					*pCallList[])
{
WORD		i;
WORD		wNumCalls;
WORD		wOffset;
PCC_HCALL	CallList;
PCALL		pCall;

	ASSERT(pConference != NULL);
	ASSERT(pwListCount != NULL);
	ASSERT(ppTermCapList != NULL);
	ASSERT(ppTermCapDescriptorList != NULL);
	ASSERT(pCallList != NULL);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ESTABLISHED_CALL);

	if ((pConference->LocalEndpointAttached == DETACHED) && (wNumCalls > 0))
		wOffset = 0;
	else
		// LocalEndpointAttached is either UNATTACHED or ATTACHED, or there are no calls
		// in the conference; in the latter case, we need to have some term caps in
		// order to form the conference term cap set (which cannot be empty)
		wOffset = 1;

	*pwListCount = (WORD)(wNumCalls + wOffset);

	*ppTermCapList = (PCC_TERMCAPLIST *)MemAlloc(sizeof(PCC_TERMCAPLIST) * (*pwListCount));
	if (*ppTermCapList == NULL) {
		MemFree(CallList);
		return CC_NO_MEMORY;
	}

	*ppTermCapDescriptorList = (PCC_TERMCAPDESCRIPTORS *)MemAlloc(sizeof(PCC_TERMCAPDESCRIPTORS) * (*pwListCount));
	if (*ppTermCapDescriptorList == NULL) {
		MemFree(CallList);
		MemFree(*ppTermCapList);
		return CC_NO_MEMORY;
	}

	*pCallList = (PCALL *)MemAlloc(sizeof(PCALL) * (*pwListCount));
	if (*pCallList == NULL) {
		MemFree(CallList);
		MemFree(*ppTermCapList);
		MemFree(*ppTermCapDescriptorList);
		return CC_NO_MEMORY;
	}

	// Fill in pTermCapList and pTermCapDescriptorList
	if (wOffset == 1) {
		// The local endpoint is attached to the conference, so fill in the first
		// slot in both lists with the local term cap and descriptor lists
		(*ppTermCapList)[0] = pConference->pLocalH245TermCapList;
		(*ppTermCapDescriptorList)[0] = pConference->pLocalH245TermCapDescriptors;
	}
	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], &pCall) == CC_OK) {
			(*ppTermCapList)[i+wOffset] = pCall->pPeerH245TermCapList;
			(*ppTermCapDescriptorList)[i+wOffset] = pCall->pPeerH245TermCapDescriptors;
			(*pCallList)[i] = pCall;
		} else {
			(*ppTermCapList)[i+wOffset] = NULL;
			(*ppTermCapDescriptorList)[i+wOffset] = NULL;
			(*pCallList)[i] = NULL;
		}
	}
	for (i = 0; i < wOffset; i++)
		(*pCallList)[wNumCalls+i] = NULL;
	MemFree(CallList);
	return CC_OK;
}



HRESULT _FreeTermCapLists(			WORD					wListCount,
									PCC_TERMCAPLIST			*pTermCapList,
									PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList,
									PCALL					pCallList[])
{
WORD	i;

	for (i = 0; i < wListCount; i++)
		if (pCallList[i] != NULL)
			UnlockCall(pCallList[i]);
	if (pTermCapList != NULL)
		MemFree(pTermCapList);
	if (pTermCapDescriptorList != NULL)
		MemFree(pTermCapDescriptorList);
	MemFree(pCallList);
	return CC_OK;
}



HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged)
{
HRESULT					status;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pTermCapList;
PCC_TERMCAPDESCRIPTORS	*pTermCapDescriptorList;
WORD					wListCount;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed == TRUE) {
		status = FreeConferenceSessionTable(pConference);
		if (status != CC_OK)
			return status;
		pConference->bSessionTableInternallyConstructed = FALSE;
	}

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pTermCapList,
								  &pTermCapDescriptorList,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbSessionTableChanged,
									wListCount,
									pTermCapList,
									pTermCapDescriptorList,
									&pConference->pSessionTable);

	_FreeTermCapLists(wListCount,
					  pTermCapList,
					  pTermCapDescriptorList,
					  pCallList);
	return status;
}



HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	if (pConference->bSessionTableInternallyConstructed)
		status = DefaultSessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	else
		status = pConference->SessionTableConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbSessionTableChanged
									0,			// wListCount
									NULL,		// pTermCapList[]
									NULL,		// pTermCapDescriptors[]
									&pConference->pSessionTable);
	pConference->pSessionTable = NULL;
	return status;
}



HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged)
{
HRESULT					status;
WORD					wListCount;
PCALL					*pCallList;
PCC_TERMCAPLIST			*pInTermCapList;
PCC_TERMCAPDESCRIPTORS	*pInTermCapDescriptors;

	ASSERT(pConference != NULL);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	ASSERT(pConference->pLocalH245H2250MuxCapability != NULL);
	status = H245CopyCap(&pConference->pConferenceH245H2250MuxCapability,
						 pConference->pLocalH245H2250MuxCapability);
	if (status != H245_ERROR_OK)
		return status;

	status = _PrepareTermCapLists(pConference,
								  &wListCount,
								  &pInTermCapList,
								  &pInTermCapDescriptors,
								  &pCallList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapListFromH245(pConference,
										   pConference->pConferenceTermCapList);
	if (status != CC_OK)
		return status;

	status = UnregisterTermCapDescriptorsFromH245(pConference,
												  pConference->pConferenceTermCapDescriptors);
	if (status != CC_OK)
		return status;

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									TRUE,		// bCreate
									pbTermCapsChanged,
									wListCount,
									pInTermCapList,
									pInTermCapDescriptors,
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);

	_FreeTermCapLists(wListCount,
					  pInTermCapList,
					  pInTermCapDescriptors,
					  pCallList);
	return status;
}



HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference)
{
HRESULT	status;

	ASSERT(pConference != NULL);

	status = pConference->TermCapConstructor(
									pConference->hConference,
									pConference->dwConferenceToken,
									FALSE,		// bCreate
									NULL,		// pbTermCapsChanged
									0,			// wListCount
									NULL,		// pInTermCapList[]
									NULL,		// pInTermCapDescriptors[]
									&pConference->pConferenceTermCapList,
									&pConference->pConferenceTermCapDescriptors);
	pConference->pConferenceTermCapList = NULL;
	pConference->pConferenceTermCapDescriptors = NULL;
	return status;
}



HRESULT FindEnqueuedRequest(		PCALL_QUEUE				pQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = pQueueHead;

	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		pQueueItem = pQueueItem->pNext;
	}
	if (pQueueItem == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	// Make sure we're not enqueuing a duplicate request
	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL) {
		if (pQueueItem->hCall == hEnqueuedCall)
			return CC_OK;
		pQueueItem = pQueueItem->pNext;
	}

	pQueueItem = (PCALL_QUEUE)MemAlloc(sizeof(CALL_QUEUE));
	if (pQueueItem == NULL)
		return CC_NO_MEMORY;
	pQueueItem->hCall = hEnqueuedCall;
	pQueueItem->pPrev = NULL;
	pQueueItem->pNext = *ppQueueHead;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = pQueueItem;
	*ppQueueHead = pQueueItem;
	return CC_OK;
}



HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall)

{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = CC_INVALID_HANDLE;

	if (*ppQueueHead == NULL)
		return CC_BAD_PARAM;

	pQueueItem = *ppQueueHead;
	*ppQueueHead = (*ppQueueHead)->pNext;
	if (*ppQueueHead != NULL)
		(*ppQueueHead)->pPrev = NULL;

	if (phEnqueuedCall != NULL)
		*phEnqueuedCall = pQueueItem->hCall;
	MemFree(pQueueItem);
	return CC_OK;
}



HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall)
{
PCALL_QUEUE	pQueueItem;

	ASSERT(ppQueueHead != NULL);
	ASSERT(hEnqueuedCall != CC_INVALID_HANDLE);

	pQueueItem = *ppQueueHead;
	while (pQueueItem != NULL)
		if (pQueueItem->hCall == hEnqueuedCall)
			break;
		else
			pQueueItem = pQueueItem->pNext;

	if (pQueueItem == NULL)
		return CC_BAD_PARAM;

	if (pQueueItem->pNext != NULL)
		pQueueItem->pNext->pPrev = pQueueItem->pPrev;
	if (pQueueItem->pPrev == NULL)
		*ppQueueHead = pQueueItem->pNext;
	else
		pQueueItem->pPrev->pNext = pQueueItem->pNext;

	MemFree(pQueueItem);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\ccutils.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/ccutils.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.40  $
 *	$Date:   31 Jan 1997 20:36:02  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitializeLock(				PLOCK					pLock);

HRESULT DeleteLock(					PLOCK					pLock);

HRESULT AcquireLock(				PLOCK					pLock);

HRESULT AcquireTimedLock(			PLOCK					pLock,
									DWORD					dwTimeout,
									BOOL					*pbTimedOut);

HRESULT RelinquishLock(				PLOCK					pLock);

BOOL EqualConferenceIDs(			PCC_CONFERENCEID		pConferenceID1,
									PCC_CONFERENCEID		pConferenceID2);

BOOL EqualAddrs(					PCC_ADDR				pAddr1,
									PCC_ADDR				pAddr2);

HRESULT ValidateOctetString(		PCC_OCTETSTRING			pOctetString);

HRESULT CopyOctetString(			PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeOctetString(			PCC_OCTETSTRING			pOctetString);

HRESULT CopySeparateStack(			H245_ACCESS_T			**ppDest,
									H245_ACCESS_T			*pSource);

HRESULT FreeSeparateStack(			H245_ACCESS_T			*pSeparateStack);

HRESULT ValidateNonStandardData(	PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT CopyNonStandardData(		PCC_NONSTANDARDDATA		*ppDest,
									PCC_NONSTANDARDDATA		pSource);

HRESULT FreeNonStandardData(		PCC_NONSTANDARDDATA		pNonStandardData);

HRESULT ValidateVendorInfo(			PCC_VENDORINFO			pVendorInfo);

HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource);

HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo);

HRESULT ValidateTermCapList(		PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateTermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT ValidateAddr(				PCC_ADDR				pAddr);

HRESULT CopyAddr(					PCC_ADDR				*ppDest,
									PCC_ADDR				pSource);

HRESULT FreeAddr(					PCC_ADDR				pAddr);

HRESULT SetQ931Port(				PCC_ADDR				pAddr);

HRESULT ValidateDisplay(			PWSTR					pszDisplay);

HRESULT CopyDisplay(				PWSTR					*ppDest,
									PWSTR					pSource);

HRESULT FreeDisplay(				PWSTR					pszDisplay);

HRESULT ValidateTerminalID(			PCC_OCTETSTRING			pTerminalID);

HRESULT CopyTerminalID(				PCC_OCTETSTRING			*ppDest,
									PCC_OCTETSTRING			pSource);

HRESULT FreeTerminalID(				PCC_OCTETSTRING			pTerminalID);

HRESULT SetTerminalType(			TRISTATE				tsMultipointController,
									BYTE					*pbTerminalType);

HRESULT CopyH245TermCapList(		PCC_TERMCAPLIST			*ppDest,
									PCC_TERMCAPLIST			pSource);

HRESULT CopyH245TermCapDescriptors(	PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPDESCRIPTORS	pSource);

HRESULT CreateH245DefaultTermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppDest,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCap(			PPCC_TERMCAP			ppTermCap);

HRESULT UnregisterTermCapListFromH245(		
									PCONFERENCE				pConference,
									PCC_TERMCAPLIST			pTermCapList);

HRESULT DestroyH245TermCapList(		PCC_TERMCAPLIST			*ppTermCapList);

HRESULT UnregisterTermCapDescriptorsFromH245(
									PCONFERENCE				pConference,
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors);

HRESULT DestroyH245TermCapDescriptors(
									PCC_TERMCAPDESCRIPTORS	*ppTermCapDescriptors);

HRESULT HostToH245IPNetwork(		BYTE					*NetworkArray,
									DWORD					dwAddr);

HRESULT H245IPNetworkToHost(		DWORD					*pdwAddr,
									BYTE					*NetworkArray);

HRESULT ProcessRemoteHangup(		CC_HCALL				hCall,
									HQ931CALL				hQ931Initiator,
									BYTE					bHangupReason);

HRESULT DefaultSessionTableConstructor(
									CC_HCONFERENCE			hConference,
									DWORD_PTR   			dwConferenceToken,
									BOOL					bCreate,
									BOOL					*pbSessionTableChanged,
									WORD					wListCount,
									PCC_TERMCAPLIST			pTermCapList[],
									PCC_TERMCAPDESCRIPTORS	pTermCapDescriptors[],
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT DefaultTermCapConstructor(	CC_HCONFERENCE					hConference,
									DWORD_PTR						dwConferenceToken,
									BOOL							bCreate,
									BOOL							*pbTermCapsChanged,
									WORD							wListCount,
									PCC_TERMCAPLIST					pInTermCapList[],
									PCC_TERMCAPDESCRIPTORS			pInTermCapDescriptors[],
									PCC_TERMCAPLIST					*ppOutTermCapList,
									PCC_TERMCAPDESCRIPTORS			*ppOutTermCapDescriptors);

HRESULT AcceptCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT PlaceCall(					PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SendTermCaps(				PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT SessionTableToH245CommunicationTable(
									PCC_SESSIONTABLE		pSessionTable,
									H245_COMM_MODE_ENTRY_T	*pH245CommunicationTable[],
									BYTE					*pbCommunicationTableCount);

HRESULT H245CommunicationTableToSessionTable(
									H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount,
									PCC_SESSIONTABLE		*ppSessionTable);

HRESULT FreeH245CommunicationTable(	H245_COMM_MODE_ENTRY_T	H245CommunicationTable[],
									BYTE					bCommunicationTableCount);

HRESULT CreateConferenceSessionTable(
									PCONFERENCE				pConference,
									BOOL					*pbSessionTableChanged);

HRESULT FreeConferenceSessionTable(	PCONFERENCE				pConference);

HRESULT CreateConferenceTermCaps(	PCONFERENCE				pConference,
									BOOL					*pbTermCapsChanged);

HRESULT FreeConferenceTermCaps(		PCONFERENCE				pConference);

HRESULT EnqueueRequest(				PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);

HRESULT DequeueRequest(				PCALL_QUEUE				*ppQueueHead,
									PCC_HCALL				phEnqueuedCall);

HRESULT DequeueSpecificRequest(		PCALL_QUEUE				*ppQueueHead,
									CC_HCALL				hEnqueuedCall);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\chanman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.43  $
 *	$Date:   04 Mar 1997 17:35:04  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "ccutils.h"
#include "listman.h"
#include "q931man.h"
#include "userman.h"
#include "callman.h"
#include "confman.h"
#include "chanman.h"


static BOOL			bChannelInited = FALSE;

static struct {
	PCHANNEL			pHead;
	LOCK				Lock;
} ChannelTable;

static struct {
	CC_HCHANNEL			hChannel;
	LOCK				Lock;
} ChannelHandle;



HRESULT InitChannelManager()
{
	ASSERT(bChannelInited == FALSE);

	ChannelTable.pHead = NULL;
	InitializeLock(&ChannelTable.Lock);

	ChannelHandle.hChannel = CC_INVALID_HANDLE + 1;
	InitializeLock(&ChannelHandle.Lock);

	bChannelInited = TRUE;
	return CC_OK;
}



HRESULT DeInitChannelManager()
{
PCHANNEL	pChannel;
PCHANNEL	pNextChannel;

	if (bChannelInited == FALSE)
		return CC_OK;

	pChannel = ChannelTable.pHead;
	while (pChannel != NULL) {
		AcquireLock(&pChannel->Lock);
		pNextChannel = pChannel->pNextInTable;
		FreeChannel(pChannel);
		pChannel = pNextChannel;
	}

	DeleteLock(&ChannelHandle.Lock);
	DeleteLock(&ChannelTable.Lock);
	bChannelInited = FALSE;
	return CC_OK;
}



HRESULT _AddChannelToTable(			PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);
	ASSERT(pChannel->hChannel != CC_INVALID_HANDLE);
	ASSERT(pChannel->bInTable == FALSE);

	AcquireLock(&ChannelTable.Lock);

	pChannel->pNextInTable = ChannelTable.pHead;
	pChannel->pPrevInTable = NULL;
	if (ChannelTable.pHead != NULL)
		ChannelTable.pHead->pPrevInTable = pChannel;
	ChannelTable.pHead = pChannel;

	pChannel->bInTable = TRUE;

	RelinquishLock(&ChannelTable.Lock);
	return CC_OK;
}



HRESULT _RemoveChannelFromTable(	PCHANNEL				pChannel)
{
CC_HCHANNEL		hChannel;
BOOL			bTimedOut;

	ASSERT(pChannel != NULL);
	ASSERT(pChannel->bInTable == TRUE);

	// Caller must have a lock on the channel object;
	// in order to avoid deadlock, we must:
	//   1. unlock the channel object,
	//   2. lock the ChannelTable,
	//   3. locate the channel object in the ChannelTable (note that
	//      after step 2, the channel object may be deleted from the
	//      ChannelTable by another thread),
	//   4. lock the channel object (someone else may have the lock)
	//   5. remove the channel object from the ChannelTable,
	//   6. unlock the ChannelTable
	//
	// The caller can now safely unlock and destroy the channel object,
	// since no other thread will be able to find the object (its been
	// removed from the ChannelTable), and therefore no other thread will
	// be able to lock it.

	// Save the channel handle; its the only way to look up
	// the channel object in the ChannelTable. Note that we
	// can't use pChannel to find the channel object, since
	// pChannel may be free'd up, and another channel object
	// allocated at the same address
	hChannel = pChannel->hChannel;

	// step 1
	RelinquishLock(&pChannel->Lock);

step2:
	// step 2
	AcquireLock(&ChannelTable.Lock);

	// step 3
	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	if (pChannel != NULL) {
		// step 4
		AcquireTimedLock(&pChannel->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pChannel->pPrevInTable == NULL)
			ChannelTable.pHead = pChannel->pNextInTable;
		else
			pChannel->pPrevInTable->pNextInTable = pChannel->pNextInTable;

		if (pChannel->pNextInTable != NULL)
			pChannel->pNextInTable->pPrevInTable = pChannel->pPrevInTable;

		pChannel->pPrevInTable = NULL;
		pChannel->pNextInTable = NULL;
		pChannel->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeChannelHandle(			PCC_HCHANNEL			phChannel)
{
	AcquireLock(&ChannelHandle.Lock);
	*phChannel = ChannelHandle.hChannel++;
	RelinquishLock(&ChannelHandle.Lock);
	return CC_OK;
}


HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD_PTR				dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									PPCHANNEL				ppChannel)
{
HRESULT		status;
	
	ASSERT(bChannelInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);
	ASSERT((bChannelType == TX_CHANNEL) ||
		   (bChannelType == RX_CHANNEL) ||
		   (bChannelType == TXRX_CHANNEL) ||
		   (bChannelType == PROXY_CHANNEL));
	ASSERT(ppChannel != NULL);

	// set phChannel now, in case we encounter an error
	*phChannel = CC_INVALID_HANDLE;

	*ppChannel = (PCHANNEL)MemAlloc(sizeof(CHANNEL));
	if (*ppChannel == NULL)
		return CC_NO_MEMORY;

	(*ppChannel)->bInTable = FALSE;
	(*ppChannel)->bMultipointChannel = FALSE;
	(*ppChannel)->hCall = hCall;
	(*ppChannel)->wNumOutstandingRequests = 0;
	(*ppChannel)->pTxH245TermCap = NULL;
	(*ppChannel)->pRxH245TermCap = NULL;
	(*ppChannel)->pTxMuxTable = NULL;
	(*ppChannel)->pRxMuxTable = NULL;
	(*ppChannel)->pSeparateStack = NULL;
	(*ppChannel)->pCloseRequests = NULL;
	(*ppChannel)->pLocalRTPAddr = NULL;
	(*ppChannel)->pLocalRTCPAddr = NULL;
	(*ppChannel)->pPeerRTPAddr = NULL;
	(*ppChannel)->pPeerRTCPAddr = NULL;
	(*ppChannel)->dwUserToken = dwUserToken;
	(*ppChannel)->hConference = pConference->hConference;
	(*ppChannel)->bSessionID = bSessionID;
	(*ppChannel)->bAssociatedSessionID = bAssociatedSessionID;
	(*ppChannel)->wLocalChannelNumber = 0;
	(*ppChannel)->wRemoteChannelNumber = 0;
	(*ppChannel)->bLocallyOpened = bLocallyOpened;
	(*ppChannel)->pNextInTable = NULL;
	(*ppChannel)->pPrevInTable = NULL;
	(*ppChannel)->pNext = NULL;
	(*ppChannel)->pPrev = NULL;
	
	InitializeLock(&(*ppChannel)->Lock);
	AcquireLock(&(*ppChannel)->Lock);

	status = _MakeChannelHandle(&(*ppChannel)->hChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	if (bLocallyOpened == TRUE)
		(*ppChannel)->tsAccepted = TS_TRUE;
	else
		(*ppChannel)->tsAccepted = TS_UNKNOWN;

	if (pTxMuxTable != NULL) {
		(*ppChannel)->pTxMuxTable = (H245_MUX_T *)MemAlloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pTxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pTxMuxTable = *pTxMuxTable;
	}

	if (pRxMuxTable != NULL) {
		(*ppChannel)->pRxMuxTable = (H245_MUX_T *)MemAlloc(sizeof(H245_MUX_T));
		if ((*ppChannel)->pRxMuxTable == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pRxMuxTable = *pRxMuxTable;
	}

	if (pSeparateStack != NULL) {
		status = CopySeparateStack(&(*ppChannel)->pSeparateStack,
								   pSeparateStack);
		if (status != CC_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}

	(*ppChannel)->bChannelType = bChannelType;
	(*ppChannel)->bCallbackInvoked = FALSE;
	if (pTxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pTxH245TermCap, pTxTermCap);
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pRxTermCap != NULL) {
		status = H245CopyCap(&(*ppChannel)->pRxH245TermCap, pRxTermCap);
		if (status != H245_ERROR_OK) {
			FreeChannel(*ppChannel);
			return status;
		}
	}
	if (pLocalRTPAddr != NULL) {
		(*ppChannel)->pLocalRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTPAddr = *pLocalRTPAddr;
	}
	if (pLocalRTCPAddr != NULL) {
		(*ppChannel)->pLocalRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pLocalRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pLocalRTCPAddr = *pLocalRTCPAddr;
	}
	if (pPeerRTPAddr != NULL) {
		(*ppChannel)->pPeerRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTPAddr = *pPeerRTPAddr;
	}
	if (pPeerRTCPAddr != NULL) {
		(*ppChannel)->pPeerRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
		if ((*ppChannel)->pPeerRTCPAddr == NULL) {
			FreeChannel(*ppChannel);
			return CC_NO_MEMORY;
		}
		*(*ppChannel)->pPeerRTCPAddr = *pPeerRTCPAddr;
	}
	
	*phChannel = (*ppChannel)->hChannel;

	// add the conference to the conference table
	status = _AddChannelToTable(*ppChannel);
	if (status != CC_OK) {
		FreeChannel(*ppChannel);
		return status;
	}

	switch (bChannelType) {
		case TX_CHANNEL:			
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = 0;
			break;

		case RX_CHANNEL:
			(*ppChannel)->wLocalChannelNumber = 0;
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case TXRX_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			if (bLocallyOpened)
				(*ppChannel)->wRemoteChannelNumber = 0;
			else
				(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		case PROXY_CHANNEL:
			status = AllocateChannelNumber(pConference, &(*ppChannel)->wLocalChannelNumber);
			if (status != CC_OK) {
				FreeChannel(*ppChannel);
				return status;
			}
			(*ppChannel)->wRemoteChannelNumber = wRemoteChannelNumber;
			break;

		default:
			ASSERT(0);
			break;
	}
	
	return CC_OK;
}



HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	if (pRTPAddr != NULL) {
		if (pChannel->pLocalRTPAddr == NULL) {
			pChannel->pLocalRTPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTPAddr = *pRTPAddr;
	}

	if (pRTCPAddr != NULL) {
		if (pChannel->pLocalRTCPAddr == NULL) {
			pChannel->pLocalRTCPAddr = (PCC_ADDR)MemAlloc(sizeof(CC_ADDR));
			if (pChannel->pLocalRTCPAddr == NULL)
				return CC_NO_MEMORY;
		}
		*pChannel->pLocalRTCPAddr = *pRTCPAddr;
	}

	return CC_OK;
}



HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel)
{
	ASSERT(pSeparateStack != NULL);
	ASSERT(pChannel != NULL);

	if (pChannel->pSeparateStack != NULL)
		return CC_BAD_PARAM;

	pChannel->pSeparateStack = (H245_ACCESS_T *)MemAlloc(sizeof(H245_ACCESS_T));
	if (pChannel->pSeparateStack == NULL)
		return CC_NO_MEMORY;
	*pChannel->pSeparateStack = *pSeparateStack;
	return CC_OK;
}



// Caller must have a lock on the channel object
HRESULT FreeChannel(				PCHANNEL				pChannel)
{
HRESULT				status;
CC_HCHANNEL			hChannel;
PCONFERENCE			pConference;

	ASSERT(pChannel != NULL);

	// caller must have a lock on the channel object,
	// so there's no need to re-lock it
	
	hChannel = pChannel->hChannel;
	if (pChannel->hConference != CC_INVALID_HANDLE) {
		UnlockChannel(pChannel);
		status = LockChannelAndConference(hChannel, &pChannel, &pConference);
		if (status != CC_OK)
			return status;
	}

	if (pChannel->bInTable == TRUE)
		if (_RemoveChannelFromTable(pChannel) == CC_BAD_PARAM)
			// the channel object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pChannel->hConference != CC_INVALID_HANDLE)
		RemoveChannelFromConference(pChannel, pConference);

	if (pChannel->pSeparateStack != NULL)
		FreeSeparateStack(pChannel->pSeparateStack);

	if (pChannel->pTxMuxTable != NULL)
		MemFree(pChannel->pTxMuxTable);

	if (pChannel->pRxMuxTable != NULL)
		MemFree(pChannel->pRxMuxTable);

	if (pChannel->pTxH245TermCap != NULL)
		H245FreeCap(pChannel->pTxH245TermCap);

	if (pChannel->pRxH245TermCap != NULL)
		H245FreeCap(pChannel->pRxH245TermCap);

	while (DequeueRequest(&pChannel->pCloseRequests, NULL) == CC_OK);

	if (pChannel->pLocalRTPAddr != NULL)
		MemFree(pChannel->pLocalRTPAddr);

	if (pChannel->pLocalRTCPAddr != NULL)
		MemFree(pChannel->pLocalRTCPAddr);

	if (pChannel->pPeerRTPAddr != NULL)
		MemFree(pChannel->pPeerRTPAddr);

	if (pChannel->pPeerRTCPAddr != NULL)
		MemFree(pChannel->pPeerRTCPAddr);

	if (pChannel->wLocalChannelNumber != 0) {
		FreeChannelNumber(pConference, pChannel->wLocalChannelNumber);
	}

	if (pChannel->hConference != CC_INVALID_HANDLE)
		UnlockConference(pConference);

	// Since the channel object has been removed from the ChannelTable,
	// no other thread will be able to find the channel object and obtain
	// a lock, so its safe to unlock the channel object and delete it here
	RelinquishLock(&pChannel->Lock);
	DeleteLock(&pChannel->Lock);
	MemFree(pChannel);
	return CC_OK;
}



HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel)
{
BOOL	bTimedOut;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);

step1:
	AcquireLock(&ChannelTable.Lock);

	*ppChannel = ChannelTable.pHead;
	while ((*ppChannel != NULL) && ((*ppChannel)->hChannel != hChannel))
		*ppChannel = (*ppChannel)->pNextInTable;

	if (*ppChannel != NULL) {
		AcquireTimedLock(&(*ppChannel)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ChannelTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ChannelTable.Lock);

	if (*ppChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference)
{
HRESULT			status;
CC_HCONFERENCE	hConference;

	ASSERT(hChannel != CC_INVALID_HANDLE);
	ASSERT(ppChannel != NULL);
	ASSERT(ppConference != NULL);

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK)
		return status;
	
	if ((*ppChannel)->hConference == CC_INVALID_HANDLE) {
		UnlockChannel(*ppChannel);
		return CC_BAD_PARAM;
	}

	hConference = (*ppChannel)->hConference;
	UnlockChannel(*ppChannel);

	status = LockConference(hConference, ppConference);
	if (status != CC_OK)
		return status;

	status = LockChannel(hChannel, ppChannel);
	if (status != CC_OK) {
		UnlockConference(*ppConference);
		return status;
	}
	
	return CC_OK;
}



HRESULT ValidateChannel(			CC_HCHANNEL				hChannel)
{
PCHANNEL	pChannel;

	ASSERT(hChannel != CC_INVALID_HANDLE);

	AcquireLock(&ChannelTable.Lock);

	pChannel = ChannelTable.pHead;
	while ((pChannel != NULL) && (pChannel->hChannel != hChannel))
		pChannel = pChannel->pNextInTable;

	RelinquishLock(&ChannelTable.Lock);

	if (pChannel == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT UnlockChannel(				PCHANNEL				pChannel)
{
	ASSERT(pChannel != NULL);

	RelinquishLock(&pChannel->Lock);
	return CC_OK;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\chanman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/chanman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.20  $
 *	$Date:   31 Jan 1997 13:44:24  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

HRESULT InitChannelManager();

HRESULT DeInitChannelManager();

HRESULT AllocAndLockChannel(		PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference,
									CC_HCALL				hCall,
									PCC_TERMCAP				pTxTermCap,
									PCC_TERMCAP				pRxTermCap,
									H245_MUX_T				*pTxMuxTable,
									H245_MUX_T				*pRxMuxTable,
									H245_ACCESS_T			*pSeparateStack,
									DWORD_PTR				dwUserToken,
									BYTE					bChannelType,
									BYTE					bSessionID,
									BYTE					bAssociatedSessionID,
									WORD					wRemoteChannelNumber,
									PCC_ADDR				pLocalRTPAddr,
									PCC_ADDR				pLocalRTCPAddr,
									PCC_ADDR				pPeerRTPAddr,
									PCC_ADDR				pPeerRTCPAddr,
									BOOL					bLocallyOpened,
									PPCHANNEL				ppChannel);

HRESULT AddLocalAddrPairToChannel(	PCC_ADDR				pRTPAddr,
									PCC_ADDR				pRTCPAddr,
									PCHANNEL				pChannel);

HRESULT AddSeparateStackToChannel(	H245_ACCESS_T			*pSeparateStack,
									PCHANNEL				pChannel);

HRESULT FreeChannel(				PCHANNEL				pChannel);

HRESULT LockChannel(				CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel);

HRESULT LockChannelAndConference(	CC_HCHANNEL				hChannel,
									PPCHANNEL				ppChannel,
									PPCONFERENCE			ppConference);

HRESULT ValidateChannel(			CC_HCHANNEL				hChannel);

HRESULT UnlockChannel(				PCHANNEL				pChannel);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api_util.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR:     cjutzi (Curt Jutzi)
 *
 *  $Workfile:   api_util.c  $
 *  $Revision:   1.35  $
 *  $Modtime:   25 Feb 1997 10:36:12  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_util.c_v  $
 *
 *    Rev 1.35   25 Feb 1997 11:18:44   MANDREWS
 *
 * Fixed dynamic term cap ID generation; dynamic term cap IDs now
 * start at 32K + 1 and increase from there. Static term cap IDs
 * (specified by the client) are now restricted to the range of 1..32K.
 *
 *    Rev 1.34   29 Jan 1997 16:25:06   EHOWARDX
 * Changed del_cap_descriptor() to match changes to set_cap_descriptor().
 *
 *    Rev 1.33   29 Jan 1997 14:44:36   MANDREWS
 * Fixed warning that occured in release mode build.
 *
 *    Rev 1.32   28 Jan 1997 14:46:58   EHOWARDX
 * Potential fix for capability descriptor problem.
 *
 *    Rev 1.31   14 Oct 1996 14:01:20   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.30   16 Sep 1996 19:46:18   EHOWARDX
 * Added del_mux_cap for local and remote multiplex capability
 * to api_deinit to (hopefully) fix memory leak.
 *
 *    Rev 1.29   11 Oct 1996 15:19:42   EHOWARDX
 * Fixed H245CopyCap() bug.
 *
 *    Rev 1.28   28 Aug 1996 11:37:22   EHOWARDX
 * const changes.
 *
 *    Rev 1.27   05 Aug 1996 15:31:42   EHOWARDX
 *
 * Fixed error in CopyH2250Cap.
 *
 *    Rev 1.26   02 Aug 1996 21:10:42   EHOWARDX
 *
 * H.225.0 Mux cap bug second pass - see if this works.
 *
 *    Rev 1.25   02 Aug 1996 20:34:20   EHOWARDX
 * First pass at H.225.0 Mux cap bug.
 *
 *    Rev 1.24   19 Jul 1996 12:16:30   EHOWARDX
 *
 * Rewrite of api_fsm_event() debug routine.
 *
 *    Rev 1.23   16 Jul 1996 11:47:18   EHOWARDX
 *
 * Eliminated H245_ERROR_MUX_CAPS_ALREADY_SET from debug error text function.
 *
 *    Rev 1.22   09 Jul 1996 17:10:24   EHOWARDX
 * Fixed pointer offset bug in processing DataType from received
 * OpenLogicalChannel.
 *
 *    Rev 1.21   01 Jul 1996 22:12:42   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.20   24 Jun 1996 12:27:02   EHOWARDX
 *
 * Same as 1.17.1.0.
 *
 *    Rev 1.19   17 Jun 1996 18:10:06   EHOWARDX
 *
 * Changed first argument to build_totcap_cap_n_client_from_capability()
 * from VOID to struct capability *.
 *
 *    Rev 1.18   14 Jun 1996 18:57:56   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.17   10 Jun 1996 16:56:56   EHOWARDX
 * Removed #include "h245init.x"
 *
 *    Rev 1.16   06 Jun 1996 18:48:36   EHOWARDX
 * Fine-tuning tracker functions.
 *
 *    Rev 1.15   04 Jun 1996 13:56:40   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.14   31 May 1996 18:21:08   EHOWARDX
 * Changed map_api_error to reflect updated error codes.
 *
 *    Rev 1.13   30 May 1996 23:39:02   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.12   29 May 1996 15:20:10   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.11   28 May 1996 14:25:28   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.10   20 May 1996 22:15:46   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.9   20 May 1996 14:35:16   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.8   16 May 1996 19:40:48   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.7   16 May 1996 16:53:58   EHOWARDX
 * Fixed bug in set_capability() - need to set capability entry number
 * AFTER doing load_cap().
 *
 *    Rev 1.6   16 May 1996 15:59:26   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.5   15 May 1996 19:53:28   unknown
 * Fixed H245SetCapDescriptor.
 *
 *    Rev 1.4   14 May 1996 13:58:04   EHOWARDX
 * Fixed capability list order (made fifo).
 * Added support for NonStandard and H.222 mux capabilities to set_cap_descrip
 *
 *    Rev 1.3   14 May 1996 12:27:24   EHOWARDX
 * Check-in for integration.
 * Still need to fix non-standard and H.222 mux capabilities.
 *
 *    Rev 1.2   13 May 1996 23:16:46   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.1   11 May 1996 20:33:08   EHOWARDX
 * Checking in for the night...
 *
 *    Rev 1.0   09 May 1996 21:06:10   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.23.1.8   09 May 1996 19:30:56   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.23.1.7   27 Apr 1996 21:09:46   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.23.1.6   26 Apr 1996 15:53:52   EHOWARDX
 * Added H.225.0 Capability support; Changed Capability indication
 * to only callback once with PDU.
 *
 *    Rev 1.23.1.5   24 Apr 1996 20:54:36   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.23.1.4   23 Apr 1996 14:47:20   EHOWARDX
 * Disabled dump_pdu.
 *
 *    Rev 1.23.1.3   19 Apr 1996 12:54:18   EHOWARDX
 * Updated to 1.28.
 *
 *    Rev 1.23.1.2   15 Apr 1996 15:10:52   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.23.1.1   03 Apr 1996 17:14:56   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.23.1.0   03 Apr 1996 15:54:26   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.22   01 Apr 1996 16:43:18   cjutzi
 *
 * - Completed ENdConnection, and made asynch.. rather
 *   than sync.. as before
 * - Changed H245ShutDown to be sync rather than async..
 *
 *    Rev 1.21   29 Mar 1996 09:35:16   cjutzi
 *
 * -
 * - fixed ring3 build error message for check_pdu
 *
 *    Rev 1.20   27 Mar 1996 08:37:28   cjutzi
 *
 * - removed error from routine .. was unreferenced variable..
 *
 *    Rev 1.19   19 Mar 1996 20:31:06   cjutzi
 *
 * - added bi-directional channel stuff
 *
 *    Rev 1.18   13 Mar 1996 14:12:52   cjutzi
 *
 * - clean up..
 *
 *    Rev 1.17   13 Mar 1996 09:25:34   cjutzi
 *
 * - removed LPCRITICIAL -> CRITICAL SECTION *
 *
 *    Rev 1.16   12 Mar 1996 16:40:50   cjutzi
 *
 * - removed deadlock..
 *
 *    Rev 1.15   12 Mar 1996 15:51:08   cjutzi
 *
 * - added locking
 * - implented End Session
 * - fixed callback bug for deleting caps on cleanup..
 *
 *    Rev 1.14   08 Mar 1996 14:04:48   cjutzi
 *
 * - added mux table entry code.
 * - parse all mux table entries.. (as much as needed at this point)
 *
 *    Rev 1.13   06 Mar 1996 12:35:02   cjutzi
 *
 * - typeo.. :-).. for ANS1 error ..
 *
 *    Rev 1.12   06 Mar 1996 08:49:42   cjutzi
 *
 * - added H245_ERROR_ASN1
 * - #ifdef'ed the call to check pdu.. in api_fsm
 *
 *    Rev 1.11   05 Mar 1996 17:37:14   cjutzi
 *
 * - implemented Send Local Mux Table..
 * - removed bzero/bcopy and changed free api
 *
 *
 *    Rev 1.10   01 Mar 1996 13:49:00   cjutzi
 *
 * - added hani's new fsm id's
 * - added debug print for events.
 *
 *    Rev 1.9   29 Feb 1996 08:38:14   cjutzi
 *
 * - added error messages ..
 *
 *    Rev 1.8   26 Feb 1996 16:33:28   cjutzi
 *
 * - fixed GP for tracker.  p_prev was not initialized to NULL
 *
 *
 *    Rev 1.7   26 Feb 1996 11:06:18   cjutzi
 *
 * - added simltanious caps.. and fixed bugs..
 *   lot's o-changes..
 *
 *    Rev 1.6   16 Feb 1996 13:02:34   cjutzi
 *
 *  - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 10:53:10   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - modifed H223 stuff
 * - cleaned up open
 *
 *    Rev 1.4   09 Feb 1996 16:58:40   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/


/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#undef UNICODE
#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"


/***********************/
/*    H245 INCLUDES    */
/***********************/
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"
#include "fsmexpor.h"
#include "api_util.x"
#include "api_debu.x"
#include "h245deb.x"



// This array is used to map user-specified Client Type into correct Data Type
BYTE DataTypeMap[] =
{
  H245_DATA_DONTCARE,           //  H245_CLIENT_DONTCARE,
  H245_DATA_NONSTD,             //  H245_CLIENT_NONSTD,

  H245_DATA_VIDEO,              //  H245_CLIENT_VID_NONSTD,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H261,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H262,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_H263,
  H245_DATA_VIDEO,              //  H245_CLIENT_VID_IS11172,

  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_NONSTD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ALAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G711_ULAW56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_64,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_56,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G722_48,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G723,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G728,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_G729,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_GDSVD,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS11172,
  H245_DATA_AUDIO,              //  H245_CLIENT_AUD_IS13818,

  H245_DATA_DATA,               //  H245_CLIENT_DAT_NONSTD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T120,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSMCC,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_USERDATA,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T84,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_T434,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H224,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_NLPID,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_DSVD,
  H245_DATA_DATA,               //  H245_CLIENT_DAT_H222,

  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_TX,
  H245_DATA_ENCRYPT_D,          //  H245_CLIENT_ENCRYPTION_RX,
  H245_DATA_CONFERENCE,         //  H245_CLIENT_CONFERENCE,

  // Multiplex capabilities
  H245_DATA_MUX,                //  H245_CLIENT_MUX_NONSTD,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H222,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H223,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_VGMUX,
  H245_DATA_MUX,                //  H245_CLIENT_MUX_H2250
};

unsigned ObjectIdLength (const NonStandardIdentifier *pIdentifier)
{
  register unsigned   uLength = 0;
  register POBJECTID  pObject = pIdentifier->u.object;
  ASSERT(pIdentifier->choice == object_chosen);
  while (pObject)
  {
    ++uLength;
    pObject = pObject->next;
  }
  return uLength;
} // ObjectIdLength()



void FreeNonStandardIdentifier(NonStandardIdentifier *pFree)
{
    register POBJECTID    pObject;

    if (pFree->choice == object_chosen)
    {
        // Free Object Identifier
        while (pFree->u.object)
        {
            pObject = pFree->u.object;
            pFree->u.object = pObject->next;
            MemFree(pObject);
        }
    }
} // FreeNonStandardIdentifier()



HRESULT CopyNonStandardIdentifier(NonStandardIdentifier *pNew, const NonStandardIdentifier *pOld)
{

  // Copy the base structure
  *pNew = *pOld;

  if (pOld->choice == object_chosen)
  {
    // Copy Object Identifier
    POBJECTID                pObjectList;
    POBJECTID                pObjectOld;
    POBJECTID                pObjectNew;

    pNew->u.object = NULL;
    pObjectList = NULL;
    pObjectOld = pOld->u.object;
    while (pObjectOld)
    {
      // Allocate new structure
      pObjectNew = MemAlloc(sizeof(*pObjectNew));
      if (pObjectNew == NULL)
      {
        H245TRACE(0,1,"API:CopyNonStandardIdentifier - malloc failed");
        FreeNonStandardIdentifier(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      pObjectNew->value = pObjectOld->value;

      // Add new structure to list
      pObjectNew->next  = NULL;
      if (pNew->u.object == NULL)
      {
        pNew->u.object = pObjectNew;
      }
      else
      {
        pObjectList->next = pObjectNew;
      }
      pObjectList = pObjectNew;

      // Get next old structure to copy
      pObjectOld = pObjectOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyNonStandardIdentifier()



void FreeNonStandardParameter(NonStandardParameter *pFree)
{
    FreeNonStandardIdentifier(&pFree->nonStandardIdentifier);

    if (pFree->data.value)
    {
        MemFree(pFree->data.value);
        pFree->data.value = NULL;
    }
} // FreeNonStandardParameter()



HRESULT CopyNonStandardParameter(NonStandardParameter *pNew, const NonStandardParameter *pOld)
{
  // Copy the base structure
  *pNew = *pOld;

  if (pOld->nonStandardIdentifier.choice == object_chosen)
  {
    HRESULT lResult = CopyNonStandardIdentifier(&pNew->nonStandardIdentifier, &pOld->nonStandardIdentifier);
    if (lResult != H245_ERROR_OK)
    {
      pNew->data.value = NULL;
      return lResult;
    }
  }

  if (pOld->data.length && pOld->data.value)
  {
    // Copy value
    pNew->data.value = MemAlloc(pOld->data.length);
    if (pNew->data.value == NULL)
    {
      H245TRACE(0,1,"API:CopyNonStandardParameter - malloc failed");
      return H245_ERROR_NOMEM;
    }
    memcpy(pNew->data.value, pOld->data.value, pOld->data.length);
  }

  return H245_ERROR_OK;
} // CopyNonStandardParameter()



void FreeH222Cap(H222Capability *pFree)
{
  register VCCapabilityLink pVC;

  while (pFree->vcCapability)
  {
    pVC = pFree->vcCapability;
    pFree->vcCapability = pVC->next;
    MemFree(pVC);
  }
} // FreeH222Cap()



HRESULT CopyH222Cap(H222Capability *pNew, const H222Capability *pOld)
{
  VCCapabilityLink pVcNew;
  VCCapabilityLink pVcOld;
  VCCapabilityLink pVcList;

  pNew->numberOfVCs = pOld->numberOfVCs;
  pNew->vcCapability = NULL;
  pVcList = NULL;
  pVcOld = pOld->vcCapability;
  while (pVcOld)
  {
    // Allocate new structure
    pVcNew = MemAlloc(sizeof(*pVcNew));
    if (pVcNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH222Cap - malloc failed");
      FreeH222Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Copy old structure to new structure
    *pVcNew = *pVcOld;

    // Add new structure to list
    pVcNew->next = NULL;
    if (pNew->vcCapability == NULL)
    {
      pNew->vcCapability = pVcNew;
    }
    else if (NULL != pVcList)
    {
      pVcList->next = pVcNew;
    }
    pVcList = pVcNew;

    // Get next old structure to copy
    pVcOld = pVcOld->next;
  }

  return H245_ERROR_OK;
} // CopyH222Cap()



void FreeMediaDistributionCap(MediaDistributionCapability *pFree)
{
  if (pFree->bit_mask & centralizedData_present)
  {
    register CentralizedDataLink  pLink;

    while (pFree->centralizedData)
    {
      pLink = pFree->centralizedData;
      pFree->centralizedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          MemFree(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      MemFree(pLink);
    }
  }

  if (pFree->bit_mask & distributedData_present)
  {
    register DistributedDataLink  pLink;

    while (pFree->distributedData)
    {
      pLink = pFree->distributedData;
      pFree->distributedData = pLink->next;
      switch (pLink->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          MemFree(pLink->value.application.u.DACy_applctn_nlpd.nlpidData.value);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLink->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          FreeNonStandardParameter(&pLink->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      MemFree(pLink);
    }
  }
} // FreeMediaDistributionCap()



HRESULT CopyMediaDistributionCap(MediaDistributionCapability *pNew,
                           const MediaDistributionCapability *pOld)
{
  HRESULT lResult = H245_ERROR_OK;
  *pNew = *pOld;
  pNew->centralizedData = NULL;
  pNew->distributedData = NULL;

  if (pOld->bit_mask & centralizedData_present)
  {
    CentralizedDataLink pLinkList = NULL;
    CentralizedDataLink pLinkOld = pOld->centralizedData;
    CentralizedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = MemAlloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->centralizedData == NULL)
      {
        pNew->centralizedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            MemAlloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                             &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  if (pOld->bit_mask & distributedData_present)
  {
    DistributedDataLink pLinkList = NULL;
    DistributedDataLink pLinkOld = pOld->distributedData;
    DistributedDataLink pLinkNew;

    while (pLinkOld)
    {
      // Allocate new structure
      pLinkNew = MemAlloc(sizeof(*pLinkNew));
      if (pLinkNew == NULL)
      {
        H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
        FreeMediaDistributionCap(pNew);
        return H245_ERROR_NOMEM;
      }

      // Copy old structure to new structure
      *pLinkNew = *pLinkOld;

      // Add new structure to list
      pLinkNew->next = NULL;
      if (pNew->distributedData == NULL)
      {
        pNew->distributedData = pLinkNew;
      }
      else
      {
        pLinkList->next = pLinkNew;
      }
      pLinkList = pLinkNew;

      // Allocate new memory for each pointer in new structure
      switch (pLinkOld->value.application.choice)
      {
      case DACy_applctn_nnStndrd_chosen:
        lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_nnStndrd,
                                         &pLinkOld->value.application.u.DACy_applctn_nnStndrd);
        break;

      case DACy_applctn_nlpd_chosen:
        if (pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value != NULL)
        {
          pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value =
            MemAlloc(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
          if (pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value == NULL)
          {
            H245TRACE(0,1,"API:CopyMediaDistributionCap - malloc failed");
            FreeMediaDistributionCap(pNew);
            return H245_ERROR_NOMEM;
          }
          memcpy(pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.value,
               pLinkOld->value.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pLinkNew->value.application.u.DACy_applctn_nlpd.nlpidData.length);
        }

        // Fall-through to next case

      case DACy_applctn_t120_chosen:
      case DACy_applctn_dsm_cc_chosen:
      case DACy_applctn_usrDt_chosen:
      case DACy_applctn_t84_chosen:
      case DACy_applctn_t434_chosen:
      case DACy_applctn_h224_chosen:
      case DACy_an_h222DtPrttnng_chosen :
        if (pLinkOld->value.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
        {
          lResult = CopyNonStandardParameter(&pLinkNew->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                           &pLinkOld->value.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
        }
        break;

      case DACy_applctn_dsvdCntrl_chosen:
        // Do nothing
        break;
      } // switch
      if (lResult != H245_ERROR_OK)
      {
        FreeMediaDistributionCap(pNew);
        return lResult;
      }

      // Get next old structure to copy
      pLinkOld = pLinkOld->next;
    }
  }

  return H245_ERROR_OK;
} // CopyMediaDistributionCap()



void FreeH2250Cap(H2250Capability *pFree)
{
  register MediaDistributionCapabilityLink pLink;

  while (pFree->receiveMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->receiveMultipointCapability.mediaDistributionCapability;
    pFree->receiveMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }

  while (pFree->transmitMultipointCapability.mediaDistributionCapability)
  {
    pLink = pFree->transmitMultipointCapability.mediaDistributionCapability;
    pFree->transmitMultipointCapability.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }

  while (pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability)
  {
    pLink = pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
    pFree->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLink->next;
    FreeMediaDistributionCap(&pLink->value);
    MemFree(pLink);
  }
} // FreeH2250Cap()



HRESULT CopyH2250Cap(H2250Capability *pNew, const H2250Capability *pOld)
{
  MediaDistributionCapabilityLink pLinkList;
  MediaDistributionCapabilityLink pLinkOld;
  MediaDistributionCapabilityLink pLinkNew;
  HRESULT lResult;

  // Copy base structure
  *pNew = *pOld;
  pNew->receiveMultipointCapability.mediaDistributionCapability  = NULL;
  pNew->transmitMultipointCapability.mediaDistributionCapability = NULL;
  pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability     = NULL;

  pLinkList = NULL;
  pLinkOld = pOld->receiveMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->receiveMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->receiveMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->transmitMultipointCapability.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->transmitMultipointCapability.mediaDistributionCapability == NULL)
    {
      pNew->transmitMultipointCapability.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  pLinkList = NULL;
  pLinkOld = pOld->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability;
  while (pLinkOld)
  {
    // Allocate new structure
    pLinkNew = MemAlloc(sizeof(*pLinkNew));
    if (pLinkNew == NULL)
    {
      H245TRACE(0,1,"API:CopyH2250Cap - malloc failed");
      FreeH2250Cap(pNew);
      return H245_ERROR_NOMEM;
    }

    // Add new structure to list
    pLinkNew->next = NULL;
    if (pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability == NULL)
    {
      pNew->rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = pLinkNew;
    }
    else
    {
      pLinkList->next = pLinkNew;
    }
    pLinkList = pLinkNew;

    // Copy old structure to new
    lResult = CopyMediaDistributionCap(&pLinkNew->value, &pLinkOld->value);
    if (lResult != H245_ERROR_OK)
    {
      FreeH2250Cap(pNew);
      return lResult;
    }

    // Get next old structure to copy
    pLinkOld = pLinkOld->next;
  }

  return H245_ERROR_OK;
} // CopyH2250Cap()



HRESULT set_cap_descriptor(
                        struct InstanceStruct         *pInstance,
                        H245_CAPDESC_T                *pCapDesc,
                        H245_CAPDESCID_T              *pCapDescId,
                        struct TerminalCapabilitySet  *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;
  BOOL                          bNewDescriptor;
  unsigned int                  sim_cap;
  SmltnsCpbltsLink              p_sim_cap;
  SmltnsCpbltsLink              p_sim_cap_lst = NULL;
  unsigned int                  alt_cap;

  H245TRACE(pInstance->dwInst,10,"API:set_cap_descriptor");
  ASSERT(*pCapDescId < 256);

  /* Check if capability descriptor already exists */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == *pCapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL)
  {
    ASSERT(pTermCapSet->capabilityDescriptors.count < 256);
    p_cap_desc = &pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
    p_cap_desc->capabilityDescriptorNumber = (CapabilityDescriptorNumber) *pCapDescId;
    bNewDescriptor = TRUE;
  }
  else
  {
    bNewDescriptor = FALSE;
  }
  if (p_cap_desc->smltnsCpblts)
    dealloc_simultaneous_cap (p_cap_desc);

  /* for every entry in the altcap list */
  for (sim_cap = 0; sim_cap < pCapDesc->Length; ++sim_cap)
  {
    /* check for out of bounds error or memory allocation failure */
    if ((pCapDesc->SimCapArray[sim_cap].Length > 256) ||
        (!(p_sim_cap = (SmltnsCpbltsLink)alloc_link(sizeof(*p_sim_cap)))))
    {
      if (p_cap_desc->smltnsCpblts)
        dealloc_simultaneous_cap (p_cap_desc);
      H245TRACE(pInstance->dwInst,1,"API:set_cap_descriptor - no memory");
      return H245_ERROR_NOMEM;
    }

    if (!p_cap_desc->smltnsCpblts)
    {
      /* first time through */
      p_cap_desc->smltnsCpblts = p_sim_cap;
    }
    else
    {
      /* every other time through */
      ASSERT (p_sim_cap_lst);
      p_sim_cap_lst->next = p_sim_cap;
    }

    /* setup for next time through */
    p_sim_cap_lst = p_sim_cap;

    /* load up the new simultanoius cap */
    for (alt_cap = 0; alt_cap < pCapDesc->SimCapArray[sim_cap].Length; ++alt_cap)
    {
      if (!(find_capid_by_entrynumber (&pInstance->API.PDU_LocalTermCap.TERMCAPSET,
                                   pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap])))
      {
        if (p_cap_desc->smltnsCpblts)
          dealloc_simultaneous_cap (p_cap_desc);
        return H245_ERROR_INVALID_CAPID;
      }

      /* assign Altcap */
      p_sim_cap->value.value[alt_cap] = (unsigned short)pCapDesc->SimCapArray[sim_cap].AltCaps[alt_cap];
    } /* for C*/

    /* set count */
    p_sim_cap->value.count = (unsigned short)pCapDesc->SimCapArray[sim_cap].Length;

  } /* for */

  /* Success! */
  /* Set the simultaneous capabilities present bit */
  /* Increment the capability descriptor count */
  /* Set the descriptors present bit even though it may already be set */
  p_cap_desc->bit_mask |= smltnsCpblts_present;
  if (bNewDescriptor)
    pTermCapSet->capabilityDescriptors.count++;
  pTermCapSet->bit_mask |= capabilityDescriptors_present;

  return H245_ERROR_OK;
}

HRESULT del_cap_descriptor (struct InstanceStruct        *pInstance,
                            H245_CAPDESCID_T              CapDescId,
                            struct TerminalCapabilitySet *pTermCapSet)
{
  CapabilityDescriptor         *p_cap_desc;
  unsigned int                  uId;

  /* Check if capability descriptor already exists and if it is valid */
  p_cap_desc = NULL;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
    {
      H245TRACE(pInstance->dwInst,1,"API:del_cap_descriptor - invalid cap descriptor");
      return H245_ERROR_INVALID_CAPDESCID;
    }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  pTermCapSet->capabilityDescriptors.count--;
  pTermCapSet->capabilityDescriptors.value[uId] =
    pTermCapSet->capabilityDescriptors.value[pTermCapSet->capabilityDescriptors.count];
  if (pTermCapSet->capabilityDescriptors.count == 0)
    pTermCapSet->bit_mask &= ~capabilityDescriptors_present;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   free_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      none
 *
 * ASSUMES:     none
 *
 *****************************************************************************/
void
free_object_id (POBJECTID p_obj_id)
{
  register POBJECTID p_obj_tmp;

  /* free all the objects */
  while (p_obj_id != NULL)
    {
      p_obj_tmp = p_obj_id;
      p_obj_id = p_obj_id->next;
      MemFree (p_obj_tmp);
    }
}

/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_element
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_element (MultiplexElement *p_ASN_mux_el)
{
  int count = 0;

  if (p_ASN_mux_el->type.choice == subElementList_chosen)
    {
      if (p_ASN_mux_el->type.u.subElementList)
        {
          for (count = p_ASN_mux_el->type.u.subElementList->count;
               count;
               count--)
            {
              free_mux_element (&(p_ASN_mux_el->type.u.subElementList->value[count]));
            }
          MemFree (p_ASN_mux_el->type.u.subElementList);
        }
    }
}
/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   free_mux_desc_list
 *
 * DESCRIPTION
 *              free mux element desciptor list
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
free_mux_desc_list (MultiplexEntryDescriptorLink p_ASN_med_link)
{
  MultiplexEntryDescriptorLink  p_ASN_med_link_tofree;

  /* free all entries on descriptor list */
  while (p_ASN_med_link)
    {
      int count = 0;

      for (count = p_ASN_med_link->value.elementList.count;
           count;
           count--)
        {
          free_mux_element (&(p_ASN_med_link->value.elementList.value[count]));
        }
      p_ASN_med_link_tofree = p_ASN_med_link;
      p_ASN_med_link = p_ASN_med_link->next;
      MemFree (p_ASN_med_link_tofree);
    }
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 *****************************************************************************/
H245_LINK_T  *
alloc_link (int size)
{
  H245_LINK_T *p_link = (H245_LINK_T *)MemAlloc (size);
  if (p_link)
    p_link->p_next = NULL;
  return p_link;
}


/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   alloc_new_capid -
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *              Caller marks the bit_mask indicating when
 *                the table entry can be used.
 *
 * RETURN:              NULL     if not found
 *                      pCapLink if found
 *
 *****************************************************************************/
CapabilityTableLink
alloc_link_cap_entry ( struct TerminalCapabilitySet *pTermCapSet)
{
  register CapabilityTableLink  pCapLink;
  register CapabilityTableLink  pCapLinkSearch;

  ASSERT(pTermCapSet != NULL);

  pCapLink = (CapabilityTableLink)MemAlloc(sizeof(*pCapLink));
  if (pCapLink)
  {
    pCapLink->next = NULL;
    pCapLink->value.bit_mask = 0;
    pCapLinkSearch = pTermCapSet->capabilityTable;

    // Insert at END of linked list
    if (pCapLinkSearch)
    {
      while (pCapLinkSearch->next)
      {
        pCapLinkSearch = pCapLinkSearch->next;
      }
      pCapLinkSearch->next = pCapLink;
    }
    else
    {
      pTermCapSet->capabilityTable = pCapLink;
    }
  }

  return pCapLink;
} // alloc_link_cap_entry()


/*****************************************************************************
 *
 * TYPE:        GLOBAL
 *
 * PROCEDURE:   dealloc_simultaneous_cap - deallocate alternative Cap Set
 *
 * DESCRIPTION
 *
 * RETURN:      N/A
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/

void dealloc_simultaneous_cap (CapabilityDescriptor *pCapdes)
{
  SmltnsCpbltsLink      p_sim_cap;
  SmltnsCpbltsLink      p_sim_cap_tmp;

  pCapdes->bit_mask &= ~smltnsCpblts_present;

  for (p_sim_cap = pCapdes->smltnsCpblts;
       p_sim_cap;
       )
    {
      p_sim_cap_tmp = p_sim_cap->next;
      MemFree (p_sim_cap);
      p_sim_cap = p_sim_cap_tmp;

    } /* for */

  pCapdes->smltnsCpblts = NULL;

} /* procedrue */

/*****************************************************************************
 *
 * TYPE:        local
 *
 * PROCEDURE:   find_capid_by_entrynumber -
 *
 * DESCRIPTION:
 *
 * RETURN:      NULL - if error
 *              capabiliytTableLink if ok
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
CapabilityTableLink
find_capid_by_entrynumber (
                           struct TerminalCapabilitySet *pTermCapSet,
                           H245_CAPID_T                  cap_id
                          )
{
  register CapabilityTableLink  pCapLink;

  ASSERT (pTermCapSet != NULL);

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;
       pCapLink = pCapLink->next)
  {
    if  (pCapLink->value.capabilityTableEntryNumber == cap_id &&
         pCapLink->value.bit_mask == capability_present)
    {
      return pCapLink;
    }
  }
  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   load_cap
 *
 * DESCRIPTION: Takes a totcap and loads a capability structure
 *              i.e. Input is the total capability
 *                   Output is the *pCapability
 *              NOTE: Non Standard Capabilities.. allocate memory
 *                    which needs to be free'd later..
 *
 * RETURN:
 *
 *****************************************************************************/
HRESULT
load_cap (struct Capability   *pCapability,  /* output */
          const H245_TOTCAP_T *pTotCap )     /* input  */
{
  HRESULT                       lError = H245_ERROR_OK;

  H245TRACE(0,10,"API:laod_cap <-");

  switch (pTotCap->ClientType)
    {
    /* General NON Standard Cap */
    case H245_CLIENT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.Capability_nonStandard,
                                        &pTotCap->Cap.H245_NonStd);
      break;

    /* VIDEO */
    case H245_CLIENT_VID_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Vid_NONSTD);
      pCapability->u.receiveVideoCapability.choice = VdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_VID_H261:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H261");
      pCapability->u.receiveVideoCapability.u.h261VideoCapability = pTotCap->Cap.H245Vid_H261;
      pCapability->u.receiveVideoCapability.choice = h261VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H262:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H262");
      pCapability->u.receiveVideoCapability.u.h262VideoCapability = pTotCap->Cap.H245Vid_H262;
      pCapability->u.receiveVideoCapability.choice = h262VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_H263:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_H263");
      pCapability->u.receiveVideoCapability.u.h263VideoCapability = pTotCap->Cap.H245Vid_H263;
      pCapability->u.receiveVideoCapability.choice = h263VideoCapability_chosen;
      break;
    case H245_CLIENT_VID_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_VID_IS11172");
      pCapability->u.receiveVideoCapability.u.is11172VideoCapability = pTotCap->Cap.H245Vid_IS11172;
      pCapability->u.receiveVideoCapability.choice = is11172VideoCapability_chosen;
      break;

    /* AUDIO */
    case H245_CLIENT_AUD_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_NONSTD");
      lError = CopyNonStandardParameter(&pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard,
                                        &pTotCap->Cap.H245Aud_NONSTD);
      pCapability->u.receiveAudioCapability.choice = AdCpblty_nonStandard_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k = pTotCap->Cap.H245Aud_G711_ALAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ALAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ALAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k = pTotCap->Cap.H245Aud_G711_ALAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Alaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW64");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k = pTotCap->Cap.H245Aud_G711_ULAW64;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw64k_chosen;
      break;
    case H245_CLIENT_AUD_G711_ULAW56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G711_ULAW56");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k = pTotCap->Cap.H245Aud_G711_ULAW56;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g711Ulaw56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_64:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_64");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k = pTotCap->Cap.H245Aud_G722_64;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_64k_chosen;
      break;
    case H245_CLIENT_AUD_G722_56:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_56");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k = pTotCap->Cap.H245Aud_G722_56;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_56k_chosen;
      break;
    case H245_CLIENT_AUD_G722_48:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G722_48");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k = pTotCap->Cap.H245Aud_G722_48;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g722_48k_chosen;
      break;
    case H245_CLIENT_AUD_G723:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G723");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g7231 = pTotCap->Cap.H245Aud_G723;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g7231_chosen;
      break;
    case H245_CLIENT_AUD_G728:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G728");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g728 = pTotCap->Cap.H245Aud_G728;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g728_chosen;
      break;
    case H245_CLIENT_AUD_G729:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_G729");
      pCapability->u.receiveAudioCapability.u.AudioCapability_g729 = pTotCap->Cap.H245Aud_G729;
      pCapability->u.receiveAudioCapability.choice = AudioCapability_g729_chosen;
      break;
    case H245_CLIENT_AUD_GDSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_GDSVD");
      pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA = pTotCap->Cap.H245Aud_GDSVD;
      pCapability->u.receiveAudioCapability.choice = AdCpblty_g729AnnexA_chosen;
      break;
    case H245_CLIENT_AUD_IS11172:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS11172");
      pCapability->u.receiveAudioCapability.u.is11172AudioCapability = pTotCap->Cap.H245Aud_IS11172;
      pCapability->u.receiveAudioCapability.choice = is11172AudioCapability_chosen;
      break;
    case H245_CLIENT_AUD_IS13818:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_AUD_IS13818");
      pCapability->u.receiveAudioCapability.u.is13818AudioCapability = pTotCap->Cap.H245Aud_IS13818;
      pCapability->u.receiveAudioCapability.choice = is13818AudioCapability_chosen;
      break;

    /* DATA */
    case H245_CLIENT_DAT_NONSTD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NONSTD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NONSTD;
      lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd,
                                              &pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd);
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nnStndrd_chosen;
      break;
    case H245_CLIENT_DAT_T120:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T120");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T120;
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t120_chosen;
      break;
    case H245_CLIENT_DAT_DSMCC:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSMCC");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      if (pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsm_cc_chosen;
      break;
    case H245_CLIENT_DAT_USERDATA:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_USERDATA");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_USERDATA;
      if (pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd,
                                              &pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_usrDt_chosen;
      break;
    case H245_CLIENT_DAT_T84:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T84");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T84;
      if (pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd,
                                                   &pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t84_chosen;
      break;
    case H245_CLIENT_DAT_T434:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_T434");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_T434;
      if (pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_t434_chosen;
      break;
    case H245_CLIENT_DAT_H224:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H224");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H224;
      if (pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_h224_chosen;
      break;
    case H245_CLIENT_DAT_NLPID:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_NLPID");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_NLPID;
      if (pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd,
                                                 &pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
      }
      if (lError == H245_ERROR_OK && pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length != 0)
      {
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value =
          MemAlloc(pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value)
        {
          memcpy(pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.value,
                 pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidData.length);
        }
        else
          lError = H245_ERROR_NOMEM;
      }
      else
        pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value = NULL;

      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_nlpd_chosen;
      break;
    case H245_CLIENT_DAT_DSVD:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_DSVD");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_DSMCC;
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_applctn_dsvdCntrl_chosen;
      break;
    case H245_CLIENT_DAT_H222:
      H245TRACE(0,20,"API:load_cap - H245_CLIENT_DAT_H222");
      pCapability->u.rcvDtApplctnCpblty = pTotCap->Cap.H245Dat_H222;
      if (pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
      {
        lError = CopyNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd,
                                                  &pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
      }
      pCapability->u.rcvDtApplctnCpblty.application.choice = DACy_an_h222DtPrttnng_chosen ;
      break;
    default:
      H245TRACE(0,20,"API:load_cap - default");
      lError = H245_ERROR_NOSUP;
    } /* switch */

  if (lError != H245_ERROR_OK)
    H245TRACE(0,1,"API:load_cap -> %s",map_api_error(lError));
  else
    H245TRACE(0,10,"API:load_cap -> OK");
  return lError;
}


void
free_cap (struct Capability * pCapability,      // input, output
          const H245_TOTCAP_T *pTotCap)         // input
{
    ASSERT(!IsBadWritePtr(pCapability, sizeof(*pCapability)));

    switch (pTotCap->ClientType)
    {
        case H245_CLIENT_NONSTD:
            FreeNonStandardParameter(&pCapability->u.Capability_nonStandard);
            break;

        case H245_CLIENT_VID_NONSTD:
            FreeNonStandardParameter(&pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard);
            break;

        case H245_CLIENT_AUD_NONSTD:
            FreeNonStandardParameter(&pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard);
            break;

        case H245_CLIENT_DAT_NONSTD:
            FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd);
            break;

        case H245_CLIENT_DAT_T120:
            if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd);
            }
            else
            {
                if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value)
                {
                    WARNING_OUT(("H245_CLIENT_DAT_T120 no non-standard parameter to free"));
                }
            }
            break;

        case H245_CLIENT_DAT_DSMCC:
            if (pTotCap->Cap.H245Dat_DSMCC.application.u.DACy_applctn_dsm_cc.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_dsm_cc.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_USERDATA:
            if (pTotCap->Cap.H245Dat_USERDATA.application.u.DACy_applctn_usrDt.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_usrDt.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_T84:
            if (pTotCap->Cap.H245Dat_T84.application.u.DACy_applctn_t84.t84Protocol.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t84.t84Protocol.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_T434:
            if (pTotCap->Cap.H245Dat_T434.application.u.DACy_applctn_t434.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_t434.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_H224:
            if (pTotCap->Cap.H245Dat_H224.application.u.DACy_applctn_h224.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_h224.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_NLPID:
            if (pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value)
            {
                MemFree(pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidData.value);
            }

            if (pTotCap->Cap.H245Dat_NLPID.application.u.DACy_applctn_nlpd.nlpidProtocol.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_applctn_nlpd.nlpidProtocol.u.DtPrtclCpblty_nnStndrd);
            }
            break;

        case H245_CLIENT_DAT_H222:
            if (pTotCap->Cap.H245Dat_H222.application.u.DACy_an_h222DtPrttnng.choice == DtPrtclCpblty_nnStndrd_chosen)
            {
                FreeNonStandardParameter(&pCapability->u.rcvDtApplctnCpblty.application.u.DACy_an_h222DtPrttnng.u.DtPrtclCpblty_nnStndrd);
            }
            break;
    }
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_mux
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

HRESULT
build_totcap_from_mux(H245_TOTCAP_T *pTotCap, MultiplexCapability *pMuxCap, H245_CAPDIR_T Dir)
{
  H245TRACE(0,10,"API:build_totcap_from_mux <-");

  /* initialize TotCap */
  pTotCap->Dir        = Dir;
  pTotCap->DataType   = H245_DATA_MUX;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  switch (pMuxCap->choice)
  {
  case MltplxCpblty_nonStandard_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - MltplxCpblty_nonStandard_chosen");
    pTotCap->Cap.H245Mux_NONSTD = pMuxCap->u.MltplxCpblty_nonStandard;
    pTotCap->ClientType = H245_CLIENT_MUX_NONSTD;
    // TBD - copy nonstandard parameter
    H245PANIC();
    break;

  case h222Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h222Capability_chosen");
    pTotCap->Cap.H245Mux_H222 = pMuxCap->u.h222Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H222;
    break;

  case h223Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h223Capability_chosen");
    pTotCap->Cap.H245Mux_H223 = pMuxCap->u.h223Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H223;
    break;

  case v76Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - v76Capability_chosen");
    pTotCap->Cap.H245Mux_VGMUX = pMuxCap->u.v76Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_VGMUX;
    break;

  case h2250Capability_chosen:
    H245TRACE(0,20,"API:build_totcap_from_mux - h2250Capability_chosen");
    pTotCap->Cap.H245Mux_H2250 = pMuxCap->u.h2250Capability;
    pTotCap->ClientType = H245_CLIENT_MUX_H2250;
    break;

  default:
    H245TRACE(0,20,"API:build_totcap_from_mux - unrecogized choice %d", pMuxCap->choice);
    return H245_ERROR_NOSUP;
  }

  H245TRACE(0,10,"API:build_totcap_from_mux -> OK");
  return H245_ERROR_OK;
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_from_captbl
 *
 * DESCRIPTION:
 *              called by both top down , and bottom up..
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
build_totcap_from_captbl (H245_TOTCAP_T        *pTotCap,
                          CapabilityTableLink   pCapLink,
                          int                   lcl_rmt)
{
  unsigned short choice;
  DWORD          error;

  H245TRACE(0,10,"API:build_totcap_from_captbl <-");

  /* initialize TotCap */
  pTotCap->Dir        = H245_CAPDIR_DONTCARE;
  pTotCap->DataType   = H245_DATA_DONTCARE;
  pTotCap->ClientType = H245_CLIENT_DONTCARE;
  pTotCap->CapId      = 0;

  /* note.. this has to come first if using for deleted caps */
  /* capability entry number will be present, however if     */
  /* the capability is not present that indicates that the   */
  /* capability should be deleted                            */

  pTotCap->CapId = pCapLink->value.capabilityTableEntryNumber;

  if (!(pCapLink->value.bit_mask & capability_present))
    return H245_ERROR_OK;

  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - Capability_nonStandard_chosen");
      pTotCap->DataType = H245_DATA_NONSTD;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = Capability_nonStandard_chosen;
      break;
    case receiveVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveVideoCapability.choice;
      break;
    case transmitVideoCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitVideoCapability_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitVideoCapability.choice;
      break;
    case rcvAndTrnsmtVdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtVdCpblty_chosen");
      pTotCap->DataType = H245_DATA_VIDEO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtVdCpblty.choice;
      break;
    case receiveAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - receiveAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.receiveAudioCapability.choice;
      break;
    case transmitAudioCapability_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - transmitAudioCapability_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.transmitAudioCapability.choice;
      break;
    case rcvAndTrnsmtAdCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvAndTrnsmtAdCpblty_chosen");
      pTotCap->DataType = H245_DATA_AUDIO;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      choice            = pCapLink->value.capability.u.rcvAndTrnsmtAdCpblty.choice;
      break;
    case rcvDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rcvDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice;
      break;
    case trnsmtDtApplctnCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - trnsmtDtApplctnCpblty_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLTX:H245_CAPDIR_RMTTX;
      choice            = pCapLink->value.capability.u.trnsmtDtApplctnCpblty.application.choice;
      break;
    case rATDACy_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - rATDACy_chosen");
      pTotCap->DataType = H245_DATA_DATA;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRX:H245_CAPDIR_RMTRX;
      choice            = pCapLink->value.capability.u.rATDACy.application.choice;
      break;
    case h233EncryptnTrnsmtCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnTrnsmtCpblty_chosen");
      pTotCap->DataType = H245_DATA_ENCRYPT_D;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      /* (TBC) */
      return H245_ERROR_NOSUP;
      break;
    case h233EncryptnRcvCpblty_chosen:
      H245TRACE(0,20,"API:build_totcap_from_captbl - h233EncryptnRcvCpblty_chosen");
      pTotCap->DataType = H245_DATA_ENCRYPT_D;
      pTotCap->Dir      = lcl_rmt==H245_LOCAL?H245_CAPDIR_LCLRXTX:H245_CAPDIR_RMTRXTX;
      /* (TBC) */
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_from_captbl - default");
      /* TBC .. */
      return H245_ERROR_NOSUP;
      break;
    }

  /* load the tot cap's capability and client from capability */
  if ((error = build_totcap_cap_n_client_from_capability (&pCapLink->value.capability,
                                                         pTotCap->DataType,
                                                         choice,
                                                         pTotCap)) != H245_ERROR_OK)
    {
      H245TRACE(0,1,"API:build_totcap_from_captbl -> %s",map_api_error(error));
      return error;
    }

  H245TRACE(0,10,"API:build_totcap_from_captbl -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   build_totcap_n_client_from_capbility
 *
 * DESCRIPTION:
 *              Take a capability structure (pCapability),
 *              data type (audio/video/data) choice...
 *              Which is found in the pdu . and the totcap;
 *              NOTE: does not handle H245_DATA_MUX_T
 *
 * RETURN:
 *
 * ASSUMES:
 *              ONLY HANDLES Terminal Caps.. Does not handle MUX Caps.
 *
 *              totcap.DataType is defined
 *              totcap.CapId    is defined
 *              totcap.Cap      is non NULL
 *
 *****************************************************************************/
HRESULT
build_totcap_cap_n_client_from_capability (struct Capability    *pCapability,
                                          H245_DATA_T            data_type,
                                          unsigned short         choice,
                                          H245_TOTCAP_T         *pTotCap)
{
  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability <-");

  switch (data_type)
    {
    case H245_DATA_NONSTD:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_NONSTD");
      pTotCap->ClientType = H245_CLIENT_NONSTD;
      pTotCap->Cap.H245_NonStd = pCapability->u.Capability_nonStandard;
      break;

    case H245_DATA_AUDIO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_AUDIO");
      switch (choice)
        {
        case AdCpblty_nonStandard_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_NONSTD;
          pTotCap->Cap.H245Aud_NONSTD      = pCapability->u.receiveAudioCapability.u.AdCpblty_nonStandard;
          break;
        case AdCpblty_g711Alaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW64;
          pTotCap->Cap.H245Aud_G711_ALAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw64k;
          break;
        case AdCpblty_g711Alaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Alaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ALAW56;
          pTotCap->Cap.H245Aud_G711_ALAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Alaw56k;
          break;
        case AdCpblty_g711Ulaw64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW64;
          pTotCap->Cap.H245Aud_G711_ULAW64 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw64k;
          break;
        case AdCpblty_g711Ulaw56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g711Ulaw56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G711_ULAW56;
          pTotCap->Cap.H245Aud_G711_ULAW56 = pCapability->u.receiveAudioCapability.u.AdCpblty_g711Ulaw56k;
          break;
        case AudioCapability_g722_64k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_64k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_64;
          pTotCap->Cap.H245Aud_G722_64     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_64k;
          break;
        case AudioCapability_g722_56k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_56k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_56;
          pTotCap->Cap.H245Aud_G722_56     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_56k;
          break;
        case AudioCapability_g722_48k_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g722_48k_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G722_48;
          pTotCap->Cap.H245Aud_G722_48     = pCapability->u.receiveAudioCapability.u.AudioCapability_g722_48k;
          break;
        case AudioCapability_g7231_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g7231_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G723;
          pTotCap->Cap.H245Aud_G723        = pCapability->u.receiveAudioCapability.u.AudioCapability_g7231;
          break;
        case AudioCapability_g728_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g728_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G728;
          pTotCap->Cap.H245Aud_G728        = pCapability->u.receiveAudioCapability.u.AudioCapability_g728;
          break;
        case AudioCapability_g729_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AudioCapability_g729_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_G729;
          pTotCap->Cap.H245Aud_G729        = pCapability->u.receiveAudioCapability.u.AudioCapability_g729;
          break;
        case AdCpblty_g729AnnexA_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - AdCpblty_g729AnnexA_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_GDSVD;
          pTotCap->Cap.H245Aud_GDSVD       = pCapability->u.receiveAudioCapability.u.AdCpblty_g729AnnexA;
          break;
        case is11172AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is11172AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS11172;
          pTotCap->Cap.H245Aud_IS11172     = pCapability->u.receiveAudioCapability.u.is11172AudioCapability;
          break;
        case is13818AudioCapability_chosen:
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - is13818AudioCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_AUD_IS13818;
          pTotCap->Cap.H245Aud_IS13818     = pCapability->u.receiveAudioCapability.u.is13818AudioCapability;
          break;
        default:
          pTotCap->ClientType = 0;
          H245TRACE(0,20,  "API:build_totcap_cap_n_client_from_capability - choice - default");
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_VIDEO:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_VIDEO");

      switch (choice)
        {
        case VdCpblty_nonStandard_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - VdCpblty_nonStandard_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_NONSTD;
          pTotCap->Cap.H245Vid_NONSTD    = pCapability->u.receiveVideoCapability.u.VdCpblty_nonStandard;
          break;
        case h261VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h261VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H261;
          pTotCap->Cap.H245Vid_H261      = pCapability->u.receiveVideoCapability.u.h261VideoCapability;
          break;
        case h262VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h262VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H262;
          pTotCap->Cap.H245Vid_H262      = pCapability->u.receiveVideoCapability.u.h262VideoCapability;
          break;
        case h263VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - h263VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_H263;
          pTotCap->Cap.H245Vid_H263      = pCapability->u.receiveVideoCapability.u.h263VideoCapability;
          break;
        case is11172VideoCapability_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - is11172VideoCapability_chosen");
          pTotCap->ClientType = H245_CLIENT_VID_IS11172;
          pTotCap->Cap.H245Vid_IS11172   = pCapability->u.receiveVideoCapability.u.is11172VideoCapability;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;

    case H245_DATA_DATA:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_DATA");

      pTotCap->Cap.H245Dat_NONSTD = pCapability->u.rcvDtApplctnCpblty;
      switch (choice)
        {
        case DACy_applctn_nnStndrd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nnStndrd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NONSTD;
          break;
        case DACy_applctn_t120_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t120_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T120;
          break;
        case DACy_applctn_dsm_cc_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsm_cc_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSMCC;
          break;
        case DACy_applctn_usrDt_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_usrDt_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_USERDATA;
          break;
        case DACy_applctn_t84_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t84_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T84;
          break;
        case DACy_applctn_t434_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_t434_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_T434;
          break;
        case DACy_applctn_h224_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_h224_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H224;
          break;
        case DACy_applctn_nlpd_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_nlpd_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_NLPID;
          break;
        case DACy_applctn_dsvdCntrl_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_applctn_dsvdCntrl_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_DSVD;
          break;
        case DACy_an_h222DtPrttnng_chosen:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - DACy_an_h222DtPrttnng_chosen");
          pTotCap->ClientType = H245_CLIENT_DAT_H222;
          break;
        default:
          H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - choice - default");
          pTotCap->ClientType = 0;
          return H245_ERROR_NOSUP;
          break;
        }
      break;
    case H245_DATA_ENCRYPT_D:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_ENCRYPT_D");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    case H245_DATA_MUX:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - H245_DATA_MUX");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
      break;
    default:
      H245TRACE(0,20,"API:build_totcap_cap_n_client_from_capability - default");
      pTotCap->ClientType = 0;
      H245PANIC();
      return H245_ERROR_NOSUP;
    }

  H245TRACE(0,10,"API:build_totcap_cap_n_client_from_capability -> OK");
  return H245_ERROR_OK;
}
/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_link
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
HRESULT
del_link (
          H245_LINK_T   **pp_link_start,
          H245_LINK_T   *p_link
          )
{
  struct H245_LINK_T    *p_link_look = NULL;
  struct H245_LINK_T    *p_link_lst = NULL;

  H245TRACE(0,10,"API:del_link <-");
  /* get current count on table */

  for (p_link_look = *pp_link_start;
       p_link_look && (p_link_look != p_link);
       p_link_lst = p_link_look,
         p_link_look = p_link_look->p_next
       );

  /* cap was not in list */

  if (!p_link_look)
  {
    H245TRACE(0,1,"API:del_link -> link not found!");
    return H245_ERROR_PARAM;
  }

  /* modify entry in table */
  if (!p_link_lst)
    *pp_link_start = p_link_look->p_next;

  else
    p_link_lst->p_next = p_link_look->p_next;

  MemFree (p_link_look);

  H245TRACE(0,10,"API:del_link -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   del_cap_link
 *
 * DESCRIPTION:
 *
 * ASSUMES:     Capability Table is locked before call
 *
 * RETURN:      None
 *
 * ASSUME:      List is Locked
 *
 *
 *****************************************************************************/
HRESULT
del_cap_link (
               struct TerminalCapabilitySet    *pTermCapSet,  /* capabilty set */
               CapabilityTableLink              pCapLink
             )
{
  CapabilityTableLink           pCapLink_look = NULL;
  CapabilityTableLink           pCapLink_lst = NULL;
  CapabilityTableEntry         *pCap_entry = NULL;
  unsigned char                *p_char_to_free = NULL;
  POBJECTID                     p_objid_to_free = NULL;

  H245TRACE(0,10,"API:del_cap_link <-");

  ASSERT (pTermCapSet);
  ASSERT (pCapLink);

  /************************************************/
  /* BEGIN :  Non Standard Capability Special Case */
  /************************************************/
  switch (pCapLink->value.capability.choice)
    {
    case Capability_nonStandard_chosen:

      /* free nonstandard data value */
      p_char_to_free = pCapLink->value.capability.u.Capability_nonStandard.data.value;

      /* free the object id */
      if (pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice == object_chosen)
        p_objid_to_free = pCapLink->value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.object;
      break;

    case receiveVideoCapability_chosen:
    case transmitVideoCapability_chosen:
    case rcvAndTrnsmtVdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveVideoCapability.choice == VdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.data.value;
          /* free the object id */
          if (pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveVideoCapability.u.VdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }

      break;

    case receiveAudioCapability_chosen:
    case transmitAudioCapability_chosen:
    case rcvAndTrnsmtAdCpblty_chosen:

      /* free nonstandard data value */
      if (pCapLink->value.capability.u.receiveAudioCapability.choice == AdCpblty_nonStandard_chosen)
        {
          /* nonstd value */
          p_char_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.receiveAudioCapability.u.AdCpblty_nonStandard.nonStandardIdentifier.u.object;
        }
      break;

    case rcvDtApplctnCpblty_chosen:
    case trnsmtDtApplctnCpblty_chosen:
    case rATDACy_chosen :

      if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.choice == DACy_applctn_nnStndrd_chosen)
        {
          /* free nonstandard data value */
          p_char_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.data.value;

          /* free the object id */
          if (pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
            p_objid_to_free = pCapLink->value.capability.u.rcvDtApplctnCpblty.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
        }
      break;

    case h233EncryptnTrnsmtCpblty_chosen:
    case h233EncryptnRcvCpblty_chosen:
    default:
      break;
    }

  /* free the value if there is one */
  if (p_char_to_free)
    {
      H245TRACE(0,0,"TMPMSG: Free NonStandard Value");
      MemFree(p_char_to_free);
    }

  /* free the objectid */
  if (p_objid_to_free)
    {
      H245TRACE(0,0,"TMPMSG: Free NonStandard ID");
      free_object_id (p_objid_to_free);
    }

  /************************************************/
  /* END :  Non Standard Capability Special Case  */
  /************************************************/

  H245TRACE(0,10,"API:del_cap_link -> OK");
  return del_link(&((H245_LINK_T *) pTermCapSet->capabilityTable),
           (H245_LINK_T *) pCapLink);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   dealloc_link_cap_list
 *
 * DESCRIPTION: deallocs the entire list of capabilities from a capabiltiy
 *              set
 *
 * ASSUMES:     Capability Table is locked before call
 *              del_cap_link updates pTermCapSet->capabilityTable
 *                   correctly.
 *
 *****************************************************************************/
void
dealloc_link_cap_list ( struct TerminalCapabilitySet *pTermCapSet)
{
  while (pTermCapSet->capabilityTable)
    del_cap_link  (pTermCapSet, pTermCapSet->capabilityTable);
}

/*****************************************************************************
 *
 * TYPE:
 *
 * PROCEDURE:   clean_cap_table - clean out all unused cap entries
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     on entry.. table locked
 *
 *****************************************************************************/
void
clean_cap_table( struct TerminalCapabilitySet *pTermCapSet )
{
  CapabilityTableLink   pCapLink;
  CapabilityTableLink   pCap_nxt;

  H245TRACE(0,10,"API:clean_cap_table <-");
  /* traverse through the list.. delete all where capabilities are not set */

  for (pCapLink = pTermCapSet->capabilityTable;
       pCapLink;)
    {
      pCap_nxt = pCapLink->next;

      if (!(pCapLink->value.bit_mask & capability_present))
        {
          H245TRACE(0,20,"API:clean_cap_table - deleting CapId = %d",
                    pCapLink->value.capabilityTableEntryNumber);
          del_cap_link ( pTermCapSet, pCapLink );
        }
      pCapLink = pCap_nxt;
    }

  /* if no tercaps present unset flag */
  if (!pTermCapSet->capabilityTable)
    pTermCapSet->bit_mask &= ~capabilityTable_present;

  H245TRACE(0,10,"API:clean_cap_table -> OK");
}


/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   alloc_link_tracker
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
alloc_link_tracker (struct InstanceStruct *     pInstance,
                    API_TRACKER_T               TrackerType,
                    DWORD_PTR                   dwTransId,
                    API_TRACKER_STATE_T         State,
                    API_TRACKER_CH_ALLOC_T      ChannelAlloc,
                    API_TRACKER_CH_T            ChannelType,
                    H245_DATA_T                 DataType,
                    H245_CHANNEL_T              wTxChannel,
                    H245_CHANNEL_T              wRxChannel,
                    DWORD                       MuxEntryCount
                    )
{
  Tracker_T *p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker <-");
  /* allocate tracker object */

  if (!(p_tracker = (Tracker_T *)MemAlloc(sizeof(Tracker_T))))
  {
    H245TRACE(pInstance->dwInst,1,"API:alloc_link_trakcer -> No memory");
    return NULL;
  }

  p_tracker->TrackerType            = TrackerType;
  p_tracker->TransId                = dwTransId;
  p_tracker->State                  = State;
  switch (TrackerType)
  {
  case API_OPEN_CHANNEL_T:
  case API_CLOSE_CHANNEL_T:
    p_tracker->u.Channel.ChannelAlloc = ChannelAlloc;
    p_tracker->u.Channel.ChannelType  = ChannelType;
    p_tracker->u.Channel.DataType     = DataType;
    p_tracker->u.Channel.TxChannel    = wTxChannel;
    p_tracker->u.Channel.RxChannel    = wRxChannel;
    break;

  case API_SEND_MUX_T:
  case API_RECV_MUX_T:
    p_tracker->u.MuxEntryCount        = MuxEntryCount;
    break;

  default:
    break;
  } // switch

  p_tracker->p_next                 = pInstance->API.pTracker;
  if (p_tracker->p_next)
  {
    p_tracker->p_prev = p_tracker->p_next->p_prev;
    p_tracker->p_next->p_prev = p_tracker;
  }
  else
  {

    p_tracker->p_prev = NULL;
  }
  pInstance->API.pTracker = p_tracker;

  H245TRACE(pInstance->dwInst,10,"API:alloc_link_tracker -> %x", p_tracker);
  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void
unlink_dealloc_tracker (struct InstanceStruct *pInstance,  Tracker_T *p_tracker)
{
  H245TRACE(pInstance->dwInst,4,"API:unlink_dealloc_tracker - type = %s",map_tracker_type (p_tracker->TrackerType));

  if (p_tracker->p_next)
    p_tracker->p_next->p_prev = p_tracker->p_prev;

  /* if not first on the list */
  if (p_tracker->p_prev)
    p_tracker->p_prev->p_next = p_tracker->p_next;
  else
    pInstance->API.pTracker = p_tracker->p_next;

  MemFree (p_tracker);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_txchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_txchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.TxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_rxchannel
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_rxchannel (struct InstanceStruct *pInstance, DWORD dwChannel, API_TRACKER_CH_ALLOC_T ChannelAlloc)
{
  register Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;p_tracker;p_tracker = p_tracker->p_next)
  {
    if (p_tracker->u.Channel.RxChannel    == dwChannel &&
        p_tracker->u.Channel.ChannelAlloc == ChannelAlloc)
    {
      return p_tracker;
    }
  }

  return NULL;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_pointer
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_pointer (struct InstanceStruct *pInstance, Tracker_T *p_tracker_look)
{
  Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);

  for (p_tracker = pInstance->API.pTracker;
       ((p_tracker) && (p_tracker != p_tracker_look));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   find_tracker_by_type
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:     table MUST be locked before this call on this call ..
 *
 *****************************************************************************/
Tracker_T *
find_tracker_by_type (struct InstanceStruct *pInstance,
                      API_TRACKER_T tracker_type,
                      Tracker_T *p_tracker_start)
{
  Tracker_T *p_tracker;

  ASSERT (pInstance != NULL);
  if (p_tracker_start)
    p_tracker = p_tracker_start;
  else
    p_tracker = pInstance->API.pTracker;

  for (;
       ((p_tracker) && (p_tracker->TrackerType != tracker_type));
       p_tracker = p_tracker->p_next);

  return p_tracker;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   set_capability -
 *
 * DESCRIPTION:
 *              NOTE: capid in the TotCap structure is
 *                    ignored.
 *
 * RETURN:
 *              NewCapId            if no error
 *              H245_INVALID_CAPID  if error
 *
 * ASSUMES:
 *              Assumes the H245_INST_T is valid and has been checked
 *
 *****************************************************************************/
void del_mux_cap(struct TerminalCapabilitySet *pTermCapSet)
{
  if (pTermCapSet->bit_mask & multiplexCapability_present)
  {
    switch (pTermCapSet->multiplexCapability.choice)
    {
    case MltplxCpblty_nonStandard_chosen:
      FreeNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard);
      break;

    case h222Capability_chosen:
      FreeH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability);
      break;

    case h2250Capability_chosen:
      FreeH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability);
      break;

    } // switch
    pTermCapSet->bit_mask &= ~multiplexCapability_present;
  }
} // del_mux_cap()

HRESULT set_mux_cap(struct InstanceStruct        *pInstance,
                    struct TerminalCapabilitySet *pTermCapSet,
                    H245_TOTCAP_T                *pTotCap)
{
  HRESULT                   lError;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_MUX_NONSTD:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - NONSTD");
    lError = CopyNonStandardParameter(&pTermCapSet->multiplexCapability.u.MltplxCpblty_nonStandard,
                                        &pTotCap->Cap.H245Mux_NONSTD);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = MltplxCpblty_nonStandard_chosen;
    break;

  case H245_CLIENT_MUX_H222:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H222");
    lError = CopyH222Cap(&pTermCapSet->multiplexCapability.u.h222Capability,
                           &pTotCap->Cap.H245Mux_H222);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h222Capability_chosen;
    break;

  case H245_CLIENT_MUX_H223:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H223");
    pTermCapSet->multiplexCapability.u.h223Capability = pTotCap->Cap.H245Mux_H223;
    pTermCapSet->multiplexCapability.choice = h223Capability_chosen;
    break;

  case H245_CLIENT_MUX_VGMUX:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - VGMUX");
    pTermCapSet->multiplexCapability.u.v76Capability = pTotCap->Cap.H245Mux_VGMUX;
    pTermCapSet->multiplexCapability.choice = v76Capability_chosen;
    break;

  case H245_CLIENT_MUX_H2250:
    H245TRACE(pInstance->dwInst,4,"API:set_mux_cap - H2250");
    lError = CopyH2250Cap(&pTermCapSet->multiplexCapability.u.h2250Capability,
                          &pTotCap->Cap.H245Mux_H2250);
    if (lError != H245_ERROR_OK)
      return lError;
    pTermCapSet->multiplexCapability.choice = h2250Capability_chosen;
    break;

  default:
    H245TRACE(pInstance->dwInst,1,"API:set_mux_cap - Unrecognized Client Type %d", pTotCap->ClientType);
    return H245_ERROR_NOSUP;
  }

  pTermCapSet->bit_mask |= multiplexCapability_present;
  return H245_ERROR_OK;
} // set_mux_cap()

HRESULT
set_capability (
                struct InstanceStruct        *pInstance,
                struct TerminalCapabilitySet *pTermCapSet,
                H245_TOTCAP_T                *pTotCap         /* tot capability for update*/
                )
{
  CapabilityTableEntry         *pCapEntry;
  Capability                   *pCapability;
  CapabilityTableLink           pCapLink;
  HRESULT                       lError;

  ASSERT(pInstance   != NULL);
  ASSERT(pTermCapSet != NULL);
  ASSERT(pTotCap     != NULL);

  /* if the table entry is currently in the table, */
  /* then  delete it and add a new entry with the same entry number */
  pCapLink = find_capid_by_entrynumber (pTermCapSet, pTotCap->CapId);
  if (pCapLink)
  {
    del_cap_link (pTermCapSet, pCapLink);
  } /* if pCapLink */

  /* allocate an entry for the new terminal capbaility  */
  pCapLink = alloc_link_cap_entry (pTermCapSet);
  if (pCapLink == NULL)
  {
    return H245_ERROR_NOMEM;
  }

  /* make it easier to deal with the Asn1 structures */
  pCapEntry   = &pCapLink->value;
  pCapability = &pCapEntry->capability;
  pCapability->choice = 0;
  switch (pTotCap->DataType)
  {
  case H245_DATA_NONSTD:
    pCapability->choice = Capability_nonStandard_chosen;
    break;

  case H245_DATA_VIDEO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveVideoCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtVdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_AUDIO:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = transmitAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = receiveAudioCapability_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rcvAndTrnsmtAdCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_DATA:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = trnsmtDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = rcvDtApplctnCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRXTX:
    case H245_CAPDIR_LCLRXTX:
      pCapability->choice = rATDACy_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_ENCRYPT_D:
    switch (pTotCap->Dir)
    {
    case H245_CAPDIR_RMTTX:
    case H245_CAPDIR_LCLTX:
      pCapability->choice = h233EncryptnTrnsmtCpblty_chosen;
      break;
    case H245_CAPDIR_RMTRX:
    case H245_CAPDIR_LCLRX:
      pCapability->choice = h233EncryptnRcvCpblty_chosen;
      break;
    } // switch (Dir)
    break;

  case H245_DATA_CONFERENCE:
    pCapability->choice = conferenceCapability_chosen;
    break;

  } // switch (DataType)

  /* if error occured, free cap, unlock, and return */
  if (pCapability->choice == 0)
  {
    H245TRACE(pInstance->dwInst,1,"API:set_capability -> Invalid capability");
    del_cap_link (pTermCapSet, pCapLink);
    return H245_ERROR_PARAM;
  }

  /* load total cap into Capability Set */
  /* if load cap returns error, free cap, unlock, and return */
  lError = load_cap(pCapability, pTotCap);
  if (lError != H245_ERROR_OK)
  {
    del_cap_link (pTermCapSet, pCapLink);
    return lError;
  }

  /* mark the entry as in use */
  pCapEntry->bit_mask = capability_present;
  pCapEntry->capabilityTableEntryNumber = pTotCap->CapId;

  /* set termcapTable  present */
  pTermCapSet->bit_mask |= capabilityTable_present;

  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Local
 *
 * PROCEDURE:   build_object_id
 *
 * DESCRIPTION
 *
 * RETURN:      linked list of Object ID structures
 *
 * ASSUMES:     Input string is a valid "<n>.<n>.<n>..."
 *
 *****************************************************************************/
static POBJECTID
build_object_id (const char *p_str)
{
  POBJECTID p_obj_id             = NULL;
  POBJECTID p_obj_id_first       = NULL;
  POBJECTID p_obj_id_lst         = NULL;
  int    value = 0;
  int    fset = FALSE;

  /* if no sting.. forget it */

  if (!p_str)
    return NULL;

  H245TRACE(0,20,"API:Object Id %s",p_str);

  /* while there is a string left.. */

  while (*p_str != '\0')
    {
      /* while there is a string left, and it's not a '.' */

      value = 0;
      fset = FALSE;

      while ((*p_str != '\0') && (*p_str != '.'))
        {
          fset = TRUE;
          value = value*10+(*p_str-'0');
          p_str++;
        }
      /* must ahve been a "." or an end string */

      if (fset)
        {
          if (*p_str != '\0')
            p_str++;

          /* allocate the first object */
          if (!(p_obj_id = (POBJECTID) MemAlloc (sizeof(*p_obj_id))))
            {
              free_object_id (p_obj_id_first);

              return NULL;

            } /* if alloc failes */

          /* if first objected allocated */
          if (!p_obj_id_first)
            p_obj_id_first = p_obj_id;
          else
            p_obj_id_lst->next = p_obj_id;

          p_obj_id->value = (unsigned short) value;
          p_obj_id->next = NULL;
          p_obj_id_lst = p_obj_id;
        }

    } /* while  */

  return p_obj_id_first;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_table_list - recursively free mux table list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_table_list (H245_MUX_TABLE_T *p_mux_tbl)
{
  if (!p_mux_tbl)
    return;

  free_mux_table_list (p_mux_tbl->pNext);
  free_mux_el_list (p_mux_tbl->pMuxTblEntryElem);
  MemFree (p_mux_tbl);
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   free_mux_el_list - recursively free mux element list
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUME:      List is Locked
 *
 *****************************************************************************/
void free_mux_el_list (H245_MUX_ENTRY_ELEMENT_T *p_mux_el)
{
  if (!p_mux_el)
    return;

  if (p_mux_el->Kind == H245_MUX_ENTRY_ELEMENT)
    free_mux_el_list (p_mux_el->u.pMuxTblEntryElem);

  free_mux_el_list (p_mux_el->pNext);
  MemFree (p_mux_el);
}
/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_init ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_init (struct InstanceStruct *pInstance)
{
  ASSERT (pInstance != NULL);

  H245TRACE(pInstance->dwInst,10,"API:api_init <-");

  /**************************/
  /* Terminal Cap TABLE     */
  /**************************/
  pInstance->API.PDU_LocalTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;
  pInstance->API.PDU_RemoteTermCap.choice = MltmdSystmCntrlMssg_rqst_chosen;
  pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.choice =
    terminalCapabilitySet_chosen;

  /**************************/
  /* MULTIPLEX TABLE CAP's  */
  /**************************/

  switch (pInstance->Configuration)
    {
    case H245_CONF_H324:
      {
        H223Capability *p_H223;
        /* set h223 capabilities */
        pInstance->API.PDU_LocalTermCap.
          u.MltmdSystmCntrlMssg_rqst.
            u.terminalCapabilitySet.multiplexCapability.choice =
              h223Capability_chosen;

        p_H223 = &(pInstance->API.PDU_LocalTermCap.
                   u.MltmdSystmCntrlMssg_rqst.
                    u.terminalCapabilitySet.multiplexCapability.
                     u.h223Capability);

        /* (TBC) how do we communicate this to the API */
        /* booleans.. */
        p_H223->transportWithI_frames;
        p_H223-> videoWithAL1 = FALSE;
        p_H223-> videoWithAL2 = FALSE;
        p_H223-> videoWithAL3 = TRUE;
        p_H223-> audioWithAL1 = FALSE;
        p_H223-> audioWithAL2 = TRUE;
        p_H223-> audioWithAL3 = FALSE;
        p_H223-> dataWithAL1 = FALSE;
        p_H223-> dataWithAL2 = FALSE;
        p_H223-> dataWithAL3 = FALSE;
        /* ushort's */
        p_H223-> maximumAl2SDUSize = 2048;
        p_H223-> maximumAl3SDUSize = 2048;
        p_H223-> maximumDelayJitter = 0;
        /* enhanced/Basic */
        p_H223->h223MultiplexTableCapability.choice = h223MltplxTblCpblty_bsc_chosen;
      }
      break;
    case H245_CONF_H323:
      break;
    case H245_CONF_H310:
    case H245_CONF_GVD:
    default:
      return H245_ERROR_NOSUP;
      break;

    } /* switch */

  /* setup Object Id for Terminal Cap Set */
  /* (TBC) where do we get/set the protocolIdentifier */
  pInstance->API.PDU_LocalTermCap.
    u.MltmdSystmCntrlMssg_rqst.
      u.terminalCapabilitySet.protocolIdentifier = build_object_id (H245_PROTOID);

  pInstance->API.MasterSlave = APIMS_Undef;
  pInstance->API.SystemState = APIST_Inited;

  pInstance->API.LocalCapIdNum = H245_MAX_CAPID + 1;
  pInstance->API.LocalCapDescIdNum = 0;

  H245TRACE(pInstance->dwInst,10,"API:api_init -> OK");
  return H245_ERROR_OK;
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   api_deinit ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
HRESULT
api_deinit (struct InstanceStruct *pInstance)
{
  Tracker_T *pTracker;
  int        nCount;

  H245TRACE(pInstance->dwInst,10,"API:api_deinit <-");

  /* free structures and act on outstanding links in structure */
#ifndef NDEBUG
  dump_tracker(pInstance);
#endif
  free_object_id (pInstance->API.PDU_LocalTermCap.
                  u.MltmdSystmCntrlMssg_rqst.
                  u.terminalCapabilitySet.protocolIdentifier);

  /* free simultaneous capabilities */
  for (nCount = 0; nCount < 256; ++nCount)
  {
    if (pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_LocalTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
    if (pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount].smltnsCpblts)
      dealloc_simultaneous_cap (&pInstance->API.PDU_RemoteTermCap.TERMCAPSET.capabilityDescriptors.value[nCount]);
  }

  /* free capabilities */
  del_mux_cap(&pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  del_mux_cap(&pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
  dealloc_link_cap_list ( &pInstance->API.PDU_LocalTermCap.TERMCAPSET);
  dealloc_link_cap_list ( &pInstance->API.PDU_RemoteTermCap.TERMCAPSET);

  while ((pTracker = pInstance->API.pTracker) != NULL)
  {
    H245TRACE(pInstance->dwInst,1,"API:api_deinit -> %s Tracker Still Pending",
              map_tracker_type(pTracker->TrackerType));
    unlink_dealloc_tracker (pInstance, pTracker);
  }

  H245TRACE(pInstance->dwInst,10,"API:api_deinit -> OK");
  return H245_ERROR_OK;
}

#if defined(_DEBUG)

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_api_error ()
 *
 * DESCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/

LPSTR map_api_error (HRESULT lError)
{
  static TCHAR szBuf[128];

  switch (lError)
  {
  case  H245_ERROR_OK:                  return "H245_ERROR_OK";
  case  H245_ERROR_INVALID_DATA_FORMAT: return "H245_ERROR_INVALID_DATA_FORMAT";
  case  H245_ERROR_NOMEM:               return "H245_ERROR_NOMEM";
  case  H245_ERROR_NOSUP:               return "H245_ERROR_NOSUP";
  case  H245_ERROR_PARAM:               return "H245_ERROR_PARAM";
  case  H245_ERROR_ALREADY_INIT:        return "H245_ERROR_ALREADY_INIT";
  case  H245_ERROR_NOT_CONNECTED:       return "H245_ERROR_NOT_CONNECTED";



  case  H245_ERROR_NORESOURCE:          return "H245_ERROR_NORESOURCE";
  case  H245_ERROR_NOTIMP:              return "H245_ERROR_NOTIMP";
  case  H245_ERROR_SUBSYS:              return "H245_ERROR_SUBSYS";
  case  H245_ERROR_FATAL:               return "H245_ERROR_FATAL";
  case  H245_ERROR_MAXTBL:              return "H245_ERROR_MAXTBL";
  case  H245_ERROR_CHANNEL_INUSE:       return "H245_ERROR_CHANNEL_INUSE";
  case  H245_ERROR_INVALID_CAPID:       return "H245_ERROR_INVALID_CAPID";
  case  H245_ERROR_INVALID_OP:          return "H245_ERROR_INVALID_OP";
  case  H245_ERROR_UNKNOWN:             return "H245_ERROR_UNKNOWN";
  case  H245_ERROR_NOBANDWIDTH:         return "H245_ERROR_NOBANDWIDTH";
  case  H245_ERROR_LOSTCON:             return "H245_ERROR_LOSTCON";
  case  H245_ERROR_INVALID_MUXTBLENTRY: return "H245_ERROR_INVALID_MUXTBLENTRY";
  case  H245_ERROR_INVALID_INST:        return "H245_ERROR_INVALID_INST";
  case  H245_ERROR_INPROCESS:           return "H245_ERROR_INPROCESS";
  case  H245_ERROR_INVALID_STATE:       return "H245_ERROR_INVALID_STATE";
  case  H245_ERROR_TIMEOUT:             return "H245_ERROR_TIMEOUT";
  case  H245_ERROR_INVALID_CHANNEL:     return "H245_ERROR_INVALID_CHANNEL";
  case  H245_ERROR_INVALID_CAPDESCID:   return "H245_ERROR_INVALID_CAPDESCID";
  case  H245_ERROR_CANCELED:            return "H245_ERROR_CANCELED";
  case  H245_ERROR_MUXELEMENT_DEPTH:    return "H245_ERROR_MUXELEMENT_DEPTH";
  case  H245_ERROR_MUXELEMENT_WIDTH:    return "H245_ERROR_MUXELEMENT_WIDTH";
  case  H245_ERROR_ASN1:                return "H245_ERROR_ASN1";
  case  H245_ERROR_NO_MUX_CAPS:         return "H245_ERROR_NO_MUX_CAPS";
  case  H245_ERROR_NO_CAPDESC:          return "H245_ERROR_NO_CAPDESC";
  default:
    wsprintf (szBuf,"**** UNKNOWN ERROR *** %d (0x%x)",lError,lError);
    return szBuf;
  }
}

/*****************************************************************************
 *
 * TYPE:        Global
 *
 * PROCEDURE:   map_fsm_event -
 *
 * DESpCRIPTION:
 *
 * RETURN:
 *
 * ASSUMES:
 *
 *****************************************************************************/
LPSTR map_fsm_event (DWORD event)
{
  static TCHAR szBuf[128];

  switch (event)
  {
  case  H245_IND_MSTSLV:                 return "H245_IND_MSTSLV";
  case  H245_IND_CAP:                    return "H245_IND_CAP";
  case  H245_IND_OPEN:                   return "H245_IND_OPEN";
  case  H245_IND_OPEN_CONF:              return "H245_IND_OPEN_CONF";
  case  H245_IND_CLOSE:                  return "H245_IND_CLOSE";
  case  H245_IND_REQ_CLOSE:              return "H245_IND_REQ_CLOSE";
  case  H245_IND_MUX_TBL:                return "H245_IND_MUX_TBL";
  case  H245_IND_MTSE_RELEASE:           return "H245_IND_MTSE_RELEASE";
  case  H245_IND_RMESE:                  return "H245_IND_RMESE";
  case  H245_IND_RMESE_RELEASE:          return "H245_IND_RMESE_RELEASE";
  case  H245_IND_MRSE:                   return "H245_IND_MRSE";
  case  H245_IND_MRSE_RELEASE:           return "H245_IND_MRSE_RELEASE";
  case  H245_IND_MLSE:                   return "H245_IND_MLSE";
  case  H245_IND_MLSE_RELEASE:           return "H245_IND_MLSE_RELEASE";
  case  H245_IND_NONSTANDARD_REQUEST:    return "H245_IND_NONSTANDARD_REQUEST";
  case  H245_IND_NONSTANDARD_RESPONSE:   return "H245_IND_NONSTANDARD_RESPONSE";
  case  H245_IND_NONSTANDARD_COMMAND:    return "H245_IND_NONSTANDARD_COMMAND";
  case  H245_IND_NONSTANDARD:            return "H245_IND_NONSTANDARD";
  case  H245_IND_MISC_COMMAND:           return "H245_IND_MISC_COMMAND";
  case  H245_IND_MISC:                   return "H245_IND_MISC";
  case  H245_IND_COMM_MODE_REQUEST:      return "H245_IND_COMM_MODE_REQUEST";
  case  H245_IND_COMM_MODE_RESPONSE:     return "H245_IND_COMM_MODE_RESPONSE";
  case  H245_IND_COMM_MODE_COMMAND:      return "H245_IND_COMM_MODE_COMMAND";
  case  H245_IND_CONFERENCE_REQUEST:     return "H245_IND_CONFERENCE_REQUEST";
  case  H245_IND_CONFERENCE_RESPONSE:    return "H245_IND_CONFERENCE_RESPONSE";
  case  H245_IND_CONFERENCE_COMMAND:     return "H245_IND_CONFERENCE_COMMAND";
  case  H245_IND_CONFERENCE:             return "H245_IND_CONFERENCE";
  case  H245_IND_SEND_TERMCAP:           return "H245_IND_SEND_TERMCAP";
  case  H245_IND_ENCRYPTION:             return "H245_IND_ENCRYPTION";
  case  H245_IND_FLOW_CONTROL:           return "H245_IND_FLOW_CONTROL";
  case  H245_IND_ENDSESSION:             return "H245_IND_ENDSESSION";
  case  H245_IND_FUNCTION_NOT_UNDERSTOOD:return "H245_IND_FUNCTION_NOT_UNDERSTOOD:";
  case  H245_IND_JITTER:                 return "H245_IND_JITTER";
  case  H245_IND_H223_SKEW:              return "H245_IND_H223_SKEW";
  case  H245_IND_NEW_ATM_VC:             return "H245_IND_NEW_ATM_VC";
  case  H245_IND_USERINPUT:              return "H245_IND_USERINPUT";
  case  H245_IND_H2250_MAX_SKEW:         return "H245_IND_H2250_MAX_SKEW";
  case  H245_IND_MC_LOCATION:            return "H245_IND_MC_LOCATION";
  case  H245_IND_VENDOR_ID:              return "H245_IND_VENDOR_ID";
  case  H245_IND_FUNCTION_NOT_SUPPORTED: return "H245_IND_FUNCTION_NOT_SUPPORTED";
  case  H245_IND_H223_RECONFIG:          return "H245_IND_H223_RECONFIG";
  case  H245_IND_H223_RECONFIG_ACK:      return "H245_IND_H223_RECONFIG_ACK";
  case  H245_IND_H223_RECONFIG_REJECT:   return "H245_IND_H223_RECONFIG_REJECT";
  case  H245_CONF_INIT_MSTSLV:           return "H245_CONF_INIT_MSTSLV";
  case  H245_CONF_SEND_TERMCAP:          return "H245_CONF_SEND_TERMCAP";
  case  H245_CONF_OPEN:                  return "H245_CONF_OPEN";
  case  H245_CONF_NEEDRSP_OPEN:          return "H245_CONF_NEEDRSP_OPEN";
  case  H245_CONF_CLOSE:                 return "H245_CONF_CLOSE";
  case  H245_CONF_REQ_CLOSE:             return "H245_CONF_REQ_CLOSE";
  case  H245_CONF_MUXTBL_SND:            return "H245_CONF_MUXTBL_SND";
  case  H245_CONF_RMESE:                 return "H245_CONF_RMESE";
  case  H245_CONF_RMESE_REJECT:          return "H245_CONF_RMESE_REJECT";
  case  H245_CONF_RMESE_EXPIRED:         return "H245_CONF_RMESE_EXPIRED";
  case  H245_CONF_MRSE:                  return "H245_CONF_MRSE";
  case  H245_CONF_MRSE_REJECT:           return "H245_CONF_MRSE_REJECT";
  case  H245_CONF_MRSE_EXPIRED:          return "H245_CONF_MRSE_EXPIRED";
  case  H245_CONF_MLSE:                  return "H245_CONF_MLSE";
  case  H245_CONF_MLSE_REJECT:           return "H245_CONF_MLSE_REJECT";
  case  H245_CONF_MLSE_EXPIRED:          return "H245_CONF_MLSE_EXPIRED";
  case  H245_CONF_RTDSE:                 return "H245_CONF_RTDSE";
  case  H245_CONF_RTDSE_EXPIRED:         return "H245_CONF_RTDSE_EXPIRED";
  default:
    wsprintf (szBuf,"**** UNKNOWN EVENT *** %d (0x%x)",event,event);
    return szBuf;
  }
}

LPSTR map_tracker_type (API_TRACKER_T tracker_type)
{
  static TCHAR szBuf[128];

  switch (tracker_type)
  {
  case  API_TERMCAP_T:       return "API_TERMCAP_T";
  case  API_OPEN_CHANNEL_T:  return "API_OPEN_CHANNEL_T";
  case  API_CLOSE_CHANNEL_T: return "API_CLOSE_CHANNEL_T";
  case  API_MSTSLV_T:        return "API_MSTSLV_T";
  case  API_SEND_MUX_T:      return "API_SEND_MUX_T";
  case  API_RECV_MUX_T:      return "API_RECV_MUX_T";
  default:
    wsprintf (szBuf,"**** UNKNOWN TRACKER TYPE *** %d (0x%x)",tracker_type,tracker_type);
    return szBuf;
  }
}

#endif // (_DEBUG)

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\coder.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*																		*
*	$Archive:   S:\sturgeon\src\gkpdu\vcs\coder.cpv  $
*																		*
*	$Revision:   1.5  $
*	$Date:   24 Jan 1997 19:38:44  $
*																		*
*	$Author:   BPOLING  $
*
*	$Log:   S:\sturgeon\src\gkpdu\vcs\coder.cpv  $
//
//    Rev 1.5   24 Jan 1997 19:38:44   BPOLING
// remove string include files, not needed.
//
//    Rev 1.2   18 Dec 1996 21:49:12   BPOLING
// builds with msdev and for windows only
//
//    Rev 1.1   15 Nov 1996 16:17:44   BPOLING
// added vcs headers.
*
*************************************************************************
*																		*
*	CODER.CPP															*
*																		*
*	PURPOSE:															*
*																		*
*	FUNCTIONS:															*
*																		*
*	COMMENTS: 															*
*																		*
*																		*
*************************************************************************
*																		*
*	$History: CODER.CPP													*
*																		*
*																		*
************************************************************************/

/************************************************************************
 * 							Include Files           				   	*
 ***********************************************************************/

#include "precomp.h"

#ifdef __cplusplus
extern "C" {
#endif /*__cplusplus*/

#include   "h225asn.h"
#include   "coder.hpp"

#ifdef __cplusplus
}
#endif /*__cplusplus*/

/************************************************************************
 * 							Local Manifest Constants					*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/


/************************************************************************
 * 							Local Private Data						   	*
 ***********************************************************************/

/************************************************************************
 * 								Start of Code							*
 ***********************************************************************/


Coder::Coder(){
}

Coder::~Coder(){

	EnterCriticalSection(&m_critSec);
	GK_TermWorld(&m_World);
	LeaveCriticalSection(&m_critSec);
	DeleteCriticalSection(&m_critSec);
}

// initializes the oss library.
// the oss library provide ASN.1 encoding / decoding libraries.
//

int Coder::InitCoder()
{

    int	iError = 0;
	m_protocolIdentifier1.next = &m_protocolIdentifier2;
	m_protocolIdentifier1.value = ITU_T;
	m_protocolIdentifier2.next = &m_protocolIdentifier3;
	m_protocolIdentifier2.value = RECOMMENDATION;
	m_protocolIdentifier3.next = &m_protocolIdentifier4;
	m_protocolIdentifier3.value = SERIES;
	m_protocolIdentifier4.next = &m_protocolIdentifier5;
	m_protocolIdentifier4.value = RECOMM_NUMBER;
	m_protocolIdentifier5.next = &m_protocolIdentifier6;
	m_protocolIdentifier5.value = VERSION;
	m_protocolIdentifier6.next = NULL;
	m_protocolIdentifier6.value = ADDITIONAL;
	InitializeCriticalSection(&m_critSec);
	
	// Call TELES Library initialization routine
    EnterCriticalSection(&m_critSec);
    iError = GK_InitWorld(&m_World);
	LeaveCriticalSection(&m_critSec);

	return iError;
}

// ASN.1 Encode a H.323 PDU
// Take a H.323 structure and returns a H.323 PDU
//
int Coder::	Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf){
	int iError;

	// initialize encoding buffer structure values
	pOutputOssBuf->value = NULL;
	pOutputOssBuf->length = 0;

	// encode pdu
	EnterCriticalSection(&m_critSec);
    iError = GK_Encode(&m_World,
                       (void *)pInputData,
                       RasMessage_PDU,
                       pOutputOssBuf);
	LeaveCriticalSection(&m_critSec);
    return iError;
}


int Coder::Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData){
	int iError;

	// NULL tells decoder to malloc memory for RasMessage
	// user must free this memory by calling Coder::FreePDU()
	 *pOutputData = NULL;
	
	// decode the pdu
	EnterCriticalSection(&m_critSec);
    iError = GK_Decode(&m_World,
                       (void **)pOutputData,
                       RasMessage_PDU,
                       pInputOssBuf);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by decode
int Coder::Free(RasMessage *pData){
	int iError;

	EnterCriticalSection(&m_critSec);
//	iError = freePDU(&m_World,RasMessage_PDU,pData, GKPDU_Module);
	iError = freePDU(&m_World,RasMessage_PDU,pData, H225ASN_Module);
	LeaveCriticalSection(&m_critSec);
	return iError;
}

// Used to free buffer created by encode
void Coder::Free(ASN1_BUF Asn1Buf){
	EnterCriticalSection(&m_critSec);
	//GKPDU_Module->encfree(m_World.pEncInfo,(void *)(Asn1Buf.value));
	ASN1_FreeEncoded(m_World.pEncInfo,(void *)(Asn1Buf.value));
	LeaveCriticalSection(&m_critSec);
}


RequestSeqNum Coder::GetSequenceNumber(RasMessage *prasStruct){
	
	RequestSeqNum rNum = 0;

	switch(prasStruct->choice){
		case gatekeeperRequest_chosen:
			return prasStruct->u.gatekeeperRequest.requestSeqNum;
		case gatekeeperConfirm_chosen:
			return prasStruct->u.gatekeeperConfirm.requestSeqNum;
		case gatekeeperReject_chosen:
			return prasStruct->u.gatekeeperReject.requestSeqNum;
		case registrationRequest_chosen:
			return prasStruct->u.registrationRequest.requestSeqNum;
		case registrationConfirm_chosen:
			return prasStruct->u.registrationConfirm.requestSeqNum;
		case registrationReject_chosen:
			return prasStruct->u.registrationReject.requestSeqNum;
		case unregistrationRequest_chosen:
			return prasStruct->u.unregistrationRequest.requestSeqNum;
		case unregistrationConfirm_chosen:
			return prasStruct->u.unregistrationConfirm.requestSeqNum;
		case unregistrationReject_chosen:
			return prasStruct->u.unregistrationReject.requestSeqNum;
		case admissionRequest_chosen:
			return prasStruct->u.admissionRequest.requestSeqNum;
		case admissionConfirm_chosen:
			return prasStruct->u.admissionConfirm.requestSeqNum;
		case admissionReject_chosen:
			return prasStruct->u.admissionReject.requestSeqNum;
		case bandwidthRequest_chosen:
			return prasStruct->u.bandwidthRequest.requestSeqNum;
		case bandwidthConfirm_chosen:
			return prasStruct->u.bandwidthConfirm.requestSeqNum;
		case bandwidthReject_chosen:
			return prasStruct->u.bandwidthReject.requestSeqNum;
		case disengageRequest_chosen:
			return prasStruct->u.disengageRequest.requestSeqNum;
		case disengageConfirm_chosen:
			return prasStruct->u.disengageConfirm.requestSeqNum;
		case disengageReject_chosen:
			return prasStruct->u.disengageReject.requestSeqNum;
		case locationRequest_chosen:
			return prasStruct->u.locationRequest.requestSeqNum;
		case locationConfirm_chosen:
			return prasStruct->u.locationConfirm.requestSeqNum;
		case locationReject_chosen:
			return prasStruct->u.locationReject.requestSeqNum;
		case infoRequest_chosen:
			return prasStruct->u.infoRequest.requestSeqNum;
		case infoRequestResponse_chosen:
			return prasStruct->u.infoRequestResponse.requestSeqNum;
		case nonStandardMessage_chosen:
			return prasStruct->u.nonStandardMessage.requestSeqNum;
		case unknownMessageResponse_chosen:
			return prasStruct->u.unknownMessageResponse.requestSeqNum;
		default:
			return rNum;
	}

	return rNum;

}


RequestSeqNum Coder::SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum){
	
	RequestSeqNum rNum = 0;

	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			return (rasStruct.u.gatekeeperRequest.requestSeqNum = reqNum);
		case gatekeeperConfirm_chosen:
			return (rasStruct.u.gatekeeperConfirm.requestSeqNum = reqNum);
		case gatekeeperReject_chosen:
			return (rasStruct.u.gatekeeperReject.requestSeqNum = reqNum);
		case registrationRequest_chosen:
			return  (rasStruct.u.registrationRequest.requestSeqNum = reqNum);
		case registrationConfirm_chosen:
			return  (rasStruct.u.registrationConfirm.requestSeqNum = reqNum);
		case registrationReject_chosen:
			return  (rasStruct.u.registrationReject.requestSeqNum = reqNum);
		case unregistrationRequest_chosen:
			return  (rasStruct.u.unregistrationRequest.requestSeqNum = reqNum);
		case unregistrationConfirm_chosen:
			return  (rasStruct.u.unregistrationConfirm.requestSeqNum = reqNum);
		case unregistrationReject_chosen:
			return  (rasStruct.u.unregistrationReject.requestSeqNum = reqNum);
		case admissionRequest_chosen:
			return  (rasStruct.u.admissionRequest.requestSeqNum = reqNum);
		case admissionConfirm_chosen:
			return  (rasStruct.u.admissionConfirm.requestSeqNum = reqNum);
		case admissionReject_chosen:
			return  (rasStruct.u.admissionReject.requestSeqNum = reqNum);
		case bandwidthRequest_chosen:
			return  (rasStruct.u.bandwidthRequest.requestSeqNum = reqNum);
		case bandwidthConfirm_chosen:
			return  (rasStruct.u.bandwidthConfirm.requestSeqNum = reqNum);
		case bandwidthReject_chosen:
			return  (rasStruct.u.bandwidthReject.requestSeqNum = reqNum);
		case disengageRequest_chosen:
			return  (rasStruct.u.disengageRequest.requestSeqNum = reqNum);
		case disengageConfirm_chosen:
			return  (rasStruct.u.disengageConfirm.requestSeqNum = reqNum);
		case disengageReject_chosen:
			return  (rasStruct.u.disengageReject.requestSeqNum = reqNum);
		case locationRequest_chosen:
			return  (rasStruct.u.locationRequest.requestSeqNum = reqNum);
		case locationConfirm_chosen:
			return  (rasStruct.u.locationConfirm.requestSeqNum = reqNum);
		case locationReject_chosen:
			return  (rasStruct.u.locationReject.requestSeqNum = reqNum);
		case infoRequest_chosen:
			return  (rasStruct.u.infoRequest.requestSeqNum = reqNum);
		case infoRequestResponse_chosen:
			return  (rasStruct.u.infoRequestResponse.requestSeqNum = reqNum);
		case nonStandardMessage_chosen:
			return  (rasStruct.u.nonStandardMessage.requestSeqNum = reqNum);
		case unknownMessageResponse_chosen:
			return  (rasStruct.u.unknownMessageResponse.requestSeqNum = reqNum);
		default:
			return (rNum);
	}

	return rNum;

}


// Returns a pointer EndpointIdentifier for any RasMessage
// NULL for RasMessage that have no EndpointIdentifier
EndpointIdentifier *Coder::GetEndpointID(RasMessage *prasStruct)
{

	switch(prasStruct->choice){
		// Message with endpointID
		case registrationConfirm_chosen:
			return &(prasStruct->u.registrationConfirm.endpointIdentifier);
		case unregistrationRequest_chosen:
			// Optional
			return &(prasStruct->u.unregistrationRequest.URt_endpntIdntfr);
		case admissionRequest_chosen:
			return &(prasStruct->u.admissionRequest.endpointIdentifier);
		case bandwidthRequest_chosen:
			return &(prasStruct->u.bandwidthRequest.endpointIdentifier);
		case disengageRequest_chosen:
			return &(prasStruct->u.disengageRequest.endpointIdentifier);
		case infoRequestResponse_chosen:
			return &(prasStruct->u.infoRequestResponse.endpointIdentifier);
 		case locationRequest_chosen:
			// Optional
			return &(prasStruct->u.locationRequest.LctnRqst_endpntIdntfr);

		// Messages without an endpointID
		default:
		case gatekeeperRequest_chosen:
		case gatekeeperConfirm_chosen:
		case gatekeeperReject_chosen:
		case registrationRequest_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		case registrationReject_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthReject_chosen:
		case bandwidthConfirm_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
			return NULL;
	}

	return NULL;


}


ProtocolIdentifier Coder::SetProtocolIdentifier(RasMessage &rasStruct){
	
	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			return (rasStruct.u.gatekeeperRequest.protocolIdentifier = &m_protocolIdentifier1);
		case gatekeeperConfirm_chosen:
			return (rasStruct.u.gatekeeperConfirm.protocolIdentifier = &m_protocolIdentifier1);
		case gatekeeperReject_chosen:
			return (rasStruct.u.gatekeeperReject.protocolIdentifier = &m_protocolIdentifier1);
		case registrationRequest_chosen:
			return  (rasStruct.u.registrationRequest.protocolIdentifier = &m_protocolIdentifier1);
		case registrationConfirm_chosen:
			return  (rasStruct.u.registrationConfirm.protocolIdentifier = &m_protocolIdentifier1);
		case registrationReject_chosen:
			return  (rasStruct.u.registrationReject.protocolIdentifier = &m_protocolIdentifier1);

		case unregistrationRequest_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionRequest_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthRequest_chosen:
		case bandwidthConfirm_chosen:
		case bandwidthReject_chosen:
		case disengageRequest_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationRequest_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
		case infoRequestResponse_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		default:
			return NULL;
	}
	return NULL;
}

// Returns TRUE if protocols match, FALSE - otherwise
BOOL Coder::VerifyProtocolIdentifier(RasMessage &rasStruct){
	struct ObjectID_ *pprotID;
	struct ObjectID_ *pmprotID = &m_protocolIdentifier1;

	switch(rasStruct.choice){
		case gatekeeperRequest_chosen:
			{
			pprotID = rasStruct.u.gatekeeperRequest.protocolIdentifier;
			break;
			}
		case gatekeeperConfirm_chosen:
			{
			pprotID = rasStruct.u.gatekeeperConfirm.protocolIdentifier;
			break;
			}
		case gatekeeperReject_chosen:
			{
			pprotID = rasStruct.u.gatekeeperReject.protocolIdentifier;
			break;
			}
		case registrationRequest_chosen:
			{
			pprotID = rasStruct.u.registrationRequest.protocolIdentifier;
			break;
			}
		case registrationConfirm_chosen:
			{
			pprotID = rasStruct.u.registrationConfirm.protocolIdentifier;
			break;
			}
		case registrationReject_chosen:
			{
			pprotID = rasStruct.u.registrationReject.protocolIdentifier;
			break;
			}

		case unregistrationRequest_chosen:
		case unregistrationConfirm_chosen:
		case unregistrationReject_chosen:
		case admissionRequest_chosen:
		case admissionConfirm_chosen:
		case admissionReject_chosen:
		case bandwidthRequest_chosen:
		case bandwidthConfirm_chosen:
		case bandwidthReject_chosen:
		case disengageRequest_chosen:
		case disengageConfirm_chosen:
		case disengageReject_chosen:
		case locationRequest_chosen:
		case locationConfirm_chosen:
		case locationReject_chosen:
		case infoRequest_chosen:
		case infoRequestResponse_chosen:
		case nonStandardMessage_chosen:
		case unknownMessageResponse_chosen:
		default:
			return TRUE; // if no protocolIdentifier -> return TRUE by default;
	}

    while (!pprotID && !pmprotID)
	{
		if (pprotID->value != pmprotID->value)
			return FALSE;
		
		pprotID = pprotID->next;
		pmprotID = pmprotID->next;
	}

	if (!pprotID && !pmprotID)
		 return TRUE;
	else return FALSE;
}

// finds the requested protocol rasAddress and copies it
DWORD Coder::CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice)
{
	if(!pDestAddress) return ASN1_ERR_BADARGS;

	// choice 0 just grabs first address
	if(choice)
	{
		while(pSrcSeqRasAddress)
		{
			if(pSrcSeqRasAddress->value.choice == choice) break;
			pSrcSeqRasAddress = pSrcSeqRasAddress->next;
		}
	}

	if(pSrcSeqRasAddress)
	{
		CopyMemory(pDestAddress,&(pSrcSeqRasAddress->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

DWORD Coder::CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice)
{
	PSEQTRANSADDS pSeqTransAdd;

	if(!pDestAddress) return ASN1_ERR_BADARGS;

	if(prasStruct->choice != registrationRequest_chosen)
		return ASN1_ERR_BADARGS;

	pSeqTransAdd = (PSEQTRANSADDS) prasStruct->u.registrationRequest.rasAddress;

	while(pSeqTransAdd)
	{
		if(pSeqTransAdd->value.choice == choice) break;
		pSeqTransAdd = pSeqTransAdd->next;
	}

	if(pSeqTransAdd)
	{
		CopyMemory(pDestAddress,&(pSeqTransAdd->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

// finds the requested protocol callSignalAddress and copies it
DWORD Coder::CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice)
{
	if(!pDestCallSignalAddress) return ASN1_ERR_BADARGS;

	while(pSrcSeqCSAAddress)
	{
		if(pSrcSeqCSAAddress->value.choice == choice) break;
		pSrcSeqCSAAddress = pSrcSeqCSAAddress->next;
	}

	if(pSrcSeqCSAAddress)
	{
		CopyMemory(pDestCallSignalAddress,&(pSrcSeqCSAAddress->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}

DWORD Coder::CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice)
{
	PSEQTRANSADDS pSeqTransAdd;

	if(!pCallSignalAddress) return ASN1_ERR_BADARGS;

	if(prasStruct->choice != registrationRequest_chosen)
		return ASN1_ERR_BADARGS;

	pSeqTransAdd = (PSEQTRANSADDS) prasStruct->u.registrationRequest.callSignalAddress;

	while(pSeqTransAdd)
	{
		if(pSeqTransAdd->value.choice == choice) break;
		pSeqTransAdd = pSeqTransAdd->next;
	}

	if(pSeqTransAdd)
	{
		CopyMemory(pCallSignalAddress,&(pSeqTransAdd->value),sizeof(TransportAddress));
	}
	else
	{
		return ASN1_ERR_BADARGS;
	}

	return ASN1_SUCCESS;
}



// THE FOLLOWING IS ADDED FOR TELES ASN.1 INTEGRATION

extern "C" {

int GK_InitWorld(ASN1_CODER_INFO *pWorld)
{
    int rc;

    ZeroMemory(pWorld, sizeof(*pWorld));

    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    rc = ASN1_CreateEncoder(
                H225ASN_Module,           // ptr to mdule
                &(pWorld->pEncInfo),    // ptr to encoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
    if (rc == ASN1_SUCCESS)
    {
        ASSERT(pWorld->pEncInfo != NULL);
        rc = ASN1_CreateDecoder(
                H225ASN_Module,           // ptr to mdule
                &(pWorld->pDecInfo),    // ptr to decoder info
                NULL,                   // buffer ptr
                0,                      // buffer size
                NULL);                  // parent ptr
        ASSERT(pWorld->pDecInfo != NULL);
    }

    if (rc != ASN1_SUCCESS)
    {
        GK_TermWorld(pWorld);
    }

    return rc;
}

int GK_TermWorld(ASN1_CODER_INFO *pWorld)
{
    if (H225ASN_Module == NULL)
    {
        return ASN1_ERR_BADARGS;
    }

    ASN1_CloseEncoder(pWorld->pEncInfo);
    ASN1_CloseDecoder(pWorld->pDecInfo);

    ZeroMemory(pWorld, sizeof(*pWorld));

    return ASN1_SUCCESS;
}

int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf)
{
	int rc;
    ASN1encoding_t pEncInfo = pWorld->pEncInfo;
    BOOL fBufferSupplied = (pBuf->value != NULL) && (pBuf->length != 0);
    DWORD dwFlags = fBufferSupplied ? ASN1ENCODE_SETBUFFER : ASN1ENCODE_ALLOCATEBUFFER;

	// clean up out parameters
    if (! fBufferSupplied)
    {
        pBuf->length = 0;
        pBuf->value = NULL;
    }

    rc = ASN1_Encode(
                    pEncInfo,                   // ptr to encoder info
                    pStruct,                    // pdu data structure
                    nPDU,                       // pdu id
                    dwFlags,                    // flags
                    pBuf->value,                // buffer
                    pBuf->length);              // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        if (fBufferSupplied)
        {
            ASSERT(pBuf->value == pEncInfo->buf);
            ASSERT(pBuf->length >= pEncInfo->len);
        }
        else
        {
            pBuf->value = pEncInfo->buf;             // buffer to encode into
        }
        pBuf->length = pEncInfo->len;        // len of encoded data in buffer
    }
    else
    {
		ASSERT(FALSE);
    }
    return rc;
}

int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf)
{
    ASN1decoding_t pDecInfo = pWorld->pDecInfo;
    BYTE *pEncoded = pBuf->value;
    ULONG cbEncodedSize = pBuf->length;

    int rc = ASN1_Decode(
                    pDecInfo,                   // ptr to encoder info
                    ppStruct,                   // pdu data structure
                    nPDU,                       // pdu id
                    ASN1DECODE_SETBUFFER,       // flags
                    pEncoded,                   // do not provide buffer
                    cbEncodedSize);             // buffer size if provided
    if (ASN1_SUCCEEDED(rc))
    {
        ASSERT(pDecInfo->pos > pDecInfo->buf);
        pBuf->length -= (ULONG)(pDecInfo->pos - pDecInfo->buf);
        pBuf->value = pDecInfo->pos;
    }
    else
    {
		ASSERT(FALSE);
        *ppStruct = NULL;
    }
    return rc;
}

} // extern "C"

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\coder.hpp ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\coder.hpv  $
 *
 *	$Revision:   1.4  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *	$Log:   S:\sturgeon\src\include\vcs\coder.hpv  $
// 
//    Rev 1.4   16 Jan 1997 15:25:06   BPOLING
// changed copyrights to 1997
// 
//    Rev 1.3   18 Dec 1996 21:49:58   BPOLING
// builds with msdev and for windows only
// 
//    Rev 1.2   09 Dec 1996 14:13:54   EHOWARDX
// Updated copyright notice.
 * 
 *    Rev 1.1   15 Nov 1996 16:16:14   BPOLING
 * vcs header added.
 *                                                                     *
 ***********************************************************************
 *																	   *
 *	coder.hpp														   *
 *																	   * 
 *	PURPOSE:	Encode/Decode ANS.1 Gatekeeper PDU using the ANS.1     *
 *				compiler functions.									   *
 *																	   *
 *	FUNCTIONS:														   *
 *																	   *
 *	COMMENTS: 														   *
 *																	   *
 ***********************************************************************/

/************************************************************************
 * 						Include Files		           				   	*
 ***********************************************************************/

/************************************************************************
 * 						Manifest Constants								*
 ***********************************************************************/
																			
/************************************************************************
*						GLOBAL VARIABLES								*
************************************************************************/

/************************************************************************
 * 						Class Definitions								*
 ***********************************************************************/

#ifndef _CODER_HPP
#define _CODER_HPP

#include "av_asn1.h"
#include "gk_asn1.h"

extern "C" {
int GK_InitWorld(ASN1_CODER_INFO *pWorld);
int GK_TermWorld(ASN1_CODER_INFO *pWorld);
int GK_Encode(ASN1_CODER_INFO *pWorld, void *pStruct, int nPDU, ASN1_BUF *pBuf);
int GK_Decode(ASN1_CODER_INFO *pWorld, void **ppStruct, int nPDU, ASN1_BUF *pBuf);
}

//  DEBUG OPTIONS
#define CODER_DEBUG		  0x00000001
#define CODER_SUPER_DEBUG 0x00000002

// Coder Error Messages

#define CODER_NOERROR 0
#define CODER_ERROR   1

// Protocol version information
#define ITU_T			0
#define RECOMMENDATION	0
#define SERIES			8     // H225.0
#define RECOMM_NUMBER   2250
#define VERSION         0
#define ADDITIONAL      2


// typedef struct InfoRequestResponse_perCallInfo      SEQPERCALLINFO, *PSEQPERCALLINFO;

typedef struct _seqtransadds{
    struct _seqtransadds  	*next;
    TransportAddress 		value;
} SEQTRANSADDS, *PSEQTRANSADDS;

typedef struct _seqaliasadds {
    struct _seqaliasadds  	*next;
    AliasAddress    		value;
} SEQALIASADDS, *PSEQALIASADDS;

class Coder{

private:
	ASN1_CODER_INFO		m_World;
	CRITICAL_SECTION	m_critSec;

public:
	struct ObjectID_ m_protocolIdentifier1,m_protocolIdentifier2,m_protocolIdentifier3,
		             m_protocolIdentifier4,m_protocolIdentifier5,m_protocolIdentifier6;

public:
	Coder();
	~Coder();

	int InitCoder();
	// Creates an OssBuf
	int Encode(RasMessage *pInputData, ASN1_BUF *pOutputOssBuf);
	// Create memory to hold decoded OssBuf
	// For H323 this is a rasStruct
	int Decode(ASN1_BUF *pInputOssBuf, RasMessage **pOutputData);
	// Used to free buffer created by decode
	int Free(RasMessage *pData);
	// Used to free buffer created by encode
	void Free(ASN1_BUF Asn1Buf);
	// Returns the sequence number out of any RasMessage
	// Returns zero on error
	RequestSeqNum GetSequenceNumber(RasMessage *prasStruct);
	RequestSeqNum SetSequenceNumber(RasMessage &rasStruct,RequestSeqNum reqNum);
	// Returns a pointer EndpointIdentifier for any RasMessage
	// NULL for RasMessage that have no EndpointIdentifier
	EndpointIdentifier *GetEndpointID(RasMessage *prasStruct);
	// Returns a pointer to a valid H323 protocolIdentifier linked list 
	// when a valid Rasmessage is passed in and sets the protocol Identifier
	// item in RasMessages that have an protocol Identifier
	// If in an RasMessage that doesn't have a protocol identifer is passed in,
	// NULL is returned.
	ProtocolIdentifier SetProtocolIdentifier(RasMessage &rasStruct);
	// Returns TRUE if protocols match, FALSE - otherwise
	BOOL VerifyProtocolIdentifier(RasMessage &rasStruct);
	// finds the requested protocol rasAddress and copies it
	DWORD CopyRasAddress(TransportAddress *pDestAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyRasAddress(TransportAddress *pDestAddress, PSEQTRANSADDS pSrcSeqRasAddress, unsigned short choice);
	// finds the requested protocol callSignalAddress and copies it
	DWORD CopyCallSignal(TransportAddress *pCallSignalAddress, RasMessage *prasStruct, unsigned short choice);
	DWORD CopyCallSignal(TransportAddress *pDestCallSignalAddress, PSEQTRANSADDS pSrcSeqCSAAddress, unsigned short choice);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\confman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.39  $
 *	$Date:   31 Jan 1997 13:44:26  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

// Call types must be bit maps
#define ENQUEUED_CALL		0x01
#define PLACED_CALL			0x02
#define ESTABLISHED_CALL	0x04
#define VIRTUAL_CALL		0x08
#define REAL_CALLS			(ENQUEUED_CALL | PLACED_CALL | ESTABLISHED_CALL)
#define ALL_CALLS			(REAL_CALLS | VIRTUAL_CALL)

HRESULT InitConferenceManager();

HRESULT DeInitConferenceManager();

HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference,
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel);

HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber);

HRESULT AllocateChannelNumber(		PCONFERENCE				pConference,
									WORD					*pwChannelNumber);

HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber);

HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR				dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference);

HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall);

HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference);

HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference);

HRESULT FreeConference(				PCONFERENCE				pConference);

HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference);

HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete);

HRESULT ValidateConference(			CC_HCONFERENCE			hConference);

HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference);

HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference);

HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[]);

HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType);

HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType);

HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference);

HRESULT UnlockConference(			PCONFERENCE				pConference);

HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept);

HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall);

HRESULT ReInitializeConference(		PCONFERENCE				pConference);


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\api_dwn.c ===
/******************************************************************************
 *
 *   INTEL Corporation Proprietary Information
 *   Copyright (c) 1994, 1995, 1996 Intel Corporation.
 *
 *   This listing is supplied under the terms of a license agreement
 *   with INTEL Corporation and may not be used, copied, nor disclosed
 *   except in accordance with the terms of that agreement.
 *
 *****************************************************************************/

/******************************************************************************
 *
 *  AUTHOR: cjutzi (Curt Jutzi) Intel Corporation
 *
 *  $Workfile:   api_dwn.c  $
 *  $Revision:   1.45  $
 *  $Modtime:   05 Mar 1997 09:53:36  $
 *  $Log:   S:/STURGEON/SRC/H245/SRC/VCS/api_dwn.c_v  $
 *
 *    Rev 1.45   05 Mar 1997 09:56:04   MANDREWS
 * Fixed compiler warning in release mode.
 *
 *    Rev 1.44   04 Mar 1997 17:33:26   MANDREWS
 * H245CopyCap() and H245CopyCapDescriptor() now return HRESULTs.
 *
 *    Rev 1.43   26 Feb 1997 11:12:06   MANDREWS
 * Fixed problem in assigning dynamic term cap IDs; the dynamic IDs were
 * overlapping with static IDs.
 *
 *    Rev 1.42   Feb 24 1997 18:30:18   tomitowx
 * multiple modedescriptor support
 *
 *    Rev 1.41   07 Feb 1997 15:33:58   EHOWARDX
 * Changed H245DelCapDescriptor to match changes to set_cap_descriptor.
 *
 *    Rev 1.40   27 Jan 1997 12:40:16   MANDREWS
 *
 * Fixed warnings.
 *
 *    Rev 1.39   09 Jan 1997 19:17:04   EHOWARDX
 *
 * Initialize lError to H245_ERROR_OK to prevent "may be uninitialized"
 * warning.
 *
 *    Rev 1.38   19 Dec 1996 17:18:50   EHOWARDX
 * Changed to use h245asn1.h definitions instead of _setof3 and _setof8.
 *
 *    Rev 1.37   12 Dec 1996 15:57:22   EHOWARDX
 * Master Slave Determination kludge.
 *
 *    Rev 1.36   11 Dec 1996 13:55:44   SBELL1
 * Changed H245Init parameters.
 *
 *    Rev 1.35   17 Oct 1996 18:17:36   EHOWARDX
 * Changed general string to always be Unicode.
 *
 *    Rev 1.34   14 Oct 1996 14:01:26   EHOWARDX
 * Unicode changes.
 *
 *    Rev 1.33   11 Oct 1996 15:19:56   EHOWARDX
 * Fixed H245CopyCap() bug.
 *
 *    Rev 1.32   28 Aug 1996 11:37:10   EHOWARDX
 * const changes.
 *
 *    Rev 1.31   19 Aug 1996 16:28:36   EHOWARDX
 * H245CommunicationModeResponse/H245CommunicationModeCommand bug fixes.
 *
 *    Rev 1.30   15 Aug 1996 15:19:46   EHOWARDX
 * First pass at new H245_COMM_MODE_ENTRY_T requested by Mike Andrews.
 * Use at your own risk!
 *
 *    Rev 1.29   08 Aug 1996 16:02:58   EHOWARDX
 *
 * Eliminated api_vers.h.
 * Changed H245Init Debug trace to eliminate API_VERSION.
 *
 *    Rev 1.28   19 Jul 1996 12:48:22   EHOWARDX
 *
 * Multipoint clean-up.
 *
 *    Rev 1.27   01 Jul 1996 22:13:42   EHOWARDX
 *
 * Added Conference and CommunicationMode structures and functions.
 *
 *    Rev 1.26   18 Jun 1996 14:53:16   EHOWARDX
 * Eliminated Channel parameter to MaintenanceLoopRelease.
 * Made Multiplex Capability mandatory -- H245SendTermCaps now returns
 * H245_ERROR_NO_MUX_CAPS if no Multiplex Capability has been defined.
 *
 *    Rev 1.25   14 Jun 1996 18:57:38   EHOWARDX
 * Geneva update.
 *
 *    Rev 1.24   10 Jun 1996 16:59:02   EHOWARDX
 * Moved init/shutdown of submodules to CreateInstance/InstanceUnlock.
 *
 *    Rev 1.23   06 Jun 1996 18:50:10   EHOWARDX
 * Equivalent of H.324 bugs #808 and 875 fixed.
 *
 *    Rev 1.22   05 Jun 1996 17:16:48   EHOWARDX
 * MaintenanceLoop bug fix.
 *
 *    Rev 1.21   04 Jun 1996 13:56:42   EHOWARDX
 * Fixed Release build warnings.
 *
 *    Rev 1.20   30 May 1996 23:38:52   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.19   29 May 1996 16:08:04   unknown
 * Fixed bug in copying nonstandard identifiers.
 *
 *    Rev 1.18   29 May 1996 15:19:48   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.17   28 May 1996 14:25:12   EHOWARDX
 * Tel Aviv update.
 *
 *    Rev 1.16   21 May 1996 15:46:54   EHOWARDX
 * Fixed bugs in NonStandard messages using object identifier.
 *
 *    Rev 1.15   20 May 1996 22:17:54   EHOWARDX
 * Completed NonStandard Message and H.225.0 Maximum Skew indication
 * implementation. Added ASN.1 validation to H245SetLocalCap and
 * H245SetCapDescriptor. Check-in from Microsoft drop on 17-May-96.
 *
 *    Rev 1.14   20 May 1996 14:35:12   EHOWARDX
 * Got rid of asynchronous H245EndConnection/H245ShutDown stuff...
 *
 *    Rev 1.13   17 May 1996 14:53:38   EHOWARDX
 * Added calls to StartSystemClose() and EndSystemClose().
 *
 *    Rev 1.12   16 May 1996 19:40:30   EHOWARDX
 * Fixed multiplex capability bug.
 *
 *    Rev 1.11   16 May 1996 16:36:10   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.10   16 May 1996 16:14:06   EHOWARDX
 * Fixed backwards-compatibility problem in H245SetLocalCap
 * (CapId of zero should result in dynamically-allocated cap id being used)
 *
 *    Rev 1.9   16 May 1996 16:03:44   EHOWARDX
 * Fixed typo in H245SetCapDescriptor.
 *
 *    Rev 1.8   16 May 1996 15:58:32   EHOWARDX
 * Fine-tuning H245SetLocalCap/H245DelLocalCap/H245SetCapDescriptor/
 * H245DelCapDescriptor behaviour.
 *
 *    Rev 1.7   15 May 1996 21:49:46   unknown
 * Added call to InstanceLock() to increment lock count before call
 * to InstanceDelete() in H245EndConnectionPhase2().
 *
 *    Rev 1.6   15 May 1996 19:54:02   unknown
 * Fixed H245SetCapDescriptor.
 *
 *    Rev 1.5   14 May 1996 16:56:22   EHOWARDX
 * Last minute change from H245_IND_CAPDESC_T to H245_TOTCAPDESC_T.
 * H245EnumCaps() callback now uses H245_TOTCAPDESC_T instead
 * of separate H245_CAPDESCID_T and H245_CAPDESC_T for consistency.
 *
 *    Rev 1.4   14 May 1996 15:55:44   EHOWARDX
 * Added mux cap handling to H245DelLocalCap.
 *
 *    Rev 1.3   14 May 1996 14:06:06   EHOWARDX
 * Fixed abort from H245EnumCaps - if Cap Callback returns non-zero,
 * Cap Desc Callback is never called.
 *
 *    Rev 1.2   13 May 1996 23:16:42   EHOWARDX
 * Fixed remote terminal capability handling.
 *
 *    Rev 1.1   11 May 1996 20:32:52   EHOWARDX
 * Checking in for the night...
 *
 *    Rev 1.0   09 May 1996 21:06:06   EHOWARDX
 * Initial revision.
 *
 *    Rev 1.25.1.10   09 May 1996 19:31:02   EHOWARDX
 * Redesigned thread locking logic.
 * Added new API functions.
 *
 *    Rev 1.25.1.9   01 May 1996 19:31:16   EHOWARDX
 * Added H245CopyCap(), H245FreeCap(), H245CopyMux(), H245FreeMux().
 * Changed H2250_xxx definitions for H.225.0 address types to H245_xxx.
 *
 *    Rev 1.25.1.8   27 Apr 1996 21:09:20   EHOWARDX
 * Changed Channel Numbers to words, added H.225.0 support.
 *
 *    Rev 1.25.1.7   25 Apr 1996 20:06:26   EHOWARDX
 * Moved setting of EndSessionPdu in EndSessionPhase1 to before call to api_fs
 *
 *    Rev 1.25.1.6   25 Apr 1996 17:57:00   EHOWARDX
 * Added dwTxPort argument to H245OpenChannel().
 *
 *    Rev 1.25.1.5   25 Apr 1996 16:51:00   EHOWARDX
 * Function changes as per H.245 API Changes spec.
 *
 *    Rev 1.25.1.4   24 Apr 1996 20:54:32   EHOWARDX
 * Added new OpenLogicalChannelAck/OpenLogicalChannelReject support.
 *
 *    Rev 1.25.1.3   19 Apr 1996 12:54:40   EHOWARDX
 * Updated to 1.30
 *
 *    Rev 1.25.1.2   15 Apr 1996 15:10:48   EHOWARDX
 * Updated to match Curt's current version.
 *
 *    Rev 1.25.1.1   03 Apr 1996 17:12:50   EHOWARDX
 * Integrated latest H.323 changes.
 *
 *    Rev 1.25.1.0   03 Apr 1996 15:53:42   cjutzi
 * Branched for H.323.
 *
 *    Rev 1.20   27 Mar 1996 15:25:34   cjutzi
 * - fixed a bug from this morning checkin dynamically allocating
 *   pdu's.. free_mux_tbl was getting called after pdu was free'd..
 *   this was a problem since the mux table pointer was in the pdu
 *
 *    Rev 1.19   27 Mar 1996 08:37:08   cjutzi
 *
 * - removed PDU from stack.. made them dynamically allocated
 *
 *    Rev 1.18   20 Mar 1996 14:47:32   cjutzi
 * - added ERROR H245_ERROR_NO_CAPDESC to SendTermCaps.
 *
 *    Rev 1.17   18 Mar 1996 15:23:16   cjutzi
 *
 *
 *
 *    Rev 1.16   13 Mar 1996 09:15:44   cjutzi
 *
 * - changed LLPCRITICAL_SECTION to CRITICAL_SECTION *
 *
 *    Rev 1.15   12 Mar 1996 15:51:48   cjutzi
 *
 * - implemented locking
 * - fixed callback bug w/ clenaup on term caps..
 * - implemented End Session
 * - fixed shutdown
 *
 *    Rev 1.14   08 Mar 1996 14:02:48   cjutzi
 *
 * - removed H245SetSimultaneous stuff..
 * - added H245SetCapDescriptor Stuff..
 * - completeed MuxTable Entry Stuff.
 * - required H223 -or- some portion of MuxCapbilities to be
 *   there before you issue SendCaps..
 * - NOTE: need to inforce the Simultaneous capabilities in
 *   the same mannor..
 *
 *    Rev 1.13   05 Mar 1996 17:35:38   cjutzi
 *
 * - implemented SendMultiplexTable..
 * - removed bcopy/bzero and changed free call
 * - added master slave indication
 *
 *    Rev 1.12   01 Mar 1996 13:48:24   cjutzi
 *
 * - added hani's new fsm id's
 * - added some support for release on close request.
 *
 *    Rev 1.11   29 Feb 1996 17:27:10   cjutzi
 *
 * - bi-directional channel working..
 *
 *    Rev 1.10   29 Feb 1996 08:35:52   cjutzi
 *
 * - added p_ossWorld to initialization
 *
 *    Rev 1.9   27 Feb 1996 13:30:18   cjutzi
 *
 * - fixed master slave problem with conf_ind and tracker type
 * - removed RSP_LCSE in close channel resp
 *
 *    Rev 1.8   26 Feb 1996 17:23:18   cjutzi
 *
 * - MiscCommand API added
 * - Fixed Assert for H245Init.. was not NULL'n out the pointers for the
 *   context blocks..
 *
 *    Rev 1.7   26 Feb 1996 11:05:16   cjutzi
 *
 * - added simultaneous caps.. and fixed bugs..
 *   lot's of changes..
 *
 *    Rev 1.6   16 Feb 1996 13:01:08   cjutzi
 *
 * - got open / close / request close working in both directions.
 *
 *    Rev 1.5   15 Feb 1996 14:42:54   cjutzi
 *
 * - fixed trace level bind w/ Instance.. no other change but had to
 *   add when h245deb.c when in..
 *
 *
 *    Rev 1.4   15 Feb 1996 10:50:54   cjutzi
 *
 * - termcaps working
 * - changed API interface for MUX_T
 * - changed callback or IND_OPEN
 * - changed constants IND_OPEN/IND_OPEN_NEEDRSP etc..
 * - cleaned up the open.. (not complete yet.. )
 *
 *    Rev 1.3   09 Feb 1996 16:58:36   cjutzi
 *
 * - cleanup.. and some fixes..
 * - added and or changed headers to reflect the log of changes
 *
 *****************************************************************************/

/****************************************************************************/
/****************************************************************************/
/****************************************************************************/
/****                                                                   *****/
/****                   NOTES TO THE READER                             *****/
/****                                                                   *****/
/**** This program has been put together using a a screen which is      *****/
/**** wider than 80 characters.. It is best if a similar screen size is *****/
/**** used.. Of course emacs is my preference but 80 col screens will   *****/
/**** cause you much frustration..                                      *****/
/****                                                                   *****/
/**** Tabs are set to 8                                                 *****/
/****                                                                   *****/
/**** NOTE:                                                             *****/
/****           Headers are documented, however they may or may not     *****/
/****   coorispond to reality.  See the H245Spec.doc from Intel for the *****/
/****   current :-> H245 specification                                  *****/
/****                                                                   *****/
/**** DISCLAMER:                                                        *****/
/****                                                                   *****/
/****   Since this code wasn't developed in Word 7.0, I am fully        *****/
/****   responsable for all spelling mistakes in the comments. Please   *****/
/****   disregard the spelling mistakes.. or fix them, if you are       *****/
/****   currently modifying the code.                                   *****/
/****                                                                   *****/
/****                           - Thankyou                              *****/
/****                                                                   *****/
/****                                   Curt Jutzi                      *****/
/****                                   Oregon, USA                     *****/
/****                                                                   *****/
/****************************************************************************/
/****************************************************************************/
/****************************************************************************/

#ifndef STRICT
#define STRICT
#endif

#include "precomp.h"

/***********************/
/*    H245 INCLUDES    */
/***********************/
#define H245DLL_EXPORT
#include "h245api.h"
#include "h245com.h"
#include "h245sys.x"

#include "api_util.x"
#include "pdu.x"
#include "fsmexpor.h"
#include "api_debu.x"
#include "sr_api.h"
#include "h245deb.x"



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245Init
 *
 * DESCRIPTION
 *
 *       H245_INST_T  H245Init (
 *                              H245_CONF_T               Configuration,
 *                              DWORD                     dwH245PhysId,
 *                              DWORD                     dwLinkLayerPhysId,
 *                              DWORD                     dwPreserved,
 *                              H245_CONF_IND_CALLBACK_T  Callback
 *                              )
 *      Description:
 *
 *              Called to create an H.245 instance and its related sublayers
 *              (e.g., SRP). This function must be called before any other
 *              API calls may be called  The current H.245 implementation can
 *              only have, at most, one client. Therefore H245Init can only be
 *              called once per physical ID.
 *      Input
 *
 *              Configuration   Indicates the type of configuration the client
 *                              wishes to establish, e.g.  H.324, H.323, H.310,
 *                              or DSVD.
 *              dwH245PhysId    Parameter identifying the H245 entry
 *              pdwLinkLayerPhysId
 *                              Output parameter identifying the linkLayer
 *                              entry.
 *              dwPreserved     Parameter that may be used by H.245 client to
 *                              provide context, passed back to client in all
 *                              confirms and indications.
 *              Callback        Callback routine supplied by the client which
 *                              will be used by the H.245 subsystem to convey
 *                              confirm and indication messages back to the
 *                              client.
 *      Call Type:
 *
 *              Synchronous
 *
 *      Return Values:
 *
 *              Return value of 0 indicates Failure
 *              Return value of non 0 is a valid H245_INST_T
 *
 *      Errors:
 *              N/A
 *
 *      See Also:
 *              H245EndSession
 *              H245Shutdown
 *
 *
 *****************************************************************************/

H245DLL H245_INST_T
H245Init                (
                         H245_CONFIG_T            Configuration,
                         unsigned long            dwH245PhysId,
                         unsigned long            *pdwLinkLayerPhysId,
                         DWORD_PTR                dwPreserved,
                         H245_CONF_IND_CALLBACK_T CallBack,
                         unsigned char            byTerminalType
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE(dwH245PhysId,4,"H245Init(%d, 0x%x, 0x%x, 0x%x, %d) <-",
            Configuration, dwH245PhysId, dwPreserved, CallBack, byTerminalType);

  switch (Configuration)
  {
  case H245_CONF_H324:
  case H245_CONF_H323:
    break;

  default:
    H245TRACE(dwH245PhysId,1,"H245Init -> Invalid Configuration %d", Configuration);
    return H245_INVALID_ID;
  } // switch

  if (CallBack == NULL)
  {
    H245TRACE(dwH245PhysId,1,"H245Init -> Null CallBack");
    return H245_INVALID_ID;
  }

  /* see if this physical identifier has been initialized already */
  // Send down H245PhysId that was input.
  pInstance = InstanceCreate(dwH245PhysId, Configuration);
  if (pInstance == NULL)
  {
    return H245_INVALID_ID;
  }

  // Get the linkLayer PhysId.
  *pdwLinkLayerPhysId = pInstance->SendReceive.hLinkLayerInstance;

  // Initialize instance API structure
  pInstance->API.dwPreserved     = dwPreserved;
  pInstance->API.ConfIndCallBack = CallBack;

  // Initialize instance FSM structure
  pInstance->StateMachine.sv_TT     = byTerminalType;
  pInstance->StateMachine.sv_STATUS = INDETERMINATE;

  H245TRACE(pInstance->dwInst,4,"H245Init -> %d", pInstance->dwInst);
  lError = pInstance->dwInst;
  InstanceUnlock(pInstance);
  return lError;
} // H245Init()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EndSession
 *
 * DESCRIPTION
 *
 *              Yes.. this should be explained.. Since Send Receive needs
 *              to flush some buffers and send out an End Session.. what we've
 *              hopefully done is a 2 phase shut down...
 *
 *              call StartSessionClose which initiates the flush..
 *              when flush is complete EndSessionPhase1 is called..
 *              The end session pdu is then placed in the send queue..
 *              When the End Session Pdu is sent.. the EndSession Phase
 *              2 is called, and the result is sent up to the client..
 *
 *              Hope that helps..
 *
 *
 *      HRESULT H245EndSession ( H245_INST_T           dwInst,
 *                                 H245_ENDSESSION_T     Mode,
 *                                 H245_NONSTANDARD_T   *pNonStd (*optional*)
 *                               )
 *
 *      Description:
 *              Called to shutdown the peer to peer session between this H.245
 *              session and the remote peers H.245 layer.
 *
 *              It will terminate by issuing an EndSession command to the
 *              remote side and call end session for all the H.245 subsystems.
 *              All resources are returned; therefore no further action is
 *              permitted, except H245ShutDown until another H245Init API call
 *              is made.
 *
 *      input
 *              dwInst          Instance handle returned by H245Init
 *              Mode            Mode which the client wishes to terminat
 *                              the session
 *              pNonStd         If the mode is non standard this is the non
 *                              standard parameter passes to the remote client.
 *                              This parameter is optional, and should be set
 *                              to NULL if not used
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *      See Also:
 *              H245Shutdown
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245EndSession          (
                         H245_INST_T                    dwInst,
                         H245_ENDSESSION_T              Mode,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  register MltmdSystmCntrlMssg   *pPdu;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245EndSession <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* system should be in either connecting or connected */

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    break;

  default:
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOT_CONNECTED;
  }

  // Allocate the PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  // Build the PDU
  lError = pdu_cmd_end_session (pPdu, Mode, pNonStd);

  if (lError == H245_ERROR_OK)
  {
    // Send the PDU
    lError = FsmOutgoing(pInstance, pPdu, 0);
  }

  // Free the PDU buffer
  MemFree(pPdu);

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245EndSession -> %s",map_api_error(lError));
  }
  else
  {
    H245TRACE (dwInst,4,"H245EndSession -> OK");
    pInstance->API.SystemState = APIST_Disconnected;
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245EndSession()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245ShutDown
 *
 * DESCRIPTION
 *
 *      HRESULT  H245Shutdown ( H245_INST_T      dwInst);
 *
 *      Description:
 *
 *              Called to terminate the specified instance of H.245. If there
 *              is currently an active session (see H245Init) then the H.245
 *              subsystem will issue an EndSession to the other side and wait
 *              for H.245 sublayer termination notifications before it queues
 *              Callback confirm.
 *
 *              This call will force the client to issue another H245Init
 *              before it can use any of the H.245 API functions.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *
 *      Call Type:
 *              asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *****************************************************************************/

H245DLL HRESULT
H245ShutDown            (H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register HRESULT                lError;

  H245TRACE (dwInst,4,"H245ShutDown <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ShutDown -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  switch (pInstance->API.SystemState)
  {
  case APIST_Connecting:
  case APIST_Connected:
    lError = H245EndSession(dwInst,H245_ENDSESSION_DISCONNECT,NULL);
    break;

  default:
    lError = H245_ERROR_OK;
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ShutDown -> %s", map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ShutDown -> OK");
  InstanceDelete  (pInstance);
  return H245_ERROR_OK;
} // H245ShutDown()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245InitMasterSlave
 *
 * DESCRIPTION
 *
 *      HRESULT  H245InitMasterSlave ( H245_INST_T       dwInst,
 *                                    DWORD              dwTransId )
 *
 *      Description:
 *              Called to initiate the H.245 master slave negotiation.
 *              Upon completion of the negotiation the local client will
 *              receive an H245_CONF_INIT_MSTSLV message indicating the
 *              result of the negotiation.
 *      Input
 *              dwInst          Instance handle returned by
 *                              H245GetInstanceId
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous response to
 *                              this call.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_INIT_MSTSLV
 *
 *      Errors:
 *              H245_ERROR_OK           Master Slave Determination started
 *              H245_ERROR_INPROCESS    Master Slave Determination currently
 *                                      in process
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INPROCESS    In process
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245Init
 *
 *      callbacks
 *              H245_IND_MSTSLV
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245InitMasterSlave     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu = NULL;

  /* check for valid instance handle */

  H245TRACE (dwInst,4,"H245InitMasterSlave <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* if the transaction is in process.. tell client */
  if (pInstance->API.MasterSlave == APIMS_InProcess)
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_INPROCESS));
      InstanceUnlock(pInstance);
      return H245_ERROR_INPROCESS;
    }

  /* if the transaction is already complete */
  if (pInstance->API.MasterSlave != APIMS_Undef)
  {
    if (pInstance->API.ConfIndCallBack)
    {
      H245_CONF_IND_T    confirm_ind_event;
      confirm_ind_event.Kind = H245_CONF;
      confirm_ind_event.u.Confirm.Confirm       = H245_CONF_INIT_MSTSLV;
      confirm_ind_event.u.Confirm.dwPreserved   = pInstance->API.dwPreserved;
      confirm_ind_event.u.Confirm.dwTransId     = dwTransId;
      confirm_ind_event.u.Confirm.Error         = H245_ERROR_OK;
      confirm_ind_event.u.Confirm.u.ConfMstSlv  =
        (pInstance->API.MasterSlave == APIMS_Master) ? H245_MASTER : H245_SLAVE;
      (*pInstance->API.ConfIndCallBack)(&confirm_ind_event, NULL);
    }
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
    InstanceUnlock(pInstance);
    return H245_ERROR_OK;
  }

  /* get somthing to keep track of what the heck you're doing.. */
  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_MSTSLV_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL,
                                        H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  /* set master slave in process */
  pInstance->API.SystemState = APIST_Connecting;
  pInstance->API.MasterSlave = APIMS_InProcess;

  memset(pPdu, 0, sizeof(*pPdu));
  pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
  pPdu->u.MltmdSystmCntrlMssg_rqst.choice = masterSlaveDetermination_chosen;

  lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree(pPdu);
  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245InitMasterSlave -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245InitMasterSlave -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245InitMasterSlave()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetLocalCap
 *
 * DESCRIPTION
 *
 *       HRESULT H245SetLocalCap (
 *                              H245_INST_T      dwInst,
 *                              H245_TOTCAP_T   *pTotCap,
 *                              H245_CAPID_T    *pCapId
 *                              )
 *
 *      Description:
 *              This function allows the client to define a specific
 *              capability to the H.245 subsystem. When this function is
 *              called a new capability entry is made in the local capability
 *              table.  The returned value in *pCapId can be used by the client
 *              to refer to that registered capability.  NULL in the *pCapId
 *              is valid.
 *
 *              This call is used for both client (Audio / Video / Data / Mux)
 *              capabilities.  It is not used for setting capability descriptors.
 *
 *      Note:
 *              7 This function does not communicate this update to the
 *                remote peer until the client calls H245SendTermCaps.
 *              7 pTotCap->CapId is of no significance in this call.
 *
 *              pTotCap->CapId is of no significance in this call and should
 *              be set to 0
 *
 *              if DataType of H245_DATA_MUX  is used  (i.e. in setting the
 *              mux table capabilities) No capid is returned, and it can not
 *              be used in H245SetCapDescritptor  api call.
 *
 *      Input
 *              dwInst  Instance handle returned by GetInstanceId
 *                      pTotCap Capability set defining the capability
 *
 *              Note:   pTotCap->CapId is of no significance in this call.
 *
 *      output
 *              pCapId  Capability id which client can use to reference
 *                      this capability in the H.245 subsystem.  This can
 *                      be NULL, in this case nothing is returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              If pCap is not null, the local cap table id is returned
 *              to the client in this parameter.
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        There was an invalid parameter passed
 *              H245_ERROR_MAXTBL       Entry not made because local cap table
 *                                      is full
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245DelLocalCap
 *              H245EnumCaps
 *              H245SetCapDescriptor
 *
 *
 * ASSUMPTION:
 *                      pTotCap->CapId  will be set to H245_INVALID_CAPID
 *                      pTotCap->Dir    will be set
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetLocalCap         (
                         H245_INST_T            dwInst,
                         H245_TOTCAP_T *        pTotCap,
                         H245_CAPID_T  *        pCapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* check for valid parameters */
  if (pTotCap == NULL ||
      pCapId  == NULL ||
	  ((*pCapId > H245_MAX_CAPID) && (*pCapId != H245_INVALID_CAPID)) ||
      pTotCap->Dir < H245_CAPDIR_LCLRX   ||
      pTotCap->Dir > H245_CAPDIR_LCLRXTX ||
      pTotCap->ClientType < H245_CLIENT_NONSTD ||
      pTotCap->ClientType > H245_CLIENT_MUX_H2250)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  // Don't trust the user filled-in data type!
  pTotCap->DataType = DataTypeMap[pTotCap->ClientType];

  /* if it's a MUX type handle here */
  if (pTotCap->DataType == H245_DATA_MUX)
  {
    // Add multiplex capability
    if (pTermCapSet->bit_mask & multiplexCapability_present)
    {
      del_mux_cap(pTermCapSet);
    }

    *pCapId = pTotCap->CapId = 0;
    lError = set_mux_cap(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate mux capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad mux capability - delete it
        del_mux_cap(pTermCapSet);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }
  else if (*pCapId == 0 || *pCapId == H245_INVALID_CAPID)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapIdNum == H245_INVALID_CAPID)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapId = pInstance->API.LocalCapIdNum;

    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)

    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    pTotCap->CapId = *pCapId;
    lError = set_capability(pInstance, pTermCapSet, pTotCap);

#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate capability
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Bad capability - delete it
        H245DelLocalCap(dwInst, *pCapId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245SetLocalCap -> %s",map_api_error(lError));
    pTotCap->CapId = *pCapId = H245_INVALID_CAPID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245SetLocalCap -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelLocalCap
 *
 * DESCRIPTION  Delete Local Cap simply disables the cap.. it
 *              will not be updated until the client issues
 *              H245SendTermCaps
 *
 *
 *       HRESULT H245DelLocalCap(
 *                              H245_INST_T     dwInst,
 *                              H245_CAPID_T    CapId
 *                              )
 *
 *      Description:
 *              This function allows the client to delete a specific
 *              capability id in the H.245 subsystem.
 *
 *              Note: This function does not communicate this update
 *              to the remote peer until the client calls H245SendTermCaps.
 *
 *      Input
 *              dwInst  Instance handle returned by H245GetInstanceId
 *              CapId   Cap Id the client wishes to remove from the
 *              capability table.
 *
 *              If an error occurs no action is taken and the CapId the
 *              client wished to delete is not changed.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK           Capability deleted
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245SendTermCaps
 *              H245EnumCaps
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelLocalCap         (
                         H245_INST_T            dwInst,
                         H245_CAPID_T           CapId
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  HRESULT                         lError = H245_ERROR_OK;

  H245TRACE (dwInst,4,"H245DelLocalCap <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;

  if (CapId == 0)
  {
    // Delete multiplex capability
    del_mux_cap(pTermCapSet);
  }
  else
  {
    /* (TBC) if I delete my capability id.. what about simultaneous caps ?? */
    /* should I go through the list and deactivate them ??                */
    pCapLink = find_capid_by_entrynumber (pTermCapSet, CapId);
    if (pCapLink)
    {
      // Delete terminal capability
      disable_cap_link (pCapLink);
    }
    else
    {
      lError = H245_ERROR_PARAM;
    }
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245DelLocalCap -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245DelLocalCap -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245DelLocalCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SetCapDescriptor
 *
 * DESCRIPTION
 *
 *      HRESULT H245SetCapDescriptor (
 *                                  H245_INST_T       dwInst,
 *                                  H245_CAPDESC_T   *pCapDesc,
 *                                  H245_CAPDESCID_T *pCapDescId (* Optional *)
 *                                  )
 *      Description:
 *              This procedure is called to set local capability descriptors.
 *              It will return a capability descriptor id in the parameter
 *              *pCapDescId if it is non null.
 *
 *              Note:
 *                These capabilities are communicated via the H245SendTermCaps
 *                API call.  Any updates to the CapDescriptor table (either
 *                additions or deletions ) will not be communicated to the
 *                remote side until the H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDesc         This is the capability Descriptor you wish
 *                              to set
 *      Output
 *              pCapDescId      optional: Capability id that will be returned.
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_CAPID Capid used in CapDesc was not
 *                                       registred
 *              H245_ERROR_MAXTB         Out of table space to store Descriptor
 *              H245_ERROR_PARAM         Descriptor is too long or not valid
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245DelCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *****************************************************************************/

H245DLL HRESULT
H245SetCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESC_T        *pCapDesc,
                         H245_CAPDESCID_T      *pCapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                          lError;

  H245TRACE (dwInst,4,"H245SetCapDescriptor <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* must have capdescriptor &&   */
  /* length must be less than 256 */
  if (pCapDesc == NULL ||
      pCapDesc->Length >= 256 ||
      pCapDescId == NULL)
  {
    H245TRACE (dwInst,1,"H245SetCapDescriptor -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (*pCapDescId >= 256)
  {
    // Assign the next never-used cap id
    if (pInstance->API.LocalCapDescIdNum >= 256)
    {
      // All possible capability identifiers have been assigned
      H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(H245_ERROR_MAXTBL));
      InstanceUnlock(pInstance);
      return H245_ERROR_MAXTBL;
    }
    *pCapDescId = pInstance->API.LocalCapDescIdNum;

    /* insert in the new capability descriptor in the local capability descriptor table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
    if (lError == H245_ERROR_OK)
      pInstance->API.LocalCapDescIdNum++;
  }
  else
  {
    /* insert in the new capability in the local capability set table */
    lError = set_cap_descriptor(pInstance, pCapDesc, pCapDescId,
                                  &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet);
#if defined(_DEBUG)
    if (lError == H245_ERROR_OK)
    {
      // Validate Capability Descriptor
      if (check_pdu(pInstance, &pInstance->API.PDU_LocalTermCap))
      {
        // Capability Descriptor Invalid - delete it
        H245DelCapDescriptor(dwInst, *pCapDescId);
        lError = H245_ERROR_ASN1;
      }
    }
#endif // (DEBUG)
  }

  if (lError != H245_ERROR_OK)
  {
    H245TRACE (dwInst,1,"H245CapDescriptor -> %s",map_api_error(lError));
    *pCapDescId = H245_INVALID_CAPDESCID;
  }
  else
  {
    H245TRACE (dwInst,4,"H245CapDescriptor -> OK");
  }
  InstanceUnlock(pInstance);
  return lError;
} // H245SetCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245DelCapDescriptor
 *
 * DESCRIPTION
 *
 *       HRESULT H245DelCapDescriptor (
 *                                   H245_INST_T          dwInst,
 *                                   H245_CAPDESCID_T     CapDescId
 *                                   )
 *      Description:
 *              This procedure is called to delete local capability descriptors.
 *
 *              Note:
 *                      These capabilities are communicated via the
 *                      H245SendTermCaps API call.  Any updates to the
 *                      CapDescriptor table (either additions or deletions )
 *                      will not be communicated to the remote side until the
 *                      H245SendTermCaps call is made.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              CapDescId       This is the capability Descriptor you wish
 *                              to delete
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_INST
 *
 *      See Also:
 *              H245SetCapDescriptor
 *              H245SendTermCaps
 *
 * ASSUMES:
 *
 *              SimCapId is the array entry point in the apabilityDescriptors
 *              array.. this has a limitation, in that you can never wrap the
 *              array at 256.. this will be cleaned up when array is turned into
 *              linked list.
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245DelCapDescriptor    (
                         H245_INST_T            dwInst,
                         H245_CAPDESCID_T       CapDescId
                        )
{
  register struct InstanceStruct *pInstance;
  CapabilityDescriptor           *p_cap_desc;
  struct TerminalCapabilitySet   *pTermCapSet;
  unsigned int                    uId;
  H245TRACE (dwInst,4,"H245DelCapDescriptor <-");

  if (CapDescId >= 256)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"API:H24DelCapDescriptor -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  /* get pointer to Capability Descriptor */
  p_cap_desc = NULL;
  pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
  for (uId = 0; uId < pTermCapSet->capabilityDescriptors.count; ++uId)
  {
    if (pTermCapSet->capabilityDescriptors.value[uId].capabilityDescriptorNumber == CapDescId)
    {
      p_cap_desc = &pTermCapSet->capabilityDescriptors.value[uId];
      break;
    }
  }
  if (p_cap_desc == NULL ||
      p_cap_desc->smltnsCpblts == NULL ||
      (p_cap_desc->bit_mask & smltnsCpblts_present) == 0)
  {
    H245TRACE(dwInst,1,"API:H24DelCapDescriptor -> Invalid cap desc id %d",CapDescId);
    InstanceUnlock(pInstance);
    return H245_ERROR_INVALID_CAPDESCID;
  }

  /* free up the list */
  dealloc_simultaneous_cap (p_cap_desc);

  /* (TBC) what if you've removed the last simultaneous cap ? */

  /* in this case.. the count does not go down.. it simply    */
  /* removes the cap descriptor bit from the table..          */

  H245TRACE (dwInst,4,"H245DelCapDescriptor -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245DelCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendTermCaps
 *
 * DESCRIPTION
 *
 *      HRESULT
 *      H245SendTermCaps (
 *                      H245_INST_T             dwInst,
 *                      DWORD                   dwTransId
 *                      )
 *
 *      Description:
 *
 *              Called to send terminal capabilities to the remote H.245 peer.
 *              When remote capabilities are receive the client will be
 *              notified by the H245_IND_CAP indication. When remote side has
 *              acknowledged the local terminal capabilities and has responded
 *              with their terminal capabilities the client will receive an
 *              H245_CONF_ TERMCAP.  Between H245Init and H245SendTermCap the
 *              client may call H245SetLocalCap to register capabilities.
 *              These capabilities will not be registered to the remote side
 *              until H245SendTermCap has been called.
 *
 *              Note: As required by the H245 specification, Mutliplex
 *                    capabilities, and Capability descriptors must be
 *                    loaded before the first capability PDU is sent.
 *
 *                    Once H245SendTermCap is called, any subsequent calls to
 *                    H245SetLocalTermCap will result in that capability being
 *                    communicated to the remote H.245 peer.
 *
 *      Input
 *              dwInst                  Instance handle returned by
 *                                      H245GetInstanceId
 *              dwTransId               User supplied object used to identify
 *                                      this request in the asynchronous
 *                                      response to this call.
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_TERMCAP
 *
 *      Errors:
 *              H245_ERROR_OK           Function succeeded
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_NO_MUX_CAPS  no Mux capabilities have been set yet
 *              H245_ERROR_NO_CAPDESC   no Capability Descriptors have been set
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245Init
 *
 *      callbacks
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *              H245_IND_CAP_DEL
 *              H245_IND_CAPDESC_DEL
 *
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendTermCaps        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  struct InstanceStruct  *pInstance;
  Tracker_T              *pTracker;
  HRESULT                 lError;
  unsigned char			  TermCapData = TRUE;
  struct TerminalCapabilitySet_capabilityTable  TermCap = {0};

  H245TRACE(dwInst,4,"H245SendTermCaps <-");

  /* check for valid instance handle */

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* must have mux parameters set */
  if ((pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & multiplexCapability_present) == 0)
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_MUX_CAPS));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_MUX_CAPS;
    }

  /* must have capability descriptors set */
  if (!(pInstance->API.PDU_LocalTermCap.TERMCAPSET.bit_mask & capabilityDescriptors_present))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NO_CAPDESC));
      InstanceUnlock(pInstance);
      return H245_ERROR_NO_CAPDESC;
    }

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_TERMCAP_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_UNDEF,
                                        API_CH_TYPE_UNDEF,
                                        0,
                                        H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                        0)))
    {
      H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }

  pdu_req_termcap_set (&pInstance->API.PDU_LocalTermCap, 0);
  TermCap.next = pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable;
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = &TermCap;
  TermCap.value.bit_mask = capability_present;
  TermCap.value.capabilityTableEntryNumber = pInstance->API.LocalCapIdNum;
  TermCap.value.capability.choice = Capability_nonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.choice = h221NonStandard_chosen;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35CountryCode	 = 0xB5;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.t35Extension	 = 0x42;
  TermCap.value.capability.u.Capability_nonStandard.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = 0x8080;
  TermCap.value.capability.u.Capability_nonStandard.data.value  = &TermCapData;
  TermCap.value.capability.u.Capability_nonStandard.data.length = sizeof(TermCapData);
  lError = FsmOutgoing(pInstance, &pInstance->API.PDU_LocalTermCap, (DWORD_PTR)pTracker);
  pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet.capabilityTable = TermCap.next;

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SendTermCaps -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SendTermCaps -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendTermCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245EnumCaps
 *
 * DESCRIPTION
 *
 *      HRESULT  H245EnumCaps (
 *                           DWORD                       dwInst,
 *                           DWORD                       dwTransId,
 *                           H245_CAPDIR_T               Direction,
 *                           H245_DATA_T                 DataType,
 *                           H245_CLIENT_T               ClientType,
 *                           H245_CAP_CALLBACK_T         CallBack
 *                           )
 *
 *
 *      Callback:
 *              CallBack (
 *                             DWORD                      dwTransId,
 *                             H245_TOTCAP_T             *pTotCap,
 *                       )
 *
 *      Description:
 *
 *              This function calls the H.245 client back for every
 *              capability as defined in the API call that complies with the
 *              request.  If the DataType parameter is set to 0 all of the
 *              caps types are returned (either local or remote based on the
 *              Direction parameter) no mater what is in the ClientType
 *              parameter. If the ClientType parameter is 0, it will return
 *              all of the capabilities of the given DataType.
 *
 *              The user supplied call back is called within the context of
 *              the call, therefor the call will be considered synchronous.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Direction       Local/Remote Receive, Transmit, or Receive and
 *                              Transmit
 *              DataType        Type of data (Audio, Video, Data, etc.)
 *              ClientType      Client type (H.262, G.711. etc. ).
 *              dwTransId       User supplied object used to identify this
 *                              request in the callback.
 *
 *      CallBack Output
 *              dwTransId       Identical to dwTransId passed in H245EnumCaps
 *                              pTotCap Pointer one of the capabilities.
 *
 *              Note: TotCap parameter must be copied in the callback.  This
 *                    data structure is reused for each callback.
 *
 *      Call Type:
 *              Synchronous Callback - i.e. called back in the context of
 *                              the API call
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        One or more parameters were invalid
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle.
 *
 *      See Also:
 *              H245SetLocalCap
 *              H245ReplLocalCap
 *
 *      callback
 *
 *              H245_IND_CAP
 *              H245_IND_CAPDESC
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245EnumCaps            (
                         H245_INST_T              dwInst,
                         DWORD_PTR                dwTransId,
                         H245_CAPDIR_T            Direction,
                         H245_DATA_T              DataType,
                         H245_CLIENT_T            ClientType,
                         H245_CAP_CALLBACK_T      pfCapCallback,
                         H245_CAPDESC_CALLBACK_T  pfCapDescCallback
                        )
{
  register struct InstanceStruct *pInstance;
  struct TerminalCapabilitySet   *pTermCapSet;
  CapabilityTableLink             pCapLink;
  int                             lcl_rmt;
  H245_TOTCAP_T                   totcap;
  int                             nResult = 0;

  H245TRACE (dwInst,4,"H245EnumCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* check for callback routine */
  if (pfCapCallback == NULL && pfCapDescCallback == NULL)
    {
      H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* ok... check the direction.. either remote or local caps.. */
  switch (Direction)
  {
  case H245_CAPDIR_RMTRX:
  case H245_CAPDIR_RMTTX:
  case H245_CAPDIR_RMTRXTX:
    pTermCapSet = &pInstance->API.PDU_RemoteTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_REMOTE;
    break;

  case H245_CAPDIR_LCLRX:
  case H245_CAPDIR_LCLTX:
  case H245_CAPDIR_LCLRXTX:
    pTermCapSet = &pInstance->API.PDU_LocalTermCap.u.MltmdSystmCntrlMssg_rqst.u.terminalCapabilitySet;
    lcl_rmt = H245_LOCAL;
    break;

  /* must be either local or remote */
  // case H245_CAPDIR_DONTCARE:
  default:
    H245TRACE (dwInst,1,"H245EnumCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  if (pfCapCallback)
  {
    if (pTermCapSet->bit_mask & multiplexCapability_present &&
        build_totcap_from_mux(&totcap, &pTermCapSet->multiplexCapability, Direction) == H245_ERROR_OK)
    {
      (*pfCapCallback)(dwTransId, &totcap);
    }

    if (ClientType == H245_CLIENT_DONTCARE)
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.DataType == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // if
    else
    {
      if (DataType == H245_DATA_DONTCARE)
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap, pCapLink, lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          } /* if cap match */
        } // for
      } // if
      else
      {
        for (pCapLink = pTermCapSet->capabilityTable; pCapLink && nResult == 0; pCapLink = pCapLink->next)
        {
          /* if capability is present */
          if (pCapLink->value.bit_mask & capability_present &&
              build_totcap_from_captbl(&totcap,pCapLink,lcl_rmt) == H245_ERROR_OK &&
              totcap.ClientType == ClientType &&
              totcap.DataType   == DataType)
          {
            nResult = (*pfCapCallback)(dwTransId, &totcap);
          }
        } // for
      } // else
    } // else
  } // if (pfCapCallback)

  if (pfCapDescCallback)
  {
    // Convert CapabilityDescriptor format to H245_CAPDESC_T format
    unsigned int                uCapDesc;
    register SmltnsCpbltsLink   pSimCap;
    register unsigned int       uAltCap;
    H245_TOTCAPDESC_T           TotCapDesc;

    for (uCapDesc = 0;
         uCapDesc < pTermCapSet->capabilityDescriptors.count && nResult == 0;
         ++uCapDesc)
    {
      if (pTermCapSet->capabilityDescriptors.value[uCapDesc].bit_mask & smltnsCpblts_present)
      {
        ASSERT(pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber <= 256);
        TotCapDesc.CapDesc.Length = 0;
        pSimCap = pTermCapSet->capabilityDescriptors.value[uCapDesc].smltnsCpblts;
        ASSERT(pSimCap != NULL);
        while (pSimCap)
        {
          if (TotCapDesc.CapDesc.Length >= H245_MAX_SIMCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of simutaneous capabilities exceeds H245_MAX_SIMCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          if (pSimCap->value.count > H245_MAX_ALTCAPS)
          {
            H245TRACE (dwInst,1,"H245EnumCaps -> Number of alternative capabilities exceeds H245_MAX_ALTCAPS");
            InstanceUnlock(pInstance);
            return H245_ERROR_MAXTBL;
          }
          TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].Length = (WORD) pSimCap->value.count;
          for (uAltCap = 0; uAltCap < pSimCap->value.count; ++uAltCap)
          {
            TotCapDesc.CapDesc.SimCapArray[TotCapDesc.CapDesc.Length].AltCaps[uAltCap] = pSimCap->value.value[uAltCap];
          }
          TotCapDesc.CapDesc.Length++;
          pSimCap = pSimCap->next;
        } // while
        TotCapDesc.CapDescId = pTermCapSet->capabilityDescriptors.value[uCapDesc].capabilityDescriptorNumber;
        nResult = pfCapDescCallback(dwTransId, &TotCapDesc);
      } // if
    } // for
  } // if (pfCapDescCallback)

  H245TRACE (dwInst,4,"H245EnumCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245EnumCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245GetCaps
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

static H245_TOTCAP_T * *      ppTotCapGlobal;
static unsigned long          dwTotCapLen;
static unsigned long          dwTotCapMax;
static H245_TOTCAPDESC_T * *  ppCapDescGlobal;
static unsigned long          dwCapDescLen;
static unsigned long          dwCapDescMax;
static HRESULT                dwGetCapsError;

static int
GetCapsCapCallback(DWORD_PTR dwTransId, H245_TOTCAP_T *pTotCap)
{
  H245_TOTCAP_T *pNewCap;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwTotCapLen >= dwTotCapMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCap(&pNewCap, pTotCap);
      if (dwGetCapsError == H245_ERROR_OK)
      {
        *ppTotCapGlobal++ = pNewCap;
        ++dwTotCapLen;
      }
    }
  }

  return 0;
} // GetCapsCapCallback()

static int
GetCapsCapDescCallback(DWORD_PTR dwTransId, H245_TOTCAPDESC_T *pCapDesc)
{
  H245_TOTCAPDESC_T *pNewCapDesc;

  if (dwGetCapsError == H245_ERROR_OK)
  {
    if (dwCapDescLen >= dwCapDescMax)
    {
      dwGetCapsError = H245_ERROR_MAXTBL;
    }
    else
    {
      dwGetCapsError = H245CopyCapDescriptor(&pNewCapDesc,pCapDesc);
      {
        *ppCapDescGlobal++ = pNewCapDesc;
        ++dwCapDescLen;
      }
    }
  }

  return 0;
} // GetCapsCapDescCallback()

H245DLL HRESULT
H245GetCaps             (
                         H245_INST_T            dwInst,
                         H245_CAPDIR_T          Direction,
                         H245_DATA_T            DataType,
                         H245_CLIENT_T          ClientType,
                         H245_TOTCAP_T * *      ppTotCap,
                         unsigned long *        pdwTotCapLen,
                         H245_TOTCAPDESC_T * *  ppCapDesc,
                         unsigned long *        pdwCapDescLen
                        )
{
  register struct InstanceStruct *pInstance;
  H245_CAP_CALLBACK_T           CapCallback;
  H245_CAPDESC_CALLBACK_T       CapDescCallback;

  H245TRACE (dwInst,4,"H245GetCaps <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  dwTotCapLen     = 0;
  if (ppTotCap == NULL || pdwTotCapLen == NULL || *pdwTotCapLen == 0)
  {
    CapCallback = NULL;
  }
  else
  {
    CapCallback     = GetCapsCapCallback;
    ppTotCapGlobal  = ppTotCap;
    dwTotCapMax     = *pdwTotCapLen;
  }

  dwCapDescLen    = 0;
  if (ppCapDesc == NULL || pdwCapDescLen == NULL || *pdwCapDescLen == 0)
  {
    CapDescCallback = NULL;
  }
  else
  {
    CapDescCallback = GetCapsCapDescCallback;
    ppCapDescGlobal = ppCapDesc;
    dwCapDescMax    = *pdwCapDescLen;
  }

  /* check parameters */
  if (CapCallback == NULL && CapDescCallback == NULL)
  {
    H245TRACE (dwInst,1,"H245GetCaps -> %s",map_api_error(H245_ERROR_PARAM));
    InstanceUnlock(pInstance);
    return H245_ERROR_PARAM;
  }

  dwGetCapsError = H245_ERROR_OK;
  H245EnumCaps(dwInst,
               0,
               Direction,
               DataType,
               ClientType,
               CapCallback,
               CapDescCallback);

  if (pdwTotCapLen)
    *pdwTotCapLen = dwTotCapLen;
  if (pdwCapDescLen)
    *pdwCapDescLen = dwCapDescLen;
  if (dwGetCapsError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245GetCaps -> %s", map_api_error(dwGetCapsError));
  else
    H245TRACE (dwInst,4,"H245GetCaps -> OK");
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245GetCaps()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCap             (H245_TOTCAP_T			**ppDestTotCap,
						 const H245_TOTCAP_T	*pTotCap)
{
  POBJECTID               pObjectTo;
  POBJECTID               pObjectFrom;
  HRESULT				  Status;

  if (ppDestTotCap == NULL)
	  return H245_ERROR_PARAM;

  *ppDestTotCap = NULL;

  if (pTotCap == NULL)
	  return H245_ERROR_PARAM;

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_NONSTD:
  case H245_CLIENT_VID_NONSTD:
  case H245_CLIENT_AUD_NONSTD:
  case H245_CLIENT_MUX_NONSTD:
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245_NonStd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245_NonStd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.value,
             pTotCap->Cap.H245_NonStd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245_NonStd.data.value = NULL;
    }
    if (pTotCap->Cap.H245_NonStd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245_NonStd.data.length);
      (*ppDestTotCap)->Cap.H245_NonStd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245_NonStd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_NONSTD:
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen)
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length +
        ObjectIdLength(&pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    if (pTotCap->Cap.H245_NonStd.data.length != 0)
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value =
        (unsigned char *)(*ppDestTotCap + 1);
      memcpy((*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value,
             pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
    }
    else
    {
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.value = NULL;
    }
    if (pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object != NULL)
    {
      pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
        pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.data.length);
      (*ppDestTotCap)->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
      pObjectFrom = pTotCap->Cap.H245Dat_NONSTD.application.u.DACy_applctn_nnStndrd.nonStandardIdentifier.u.object;
      do
      {
        pObjectTo->value = pObjectFrom->value;
        pObjectTo->next  = pObjectTo + 1;
        ++pObjectTo;
      } while ((pObjectFrom = pObjectFrom->next) != NULL);
      --pObjectTo;
      pObjectTo->next = NULL;
    }
    break;

  case H245_CLIENT_DAT_T120:
  case H245_CLIENT_DAT_DSMCC:
  case H245_CLIENT_DAT_USERDATA:
  case H245_CLIENT_DAT_T434:
  case H245_CLIENT_DAT_H224:
  case H245_CLIENT_DAT_H222:
    if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.choice == DtPrtclCpblty_nnStndrd_chosen)
    {
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen)
      {
        *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length +
          ObjectIdLength(&pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier) * sizeof(OBJECTID));
      }
      else
      {
        *ppDestTotCap = MemAlloc(sizeof(*pTotCap) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

      **ppDestTotCap = *pTotCap;
      if (pTotCap->Cap.H245_NonStd.data.length != 0)
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value =
          (unsigned char *)(*ppDestTotCap + 1);
        memcpy((*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value,
               pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
      }
      else
      {
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.value = NULL;
      }
      if (pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.choice == object_chosen &&
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object != NULL)
      {
        pObjectTo = (POBJECTID)(((unsigned char *)(*ppDestTotCap + 1)) +
          pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.data.length);
        (*ppDestTotCap)->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object = pObjectTo;
        pObjectFrom = pTotCap->Cap.H245Dat_T120.application.u.DACy_applctn_t120.u.DtPrtclCpblty_nnStndrd.nonStandardIdentifier.u.object;
        do
        {
          pObjectTo->value = pObjectFrom->value;
          pObjectTo->next  = pObjectTo + 1;
          ++pObjectTo;
        } while ((pObjectFrom = pObjectFrom->next) != NULL);
        --pObjectTo;
        pObjectTo->next = NULL;
      }
    }
    else
    {
      *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	  if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
      **ppDestTotCap = *pTotCap;
    }
    break;

  case H245_CLIENT_CONFERENCE:
  {
    NonStandardDataLink pList;
    NonStandardDataLink pFrom;
    NonStandardDataLink pTo;

	// Initialize Status here to prevent compiler warning "returning a possibly
	// uninitialized value"
	Status = H245_ERROR_NOMEM;

    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;

    pList = NULL;
    (*ppDestTotCap)->Cap.H245Conference.nonStandardData = NULL;
    pFrom = pTotCap->Cap.H245Conference.nonStandardData;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
	  if (pTo == NULL)
		  Status = H245_ERROR_NOMEM;

      if (pTo != NULL)
      {
        Status = CopyNonStandardParameter(&pTo->value, &pFrom->value);
		if (Status != H245_ERROR_OK)
        {
          MemFree(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          MemFree(pTo);
        }
        MemFree(*ppDestTotCap);
		*ppDestTotCap = NULL;
        return Status;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Conference.nonStandardData;
      (*ppDestTotCap)->Cap.H245Conference.nonStandardData = pTo;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H222:
  {
    VCCapabilityLink pList = NULL;
    VCCapabilityLink pFrom;
    VCCapabilityLink pTo;

    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = NULL;
    pFrom = pTotCap->Cap.H245Mux_H222.vcCapability;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          MemFree(pTo);
        }
        MemFree(*ppDestTotCap);
        *ppDestTotCap = NULL;
        return H245_ERROR_NOMEM;
      }
      pTo->value = pFrom->value;
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability;
      (*ppDestTotCap)->Cap.H245Mux_H222.vcCapability = pList;
    } // while
    break;
  }

  case H245_CLIENT_MUX_H2250:
    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;

    **ppDestTotCap = *pTotCap;
    Status = CopyH2250Cap(&(*ppDestTotCap)->Cap.H245Mux_H2250, &pTotCap->Cap.H245Mux_H2250);
    if (Status != H245_ERROR_OK)
	{
      MemFree(*ppDestTotCap);
	  *ppDestTotCap = NULL;
	  return Status;
    }
    break;

  default:
    *ppDestTotCap = MemAlloc(sizeof(*pTotCap));
	if (*ppDestTotCap == NULL)
		return H245_ERROR_NOMEM;
    **ppDestTotCap = *pTotCap;
  } // switch

  return H245_ERROR_OK;
} // H245CopyCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCap
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCap             (H245_TOTCAP_T *        pTotCap)
{
  if (pTotCap == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pTotCap->ClientType)
  {
  case H245_CLIENT_CONFERENCE:
    {
      NonStandardDataLink pList;
      NonStandardDataLink pTo;

      pList = pTotCap->Cap.H245Conference.nonStandardData;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        FreeNonStandardParameter(&pTo->value);
        MemFree(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H222:
    {
      VCCapabilityLink pList;
      VCCapabilityLink pTo;

      pList = pTotCap->Cap.H245Mux_H222.vcCapability;
      while (pList)
      {
        pTo = pList;
        pList = pList->next;
        MemFree(pTo);
      }
    }
    break;

  case H245_CLIENT_MUX_H2250:
    FreeH2250Cap(&pTotCap->Cap.H245Mux_H2250);
    break;

  } // switch
  MemFree(pTotCap);
  return 0;
} // H245FreeCap()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CopyCapDescriptor   (H245_TOTCAPDESC_T			**ppDestCapDesc,
						 const H245_TOTCAPDESC_T	*pCapDesc)
{
  if (ppDestCapDesc == NULL)
	  return H245_ERROR_PARAM;

  *ppDestCapDesc = NULL;

  if (pCapDesc == NULL)
	  return H245_ERROR_PARAM;

  *ppDestCapDesc = MemAlloc(sizeof(**ppDestCapDesc));
  if (*ppDestCapDesc == NULL)
	  return H245_ERROR_NOMEM;

  **ppDestCapDesc = *pCapDesc;
  return H245_ERROR_OK;
} // H245CopyCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeCapDescriptor
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeCapDescriptor   (H245_TOTCAPDESC_T *    pCapDesc)
{
  if (pCapDesc == NULL)
  {
    return H245_ERROR_PARAM;
  }

  MemFree(pCapDesc);
  return 0;
} // H245FreeCapDescriptor()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CopyMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL H245_MUX_T *
H245CopyMux             (const H245_MUX_T *           pMux)
{
  register unsigned int   uLength;
  register H245_MUX_T    *pNew;
  H2250LCPs_nnStndrdLink  pList;
  H2250LCPs_nnStndrdLink  pFrom;
  H2250LCPs_nnStndrdLink  pTo;

  switch (pMux->Kind)
  {
  case H245_H222:
    uLength = sizeof(*pMux) +
      pMux->u.H222.programDescriptors.length +
      pMux->u.H222.streamDescriptors.length;
    pNew = MemAlloc(uLength);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H222.programDescriptors.length != 0)
      {
        pNew->u.H222.programDescriptors.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.value,
               pMux->u.H222.programDescriptors.length);
      }
      else
      {
        pNew->u.H222.programDescriptors.value = NULL;
      }

      if (pMux->u.H222.streamDescriptors.length != 0)
      {
        pNew->u.H222.streamDescriptors.value = ((unsigned char *)pNew) +
          (uLength - pMux->u.H222.streamDescriptors.length);
        memcpy(pNew->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.value,
               pMux->u.H222.streamDescriptors.length);
      }
      else
      {
        pNew->u.H222.streamDescriptors.value = NULL;
      }
    }
    break;

  case H245_H223:
    pNew = MemAlloc(sizeof(*pMux) + pMux->u.H223.H223_NONSTD.data.length);
    if (pNew != NULL)
    {
      *pNew = *pMux;
      if (pMux->u.H223.H223_NONSTD.data.length != 0)
      {
        pNew->u.H223.H223_NONSTD.data.value = (unsigned char *)(pNew + 1);
        memcpy(pNew->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.value,
               pMux->u.H223.H223_NONSTD.data.length);
      }
      else
      {
        pNew->u.H223.H223_NONSTD.data.value = NULL;
      }
    }
    break;

  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list, mediaChannel and mediaControlChannel
    //         in same place in both structures
    if (pMux->u.H2250.mediaChannelPresent &&
        (pMux->u.H2250.mediaChannel.type == H245_IPSSR_UNICAST ||
         pMux->u.H2250.mediaChannel.type == H245_IPLSR_UNICAST) &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.route != NULL &&
        pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount != 0)
    {
      if (pMux->u.H2250.mediaControlChannelPresent &&
          (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
           pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
          pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
      {
        unsigned int          uLength2;
        uLength  = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        uLength2 = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
        pNew = MemAlloc(sizeof(*pMux) + uLength + uLength2);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route =
            pNew->u.H2250.mediaChannel.u.ipSourceRoute.route + uLength;
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
          memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
                 uLength2);
        }
      }
      else
      {
        uLength = pMux->u.H2250.mediaChannel.u.ipSourceRoute.dwCount << 2;
        pNew = MemAlloc(sizeof(*pMux) + uLength);
        if (pNew != NULL)
        {
          *pNew = *pMux;
          pNew->u.H2250.mediaChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
          memcpy(pNew->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 pMux->u.H2250.mediaChannel.u.ipSourceRoute.route,
                 uLength);
        }
      }
    }
    else if (pMux->u.H2250.mediaControlChannelPresent &&
             (pMux->u.H2250.mediaControlChannel.type == H245_IPSSR_UNICAST ||
              pMux->u.H2250.mediaControlChannel.type == H245_IPLSR_UNICAST) &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route != NULL &&
             pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount != 0)
    {
      uLength = pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.dwCount << 2;
      pNew = MemAlloc(sizeof(*pMux) + uLength);
      if (pNew != NULL)
      {
        *pNew = *pMux;
        pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route = (unsigned char *) (pNew + 1);
        memcpy(pNew->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               pMux->u.H2250.mediaControlChannel.u.ipSourceRoute.route,
               uLength);
      }
    }
    else
    {
      pNew = MemAlloc(sizeof(*pMux));
      if (pNew != NULL)
      {
        *pNew = *pMux;
      }
    }
    pList = NULL;
    pNew->u.H2250.nonStandardList = NULL;
    pFrom = pMux->u.H2250.nonStandardList;
    while (pFrom)
    {
      pTo = MemAlloc(sizeof(*pTo));
      if (pTo != NULL)
      {
        if (CopyNonStandardParameter(&pTo->value, &pFrom->value) != H245_ERROR_OK)
        {
          MemFree(pTo);
          pTo = NULL;
        }
      }
      if (pTo == NULL)
      {
        while (pList)
        {
          pTo = pList;
          pList = pList->next;
          FreeNonStandardParameter(&pTo->value);
          MemFree(pTo);
        }
        MemFree(pNew);
        return NULL;
      }
      pTo->next = pList;
      pList = pTo;
      pFrom = pFrom->next;
    } // while
    while (pList)
    {
      pTo = pList;
      pList = pList->next;
      pTo->next = pNew->u.H2250.nonStandardList;
      pNew->u.H2250.nonStandardList = pTo;
    } // while
    break;

//  case H245_VGMUX:
 default:
    pNew = MemAlloc(sizeof(*pMux));
    if (pNew != NULL)
    {
      *pNew = *pMux;
    }
  } // switch

  return pNew;
} // H245CopyMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FreeMux
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FreeMux             (H245_MUX_T *           pMux)
{
  H2250LCPs_nnStndrdLink      pLink;

  if (pMux == NULL)
  {
    return H245_ERROR_PARAM;
  }

  switch (pMux->Kind)
  {
  case H245_H2250:
  case H245_H2250ACK:
    // Caveat: assumes nonstandard list is in same place in both structures
    while (pMux->u.H2250.nonStandardList)
    {
      pLink = pMux->u.H2250.nonStandardList;
      pMux->u.H2250.nonStandardList = pLink->next;
      FreeNonStandardParameter(&pLink->value);
      MemFree(pLink);
    }
    break;
  } // switch

  MemFree(pMux);
  return 0;
} // H245FreeMux()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245OpenChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245OpenChannel (
 *                              H245_INST_T      dwInst,
 *                              DWORD            dwTransId,
 *                              DWORD            dwTxChannel,
 *                              H245_TOTCAP_T   *pTxMode,
 *                              H245_MUX_T      *pTxMux,
 *                              H245_TOTCAP_T   *pRxMode, (* bi-dir only *)
 *                              H245_MUX_T      *pRxMux   (* bi-dir only *)
 *                              )
 *
 *      Description:
 *              This function is called to open either a uni-directional,
 *              or a bi-directional channel.  The  mode to the remote peer
 *              will be designated by the *pTxMode.. To open a bi-directional
 *              channel the client selects a non-null receive mode ( *pRxMode).
 *              This mode  indicates to  the remote peer its transmit mode.
 *              For  uni-directional channels the *pRxMode must be NULL.
 *
 *              The dwTxChannel parameter indicates which forward logical
 *              channel the H.245 will open.  If this is a bi-directional
 *              channel open, the confirm will indicate the logical channel
 *              specified in the open request by the remote terminal
 *
 *              The pMux parameter will contain a pointer to H.223, H.222,
 *              VGMUX, or other logical channel parameters depending on the
 *              system configuration. (see H245_H223_LOGICAL_PARAM).  This
 *              may be NULL for some clients.
 *
 *      Note:
 *              7 pTxMode->CapId is of no significance in this call.
 *                      It is not used
 *              7 pRxMode->CapId is of no significance in this call.
 *                      It is not used
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              dwTxChannel     Logical Channel number for forward (Transmit)
 *                              Channel
 *              pTxMode         The capability (mode) used for transmission
 *                              to the remote peer.
 *                              Note: pTxMode->CapId is ignored
 *              pTxMux          The formward logical channel parameters
 *                              for H.223, H.222, VGMUX, etc.
 *              pRxMode         Optional: Transmit mode specified for the
 *                              remote terminal. This is used only for
 *                              Bi-directional Channel opens and must be set
 *                              to NULL if opening a Uni-directional channel.
 *                              Note: pRxMode->CapId is ignored
 *              pRxMux          Optional : The reverse logical channel
 *                              parameters for H.223, H.222, VGMUX, etc. or
 *                              NULL.
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callback:
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN  Bi-Directional Channels only
 *                                      waiting for confirm.
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                One or more parameters were
 *                                              invalid
 *              H245_ERROR_BANDWIDTH_OVERFLOW   Open would exceed bandwidth
 *                                              limitations
 *              H245_ERROR_NOMEM
 *              H245_ERROR_NORESOURCE           Out of resources, too many
 *                                              open channels or outside scope
 *                                              of simultaneous capabilities.
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_INVALID_STATE        Not in the proper state to
 *                                              issue open
 *              H245_ERROR_CHANNEL_INUSE        Channel is currently open
 *
 *      See Also:
 *              H245CloseChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *
 *      callback
 *
 *              H245_CONF_OPEN
 *              H245_CONF_NEEDRSP_OPEN
 *              H245_IND_OPEN_CONF
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannel         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel,
                         const H245_TOTCAP_T *  pTxMode,
                         const H245_MUX_T    *  pTxMux,
                         H245_PORT_T            dwTxPort,       // optional
                         const H245_TOTCAP_T *  pRxMode,        // bi-dir only
                         const H245_MUX_T    *  pRxMux,         // bi-dir only
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;
  Tracker_T                      *pTracker;
  MltmdSystmCntrlMssg            *pPdu;

  H245TRACE (dwInst,4,"H245OpenChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }
  /* must have performed Master Slave Negotiation at this point */
  if (pInstance->Configuration == H245_CONF_H324 &&
      pInstance->API.MasterSlave != APIMS_Master &&
      pInstance->API.MasterSlave != APIMS_Slave)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);

  /* channel is currently in use */
  if (pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_CHANNEL_INUSE));
      InstanceUnlock(pInstance);
      return H245_ERROR_CHANNEL_INUSE;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  /* lock in the transmit side..                        */
  /* wait until OpenChannelConfResp to setup RxChannel  */

  lError = pdu_req_open_channel(pPdu,
                                  wTxChannel,
                                  dwTxPort,        /* forward port */
                                  pTxMode,
                                  pTxMux,
                                  pRxMode,
                                  pRxMux,
                                  pSeparateStack);
  if (lError != H245_ERROR_OK)
    {
      H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
      free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);
      InstanceUnlock(pInstance);
      return lError;
    }

  /* if allocation error */

  if (!(pTracker = alloc_link_tracker (pInstance,
                                        API_OPEN_CHANNEL_T,
                                        dwTransId,
                                        API_ST_WAIT_RMTACK,
                                        API_CH_ALLOC_LCL,
                                        (pRxMode?API_CH_TYPE_BI:API_CH_TYPE_UNI),
                                        pTxMode->DataType,
                                        wTxChannel, H245_INVALID_CHANNEL,
                                        0)))
  {
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  free_pdu_req_open_channel(pPdu, pTxMode, pRxMode);

  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245OpenChannel -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245OpenChannel -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelAccept   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel,     // RxChannel from IND_OPEN
                         const H245_MUX_T *     pRxMux,         // optional H2250LogicalChannelAckParameters
                         H245_CHANNEL_T         wTxChannel,     // bi-dir only
                         const H245_MUX_T *     pTxMux,         // bi-dir only optional H2250LogicalChannelParameters
                         H245_PORT_T            dwTxPort,       // bi-dir only optional
                         const H245_ACCESS_T *  pSeparateStack  // optional
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelAccept <- wRxChannel=%d wTxChannel=%d",
             wRxChannel, wTxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if not open.. invalid op */
  if (pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*       if was uni open w/ TxChannel set.. error     */
  /* -or -                                              */
  /*       if was bi open w/ !TxChannel set.. error     */

  /* AND it wasn't a reject                             */

  if (pTracker->u.Channel.ChannelType == API_CH_TYPE_BI && wTxChannel == 0)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* for debug */
  ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  /* setup tracker object for new transaction */
  pTracker->TransId = dwTransId;

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));


  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      pTracker->State = API_ST_IDLE;
      pTracker->u.Channel.TxChannel = 0;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                0,
                                                NULL,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        MemFree (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    case API_CH_TYPE_BI:
      pTracker->State = API_ST_WAIT_CONF;       /* waiting for confirmation */
      pTracker->u.Channel.TxChannel = wTxChannel;
      lError = pdu_rsp_open_logical_channel_ack(pPdu,
                                                wRxChannel,
                                                pRxMux,
                                                wTxChannel,
                                                pTxMux,
                                                dwTxPort,
                                                pSeparateStack);
      if (lError != H245_ERROR_OK)
      {
        // If parameter error, we don't want to deallocate tracker
        MemFree (pPdu);
        InstanceUnlock(pInstance);
        return lError;
      }
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelAccept: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  MemFree (pPdu);

  switch (lError)
  {
  case H245_ERROR_OK:
    H245TRACE (dwInst,4,"H245OpenChannelAccept -> OK");
    break;

  default:
    // Deallocate tracker object for all errors except parameter error
    unlink_dealloc_tracker (pInstance, pTracker);

    // Fall-through to next case is intentional

  case H245_ERROR_PARAM:
      // If parameter error, we don't want to deallocate tracker
      H245TRACE (dwInst,1,"H245OpenChannelAccept -> %s",map_api_error(lError));
  } // switch

  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245OpenChannelReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245OpenChannelReject   (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wRxChannel, // RxChannel from IND_OPEN
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T *           pTracker;
  MltmdSystmCntrlMssg * pPdu;
  HRESULT               lError;

  H245TRACE (dwInst,4,"H245OpenChannelReject <- wRxChannel=%d", wRxChannel);

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);

  /* not locking tracker.. since no indication will come in until I issue the request */
  /* if not open.. invalid op */
  if (pTracker == NULL || pTracker->TrackerType != API_OPEN_CHANNEL_T)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* for debug */
  ASSERT (pTracker->u.Channel.RxChannel == wRxChannel);
  ASSERT (pTracker->u.Channel.ChannelAlloc == API_CH_ALLOC_RMT);

  /* check state.. must be returning.. */
  if (pTracker->State != API_ST_WAIT_LCLACK)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_INVALID_STATE));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_STATE;
    }

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(*pPdu));

  pdu_rsp_open_logical_channel_rej(pPdu, wRxChannel, wCause);

  switch (pTracker->u.Channel.ChannelType)
    {
    case API_CH_TYPE_UNI:
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    case API_CH_TYPE_BI:
      lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
      break;

    default:
      H245TRACE (dwInst,1,"H245OpenChannelReject: Invalid Tracker Channel Type %d",
                 pTracker->u.Channel.ChannelType);
      lError = H245_ERROR_FATAL;
    } // switch

  MemFree (pPdu);
  unlink_dealloc_tracker (pInstance, pTracker);

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245OpenChannelReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245OpenChannelReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245OpenChannelReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannel
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannel (
 *                              H245_INST_T     dwInst,
 *                              DWORD           dwTransId,
 *                              DWORD           wTxChannel,
 *                              )
 *      Description:
 *              Called to close a channel upon which the client previously
 *              issued an OpenChannel request.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM        wChannel is not a locally opened
 *                                      channel
 *              H245_ERROR_INVALID_INST dwInst is not a valid intance handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on
 *                                      this channel.(See H245CloseChannelReq)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannelReq
 *
 *      callback
 *              H245_CONF_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannel        (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wTxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannel <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wTxChannel, API_CH_ALLOC_LCL);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  /* setup new tracker state */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_close_logical_channel(pPdu, wTxChannel, 0/* user */);

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);

  /* error.. so deallocate tracker structure */
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannel -> %s",map_api_error(error));
  }
  else
  {
    H245TRACE (dwInst,4,"H245CloseChannel -> OK");
  }
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;
} // H245CloseChannel()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReq
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReq (
 *                                 H245_INST_T          dwInst,
 *                                 DWORD                dwTransId,
 *                                 DWORD                wChannel,
 *                                 )
 *      Description:
 *              Called to request the remote peer to close a logical channel
 *              it previously opened
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify this
 *                              request in the asynchronous confirm to this
 *                              call
 *              wChannel        Logical Channel Number to close
 *
 *              Note: This is only asking permission.  Even if the Close
 *              Request is accepted the channel still has to be closed from
 *              the remote side.  (i.e. this does not close the channel it
 *              only asked the remote side it issue a close)
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_CLOSE
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM                wChannel is not a channel
 *                                              opened by remote peer
 *              H245_ERROR_INVALID_INST         dwInst is not a valid instance
 *                                              handle
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP           Can not perform this operation
 *                                              on this channel
 *                                              (see H245CloseChannel)
 *      See Also:
 *              H245OpenChannel
 *              H245OpenChannelIndResp
 *              H245OpenChannelConfResp
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_CONF_CLOSE
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReq     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_CHANNEL_T         wRxChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReq <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_rxchannel (pInstance, wRxChannel, API_CH_ALLOC_RMT);
  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /*  verify state of tracker */
  pTracker->State = API_ST_WAIT_RMTACK;
  pTracker->TrackerType = API_CLOSE_CHANNEL_T;
  pTracker->TransId = dwTransId;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  pdu_req_request_close_channel(pPdu, wRxChannel);

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);
  if (error != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245CloseChannelReq -> %s",map_api_error(error));
  }
  else
    H245TRACE (dwInst,4,"H245CloseChannelReq -> OK");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReq()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245CloseChannelReqResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245CloseChannelReqResp (
 *                                      H245_INST_T     dwInst,
 *                                      H245_ACC_REJ_T  AccRej,
 *                                      DWORD           wChannel
 *                                      )
 *
 *      Description:
 *              This routine is called to accept or reject a
 *              RequestChannelClose (H245_IND_REQ_CLOSE indication) from the
 *              remote peer. The channel must have been locally opened.  The
 *              parameter AccRej is H245_ACC to accept or H245_REJ to reject
 *              the close.  The local client should follow this response with
 *              a H245CloseChannel call.
 *
 *              If there was a Release CloseChannelRequest event that
 *              occurred during this transaction there error code returned
 *              will be H245_ERROR_CANCELED.  This indicates to the H.245
 *              client that no action should be taken.
 *
 *      Input
 *              dwInst          Instance handle returned by H245GetInstanceId
 *              AccRej          this parameter contains either H245_ACC or
 *                              H245_REJ.  This indicates to H.245 which
 *                              action to take.
 *              wChannel        Logical Channel Number to close
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_PARAM
 *              H245_ERROR_NOMEM
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_INVALID_OP   Can not perform this operation on this
 *                                      channel (see H245CloseChannel)
 *              H245_ERROR_INVALID_INST dwInst is not a valid instance handle
 *              H245_ERROR_CANCELED     if release was received during the
 *                                      processing of this request..
 *      See Also:
 *              H245CloseChannel
 *
 *      callback
 *
 *              H245_IND_REQ_CLOSE
 *              H245_IND_CLOSE
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CloseChannelReqResp (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_T         AccRej,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  Tracker_T             *pTracker;
  DWORD                  error;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245CloseChannelReqResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if channel not found in tracker list */
  /* note that it looks for given channel given who alloced it */
  pTracker = find_tracker_by_txchannel (pInstance, wChannel,  API_CH_ALLOC_LCL);

  /* not locking tracker.. since no indication will come in until I issue the request */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* if the request was canceled.. tell useer */
  if (pTracker->State == API_ST_WAIT_LCLACK_CANCEL)
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_CANCELED));
      InstanceUnlock(pInstance);
      return H245_ERROR_CANCELED;
    }

  /* verify state of tracker */
  if ((pTracker->State != API_ST_WAIT_LCLACK) ||
      (pTracker->TrackerType != API_CLOSE_CHANNEL_T))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  /* set the state to idle.. expect this side to close the channel next */
  pTracker->State = API_ST_IDLE;

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* ok.. get pdu */
  if (AccRej == H245_ACC)
  {
    pTracker = NULL;
    pdu_rsp_request_channel_close_ack(pPdu, wChannel);
  }
  else
  {
    pdu_rsp_request_channel_close_rej(pPdu, wChannel, AccRej);
  }

  error = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);
  MemFree (pPdu);
  if (error != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CloseChannelReqResp -> %s",map_api_error(error));
  else
    H245TRACE (dwInst,4,"H245CloseChannelReqResp ->");
  InstanceUnlock(pInstance);
  return error;
} // H245CloseChannelReqResp()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SendLocalMuxTable
 *
 * DESCRIPTION
 *
 *      HRESULT H245SendLocalMuxTable (
 *                                    H245_INST_T        dwInst,
 *                                    DWORD              dwTransId,
 *                                    H245_MUX_TABLE_T  *pMuxTbl
 *                                    )
 *      Description:
 *              This routine is called to send a mux table to the remote
 *              side. The remote side can either reject or accept each mux
 *              table entry in a message. The confirm is sent back to the
 *              calling H.245 client based on the acceptance or non
 *              acceptance of each Mux table entry with H245_CONF_MUXTBL_SND.
 *
 *              This is a fairly dangerous call, since the mux table
 *              structure is a linked lise of mux table entries.  Invalid
 *              data structures could cause an access error. Example code is
 *              supplied in the appendix.
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              dwTransId       User supplied object used to identify
 *                              this request in the asynchronous
 *                              confirm to this call.
 *      pMuxTbl Mux table entry structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Callbacks:
 *              H245_CONF_MUXTBLSND
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *
 *      See Also:
 *              APPENDIX Examples
 *
 *      callback
 *
 *              H245_CONF_MUXTBL_SND
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendLocalMuxTable   (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_MUX_TABLE_T      *pMuxTable
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                 lError;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245SendLocalMuxTable <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* make sure parameters ar ok.. */
  if (!pMuxTable)
    {
      H245TRACE (dwInst,1,"H245endLocalMuxTable  -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* allocate tracker for event */
  pTracker = alloc_link_tracker (pInstance,
                                  API_SEND_MUX_T,
                                  dwTransId,
                                  API_ST_WAIT_RMTACK,
                                  API_CH_ALLOC_UNDEF,
                                  API_CH_TYPE_UNDEF,
                                  0,
                                  H245_INVALID_CHANNEL, H245_INVALID_CHANNEL,
                                  0);
  if (pTracker == NULL)
  {
    H245TRACE(dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(H245_ERROR_NOMEM));
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }

  // Allocate PDU buffer
  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
  {
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",H245_ERROR_NOMEM);
    InstanceUnlock(pInstance);
    return H245_ERROR_NOMEM;
  }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  lError = pdu_req_send_mux_table(pInstance,
                                  pPdu,
                                  pMuxTable,
                                  0,
                                  &pTracker->u.MuxEntryCount);
  if (lError == H245_ERROR_OK)
  {
    lError = FsmOutgoing(pInstance, pPdu, (DWORD_PTR)pTracker);

    /* free the list just built */
    free_mux_desc_list(pPdu->u.MltmdSystmCntrlMssg_rqst.u.multiplexEntrySend.multiplexEntryDescriptors);
  }

  /* free the pdu */
  MemFree (pPdu);

  if (lError != H245_ERROR_OK)
  {
    unlink_dealloc_tracker (pInstance, pTracker);
    H245TRACE (dwInst,1,"H245SendLocalMuxTable -> %s",map_api_error(lError));
  }
  else
    H245TRACE (dwInst,4,"H245SendLocalMuxTable -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendLocalMuxTable()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MuxTableIndResp
 *
 * DESCRIPTION
 *
 *      HRESULT H245MuxTableIndResp (
 *                                  H45_INST_T          dwInst,
 *                                  H245_ACC_REJ_MUX_T  AccRejMux,
 *                                  DWORD               Count
 *                                  )
 *      Description:
 *              This procedure is called to either accept or reject mux
 *              table entries sent up in the H245_IND_MUX_TBL indication.
 *
 *      Input
 *              dwInst                  Instance handle returned by H245Init
 *              AccRejMux               Accept Reject Mux structure
 *              Count                   number of entries in the structure
 *
 *      Call Type:
 *              Asynchronous
 *
 *      Return Values:
 *              See Errors
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_INVALID_MUXTBLENTRY
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *              H245_ERROR_INVALID_OP
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *      See Also:
 *              H245SendLocalMuxTable
 *
 *      callback
 *
 *              H245_IND_MUX_TBL
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MuxTableIndResp     (
                         H245_INST_T            dwInst,
                         H245_ACC_REJ_MUX_T     AccRejMux,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  DWORD                   ii;
  Tracker_T              *pTracker;
  MltmdSystmCntrlMssg    *pPdu;

  H245TRACE (dwInst,4,"H245MuxTableIndResp <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp  -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* look for tracker.. */
  pTracker = NULL;
  pTracker = find_tracker_by_type (pInstance, API_RECV_MUX_T, pTracker);

  /* if tracker not found.. issue invalid op */
  if (!pTracker)
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_INVALID_OP));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_OP;
    }

  ASSERT (pTracker->State == API_ST_WAIT_LCLACK);

  /* can't ack or reject more than you got */
  if ((dwCount > pTracker->u.MuxEntryCount) ||
      (dwCount > 15))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    }

  /* verify the mux table entry id's */
  for (ii=0;ii<dwCount;ii++)
    {
      if ((AccRejMux[ii].MuxEntryId > 15) ||
          (AccRejMux[ii].MuxEntryId <= 0))
        {
          H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_PARAM));
          InstanceUnlock(pInstance);
          return H245_ERROR_PARAM;
        }
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MuxTableIndResp -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* if there are any rejects in the list.. send reject */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_rej (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if there are any accepts in the list.. send accept */
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));
  if (pdu_rsp_mux_table_ack (pPdu,0,AccRejMux,dwCount) == H245_ERROR_OK)
    FsmOutgoing(pInstance, pPdu, 0);

  /* if we've acked all the entries */
  if (!(pTracker->u.MuxEntryCount -= dwCount))
    unlink_dealloc_tracker (pInstance, pTracker);

  MemFree (pPdu);
  H245TRACE (dwInst,4,"H245MuxTableIndResp -> %s",H245_ERROR_OK);
  InstanceUnlock(pInstance);
  return H245_ERROR_OK;

} // H245MuxTableIndResp()



#if 0

/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245MiscCommand
 *
 * DESCRIPTION
 *
 *      HRESULT H245MiscCommand (
 *                              H245_INST_T      dwInst,
 *                              DWORD            wChannel,
 *                              H245_MISC_T     *pMisc
 *                              )
 *      Description:
 *              Send a Misc. command to the remote side (see H245_MISC_T
 *              data Structure)
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              wChannel        Logical Channel Number
 *              pMisc           pointer to a misc. command structure
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_INVALID_CHANNEL
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *              H245_ERROR_INVALID_INST
 *
 *      callback
 *
 *              H245_IND_MISC
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT H245MiscCommand (
                         H245_INST_T            dwInst,
                         WORD                   wChannel,
                         H245_MISC_T            *pMisc
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;

  H245TRACE (dwInst,4,"H245MiscCommand <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }
  /* system should be in connected state */

  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  /* if the channel can not be found */
  if (!find_tracker_by_txchannel(pInstance, wChannel, API_CH_ALLOC_LCL) &&
      !find_tracker_by_rxchannel(pInstance, wChannel, API_CH_ALLOC_RMT))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_INVALID_CHANNEL));
      InstanceUnlock(pInstance);
      return H245_ERROR_INVALID_CHANNEL;
    }

  if (!(pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg))))
    {
      H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* budld pdu for misc command */
  pdu_cmd_misc (pPdu, pMisc, wChannel);

  lError = FsmOutgoing(pInstance, pPdu, 0);
  MemFree (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MiscCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MiscCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MiscCommand()

#endif


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntry
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntry (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntry <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }
  for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
  {
     if (pwMultiplexTableEntryNumbers[dwIndex] < 1 ||
         pwMultiplexTableEntryNumbers[dwIndex] > 15)
     {
       H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_PARAM));
       return H245_ERROR_PARAM;
     }
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMultiplexEntry_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMultiplexEntry.entryNumbers.value[dwIndex] =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntry -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntry -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntry()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryAck (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestMultiplexEntryAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.requestMultiplexEntryAck.entryNumbers.value[dwIndex] =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryAck()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMultiplexEntryReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMultiplexEntryReject (
                         H245_INST_T            dwInst,
                         const unsigned short * pwMultiplexTableEntryNumbers,
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  DWORD                           dwIndex;

  H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject <-");

  if (pwMultiplexTableEntryNumbers == NULL || dwCount < 1 || dwCount > 15)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = rqstMltplxEntryRjct_chosen;
    pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.count = (WORD)dwCount;
    for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
    {
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].multiplexTableEntryNumber =
        (MultiplexTableEntryNumber) pwMultiplexTableEntryNumbers[dwIndex];
      pPdu->u.MSCMg_rspns.u.rqstMltplxEntryRjct.rejectionDescriptions.value[dwIndex].cause.choice = RMERDs_cs_unspcfdCs_chosen;
    }

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMultiplexEntryReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMultiplexEntryReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMultiplexEntryReject()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestMode
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestMode         (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
//                         const ModeElement *    pModeElements,
//tomitowoju@intel.com
						 ModeDescription 		ModeDescriptions[],
//tomitowoju@intel.com
                         unsigned long          dwCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  RequestedModesLink              pLink;
  RequestedModesLink              pLink_First;
  DWORD                           dwIndex;
// tomitowoju@intel.com
  ULONG ulPDUsize;
// tomitowoju@intel.com

  H245TRACE (dwInst,4,"H245RequestMode <-");

//tomitowoju@intel.com							
//  if (pModeElements == NULL || dwCount == 0 || dwCount > 256)
  if (ModeDescriptions == NULL || dwCount == 0 || dwCount > 256)
//tomitowoju@intel.com							
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

//tomitowoju@intel.com							
//  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + sizeof(*pLink));
  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + (sizeof(*pLink)*(dwCount)));
//tomitowoju@intel.com
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
	USHORT usModeDescIndex =0;
	
    memset(pPdu, 0, sizeof(*pPdu));

    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = requestMode_chosen;
//tomitowoju@intel.com
//    pLink = (RequestedModesLink)(pPdu + 1);
    pLink = (RequestedModesLink)(pPdu + usModeDescIndex+1);
//tomitowoju@intel.com

//tomitowoju@intel.com
//    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes = pLink;
//tomitowoju@intel.com

//tomitowoju@intel.com
	pLink_First = pLink;
//tomitowoju@intel.com
// --> linked list of mode descriptions ... up to 1..256
//tomitowoju@intel.com
     while(usModeDescIndex<=(dwCount-1))
	 {
//tomitowoju@intel.com

			//tomitowoju@intel.com
		 //	pLink->next = NULL;
			//tomitowoju@intel.com



		//  --> number of actual mode-elements associated with this mode description
			//tomitowoju@intel.com
		//		pLink->value.count = (WORD)dwCount;
				pLink->value.count = (WORD)ModeDescriptions[usModeDescIndex].count;
			//tomitowoju@intel.com

//				for (dwIndex = 0; dwIndex < dwCount; ++dwIndex)
				for (dwIndex = 0; dwIndex < ModeDescriptions[usModeDescIndex].count; ++dwIndex)
				{
			//tomitowoju@intel.com
			//      pLink->value.value[dwIndex] = pModeElements[dwIndex];
				  pLink->value.value[dwIndex] = ModeDescriptions[usModeDescIndex].value[dwIndex];
			//tomitowoju@intel.com
				}
			//tomitowoju@intel.com
			usModeDescIndex++;
			if(usModeDescIndex<=(dwCount-1))
			{
		 	pLink->next = (RequestedModesLink)(pPdu + usModeDescIndex+1);
			pLink = pLink->next;
			pLink->next = NULL;
			}
			//tomitowoju@intel.com


//tomitowoju@intel.com
	 }
//tomitowoju@intel.com

//tomitowoju@intel.com
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.requestMode.requestedModes = pLink_First;
//tomitowoju@intel.com
	//--
	 ulPDUsize = (sizeof(*pPdu) + (sizeof(*pLink)*(dwCount)));
	//--
    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestMode -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestMode -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestMode()





/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeAck
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeAck      (
                         H245_INST_T            dwInst,
                         unsigned short         wResponse
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeAck <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeAck_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeAck.response.choice = wResponse;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeAck -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeAck -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeAck()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RequestModeReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RequestModeReject   (
                         H245_INST_T            dwInst,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RequestModeReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = requestModeReject_chosen;
    pPdu->u.MSCMg_rspns.u.requestModeReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RequestModeReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RequestModeReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RequestModeReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245RoundTripDelayRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245RoundTripDelayRequest (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245RoundTripDelayRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = roundTripDelayRequest_chosen;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245RoundTripDelayRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245RoundTripDelayRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245RoundTripDelayRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoop
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoop     (
                         H245_INST_T            dwInst,
                         DWORD_PTR              dwTransId,
                         H245_LOOP_TYPE_T       dwLoopType,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoop <-");

  if (dwLoopType < systemLoop_chosen ||
      dwLoopType > logicalChannelLoop_chosen ||
      (dwLoopType != systemLoop_chosen && wChannel == 0))
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = maintenanceLoopRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.choice = (WORD)dwLoopType;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.maintenanceLoopRequest.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, dwTransId);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoop -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoop -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoop()


/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopRelease
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopRelease (H245_INST_T         dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopRelease <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = mntnncLpOffCmmnd_chosen;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopRelease -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopRelease -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopRelease()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopAccept
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopAccept (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopAccept <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopAck_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopAck.type.u.mediaLoop = wChannel;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopAccept -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopAccept -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopAccept()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MaintenanceLoopReject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MaintenanceLoopReject (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wChannel,
                         unsigned short         wCause
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MaintenanceLoopReject <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = maintenanceLoopReject_chosen;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.type.u.mediaLoop = wChannel;
    pPdu->u.MSCMg_rspns.u.maintenanceLoopReject.cause.choice = wCause;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MaintenanceLoopReject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MaintenanceLoopReject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MaintenanceLoopReject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardObject
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardObject   (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         const unsigned short * pwObjectId,
                         unsigned long          dwObjectIdLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  POBJECTID                       pObject;

  H245TRACE (dwInst,4,"H245NonStandardObject <-");

  if (pData == NULL || dwDataLength == 0 || pwObjectId == NULL || dwObjectIdLength == 0)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
    return H245_ERROR_PARAM;
  }

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + dwObjectIdLength * sizeof(*pObject));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = object_chosen;

    // Copy the object identifier
    pObject = (POBJECTID) (pPdu + 1);
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.object = pObject;
    do
    {
      pObject->next = pObject + 1;
      pObject->value = *pwObjectId++;
      ++pObject;
    } while (--dwObjectIdLength);

    // Null terminate the linked list
    --pObject;
    pObject->next = NULL;

    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardObject -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardObject -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardObject()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245NonStandardH221
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245NonStandardH221     (
                         H245_INST_T            dwInst,
                         H245_MESSAGE_TYPE_T    MessageType,
                         const unsigned char *  pData,
                         unsigned long          dwDataLength,
                         unsigned char          byCountryCode,
                         unsigned char          byExtension,
                         unsigned short         wManufacturerCode
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245NonStandard221 <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    switch (MessageType)
    {
    case H245_MESSAGE_REQUEST:
      pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
      pPdu->u.MltmdSystmCntrlMssg_rqst.choice = RqstMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_RESPONSE:
      pPdu->choice = MSCMg_rspns_chosen;
      pPdu->u.MSCMg_rspns.choice = RspnsMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_COMMAND:
      pPdu->choice = MSCMg_cmmnd_chosen;
      pPdu->u.MSCMg_cmmnd.choice = CmmndMssg_nonStandard_chosen;
      break;

    case H245_MESSAGE_INDICATION:
      pPdu->choice = indication_chosen;
      pPdu->u.indication.choice = IndctnMssg_nonStandard_chosen;
      break;

    default:
      H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(H245_ERROR_PARAM));
      InstanceUnlock(pInstance);
      return H245_ERROR_PARAM;
    } // switch

    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.length = (WORD)dwDataLength;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.data.value  = (unsigned char *)pData;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.choice = h221NonStandard_chosen;

    // Fill in the H.221 identifier
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35CountryCode   = byCountryCode;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.t35Extension     = byExtension;
    pPdu->u.indication.u.IndctnMssg_nonStandard.nonStandardData.nonStandardIdentifier.u.h221NonStandard.manufacturerCode = wManufacturerCode;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245NonStandardH221 -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245NonStandardH221 -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245NonStandardH221



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeRequest(H245_INST_T            dwInst)
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245CommunicationModeRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = communicationModeRequest_chosen;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeRequest



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeResponse(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeTableLink      pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = cmmnctnMdRspns_chosen;
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.choice = communicationModeTable_chosen;
    pLink = (CommunicationModeTableLink)(pPdu + 1);
    pPdu->u.MSCMg_rspns.u.cmmnctnMdRspns.u.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245CommunicationModeCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245CommunicationModeCommand(
                         H245_INST_T            dwInst,
                         const H245_COMM_MODE_ENTRY_T *pTable,
                         unsigned char          byTableCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError = H245_ERROR_OK;
  CommunicationModeCommandLink    pLink;
  unsigned int                    uIndex;

  H245TRACE (dwInst,4,"H245CommunicationModeCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu) + byTableCount * sizeof(*pLink));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = communicationModeCommand_chosen;
    pLink = (CommunicationModeCommandLink)(pPdu + 1);
    pPdu->u.MSCMg_cmmnd.u.communicationModeCommand.communicationModeTable = pLink;
    for (uIndex = 0; uIndex < byTableCount; ++uIndex)
    {
      pLink[uIndex].next = &pLink[uIndex + 1];
      lError = SetupCommModeEntry(&pLink[uIndex].value, &pTable[uIndex]);
      if (lError != H245_ERROR_OK)
         break;
    }
    pLink[byTableCount - 1].next = NULL;
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245CommunicationModeCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245CommunicationModeCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245CommunicationModeCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceRequest
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceRequest   (
                         H245_INST_T            dwInst,
                         H245_CONFER_REQ_ENUM_T RequestType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceRequest <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MltmdSystmCntrlMssg_rqst_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.choice = conferenceRequest_chosen;
    pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.choice = (WORD)RequestType;
    switch (RequestType)
    {
    case dropTerminal_chosen:
    case requestTerminalID_chosen:
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.mcuNumber      = byMcuNumber;
      pPdu->u.MltmdSystmCntrlMssg_rqst.u.conferenceRequest.u.dropTerminal.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case terminalListRequest_chosen:
    case makeMeChair_chosen:
    case cancelMakeMeChair_chosen:
    case enterH243Password_chosen:
    case enterH243TerminalID_chosen:
    case enterH243ConferenceID_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceRequest -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceRequest -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceRequest()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceResponse
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceResponse  (
                         H245_INST_T            dwInst,
                         H245_CONFER_RSP_ENUM_T ResponseType,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber,
                         const unsigned char   *pOctetString,
                         unsigned char          byOctetStringLength,
                         const TerminalLabel   *pTerminalList,
                         unsigned short         wTerminalListCount
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;
  unsigned                        uIndex;

  H245TRACE (dwInst,4,"H245ConferenceResponse <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_rspns_chosen;
    pPdu->u.MSCMg_rspns.choice = conferenceResponse_chosen;
    pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = (WORD)ResponseType;
    switch (ResponseType)
    {
    case mCTerminalIDResponse_chosen:
    case terminalIDResponse_chosen:
    case conferenceIDResponse_chosen:
    case passwordResponse_chosen:
      if (pOctetString == NULL ||
          byOctetStringLength == 0 ||
          byOctetStringLength > 128)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalLabel.terminalNumber = byTerminalNumber;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.length            = byOctetStringLength;
      memcpy(pPdu->u.MSCMg_rspns.u.conferenceResponse.u.mCTerminalIDResponse.terminalID.value,
             pOctetString,
             byOctetStringLength);

      // Fall-through to next case is intentional

    case videoCommandReject_chosen:
    case terminalDropReject_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalListResponse_chosen:
      if (pTerminalList == NULL ||
          wTerminalListCount == 0 ||
          wTerminalListCount > 256)
      {
          H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(H245_ERROR_PARAM));
          return H245_ERROR_PARAM;
      }
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.count = wTerminalListCount;
      for (uIndex = 0; uIndex < wTerminalListCount; ++uIndex)
      {
        pPdu->u.MSCMg_rspns.u.conferenceResponse.u.terminalListResponse.value[uIndex] =
          pTerminalList[uIndex];
      }
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_DENIED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = deniedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case H245_RSP_GRANTED_CHAIR_TOKEN:
      pPdu->u.MSCMg_rspns.u.conferenceResponse.choice = makeMeChairResponse_chosen;
      pPdu->u.MSCMg_rspns.u.conferenceResponse.u.makeMeChairResponse.choice = grantedChairToken_chosen;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceResponse -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceResponse -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceResponse()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceCommand
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceCommand   (
                         H245_INST_T            dwInst,
                         H245_CONFER_CMD_ENUM_T CommandType,
                         H245_CHANNEL_T         Channel,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceCommand <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = conferenceCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.conferenceCommand.choice = (WORD)CommandType;
    switch (CommandType)
    {
    case brdcstMyLgclChnnl_chosen:
    case cnclBrdcstMyLgclChnnl_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.brdcstMyLgclChnnl = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case ConferenceCommand_makeTerminalBroadcaster_chosen:
    case ConferenceCommand_sendThisSource_chosen:
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.mcuNumber      = byMcuNumber;
      pPdu->u.MSCMg_cmmnd.u.conferenceCommand.u.makeTerminalBroadcaster.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case cnclMkTrmnlBrdcstr_chosen:
    case cancelSendThisSource_chosen:
    case dropConference_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceCommand -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceCommand -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceCommand()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245ConferenceIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245ConferenceIndication(
                         H245_INST_T            dwInst,
                         H245_CONFER_IND_ENUM_T IndicationType,
                         unsigned char          bySbeNumber,
                         unsigned char          byMcuNumber,
                         unsigned char          byTerminalNumber
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245ConferenceIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = conferenceIndication_chosen;
    pPdu->u.indication.u.conferenceIndication.choice = (WORD)IndicationType;
    switch (IndicationType)
    {
    case sbeNumber_chosen:
      pPdu->u.indication.u.conferenceIndication.u.sbeNumber = bySbeNumber;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case terminalNumberAssign_chosen:
    case terminalJoinedConference_chosen:
    case terminalLeftConference_chosen:
    case terminalYouAreSeeing_chosen:
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.mcuNumber      = byMcuNumber;
      pPdu->u.indication.u.conferenceIndication.u.terminalNumberAssign.terminalNumber = byTerminalNumber;

      // Fall-through to next case is intentional

    case seenByAtLeastOneOther_chosen:
    case cnclSnByAtLstOnOthr_chosen:
    case seenByAll_chosen:
    case cancelSeenByAll_chosen:
    case requestForFloor_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245ConferenceIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245ConferenceIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245ConferenceIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245UserInput
 *
 * DESCRIPTION
 *
 *      HRESULT H245UserInput (
 *                           H245_INST_T                         dwInst,
 *                           char                               *pGenString,
 *                           H245_NONSTANDARD_PARAMETER_T       *pNonStd
 *                           )
 *      Description:
 *
 *              Send a User Input indiation to the remote side.  One of the
 *              two parameters must be set (pGenString, pNonStd).  The client
 *              can either send a string or a NonStandard parameter set to the
 *              remote client.  Only one of the two parameters can contain a
 *              value.  The other is required to be NULL.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              pGenString      choice: String to be sent to remote
 *                              side in accordance with T.51 specification.
 *              pNonStd         choice: NonStandard Parameter
 *
 *      Call Type:
 *              Synchronous
 *
 *      Return Values:
 *              See Errors
 *
 *      Errors:
 *              H245_ERROR_OK
 *              H245_ERROR_NOT_CONNECTED
 *              H245_ERROR_NOMEM
 *              H245_ERROR_PARAM
 *
 *      callback
 *              H245_IND_USERINPUT
 *
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245UserInput           (
                         H245_INST_T                    dwInst,
                         const WCHAR *                        pGenString,
                         const H245_NONSTANDARD_PARAMETER_T * pNonStd
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT               lError;
  MltmdSystmCntrlMssg   *pPdu;
#if 1
  int                   nLength;
  char *                pszGeneral = NULL;
#endif

  H245TRACE (dwInst,4,"H245UserInput <-");

  /* check for valid instance handle */
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_INVALID_INST));
      return H245_ERROR_INVALID_INST;
    }

  /* system should be in connected state */
  if (pInstance->API.SystemState != APIST_Connected)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOT_CONNECTED));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOT_CONNECTED;
    }

  pPdu = (MltmdSystmCntrlMssg *)MemAlloc(sizeof(MltmdSystmCntrlMssg));
  if (pPdu == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
  memset(pPdu, 0, sizeof(MltmdSystmCntrlMssg));

  /* build PDU */
#if 1
  if (pGenString)
  {
    nLength = WideCharToMultiByte(CP_ACP,     // code page
                                  0,          // dwFlags
                                  pGenString, // Unicode string
                                  -1,         // Unicode string length (bytes)
                                  NULL,       // ASCII string
                                  0,          // max ASCII string length
                                  NULL,       // default character
                                  NULL);     // default character used
    pszGeneral = MemAlloc(nLength);
    if (pszGeneral == NULL)
    {
      H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(H245_ERROR_NOMEM));
      InstanceUnlock(pInstance);
      return H245_ERROR_NOMEM;
    }
    nLength = WideCharToMultiByte(CP_ACP,       // code page
                                  0,            // dwFlags
                                  pGenString,   // Unicode string
                                  -1,           // Unicode string length (bytes)
                                  pszGeneral,   // ASCII string
                                  nLength,      // max ASCII string length
                                  NULL,         // default character
                                  NULL);        // default character used
    lError = pdu_ind_usrinpt (pPdu, NULL, pszGeneral);
  }
  else
  {
    lError = pdu_ind_usrinpt (pPdu, pNonStd, NULL);
  }
#else
    lError = pdu_ind_usrinpt (pPdu, pNonStd, pGenString);
#endif
  if (lError == H245_ERROR_OK)
    lError = FsmOutgoing(pInstance, pPdu, 0);
#if 1
  if (pszGeneral)
    MemFree(pszGeneral);
#endif
  MemFree (pPdu);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245UserInput -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245UserInput -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245UserInput()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245FlowControl
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245FlowControl         (
                         H245_INST_T            dwInst,
                         H245_SCOPE_T           Scope,
                         H245_CHANNEL_T         Channel,       // only used if Scope is H245_SCOPE_CHANNEL_NUMBER
                         unsigned short         wResourceID,   // only used if Scope is H245_SCOPE_RESOURCE_ID
                         unsigned long          dwRestriction  // H245_NO_RESTRICTION if no restriction
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245FlowControl <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = MSCMg_cmmnd_chosen;
    pPdu->u.MSCMg_cmmnd.choice = flowControlCommand_chosen;
    pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.choice = (WORD)Scope;
    if (dwRestriction == H245_NO_RESTRICTION)
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = noRestriction_chosen;
    }
    else
    {
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.choice = maximumBitRate_chosen;
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.restriction.u.maximumBitRate = dwRestriction;
    }
    switch (Scope)
    {
    case FCCd_scp_lgclChnnlNmbr_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FCCd_scp_lgclChnnlNmbr = Channel;
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    case FlwCntrlCmmnd_scp_rsrcID_chosen:
      pPdu->u.MSCMg_cmmnd.u.flowControlCommand.scope.u.FlwCntrlCmmnd_scp_rsrcID = wResourceID;

      // Fall-through to next case

    case FCCd_scp_whlMltplx_chosen:
      lError = FsmOutgoing(pInstance, pPdu, 0);
      break;

    default:
      lError = H245_ERROR_PARAM;
    } // switch
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245FlowControl -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245FlowControl -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245FlowControl()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H223SkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H223SkewIndication  (
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H223SkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h223SkewIndication_chosen;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h223SkewIndication.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h223SkewIndication.skew                  = wSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H223SkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H223SkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H223SkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245H2250MaximumSkewIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245H2250MaximumSkewIndication(
                         H245_INST_T            dwInst,
                         H245_CHANNEL_T         wLogicalChannelNumber1,
                         H245_CHANNEL_T         wLogicalChannelNumber2,
                         unsigned short         wMaximumSkew
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = h2250MxmmSkwIndctn_chosen;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber1 = wLogicalChannelNumber1;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.logicalChannelNumber2 = wLogicalChannelNumber2;
    pPdu->u.indication.u.h2250MxmmSkwIndctn.maximumSkew           = wMaximumSkew;
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245H2250MaximumSkewIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245H2250MaximumSkewIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245H2250MaximumSkewIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245MCLocationIndication
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245MCLocationIndication(
                         H245_INST_T                dwInst,
                         const H245_TRANSPORT_ADDRESS_T * pSignalAddress
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245MCLocationIndication <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = mcLocationIndication_chosen;
    lError = SetupTransportAddress(&pPdu->u.indication.u.mcLocationIndication.signalAddress,
                                   pSignalAddress);
    if (lError == H245_ERROR_OK)
    {
      lError = FsmOutgoing(pInstance, pPdu, 0);
    }
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245MCLocationIndication -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245MCLocationIndication -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245MCLocationIndication()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245VendorIdentification
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245VendorIdentification(
                         H245_INST_T            dwInst,
                         const H245_NONSTANDID_T *pIdentifier,
                         const unsigned char   *pProductNumber,
                         unsigned char          byProductNumberLength,
                         const unsigned char   *pVersionNumber,
                         unsigned char          byVersionNumberLength
                        )
{
  register struct InstanceStruct *pInstance;
  register PDU_T *                pPdu;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245VendorIdentification <-");

  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  pPdu = (PDU_T *)MemAlloc(sizeof(*pPdu));
  if (pPdu == NULL)
  {
    lError = H245_ERROR_NOMEM;
  }
  else
  {
    memset(pPdu, 0, sizeof(*pPdu));
    pPdu->choice = indication_chosen;
    pPdu->u.indication.choice = vendorIdentification_chosen;
    pPdu->u.indication.u.vendorIdentification.bit_mask = 0;
    pPdu->u.indication.u.vendorIdentification.vendor = *pIdentifier;
    if (pProductNumber != NULL && byProductNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= productNumber_present;
      pPdu->u.indication.u.vendorIdentification.productNumber.length = byProductNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.productNumber.value,
             pProductNumber,
             byProductNumberLength);
    }
    if (pVersionNumber != NULL && byVersionNumberLength != 0)
    {
      pPdu->u.indication.u.vendorIdentification.bit_mask |= versionNumber_present;
      pPdu->u.indication.u.vendorIdentification.versionNumber.length = byVersionNumberLength;
      memcpy(pPdu->u.indication.u.vendorIdentification.versionNumber.value,
             pVersionNumber,
             byVersionNumberLength);
    }
    lError = FsmOutgoing(pInstance, pPdu, 0);
    MemFree(pPdu);
  }

  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245VendorIdentification -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245VendorIdentification -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245VendorIdentification()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 * PROCEDURE:   H245SendPDU
 *
 * DESCRIPTION
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SendPDU             (
                         H245_INST_T            dwInst,
                         PDU_T *                pPdu
                        )
{
  register struct InstanceStruct *pInstance;
  HRESULT                         lError;

  H245TRACE (dwInst,4,"H245SendPDU <-");

  // Check for valid instance handle
  pInstance = InstanceLock(dwInst);
  if (pInstance == NULL)
  {
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(H245_ERROR_INVALID_INST));
    return H245_ERROR_INVALID_INST;
  }

  lError = FsmOutgoing(pInstance, pPdu, 0);
  if (lError != H245_ERROR_OK)
    H245TRACE (dwInst,1,"H245SendPDU -> %s",map_api_error(lError));
  else
    H245TRACE (dwInst,4,"H245SendPDU -> OK");
  InstanceUnlock(pInstance);
  return lError;
} // H245SendPDU()



/*****************************************************************************
 *
 * TYPE:        H245 API
 *
 *****************************************************************************
 *
 * PROCEDURE:   H245SystemControl
 *
 * DESCRIPTION
 *
 *      HRESULT H245SystemControl
 *                              (       H245_INST_T     dwInst,
 *                                      DWORD           Request ,
 *                                      VOID            *pData
 *                              )
 *
 *      Description:
 *                      This function should not be used by clients who
 *                      normally interface to the H.245 subsystem.  It is
 *                      defined here to help during development and debug
 *                      of the H.245 subsystem.
 *
 *                      This is a roll your own.. and can do what
 *                      ever the user needs.. It's a hook to allow
 *                      IOCTL (unix) calls that can either be
 *                      passed to lower stack elements (AT&T Streams IOCTL
 *                      would be an example - :) or simply to get or put
 *                      information to the H245 SubSytem.
 *
 *      Input
 *              dwInst          Instance handle returned by H245Init
 *              Request         Requested system control
 *              pData           In the case of sending information
 *                              down to H.245 this is an input
 *                              parameter, and it's data format
 *                              is determined by the Request.
 *      output
 *              pData           In the case of retrieving information
 *                              from  H.245 this can be an output
 *                              parameter, and it's data format is
 *                              determined by the Request.  It may not
 *                              have valid data if the request is a
 *                              synchronous request. (See Request Options).
 *      Call Type:
 *
 *              Synchronous
 *
 *      Request Options:
 *
 *        H245_SYSCON_GET_STATS    Retrieves Statistics
 *                                 from H.245 subsystem
 *                                 parameter pData = &H245_SYSCON_STAT_T
 *        H245_ SYSCON_RESET_STATS Resets the statistics
 *                                 pData = NULL
 *        H245_SYS_TRACE           Set Trace Level
 *                                 pData = &DWORD (Trace Level)
 *
 *      Return Values:
 *              See Request Options
 *
 *      Errors:
 *              H245_ERROR_OK
 *
 * RETURN:
 *
 *****************************************************************************/

H245DLL HRESULT
H245SystemControl       (
                         H245_INST_T            dwInst,
                         unsigned long          dwRequest,
                         void   *               pData
                        )
{
  HRESULT                         lError;
  DWORD                           dwTemp;

  H245TRACE(dwInst,4,"H245SystemControl <-");

  if (dwRequest == H245_SYSCON_DUMP_TRACKER)
  {
    register struct InstanceStruct *pInstance = InstanceLock(dwInst);
    if (pInstance == NULL)
    {
      lError = H245_ERROR_INVALID_INST;
    }
    else
    {
      dump_tracker(pInstance);
      InstanceUnlock(pInstance);
      lError = H245_ERROR_OK;
    }
  }
  else if (pData == NULL)
  {
    lError = H245_ERROR_PARAM;
  }
  else
  {
    lError = H245_ERROR_OK;
    switch (dwRequest)
      {
      case H245_SYSCON_GET_FSM_N100:
        *((DWORD *)pData) = (DWORD) uN100;
        H245TRACE(dwInst,20,"H245SystemControl: Get N100 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T101:
        *((DWORD *)pData) = (DWORD) uT101;
        H245TRACE(dwInst,20,"H245SystemControl: Get T101 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T102:
        *((DWORD *)pData) = (DWORD) uT102;
        H245TRACE(dwInst,20,"H245SystemControl: Get T102 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T103:
        *((DWORD *)pData) = (DWORD) uT103;
        H245TRACE(dwInst,20,"H245SystemControl: Get T103 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T104:
        *((DWORD *)pData) = (DWORD) uT104;
        H245TRACE(dwInst,20,"H245SystemControl: Get T104 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T105:
        *((DWORD *)pData) = (DWORD) uT105;
        H245TRACE(dwInst,20,"H245SystemControl: Get T105 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T106:
        *((DWORD *)pData) = (DWORD) uT106;
        H245TRACE(dwInst,20,"H245SystemControl: Get T106 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T107:
        *((DWORD *)pData) = (DWORD) uT107;
        H245TRACE(dwInst,20,"H245SystemControl: Get T107 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T108:
        *((DWORD *)pData) = (DWORD) uT108;
        H245TRACE(dwInst,20,"H245SystemControl: Get T108 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_GET_FSM_T109:
        *((DWORD *)pData) = (DWORD) uT109;
        H245TRACE(dwInst,20,"H245SystemControl: Get T109 = %d",*((DWORD *)pData));
        break;

      case H245_SYSCON_SET_FSM_N100:
        dwTemp = (DWORD) uN100;
        uN100  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set N100 = %d",uN100);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T101:
        dwTemp = (DWORD) uT101;
        uT101  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T101 = %d",uT101);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T102:
        dwTemp = (DWORD) uT102;
        uT102  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T102 = %d",uT102);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T103:
        dwTemp = (DWORD) uT103;
        uT103  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T103 = %d",uT103);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T104:
        dwTemp = (DWORD) uT104;
        uT104  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T104 = %d",uT104);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T105:
        dwTemp = (DWORD) uT105;
        uT105  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T105 = %d",uT105);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T106:
        dwTemp = (DWORD) uT106;
        uT106  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T106 = %d",uT106);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T107:
        dwTemp = (DWORD) uT107;
        uT107  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T107 = %d",uT107);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T108:
        dwTemp = (DWORD) uT108;
        uT108  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T108 = %d",uT108);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_SET_FSM_T109:
        dwTemp = (DWORD) uT109;
        uT109  = (unsigned int) *((DWORD *)pData);
        H245TRACE(dwInst,20,"H245SystemControl: Set T109 = %d",uT109);
        *((DWORD *)pData) = dwTemp;
        break;

      case H245_SYSCON_TRACE_LVL:
        dwTemp = TraceLevel;
        TraceLevel = *(DWORD *)pData;
        H245TRACE(dwInst,20,"H245SystemControl: Set TraceLevel = %d",TraceLevel);
        *((DWORD *)pData) = dwTemp;
        break;

      default:
        lError = H245_ERROR_NOTIMP;
    } // switch
  } // else

  if (lError != H245_ERROR_OK)
    H245TRACE(dwInst,1,"H245SystemControl -> %s",map_api_error(lError));
  else
    H245TRACE(dwInst,4,"H245SystemControl -> OK");
  return lError;
} // H245SystemControl()

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\confman.c ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/confman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1993-1994 Intel Corporation.
 *
 *	$Revision:   1.91  $
 *	$Date:   04 Mar 1997 17:35:06  $
 *	$Author:   MANDREWS  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *		
 *
 *	Notes:
 *
 ***************************************************************************/

#include "precomp.h"

#include "apierror.h"
#include "incommon.h"
#include "callcont.h"
#include "q931.h"
#include "ccmain.h"
#include "confman.h"
#include "ccutils.h"
#include "chanman.h"
#include "callman.h"


static BOOL		bConferenceInited = FALSE;

static struct {
	PCONFERENCE			pHead;
	LOCK				Lock;
} ConferenceTable;

static struct {
	CC_HCONFERENCE		hConference;
	LOCK				Lock;
} ConferenceHandle;


CC_CONFERENCEID	 InvalidConferenceID;



HRESULT InitConferenceManager()
{
	ASSERT(bConferenceInited == FALSE);

	ConferenceTable.pHead = NULL;
	InitializeLock(&ConferenceTable.Lock);

	ConferenceHandle.hConference = CC_INVALID_HANDLE + 1;
	InitializeLock(&ConferenceHandle.Lock);

	memset(&InvalidConferenceID, 0, sizeof(InvalidConferenceID));

	bConferenceInited = TRUE;
	return CC_OK;
}



HRESULT DeInitConferenceManager()
{
PCONFERENCE	pConference;
PCONFERENCE	pNextConference;

	if (bConferenceInited == FALSE)
		return CC_OK;

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		AcquireLock(&pConference->Lock);
		pNextConference = pConference->pNextInTable;
		FreeConference(pConference);
		pConference = pNextConference;
	}

	DeleteLock(&ConferenceHandle.Lock);
	DeleteLock(&ConferenceTable.Lock);
	bConferenceInited = FALSE;
	return CC_OK;
}



HRESULT _CreateLocalH245H2250MuxCapability(
									PCONFERENCE				pConference)
{
HRESULT				status;
CC_TERMCAP			TermCap;
struct MultipointCapability_mediaDistributionCapability		RXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		TXMediaDistributionCapability;
struct MultipointCapability_mediaDistributionCapability		RXTXMediaDistributionCapability;

	ASSERT(pConference != NULL);

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	TermCap.Dir = H245_CAPDIR_LCLRXTX;
	TermCap.DataType = H245_DATA_MUX;
	TermCap.ClientType = H245_CLIENT_MUX_H2250;
	TermCap.CapId = 0;  // CapId = 0 is a special case for mux capabilities
	TermCap.Cap.H245Mux_H2250.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.maximumAudioDelayJitter = 60;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability = &RXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.receiveMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability = &TXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.transmitMultipointCapability.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multicastCapability = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.multiUniCastConference = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability = &RXTXMediaDistributionCapability;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->next = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedControl = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedControl = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedAudio = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedAudio = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedVideo = FALSE;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedVideo = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.centralizedData = NULL;
	TermCap.Cap.H245Mux_H2250.rcvAndTrnsmtMltpntCpblty.mediaDistributionCapability->value.distributedData = NULL;
	TermCap.Cap.H245Mux_H2250.mcCapability.centralizedConferenceMC = FALSE;
	TermCap.Cap.H245Mux_H2250.mcCapability.decentralizedConferenceMC = (char)pConference->bMultipointCapable;
	TermCap.Cap.H245Mux_H2250.rtcpVideoControlCapability = FALSE;
	TermCap.Cap.H245Mux_H2250.mediaPacketizationCapability.bit_mask = 0;
	TermCap.Cap.H245Mux_H2250.mediaPacketizationCapability.h261aVideoPacketization = FALSE;
	
	status = H245CopyCap(&pConference->pLocalH245H2250MuxCapability,
						 &TermCap);
					
	return status;
}



HRESULT _AddConferenceToTable(		PCONFERENCE				pConference)
{
PCONFERENCE	pCurrent;

	ASSERT(pConference != NULL);
	ASSERT(pConference->hConference != CC_INVALID_HANDLE);
	ASSERT(pConference->bInTable == FALSE);

	AcquireLock(&ConferenceTable.Lock);

	// If a valid non-zero conference ID was specified, make sure
	// there's not a duplicate in the conference table
	if (!EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		pCurrent = ConferenceTable.pHead;
		while (pCurrent != NULL) {
			if (EqualConferenceIDs(&pCurrent->ConferenceID,
				                   &pConference->ConferenceID)) {
				RelinquishLock(&ConferenceTable.Lock);
				return CC_DUPLICATE_CONFERENCE_ID;
			}
			pCurrent = pCurrent->pNextInTable;
		}
	}

	pConference->pNextInTable = ConferenceTable.pHead;
	pConference->pPrevInTable = NULL;
	if (ConferenceTable.pHead != NULL)
		ConferenceTable.pHead->pPrevInTable = pConference;
	ConferenceTable.pHead = pConference;

	pConference->bInTable = TRUE;

	RelinquishLock(&ConferenceTable.Lock);
	return CC_OK;
}



HRESULT _RemoveConferenceFromTable(	PCONFERENCE				pConference)
{
CC_HCONFERENCE	hConference;
BOOL			bTimedOut;

	ASSERT(pConference != NULL);
	ASSERT(pConference->bInTable == TRUE);

	// Caller must have a lock on the conference object;
	// in order to avoid deadlock, we must:
	//   1. unlock the conference object,
	//   2. lock the ConferenceTable,
	//   3. locate the conference object in the ConferenceTable (note that
	//      after step 2, the conference object may be deleted from the
	//      ConferenceTable by another thread),
	//   4. lock the conference object (someone else may have the lock)
	//   5. remove the conference object from the ConferenceTable,
	//   6. unlock the ConferenceTable
	//
	// The caller can now safely unlock and destroy the conference object,
	// since no other thread will be able to find the object (its been
	// removed from the ConferenceTable), and therefore no other thread will
	// be able to lock it.

	// Save the conference handle; its the only way to look up
	// the conference object in the ConferenceTable. Note that we
	// can't use pConference to find the conference object, since
	// pConference may be free'd up, and another conference object
	// allocated at the same address
	hConference = pConference->hConference;

	// step 1
	RelinquishLock(&pConference->Lock);

step2:
	// step 2
	AcquireLock(&ConferenceTable.Lock);

	// step 3
	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	if (pConference != NULL) {
		// step 4
		AcquireTimedLock(&pConference->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step2;
		}
		// step 5
		if (pConference->pPrevInTable == NULL)
			ConferenceTable.pHead = pConference->pNextInTable;
		else
			pConference->pPrevInTable->pNextInTable = pConference->pNextInTable;

		if (pConference->pNextInTable != NULL)
			pConference->pNextInTable->pPrevInTable = pConference->pPrevInTable;

		pConference->pNextInTable = NULL;
		pConference->pPrevInTable = NULL;
		pConference->bInTable = FALSE;
	}

	// step 6
	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT _MakeConferenceHandle(		PCC_HCONFERENCE			phConference)
{
	AcquireLock(&ConferenceHandle.Lock);
	*phConference = ConferenceHandle.hConference++;
	RelinquishLock(&ConferenceHandle.Lock);
	return CC_OK;
}



HRESULT AllocateTerminalNumber(		PCONFERENCE				pConference,
									H245_TERMINAL_LABEL_T	*pH245TerminalLabel)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pH245TerminalLabel != NULL);
	ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_TRUE);
	
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->TerminalNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) == 0) {
					pConference->TerminalNumberAllocation[i] |= bMask;
					pH245TerminalLabel->mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
					pH245TerminalLabel->terminalNumber = (TerminalNumber)((i * 8) + j + 1);
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more terminal numbers are available for this conference
	return CC_BAD_PARAM;
}



HRESULT FreeTerminalNumber(			PCONFERENCE				pConference,
									BYTE					bTerminalNumber)
{
unsigned	i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	if (bTerminalNumber > NUM_TERMINAL_ALLOCATION_SLOTS * 8)
		return CC_BAD_PARAM;

	--bTerminalNumber;
	i = bTerminalNumber / 8;
	j = bTerminalNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->TerminalNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
	pConference->TerminalNumberAllocation[i] &= ~bMask;
	return CC_OK;
}



HRESULT AllocateChannelNumber(		PCONFERENCE				pConference,
									WORD					*pwChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);
	ASSERT(pwChannelNumber != NULL);

	for (i = 0; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++) {
		bMask = 0x01;
		if (pConference->ChannelNumberAllocation[i] != 0xFF) {
			for (j = 0; j < 8; j++) {
				if ((pConference->ChannelNumberAllocation[i] & bMask) == 0) {
					pConference->ChannelNumberAllocation[i] |= bMask;
					*pwChannelNumber = (WORD) (((i * 8) + j) +
						               (pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber << 8));
					return CC_OK;
				}
				bMask *= 2;
			}
		}
	}
	// No more channel numbers are available for this conference
	*pwChannelNumber = 0;
	return CC_BAD_PARAM;
}



HRESULT FreeChannelNumber(			PCONFERENCE				pConference,
									WORD					wChannelNumber)
{
unsigned    i, j;
BYTE	bMask;

	ASSERT(pConference != NULL);

	wChannelNumber &= 0xFF;

	if ((wChannelNumber > NUM_CHANNEL_ALLOCATION_SLOTS * 8) ||
		(wChannelNumber == 0))
		return CC_BAD_PARAM;

	i = wChannelNumber / 8;
	j = wChannelNumber % 8;
	bMask = (BYTE)(0x01 << j);
	if ((pConference->ChannelNumberAllocation[i] & bMask) == 0)
		return CC_BAD_PARAM;
	pConference->ChannelNumberAllocation[i] &= ~bMask;
	return CC_OK;
}



HRESULT AllocAndLockConference(		PCC_HCONFERENCE			phConference,
									PCC_CONFERENCEID		pConferenceID,
									BOOL					bMultipointCapable,
									BOOL					bForceMultipointController,
									PCC_TERMCAPLIST			pLocalTermCapList,
									PCC_TERMCAPDESCRIPTORS	pLocalTermCapDescriptors,
									PCC_VENDORINFO			pVendorInfo,
									PCC_OCTETSTRING			pTerminalID,
									DWORD_PTR   			dwConferenceToken,
									CC_SESSIONTABLE_CONSTRUCTOR SessionTableConstructor,
									CC_TERMCAP_CONSTRUCTOR	TermCapConstructor,
									CC_CONFERENCE_CALLBACK	ConferenceCallback,
									PPCONFERENCE			ppConference)

{
WORD				i;
HRESULT				status;
TRISTATE			tsMultipointController;
	
	ASSERT(bConferenceInited == TRUE);

	// all parameters should have been validated by the caller
	ASSERT(phConference != NULL);
	ASSERT(pLocalTermCapList != NULL);
#ifdef _DEBUG
	if (pLocalTermCapList->wLength != 0)
		ASSERT(pLocalTermCapList->pTermCapArray != NULL);

	for (i = 0; i < pLocalTermCapList->wLength; i++)
		ASSERT(pLocalTermCapList->pTermCapArray[i] != NULL);

	if (pLocalTermCapDescriptors != NULL) {
		ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray != NULL);
		for (i = 0; i < pLocalTermCapDescriptors->wLength; i++)
			ASSERT(pLocalTermCapDescriptors->pTermCapDescriptorArray[i] != NULL);
	}
#endif
	ASSERT(pVendorInfo != NULL);
	ASSERT(SessionTableConstructor != NULL);
	ASSERT(TermCapConstructor != NULL);
	ASSERT(ConferenceCallback != NULL);
	ASSERT(ppConference != NULL);

	// set phConference now, in case we encounter an error
	*phConference = CC_INVALID_HANDLE;

	*ppConference = (PCONFERENCE)MemAlloc(sizeof(CONFERENCE));
	if (*ppConference == NULL)
		return CC_NO_MEMORY;

	if (bForceMultipointController == TRUE)
		tsMultipointController = TS_TRUE;
	else if (bMultipointCapable == TRUE)
		tsMultipointController = TS_UNKNOWN;
	else
		tsMultipointController = TS_FALSE;

	(*ppConference)->bInTable = FALSE;
	(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
	(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
 	(*ppConference)->LocalParticipantInfo.pEnqueuedRequestsForTerminalID = NULL;

	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		(*ppConference)->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	(*ppConference)->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		(*ppConference)->ChannelNumberAllocation[i] = 0;
	(*ppConference)->bMultipointCapable = bMultipointCapable;
	(*ppConference)->bForceMC = bForceMultipointController;
	(*ppConference)->SessionTableConstructor = SessionTableConstructor;
	(*ppConference)->TermCapConstructor = TermCapConstructor;
	(*ppConference)->dwConferenceToken = dwConferenceToken;
	(*ppConference)->bDeferredDelete = FALSE;
	(*ppConference)->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL
	(*ppConference)->LocalEndpointAttached = NEVER_ATTACHED;
	(*ppConference)->ConferenceCallback = ConferenceCallback;
	(*ppConference)->SaveConferenceCallback = ConferenceCallback;
	(*ppConference)->bSessionTableInternallyConstructed = FALSE;
	(*ppConference)->pSessionTable = NULL;
	(*ppConference)->pConferenceH245H2250MuxCapability = NULL;
	(*ppConference)->pConferenceTermCapList = NULL;
	(*ppConference)->pConferenceTermCapDescriptors = NULL;
	(*ppConference)->pLocalH245H2250MuxCapability = NULL;
	(*ppConference)->pLocalH245TermCapList = NULL;
	(*ppConference)->pLocalH245TermCapDescriptors = NULL;
	(*ppConference)->pEnqueuedCalls = NULL;
	(*ppConference)->pPlacedCalls = NULL;
	(*ppConference)->pEstablishedCalls = NULL;
	(*ppConference)->pVirtualCalls = NULL;
	(*ppConference)->pChannels = NULL;
	(*ppConference)->tsMultipointController = tsMultipointController;
	(*ppConference)->tsMaster = TS_UNKNOWN;
	(*ppConference)->pMultipointControllerAddr = NULL;
	(*ppConference)->ConferenceMode = UNCONNECTED_MODE;
	(*ppConference)->pVendorInfo = NULL;
	(*ppConference)->pEnqueuedRequestModeCalls = NULL;
	(*ppConference)->pNextInTable = NULL;
	(*ppConference)->pPrevInTable = NULL;
	
	if (pConferenceID == NULL) {
		pConferenceID = &InvalidConferenceID;
		(*ppConference)->bDynamicConferenceID = TRUE;
	} else
		(*ppConference)->bDynamicConferenceID = FALSE;

	(*ppConference)->ConferenceID = *pConferenceID;

	InitializeLock(&(*ppConference)->Lock);
	AcquireLock(&(*ppConference)->Lock);
	
	status = _MakeConferenceHandle(&(*ppConference)->hConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}
	
	if (pTerminalID != NULL) {
		(*ppConference)->bDynamicTerminalID = FALSE;
		(*ppConference)->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_VALID;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength =
			pTerminalID->wOctetStringLength;
		(*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString =
			(BYTE *)MemAlloc(pTerminalID->wOctetStringLength);
		if ((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString == NULL) {
			FreeConference(*ppConference);
			return CC_NO_MEMORY;
		}
		memcpy((*ppConference)->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString,
			   pTerminalID->pOctetString,
			   pTerminalID->wOctetStringLength);
	} else {
		(*ppConference)->bDynamicTerminalID = TRUE;
	}

	status = _CreateLocalH245H2250MuxCapability(*ppConference);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	// make a local copy of pTermCapList
	status = CopyH245TermCapList(&(*ppConference)->pLocalH245TermCapList,
								 pLocalTermCapList);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	// create a new descriptor list if one was not supplied
	if (pLocalTermCapDescriptors == NULL)
		status = CreateH245DefaultTermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
									                 (*ppConference)->pLocalH245TermCapList);
	else
		// make a local copy of pTermCapDescriptors
		status = CopyH245TermCapDescriptors(&(*ppConference)->pLocalH245TermCapDescriptors,
											pLocalTermCapDescriptors);

	if (status != CC_OK) {
		FreeConference(*ppConference);
		return CC_NO_MEMORY;
	}

	status = CopyVendorInfo(&((*ppConference)->pVendorInfo), pVendorInfo);
	if (status != CC_OK) {
		FreeConference(*ppConference);
		return status;
	}

	*phConference = (*ppConference)->hConference;

	// add the conference to the conference table
	status = _AddConferenceToTable(*ppConference);
	if (status != CC_OK)
		FreeConference(*ppConference);

	// CreateConferenceTermCaps() must be called after _AddConferenceToTable(),
	// since it will re-lock the conference object
	if ((*ppConference)->tsMultipointController == TS_TRUE) {
		status = CreateConferenceTermCaps(*ppConference, NULL);
		if (status != CC_OK) {
			FreeConference(*ppConference);
			return status;
		}
	}
	
	return status;
}



HRESULT RemoveCallFromConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	// The call object must have been removed from the call table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pCall->bInTable == FALSE);

	if (pCall->pPrev == NULL) {
		// the call object is either at the head of the enqueued call list,
		// the head of the placed call list, the head of the established
		// call list, the head of the virtual call list, or is detached
		// from the conference
		if (pConference->pEnqueuedCalls == pCall)
			// The call is on the enqueued call list
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			// the call is on the placed call list
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			// the call is on the established call list
			pConference->pEstablishedCalls = pCall->pNext;
		else if (pConference->pVirtualCalls == pCall)
			pConference->pVirtualCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	pCall->pNext = NULL;
	pCall->pPrev = NULL;

	return CC_OK;
}



HRESULT RemoveEnqueuedCallFromConference(
									PCONFERENCE				pConference,
									PCC_HCALL				phCall)
{
	ASSERT(pConference != NULL);
	ASSERT(phCall != NULL);

	if (pConference->pEnqueuedCalls == NULL) {
		// No enqueued calls; this is not an error, since the caller can't tell
		// whether there are any enqueued calls in this conference
		*phCall = CC_INVALID_HANDLE;
		return CC_OK;
	}

	// Move the call object from the enqueued call list to the placed
	// call list.

	// Note that another thread may have a lock on the enqueued call
	// object, and may be trying to delete it; they will first need to
	// lock the conference object (which this thread has locked), remove
	// the call object from the enqueued call list, then free the call object.
	// We are therefore safe in creating a pointer to the call object, although
	// we may not examine or change any of its contents other than hCall (read-only),
	// pNext and pPrev.
	
	*phCall = pConference->pEnqueuedCalls->hCall;
	pConference->pEnqueuedCalls = pConference->pEnqueuedCalls->pNext;
	if (pConference->pEnqueuedCalls != NULL)
		pConference->pEnqueuedCalls->pPrev = NULL;
	return CC_OK;
}



HRESULT RemoveChannelFromConference(PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
	ASSERT(pChannel != NULL);
	ASSERT(pConference != NULL);

	// The channel object must have been removed from the channel table
	// prior to removing it from the associated conference object.
	// This assures us that no other thread is waiting for a lock on it.
	ASSERT(pChannel->bInTable == FALSE);

	if (pChannel->pPrev == NULL) {
		// the channel object is at the head of the channel list,
		// or has been detached from the conference
		if (pConference->pChannels == pChannel)
			pConference->pChannels = pChannel->pNext;
	} else
		pChannel->pPrev->pNext = pChannel->pNext;

	if (pChannel->pNext != NULL)
		pChannel->pNext->pPrev = pChannel->pPrev;

	pChannel->pNext = NULL;
	pChannel->pPrev = NULL;

	return CC_OK;
}



HRESULT AddEnqueuedCallToConference(PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT(EqualConferenceIDs(&pCall->ConferenceID, &InvalidConferenceID));
	ASSERT(EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID));
	ASSERT(pConference->pPlacedCalls != NULL);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pEnqueuedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEnqueuedCalls != NULL) {
		ASSERT(pConference->pEnqueuedCalls->pPrev == NULL);
		pConference->pEnqueuedCalls->pPrev = pCall;
	}
	pConference->pEnqueuedCalls = pCall;
	return CC_OK;
}



HRESULT AddPlacedCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);

	if (EqualConferenceIDs(&pConference->ConferenceID,
			               &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		if (pConference->pPlacedCalls != NULL)
			return CC_BAD_PARAM;
		else
			pConference->ConferenceID = pCall->ConferenceID;
	} else
		if (!EqualConferenceIDs(&pConference->ConferenceID,
			                    &pCall->ConferenceID))
			return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;

	// Now link pCall into the placed call list
	pCall->pNext = pConference->pPlacedCalls;
	pCall->pPrev = NULL;
	if (pConference->pPlacedCalls != NULL) {
		ASSERT(pConference->pPlacedCalls->pPrev == NULL);
		pConference->pPlacedCalls->pPrev = pCall;
	}
	pConference->pPlacedCalls = pCall;
	return CC_OK;
}



HRESULT AddEstablishedCallToConference(
									PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	ASSERT((EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) ||
		   (EqualConferenceIDs(&pCall->ConferenceID, &pConference->ConferenceID)));

	if (EqualConferenceIDs(&pConference->ConferenceID, &InvalidConferenceID)) {
		// If a conference ID has not been assigned, but there are
		// placed or enqueued calls on the conference, the conference ID
		// will be assigned by a callee when the first of these calls completes.
		// Since pCall has an assigned conference ID (which will differ from
		// the ID to be assigned to this conference), we cannot assign pCall
		// to this conference.
		ASSERT(pConference->pEstablishedCalls == NULL);
		pConference->ConferenceID = pCall->ConferenceID;
	} else if (!EqualConferenceIDs(&pConference->ConferenceID, &pCall->ConferenceID))
		return CC_BAD_PARAM;

	pCall->hConference = pConference->hConference;

	// Unlink pCall from pConference, if necessary
	if (pCall->pPrev == NULL) {
		// pCall is at the head of either the enqueued call list,
		// the placed call list, or the established call list, or
		// is not yet associated with the conference object
		if (pConference->pEnqueuedCalls == pCall)
			pConference->pEnqueuedCalls = pCall->pNext;
		else if (pConference->pPlacedCalls == pCall)
			pConference->pPlacedCalls = pCall->pNext;
		else if (pConference->pEstablishedCalls == pCall)
			pConference->pEstablishedCalls = pCall->pNext;
	} else
		pCall->pPrev->pNext = pCall->pNext;

	if (pCall->pNext != NULL)
		pCall->pNext->pPrev = pCall->pPrev;
	
	// Now link pCall into the established call list
	pCall->pNext = pConference->pEstablishedCalls;
	pCall->pPrev = NULL;
	if (pConference->pEstablishedCalls != NULL) {
		ASSERT(pConference->pEstablishedCalls->pPrev == NULL);
		pConference->pEstablishedCalls->pPrev = pCall;
	}
	pConference->pEstablishedCalls = pCall;
	return CC_OK;
}



HRESULT AddVirtualCallToConference(	PCALL					pCall,
									PCONFERENCE				pConference)
{
	ASSERT(pCall != NULL);
	ASSERT(pConference != NULL);
	// this is a bogus ASSERT --- ASSERT(pConference->ConferenceMode == MULTIPOINT_MODE);
	ASSERT(pConference->tsMultipointController == TS_FALSE);
	// Call cannot already be associated with the conference
	ASSERT(pCall->pNext == NULL);
	ASSERT(pCall->pPrev == NULL);

	pCall->hConference = pConference->hConference;

	pCall->pNext = pConference->pVirtualCalls;
	pCall->pPrev = NULL;
	if (pConference->pVirtualCalls != NULL) {
		ASSERT(pConference->pVirtualCalls->pPrev == NULL);
		pConference->pVirtualCalls->pPrev = pCall;
	}
	pConference->pVirtualCalls = pCall;
	return CC_OK;
}



HRESULT AddChannelToConference(		PCHANNEL				pChannel,
									PCONFERENCE				pConference)
{
PPCHANNEL	ppChannel;

	ASSERT(pChannel != NULL);
	ASSERT((pChannel->bChannelType == TX_CHANNEL) ||
		   (pChannel->bChannelType == RX_CHANNEL) ||
		   (pChannel->bChannelType == TXRX_CHANNEL) ||
		   (pChannel->bChannelType == PROXY_CHANNEL));
	ASSERT(pConference != NULL);
	ASSERT(pChannel->hConference == pConference->hConference);
	ASSERT(pChannel->pNext == NULL);
	ASSERT(pChannel->pPrev == NULL);
	ASSERT(pConference->ConferenceMode != UNCONNECTED_MODE);

	if (pConference->pEstablishedCalls == NULL)
		// Can't open a channel unless we have at least one established call
		return CC_BAD_PARAM;

	ppChannel = &pConference->pChannels;

	pChannel->pNext = *ppChannel;
	pChannel->pPrev = NULL;
	if (*ppChannel != NULL) {
		ASSERT((*ppChannel)->pPrev == NULL);
		(*ppChannel)->pPrev = pChannel;
	}
	*ppChannel = pChannel;
	if (pConference->ConferenceMode == POINT_TO_POINT_MODE)
		pChannel->bMultipointChannel = FALSE;
	else
		pChannel->bMultipointChannel = TRUE;
	return CC_OK;
}



// Caller must have a lock on the conference object
// There must be no calls on this conference object
// (previous calls must have been cleared by calling Hangup())
HRESULT FreeConference(			PCONFERENCE				pConference)
{
CC_HCONFERENCE		hConference;
PCALL				pVirtualCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
PCHANNEL			pChannel;

	ASSERT(pConference != NULL);
	ASSERT(pConference->pEnqueuedCalls == NULL);
	ASSERT(pConference->pPlacedCalls == NULL);
	ASSERT(pConference->pEstablishedCalls == NULL);
	
	// caller must have a lock on the conference object,
	// so there's no need to re-lock it
	
	hConference = pConference->hConference;

	if (pConference->bInTable == TRUE)
		if (_RemoveConferenceFromTable(pConference) == CC_BAD_PARAM)
			// the conference object was deleted by another thread,
			// so just return CC_OK
			return CC_OK;

	if (pConference->pLocalH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pLocalH245H2250MuxCapability);

	// free up the LocalTermCapList elements
	DestroyH245TermCapList(&pConference->pLocalH245TermCapList);

	// free up the local terminal capability descriptors
	DestroyH245TermCapDescriptors(&pConference->pLocalH245TermCapDescriptors);

	if (pConference->pMultipointControllerAddr != NULL)
		MemFree(pConference->pMultipointControllerAddr);

	if (pConference->pVendorInfo != NULL)
		FreeVendorInfo(pConference->pVendorInfo);

	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);

	if (pConference->pConferenceH245H2250MuxCapability != NULL)
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);

	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);

	if (pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL)
	{
		MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	}
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, VIRTUAL_CALL);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pVirtualCall) == CC_OK)
			FreeCall(pVirtualCall);
	if (CallList != NULL)
		MemFree(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
		FreeChannel(pChannel);
	if (ChannelList != NULL)
		MemFree(ChannelList);

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	// since the conference object has been removed from the ConferenceTable,
	// no other thread will be able to find the conference object and obtain
	// a lock, so its safe to unlock the conference object and delete it here
	RelinquishLock(&pConference->Lock);
	DeleteLock(&pConference->Lock);
	MemFree(pConference);
	return CC_OK;
}



HRESULT LockConference(				CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceEx(			CC_HCONFERENCE			hConference,
									PPCONFERENCE			ppConference,
									TRISTATE				tsDeferredDelete)
{
BOOL	bTimedOut;

	ASSERT(hConference != CC_INVALID_HANDLE);
	ASSERT(ppConference != NULL);

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) && ((*ppConference)->hConference != hConference))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
		if (tsDeferredDelete == TS_TRUE) {
			if ((*ppConference)->bDeferredDelete != TRUE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		} else if (tsDeferredDelete == TS_FALSE) {
			if ((*ppConference)->bDeferredDelete != FALSE) {
				RelinquishLock(&(*ppConference)->Lock);
				*ppConference = NULL;
			}
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT ValidateConference(			CC_HCONFERENCE			hConference)
{
PCONFERENCE	pConference;

	ASSERT(hConference != CC_INVALID_HANDLE);

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while ((pConference != NULL) && (pConference->hConference != hConference))
		pConference = pConference->pNextInTable;

	RelinquishLock(&ConferenceTable.Lock);

	if (pConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT LockConferenceID(			PCC_CONFERENCEID		pConferenceID,
									PPCONFERENCE			ppConference)
{
BOOL	bTimedOut;

	ASSERT(!EqualConferenceIDs(pConferenceID, &InvalidConferenceID));
	ASSERT(ppConference != NULL);
	// There may be many conference objects in the table with unassigned
	// conference IDs (ConferenceID = InvalidConferenceID).  The caller may
	// never ask us to search for an unassigned conference ID.

step1:
	AcquireLock(&ConferenceTable.Lock);

	*ppConference = ConferenceTable.pHead;
	while ((*ppConference != NULL) &&
		   (!EqualConferenceIDs(&(*ppConference)->ConferenceID, pConferenceID)))
		*ppConference = (*ppConference)->pNextInTable;

	if (*ppConference != NULL) {
		AcquireTimedLock(&(*ppConference)->Lock,10,&bTimedOut);
		if (bTimedOut) {
			RelinquishLock(&ConferenceTable.Lock);
			Sleep(0);
			goto step1;
		}
	}

	RelinquishLock(&ConferenceTable.Lock);

	if (*ppConference == NULL)
		return CC_BAD_PARAM;
	else
		return CC_OK;
}



HRESULT FindChannelInConference(	WORD					wChannel,
									BOOL					bLocalChannel,
									BYTE					bChannelType,
									CC_HCALL				hCall,
									PCC_HCHANNEL			phChannel,
									PCONFERENCE				pConference)
{
PCHANNEL	pChannel;
WORD		wChannelNumber;

	ASSERT(wChannel != 0);
	ASSERT(phChannel != NULL);
	ASSERT(pConference != NULL);

	*phChannel = CC_INVALID_HANDLE;

	pChannel = pConference->pChannels;
	while (pChannel != NULL) {
		if (bLocalChannel)
			wChannelNumber = pChannel->wLocalChannelNumber;
		else
			wChannelNumber = pChannel->wRemoteChannelNumber;
		if ((wChannelNumber == wChannel) &&
		    ((pChannel->bChannelType & bChannelType) != 0) &&
		    ((hCall == CC_INVALID_HANDLE) ||
		    (pChannel->hCall == hCall)))
			break;
		pChannel = pChannel->pNext;
	}
	if (pChannel == NULL)
		return CC_BAD_PARAM;
	*phChannel = pChannel->hChannel;
	return CC_OK;
}



HRESULT EnumerateConferences(		PWORD					pwNumConferences,
									CC_HCONFERENCE			ConferenceList[])
{
WORD		wIndexLimit;
PCONFERENCE	pConference;


	if ((*pwNumConferences != 0) && (ConferenceList == NULL))
		return CC_BAD_PARAM;
	if ((*pwNumConferences == 0) && (ConferenceList != NULL))
		return CC_BAD_PARAM;

	wIndexLimit = *pwNumConferences;
	*pwNumConferences = 0;

	AcquireLock(&ConferenceTable.Lock);

	pConference = ConferenceTable.pHead;
	while (pConference != NULL) {
		if (*pwNumConferences < wIndexLimit)
			ConferenceList[*pwNumConferences] = pConference->hConference;
		(*pwNumConferences)++;
		pConference = pConference->pNextInTable;
	}

	RelinquishLock(&ConferenceTable.Lock);

	return CC_OK;
}



HRESULT EnumerateCallsInConference(	WORD					*pwNumCalls,
									PCC_HCALL				pCallList[],
									PCONFERENCE				pConference,
									BYTE					bCallType)
{
WORD	i;
PCALL	pCall;

	ASSERT(pwNumCalls != NULL);
	ASSERT(pConference != NULL);

	*pwNumCalls = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pwNumCalls)++;
			pCall = pCall->pNext;
		}
	}

	if (pCallList == NULL)
		return CC_OK;

	if (*pwNumCalls == 0) {
		*pCallList = NULL;
		return CC_OK;
	}

	*pCallList = (PCC_HCALL)MemAlloc(sizeof(CC_HCALL) * (*pwNumCalls));
	if (*pCallList == NULL)
		return CC_NO_MEMORY;

	i = 0;

	if (bCallType & ENQUEUED_CALL) {
		pCall = pConference->pEnqueuedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & PLACED_CALL) {
		pCall = pConference->pPlacedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & ESTABLISHED_CALL) {
		pCall = pConference->pEstablishedCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}

	if (bCallType & VIRTUAL_CALL) {
		pCall = pConference->pVirtualCalls;
		while (pCall != NULL) {
			(*pCallList)[i] = pCall->hCall;
			i++;
			pCall = pCall->pNext;
		}
	}
	return CC_OK;
}



HRESULT EnumerateChannelsInConference(
									WORD					*pwNumChannels,
									PCC_HCHANNEL			pChannelList[],
									PCONFERENCE				pConference,
									BYTE					bChannelType)
{
WORD		i;
PCHANNEL	pChannel;

	ASSERT(pwNumChannels != NULL);
	ASSERT(pConference != NULL);

	*pwNumChannels = 0;

	pChannel = pConference->pChannels;

	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType)
			(*pwNumChannels)++;
		pChannel = pChannel->pNext;
	}

	if (pChannelList == NULL)
		return CC_OK;

	if (*pwNumChannels == 0) {
		*pChannelList = NULL;
		return CC_OK;
	}

	*pChannelList = (PCC_HCHANNEL)MemAlloc(sizeof(CC_HCHANNEL) * (*pwNumChannels));
	if (*pChannelList == NULL)
		return CC_NO_MEMORY;

	i = 0;
	pChannel = pConference->pChannels;
		
	while (pChannel != NULL) {
		if (pChannel->bChannelType & bChannelType) {
			(*pChannelList)[i] = pChannel->hChannel;
			i++;
		}
		pChannel = pChannel->pNext;
	}

	return CC_OK;
}



HRESULT EnumerateTerminalLabelsInConference(
									WORD					*pwNumTerminalLabels,
									H245_TERMINAL_LABEL_T   *pH245TerminalLabelList[],
									PCONFERENCE				pConference)
{
WORD	i, j;
WORD	wIndex;
BYTE	bMask;

	ASSERT(pwNumTerminalLabels != NULL);
	ASSERT(pConference != NULL);

	// First count the number of known terminals
	*pwNumTerminalLabels = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0)
					(*pwNumTerminalLabels)++;
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED)
		(*pwNumTerminalLabels)++;

	if (pH245TerminalLabelList == NULL)
		return CC_OK;

	if (*pwNumTerminalLabels == 0)
		*pH245TerminalLabelList = NULL;

	*pH245TerminalLabelList = (H245_TERMINAL_LABEL_T *)MemAlloc(sizeof(H245_TERMINAL_LABEL_T) *
												       (*pwNumTerminalLabels));
	if (*pH245TerminalLabelList == NULL)
		return CC_NO_MEMORY;

	wIndex = 0;
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++) {
		if (pConference->TerminalNumberAllocation[i] != 0) {
			bMask = 0x01;
			for (j = 0; j < 8; j++) {
				if ((pConference->TerminalNumberAllocation[i] & bMask) != 0) {
					(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
					(*pH245TerminalLabelList)[wIndex].terminalNumber = (TerminalNumber) ((i * 8) + j + 1);
					wIndex++;
				}	
				bMask *= 2;
			}
		}
	}
	if (pConference->LocalEndpointAttached == ATTACHED) {
		(*pH245TerminalLabelList)[wIndex].mcuNumber = pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber;
		(*pH245TerminalLabelList)[wIndex].terminalNumber = 0;
	}
	return CC_OK;
}



HRESULT UnlockConference(			PCONFERENCE				pConference)
{
	ASSERT(pConference != NULL);

	RelinquishLock(&pConference->Lock);
	return CC_OK;
}



HRESULT AsynchronousDestroyConference(
									CC_HCONFERENCE			hConference,
									BOOL					bAutoAccept)
{
HRESULT			status;
PCONFERENCE		pConference;
WORD			wNumCalls;
WORD			wNumChannels;
WORD			i;
PCHANNEL		pChannel;
PCC_HCHANNEL	ChannelList;

	status = LockConference(hConference, &pConference);
	if (status != CC_OK)
		return status;

	status = EnumerateCallsInConference(&wNumCalls, NULL, pConference, REAL_CALLS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// This is an illegal call if:
	// 1. The local endpoint is currently attached;
	// 2. The local endpoint has never been attached, but is in the
	// process of placing a call
	if ((pConference->LocalEndpointAttached == ATTACHED) ||
	    ((pConference->LocalEndpointAttached == NEVER_ATTACHED) &&
		 (wNumCalls > 0))) {
		UnlockConference(pConference);
		return CC_BAD_PARAM;
	}

	pConference->ConferenceCallback = NULL;

	// can't destroy a conference if there are active calls
	if (wNumCalls != 0) {
		pConference->bDeferredDelete = TRUE;
		pConference->bAutoAccept = bAutoAccept;
		UnlockConference(pConference);
		return CC_OK;
	}

	status = EnumerateChannelsInConference(&wNumChannels,
		                                   &ChannelList,
										   pConference,
										   ALL_CHANNELS);
	if (status != CC_OK) {
		UnlockConference(pConference);
		return status;
	}

	// free all the channels
	for (i = 0; i < wNumChannels; i++) {
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			// Notice that since we're going to hangup, we don't need to
			// close any channels
			FreeChannel(pChannel);
	}

	if (ChannelList != NULL)
		MemFree(ChannelList);

	FreeConference(pConference);
	
	return CC_OK;
}



HRESULT FindPeerParticipantInfo(	H245_TERMINAL_LABEL_T	H245TerminalLabel,
									PCONFERENCE				pConference,
									BYTE					bCallType,
									PCALL					*ppCall)
{
WORD		wNumCalls;
PCC_HCALL	CallList;
WORD		i;
HRESULT		status;

	ASSERT(pConference != NULL);
	ASSERT(ppCall != NULL);

	status = EnumerateCallsInConference(&wNumCalls,
										&CallList,
										pConference,
										bCallType);
	if (status != CC_OK)
		return status;

	for (i = 0; i < wNumCalls; i++) {
		if (LockCall(CallList[i], ppCall) == CC_OK) {
			if ((*ppCall)->pPeerParticipantInfo != NULL)
				if (((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bMCUNumber ==
					 H245TerminalLabel.mcuNumber) &&
					((*ppCall)->pPeerParticipantInfo->ParticipantInfo.TerminalLabel.bTerminalNumber ==
					 H245TerminalLabel.terminalNumber)) {
						MemFree(CallList);
						return CC_OK;
					}
			UnlockCall(*ppCall);
		}
	}
	if (CallList != NULL)
		MemFree(CallList);
	*ppCall = NULL;
	return CC_BAD_PARAM;
}



HRESULT ReInitializeConference(		PCONFERENCE				pConference)
{
PCALL				pCall;
WORD				wNumCalls;
WORD				i;
PCC_HCALL			CallList;
PCHANNEL			pChannel;
WORD				wNumChannels;
PCC_HCHANNEL		ChannelList;
HRESULT				status;

	ASSERT(pConference != NULL);

	if (pConference->bDynamicConferenceID == TRUE)
		pConference->ConferenceID = InvalidConferenceID;
	
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bMCUNumber = 1;
	pConference->LocalParticipantInfo.ParticipantInfo.TerminalLabel.bTerminalNumber = 255;
	if (pConference->bDynamicTerminalID == TRUE) {
		pConference->LocalParticipantInfo.TerminalIDState = TERMINAL_ID_INVALID;
		if(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString != NULL)
		{
		    MemFree(pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString);
    		pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.pOctetString = NULL;
	    	pConference->LocalParticipantInfo.ParticipantInfo.TerminalID.wOctetStringLength = 0;
	    }
	}
	while (DequeueRequest(&pConference->LocalParticipantInfo.pEnqueuedRequestsForTerminalID, NULL) == CC_OK);
	for (i = 0; i < NUM_TERMINAL_ALLOCATION_SLOTS; i++)
		pConference->TerminalNumberAllocation[i] = 0;
	// Channel 0 is reserved for the H.245 control channel
	pConference->ChannelNumberAllocation[0] = 0x01;
	for (i = 1; i < NUM_CHANNEL_ALLOCATION_SLOTS; i++)
		pConference->ChannelNumberAllocation[i] = 0;
	pConference->bDeferredDelete = FALSE;
	pConference->bAutoAccept = FALSE;  // ignored unless ConferenceCallback is NULL	
	pConference->LocalEndpointAttached = NEVER_ATTACHED;
	if (pConference->pSessionTable != NULL)
		FreeConferenceSessionTable(pConference);
	_CreateLocalH245H2250MuxCapability(pConference);
	if (pConference->pConferenceH245H2250MuxCapability != NULL) {
		H245FreeCap(pConference->pConferenceH245H2250MuxCapability);
		pConference->pConferenceH245H2250MuxCapability = NULL;
	}
	if ((pConference->pConferenceTermCapList != NULL) ||
		(pConference->pConferenceTermCapDescriptors != NULL))
		FreeConferenceTermCaps(pConference);
	pConference->bSessionTableInternallyConstructed = FALSE;
	pConference->ConferenceCallback = pConference->SaveConferenceCallback;

	EnumerateCallsInConference(&wNumCalls, &CallList, pConference, ALL_CALLS);
	for (i = 0; i < wNumCalls; i++)
		if (LockCall(CallList[i], &pCall) == CC_OK)
			FreeCall(pCall);
	if (CallList != NULL)
		MemFree(CallList);

	EnumerateChannelsInConference(&wNumChannels, &ChannelList, pConference, ALL_CHANNELS);
	for (i = 0; i < wNumChannels; i++)
		if (LockChannel(ChannelList[i], &pChannel) == CC_OK)
			FreeChannel(pChannel);
	if (ChannelList != NULL)
		MemFree(ChannelList);

	if (pConference->bForceMC == TRUE)
		pConference->tsMultipointController = TS_TRUE;
	else if (pConference->bMultipointCapable == TRUE)
		pConference->tsMultipointController = TS_UNKNOWN;
	else
		pConference->tsMultipointController = TS_FALSE;
	pConference->tsMaster = TS_UNKNOWN;
	pConference->ConferenceMode = UNCONNECTED_MODE;
	if (pConference->pMultipointControllerAddr != NULL) {
		MemFree(pConference->pMultipointControllerAddr);
		pConference->pMultipointControllerAddr = NULL;
	}

	while (DequeueRequest(&pConference->pEnqueuedRequestModeCalls, NULL) == CC_OK);

	if (pConference->tsMultipointController == TS_TRUE)
		status = CreateConferenceTermCaps(pConference, NULL);
	else
		status = CC_OK;

	return status;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\cpls.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************/

#ifndef __CPLS_H
#define __CPLS_H

#include <limits.h>

#ifdef WIN32
    #include <precomp.h>
	#include "port32.h"
#endif

#ifdef _WINDOWS
	#ifndef _MSWINDOWS_
		#define _MSWINDOWS_
	#endif
#endif

typedef int HLOG;                          

#ifndef FALSE
	#define FALSE   0
#endif

#ifndef TRUE
	#define TRUE    1
#endif
#ifdef WIN32
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT __declspec(dllexport)
		#define CPLS_EXPORT __declspec(dllexport)
	#else
		#define CPLS_FAREXPORT __declspec(dllimport)
		#define CPLS_EXPORT __declspec(dllimport)
	#endif
	#ifndef EXPORT
		#define EXPORT
	#endif	// EXPORT
#elif _MSWINDOWS_
	#ifndef CALLBACK
		#define CALLBACK _far _pascal
	#endif
	#ifdef BUILDING_CPLS_DLL
		#define CPLS_FAREXPORT _far _export _pascal
		#define CPLS_EXPORT _export
	#else
		#define CPLS_FAREXPORT _far _pascal
		#define CPLS_EXPORT
	#endif
	#ifndef EXPORT
		#define EXPORT _export
	#endif	// EXPORT
	#ifndef FAR
		#define FAR _far
	#endif
#else    
	#ifndef CALLBACK
		#define CALLBACK      
	#endif
	#define CPLS_FAREXPORT
	#ifndef EXPORT
		#define EXPORT  
	#endif
	#ifndef FAR
		#define FAR
	#endif
#endif  // _MSWINDOWS_  


typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef const char FAR* CPLProtocol;
typedef int CPLProtocolID;

#define CONFIG_FILENAME "CPLS.INI"    // internal use only

// Pre-defined event and event category constants.
//
#define String_Event USHRT_MAX
#define Binary_Event USHRT_MAX-1

#define String_Category USHRT_MAX
#define Binary_Category USHRT_MAX-1

#ifdef __cplusplus      
	class CProtocolLog;
	class CProtocolEvent;
	typedef CProtocolEvent FAR* (CALLBACK *CPLEventGenesisProc)( 
															BYTE FAR* pObject,              // in
															CProtocolLog FAR* pSourceLog,   // in
															BOOL bCopyObject );             // in
extern "C"{

// This first one is only for C++ clients...
void CPLS_FAREXPORT CPLRegisterEventGenesisProc( CPLProtocolID ProtocolID, CPLEventGenesisProc pfnGenesisProc );

#endif  // __cplusplus

// Possible file mode values for CPLOpen().
//
#define CPLS_CREATE 0		// Will overwrite an existing file.
#define CPLS_APPEND 1		// Will append to an existing file, or create a new one.

/////////////////////////////////////////////////////////////////////////////
// 					PROTOCOL LOGGING FUNCTIONS
//
// Here is the sequence of functions to call for use of a protocol logger:
//		1) CPLInitialize() or CPLINTInitialize()
//		2) CPLOpen()
//		3) CPLOutput*() or CPLINTOutput*() -- repeat as necessary
//		4) CPLClose()
//		5) CPLUninitialize()
//
// CPLInitialize() - Creates a protocol logger.
// CPLINTInitialize() - The version of CPLInitialize() which must be called
//		by clients which will be calling the CPLINTOuptut*() functions within
//		interrupt context.  CPLINTInitialize may not be called within
//		interrupt context.
// CPLUninitialize() - Releases a protocol logger.  This must be called for
//		every initialized logger before shutdown in order to free associated
//		memory.
// CPLOpen() - Associates a protocol logger with a file (output stream).
// CPLClose() - Releases a logger's usage of a stream.  This function does
//		not block.  A "close" event is placed on the event queue of the
//		stream.  Release of the stream occurs when this "close" event is
//		serviced.
// CPLOutputDebug() - 
// CPLINTOutputDebug() - The version of CPLOutputDebug() safely callable
//		within interrupt context.
// CPLOutputAscii() - 
// CPLINTOutputAscii() - The version of CPLOutputAscii() safely callable
//		within interrupt context.
// CPLOutput() - 
// CPLINTOutput() - The version of CPLOutput() safely callable
//		within interrupt context.
// CPLFlush() - Flushes all events to the stream of the specified logger.
//		Blocks until the flush is complete.
// CPLINTFlush() -  The version of CPLFlush() safely callable within
//		interrupt context.  This version does not block.  A "flush" message
//		is sent to CPLS.  The flush occurs when this flush message is
//		serviced.
// CPLFlushAndClose() -
// CPLEnable() - Enables or disables protocol logging at runtime.
// CPLEnableAsync() - Sets synchronous or asynchronous logging output mode.
//		CURRENTLY NOT SUPPORTED.
// CPLLogAscii() - 
// CPLINTLogAscii() - The version of CPLLogAscii() safely callable
//		within interrupt context.
//
// Only these functions may be called from within interrupt context:
//		CPLINTOutputDebug()
//		CPLINTOutputAscii()
//		CPLINTOutput()
//		CPLINTFlush()
//		CPLEnable()
//		CPLINTLogAscii()
/////////////////////////////////////////////////////////////////////////////
CPLProtocolID CPLS_FAREXPORT WINAPI CPLInitialize( CPLProtocol Protocol );

CPLProtocolID CPLS_FAREXPORT CPLINTInitialize( CPLProtocol Protocol );

int  CPLS_FAREXPORT WINAPI CPLUninitialize( HLOG hlog );

HLOG CPLS_FAREXPORT WINAPI CPLOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
HLOG CPLS_FAREXPORT CPLINTOpen( CPLProtocolID ProtocolID, 
							const char FAR* szName, 
							int FileMode );
int  CPLS_FAREXPORT WINAPI CPLClose( HLOG hLog );

int  CPLS_FAREXPORT CPLOutputDebug( HLOG hLog, 
							const char FAR* szString );
int  CPLS_FAREXPORT CPLINTOutputDebug( HLOG hLog, 
							const char FAR* szString );

int  CPLS_FAREXPORT CPLOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutputAscii( HLOG hLog, 
							WORD EventID, 
							const char FAR* szEvent, 
							BYTE FAR* pData, 
							int nDataBytes, 
							WORD EventCategory, 
							unsigned long UserData );

int  CPLS_FAREXPORT WINAPI CPLOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );
int  CPLS_FAREXPORT CPLINTOutput( HLOG hLog, 
							BYTE FAR* pData, 
							int nDataBytes,
							unsigned long UserData );

int  CPLS_FAREXPORT CPLFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLINTFlush( HLOG hLog );
int  CPLS_FAREXPORT CPLFlushAndClose( HLOG hLog );

void CPLS_FAREXPORT CPLEnable( BOOL bEnable );
//void CPLS_FAREXPORT CPLEnableAsync( BOOL bEnable );

#ifdef __cplusplus
};      // extern "C"
#endif  // __cplusplus

#define CPLLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )

#define CPLINTLogAscii( hLog, \
				EventID, \
				pData, \
				nDataBytes, \
				EventCategory, \
				UserData ) \
		CPLINTOutputAscii( hLog, EventID, #EventID, pData, nDataBytes, EventCategory, UserData )
		
#endif  // __CPLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dcall.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dcall.cpv  $
*																		*
*	$Revision:   1.12  $
*	$Date:   25 Feb 1997 11:46:24  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dcall.cpv  $
// 
//    Rev 1.12   25 Feb 1997 11:46:24   CHULME
// Memset CallInfo structure to zero to avoid unwanted data
// 
//    Rev 1.11   17 Jan 1997 15:53:50   CHULME
// Put debug variables on conditional compile to avoid release warnings
// 
//    Rev 1.10   17 Jan 1997 09:01:22   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.9   10 Jan 1997 17:42:04   CHULME
// Added CRV and conferenceID to CallReturnInfo structure
// 
//    Rev 1.8   10 Jan 1997 16:13:36   CHULME
// Removed MFC dependency
// 
//    Rev 1.7   20 Dec 1996 16:38:58   CHULME
// Removed extraneous debug statements
// 
//    Rev 1.6   20 Dec 1996 14:08:32   CHULME
// Swapped send and recv addresses in infoRequestResponse
// 
//    Rev 1.5   19 Dec 1996 19:11:54   CHULME
// Set originator bit in IRR
// 
//    Rev 1.4   19 Dec 1996 17:59:52   CHULME
// Use dest addr from ACF in IRR if call made with just Alias
// 
//    Rev 1.3   17 Dec 1996 18:22:24   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.2   02 Dec 1996 23:50:52   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:21:20   CHULME
// Added VCS log to the header
*************************************************************************/

// dcall.cpp : Provides the implementation for the CCall class
//

#include "precomp.h"

#include <process.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"
#include <objbase.h>
#include "iras.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCall construction

CCall::CCall()
{
	// ABSTRACT:  The constructor for the CCall class will initialize
	//            the member variables.  
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CCall::CCall()\n", 0);

	memset(&m_CallIdentifier, 0, sizeof(m_CallIdentifier));
	memset(&m_callType, 0, sizeof(CallType));
	m_pRemoteInfo = 0;
	memset(&m_RemoteCallSignalAddress, 0, sizeof(TransportAddress));
	m_pDestExtraCallInfo = 0;
	memset(&m_LocalCallSignalAddress, 0, sizeof(TransportAddress));
	m_bandWidth = 0;
	m_callReferenceValue = 0;
	memset(&m_conferenceID, 0, sizeof(ConferenceIdentifier));
	m_activeMC = 0;
	m_answerCall = 0;

	m_usTimeTilStatus = DEFAULT_STATUS_PERIOD;	// Reset on ACF
	m_uRetryResetCount = GKCALL_RETRY_INTERVAL_SECONDS;
	m_uRetryCountdown =GKCALL_RETRY_INTERVAL_SECONDS;
	m_uMaxRetryCount = GKCALL_RETRY_MAX;
	
	m_CFbandWidth = 0;

	m_CallReturnInfo.hCall = 0;
	memset(&m_CallReturnInfo.callModel, 0, sizeof(CallModel));
	memset(&m_CallReturnInfo.destCallSignalAddress, 0, sizeof(TransportAddress));
	m_CallReturnInfo.bandWidth = 0;
	m_CallReturnInfo.callReferenceValue = 0;
	memset(&m_CallReturnInfo.conferenceID, 0, sizeof(ConferenceIdentifier));

	m_CallReturnInfo.wError = 0;

	m_CFirrFrequency = 0;

	m_State = GK_ADM_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_ADM_PENDING (%X)\n", this);

	m_pRasMessage = 0;
	m_usRetryCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
// CCall destruction

CCall::~CCall()
{
	// ABSTRACT:  The destructor for the CCall class must free the
	//            memory allocated for the Alias addresses.  It does this by 
	//            deleting the structures and walking the link list.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA1, *pAA2;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_CONDES, "CCall::~CCall()\n", 0);

	m_CallReturnInfo.hCall = 0;	// Delete self reference

	// Delete allocated memory for sequence of alias addresses
	pAA1 = m_pRemoteInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	pAA1 = m_pDestExtraCallInfo;
	while (pAA1 != 0)
	{
		pAA2 = pAA1->next;
		if (pAA1->value.choice == h323_ID_chosen)
		{
			SPIDER_TRACE(SP_NEWDEL, "del pAA1->value.u.h323_ID.value = %X\n", pAA1->value.u.h323_ID.value);
			delete pAA1->value.u.h323_ID.value;
		}
		SPIDER_TRACE(SP_NEWDEL, "del pAA1 = %X\n", pAA1);
		delete pAA1;
		pAA1 = pAA2;
	}

	// Delete memory for last RAS message if still allocated
	if (m_pRasMessage)
	{
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;
	}
}

HRESULT 
CCall::AddRemoteInfo(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_AdmissionRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            This procedure returns 0 if successful and non-zero 
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddRemoteInfo(%X)\n", rvalue.choice);

	if (m_pRemoteInfo == 0)	// First one in the list
	{
		m_pRemoteInfo = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pRemoteInfo = %X\n", m_pRemoteInfo);
		if (m_pRemoteInfo == 0)
			return (GKI_NO_MEMORY);
		memset(m_pRemoteInfo, 0, sizeof(SeqAliasAddr));
		p1 = m_pRemoteInfo;
	}
	else 
	{
		for (p1 = m_pRemoteInfo; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

HRESULT 
CCall::AddDestExtraCallInfo(AliasAddress& rvalue)
{
	// ABSTRACT:  This procedure is called to add an alias address
	//            to the link list of alias addresses.  This will
	//            be called for each alias on receiving a GKI_AdmissionRequest.
	//            A local copy is made to avoid reliance on the client
	//            keeping the memory valid.
	//            This procedure returns 0 if successful and non-zero 
	//            for a failure.
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*p1;
	unsigned short	uIdx;
	unsigned short	*pus;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CRegistration::AddDestExtraCallInfo(%X)\n", rvalue.choice);

	if (m_pDestExtraCallInfo == 0)	// First one in the list
	{
		m_pDestExtraCallInfo = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new m_pDestExtraCallInfo = %X\n", m_pDestExtraCallInfo);
		if (m_pDestExtraCallInfo == 0)
			return (GKI_NO_MEMORY);
		memset(m_pDestExtraCallInfo, 0, sizeof(SeqAliasAddr));
		p1 = m_pDestExtraCallInfo;
	}
	else 
	{
		for (p1 = m_pDestExtraCallInfo; p1->next != 0; p1 = p1->next)
			;						// walk the list til last entry
		p1->next = new SeqAliasAddr;
		SPIDER_TRACE(SP_NEWDEL, "new p1->next = %X\n", p1->next);
		if (p1->next == 0)
			return (GKI_NO_MEMORY);
		memset(p1->next, 0, sizeof(SeqAliasAddr));
		p1 = p1->next;
	}
	p1->next = 0;					// initialize new structure fields
	p1->value = rvalue;
	if (p1->value.choice == h323_ID_chosen)
	{
		pus = new unsigned short[p1->value.u.h323_ID.length];
		SPIDER_TRACE(SP_NEWDEL, "new pus = %X\n", pus);
		if (pus == 0)
			return (GKI_NO_MEMORY);
		memset(pus, 0, sizeof(unsigned short) * p1->value.u.h323_ID.length);
		for (uIdx = 0; uIdx < p1->value.u.h323_ID.length; uIdx++)
			*(pus + uIdx) = *(p1->value.u.h323_ID.value + uIdx);
		p1->value.u.h323_ID.value = pus;
	}
	return (GKI_OK);
}

HRESULT 
CCall::SetLocalCallSignalAddress(unsigned short usCallTransport)
{
	TransportAddress	*pTA;

	pTA = g_pReg->GetTransportAddress(usCallTransport);
	if (pTA == NULL)
		return (GKI_NO_TA_ERROR);
	m_LocalCallSignalAddress = *pTA;
	return (GKI_OK);
}

void 
CCall::SetConferenceID(ConferenceIdentifier *pCID)
{
	if ((pCID == NULL) || (pCID->length == 0))
		GenerateConferenceID();
	else
		m_conferenceID = *pCID;
}

void
CCall::GenerateConferenceID(void)
{
	CoCreateGuid((struct _GUID *)m_conferenceID.value);
	m_conferenceID.length = 16;
}

HRESULT 
CCall::AdmissionRequest(void)
{
	// ABSTRACT:  This procedure will create an AdmissionRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.  Note:  The
	//            memory allocated for the RAS Message is not freed until either
	//            a response from the gatekeeper or it times out.  This allows
	//            for retransmission without having to rebuild this message.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Copy call reference value and CRV into the return info structure
	m_CallReturnInfo.callReferenceValue = m_callReferenceValue;
	m_CallReturnInfo.conferenceID = m_conferenceID;

	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;

	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for AdmissionRequest
	m_pRasMessage->choice = admissionRequest_chosen;
	
	if (m_pDestExtraCallInfo != 0)
		m_pRasMessage->u.admissionRequest.bit_mask |= AdmissionRequest_destExtraCallInfo_present;
	
	m_pRasMessage->u.admissionRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.admissionRequest.callType = m_callType;
	m_pRasMessage->u.admissionRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	memcpy(&m_pRasMessage->u.admissionRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.admissionRequest.callIdentifier.guid.length = sizeof(GUID);
	
	m_pRasMessage->u.admissionRequest.bit_mask |= AdmissionRequest_callIdentifier_present;
	
	if (m_answerCall)	// Src & Dest are swapped in callee
	{
		if (g_pReg->GetAlias() != NULL)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destinationInfo_present;
		}
		if (m_LocalCallSignalAddress.choice != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destCallSignalAddress_present;
		}
		m_pRasMessage->u.admissionRequest.destinationInfo = (PAdmissionRequest_destinationInfo)g_pReg->GetAlias();
		m_pRasMessage->u.admissionRequest.destCallSignalAddress = m_LocalCallSignalAddress;
		m_pRasMessage->u.admissionRequest.srcInfo = (PAdmissionRequest_srcInfo)m_pRemoteInfo;
   		if (m_RemoteCallSignalAddress.choice != 0)
   		{
			m_pRasMessage->u.admissionRequest.bit_mask |= srcCallSignalAddress_present;
			m_pRasMessage->u.admissionRequest.srcCallSignalAddress = m_RemoteCallSignalAddress;
		}
	}
	else
	{
		if (m_pRemoteInfo != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destinationInfo_present;
		}
		else if (m_RemoteCallSignalAddress.choice != 0)
		{
			m_pRasMessage->u.admissionRequest.bit_mask 
				|= AdmissionRequest_destCallSignalAddress_present;
			m_pRasMessage->u.admissionRequest.destCallSignalAddress = m_RemoteCallSignalAddress;
		}
		m_pRasMessage->u.admissionRequest.destinationInfo = (PAdmissionRequest_destinationInfo)m_pRemoteInfo;
		m_pRasMessage->u.admissionRequest.srcInfo = (PAdmissionRequest_srcInfo)g_pReg->GetAlias();
	}
	m_pRasMessage->u.admissionRequest.destExtraCallInfo = (PAdmissionRequest_destExtraCallInfo)m_pDestExtraCallInfo;
	m_pRasMessage->u.admissionRequest.bandWidth = m_bandWidth;
	m_pRasMessage->u.admissionRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.admissionRequest.conferenceID = m_conferenceID;
	// The following casts are because ASN1_BOOL is a char and BOOL is an int
	// since the values of m_activeMC and m_answerCall are always 0 or 1, the
	// cast to char causes no loss of data
	m_pRasMessage->u.admissionRequest.activeMC = (ASN1_BOOL)m_activeMC;
	m_pRasMessage->u.admissionRequest.answerCall = (ASN1_BOOL)m_answerCall;

#ifdef _DEBUG
    if (dwGKIDLLFlags & SP_DUMPMEM)
        DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	SPIDER_TRACE(SP_PDU, "Send ARQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::BandwidthRequest(void)
{
	// ABSTRACT:  This procedure will create a bandwidthRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for BandwidthRequest
	m_pRasMessage->choice = bandwidthRequest_chosen;
	m_pRasMessage->u.bandwidthRequest.bit_mask = callType_present;
	
	m_pRasMessage->u.bandwidthRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.bandwidthRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	m_pRasMessage->u.bandwidthRequest.conferenceID = m_conferenceID;
	m_pRasMessage->u.bandwidthRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.bandwidthRequest.callType = m_callType;
	m_pRasMessage->u.bandwidthRequest.bandWidth = m_bandWidth;
	memcpy(&m_pRasMessage->u.bandwidthRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.bandwidthRequest.callIdentifier.guid.length = sizeof(GUID);
	
	m_pRasMessage->u.bandwidthRequest.bit_mask 
		|= BandwidthRequest_callIdentifier_present;

#ifdef _DEBUG
    if (dwGKIDLLFlags & SP_DUMPMEM)
        DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_BW_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_BW_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send BRQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::DisengageRequest(void)
{
	// ABSTRACT:  This procedure will create a disengageRequest structure
	//            call the encoder and send the PDU.  If it is successful, it
	//            will return 0, else it will return an error code.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageRequest()\n", 0);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Allocate a RasMessage structure and initialized to 0
	m_usRetryCount = 0;
	m_uRetryCountdown = m_uRetryResetCount;
	
	m_pRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new m_pRasMessage = %X\n", m_pRasMessage);
	if (m_pRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(m_pRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for DisengageRequest
	m_pRasMessage->choice = disengageRequest_chosen;
	m_pRasMessage->u.disengageRequest.bit_mask = 0;
	
	m_pRasMessage->u.disengageRequest.requestSeqNum = g_pReg->GetNextSeqNum();
	m_pRasMessage->u.disengageRequest.endpointIdentifier = g_pReg->GetEndpointIdentifier();
	m_pRasMessage->u.disengageRequest.conferenceID = m_conferenceID;
	m_pRasMessage->u.disengageRequest.callReferenceValue = m_callReferenceValue;
	m_pRasMessage->u.disengageRequest.disengageReason.choice = normalDrop_chosen;
	memcpy(&m_pRasMessage->u.disengageRequest.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	m_pRasMessage->u.disengageRequest.callIdentifier.guid.length = sizeof(GUID);
	m_pRasMessage->u.disengageRequest.bit_mask 
		|= DisengageRequest_callIdentifier_present;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(m_pRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	// Create a backup copy of the encoded PDU if using debug echo support
	if (fGKIEcho)
	{
		pEchoBuff = new char[Asn1Buf.length];
		SPIDER_TRACE(SP_NEWDEL, "new pEchoBuff = %X\n", pEchoBuff);
		if (pEchoBuff == 0)
			return (GKI_NO_MEMORY);
		memcpy(pEchoBuff, (char *)Asn1Buf.value, Asn1Buf.length);
		nEchoLen = Asn1Buf.length;
	}

	m_State = GK_DISENG_PENDING;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENG_PENDING (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send DRQ; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	return (GKI_OK);
}

HRESULT 
CCall::AdmissionConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an admissionConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  admissionRequest.
	//            It will delete the memory used for the admissionRequest
	//            change the state and notify the user by posting a message.
	//            Additional information contained in the admissionConfirm
	//            is stored in the CCall class.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return (GKI_NOT_INITIALIZED);	
		
	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_ADM_PENDING) || 
			(pRasMessage->u.admissionConfirm.requestSeqNum != 
			m_pRasMessage->u.admissionRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);

	if (pRasMessage->u.admissionConfirm.bit_mask & irrFrequency_present)
	{
		m_CFirrFrequency = pRasMessage->u.admissionConfirm.irrFrequency;
		m_usTimeTilStatus = 
				(unsigned short)(((DWORD)m_CFirrFrequency * 1000) / GKR_RETRY_TICK_MS);
		SPIDER_DEBUG(m_usTimeTilStatus);
	}
	else
		m_usTimeTilStatus = 0;		// Don't auto-send status datagrams

	m_CFbandWidth = pRasMessage->u.admissionConfirm.bandWidth;

	m_CallReturnInfo.hCall = this;
	m_CallReturnInfo.callModel = pRasMessage->u.admissionConfirm.callModel;
	m_CallReturnInfo.destCallSignalAddress = pRasMessage->u.admissionConfirm.destCallSignalAddress;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;
	m_CallReturnInfo.wError = 0;

#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(hWnd, wBaseMessage + GKI_ADM_CONFIRM, 0, %X)\n", &m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%p\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel.choice);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_ADM_CONFIRM, 
			0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::AdmissionReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if an admissionReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  admissionRequest.
	//            It will delete the memory used for the admissionRequest
	//            change the state and notify the user by posting a message
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::AdmissionReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_ADM_PENDING) || 
			(pRasMessage->u.admissionReject.requestSeqNum != 
			m_pRasMessage->u.admissionRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// We deliberately don't free the RasMessage memory.  Let the call destructor
	// do it - this provides protection from other requests for this hCall.

	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ADM_REJECT, %X, 0)\n", 
									pRasMessage->u.admissionReject.rejectReason.choice);
	PostMessage(g_pReg->GetHWnd(), 
				g_pReg->GetBaseMessage() + GKI_ADM_REJECT, 
				(WORD)pRasMessage->u.admissionReject.rejectReason.choice, 0L);

	return (GKI_DELETE_CALL);
}

HRESULT 
CCall::BandwidthConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a bandwidthConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  bandwidthRequest.
	//            It will delete the memory used for the bandwidthRequest,
	//            change the state and notify the user by posting a message.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_BW_PENDING) || 
			(pRasMessage->u.bandwidthConfirm.requestSeqNum != 
			m_pRasMessage->u.bandwidthRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
	m_CFbandWidth = pRasMessage->u.bandwidthConfirm.bandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Notify user application
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_CONFIRM, 0, %X)\n", &m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%p\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel.choice);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_BW_CONFIRM, 0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::BandwidthReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a bandwidthReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  bandwidthRequest.
	//            It will delete the memory used for the bandwidthRequest
	//            change the state and notify the user by posting a message
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::BandwidthReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding admissionRequest
	// and the sequence numbers match
	if ((m_State != GK_BW_PENDING) || 
			(pRasMessage->u.bandwidthReject.requestSeqNum != 
			m_pRasMessage->u.bandwidthRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Delete allocate RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
	delete m_pRasMessage;
	m_pRasMessage = 0;

	// Update member variables
	m_State = GK_CALL;
	SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
	m_CFbandWidth = pRasMessage->u.bandwidthReject.allowedBandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Notify user application
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_REJECT, %X, &m_CallReturnInfo)\n", 
			pRasMessage->u.bandwidthReject.rejectReason.choice);
	wsprintf(szGKDebug, "\thCall=%p\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel.choice);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_BW_REJECT, 
			(WORD)pRasMessage->u.bandwidthReject.rejectReason.choice, 
			(LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT 
CCall::SendBandwidthConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called when a bandwidthRequest is
	//            received from the gatekeeper.  It will create the 
	//            bandwidthConfirm structure, encode it and send
	//            it on the net.  It posts a message to the user
	//            notifying them.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRespRasMessage;
#ifdef _DEBUG
	unsigned int	nIdx;
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::SendBandwidthConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state
	if (m_State != GK_CALL)
		return (g_pReg->UnknownMessage(pRasMessage));

	// Update member variables
	m_CFbandWidth = pRasMessage->u.bandwidthRequest.bandWidth;
	m_CallReturnInfo.bandWidth = m_CFbandWidth;

	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for BandwidthConfirm
	pRespRasMessage->choice = bandwidthConfirm_chosen;
	pRespRasMessage->u.bandwidthConfirm.requestSeqNum = 
			pRasMessage->u.bandwidthRequest.requestSeqNum;
	pRespRasMessage->u.bandwidthConfirm.bandWidth = 
			pRasMessage->u.bandwidthRequest.bandWidth;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	SPIDER_TRACE(SP_PDU, "Send BCF; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	// Notify user of received bandwidth request
#ifdef _DEBUG
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_BW_CONFIRM, 0, %X)\n", 
			&m_CallReturnInfo);
	wsprintf(szGKDebug, "\thCall=%p\n", m_CallReturnInfo.hCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallModel=%X\n", m_CallReturnInfo.callModel.choice);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tbandWidth=%X\n", m_CallReturnInfo.bandWidth);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tcallReferenceValue=%X\n", m_CallReturnInfo.callReferenceValue);
	OutputDebugString(szGKDebug);
	OutputDebugString("\tconferenceID=");
	for (nIdx = 0; nIdx < m_CallReturnInfo.conferenceID.length; nIdx++)
	{
		wsprintf(szGKDebug, "%02X", m_CallReturnInfo.conferenceID.value[nIdx]);
		OutputDebugString(szGKDebug);
	}
	wsprintf(szGKDebug, "\n\twError=%X\n", m_CallReturnInfo.wError);
	OutputDebugString(szGKDebug);
#endif
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_BW_CONFIRM, 
			0, (LPARAM)&m_CallReturnInfo);

	return (GKI_OK);
}

HRESULT
CCall::DisengageConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a disengageConfirm is 
	//            received.  We must ensure that this matches an outstanding 
	//			  disengageRequest.
	//            It will delete the memory used for the disengageRequest,
	//            change the state and notify the user by posting a message.
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageConfirm(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding disengageRequest
	// and the sequence numbers match
	if ((m_State != GK_DISENG_PENDING) || 
			(pRasMessage->u.disengageConfirm.requestSeqNum != 
			m_pRasMessage->u.disengageRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// We deliberately don't free the RasMessage memory.  Let the call destructor
	// do it - this provides protection from other requests for this hCall.

	// Update member variables
	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_CONFIRM, 0, %X)\n", 
			this);
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_DISENG_CONFIRM, 0, (LPARAM)this);

	return (GKI_DELETE_CALL);
}

HRESULT
CCall::DisengageReject(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called if a disengageReject is 
	//            received.  We must ensure that this matches an outstanding 
	//			  disengageRequest.
	//            It will delete the memory used for the disengageRequest
	//            change the state and notify the user by posting a message
	//            If this function returns GKI_DELETE_CALL, the calling function
	//            will delete the CCall object.
	// AUTHOR:    Colin Hulme

#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CCall::DisengageReject(%X)\n", pRasMessage);

	// Verify we are in the correct state, have an outstanding disengageRequest
	// and the sequence numbers match
	if ((m_State != GK_DISENG_PENDING) || 
			(pRasMessage->u.disengageReject.requestSeqNum != 
			m_pRasMessage->u.disengageRequest.requestSeqNum))

		return (g_pReg->UnknownMessage(pRasMessage));

	// Update member variables
	switch (pRasMessage->u.disengageReject.rejectReason.choice)
	{
	case requestToDropOther_chosen:		// return to GK_CALL state
		m_State = GK_CALL;
		SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);

		// Delete allocate RasMessage storage
		SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
		delete m_pRasMessage;
		m_pRasMessage = 0;

		break;
	case DsnggRjctRsn_ntRgstrd_chosen:
	default:
		m_State = GK_DISENGAGED;
		SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
		hResult = GKI_DELETE_CALL;

		// We deliberately don't free the RasMessage memory.  Let the call destructor
		// do it - this provides protection from other requests for this hCall.
		break;
	}

	// Notify user application
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_REJECT, %X, hCall)\n", 
									pRasMessage->u.disengageReject.rejectReason.choice);
	PostMessage(g_pReg->GetHWnd(), 
			g_pReg->GetBaseMessage() + GKI_DISENG_REJECT, 
			(WORD)pRasMessage->u.disengageReject.rejectReason.choice, 
			(LPARAM)this);

	return (hResult);
}

HRESULT 
CCall::SendDisengageConfirm(RasMessage *pRasMessage)
{
	// ABSTRACT:  This function is called when a disengageRequest is
	//            received from the gatekeeper.  It will create the 
	//            disengageConfirm structure, encode it and send
	//            it on the net.  It posts a message to the user
	//            notifying them.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRespRasMessage;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CCall::SendDisengageConfirm(%X)\n", pRasMessage);
	ASSERT(g_pCoder);
	if (g_pCoder == NULL)
		return (GKI_NOT_INITIALIZED);	
		
	// Verify we are in the correct state
	if (m_State != GK_CALL)
		return (g_pReg->UnknownMessage(pRasMessage));

	// Allocate a RasMessage structure and initialized to 0
	pRespRasMessage = new RasMessage;
	SPIDER_TRACE(SP_NEWDEL, "new pRespRasMessage = %X\n", pRespRasMessage);
	if (pRespRasMessage == 0)
		return (GKI_NO_MEMORY);
	memset(pRespRasMessage, 0, sizeof(RasMessage));

	// Setup structure fields for DisengageConfirm
	pRespRasMessage->choice = disengageConfirm_chosen;
	pRespRasMessage->u.disengageConfirm.requestSeqNum = 
			pRasMessage->u.disengageRequest.requestSeqNum;

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_DUMPMEM)
		DumpMem(pRespRasMessage, sizeof(RasMessage));
#endif

	// Encode the PDU & send it
	dwErrorCode = g_pCoder->Encode(pRespRasMessage, &Asn1Buf);
	if (dwErrorCode)
		return (GKI_ENCODER_ERROR);

	m_State = GK_DISENGAGED;
	SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);

	SPIDER_TRACE(SP_PDU, "Send DCF; pCall = %X\n", this);
	if (fGKIDontSend == FALSE)
		if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
			return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

	// Free the encoder memory
	g_pCoder->Free(Asn1Buf);

	// Delete allocated RasMessage storage
	SPIDER_TRACE(SP_NEWDEL, "del pRespRasMessage = %X\n", pRespRasMessage);
	delete pRespRasMessage;

	// Notify user of received disengage request
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_DISENG_CONFIRM, 0, %X)\n", 
			this);
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_DISENG_CONFIRM, 
			0, (LPARAM)this);

	return (GKI_DELETE_CALL);
}

HRESULT
CCall::Retry(void)
{
	// ABSTRACT:  This function is called by the CRegistration Retry function
	//            at the configured time interval.  It will check if there
	//            are any outstanding PDUs for the Call object
	//            If so, they will be retransmitted.  If the maximum number of
	//            retries has expired, the memory will be cleaned up.
	//            This function will return 0 to the background thread unless
	//            it wants the thread to terminate.  This function will
	//            also send the IRR status datagram for the conference
	//            if the time period has expired.
	// AUTHOR:    Colin Hulme

	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

//	SPIDER_TRACE(SP_FUNC, "CCall::Retry()\n", 0);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return (GKI_NOT_INITIALIZED);	
		
	// Check to see if status datagram is required
	if (m_usTimeTilStatus)	// No auto-status if 0
	{
		if (--m_usTimeTilStatus == 0)
		{
			// Reset timer
			m_usTimeTilStatus = 
					(unsigned short)(((DWORD)m_CFirrFrequency * 1000) / GKR_RETRY_TICK_MS);

			hResult = SendInfoRequestResponse(0, 0, TRUE);	// send unsolicited status datagram
			if (hResult != GKI_OK)
				return (hResult);
		}
	}

	// Check to see if PDU retransmission is required
	if (m_pRasMessage && (--m_uRetryCountdown == 0))
	{
		// going to retry, reset countdown
		m_uRetryCountdown = m_uRetryResetCount;

		if (m_usRetryCount <= m_uMaxRetryCount)
		{
			// Encode the PDU & resend it
			dwErrorCode = g_pCoder->Encode(m_pRasMessage, &Asn1Buf);
			if (dwErrorCode)
				return (GKI_ENCODER_ERROR);

			SPIDER_TRACE(SP_PDU, "RESend PDU; pCall = %X\n", this);
			if (fGKIDontSend == FALSE)
				if (g_pReg->m_pSocket->Send((char *)Asn1Buf.value, Asn1Buf.length) == SOCKET_ERROR)
					return (GKI_WINSOCK2_ERROR(SOCKET_ERROR));

			// Free the encoder memory
			g_pCoder->Free(Asn1Buf);
			m_usRetryCount++;
		}
		else	// Retries expired - clean up
		{
			switch (m_pRasMessage->choice)
			{
			case admissionRequest_chosen:
				m_State = GK_DISENGAGED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
				hResult = GKI_DELETE_CALL;
				break;
			case bandwidthRequest_chosen:
				m_State = GK_CALL;
				SPIDER_TRACE(SP_STATE, "m_State = GK_CALL (%X)\n", this);
				break;
			case disengageRequest_chosen:
				m_State = GK_DISENGAGED;
				SPIDER_TRACE(SP_STATE, "m_State = GK_DISENGAGED (%X)\n", this);
				hResult = GKI_DELETE_CALL;
				break;
			}
			SPIDER_TRACE(SP_NEWDEL, "del m_pRasMessage = %X\n", m_pRasMessage);
			delete m_pRasMessage;
			m_pRasMessage = 0;

			// Notify user that gatekeeper didn't respond
		#ifdef RETRY_REREG_FOREVER
			SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_NO_RESPONSE)\n", 0);
			PostMessage(g_pReg->GetHWnd(), 
					g_pReg->GetBaseMessage() + GKI_ERROR, 
					0, GKI_NO_RESPONSE);
		#else
			// end the call as if ARJ occurred
			SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ADM_REJECT, ARJ_TIMEOUT, 0)\n", 0);
			PostMessage(g_pReg->GetHWnd(), 
					g_pReg->GetBaseMessage() + GKI_ADM_REJECT, 
					ARJ_TIMEOUT, 0L);
		#endif
		}
	}

	return (hResult);
}

HRESULT 
CCall::SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage, BOOL fThisCallOnly)
{
	// ABSTRACT:  This function is called by the Retry thread if this call
	//            is due to report an unsolicited status to the gatekeeper.
	//            It is also called in response to a received IRQ.  In the
	//            case of an IRQ, each active call should chain call the 
	//            next active call.  This allows construction of a link
	//            list of conference information that is then passed to the
	//            CRegistration::SendInfoRequestResponse function for
	//            encapsulation into the IRR message.
	//
	//			  The fThisCallOnly flag determines whether or not to walk the
	//			  chain of calls in generating the response message.
	//
	//			  If fThisCallOnly == TRUE, the chain will not be walked, and
	//			  this routine will call the CRegistration::SendInfoRequestResponse().
	// AUTHOR:    Colin Hulme, Dan Dexter

	CallInfoStruct		CallInfo;
	CallInfoStruct		*pCI;
#ifdef _DEBUG
	char				szGKDebug[80];
#endif
	HRESULT				hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "CCall::SendInfoRequestResponse(%X)\n", pCallInfo);

	memset(&CallInfo, 0, sizeof(CallInfo));
	CallInfo.next = 0;
	CallInfo.value.bit_mask = 0;
	CallInfo.value.callReferenceValue = m_callReferenceValue;
	CallInfo.value.conferenceID = m_conferenceID;
	
	memcpy(&CallInfo.value.callIdentifier.guid.value,
		&m_CallIdentifier, sizeof(GUID));
	CallInfo.value.callIdentifier.guid.length = sizeof(GUID);
	CallInfo.value.bit_mask 
		|= InfoRequestResponse_perCallInfo_Seq_callIdentifier_present;

	CallInfo.value.bit_mask |= originator_present;
	
	CallInfo.value.callSignaling.bit_mask = recvAddress_present;
	CallInfo.value.callSignaling.recvAddress = m_LocalCallSignalAddress;

	if (m_answerCall)	// If I am the callee
	{
 		// look out! if there has not been an ACF, m_CallReturnInfo.destCallSignalAddress
		// is uninitialized.  m_CallReturnInfo.hCall is set only after ACF
		if(m_CallReturnInfo.hCall)
		{
			if (m_RemoteCallSignalAddress.choice)
			{
				CallInfo.value.callSignaling.sendAddress = m_RemoteCallSignalAddress;
				CallInfo.value.callSignaling.bit_mask |= sendAddress_present;
			}
			CallInfo.value.originator = FALSE;
			CallInfo.value.callModel = m_CallReturnInfo.callModel;
		}
		else	
		{
			// we are typically in this path because we got an IRQ after 
			// sending an ARQ. 
			CallInfo.value.callModel.choice = direct_chosen;
		}
	}
	else				// I am the caller
	{
		// look out! if there has not been an ACF, m_CallReturnInfo.destCallSignalAddress
		// is uninitialized.  m_CallReturnInfo.hCall is set only after ACF
		if(m_CallReturnInfo.hCall)
		{
			CallInfo.value.callSignaling.sendAddress = m_CallReturnInfo.destCallSignalAddress;
			CallInfo.value.callSignaling.bit_mask |= sendAddress_present;
			CallInfo.value.originator = TRUE;
			CallInfo.value.callModel = m_CallReturnInfo.callModel;
		}
		else	
		{
			// we are typically in this path because we got an IRQ after 
			// sending an ARQ. 
			CallInfo.value.callModel.choice = direct_chosen;
		}
	}
	CallInfo.value.callType = m_callType;
	CallInfo.value.bandWidth = m_CFbandWidth;


	if (pCallInfo)	// Add to chain of CallInfo structures
	{
		for (pCI = pCallInfo; pCI->next != 0; pCI = pCI->next)
			;
		pCI->next = &CallInfo;
	}
	else			// We're alone - just point to ours
		pCallInfo = &CallInfo;

	// If the IRR is not just for this call, then get the next call
	// and call it's SendInfoRequestResponse() function.  If there are no
	// more calls, or this IRR was only for this call, call
	// g_pReg->SendInfoRequestResponse()
	CCall *pNextCall = NULL;
	if (!fThisCallOnly)
	{
		pNextCall = g_pReg->GetNextCall(this);
	}

	if (pNextCall)
		hResult = pNextCall->SendInfoRequestResponse(pCallInfo, pRasMessage, fThisCallOnly);
	else
		hResult = g_pReg->SendInfoRequestResponse(pCallInfo, pRasMessage);

	return (hResult);
}


//
// MatchSeqNum()
//
// ABSTRACT:
//	This function checks to see if the outstanding RAS request(s) it has
//	match the sequence number passed in.
//
// RETURNS:
//	TRUE if sequence number matches, FALSE otherwise
//
// AUTHOR:	Dan Dexter
BOOL
CCall::MatchSeqNum(RequestSeqNum seqNum)
{
	BOOL bRet = FALSE;
	// If there is no RAS message, this sequence
	// number can't be ours...
	if (!m_pRasMessage)
		return(FALSE);

	// Look at the sequence number in the RAS message and see
	// if it matches.

	switch(m_pRasMessage->choice)
	{
		case gatekeeperRequest_chosen:
			if (m_pRasMessage->u.gatekeeperRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case gatekeeperConfirm_chosen:
			if (m_pRasMessage->u.gatekeeperConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case gatekeeperReject_chosen:
			if (m_pRasMessage->u.gatekeeperReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationRequest_chosen:
			if (m_pRasMessage->u.registrationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationConfirm_chosen:
			if (m_pRasMessage->u.registrationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case registrationReject_chosen:
			if (m_pRasMessage->u.registrationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationRequest_chosen:
			if (m_pRasMessage->u.unregistrationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationConfirm_chosen:
			if (m_pRasMessage->u.unregistrationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unregistrationReject_chosen:
			if (m_pRasMessage->u.unregistrationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionRequest_chosen:
			if (m_pRasMessage->u.admissionRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionConfirm_chosen:
			if (m_pRasMessage->u.admissionConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case admissionReject_chosen:
			if (m_pRasMessage->u.admissionReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthRequest_chosen:
			if (m_pRasMessage->u.bandwidthRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthConfirm_chosen:
			if (m_pRasMessage->u.bandwidthConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case bandwidthReject_chosen:
			if (m_pRasMessage->u.bandwidthReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageRequest_chosen:
			if (m_pRasMessage->u.disengageRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageConfirm_chosen:
			if (m_pRasMessage->u.disengageConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case disengageReject_chosen:
			if (m_pRasMessage->u.disengageReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationRequest_chosen:
			if (m_pRasMessage->u.locationRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationConfirm_chosen:
			if (m_pRasMessage->u.locationConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case locationReject_chosen:
			if (m_pRasMessage->u.locationReject.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequest_chosen:
			if (m_pRasMessage->u.infoRequest.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestResponse_chosen:
			if (m_pRasMessage->u.infoRequestResponse.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case nonStandardMessage_chosen:
			if (m_pRasMessage->u.nonStandardMessage.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case unknownMessageResponse_chosen:
			if (m_pRasMessage->u.unknownMessageResponse.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case requestInProgress_chosen:
			if (m_pRasMessage->u.requestInProgress.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case resourcesAvailableIndicate_chosen:
			if (m_pRasMessage->u.resourcesAvailableIndicate.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case resourcesAvailableConfirm_chosen:
			if (m_pRasMessage->u.resourcesAvailableConfirm.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestAck_chosen:
			if (m_pRasMessage->u.infoRequestAck.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		case infoRequestNak_chosen:
			if (m_pRasMessage->u.infoRequestNak.requestSeqNum == seqNum)
				bRet = TRUE;
		break;
		default:
		break;
	}
	return bRet;
}

//
// MatchCRV()
//
// ABSTRACT:
//	This function checks to see if the CallReferenceValue associated
//	with this call object matches the CRV passed in.
//
// RETURNS:
//	TRUE if CRV number matches, FALSE otherwise
//
// AUTHOR:	Dan Dexter
BOOL
CCall::MatchCRV(CallReferenceValue crv)
{
	return(crv == m_callReferenceValue);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dcall.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dcall.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   10 Jan 1997 16:13:46  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dcall.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 16:13:46   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   17 Dec 1996 18:22:18   CHULME
 * Switch src and destination fields on ARQ for Callee
 * 
 *    Rev 1.1   22 Nov 1996 15:25:10   CHULME
 * Added VCS log to the header
*************************************************************************/

// dcall.h : interface of the CCall class
// See dcall.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef DCALL_H
#define DCALL_H

class CRegistration;

class CCall
{
private:
	CallType				m_callType;
	SeqAliasAddr			*m_pRemoteInfo;
	TransportAddress		m_RemoteCallSignalAddress;
	SeqAliasAddr			*m_pDestExtraCallInfo;
	TransportAddress		m_LocalCallSignalAddress;
	BandWidth				m_bandWidth;
	CallReferenceValue		m_callReferenceValue;
	ConferenceIdentifier	m_conferenceID;
	BOOL					m_activeMC;
	BOOL					m_answerCall;
    GUID                    m_CallIdentifier;
	unsigned short			m_usTimeTilStatus;

	UINT                    m_uRetryResetCount;
	UINT                    m_uRetryCountdown;
	UINT                    m_uMaxRetryCount;
	
	CallReturnInfo			m_CallReturnInfo;
	BandWidth				m_CFbandWidth;
	unsigned short			m_CFirrFrequency;

	enum {
		GK_ADM_PENDING,
		GK_CALL,
		GK_DISENG_PENDING,
		GK_DISENGAGED,
		GK_BW_PENDING
	}						m_State;

	RasMessage				*m_pRasMessage;
	unsigned short			m_usRetryCount;

public:
	CCall();
	~CCall();
	void SetCallIdentifier(LPGUID pID)
	{
        m_CallIdentifier = *pID;
	}
	HANDLE GetHCall(void)
	{
		return (m_CallReturnInfo.hCall);
	}
	void SetCallType(unsigned short usChoice)
	{
		m_callType.choice = usChoice;
	}
	HRESULT AddRemoteInfo(AliasAddress& rvalue);
	void SetRemoteCallSignalAddress(TransportAddress *pTA)
	{
		m_RemoteCallSignalAddress = *pTA;
	}
	HRESULT AddDestExtraCallInfo(AliasAddress& rvalue);
	HRESULT SetLocalCallSignalAddress(unsigned short usCallTransport);
	void SetBandWidth(BandWidth bw)
	{
		m_bandWidth = bw;
	}
	void SetCallReferenceValue(CallReferenceValue crv)
	{
		m_callReferenceValue = crv;
	}
	void SetConferenceID(ConferenceIdentifier *pCID);
	void GenerateConferenceID(void);
	void SetActiveMC(BOOL amc)
	{
		m_activeMC = amc;
	}
	void SetAnswerCall(BOOL ac)
	{
		m_answerCall = ac;
	}
	RasMessage *GetRasMessage(void)
	{
		return (m_pRasMessage);
	}

	HRESULT AdmissionRequest(void);
	HRESULT AdmissionConfirm(RasMessage *pRasMessage);
	HRESULT AdmissionReject(RasMessage *pRasMessage);
	HRESULT BandwidthRequest(void);
	HRESULT BandwidthConfirm(RasMessage *pRasMessage);
	HRESULT BandwidthReject(RasMessage *pRasMessage);
	HRESULT SendBandwidthConfirm(RasMessage *pRasMessage);
	HRESULT DisengageRequest(void);
	HRESULT DisengageConfirm(RasMessage *pRasMessage);
	HRESULT DisengageReject(RasMessage *pRasMessage);
	HRESULT SendDisengageConfirm(RasMessage *pRasMessage);
	HRESULT Retry(void);
	HRESULT SendInfoRequestResponse(CallInfoStruct *pCallInfo, RasMessage *pRasMessage, BOOL fThisCallOnly);
	BOOL MatchSeqNum(RequestSeqNum seqNum);
	BOOL MatchCRV(CallReferenceValue crv);
};

#endif // DCALL_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\debug.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\debug.cpv  $
*																		*
*	$Revision:   1.5  $
*	$Date:   17 Jan 1997 09:01:50  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\debug.cpv  $
// 
//    Rev 1.5   17 Jan 1997 09:01:50   CHULME
// No change.
// 
//    Rev 1.4   10 Jan 1997 16:13:52   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   17 Dec 1996 18:22:20   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.2   22 Nov 1996 15:22:30   CHULME
// Added VCS log to the header
*************************************************************************/

// Debug.cpp : Contains conditional compiled debug dump routines
//

#include "precomp.h"

#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"

#ifdef _DEBUG
extern "C" WORD DLL_EXPORT
Dump_GKI_RegistrationRequest(long lVersion, 
							 SeqTransportAddr *pCallSignalAddr, 
							 EndpointType *pTerminalType,
							 SeqAliasAddr *pRgstrtnRqst_trmnlAls, 
							 HWND hWnd,
							 WORD wBaseMessage,
							 unsigned short usRegistrationTransport)
{
	SeqTransportAddr	*ps2;
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	wsprintf(szGKDebug, "\tlVersion = %X\n", lVersion);
	OutputDebugString(szGKDebug);
	for (ps2 = pCallSignalAddr; ps2 != NULL; ps2 = ps2->next)
	{
		wsprintf(szGKDebug, "\tpCallSignalAddr->value.choice = %X\n", ps2->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps2->value.choice == ipAddress_chosen) || (ps2->value.choice == ipxAddress_chosen));
		switch (ps2->value.choice)
		{
		case ipAddress_chosen:
			len = (unsigned short) ps2->value.u.ipAddress.ip.length;
			wsprintf(szGKDebug, "\tpCallSignalAddr->value.u.ipAddress.ip.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipAddress.ip.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%d.", ps2->value.u.ipAddress.ip.value[us]);
				OutputDebugString(szGKDebug);
			}
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipAddress.port = %X\n",	
					ps2->value.u.ipAddress.port);
			OutputDebugString(szGKDebug);
			break;

		case ipxAddress_chosen:
			len = (unsigned short) ps2->value.u.ipxAddress.node.length;
			wsprintf(szGKDebug, "\tpCallSignalAddr->value.u.ipxAddress.node.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.node.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.node.value[us]);
				OutputDebugString(szGKDebug);
			}
			len = (unsigned short) ps2->value.u.ipxAddress.netnum.length;
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipxAddress.netnum.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.netnum.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.netnum.value[us]);
				OutputDebugString(szGKDebug);
			}
			len = (unsigned short) ps2->value.u.ipxAddress.port.length;
			wsprintf(szGKDebug, "\n\tpCallSignalAddr->value.u.ipxAddress.port.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpCallSignalAddr->value.u.ipxAddress.port.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%02X", ps2->value.u.ipxAddress.port.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

	wsprintf(szGKDebug, "\tpTerminalType->bit_mask = %X\n", pTerminalType->bit_mask);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tpTerminalType->mc = %X\n", pTerminalType->mc);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tpTerminalType->undefinedNode = %X\n", pTerminalType->undefinedNode);
	OutputDebugString(szGKDebug);

	for (ps4 = pRgstrtnRqst_trmnlAls; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpRgstrtnRqst_trmnlAls->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpRgstrtnRqst_trmnlAls->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpRgstrtnRqst_trmnlAls->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpRgstrtnRqst_trmnlAls->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}
	wsprintf(szGKDebug, "\thWnd = %p\n", hWnd);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\twBaseMessage = %X\n", wBaseMessage);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tRegistrationTransport = %X\n", usRegistrationTransport);
	OutputDebugString(szGKDebug);
	return (0);
}

extern "C" WORD DLL_EXPORT
Dump_GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
						SeqAliasAddr		*pRemoteInfo,
						TransportAddress	*pRemoteCallSignalAddress,
						SeqAliasAddr		*pDestExtraCallInfo,
						BandWidth			bandWidth,
						ConferenceIdentifier	*pConferenceID,
						BOOL				activeMC,
						BOOL				answerCall,
						unsigned short		usCallTransport)
{
	TransportAddress	*ps2;
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	wsprintf(szGKDebug, "\tusCallTypeChoice = %X\n", usCallTypeChoice);
	OutputDebugString(szGKDebug);

	for (ps4 = pRemoteInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpRemoteInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpRemoteInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpRemoteInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpRemoteInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

   ps2 = pRemoteCallSignalAddress;
   if (ps2)
   {
	    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->choice = %X\n", ps2->choice);
		OutputDebugString(szGKDebug);
	    ASSERT((ps2->choice == ipAddress_chosen) || (ps2->choice == ipxAddress_chosen));
	    switch (ps2->choice)
	    {
	    case ipAddress_chosen:
		    len = (unsigned short) ps2->u.ipAddress.ip.length;
		    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->u.ipAddress.ip.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipAddress.ip.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%d.", ps2->u.ipAddress.ip.value[us]);
				OutputDebugString(szGKDebug);
			}
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipAddress.port = %X\n", 
					ps2->u.ipAddress.port);
			OutputDebugString(szGKDebug);
		    break;

	    case ipxAddress_chosen:
		    len = (unsigned short) ps2->u.ipxAddress.node.length;
		    wsprintf(szGKDebug, "\tpRemoteCallSignalAddress->u.ipxAddress.node.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.node.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.node.value[us]);
				OutputDebugString(szGKDebug);
			}
		    len = (unsigned short) ps2->u.ipxAddress.netnum.length;
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipxAddress.netnum.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.netnum.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.netnum.value[us]);
				OutputDebugString(szGKDebug);
			}
		    len = (unsigned short) ps2->u.ipxAddress.port.length;
		    wsprintf(szGKDebug, "\n\tpRemoteCallSignalAddress->u.ipxAddress.port.length = %X\n", len);
			OutputDebugString(szGKDebug);
		    OutputDebugString("\tpRemoteCallSignalAddress->u.ipxAddress.port.value = ");
		    for (us = 0; us < len; us++)
			{
			    wsprintf(szGKDebug, "%02X", ps2->u.ipxAddress.port.value[us]);
				OutputDebugString(szGKDebug);
			}
		    OutputDebugString("\n");
		    break;
	    }
    }

	for (ps4 = pDestExtraCallInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpDestExtraCallInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpDestExtraCallInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpDestinationInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpDestinationInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}

	wsprintf(szGKDebug, "\tbandWidth = %X\n", bandWidth);
	OutputDebugString(szGKDebug);
    if (pConferenceID)
    {
	    wsprintf(szGKDebug, "\tpConferenceID->length = %X\n", pConferenceID->length);
		OutputDebugString(szGKDebug);
	    OutputDebugString("\tpConferenceID->value = ");
	    for (us = 0; us < pConferenceID->length; us++)
		{
		    wsprintf(szGKDebug, "%02X", pConferenceID->value[us]);
			OutputDebugString(szGKDebug);
		}
	    OutputDebugString("\n");
	}
	wsprintf(szGKDebug, "\tactiveMC = %X\n", activeMC);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tanswerCall = %X\n", answerCall);
	OutputDebugString(szGKDebug);
	wsprintf(szGKDebug, "\tusCallTransport = %X\n", usCallTransport);
	OutputDebugString(szGKDebug);
	return (0);
}

extern "C" WORD DLL_EXPORT
Dump_GKI_LocationRequest(SeqAliasAddr *pLocationInfo)
{
	SeqAliasAddr		*ps4;
	unsigned short		len, us;
	char				*pc;
	char				szGKDebug[80];

	for (ps4 = pLocationInfo; ps4 != NULL; ps4 = ps4->next)
	{
		wsprintf(szGKDebug, "\tpLocationInfo->value.choice = %X\n", ps4->value.choice);
		OutputDebugString(szGKDebug);
		ASSERT((ps4->value.choice == e164_chosen) || (ps4->value.choice == h323_ID_chosen));
		switch (ps4->value.choice)
		{
		case e164_chosen:
			OutputDebugString("\tpLocationInfo->value.u.e164 = ");
			for (pc = ps4->value.u.e164; *pc != 0; pc++)
			{
				wsprintf(szGKDebug, "%c", *pc);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		case h323_ID_chosen:
			len = (unsigned short) ps4->value.u.h323_ID.length;
			wsprintf(szGKDebug, "\tpLocationInfo->value.u.h323ID.length = %X\n", len);
			OutputDebugString(szGKDebug);
			OutputDebugString("\tpLocationInfo->value.u.h323ID.value = ");
			for (us = 0; us < len; us++)
			{
				wsprintf(szGKDebug, "%c", ps4->value.u.h323_ID.value[us]);
				OutputDebugString(szGKDebug);
			}
			OutputDebugString("\n");
			break;
		}
	}
	return (0);
}

void
SpiderWSErrDecode(int nErr)
{

#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_DEBUG(nErr);

	switch (nErr)
	{
	case WSAEINTR:
		OutputDebugString("WSAEINTR\n");
		break; 
	case WSAEBADF:
		OutputDebugString("WSAEBADF\n");
		break; 
	case WSAEACCES:
		OutputDebugString("WSAEACCES\n");
		break;
	case WSAEFAULT:
		OutputDebugString("WSAEFAULT\n");
		break;
	case WSAEINVAL:
		OutputDebugString("WSAEINVAL\n");
		break;
	case WSAEMFILE:
		OutputDebugString("WSAEMFILE\n");
		break;

	case WSAEWOULDBLOCK:
		OutputDebugString("WSAEWOULDBLOCK\n");
		break;    
	case WSAEINPROGRESS:
		OutputDebugString("WSAEINPROGRESS\n");
		break;    
	case WSAEALREADY:
		OutputDebugString("WSAEALREADY\n");
		break;       
	case WSAENOTSOCK:
		OutputDebugString("WSAENOTSOCK\n");
		break;       
	case WSAEDESTADDRREQ:
		OutputDebugString("WSAEDESTADDRREQ\n");
		break;   
	case WSAEMSGSIZE:
		OutputDebugString("WSAEMSGSIZE\n");
		break;       
	case WSAEPROTOTYPE:
		OutputDebugString("WSAEPROTOTYPE\n");
		break;     
	case WSAENOPROTOOPT:
		OutputDebugString("WSAENOPROTOOPT\n");
		break;    
	case WSAEPROTONOSUPPORT:
		OutputDebugString("WSAEPROTONOSUPPORT\n");
		break;
	case WSAESOCKTNOSUPPORT:
		OutputDebugString("WSAESOCKTNOSUPPORT\n");
		break;
	case WSAEOPNOTSUPP:
		OutputDebugString("WSAEOPNOTSUPP\n");
		break;     
	case WSAEPFNOSUPPORT:
		OutputDebugString("WSAEPFNOSUPPORT\n");
		break;   
	case WSAEAFNOSUPPORT:
		OutputDebugString("WSAEAFNOSUPPORT\n");
		break;   
	case WSAEADDRINUSE:
		OutputDebugString("WSAEADDRINUSE\n");
		break;     
	case WSAEADDRNOTAVAIL:
		OutputDebugString("WSAEADDRNOTAVAIL\n");
		break;  
	case WSAENETDOWN:
		OutputDebugString("WSAENETDOWN\n");
		break;       
	case WSAENETUNREACH:
		OutputDebugString("WSAENETUNREACH\n");
		break;    
	case WSAENETRESET:
		OutputDebugString("WSAENETRESET\n");
		break;      
	case WSAECONNABORTED:
		OutputDebugString("WSAECONNABORTED\n");
		break;   
	case WSAECONNRESET:
		OutputDebugString("WSAECONNRESET\n");
		break;     
	case WSAENOBUFS:
		OutputDebugString("WSAENOBUFS\n");
		break;        
	case WSAEISCONN:
		OutputDebugString("WSAEISCONN\n");
		break;        
	case WSAENOTCONN:
		OutputDebugString("WSAENOTCONN\n");
		break;       
	case WSAESHUTDOWN:
		OutputDebugString("WSAESHUTDOWN\n");
		break;      
	case WSAETOOMANYREFS:
		OutputDebugString("WSAETOOMANYREFS\n");
		break;   
	case WSAETIMEDOUT:
		OutputDebugString("WSAETIMEDOUT\n");
		break;      
	case WSAECONNREFUSED:
		OutputDebugString("WSAECONNREFUSED\n");
		break;   
	case WSAELOOP:
		OutputDebugString("WSAELOOP\n");
		break;          
	case WSAENAMETOOLONG:
		OutputDebugString("WSAENAMETOOLONG\n");
		break;   
	case WSAEHOSTDOWN:
		OutputDebugString("WSAEHOSTDOWN\n");
		break;      
	case WSAEHOSTUNREACH:
		OutputDebugString("WSAEHOSTUNREACH\n");
		break;   
	case WSAENOTEMPTY:
		OutputDebugString("WSAENOTEMPTY\n");
		break;      
	case WSAEPROCLIM:
		OutputDebugString("WSAEPROCLIM\n");
		break;       
	case WSAEUSERS:
		OutputDebugString("WSAEUSERS\n");
		break;         
	case WSAEDQUOT:
		OutputDebugString("WSAEDQUOT\n");
		break;         
	case WSAESTALE:
		OutputDebugString("WSAESTALE\n");
		break;         
	case WSAEREMOTE:
		OutputDebugString("WSAEREMOTE\n");
		break;        

	case WSAEDISCON:
		OutputDebugString("WSAEDISCON\n");
		break;        

	case WSASYSNOTREADY:
		OutputDebugString("WSASYSNOTREADY\n");
		break;
	case WSAVERNOTSUPPORTED:
		OutputDebugString("WSAVERNOTSUPPORTED\n");
		break;
	case WSANOTINITIALISED:
		OutputDebugString("WSANOTINITIALISED\n");
		break;
	case WSAHOST_NOT_FOUND:
		OutputDebugString("WSAHOST_NOT_FOUND\n");
		break;
	case WSATRY_AGAIN:
		OutputDebugString("WSATRY_AGAIN\n");
		break;
	case WSANO_RECOVERY:
		OutputDebugString("WSANO_RECOVERY\n");
		break;
	case WSANO_DATA:
		OutputDebugString("WSANO_DATA\n");
		break;
#if 0	// This one is a duplicate of WSANO_DATA
	case WSANO_ADDRESS:
		OutputDebugString("WSANO_ADDRESS\n");
		break;
#endif // 0
	}
}


void 
DumpMem(void *pv, int nLen)
{
	int n, nMax;
	struct {
		char szBytes[16][3];
		char c;
		char szAscii[17];
	} sRecord;
	unsigned char *puc;
	unsigned char uc;
	char				szGKDebug[80];

	puc = (unsigned char *)pv;
	while (nLen)
	{
		memset(&sRecord, ' ', sizeof(sRecord));
		sRecord.szBytes[15][2] = '\0';
		sRecord.szAscii[16] = '\0';

		nMax = (nLen < 16) ? nLen : 16;
		for (n = 0; n < nMax; n++)
		{
			uc = *(puc + n);
			wsprintf(&sRecord.szBytes[n][0], "%02X ", uc);
			sRecord.szAscii[n] = isprint(uc) ? uc : '.';
		}
		wsprintf(szGKDebug, "%p: %s '%s'\n", puc, &sRecord.szBytes[0][0], &sRecord.szAscii[0]);
		OutputDebugString(szGKDebug);
		puc += nMax;
		nLen -= nMax;
	}
}

#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dgkiexp.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiexp.h_v  $
*																		*
*	$Revision:   1.4  $
*	$Date:   11 Feb 1997 15:35:08  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiexp.h_v  $
 * 
 *    Rev 1.4   11 Feb 1997 15:35:08   CHULME
 * Added GKI_CleanupRequest function to offload DLL_PROCESS_DETACH
 * 
 *    Rev 1.3   10 Jan 1997 16:13:58   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   17 Dec 1996 18:22:28   CHULME
 * Switch src and destination fields on ARQ for Callee
 * 
 *    Rev 1.1   22 Nov 1996 15:25:14   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkiexp.h : header file
//

#ifndef DGKIEXP_H
#define DGKIEXP_H
#include "incommon.h"

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#if(0)  // it's all in one DLL
#define DLL_EXPORT __declspec(dllexport)
#define DLL_IMPORT __declspec(dllimport)
#else
#define DLL_EXPORT
#define DLL_IMPORT
#endif
// ------------------------ Variable Exports --------------------------
extern DLL_EXPORT DWORD	dwGKIDLLFlags;
extern DLL_EXPORT BOOL	fGKIEcho;
extern DLL_EXPORT BOOL  fGKIDontSend;

// ------------------------ Function Exports --------------------------
HRESULT DLL_EXPORT GKI_RegistrationRequest(long				lVersion,
										SeqTransportAddr	*pCallSignalAddr, 
										EndpointType		*pTerminalType,
										SeqAliasAddr		*pRgstrtnRqst_trmnlAls, 
										PCC_VENDORINFO      pVendorInfo,
										HWND				hWnd,
										WORD				wBaseMessage,
										unsigned short		usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_EXPORT GKI_UnregistrationRequest(void);

HRESULT DLL_EXPORT GKI_LocationRequest(SeqAliasAddr			*pLocationInfo);

HRESULT DLL_EXPORT GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
									SeqAliasAddr		*pRemoteInfo,
									TransportAddress	*pRemoteCallSignalAddress,
									SeqAliasAddr		*pDestExtraCallInfo,
									LPGUID				pCallIdentifier,
									BandWidth			bandWidth,
									ConferenceIdentifier	*pConferenceID,
									BOOL				activeMC,
									BOOL				answerCall,
									unsigned short		usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_EXPORT GKI_BandwidthRequest(HANDLE				hModCall, 
									unsigned short		usCallTypeChoice,
									BandWidth			bandWidth);

HRESULT DLL_EXPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_EXPORT GKI_Initialize(void);
HRESULT DLL_EXPORT GKI_CleanupRequest(void);

#ifdef _DEBUG
WORD DLL_EXPORT Dump_GKI_RegistrationRequest(long		lVersion, 
											SeqTransportAddr	*pCallSignalAddr, 
											EndpointType		*pTerminalType,
											SeqAliasAddr		*pRgstrtnRqst_trmnlAls, 
											HWND				hWnd,
											WORD				wBaseMessage,
											unsigned short		usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_EXPORT Dump_GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
										SeqAliasAddr		*pRemoteInfo,
										TransportAddress	*pRemoteCallSignalAddress,
										SeqAliasAddr		*pDestExtraCallInfo,
										BandWidth			bandWidth,
										ConferenceIdentifier	*pConferenceID,
										BOOL				activeMC,
										BOOL				answerCall,
										unsigned short		usCallTransport /* = ipAddress_chosen */);

WORD DLL_EXPORT Dump_GKI_LocationRequest(SeqAliasAddr	*pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif	// DGKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dgkiext.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiext.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   10 Jan 1997 16:14:02  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiext.h_v  $
 * 
 *    Rev 1.2   10 Jan 1997 16:14:02   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:22:20   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkiext.h : header file
//

#ifndef DGKIEXT_H
#define DGKIEXT_H

extern CGatekeeper		*g_pGatekeeper;
extern char				*pEchoBuff;
extern int				nEchoLen;
extern CRegistration	*g_pReg;
extern Coder			*g_pCoder;

#endif	// DGKIEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dgkilit.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkilit.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   08 Feb 1997 12:05:00  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkilit.h_v  $
 * 
 *    Rev 1.3   08 Feb 1997 12:05:00   CHULME
 * Added semaphore related literals for cleanly terminating retry thread
 * 
 *    Rev 1.2   10 Jan 1997 16:14:06   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:23:58   CHULME
 * Added VCS log to the header
*************************************************************************/

// dgkilit.h : header file
//

#ifndef DGKILIT_H
#define DGKILIT_H

#define WSVER_MAJOR				1
#define WSVER_MINOR				1

// registration retry constants
#define GKR_RETRY_TICK_MS   1000
#define GKR_RETRY_INTERVAL_SECONDS  5
#define GKR_RETRY_MAX               3

// call retry constants
#define GKCALL_RETRY_INTERVAL_SECONDS  5
#define GKCALL_RETRY_MAX               3

#define DEFAULT_RETRY_MS		5000
#define DEFAULT_MAX_RETRIES		3
#define DEFAULT_STATUS_PERIOD	(1500 * 1000)/GKR_RETRY_TICK_MS

//#define  GKREG_TIMER_ID 100

#define IPADDR_SZ				15
#define IPXADDR_SZ				21

#define GKIP_DISC_MCADDR		"224.0.1.41"
#define GKIP_DISC_PORT			1718
#define GKIP_RAS_PORT			1719

//TBD - Replace with real port numbers
#define GKIPX_DISC_PORT			12
#define GKIPX_RAS_PORT			34

// Thread related defs (in msecs)
#define TIMEOUT_SEMAPHORE			1000
#define TIMEOUT_THREAD				10000 

typedef InfoRequestResponse_perCallInfo_Element CallInfoStruct;

#endif	// DGKILIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dspider.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dspider.h_v  $
*																		*
*	$Revision:   1.2  $
*	$Date:   10 Jan 1997 16:14:18  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dspider.h_v  $
 * 
 *    Rev 1.2   10 Jan 1997 16:14:18   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:24:56   CHULME
 * Added VCS log to the header
*************************************************************************/

// dspider.h : header file
//

#ifndef DSPIDER_H
#define DSPIDER_H

#include "dgkiexp.h"	// need dwGKIDLLFlags

#ifdef _DEBUG
// Constants
const WORD SP_FUNC =	0x1;
const WORD SP_CONDES =	0x2;
const WORD SP_DEBUG =	0x4;
const WORD SP_NEWDEL =	0x8;
const WORD SP_THREAD =  0x10;
const WORD SP_STATE =	0x20;
const WORD SP_DUMPMEM = 0x40;
const WORD SP_XRS =     0x80;
const WORD SP_TEST =    0x100;
const WORD SP_LOGGER =  0x1000;
const WORD SP_PDU =		0x2000;
const WORD SP_WSOCK =	0x4000;
const WORD SP_GKI =		0x8000;


#ifdef TRACING_ENABLED

// TRACE Macros
#define SPIDER_TRACE(w, s, n)	if (dwGKIDLLFlags & w) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, s, n); \
	OutputDebugString(szGKDebug); }
#define SPIDER_DEBUG(n)			if (dwGKIDLLFlags & SP_DEBUG) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, #n "=%X\n", n); \
	OutputDebugString(szGKDebug); }
#define SPIDER_DEBUGS(n)		if (dwGKIDLLFlags & SP_DEBUG) {\
	wsprintf(szGKDebug, "%s,%d: ", __FILE__, __LINE__); \
	OutputDebugString(szGKDebug); \
	wsprintf(szGKDebug, #n "=%s\n", n); \
	OutputDebugString(szGKDebug); }
#else
#define SPIDER_TRACE(w, s, n)
#define SPIDER_DEBUG(n)
#define SPIDER_DEBUGS(s)
#endif


#else  // _DEBUG

#define SPIDER_TRACE(w, s, n)
#define SPIDER_DEBUG(n)
#define SPIDER_DEBUGS(s)
#define SpiderWSErrDecode(nRet)


#endif // _DEBUG

#endif // SPIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\dgkiprot.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\dgkiprot.h_v  $
*																		*
*	$Revision:   1.3  $
*	$Date:   17 Jan 1997 15:54:14  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\dgkiprot.h_v  $
 * 
 *    Rev 1.3   17 Jan 1997 15:54:14   CHULME
 * Put debug function prototype on conditionals to avoid release warnings
 * 
 *    Rev 1.2   10 Jan 1997 16:14:10   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.1   22 Nov 1996 15:25:06   CHULME
 * Added VCS log to the header
*************************************************************************/

// DGKIPROT.H : header file
//

#ifndef DGKIPROTO_H
#define DGKIPROTO_H

#ifdef _DEBUG
void SpiderWSErrDecode(int nErr);
void DumpMem(void *pv, int nLen);
#endif

void PostReceive(void *);
void Retry(void *);
#ifdef BROADCAST_DISCOVERY
void GKDiscovery(void *);
#endif

#endif	// DGKIPROTO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\discover.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\discover.cpv  $
*																		*
*	$Revision:   1.10  $
*	$Date:   13 Feb 1997 16:20:44  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\discover.cpv  $
// 
//    Rev 1.10   13 Feb 1997 16:20:44   CHULME
// Moved CGatekeeper::Unlock to end of Discover thread for synchronization
// 
//    Rev 1.9   12 Feb 1997 01:11:00   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.8   08 Feb 1997 12:12:06   CHULME
// Changed from using unsigned long to HANDLE for thread handles
// 
//    Rev 1.7   24 Jan 1997 18:36:06   CHULME
// Reverted to rev 1.5
// 
//    Rev 1.5   22 Jan 1997 16:53:06   CHULME
// Reset the gatekeeper reject flag before issuing discovery request
// 
//    Rev 1.4   17 Jan 1997 09:01:54   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.3   10 Jan 1997 16:14:14   CHULME
// Removed MFC dependency
// 
//    Rev 1.2   22 Nov 1996 15:20:46   CHULME
// Added VCS log to the header
*************************************************************************/

// discovery.cpp : Provides the discovery thread implementation
//
#include "precomp.h"

#include <process.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "gksocket.h"
#include "GKREG.H"
#include "GATEKPR.H"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifdef BROADCAST_DISCOVERY
void 
GKDiscovery(void *pv)
{
	// ABSTRACT:  This function is invoked in a separate thread to
	//            issue a gatekeeper discovery PDU (GRQ) and listen for a
	//            responding GCF and/or GRJ.  If successful, it will then
	//            issue a registration request (RRQ).
	// AUTHOR:    Colin Hulme

	char			szBuffer[512];
	int				nRet;
	ASN1_BUF		Asn1Buf;
	DWORD			dwErrorCode;
	RasMessage		*pRasMessage;
	char			*pDestAddr;
	HANDLE			hThread;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif
	HRESULT			hResult = GKI_OK;

	SPIDER_TRACE(SP_FUNC, "GKDiscovery()\n", 0);
	ASSERT(g_pCoder && g_pGatekeeper);
	if ((g_pCoder == NULL) && (g_pGatekeeper == NULL))
		return;	
		
	g_pGatekeeper->SetRejectFlag(FALSE);	// Reset the reject flag

	// Send Async informational notification to client that we are doing a discovery
	SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_REG_DISCOVERY, 0, 0)\n", 0);
	PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_REG_DISCOVERY, 0, 0);

	// Send a broadcast on the gatekeeper discovery port
	if ((hResult = g_pReg->GatekeeperRequest()) != GKI_OK)
	{
		SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
		PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
	}

	while (hResult == GKI_OK)
	{
		nRet = g_pReg->m_pSocket->ReceiveFrom(szBuffer, 512);

		g_pGatekeeper->Lock();
		if (g_pReg == 0)
		{
			SPIDER_TRACE(SP_THREAD, "Discovery thread exiting\n", 0);
			g_pGatekeeper->Unlock();
			return;
		}

		if (nRet != SOCKET_ERROR)
		{
			if (fGKIEcho && (pEchoBuff != 0))
			{
				if (nEchoLen != nRet)
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer len != Sent buffer len ***\n", 0);
				}
				if (memcmp(szBuffer, pEchoBuff, nEchoLen) == 0)
				{
					SPIDER_TRACE(SP_DEBUG, "Received buffer = Sent buffer\n", 0);
				}
				else
				{
					SPIDER_TRACE(SP_DEBUG, "*** Received buffer != Sent buffer ***\n", 0);
				}
				SPIDER_TRACE(SP_NEWDEL, "del pEchoBuff = %X\n", pEchoBuff);
				delete pEchoBuff;
				pEchoBuff = 0;
				hResult = GKI_EXIT_THREAD;
			}
			else	// Check incoming PDU for GCF or GRJ
			{
				// Setup Asn1Buf for decoder and decode PDU
				Asn1Buf.length = nRet;	// number of bytes received
				Asn1Buf.value = (unsigned char *)szBuffer;
				dwErrorCode = g_pCoder->Decode(&Asn1Buf, &pRasMessage);
				if (dwErrorCode)
				{
					SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_DECODER_ERROR)\n", 0);
					PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_DECODER_ERROR);
				}

				else
				{
#ifdef _DEBUG
					if (dwGKIDLLFlags & SP_DUMPMEM)
						DumpMem(pRasMessage, sizeof(RasMessage));
#endif
					switch (pRasMessage->choice)
					{
					case gatekeeperConfirm_chosen:
						SPIDER_TRACE(SP_PDU, "Rcv GCF; g_pReg = %X\n", g_pReg);
						hResult = g_pReg->GatekeeperConfirm(pRasMessage);
						if (hResult != GKI_OK)
						{
							SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
							PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
																				hResult);
						}
//////////////////////////////////////////////////////////////////////////////////////////
						else
						{
							pDestAddr = (g_pReg->GetRegistrationTransport() == ipAddress_chosen) ? 
									g_pGatekeeper->GetIPAddress() : g_pGatekeeper->GetIPXAddress();

							// Connect to destination gatekeeper and retrieve RAS port
							if (g_pReg->m_pSocket->Connect(pDestAddr))
							{
								hResult = GKI_WINSOCK2_ERROR(g_pReg->m_pSocket->GetLastError());
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
							}

							// Create RegistrationRequest structure - Encode and send PDU
							if ((hResult = g_pReg->RegistrationRequest(TRUE)) != GKI_OK)
							{
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, hResult);
							}

							// Post a receive on this socket
							hThread = (HANDLE)_beginthread(PostReceive, 0, 0);
							SPIDER_TRACE(SP_THREAD, "_beginthread(PostReceive, 0, 0); <%X>\n", hThread);
							if (hThread == (HANDLE)-1)
							{
								SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, GKI_NO_THREAD)\n", 0);
								PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, GKI_NO_THREAD);
							}
							g_pReg->SetRcvThread(hThread);

							if (hResult == GKI_OK)
								hResult = GKI_GCF_RCV;
						}

						break;
					case gatekeeperReject_chosen:
						SPIDER_TRACE(SP_PDU, "Rcv GRJ; g_pReg = %X\n", g_pReg);
						hResult = g_pReg->GatekeeperReject(pRasMessage);
						if (hResult != GKI_OK)
						{
							SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
							PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
													hResult);
						}
						break;
					default:
						SPIDER_TRACE(SP_PDU, "Rcv %X\n", pRasMessage->choice);
						hResult = g_pReg->UnknownMessage(pRasMessage);
						break;
					}
				}

				// Free the encoder memory
				g_pCoder->Free(pRasMessage);
			}
		}
		else
		{
			// WSAEINTR - returned when socket closed
			//            get out cleanly
			if ((nRet = g_pReg->m_pSocket->GetLastError()) == WSAEINTR)
				hResult = GKI_GCF_RCV;

			else
			{
				hResult = GKI_WINSOCK2_ERROR(nRet);
				SPIDER_TRACE(SP_GKI, "PostMessage(m_hWnd, m_wBaseMessage + GKI_ERROR, 0, %X)\n", hResult);
				PostMessage(g_pReg->GetHWnd(), g_pReg->GetBaseMessage() + GKI_ERROR, 0, 
											hResult);
				hResult = GKI_EXIT_THREAD;
			}
		}
		g_pGatekeeper->Unlock();
	}

	// If not successful - need to remove retry thread and registration object
	g_pGatekeeper->Lock();
	if (g_pReg == 0)
	{
		SPIDER_TRACE(SP_THREAD, "Discovery thread exiting\n", 0);
		g_pGatekeeper->Unlock();
		return;
	}

	if (hResult != GKI_GCF_RCV)
	{
		SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
		delete g_pReg;
		g_pReg = 0;
	}
	else
		g_pReg->SetDiscThread(0);

	SPIDER_TRACE(SP_THREAD, "GKDiscovery thread exiting\n", 0);
	
	g_pGatekeeper->Unlock();
}
#endif // BROADCAST_DISCOVERY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\fsminit.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsminit.c                                                 *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMINIT.C  $
 * $Revision:   1.2  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSMINIT.C_v  $
 * 
 *    Rev 1.2   09 Dec 1996 13:34:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.1   29 May 1996 15:20:16   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.0   09 May 1996 21:06:16   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.11.1.3   09 May 1996 19:48:42   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.11.1.2   15 Apr 1996 10:46:12   EHOWARDX
 * Update.
 *
 *    Rev 1.11.1.1   10 Apr 1996 21:15:38   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.11.1.0   05 Apr 1996 12:32:40   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"



/*
 *  NAME
 *      Fsm_init - allocate and initialize memory for FSM instance
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_ALREADY_INIT FSM instance exists for specified dwInst
 */

HRESULT
Fsm_init(struct InstanceStruct *pInstance)
{
    pInstance->StateMachine.sv_STATUS = INDETERMINATE;
    return H245_ERROR_OK;
}



/*
 *  NAME
 *      Fsm_shutdown - cleanup FSM instance and deallocate instance memory
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current instance
 *
 *  RETURN VALUE
 *      H245_ERROR_OK           function succeeded
 *      H245_ERROR_INVALID_INST on FSM instance exists for specified dwInst
 */


HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance)
{
    register int            i;

    for (i = 0; i < NUM_ENTITYS; ++i)
    {
        while (pInstance->StateMachine.Object_tbl[i])
        {
            H245TRACE(pInstance->dwInst, 2, "Fsm_shutdown: deallocating state entity %d", i);
            ObjectDestroy(pInstance->StateMachine.Object_tbl[i]);
        }
    }
    return H245_ERROR_OK;
} // Fsm_shutdown()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\fsmapi.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsmapi.c                                                  *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMAPI.C  $
 * $Revision:   1.12  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log L:\mphone\h245\h245env\comm\h245_3\h245_fsm\vcs\src\fsmapi.c_v $
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "h245deb.x"



extern char *EntityName[];



/*
 * This table maps FSM stateless events into H.245 API events
 */
static WORD StatelessTable[NUM_EVENTS - NUM_STATE_EVENTS] =
{
  H245_IND_NONSTANDARD_REQUEST,     // NonStandardRequestPDU
  H245_IND_NONSTANDARD_RESPONSE,    // NonStandardResponsePDU
  H245_IND_NONSTANDARD_COMMAND,     // NonStandardCommandPDU
  H245_IND_NONSTANDARD,             // NonStandardIndicationPDU
  H245_IND_MISC_COMMAND,            // MiscellaneousCommandPDU
  H245_IND_MISC,                    // MiscellaneousIndicationPDU
  H245_IND_COMM_MODE_REQUEST,       // CommunicationModeRequestPDU
  H245_IND_COMM_MODE_RESPONSE,      // CommunicationModeResponsePDU
  H245_IND_COMM_MODE_COMMAND,       // CommunicationModeCommandPDU
  H245_IND_CONFERENCE_REQUEST,      // ConferenceRequestPDU
  H245_IND_CONFERENCE_RESPONSE,     // ConferenceResponsePDU
  H245_IND_CONFERENCE_COMMAND,      // ConferenceCommandPDU
  H245_IND_CONFERENCE,              // ConferenceIndicationPDU
  H245_IND_SEND_TERMCAP,            // SendTerminalCapabilitySetPDU
  H245_IND_ENCRYPTION,              // EncryptionCommandPDU
  H245_IND_FLOW_CONTROL,            // FlowControlCommandPDU
  H245_IND_ENDSESSION,              // EndSessionCommandPDU
  H245_IND_FUNCTION_NOT_UNDERSTOOD, // FunctionNotUnderstoodIndicationPDU
  H245_IND_JITTER,                  // JitterIndicationPDU
  H245_IND_H223_SKEW,               // H223SkewIndicationPDU
  H245_IND_NEW_ATM_VC,              // NewATMVCIndicationPDU
  H245_IND_USERINPUT,               // UserInputIndicationPDU
  H245_IND_H2250_MAX_SKEW,          // H2250MaximumSkewIndicationPDU
  H245_IND_MC_LOCATION,             // MCLocationIndicationPDU
  H245_IND_VENDOR_ID,               // VendorIdentificationIndicationPDU
  H245_IND_FUNCTION_NOT_SUPPORTED,  // FunctionNotSupportedIndicationPDU
};



/*
 * Configurable counter values
 */

unsigned int    uN100 = 10;              // Master Slave Determination



/*
 * Configurable timer values
 */

unsigned int    uT101 = 30000;          // Capability Exchange
unsigned int    uT102 = 30000;          // Maintenance Loop
unsigned int    uT103 = 30000;          // Logical Channel Signalling
unsigned int    uT104 = 30000;          // H.223 Multiplex Table
unsigned int    uT105 = 30000;          // Round Trip Delay
unsigned int    uT106 = 30000;          // Master Slave Determination
unsigned int    uT107 = 30000;          // Request Multiplex Entry
unsigned int    uT108 = 30000;          // Send Logical Channel
unsigned int    uT109 = 30000;          // Mode Request



/*
 *  NAME
 *      ObjectCreate - create an State Entity object
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance data
 *      INPUT   Entity      State Entity represented by object, e.g. LCSE_OUT
 *      INPUT   Key         Lookup key for distinguish multiple instances of SE
 *      INPUT   dwTransId   Transaction identifier to be sent up to client
 *
 *  RETURN VALUE
 *      pObject     Function succeeded
 *      NULL        Memory allocation failed
 */

Object_t *
ObjectCreate(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key, DWORD_PTR dwTransId)
{
    register Object_t * pObject;

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%s(%d) Key=%d dwTransID=0x%p",
              EntityName[Entity], Entity, Key, dwTransId);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectCreate: Entity=%d Key=%d dwTransID=0x%p",
              Entity, Key, dwTransId);
#endif

    pObject = (Object_t *)MemAlloc(sizeof(*pObject));
    if (pObject == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectCreate: FSM Object memory allocation failed");
        return NULL;
    }
    memset(pObject, 0, sizeof(*pObject));

    /* copy primitive variables to my object */
    pObject->pInstance   = pInstance;
    pObject->dwInst      = pInstance->dwInst;
    pObject->dwTransId   = dwTransId;
    pObject->Key         = Key;
    pObject->Entity      = Entity;

    pObject->pNext       = pInstance->StateMachine.Object_tbl[Entity];
    pInstance->StateMachine.Object_tbl[Entity] = pObject;

    return pObject;
} // ObjectCreate()



/*
 *  NAME
 *      ObjectDestroy - deallocate an object created by ObjectCreate()
 *
 *
 *  PARAMETERS
 *  INPUT   pInst       pointer to FSM instance data
 *  INPUT   id          index into the object table
 *
 *  RETURN VALUE
 *      FALSE           object deallocated
 *      TRUE            object not found
 */

int
ObjectDestroy(Object_t *pObject)
{
    struct InstanceStruct * pInstance;
    Object_t *              pSearch;
    Object_t *              pPrev;

    ASSERT(pObject != NULL);
    ASSERT(pObject->uNestLevel == 0);
    ASSERT(pObject->pInstance != NULL);
    pInstance = pObject->pInstance;

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%s(%d) Key=%d State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->Key, pObject->State);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectDestroy: Entity=%d Key=%d State=%d",
              pObject->Entity, pObject->Key, pObject->State);
#endif

    if (pObject->dwTimerId)
    {
        H245TRACE(pObject->dwInst, 4, "ObjectDestroy: stoping timer");
        FsmStopTimer(pObject);
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == NULL)
    {
        H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: no State Entity of specified type found");
        return TRUE;
    }

    if (pInstance->StateMachine.Object_tbl[pObject->Entity] == pObject)
    {
        pInstance->StateMachine.Object_tbl[pObject->Entity] = pObject->pNext;
        MemFree(pObject);
        return FALSE;
    }

    pPrev = pInstance->StateMachine.Object_tbl[pObject->Entity];
    pSearch = pPrev->pNext;
    while (pSearch != NULL)
    {
        if (pSearch == pObject)
        {
            pPrev->pNext = pSearch->pNext;
            MemFree(pObject);
            return FALSE;
        }
        pPrev = pSearch;
        pSearch = pSearch->pNext;
    }

    H245TRACE(pInstance->dwInst, 1, "ObjectDestroy: State Entity not found");
    return TRUE;
} // ObjectDestroy()



/*
 *  NAME
 *      ObjectFind - given parsed information of a PDU, it searches the object table for
 *                         an object with a matching id, type and category
 *
 *
 *  PARAMETERS
 *  INPUT    pInst
 *  INPUT    Category       category of a given PDU
 *  INPUT    Type           type of the PDU
 *  INPUT    pdu_id         unique id shared by PDU and object (usually channel number or sequence number)
 *
 *  RETURN VALUE
 *      pObject   object found
 *      NULL      object not found
 */

Object_t *
ObjectFind(struct InstanceStruct *pInstance, Entity_t Entity, Key_t Key)
{
    register Object_t * pObject;

    ASSERT(Entity < STATELESS);
    pObject = pInstance->StateMachine.Object_tbl[Entity];
    while (pObject != NULL)
    {
        if (pObject->Key == Key)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object found",
                      EntityName[Entity], Key);
#else
            H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object found",
                      Entity, Key);
#endif
            return pObject;
        }
        pObject = pObject->pNext;
    }

#if defined(_DEBUG)
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%s, %d) object not found",
              EntityName[Entity], Key);
#else
    H245TRACE(pInstance->dwInst, 4, "ObjectFind(%d, %d) object not found",
              Entity, Key);
#endif
    return NULL;
} // ObjectFind()



/*
 *  NAME
 *      SendFunctionNotUnderstood - builds and sends Function Not Supported PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst   Current H.245 instance
 *      INPUT   pPdu     Not supported PDU
 *
 *  RETURN VALUE
 *      H245_ERROR_OK
 */


HRESULT
SendFunctionNotUnderstood(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    PDU_t *             pOut;
    HRESULT             lError;

    pOut = MemAlloc(sizeof(*pOut));
    if (pOut == NULL)
    {
        return H245_ERROR_NOMEM;
    }

    switch (pPdu->choice)
    {
    case MltmdSystmCntrlMssg_rqst_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_request_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_request =
          pPdu->u.MltmdSystmCntrlMssg_rqst;
        break;

    case MSCMg_rspns_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_response_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_response =
          pPdu->u.MSCMg_rspns;
        break;

    case MSCMg_cmmnd_chosen:
        pOut->u.indication.u.functionNotUnderstood.choice = FnctnNtUndrstd_command_chosen;
        pOut->u.indication.u.functionNotUnderstood.u.FnctnNtUndrstd_command =
          pPdu->u.MSCMg_cmmnd;
        break;

    default:
        // Can't reply to unsupported indication...
        MemFree(pOut);
        return H245_ERROR_OK;
    } // switch (Type)

    pOut->choice = indication_chosen;
    pOut->u.indication.choice = functionNotUnderstood_chosen;
    lError = sendPDU(pInstance, pOut);
    MemFree(pOut);
    return lError;
} // SendFunctionNotUnderstood()



/*
 *  NAME
 *      FsmOutgoing - process outbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   pInst       Pointer to FSM instance structure
 *      INPUT   pPdu        Pointer to PDU to send
 *      INPUT   dwTransId   Transaction identifier to use for response
 *
 *  RETURN VALUE
 *      Error codes defined in h245com.h
 */

HRESULT
FsmOutgoing(struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD_PTR dwTransId)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;

    ASSERT(pInstance != NULL);
    ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmOutgoing");

#if defined(_DEBUG)
    if (check_pdu(pInstance, pPdu))
      return H245_ERROR_ASN1;
#endif // (DEBUG)

    lError = PduParseOutgoing(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmOutgoing: PDU not recognized; Error=%d", lError);
        return lError;
    }

    ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmOutgoing: Sending stateless PDU");
        return sendPDU(pInstance, pPdu);
    }

    ASSERT(Event < NUM_STATE_EVENTS);

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)
    {
        if (bCreate == FALSE)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmOutgoing: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, dwTransId);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmOutgoing: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }
    else
    {
        pObject->dwTransId = dwTransId;
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmOutgoing()



/*
 *  NAME
 *      FsmIncoming - process inbound PDU
 *
 *
 *  PARAMETERS
 *      INPUT   dwInst      current H.245 instance
 *      INPUT   pPdu        pointer to a PDU structure
 *
 *  RETURN VALUE
 *      error codes defined in h245com.h (not checked)
 */

HRESULT
FsmIncoming(struct InstanceStruct *pInstance, PDU_t *pPdu)
{
    HRESULT             lError;
    Entity_t            Entity;
    Event_t             Event;
    Key_t               Key;
    int                 bCreate;
    Object_t *          pObject;
    Object_t *          pObject1;

    ASSERT(pInstance != NULL);
    ASSERT(pPdu != NULL);
    H245TRACE(pInstance->dwInst, 4, "FsmIncoming");

    lError = PduParseIncoming(pInstance, pPdu, &Entity, &Event, &Key, &bCreate);
    if (lError != H245_ERROR_OK)
    {
        H245TRACE(pInstance->dwInst, 1,
          "FsmIncoming: Received PDU not recognized", lError);
        SendFunctionNotUnderstood(pInstance, pPdu);
        return lError;
    }

    ASSERT(Entity < NUM_ENTITYS);

    if (Entity == STATELESS)
    {
        H245TRACE(pInstance->dwInst, 4, "FsmIncoming: Received stateless PDU");
        return H245FsmIndication(pPdu, (DWORD)StatelessTable[Event - NUM_STATE_EVENTS], pInstance, 0, H245_ERROR_OK);
    }

    ASSERT(Event < NUM_STATE_EVENTS);

    if (Event == MaintenanceLoopOffCommandPDU)
    {
        // Special case MaintenanceLoopOff applies to ALL loops
        ASSERT(Entity == MLSE_IN);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        if (pObject == NULL)
        {
            return H245_ERROR_OK;
        }
        lError = StateMachine(pObject, pPdu, Event);
        pObject = pInstance->StateMachine.Object_tbl[Entity];
        while (pObject)
        {
            if (pObject->uNestLevel == 0)
            {
                pObject1 = pObject;
                pObject  = pObject->pNext;
                ObjectDestroy(pObject1);
            }
            else
            {
                pObject->State = 0;
                pObject = pObject->pNext;
            }
        }
        return lError;
    } // if

    pObject = ObjectFind(pInstance, Entity, Key);
    if (pObject == NULL)

    {
        if (bCreate == FALSE)
        {
#if defined(_DEBUG)
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %s(%d) not found; Key=%d",
                      EntityName[Entity], Entity, Key);
#else
            H245TRACE(pInstance->dwInst, 1,
                      "FsmIncoming: State Entity %d not found; Key=%d",
                      Entity, Key);
#endif
            return H245_ERROR_PARAM;
        }
        pObject = ObjectCreate(pInstance, Entity, Key, 0);
        if (pObject == NULL)
        {
            H245TRACE(pInstance->dwInst, 1, "FsmIncoming: State Entity memory allocation failed");
            return H245_ERROR_NOMEM;
        }
    }

    return StateMachine(pObject, pPdu, Event);
} // FsmIncoming()


// CAVEAT: Need to save dwInst since StateMachine() might deallocate pObject!
HRESULT
FsmTimerEvent(struct InstanceStruct *pInstance, DWORD_PTR dwTimerId, Object_t *pObject, Event_t Event)
{
    ASSERT(pInstance != NULL);
    ASSERT(pObject   != NULL);
    ASSERT(pObject->pInstance == pInstance);
    ASSERT(pObject->dwTimerId == dwTimerId);
    H245TRACE(pInstance->dwInst, 4, "FsmTimerEvent");
    pObject->dwTimerId = 0;
    return StateMachine(pObject, NULL, Event);
} // FsmTimerEvent()

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\fsmexpor.h ===
/***********************************************************************
 *                                                                     *
 * Filename: FSMEXPOR.H                                                *
 * Module:   H245 SubSystem                                            *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSMEXPOR.H  $
 * $Revision:   1.6  $
 * $Modtime:   09 Dec 1996 13:40:40  $
 * $Log:   S:/STURGEON/SRC/H245/INCLUDE/VCS/FSMEXPOR.H_v  $
 *
 *    Rev 1.6   09 Dec 1996 13:40:44   EHOWARDX
 * Updated copyright notice.
 *
 *    Rev 1.5   19 Jul 1996 12:02:54   EHOWARDX
 * Eliminated event definitions. FSM functions now use same events as API,
 * which are defined in H245API.H.
 *
 *    Rev 1.4   30 May 1996 23:38:14   EHOWARDX
 * Cleanup.
 *
 *    Rev 1.3   29 May 1996 15:21:26   EHOWARDX
 * Change to use HRESULT.
 *
 *    Rev 1.2   28 May 1996 14:09:52   EHOWARDX
 * Tel Aviv update.
 *
 ***********************************************************************/

#include "h245asn1.h"

typedef MltmdSystmCntrlMssg PDU_t;

/* FSM initialization */
HRESULT
Fsm_init    (struct InstanceStruct *pInstance);

/* FSM shutdown */
HRESULT
Fsm_shutdown(struct InstanceStruct *pInstance);

/* Process PDU received from remote peer */
HRESULT
FsmIncoming (struct InstanceStruct *pInstance, PDU_t *pPdu);

/* Process PDU from H.245 client */
HRESULT
FsmOutgoing (struct InstanceStruct *pInstance, PDU_t *pPdu, DWORD_PTR dwTransId);

/* send a confirm to API */
HRESULT
H245FsmConfirm    (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD_PTR              dwTransId,
                   HRESULT                lError);

/* send an indication to API */
HRESULT
H245FsmIndication (PDU_t                 *pPdu,
                   DWORD                  dwEvent,
                   struct InstanceStruct *pInstance,
                   DWORD_PTR              dwTransId,
                   HRESULT                lError);



/*********************************/
/* Errors passed up to the API */
/*********************************/

/* Session initialization indications */
#define SESSION_INIT            2101 /* after first term cap exchange */
#define SESSION_FAILED          2102 /* 1st Term caps failed */

 /* finite state machine is successful */
#define FSM_OK                  0
 /* define one reject for all requests */
#define REJECT                  2100

/* define one timer expiry error for all signallling entities */
#define TIMER_EXPIRY            2200

/* master slave failed */
#define MS_FAILED               2105

/* open unidirectional/bidirectional errors */
#define ERROR_A_INAPPROPRIATE   2106    /* inappropriate message */
#define ERROR_B_INAPPROPRIATE   2107    /* inappropriate message */
#define ERROR_C_INAPPROPRIATE   2108    /* inappropriate message */
#define ERROR_D_TIMEOUT         2109    /* timeout               */
#define ERROR_E_INAPPROPRIATE   2110    /* inappropriate message */
#define ERROR_F_TIMEOUT         2111    /* Timer expiry at incoming BLCSE */

extern unsigned int     uN100;          // Master Slave Determination
extern unsigned int     uT101;          // Capability Exchange
extern unsigned int     uT102;          // Maintenance Loop
extern unsigned int     uT103;          // Logical Channel Signalling
extern unsigned int     uT104;          // H.223 Multiplex Table
extern unsigned int     uT105;          // Round Trip Delay
extern unsigned int     uT106;          // Master Slave Determination
extern unsigned int     uT107;          // Request Multiplex Entry
extern unsigned int     uT108;          // Send Logical Channel
extern unsigned int     uT109;          // Mode Request

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkerror.h ===
/***********************************************************************
 *																		*
 *	INTEL CORPORATION PROPRIETARY INFORMATION							*
 *																		*
 *	This software is supplied under the terms of a license			   	*
 *	agreement or non-disclosure agreement with Intel Corporation		*
 *	and may not be copied or disclosed except in accordance	   			*
 *	with the terms of that agreement.									*
 *																		*
 *	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
 *																		*
 *	$Archive:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 *
 *	$Revision:   1.18  $
 *	$Date:   16 Jan 1997 15:25:06  $
 *
 *	$Author:   BPOLING  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkerror.h_v  $
 * 
 *    Rev 1.18   16 Jan 1997 15:25:06   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.17   19 Dec 1996 18:46:44   BPOLING
 * added error code for no call signal address left in a user.
 * 
 *    Rev 1.16   18 Dec 1996 21:48:16   AKLEMENT
 * Fixed an error code for GWInfo.cpp
 * 
 *    Rev 1.14   18 Dec 1996 17:02:58   AKLEMENT
 * Added more GKInfo error codes.
 * 
 *    Rev 1.13   17 Dec 1996 19:20:02   AKLEMENT
 * Added GWInfo error codes.
 * 
 *    Rev 1.12   11 Dec 1996 13:32:44   AKLEMENT
 * Fixed the Prop Info header.
 * 
 *    Rev 1.11   10 Dec 1996 15:55:02   AKLEMENT
 * Added Resource Reading error define.
 * 
 *    Rev 1.10   10 Dec 1996 01:23:58   BPOLING
 * added a new error code for sending RRJ Undefined Reason.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:34   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   04 Dec 1996 10:43:18   BPOLING
 * added a new message id to post to h/i.
 * 
 *    Rev 1.7   04 Dec 1996 10:14:46   BPOLING
 * added error code for invalid ip address
 * 
 *    Rev 1.6   21 Nov 1996 13:06:18   BPOLING
 * added error code for HI PostMessage decoding.
 * 
 *    Rev 1.5   15 Nov 1996 14:38:18   BPOLING
 * vcs log fix.
 *                                                                     * 
 ***********************************************************************/

#ifndef GK_ERROR_H
#define GK_ERROR_H

#define GK_NOERROR					0

// WIN32 system error 000

#define GK_MEMORY_ERROR				1
#define GK_REGCREATEKEY_FAILED 		2
#define GK_GUID_ERROR				3
#define GK_EXCEPTION				4
#define GK_RESOURCE_ERROR			5

// Service related 100

#define GK_INVALID_ARG 				101
#define GK_NOARGS					102
#define GK_STARTSERVICE_FAILED		103
#define GK_EXIT						104

// User Class Errors 200

#define GK_USER_NOTINITIALIZED		201
#define GK_NOUSERFOUND				202
#define GK_EMPTYSEQUENCE			203
#define GK_TRANSPORTNOTFOUND		204
#define GK_ALIASNOTFOUND			205
#define GK_NO_CALLSIG				206

// Engine related Errors 300

#define GK_XRSRESPONSE				301
#define GK_NORESPONSE				303
#define GK_INVALIDMESSAGE			304
#define GK_SENDRRJ_NEEDGRQ			305
#define GK_XRSMESSAGERECEIVED		306
#define GK_NSMMESSAGERECEIVED		307
#define GK_BADENDPOINTID			308
#define GK_SENDGRJ_TERMEX			309
#define GK_SENDRRJ_UNDEFINED		310

// Ras Map related errors 400

#define GK_NORASFOUND		  	401
#define GK_RASFOUND				402
#define GK_DUPLICATERAS			403
#define GK_RAS_NOTINITIALIZED	404
#define GK_RAS_NOT_UNIQUE		405

// Sockets related errors 500

#define GK_NOPORT					501
#define GK_NOHOSTNAME				502
#define GK_UNSUPPORTEDPROTOCOL		503
#define GK_PROTOCOLNOTFOUND			504
#define GK_INVALIDPDUTYPE			505
#define GK_SOCKETSERROR				506
#define GK_RESPONSE					507
#define GK_INVALID_IPADDRESS		508

// Bound Map related errors 600

#define GK_NOBOUNDFOUND				601
#define GK_BOUNDFOUND				602
#define GK_DUPLICATEBOUND			603
#define GK_BOUND_NOTINITIALIZED		604
#define GK_BOUNDLOCKED				607
#define GK_BOUNDNOTLOCKED			608

// CONF Map related errors 700

#define GK_NOCONFFOUND				701
#define GK_CONFFOUND				702
#define GK_DUPLICATECONF			703
#define GK_CONF_NOTINITIALIZED		704
#define GK_NOT_IN_CONF				706
#define GK_INVALID_REQUEST			707
#define GK_CONFDELETE				708
#define GK_CONFCREATEFAILED			709


// PDU Error return codes 800

#define GK_ARJ_REQUEST_DENIED		800
#define GK_ARJ_UNDEFINED_REASON		801

// Alias CMap Errors 900

#define GK_ALIAS_NOTINITIALIZED		900
#define GK_ALIAS_NOT_UNIQUE			901
#define GK_ALIASFOUND				902
#define GK_NOALIASFOUND				903

// Guid Map related errors 1000

#define GK_NOGUIDFOUND				1001
#define GK_GUIDFOUND				1002
#define GK_DUPLICATEGUID			1003
#define GK_GUIDINUSE				1004
#define GK_GUID_NOTINITIALIZED		1005

// Call Sig CMap Errors 1100

#define GK_CALLSIG_NOTINITIALIZED		1100
#define GK_CALLSIG_NOT_UNIQUE			1101
#define GK_CALLSIGFOUND					1102
#define GK_NOCALLSIGFOUND				1103

// Call Errors 1200

#define GK_NOCALLFOUND					1200
#define GK_DIDNOTPURGE					1201
#define GK_CALL_NOTINITIALIZED			1202
#define GK_CALL_CREATE					1203
#define GK_CALL_DELETE					1204
#define GK_CALL_CHANGE					1205
#define GK_CALL_TIMER					1206

// Bandwidth Manager Errors 1300

#define GK_INVALID_BANDWIDTH			1300
#define GK_EXTERNAL_EXCEEDS_INTERNAL	1301
#define GK_NO_AVAILABLE_BANDWIDTH		1302
#define GK_USEDBW_WENT_NEGATIVE			1303
#define GK_LESS_AVAILABLE_BANDWIDTH		1304

// Logger Errors 1400

#define GK_LOGGING_IS_OFF				1400
#define GK_FILE_NOT_OPEN				1401
#define GK_COULD_NOT_OPEN_FILE			1402
#define GK_FILE_ALREADY_OPEN			1403
#define GK_NAME_USED_FOR_LOG			1404
#define GK_COULD_NOT_MAKE_DIR			1405

// GWInfo Errors 1500
#define GK_WRONG_PDU					1500
#define GK_NOT_GATEWAY					1501
#define GK_PROTOCOL_NOT_PRESENT			1502
#define GK_GW_NOT_FOUND					1503
#define GK_GW_NOT_REQUIRED				1504
#define GK_PREFIX_RESERVED				1505
#define GK_NO_DEST_INFO_SPECIFIED		1506

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\fsm.c ===
/***********************************************************************
 *                                                                     *
 * Filename: fsm.c                                                     *
 * Module:   H245 Finite State Machine Subsystem                       *
 *                                                                     *
 ***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1996 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *                                                                     *
 * $Workfile:   FSM.C  $
 * $Revision:   1.5  $
 * $Modtime:   09 Dec 1996 13:34:24  $
 * $Log:   S:/STURGEON/SRC/H245/SRC/VCS/FSM.C_v  $
 * 
 *    Rev 1.5   09 Dec 1996 13:34:28   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.4   02 Jul 1996 00:09:24   EHOWARDX
 * 
 * Added trace of state after state machine function called.
 * 
 *    Rev 1.3   30 May 1996 23:39:04   EHOWARDX
 * Cleanup.
 * 
 *    Rev 1.2   29 May 1996 15:20:12   EHOWARDX
 * Change to use HRESULT.
 * 
 *    Rev 1.1   28 May 1996 14:25:48   EHOWARDX
 * Tel Aviv update.
 * 
 *    Rev 1.0   09 May 1996 21:06:12   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.16.1.4   09 May 1996 19:48:34   EHOWARDX
 * Change TimerExpiryF function arguements.
 * 
 *    Rev 1.16.1.3   25 Apr 1996 17:00:18   EHOWARDX
 * Minor fixes.
 * 
 *    Rev 1.16.1.2   15 Apr 1996 10:45:38   EHOWARDX
 * Update.
 *
 *    Rev 1.16.1.1   10 Apr 1996 21:16:06   EHOWARDX
 * Check-in for safety in middle of re-design.
 *
 *    Rev 1.16.1.0   05 Apr 1996 12:21:16   EHOWARDX
 * Branched.
 *                                                                     *
 ***********************************************************************/

#include "precomp.h"

#include "h245api.h"
#include "h245com.h"
#include "h245fsm.h"
#include "openu.h"
#include "openb.h"
#include "rqstcls.h"
#include "termcap.h"
#include "muxentry.h"
#include "rmese.h"
#include "mrse.h"
#include "mlse.h"
#include "mstrslv.h"
#include "rtdse.h"



#if defined(_DEBUG)

// Signalling Entity definitions
char *               EntityName[NUM_ENTITYS] =
{
// Per-channel Signalling Entities
       "LCSE_OUT",  //         0    Uni-directional Logical Channel signalling Signalling Entity - Outbound
       "LCSE_IN",   //         1    Uni-directional Logical Channel signalling Signalling Entity - Inbound
       "BLCSE_OUT", //         2    Bi-directional  Logical Channel signalling Signalling Entity - Outbound
       "BLCSE_IN",  //         3    Bi-directional  Logical Channel signalling Signalling Entity - Inbound
       "CLCSE_OUT", //         4    Close           Logical Channel signalling Signalling Entity - Outbound
       "CLCSE_IN",  //         5    Close           Logical Channel signalling Signalling Entity - Inbound

// Per H.245 Instance Signalling Entities
       "CESE_OUT",  //         6    Capability Exchange Signalling Entity - Out-going
       "CESE_IN",   //         7    Capability Exchange Signalling Entity - In-coming
       "MTSE_OUT",  //         8    Multiplex Table Signalling Entity - Out-going
       "MTSE_IN",   //         9    Multiplex Table Signalling Entity - In-coming
       "RMESE_OUT", //        10    Request Multiplex Entry Signalling Entity - Out-going
       "RMESE_IN",  //        11    Request Multiplex Entry Signalling Entity - In-coming
       "MRSE_OUT",  //        12    Mode Request Signalling Entity - Out-going
       "MRSE_IN",   //        13    Mode Request Signalling Entity - In-coming
       "MLSE_OUT",  //        14    Maintenance Loop Signalling Entity - Out-going
       "MLSE_IN",   //        15    Maintenance Loop Signalling Entity - In-coming
       "MSDSE",     //        16    Master Slave Determination Signalling Entity
       "RTDSE",     //        17    Round Trip Delay Signalling Entity
       "STATELESS", //        18    No state machine associated with PDU
};




// Event definitions
char *               EventName[NUM_EVENTS] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
       "ReqUEstablish",                 //         0
       "OpenUChAckPDU",                 //         1
       "OpenUChRejectPDU",              //         2
       "CloseUChAckPDU",                //         3
       "ReqURelease",                   //         4
       "T103Expiry",                    //         5

// In-coming Uni-directional Logical Channel (LCSE_IN) events
       "OpenUChPDU",                    //         6
       "CloseUChPDU",                   //         7
       "ResponseUEstablish",            //         8
       "EstablishUReject",              //         9

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
       "ReqBEstablish",                 //        10
       "OpenBChAckPDU",                 //        11
       "OpenBChRejectPDU",              //        12
       "CloseBChAckPDU",                //        13
       "ReqClsBLCSE",                   //        14
       "RspConfirmBLCSE",               //        15
       "T103OutExpiry",                 //        16

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
       "OpenBChPDU",                    //        17
       "CloseBChPDU",                   //        18
       "ResponseBEstablish",            //        19
       "OpenBChConfirmPDU",             //        20
       "OpenRejectBLCSE",               //        21
       "T103InExpiry",                  //        22

// Out-going Request Close Logical Channel (CLCSE_OUT) events
       "ReqClose",                      //        23
       "ReqChCloseAckPDU",              //        24
       "ReqChCloseRejectPDU",           //        25
       "T108Expiry",                    //        26

// In-coming Request Close Logical Channel (CLCSE_IN) events
       "ReqChClosePDU",                 //        27
       "ReqChCloseReleasePDU",          //        28
       "CLCSE_CLOSE_response",          //        29
       "CLCSE_REJECT_request",          //        30

// Out-going Terminal Capablity Exchange (CESE_OUT) events
       "TransferCapRequest",            //        31
       "TermCapSetAckPDU",              //        32
       "TermCapSetRejectPDU",           //        33
       "T101Expiry",                    //        34

// In-coming Terminal Capablity Exchange (CESE_IN) events
       "TermCapSetPDU",                 //        35
       "TermCapSetReleasePDU",          //        36
       "CESE_TRANSFER_response",        //        37
       "CESE_REJECT_request",           //        38

// Out-going Multiplex Table (MTSE_OUT) events
       "MTSE_TRANSFER_request",         //        39
       "MultiplexEntrySendAckPDU",      //        40
       "MultiplexEntrySendRejectPDU",   //        41
       "T104Expiry",                    //        42

// In-coming Multiplex Table (MTSE_IN) events
       "MultiplexEntrySendPDU",         //        43
       "MultiplexEntrySendReleasePDU",  //        44
       "MTSE_TRANSFER_response",        //        45
       "MTSE_REJECT_request",           //        46

// Out-going Request Multiplex Entry (RMESE_OUT) events
       "RMESE_SEND_request",            //        47
       "RequestMultiplexEntryAckPDU",   //        48
       "RequestMultiplexEntryRejectPDU",//        49
       "T107Expiry",                    //        50

// In-coming Request Multiplex Entry (RMESE_IN) events
       "RequestMultiplexEntryPDU",      //        51
       "RequestMultiplexEntryReleasePDU",//       52
       "RMESE_SEND_response",           //        53
       "RMESE_REJECT_request",          //        54

// Out-going Mode Request (MRSE_OUT) events
       "MRSE_TRANSFER_request",         //        55
       "RequestModeAckPDU",             //        56
       "RequestModeRejectPDU",          //        57
       "T109Expiry",                    //        58

// In-coming Mode Request (MRSE_IN) events
       "RequestModePDU",                //        59
       "RequestModeReleasePDU",         //        60
       "MRSE_TRANSFER_response",        //        61
       "MRSE_REJECT_request",           //        62

// Out-going Maintenance Loop (MLSE_OUT) events
       "MLSE_LOOP_request",             //        63
       "MLSE_OUT_RELEASE_request",      //        64
       "MaintenanceLoopAckPDU",         //        65
       "MaintenanceLoopRejectPDU",      //        66
       "T102Expiry",                    //        67

// In-coming Maintenance Loop (MLSE_IN) events
       "MaintenanceLoopRequestPDU",     //        68
       "MaintenanceLoopOffCommandPDU",  //        69
       "MLSE_LOOP_response",            //        70
       "MLSE_IN_RELEASE_request",       //        71

// Master Slave Determination (MSDSE) events
       "MSDetReq",                      //        72
       "MSDetPDU",                      //        73
       "MSDetAckPDU",                   //        74
       "MSDetRejectPDU",                //        75
       "MSDetReleasePDU",               //        76
       "T106Expiry",                    //        77

// Round Trip Delay Delay (RTDSE) events
       "RTDSE_TRANSFER_request",        //        78
       "RoundTripDelayRequestPDU",      //        79
       "RoundTripDelayResponsePDU",     //        80
       "T105Expiry",                    //        81



// Events with no associated state entity
       "NonStandardRequestPDU",         //        82
       "NonStandardResponsePDU",        //        83
       "NonStandardCommandPDU",         //        84
       "NonStandardIndicationPDU",      //        85
       "MiscellaneousRequestPDU",       //        86
       "MiscellaneousResponsePDU",      //        87
       "MiscellaneousCommandPDU",       //        88
       "MiscellaneousIndicationPDU",    //        89
       "CommunicationModeRequestPDU",   //        90
       "CommunicationModeResponsePDU",  //        91
       "CommunicationModeCommandPDU",   //        92
       "SendTerminalCapabilitySetPDU",  //        93
       "EncryptionCommandPDU",          //        94
       "FlowControlCommandPDU",         //        95
       "EndSessionCommandPDU",          //        96
       "FunctionNotSupportedIndicationPDU",//       97
       "JitterIndicationPDU",           //        98
       "H223SkewIndicationPDU",         //        99
       "NewATMVCIndicationPDU",         //       100
       "UserInputIndicationPDU",        //       101
       "H2250MaximumSkewIndicationPDU", //       102
       "MCLocationIndicationPDU",       //       103
};




// Output function definitions
char *                OutputName[NUM_OUTPUTS] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
       "EstablishReleased",             //          0
       "OpenAckAwaitingE",              //          1
       "OpenRejAwaitingE",              //          2
       "ReleaseAwaitingE",              //          3
       "T103AwaitingE",                 //          4
       "ReleaseEstablished",            //          5
       "OpenRejEstablished",            //          6
       "CloseAckEstablished",           //          7
       "CloseAckAwaitingR",             //          8
       "OpenRejAwaitingR",              //          9
       "T103AwaitingR",                 //         10
       "EstablishAwaitingR",            //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
       "OpenReleased",                  //         12
       "CloseReleased",                 //         13
       "ResponseAwaiting",              //         14
       "ReleaseAwaiting",               //         15
       "CloseAwaiting",                 //         16
       "OpenAwaiting",                  //         17
       "CloseEstablished",              //         18
       "OpenEstablished",               //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
       "EstablishReqBReleased",         //         20
       "OpenChannelAckBAwaitingE",      //         21
       "OpenChannelRejBAwaitingE",      //         22
       "ReleaseReqBOutAwaitingE",       //         23
       "T103ExpiryBAwaitingE",          //         24
       "ReleaseReqBEstablished",        //         25
       "OpenChannelRejBEstablished",    //         26
       "CloseChannelAckBEstablished",   //         27
       "CloseChannelAckAwaitingR",      //         28
       "OpenChannelRejBAwaitingR",      //         29
       "T103ExpiryBAwaitingR",          //         30
       "EstablishReqAwaitingR",         //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
       "OpenChannelBReleased",          //         32
       "CloseChannelBReleased",         //         33
       "EstablishResBAwaitingE",        //         34
       "ReleaseReqBInAwaitingE",        //         35
       "CloseChannelBAwaitingE",        //         36
       "OpenChannelBAwaitingE",         //         37
       "OpenChannelConfirmBAwaitingE",  //         38
       "T103ExpiryBAwaitingC",          //         39
       "OpenChannelConfirmBAwaitingC",  //         40
       "CloseChannelBAwaitingC",        //         41
       "OpenChannelBAwaitingC",         //         42
       "CloseChannelBEstablished",      //         43
       "OpenChannelBEstablished",       //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
       "CloseRequestIdle",              //         45
       "RequestCloseAckAwaitingR",      //         46
       "RequestCloseRejAwaitingR",      //         47
       "T108ExpiryAwaitingR",           //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
       "RequestCloseIdle",              //         49
       "CloseResponseAwaitingR",        //         50
       "RejectRequestAwaitingR",        //         51
       "RequestCloseReleaseAwaitingR",  //         52
       "RequestCloseAwaitingR",         //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
       "RequestCapIdle",                //         54
       "TermCapAckAwaiting",            //         55
       "TermCapRejAwaiting",            //         56
       "T101ExpiryAwaiting",            //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
       "TermCapSetIdle",                //         58
       "ResponseCapAwaiting",           //         59
       "RejectCapAwaiting",             //         60
       "TermCapReleaseAwaiting",        //         61
       "TermCapSetAwaiting",            //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
       "MTSE0_TRANSFER_request",        //         63
       "MTSE1_TRANSFER_request",        //         64
       "MTSE1_MultiplexEntrySendAck",   //         65
       "MTSE1_MultiplexEntrySendRej",   //         66
       "MTSE1_T104Expiry",              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
       "MTSE0_MultiplexEntrySend",      //         68
       "MTSE1_MultiplexEntrySend",      //         69
       "MTSE1_MultiplexEntrySendRelease",//        70
       "MTSE1_TRANSFER_response",       //         71
       "MTSE1_REJECT_request",          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
       "RMESE0_SEND_request",           //         73
       "RMESE1_SEND_request",           //         74
       "RMESE1_RequestMuxEntryAck",     //         75
       "RMESE1_RequestMuxEntryRej",     //         76
       "RMESE1_T107Expiry",             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
       "RMESE0_RequestMuxEntry",        //         78
       "RMESE1_RequestMuxEntry",        //         79
       "RMESE1_RequestMuxEntryRelease", //         80
       "RMESE1_SEND_response",          //         81
       "RMESE1_REJECT_request",         //         82

// Out-going Request Mode (MRSE_OUT) state functions
       "MRSE0_TRANSFER_request",        //         83
       "MRSE1_TRANSFER_request",        //         84
       "MRSE1_RequestModeAck",          //         85
       "MRSE1_RequestModeRej",          //         86
       "MRSE1_T109Expiry",              //         87

// In-coming Request Mode (MRSE_IN) state functions
       "MRSE0_RequestMode",             //         88
       "MRSE1_RequestMode",             //         89
       "MRSE1_RequestModeRelease",      //         90
       "MRSE1_TRANSFER_response",       //         91
       "MRSE1_REJECT_request",          //         92

// Out-going Request Mode (MLSE_OUT) state functions
       "MLSE0_LOOP_request",            //         93
       "MLSE1_MaintenanceLoopAck",      //         94
       "MLSE1_MaintenanceLoopRej",      //         95
       "MLSE1_OUT_RELEASE_request",     //         96
       "MLSE1_T102Expiry",              //         97
       "MLSE2_MaintenanceLoopRej",      //         98
       "MLSE2_OUT_RELEASE_request",     //         99

// In-coming Request Mode (MLSE_IN) state functions
       "MLSE0_MaintenanceLoopRequest",  //        100
       "MLSE1_MaintenanceLoopRequest",  //        101
       "MLSE1_MaintenanceLoopOffCommand",//       102
       "MLSE1_LOOP_response",           //        103
       "MLSE1_IN_RELEASE_request",      //        104
       "MLSE2_MaintenanceLoopRequest",  //        105
       "MLSE2_MaintenanceLoopOffCommand",//       106

// Master Slave Determination (MSDSE) state functions
       "DetRequestIdle",                //        107
       "MSDetIdle",                     //        108
       "MSDetAckOutgoing",              //        109
       "MSDetOutgoing",                 //        110
       "MSDetRejOutgoing",              //        111
       "MSDetReleaseOutgoing",          //        112
       "T106ExpiryOutgoing",            //        113
       "MSDetAckIncoming",              //        114
       "MSDetIncoming",                 //        115
       "MSDetRejIncoming",              //        116
       "MSDetReleaseIncoming",          //        117
       "T106ExpiryIncoming",            //        118

// Round Trip Delay (RTDSE) state functions
       "RTDSE0_TRANSFER_request",       //        119
       "RTDSE0_RoundTripDelayRequest",  //        120
       "RTDSE1_TRANSFER_request",       //        121
       "RTDSE1_RoundTripDelayRequest",  //        122
       "RTDSE1_RoundTripDelayResponse", //        123
       "RTDSE1_T105Expiry",             //        124
};
#endif  // (_DEBUG)



typedef HRESULT (*STATE_FUNCTION)(Object_t *pObject, PDU_t *pPdu);

// Output function defintions
static STATE_FUNCTION StateFun[] =
{
// Out-going Open Uni-directional Logical Channel (LCSE_OUT) state functions
        establishReleased,              //          0
        openAckAwaitingE,               //          1
        openRejAwaitingE,               //          2
        releaseAwaitingE,               //          3
        t103AwaitingE,                  //          4
        releaseEstablished,             //          5
        openRejEstablished,             //          6
        closeAckEstablished,            //          7
        closeAckAwaitingR,              //          8
        openRejAwaitingR,               //          9
        t103AwaitingR,                  //         10
        establishAwaitingR,             //         11

// In-coming Open Uni-directional Logical Channel (LCSE_IN) state functions
        openReleased,                   //         12
        closeReleased,                  //         13
        responseAwaiting,               //         14
        releaseAwaiting,                //         15
        closeAwaiting,                  //         16
        openAwaiting,                   //         17
        closeEstablished,               //         18
        openEstablished,                //         19

// Out-going Open Bi-directional Logical Channel (BLCSE_OUT) state functions
        establishReqBReleased,          //         20
        openChannelAckBAwaitingE,       //         21
        openChannelRejBAwaitingE,       //         22
        releaseReqBOutAwaitingE,        //         23
        t103ExpiryBAwaitingE,           //         24
        releaseReqBEstablished,         //         25
        openChannelRejBEstablished,     //         26
        closeChannelAckBEstablished,    //         27
        closeChannelAckAwaitingR,       //         28
        openChannelRejBAwaitingR,       //         29
        t103ExpiryBAwaitingR,           //         30
        establishReqAwaitingR,          //         31

// In-coming Open Bi-directional Logical Channel (BLCSE_IN) state functions
        openChannelBReleased,           //         32
        closeChannelBReleased,          //         33
        establishResBAwaitingE,         //         34
        releaseReqBInAwaitingE,         //         35
        closeChannelBAwaitingE,         //         36
        openChannelBAwaitingE,          //         37
        openChannelConfirmBAwaitingE,   //         38
        t103ExpiryBAwaitingC,           //         39
        openChannelConfirmBAwaitingC,   //         40
        closeChannelBAwaitingC,         //         41
        openChannelBAwaitingC,          //         42
        closeChannelBEstablished,       //         43
        openChannelBEstablished,        //         44

// Out-going Request Close Logical Channel (CLCSE_OUT) state functions
        closeRequestIdle,               //         45
        requestCloseAckAwaitingR,       //         46
        requestCloseRejAwaitingR,       //         47
        t108ExpiryAwaitingR,            //         48

// In-coming Request Close Logical Channel (CLCSE_IN) state functions
        requestCloseIdle,               //         49
        closeResponseAwaitingR,         //         50
        rejectRequestAwaitingR,         //         51
        requestCloseReleaseAwaitingR,   //         52
        requestCloseAwaitingR,          //         53

// Out-going Terminal Capability Exchange (CESE_OUT) state functions
        requestCapIdle,                 //         54
        termCapAckAwaiting,             //         55
        termCapRejAwaiting,             //         56
        t101ExpiryAwaiting,             //         57

// In-coming Terminal Capability Exchange (CESE_IN) state functions
        termCapSetIdle,                 //         58
        responseCapAwaiting,            //         59
        rejectCapAwaiting,              //         60
        termCapReleaseAwaiting,         //         61
        termCapSetAwaiting,             //         62

// Out-going Multiplex Table (MTSE_OUT) state functions
        MTSE0_TRANSFER_requestF,        //         63
        MTSE1_TRANSFER_requestF,        //         64
        MTSE1_MultiplexEntrySendAckF,   //         65
        MTSE1_MultiplexEntrySendRejF,   //         66
        MTSE1_T104ExpiryF,              //         67

// In-coming Multiplex Table (MTSE_IN) state functions
        MTSE0_MultiplexEntrySendF,      //         68
        MTSE1_MultiplexEntrySendF,      //         69
        MTSE1_MultiplexEntrySendReleaseF,//        70
        MTSE1_TRANSFER_responseF,       //         71
        MTSE1_REJECT_requestF,          //         72

// Out-going Request Multiplex Entry (RMESE_OUT) state functions
        RMESE0_SEND_requestF,           //         73
        RMESE1_SEND_requestF,           //         74
        RMESE1_RequestMuxEntryAckF,     //         75
        RMESE1_RequestMuxEntryRejF,     //         76
        RMESE1_T107ExpiryF,             //         77

// In-coming Request Multiplex Entry (RMESE_IN) state functions
        RMESE0_RequestMuxEntryF,        //         78
        RMESE1_RequestMuxEntryF,        //         79
        RMESE1_RequestMuxEntryReleaseF, //         80
        RMESE1_SEND_responseF,          //         81
        RMESE1_REJECT_requestF,         //         82

// Out-going Request Mode (MRSE_OUT) state functions
        MRSE0_TRANSFER_requestF,        //         83
        MRSE1_TRANSFER_requestF,        //         84
        MRSE1_RequestModeAckF,          //         85
        MRSE1_RequestModeRejF,          //         86
        MRSE1_T109ExpiryF,              //         87

// In-coming Request Mode (MRSE_OUT) state functions
        MRSE0_RequestModeF,             //         88
        MRSE1_RequestModeF,             //         89
        MRSE1_RequestModeReleaseF,      //         90
        MRSE1_TRANSFER_responseF,       //         91
        MRSE1_REJECT_requestF,          //         92

// Out-going Request Mode (MLSE_OUT) state functions
        MLSE0_LOOP_requestF,            //         93
        MLSE1_MaintenanceLoopAckF,      //         94
        MLSE1_MaintenanceLoopRejF,      //         95
        MLSE1_OUT_RELEASE_requestF,     //         96
        MLSE1_T102ExpiryF,              //         97
        MLSE2_MaintenanceLoopRejF,      //         98
        MLSE2_OUT_RELEASE_requestF,     //         99

// In-coming Request Mode (MLSE_IN) state functions
        MLSE0_MaintenanceLoopRequestF,  //        100
        MLSE1_MaintenanceLoopRequestF,  //        101
        MLSE1_MaintenanceLoopOffCommandF,//       102
        MLSE1_LOOP_responseF,           //        103
        MLSE1_IN_RELEASE_requestF,      //        104
        MLSE2_MaintenanceLoopRequestF,  //        105
        MLSE2_MaintenanceLoopOffCommandF,//       106

// Master Slave Determination (MSDSE) state functions
        detRequestIdle,                 //        107
        msDetIdle,                      //        108
        msDetAckOutgoing,               //        109
        msDetOutgoing,                  //        110
        msDetRejOutgoing,               //        111
        msDetReleaseOutgoing,           //        112
        t106ExpiryOutgoing,             //        113
        msDetAckIncoming,               //        114
        msDetIncoming,                  //        115
        msDetRejIncoming,               //        116
        msDetReleaseIncoming,           //        117
        t106ExpiryIncoming,             //        118

// Round Trip Delay (RTDSE) state functions
        RTDSE0_TRANSFER_requestF,       //        119
        RTDSE0_RoundTripDelayRequestF,  //        120
        RTDSE1_TRANSFER_requestF,       //        121
        RTDSE1_RoundTripDelayRequestF,  //        122
        RTDSE1_RoundTripDelayResponseF, //        123
        RTDSE1_T105ExpiryF,             //        124
};



/*********************************************
 *
 * State table for the finite state machine
 *
 *********************************************/

Output_t StateTable[NUM_STATE_EVENTS][MAXSTATES] =
{
// Out-going Uni-directional Logical Channel (LCSE_OUT) events
{EstablishReleased,IGNORE,           IGNORE,             EstablishAwaitingR},  // ReqUEstablish
{IGNORE,           OpenAckAwaitingE, IGNORE,             IGNORE            },  // OpenUChAckPDU
{IGNORE,           OpenRejAwaitingE, OpenRejEstablished, OpenRejAwaitingR  },  // OpenUChRejectPDU
{IGNORE,           IGNORE,           CloseAckEstablished,CloseAckAwaitingR },  // CloseUChAckPDU
{IGNORE,           ReleaseAwaitingE, ReleaseEstablished, IGNORE            },  // ReqURelease
{BAD,              T103AwaitingE,    BAD,                T103AwaitingR     },  // T103Expiry

// In-coming Uni-directional Logical Channel (LCSE_IN) events
{OpenReleased,     OpenAwaiting,     OpenEstablished,    BAD               },  // OpenUChPDU
{CloseReleased,    CloseAwaiting,    CloseEstablished,   BAD               },  // CloseUChPDU
{IGNORE,           ResponseAwaiting, IGNORE,             BAD               },  // ResponseUEstablish
{IGNORE,           ReleaseAwaiting,  IGNORE,             BAD               },  // EstablishUReject

// Out-going Bi-directional Logical Channel (BLCSE_OUT) events
{EstablishReqBReleased,IGNORE,                      IGNORE,                      EstablishReqAwaitingR   },// ReqBEstablish
{IGNORE,               OpenChannelAckBAwaitingE,    IGNORE,                      IGNORE                  },// OpenBChAckPDU
{IGNORE,               OpenChannelRejBAwaitingE,    OpenChannelRejBEstablished,  OpenChannelRejBAwaitingR},// OpenBChRejectPDU
{IGNORE,               IGNORE,                      CloseChannelAckBEstablished, CloseChannelAckAwaitingR},// CloseBChAckPDU
{IGNORE,               ReleaseReqBOutAwaitingE,     ReleaseReqBEstablished,      IGNORE                  },// ReqClsBLCSE
{IGNORE,               IGNORE,                      IGNORE,                      IGNORE                  },// RspConfirmBLCSE
{BAD,                  T103ExpiryBAwaitingE,        BAD,                         T103ExpiryBAwaitingR    },// T103OutExpiry

// In-coming Bi-directional Logical Channel (BLCSE_IN) events
{OpenChannelBReleased, OpenChannelBAwaitingE,       OpenChannelBAwaitingC,       OpenChannelBEstablished },// OpenBChPDU
{CloseChannelBReleased,CloseChannelBAwaitingE,      CloseChannelBAwaitingC,      CloseChannelBEstablished},// CloseBChPDU
{IGNORE,               EstablishResBAwaitingE,      IGNORE,                      IGNORE                  },// ResponseBEstablish
{IGNORE,               OpenChannelConfirmBAwaitingE,OpenChannelConfirmBAwaitingC,IGNORE                  },// OpenBChConfirmPDU
{IGNORE,               ReleaseReqBInAwaitingE,      IGNORE,                      IGNORE                  },// OpenRejectBLCSE
{BAD,                  BAD,                         T103ExpiryBAwaitingC,        BAD                     },// T103InExpiry

// Out-going Request Close Logical Channel (CLCSE_OUT) events
{CloseRequestIdle,              IGNORE,                         BAD,BAD},   // ReqClose
{IGNORE,                        RequestCloseAckAwaitingR,       BAD,BAD},   // ReqChCloseAckPDU
{IGNORE,                        RequestCloseRejAwaitingR,       BAD,BAD},   // ReqChCloseRejectPDU
{BAD,                           T108ExpiryAwaitingR,            BAD,BAD},   // T108Expiry

// In-coming Request Close Logical Channel (CLCSE_IN) events
{RequestCloseIdle,              RequestCloseAwaitingR,          BAD,BAD},   // ReqChClosePDU
{IGNORE,                        RequestCloseReleaseAwaitingR,   BAD,BAD},   // ReqChCloseReleasePDU
{IGNORE,                        CloseResponseAwaitingR,         BAD,BAD},   // CLCSE_CLOSE_response
{IGNORE,                        RejectRequestAwaitingR,         BAD,BAD},   // CLCSE_REJECT_request

// Out-going Terminal Capablity Exchange (CESE_OUT) events
{RequestCapIdle,                IGNORE,                         BAD,BAD},   // TransferCapRequest
{IGNORE,                        TermCapAckAwaiting,             BAD,BAD},   // TermCapSetAckPDU
{IGNORE,                        TermCapRejAwaiting,             BAD,BAD},   // TermCapSetRejectPDU
{BAD,                           T101ExpiryAwaiting,             BAD,BAD},   // T101Expiry

// In-coming Terminal Capablity Exchange (CESE_IN) events
{TermCapSetIdle,                TermCapSetAwaiting,             BAD,BAD},   // TermCapSetPDU
{IGNORE,                        TermCapReleaseAwaiting,         BAD,BAD},   // TermCapSetRelPDU
{IGNORE,                        ResponseCapAwaiting,            BAD,BAD},   // CESE_TRANSFER_response
{IGNORE,                        RejectCapAwaiting,              BAD,BAD},   // CESE_REJECT_request

// Out-going Multiplex Table (MTSE_OUT) events
{MTSE0_TRANSFER_request,        MTSE1_TRANSFER_request,         BAD,BAD},   // TRANSFER_request
{IGNORE,                        MTSE1_MultiplexEntrySendAck,    BAD,BAD},   // MultiplexEntrySendAck
{IGNORE,                        MTSE1_MultiplexEntrySendRej,    BAD,BAD},   // MultiplexEntrySendReject
{BAD,                           MTSE1_T104Expiry,               BAD,BAD},   // T104Expiry

// In-coming Multiplex Table (MTSE_IN) events
{MTSE0_MultiplexEntrySend,      MTSE1_MultiplexEntrySend,       BAD,BAD},   // MultiplexEntrySend
{IGNORE,                        MTSE1_MultiplexEntrySendRelease,BAD,BAD},   // MultiplexEntrySendRelease
{IGNORE,                        MTSE1_TRANSFER_response,        BAD,BAD},   // MTSE_TRANSFER_response
{IGNORE,                        MTSE1_REJECT_request,           BAD,BAD},   // MTSE_REJECT_request

// Out-going Request Multiplex Entry (RMESE_OUT) events
{RMESE0_SEND_request,           RMESE1_SEND_request,            BAD,BAD},   // RMESE_SEND_request
{IGNORE,                        RMESE1_RequestMuxEntryAck,      BAD,BAD},   // RequestMultiplexEntryAck
{IGNORE,                        RMESE1_RequestMuxEntryRej,      BAD,BAD},   // RequestMultiplexEntryReject
{BAD,                           RMESE1_T107Expiry,              BAD,BAD},   // T107Expiry

// In-coming Request Multiplex Entry (RMESE_IN) events
{RMESE0_RequestMuxEntry,        RMESE1_RequestMuxEntry,         BAD,BAD},   // RequestMultiplexEntry
{IGNORE,                        RMESE1_RequestMuxEntryRelease,  BAD,BAD},   // RequestMultiplexEntryRelease
{BAD,                           RMESE1_SEND_response,           BAD,BAD},   // RMESE_SEND_response
{BAD,                           RMESE1_REJECT_request,          BAD,BAD},   // RMESE_REJECT_request

// Out-going Mode Request (MRSE_OUT) events
{MRSE0_TRANSFER_request,        MRSE1_TRANSFER_request,         BAD,BAD},   // MRSE_TRANSFER_request
{IGNORE,                        MRSE1_RequestModeAck,           BAD,BAD},   // RequestModeAck
{IGNORE,                        MRSE1_RequestModeRej,           BAD,BAD},   // RequestModeReject
{BAD,                           MRSE1_T109Expiry,               BAD,BAD},   // T109Expiry

// In-coming Mode Request (MRSE_IN) events
{MRSE0_RequestMode,             MRSE1_RequestMode,              BAD,BAD},   // RequestMode
{IGNORE,                        MRSE1_RequestModeRelease,       BAD,BAD},   // RequestModeRelease
{BAD,                           MRSE1_TRANSFER_response,        BAD,BAD},   // MRSE_TRANSFER_response
{BAD,                           MRSE1_REJECT_request,           BAD,BAD},   // MRSE_REJECT_request

// Out-going Maintenance Loop (MLSE_OUT) events
{MLSE0_LOOP_request,            BAD,                            BAD,                            BAD}, // MLSE_LOOP_request
{BAD,                           MLSE1_OUT_RELEASE_request,      MLSE2_OUT_RELEASE_request,      BAD}, // MLSE_OUT_RELEASE_request
{IGNORE,                        MLSE1_MaintenanceLoopAck,       IGNORE,                         BAD}, // MaintenanceLoopAck
{IGNORE,                        MLSE1_MaintenanceLoopRej,       MLSE2_MaintenanceLoopRej,       BAD}, // MaintenanceLoopReject
{BAD,                           MLSE1_T102Expiry,               BAD,                            BAD}, // T102Expiry

// In-coming Maintenance Loop (MLSE_IN) events
{MLSE0_MaintenanceLoopRequest,  MLSE1_MaintenanceLoopRequest,   MLSE2_MaintenanceLoopRequest,   BAD}, // MaintenanceLoopRequest
{IGNORE,                        MLSE1_MaintenanceLoopOffCommand,MLSE2_MaintenanceLoopOffCommand,BAD}, // MaintenanceLoopOffCommand
{BAD,                           MLSE1_LOOP_response,            BAD,                            BAD}, // MLSE_LOOP_response
{BAD,                           MLSE1_IN_RELEASE_request,       BAD,                            BAD}, // MLSE_IN_RELEASE_request

// Master Slave Determination (MSDSE) events
{DetRequestIdle,                IGNORE,                         IGNORE,              BAD}, // MSDetReq
{MSDetIdle,                     MSDetOutgoing,                  MSDetIncoming,       BAD}, // MSDetPDU
{IGNORE,                        MSDetAckOutgoing,               MSDetAckIncoming,    BAD}, // MSDetAckPDU
{IGNORE,                        MSDetRejOutgoing,               MSDetRejIncoming,    BAD}, // MSDetRejectPDU
{IGNORE,                        MSDetReleaseOutgoing,           MSDetReleaseIncoming,BAD}, // MSDetReleasePDU
{BAD,                           T106ExpiryOutgoing,             T106ExpiryIncoming,  BAD}, // T106Expiry

// Round Trip Delay Delay (RTDSE) events
{RTDSE0_TRANSFER_request,       RTDSE1_TRANSFER_request,        BAD,BAD},   // RTDSE_TRANSFER_request
{RTDSE0_RoundTripDelayRequest,  RTDSE0_RoundTripDelayRequest,   BAD,BAD},   // RoundTripDelayRequest
{IGNORE,                        RTDSE1_RoundTripDelayResponse,  BAD,BAD},   // RoundTripDelayResponse
{BAD,                           RTDSE1_T105Expiry,              BAD,BAD},   // T105Expiry
};



/*
 *  NAME
 *      StateMachine() - engine for finite state machine
 *
 *
 *  PARAMETERS
 *  INPUT       pObject        pointer to an FSM object structure
 *  INTPUT      event         input to the finite state machine
 *
 *  RETURN VALUE
 *   error codes defined in h245api.h
 */

HRESULT
StateMachine(Object_t *pObject, PDU_t *pPdu, Event_t Event)
{
    UINT                uFunction;
    HRESULT             lError;

    ASSERT(pObject != NULL);

    if (Event > NUM_EVENTS)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid Event %d", Event);
        return H245_ERROR_PARAM;
    }

    if (pObject->State > MAXSTATES)
    {
        H245TRACE(pObject->dwInst, 1, "StateMachine: Invalid State %d", pObject->State);
        return H245_ERROR_INVALID_STATE;
    }

    ++(pObject->uNestLevel);

#if defined(_DEBUG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) State=%d Event=%s(%d)",
              EntityName[pObject->Entity], pObject->Entity,
              pObject->State,
              EventName[Event], Event);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
              pObject->Entity, pObject->State, Event);
#endif

    uFunction = StateTable[Event][pObject->State];
    if (uFunction < (sizeof (StateFun) / sizeof(StateFun[0])))
    {
        /* indicating a valid transition */
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%s(%d)",
                  OutputName[uFunction], uFunction);
#else   // (_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Function=%d", uFunction);
#endif  // (_DEBUG)

        lError = (*StateFun[uFunction])(pObject, pPdu);

#if defined(_DEBUG)
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%s(%d) New State=%d",
              EntityName[pObject->Entity], pObject->Entity, pObject->State);
#else
    H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d New State=%d",
              pObject->Entity, pObject->State);
#endif
    }
    else if (uFunction == IGNORE)
    {
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event ignored");
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Ignored; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Entity=%d State=%d Event=%d",
                  pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_OK;
    }
    else
    {
#if defined(_DEBUG)
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%s(%d) State=%d Event=%s(%d)",
                  EntityName[pObject->Entity], pObject->Entity,
                  pObject->State,
                  EventName[Event], Event);
#else
        H245TRACE(pObject->dwInst, 2, "StateMachine: Event Invalid; Entity=%d State=%d Event=%d",
                 pObject->Entity, pObject->State, Event);
#endif
        lError = H245_ERROR_INVALID_STATE;
    }

    if (--(pObject->uNestLevel) == 0 && pObject->State == 0)
    {
        ObjectDestroy(pObject);
    }

    return lError;
} // StateMachine()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gki.cpp ===
/************************************************************************
*                                                                                                                                               *
*       INTEL CORPORATION PROPRIETARY INFORMATION                                                       *
*                                                                                                                                               *
*       This software is supplied under the terms of a license                          *
*       agreement or non-disclosure agreement with Intel Corporation            *
*       and may not be copied or disclosed except in accordance                         *
*       with the terms of that agreement.                                                                       *
*                                                                                                                                               *
*       Copyright (C) 1997 Intel Corp.  All Rights Reserved                                     *
*                                                                                                                                               *
*       $Archive:   S:\sturgeon\src\gki\vcs\gki.cpv  $
*                                                                                                                                               *
*       $Revision:   1.14  $
*       $Date:   28 Feb 1997 15:46:46  $
*                                                                                                                                               *
*       $Author:   CHULME  $
*                                                                                                                                               *
*   $Log:   S:\sturgeon\src\gki\vcs\gki.cpv  $
// 
//    Rev 1.14   28 Feb 1997 15:46:46   CHULME
// In Cleanup - check pReg still valid before waiting for 2nd thread to exit
// 
//    Rev 1.13   14 Feb 1997 16:45:40   CHULME
// Wait for all threads to exit prior to returning from synchronous Cleanup ca
// 
//    Rev 1.12   12 Feb 1997 01:12:38   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.11   11 Feb 1997 15:35:32   CHULME
// Added GKI_CleanupRequest function to offload DLL_PROCESS_DETACH
// 
//    Rev 1.10   05 Feb 1997 19:28:18   CHULME
// Remove deletion code from PROCESS_DETACH
// 
//    Rev 1.9   05 Feb 1997 16:53:10   CHULME
// 
//    Rev 1.8   05 Feb 1997 15:25:12   CHULME
// Don't wait for retry thread to exit
// 
//    Rev 1.7   05 Feb 1997 13:50:24   CHULME
// On PROCESS_DETACH - close socket and let retry thread delete pReg
// 
//    Rev 1.6   17 Jan 1997 09:02:00   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.5   13 Jan 1997 17:01:18   CHULME
// Moved error debug message to error condition
// 
//    Rev 1.4   13 Jan 1997 16:31:20   CHULME
// Changed debug string to 512 - Description can be 256 chars
// 
//    Rev 1.3   13 Jan 1997 14:25:54   EHOWARDX
// Increased size of szGKDebug debug string buffer from 80 to 128 bytes.
// 
//    Rev 1.2   10 Jan 1997 16:14:30   CHULME
// Removed MFC dependency
// 
//    Rev 1.1   22 Nov 1996 14:57:10   CHULME
// Changed the default spider flags, to quit logging raw PDU and XRS
*************************************************************************/

// gki.cpp : Defines the initialization routines for the DLL.
//
#include "precomp.h"

#include <winsock.h>
#include "dgkiexp.h"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "h225asn.h"
#include "coder.hpp"

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	// INTEROP
	#include "interop.h"
	#include "rasplog.h"
	LPInteropLogger         RasLogger;
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

DLL_EXPORT DWORD        dwGKIDLLFlags = 0xff3f;
DLL_EXPORT BOOL         fGKIEcho = FALSE;
DLL_EXPORT BOOL         fGKIDontSend = FALSE;

char                                            *pEchoBuff = 0;
int                                                     nEchoLen;
CRegistration   *g_pReg = NULL;
Coder 			*g_pCoder = NULL;

/////////////////////////////////////////////////////////////////////////////
// The one and only CGatekeeper object

CGatekeeper *g_pGatekeeper = NULL;


/////////////////////////////////////////////////////////////////////////////
// DLLMain


extern "C" HRESULT DLL_EXPORT
GKI_Initialize(void)
{
	HRESULT hr = GKI_OK;
	int nRet;
	WSADATA wsaData;
	
#ifdef _DEBUG
	char                    szGKDebug[512];
#endif

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
	//INTEROP
	RasLogger = InteropLoad(RASLOG_PROTOCOL);       // found in rasplog.h
#endif

	nRet = WSAStartup(MAKEWORD(WSVER_MAJOR, WSVER_MINOR), &wsaData);
	if (nRet != 0)
	{
		SpiderWSErrDecode(nRet);
		hr = GKI_NOT_INITIALIZED;
		goto ERROR_EXIT;
	}

	if ((HIBYTE(wsaData.wVersion) != WSVER_MINOR) || 
			(LOBYTE(wsaData.wVersion) != WSVER_MAJOR))
	{
		hr = GKI_NOT_INITIALIZED;
		goto WSA_CLEANUP_EXIT;
	}
	g_pGatekeeper = new CGatekeeper;
	
	if(!g_pGatekeeper)
	{
		hr = GKI_NO_MEMORY;
		goto WSA_CLEANUP_EXIT;
	}
	g_pCoder = new Coder; 
	if(!g_pCoder)
	{
		hr = GKI_NO_MEMORY;
		goto WSA_CLEANUP_EXIT;
	}
	// initialize the oss library
	nRet = g_pCoder->InitCoder();
	if (nRet)
	{
		hr = GKI_NOT_INITIALIZED;
		goto WSA_CLEANUP_EXIT;
	}
	
	// Get the gatekeeper information from the registry
	g_pGatekeeper->Read();
	
	return hr;
	
WSA_CLEANUP_EXIT:
	nRet = WSACleanup();
	if (nRet != 0)
	{
		SpiderWSErrDecode(-1);
	}
		
	// fall out to ERROR_EXIT
ERROR_EXIT:
	if(g_pGatekeeper)
		delete g_pGatekeeper;

	if(g_pCoder)
		delete g_pCoder;
		
	g_pGatekeeper = NULL;	
	g_pCoder = NULL;
	return hr;
}

extern "C" HRESULT DLL_EXPORT
GKI_CleanupRequest(void)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            as a precursor to unloading the DLL.  This function is responsible
	//            for all cleanup - This allows us to basically do nothing in the
	//            DllMain DLL_PROCESS_DETACH, which doesn't appear to work as intended.
	// AUTHOR:    Colin Hulme

	int						nRet;
#ifdef _DEBUG
	char                    szGKDebug[512];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_CleanupRequest()\n", 0);
	SPIDER_TRACE(SP_GKI, "GKI_CleanupRequest()\n", 0);
	if(g_pGatekeeper)	// if initialized
	{
		ASSERT(g_pCoder);	// g_pGatekeeper and g_pCoder come and go as a unit
		
		g_pGatekeeper->Lock();
		if (g_pReg != 0)
		{
			g_pReg->m_pSocket->Close();	// Close socket will terminate the other threads

			g_pGatekeeper->Unlock();
			WaitForSingleObject(g_pReg->GetRcvThread(), TIMEOUT_THREAD);
		#ifdef BROADCAST_DISCOVERY		
			if (g_pReg)
				WaitForSingleObject(g_pReg->GetDiscThread(), TIMEOUT_THREAD);
		#endif // #ifdef BROADCAST_DISCOVERY		
			g_pGatekeeper->Lock();
			if (g_pReg != 0)
			{
				SPIDER_TRACE(SP_NEWDEL, "del g_pReg = %X\n", g_pReg);
				delete g_pReg;
				g_pReg = 0;
			}
		}

#if (defined(_DEBUG) || defined(PCS_COMPLIANCE))
		//INTEROP
		InteropUnload((LPInteropLogger)RasLogger);
#endif

		SPIDER_TRACE(SP_WSOCK, "WSACleanup()\n", 0);
		nRet = WSACleanup();
		if (nRet != 0)
		{
			SpiderWSErrDecode(-1);
		}

		g_pGatekeeper->Unlock();

		delete g_pGatekeeper;
		delete g_pCoder;		// see ASSERT abovr
		g_pGatekeeper = NULL;	
		g_pCoder = NULL;
	}
	
//	GK_TermModule();

	return (GKI_OK);
}

extern "C" VOID DLL_EXPORT
GKI_SetGKAddress(PSOCKADDR_IN pAddr)
{
    if (!pAddr)
    {
        return;
    }
    g_pGatekeeper->SetSockAddr(pAddr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gatekpr.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gatekpr.cpv  $
*																		*
*	$Revision:   1.9  $
*	$Date:   19 Feb 1997 13:57:36  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gatekpr.cpv  $
// 
//    Rev 1.9   19 Feb 1997 13:57:36   CHULME
// Modified DeleteCachedAddress to write all registry settings
// 
//    Rev 1.8   14 Feb 1997 16:41:16   CHULME
// Changed registry key to GKIDLL\2.0 to match GKI version
// 
//    Rev 1.7   17 Jan 1997 12:53:00   CHULME
// Removed UNICODE dependent code
// 
//    Rev 1.6   17 Jan 1997 09:01:58   CHULME
// No change.
// 
//    Rev 1.5   13 Jan 1997 17:01:38   CHULME
// Fixed debug messages for registry cached addresses
// 
//    Rev 1.4   10 Jan 1997 16:14:22   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:37:42   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   19 Dec 1996 19:27:32   CHULME
// Retry count and interval only read/written to registry on DEBUG
// 
//    Rev 1.1   22 Nov 1996 15:24:28   CHULME
// Added VCS log to the header
*************************************************************************/

// gatekeeper.cpp : Provides the implementation for the CGatekeeper class
//

#include "precomp.h"

#include "dspider.h"
#include "dgkilit.h"
#include "GATEKPR.H"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGatekeeper construction

CGatekeeper::CGatekeeper()
:m_dwMCastTTL(1),
m_fRejectReceived(FALSE),
m_dwLockingThread(0)
{
	SetIPAddress("");
	m_GKSockAddr.sin_addr.S_un.S_addr = INADDR_ANY;
	InitializeCriticalSection(&m_CriticalSection);
}

/////////////////////////////////////////////////////////////////////////////
// CGatekeeper destruction

CGatekeeper::~CGatekeeper()
{
	if (m_dwLockingThread)
		Unlock();
	DeleteCriticalSection(&m_CriticalSection);
}


void 
CGatekeeper::Read(void)
{
// ABSTRACT:  This member function will read the gatekeeper addresses and the
//            multicast flag from the Registry and load the member variables
// AUTHOR:    Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
	DWORD			dwType;
	DWORD			dwLen;
	LONG			lRet;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::Read()\n", 0);

	dwType = REG_SZ;
	lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Conferencing\\GatekeeperDLL"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	dwLen =IPADDR_SZ + 1;
	
#if(0)	// don't do the registry hack now that setting the address is exposed
	lRet = RegQueryValueEx(hKey, TEXT("GKIPAddress"), NULL, &dwType, 
					(LPBYTE)m_GKIPAddress, &dwLen);
	SPIDER_DEBUGS(m_GKIPAddress);

	if(m_GKIPAddress[0] != 0)
	{
		m_GKSockAddr.sin_addr.s_addr = inet_addr(m_GKIPAddress);
	}
	
#endif // if(0)
	dwType = REG_DWORD;
	dwLen = sizeof(DWORD);
	RegQueryValueEx(hKey, TEXT("GKMCastTTL"), NULL, &dwType,
					(LPBYTE)&m_dwMCastTTL, &dwLen);
	SPIDER_DEBUG(m_dwMCastTTL);
	
#if(0)
#ifdef _DEBUG
	RegQueryValueEx(hKey, TEXT("GKRetryMS"), NULL, &dwType,
					(LPBYTE)&m_dwRetryMS, &dwLen);
	if (m_dwRetryMS == 0)
		m_dwRetryMS = DEFAULT_RETRY_MS;
	SPIDER_DEBUG(m_dwRetryMS);

	RegQueryValueEx(hKey, TEXT("GKMaxRetries"), NULL, &dwType,
					(LPBYTE)&m_dwMaxRetries, &dwLen);
	if (m_dwMaxRetries == 0)
		m_dwMaxRetries = DEFAULT_MAX_RETRIES;
	SPIDER_DEBUG(m_dwMaxRetries);
#else
	m_dwRetryMS = DEFAULT_RETRY_MS;
	m_dwMaxRetries = DEFAULT_MAX_RETRIES;
#endif //_DEBUG
#endif // if(0)
	RegCloseKey(hKey);
}

void 
CGatekeeper::Write(void)
{
// ABSTRACT:  This member function will write the gatekeeper addresses and the
//            multicast flag to the Registry.
// AUTHOR:    Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::Write()\n", 0);

	RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Intel\\GKIDLL\\2.0"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	RegSetValueEx(hKey, TEXT("GKIPAddress"), NULL, REG_SZ, 
					(LPBYTE)m_GKIPAddress, lstrlenA(m_GKIPAddress));
#if(0)
#ifdef _DEBUG
	RegSetValueEx(hKey, TEXT("GKMCastTTL"), NULL, REG_DWORD, 
					(LPBYTE)&m_dwMCastTTL, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKRetryMS"), NULL, REG_DWORD,
					(LPBYTE)&m_dwRetryMS, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKMaxRetries"), NULL, REG_DWORD,
					(LPBYTE)&m_dwMaxRetries, sizeof(DWORD));

#endif //_DEBUG
#endif // if(0)
	RegCloseKey(hKey);
}

#ifdef BROADCAST_DISCOVERY		
void
CGatekeeper::DeleteCachedAddresses(void)
{
	// ABSTRACT:  This memeber function will delete the cached gatekeeper
	//            addresses from the Registry
	//AUTHOR:     Colin Hulme

	HKEY			hKey;
	DWORD			dwDisposition;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "CGatekeeper::DeleteCachedAddresses()\n", 0);

	RegCreateKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Intel\\GKIDLL\\2.0"),
				   0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
				   NULL, &hKey, &dwDisposition);
	RegDeleteValue(hKey, "GKIPAddress");
	RegDeleteValue(hKey, "GKIPXAddress");

#ifdef _DEBUG
	RegSetValueEx(hKey, TEXT("GKMCastTTL"), NULL, REG_DWORD, 
					(LPBYTE)&m_dwMCastTTL, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKRetryMS"), NULL, REG_DWORD,
					(LPBYTE)&m_dwRetryMS, sizeof(DWORD));
	RegSetValueEx(hKey, TEXT("GKMaxRetries"), NULL, REG_DWORD,
					(LPBYTE)&m_dwMaxRetries, sizeof(DWORD));
#endif

	RegCloseKey(hKey);
}
#endif //#ifdef BROADCAST_DISCOVERY		

void
CGatekeeper::Lock(void)
{
	EnterCriticalSection(&m_CriticalSection);
	m_dwLockingThread = GetCurrentThreadId();
}

void
CGatekeeper::Unlock(void)
{
	// Assert that the unlock is done by the
	// thread that holds the lock
	ASSERT(m_dwLockingThread == GetCurrentThreadId());
	
	m_dwLockingThread = 0;
	LeaveCriticalSection(&m_CriticalSection);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gatekpr.h ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gatekpr.h_v  $
*																		*
*	$Revision:   1.5  $
*	$Date:   12 Feb 1997 01:10:56  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gatekpr.h_v  $
 * 
 *    Rev 1.5   12 Feb 1997 01:10:56   CHULME
 * Redid thread synchronization to use Gatekeeper.Lock
 * 
 *    Rev 1.4   17 Jan 1997 12:52:46   CHULME
 * Removed UNICODE dependent code
 * 
 *    Rev 1.3   10 Jan 1997 16:14:26   CHULME
 * Removed MFC dependency
 * 
 *    Rev 1.2   20 Dec 1996 16:38:30   CHULME
 * Fixed access synchronization with Gatekeeper lock
 * 
 *    Rev 1.1   22 Nov 1996 15:24:22   CHULME
 * Added VCS log to the header
*************************************************************************/

// GATEKPR.H : interface of the CGatekeeper class
// See gatekeeper.cpp for the implementation of this class
/////////////////////////////////////////////////////////////////////////////

#ifndef GATEKEEPER_H
#define GATEKEEPER_H

class CGatekeeper
{
private:
	char				m_GKIPAddress[IPADDR_SZ + 1];
	SOCKADDR_IN         m_GKSockAddr;
	DWORD				m_dwMCastTTL;
	BOOL				m_fRejectReceived;
	CRITICAL_SECTION	m_CriticalSection;
	DWORD				m_dwLockingThread;

public:
	CGatekeeper();
	~CGatekeeper();

	void Read(void);
	void Write(void);
	#ifdef BROADCAST_DISCOVERY		
	void DeleteCachedAddresses(void);
	#endif // #ifdef BROADCAST_DISCOVERY		
	
	PSOCKADDR_IN GetSockAddr(void)
	{
	    if(m_GKSockAddr.sin_addr.S_un.S_addr != INADDR_ANY)
	    {	
	        return(&m_GKSockAddr);
	    }
	    else return NULL;
	}
	char *GetIPAddress(void)
	{
		return(m_GKIPAddress);
	}
	DWORD GetMCastTTL(void)
	{
		return m_dwMCastTTL;
	}
	BOOL GetRejectFlag(void)
	{
		return (m_fRejectReceived);
	}

	void SetIPAddress(char *szAddr)
	{
		if (lstrlenA(szAddr) <= IPADDR_SZ)
		{
			lstrcpyA(m_GKIPAddress, szAddr);
			m_GKSockAddr.sin_addr.s_addr = inet_addr(m_GKIPAddress);
		}
	}
    void SetSockAddr(PSOCKADDR_IN pAddr)
	{
	    if(pAddr && pAddr->sin_addr.S_un.S_addr != INADDR_ANY)
	    {
           m_GKSockAddr = *pAddr;
           lstrcpyA(m_GKIPAddress, inet_ntoa(m_GKSockAddr.sin_addr));
        }
	}
	void SetMCastTTL(DWORD dwttl)
	{
		m_dwMCastTTL = dwttl;
	}
	void SetRejectFlag(BOOL fReject)
	{
		m_fRejectReceived = fReject;
	}
	void Lock(void);
	void Unlock(void);
};

class CGatekeeperLock
{
private:
	CGatekeeper*	m_pGK;
public:
	CGatekeeperLock(CGatekeeper *pGK)
	{
		ASSERT(pGK);
		m_pGK = pGK;
		pGK->Lock();
	}
	~CGatekeeperLock()
	{
		m_pGK->Unlock();
	}
};

#endif // GATEKEEPER_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkibw.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkibw.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:12:16  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkibw.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:12:16   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:08   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:22   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:24   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:48   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:22:22   CHULME
// Added VCS log to the header
*************************************************************************/

// gkibandwidth.cpp : Handles the GKI_BandwidthRequest API
//
#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT 
GKI_BandwidthRequest(HANDLE	hModCall, unsigned short usCallTypeChoice, BandWidth bandWidth)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request a change in the bandwidth of an existing conference.
	//            The handle supplied by the client is actually a pointer to the CCall 
	//            object, which will be modified
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
	CCall			*pCall;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_BandwidthRequest(%X)\n", hModCall);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_BandwidthRequest()\n", 0);
		wsprintf(szGKDebug, "\thModCall = %p\n", hModCall);
		OutputDebugString(szGKDebug);
		wsprintf(szGKDebug, "\tusCallTypeChoice = %X\n", usCallTypeChoice);
		OutputDebugString(szGKDebug);
		wsprintf(szGKDebug, "\tbandWidth = %X\n", bandWidth);
		OutputDebugString(szGKDebug);
	}
#endif

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Validate call pointer
	pCall = (CCall *)hModCall;
	if (IsBadReadPtr(pCall, sizeof(CCall)))
		return (GKI_HANDLE_ERROR);
	if (pCall != (CCall *)pCall->GetHCall())
		return (GKI_HANDLE_ERROR);

	// Protect against concurrent PDUs
	if (pCall->GetRasMessage() != 0)
		return (GKI_BUSY);

	// Initialize CCall member variables
	pCall->SetCallType(usCallTypeChoice);
	pCall->SetBandWidth(bandWidth);

	// Create BandwidthRequest structure - Encode and send PDU
	if ((hResult = pCall->BandwidthRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkiadm.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkiadm.cpv  $
*																		*
*	$Revision:   1.9  $
*	$Date:   12 Feb 1997 01:12:06  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkiadm.cpv  $
// 
//    Rev 1.9   12 Feb 1997 01:12:06   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.8   17 Jan 1997 09:02:04   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.7   10 Jan 1997 16:15:12   CHULME
// Removed MFC dependency
// 
//    Rev 1.6   20 Dec 1996 16:38:34   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.5   17 Dec 1996 18:21:58   CHULME
// Switch src and destination fields on ARQ for Callee
// 
//    Rev 1.4   02 Dec 1996 23:49:32   CHULME
// Added premptive synchronization code
// 
//    Rev 1.3   22 Nov 1996 15:24:18   CHULME
// Added VCS log to the header
*************************************************************************/

// gkiadmission.cpp : Handles the GKI_AdmissionRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_AdmissionRequest(unsigned short		usCallTypeChoice,
					SeqAliasAddr		*pRemoteInfo,
					TransportAddress	*pRemoteCallSignalAddress,
					SeqAliasAddr		*pDestExtraCallInfo,
					LPGUID				pCallIdentifier,
					BandWidth			bandWidth,
					ConferenceIdentifier	*pConferenceID,
					BOOL				activeMC,
					BOOL				answerCall,
					unsigned short		usCallTransport)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request bandwidth for a conference.  It will create a CCall
	//            object to track all pertanent information.  The handle returned
	//            to the client asynchronously will actually be a pointer to this
	//            object.
	// AUTHOR:    Colin Hulme

	CCall			*pCall;
	SeqAliasAddr	*pAA;
	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_AdmissionRequest()\n", 0);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_AdmissionRequest()\n", 0);
		Dump_GKI_AdmissionRequest(usCallTypeChoice,
									pRemoteInfo,
									pRemoteCallSignalAddress, 
									pDestExtraCallInfo,
									bandWidth,
									pConferenceID,
									activeMC,
									answerCall,
									usCallTransport);
	}
#endif
	
	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);
		
	ASSERT(pCallIdentifier);
	ASSERT((usCallTransport == ipAddress_chosen) ||(usCallTransport == ipxAddress_chosen));

	// Create a call object
	pCall = new CCall;

	SPIDER_TRACE(SP_NEWDEL, "new pCall = %X\n", pCall);
	if (pCall == 0)
		return (GKI_NO_MEMORY);

	pCall->SetCallType(usCallTypeChoice);
	pCall->SetCallIdentifier(pCallIdentifier);
	
	// Add this call to our call list
	g_pReg->AddCall(pCall);

	for (pAA = pRemoteInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = pCall->AddRemoteInfo(pAA->value)) != GKI_OK)
		{
			g_pReg->DeleteCall(pCall);
			return (hResult);
		}
	}

	if (pRemoteCallSignalAddress)
		pCall->SetRemoteCallSignalAddress(pRemoteCallSignalAddress);

	for (pAA = pDestExtraCallInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = pCall->AddDestExtraCallInfo(pAA->value)) != GKI_OK)
		{
			g_pReg->DeleteCall(pCall);
			return (hResult);
		}
	}

	if ((hResult = pCall->SetLocalCallSignalAddress(usCallTransport)) != GKI_OK)
	{
		g_pReg->DeleteCall(pCall);
		return (hResult);
	}

	pCall->SetBandWidth(bandWidth);
	pCall->SetCallReferenceValue(g_pReg->GetNextCRV());
	pCall->SetConferenceID(pConferenceID);
	pCall->SetActiveMC(activeMC);
	pCall->SetAnswerCall(answerCall);

	// Create AdmissionRequest structure - Encode and send PDU
	if ((hResult = pCall->AdmissionRequest()) != GKI_OK)
	{
		g_pReg->DeleteCall(pCall);
		return (hResult);
	}

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkideng.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkideng.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:12:12  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkideng.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:12:12   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:12   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:32   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:36   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:54   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:20:08   CHULME
// Added VCS log to the header
*************************************************************************/

// gkidisengage.cpp : Handles the GKI_DisengageRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_DisengageRequest(HANDLE hCall)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to unregister with the Gatekeeper.  The handle supplied by the client
	//            is actually a pointer to the CRegistration object, which will be 
	//            deleted
	// AUTHOR:    Colin Hulme

	HRESULT			hResult;
	CCall			*pCall;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_DisengageRequest(%X)\n", hCall);
	SPIDER_TRACE(SP_GKI, "GKI_DisengageRequest(%X)\n", hCall);

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Validate call pointer
	pCall = (CCall *)hCall;
	if (IsBadReadPtr(pCall, sizeof(CCall)))
		return (GKI_HANDLE_ERROR);
	if (pCall != (CCall *)pCall->GetHCall())
		return (GKI_HANDLE_ERROR);

	// Protect against concurrent PDUs
	if (pCall->GetRasMessage() != 0)
		return (GKI_BUSY);

	// Create DisengageRequest structure - Encode and send PDU
	if ((hResult = pCall->DisengageRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkiloc.cpp ===
/************************************************************************
*																		*
*	INTEL CORPORATION PROPRIETARY INFORMATION							*
*																		*
*	This software is supplied under the terms of a license			   	*
*	agreement or non-disclosure agreement with Intel Corporation		*
*	and may not be copied or disclosed except in accordance	   			*
*	with the terms of that agreement.									*
*																		*
*	Copyright (C) 1997 Intel Corp.	All Rights Reserved					*
*																		*
*	$Archive:   S:\sturgeon\src\gki\vcs\gkiloc.cpv  $
*																		*
*	$Revision:   1.6  $
*	$Date:   12 Feb 1997 01:11:46  $
*																		*
*	$Author:   CHULME  $
*																		*
*   $Log:   S:\sturgeon\src\gki\vcs\gkiloc.cpv  $
// 
//    Rev 1.6   12 Feb 1997 01:11:46   CHULME
// Redid thread synchronization to use Gatekeeper.Lock
// 
//    Rev 1.5   17 Jan 1997 09:02:14   CHULME
// Changed reg.h to gkreg.h to avoid name conflict with inc directory
// 
//    Rev 1.4   10 Jan 1997 16:15:36   CHULME
// Removed MFC dependency
// 
//    Rev 1.3   20 Dec 1996 16:38:20   CHULME
// Fixed access synchronization with Gatekeeper lock
// 
//    Rev 1.2   02 Dec 1996 23:49:52   CHULME
// Added premptive synchronization code
// 
//    Rev 1.1   22 Nov 1996 15:22:02   CHULME
// Added VCS log to the header
*************************************************************************/

// gkilocation.cpp : Handles the GKI_LocationRequest API
//

#include "precomp.h"

#include <process.h>
#include <winsock.h>
#include "GKICOM.H"
#include "dspider.h"
#include "dgkilit.h"
#include "DGKIPROT.H"
#include "GATEKPR.H"
#include "gksocket.h"
#include "GKREG.H"
#include "dcall.h"
#include "h225asn.h"
#include "coder.hpp"
#include "dgkiext.h"

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern "C" HRESULT DLL_EXPORT
GKI_LocationRequest(SeqAliasAddr *pLocationInfo)
{
	// ABSTRACT:  This function is exported.  It is called by the client application
	//            to request the transport address for a terminal that is registered.  
	//            with the supplied alias addresses.  
	// AUTHOR:    Colin Hulme

	SeqAliasAddr	*pAA;
	HRESULT			hResult;
#ifdef _DEBUG
	char			szGKDebug[80];
#endif

	SPIDER_TRACE(SP_FUNC, "GKI_LocationRequest()\n", 0);

#ifdef _DEBUG
	if (dwGKIDLLFlags & SP_GKI)
	{
		SPIDER_TRACE(SP_GKI, "GKI_LocationRequest()\n", 0);
		Dump_GKI_LocationRequest(pLocationInfo);
	}
#endif

	// Create a Gatekeeper lock object on the stack
	// It's constructor will lock pGK and when we return
	// from any path, its destructor will unlock pGK
	CGatekeeperLock	GKLock(g_pGatekeeper);
	if (g_pReg == 0)
		return (GKI_NOT_REG);

	// Protect against concurrent PDUs
	if (g_pReg->GetRasMessage() != 0)
		return (GKI_BUSY);

	if (g_pReg->GetState() != CRegistration::GK_REGISTERED)
		return (GKI_NOT_REG);

	// Initialize CRegistration member variables
	for (pAA = pLocationInfo; pAA != 0; pAA = pAA->next)
	{
		if ((hResult = g_pReg->AddLocationInfo(pAA->value)) != GKI_OK)
			return (hResult);
	}

	// Create LocationRequest structure - Encode and send PDU
	if ((hResult = g_pReg->LocationRequest()) != GKI_OK)
		return (hResult);

	return (GKI_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkiexp.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 *
 *	$Revision:   1.7  $
 *	$Date:   11 Feb 1997 15:37:30  $
 *
 *	$Author:   CHULME  $															*
 *
 *	$Log:   S:\sturgeon\src\include\vcs\gkiexp.h_v  $
 * 
 *    Rev 1.7   11 Feb 1997 15:37:30   CHULME
 * Added GKI_CleanupRequest function
 * 
 *    Rev 1.6   16 Jan 1997 15:25:00   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.5   17 Dec 1996 18:23:36   CHULME
 * Change interface to use Remote rather than destination for AdmissionRequest
 * 
 *    Rev 1.4   09 Dec 1996 14:13:40   EHOWARDX
 * Updated copyright notice.
 *                                                                     * 
 ***********************************************************************/

// gkiexp.h : header file
//

#ifndef GKIEXP_H
#define GKIEXP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "GKICOM.H"

#if(0) // it's all in one DLL, no need for export
#ifndef DLL_EXPORT
#define DLL_EXPORT __declspec(dllexport)
#endif
#ifndef DLL_IMPORT
#define DLL_IMPORT __declspec(dllimport)
#endif
#else
#define DLL_IMPORT
#define DLL_EXPORT
#endif

// ------------------------ Variable Imports --------------------------
extern DLL_IMPORT DWORD dwGKIDLLFlags;
extern DLL_IMPORT BOOL  fGKIEcho;
extern DLL_IMPORT BOOL  fGKIDontSend;
#if 0 //NSMWrap
extern DLL_IMPORT BOOL  fNSMWrapper;
#endif

// ------------------------ Function Imports --------------------------
HRESULT DLL_IMPORT GKI_RegistrationRequest(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
    								PCC_VENDORINFO      pVendorInfo,
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_UnregistrationRequest(void);

HRESULT DLL_IMPORT GKI_LocationRequest(SeqAliasAddr         *pLocationInfo);

HRESULT DLL_IMPORT GKI_AdmissionRequest(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pRemoteInfo,
                                    TransportAddress     *pRemoteCallSignalAddress,
                                    SeqAliasAddr         *pDestExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

HRESULT DLL_IMPORT GKI_BandwidthRequest(HANDLE              hModCall, 
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

HRESULT DLL_IMPORT GKI_DisengageRequest(HANDLE hCall);
HRESULT DLL_IMPORT GKI_Initialize(void);
HRESULT DLL_IMPORT GKI_CleanupRequest(void);
VOID DLL_IMPORT GKI_SetGKAddress(PSOCKADDR_IN pAddr);

#ifdef _DEBUG
WORD DLL_IMPORT Dump_GKI_RegistrationRequest(long        lVersion, 
                                    SeqTransportAddr     *pCallSignalAddr, 
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr, 
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);

WORD DLL_IMPORT Dump_GKI_AdmissionRequest(unsigned short usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

WORD DLL_IMPORT Dump_GKI_LocationRequest(SeqAliasAddr    *pLocationInfo);
#endif // _DEBUG

#ifdef __cplusplus
}
#endif // __cplusplus

#endif //GKIEXP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkicom.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 *
 *	$Revision:   1.3  $
 *	$Date:   10 Jan 1997 17:41:10  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkicom.h_v  $
 * 
 *    Rev 1.3   10 Jan 1997 17:41:10   CHULME
 * Changed CallReturnInfo structure to contain CRV and conferenceID
 * 
 *    Rev 1.2   10 Jan 1997 16:06:54   CHULME
 * Removed stdafx.h check for non MFC GKI implementation
 * 
 *    Rev 1.1   27 Dec 1996 14:37:22   EHOWARDX
 * Split out error codes into GKIERROR.H.
 * 
 *    Rev 1.0   11 Dec 1996 14:49:48   EHOWARDX
 * Initial revision.
 * 
 *    Rev 1.9   09 Dec 1996 14:13:38   EHOWARDX
 * Updated copyright notice.
 * 
 *    Rev 1.8   22 Nov 1996 15:25:44   CHULME
 * Added VCS log to the header
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKICOM_H
#define GKICOM_H

#include "apierror.h"
#include "gkierror.h"
#include "h225asn.h"
#include "gk_asn1.h"

// The following GKVER_xxx constants define the expiration date of GKI.DLL
#define GKVER_EXPIRE_YEAR          1997
#define GKVER_EXPIRE_MONTH         10
#define GKVER_EXPIRE_DAY           31

typedef struct SeqTransportAddr {
	struct SeqTransportAddr	*next;
	TransportAddress value;
} SeqTransportAddr;

typedef struct SeqAliasAddr {
	struct SeqAliasAddr		*next;
	AliasAddress			value;
} SeqAliasAddr;

typedef struct CallReturnInfo {
	HANDLE					hCall;
	CallModel				callModel;
	TransportAddress		destCallSignalAddress;
	BandWidth				bandWidth;
	CallReferenceValue		callReferenceValue;
	ConferenceIdentifier	conferenceID;
	WORD					wError;
} CallReturnInfo;

// Version Information for GKI Interface
#define GKI_VERSION				21	// TBD - reset to 1 after testing

// wMsg literals - these are added to the wBaseMessage supplied by the user
#define GKI_REG_CONFIRM			1
#define GKI_REG_DISCOVERY		2
#define GKI_REG_REJECT			3
#define GKI_REG_BYPASS			4

#define GKI_UNREG_CONFIRM		5
#define GKI_UNREG_REJECT		6

#define GKI_ADM_CONFIRM			7
#define GKI_ADM_REJECT			8

#define GKI_BW_CONFIRM			9
#define GKI_BW_REJECT			0xa

#define GKI_DISENG_CONFIRM		0xb
#define GKI_DISENG_REJECT		0xc

#define GKI_LOCATION_CONFIRM	0xd
#define GKI_LOCATION_REJECT		0xe

#define GKI_UNREG_REQUEST		0xf

#define GKI_ERROR				0x10
#define MAX_ASYNC_MSGS			0x10

#define HR_SEVERITY_MASK				0x80000000
#define HR_R_MASK						0x40000000
#define HR_C_MASK						0x20000000
#define HR_N_MASK						0x10000000
#define HR_R2_MASK						0x08000000
#define HR_FACILITY_MASK				0x07ff0000
#define HR_CODE_MASK					0x0000ffff

#endif // GKICOM_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkierror.h ===
/***********************************************************************
 *  INTEL Corporation Proprietary Information                          *
 *                                                                     *
 *  This listing is supplied under the terms of a license agreement    *
 *  with INTEL Corporation and may not be copied nor disclosed except  *
 *  in accordance with the terms of that agreement.                    *
 *                                                                     *
 *      Copyright (c) 1997 Intel Corporation. All rights reserved.     *
 ***********************************************************************
 *																	   *
 *	$Archive:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 *
 *	$Revision:   1.2  $
 *	$Date:   08 Feb 1997 12:20:14  $
 *
 *	$Author:   CHULME  $
 *
 *  $Log:   S:\sturgeon\src\include\vcs\gkierror.h_v  $
 * 
 *    Rev 1.2   08 Feb 1997 12:20:14   CHULME
 * Added error code for semaphore creation error
 * 
 *    Rev 1.1   16 Jan 1997 15:25:08   BPOLING
 * changed copyrights to 1997
 * 
 *    Rev 1.0   27 Dec 1996 14:37:02   EHOWARDX
 * Initial revision.
 *                                                                     * 
 ***********************************************************************/

// gkicom.h : common includes between gkitest and gki
/////////////////////////////////////////////////////////////////////////////

#ifndef GKIERROR_H
#define GKIERROR_H

// Status codes
#define GKI_EXIT_THREAD_CODE			ERROR_LOCAL_BASE_ID + 1	// not actually error code
#define GKI_REDISCOVER_CODE				ERROR_LOCAL_BASE_ID + 2	// not actually error code
#define GKI_DELETE_CALL_CODE			ERROR_LOCAL_BASE_ID + 3	// not actually error code
#define GKI_GCF_RCV_CODE				ERROR_LOCAL_BASE_ID + 4	// not actually error code

#define GKI_ALREADY_REG_CODE			ERROR_LOCAL_BASE_ID + 0x10
#define GKI_VERSION_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x11
#define GKI_ENCODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x12
#define GKI_NOT_REG_CODE				ERROR_LOCAL_BASE_ID + 0x13
#define GKI_BUSY_CODE					ERROR_LOCAL_BASE_ID + 0x14
#define GKI_NO_TA_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x15
#define GKI_NO_RESPONSE_CODE			ERROR_LOCAL_BASE_ID + 0x16
#define GKI_DECODER_ERROR_CODE			ERROR_LOCAL_BASE_ID + 0x17
#define GKI_SEMAPHORE_ERROR_CODE		ERROR_LOCAL_BASE_ID + 0x18
#define GKI_NOT_INITIALIZED_ERROR_CODE	ERROR_LOCAL_BASE_ID + 0x19

#define GKI_OK							NOERROR

#define GKI_EXIT_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_EXIT_THREAD_CODE)
#define GKI_REDISCOVER					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_REDISCOVER_CODE)
#define GKI_DELETE_CALL					MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_DELETE_CALL_CODE)
#define GKI_GCF_RCV						MAKE_CUSTOM_HRESULT(SEVERITY_SUCCESS,1,FACILITY_GKI,GKI_GCF_RCV_CODE)

#define GKI_NO_MEMORY					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_OUTOFMEMORY)
#define GKI_NO_THREAD					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_TOO_MANY_TCBS)
#define GKI_HANDLE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,ERROR_INVALID_HANDLE)

#define GKI_ALREADY_REG					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ALREADY_REG_CODE)
#define GKI_VERSION_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_VERSION_ERROR_CODE)
#define GKI_ENCODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_ENCODER_ERROR_CODE)
#define GKI_NOT_REG						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_REG_CODE)
#define GKI_BUSY						MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_BUSY_CODE)
#define GKI_NO_TA_ERROR					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_TA_ERROR_CODE)
#define GKI_NO_RESPONSE					MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NO_RESPONSE_CODE)
#define GKI_DECODER_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_DECODER_ERROR_CODE)
#define GKI_SEMAPHORE_ERROR				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_SEMAPHORE_ERROR_CODE)

#define GKI_WINSOCK2_ERROR(w)			(MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_WINSOCK2,w))
#define GKI_NOT_INITIALIZED				MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKI,GKI_NOT_INITIALIZED_ERROR_CODE)

#endif // GKIERROR_H

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkiman.h ===
/****************************************************************************
 *
 *	$Archive:   S:/STURGEON/SRC/CALLCONT/VCS/gkiman.h_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 *	Copyright (c) 1996 Intel Corporation.
 *
 *	$Revision:   1.19  $
 *	$Date:   27 Jan 1997 16:29:40  $
 *	$Author:   EHOWARDX  $
 *
 *	Deliverable:
 *
 *	Abstract:
 *
 *	Notes:
 *
 ***************************************************************************/

#ifdef GATEKEEPER

#ifndef GKIMAN_H
#define GKIMAN_H

//extern HINSTANCE hGkiDll;
extern BOOL fGKConfigured;
extern BOOL fGKEnabled;
#define GKIExists() (fGKConfigured && fGKEnabled)

typedef enum _CHANNELTYPE
{
  TX,
  RX
} CHANNELTYPE;

typedef struct _BWREQ
{
  struct _BWREQ *   pNext;
  unsigned int      uChannelBandwidth;
  CC_HCHANNEL       hChannel;
  CHANNELTYPE       Type;
} BWREQ, *PBWREQ;

typedef enum _CALLTYPE
{
  POINT_TO_POINT  = 1,
  ONE_TO_MANY,
  MANY_TO_ONE,
  MANY_TO_MANY
} CALLTYPE;

typedef struct _GKICALL
{
  struct _GKICALL * pNext;
  struct _BWREQ *   pBwReqHead;
  struct _BWREQ *   pBwReqTail;
  unsigned int      uGkiCallState;
#define GCS_START                   0
#define GCS_WAITING                 1
#define GCS_ADMITTING               2
#define GCS_ADMITTING_CLOSE_PENDING 3
#define GCS_ADMITTED                4
#define GCS_CHANGING                5
#define GCS_CHANGING_CLOSE_PENDING  6
#define GCS_DISENGAGING             7
  void *            pCall;
  CALLTYPE          CallType;
  unsigned int      uBandwidthRequested;
  unsigned int      uBandwidthAllocated;
  unsigned int      uBandwidthUsed;
  unsigned char     *pConferenceId;
  BOOL              bConferenceIdPresent;
  BOOL              bActiveMC;
  BOOL              bAnswerCall;
  BOOL              bGatekeeperRouted;
  HANDLE            hGkiCall;
  CC_HCALL          hCall;
  DWORD             dwIpAddress;
  unsigned short    wPort;
  unsigned short    usCallModelChoice;
  unsigned short    usCallTypeChoice;
  unsigned short    usCRV;
  PCC_ALIASNAMES    pCalleeAliasNames;
  PCC_ALIASNAMES    pCalleeExtraAliasNames;
  GUID              CallIdentifier;
} GKICALL, *PGKICALL, **PPGKICALL;

HRESULT GkiSetRegistrationAliases(PCC_ALIASNAMES pLocalAliasNames);
HRESULT GkiSetVendorConfig( PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration);
HRESULT GkiOpenListen  (CC_HLISTEN hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort);
HRESULT GkiListenAddr (SOCKADDR_IN* psin);
HRESULT GkiCloseListen (CC_HLISTEN hListen);
HRESULT GkiOpenCall    (PGKICALL pGkiCall, void *pConference);
HRESULT GkiCloseCall   (PGKICALL pGkiCall);
HRESULT GkiFreeCall    (PGKICALL pGkiCall);
HRESULT GkiOpenChannel (PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel, CHANNELTYPE Type);
HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel);

#endif // GKIMAN_H

#endif // GATEKEEPER

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\netmeeting\av\callcont\gkiman.c ===
/****************************************************************************
 *
 * $Archive:   S:\sturgeon\src\callcont\vcs\gkiman.c_v  $
 *
 *  INTEL Corporation Prorietary Information
 *
 *  This listing is supplied under the terms of a license agreement
 *  with INTEL Corporation and may not be copied nor disclosed except
 *  in accordance with the terms of that agreement.
 *
 * Copyright (c) 1996 Intel Corporation.
 *
 * $Revision:   1.77  $
 * $Date:   05 Mar 1997 14:30:26  $
 * $Author:   SBELL1  $
 *
 * Deliverable:
 *
 * Abstract:
 *
 * Notes:
 *
 *  Much effort has gone into working around the following constraints of
 *  the GKI interface:
 *  1) Only one admission request can be pending at a time. This is because
 *     the hCall is unknown until it completes.
 *  2) Only one bandwidth request per call can be pending at a time.
 *  3) Any pending bandwidth request must complete before issuing a
 *     disengage request.
 *  4) Any calls must be disengaged before issuing a deregistration request.
 *
 ***************************************************************************/
#ifdef GATEKEEPER

#include "precomp.h"

#include "incommon.h"
#include "ccerror.h"
#include "isrg.h"
#include "gkiexp.h"
#include "callman2.h"
#include "cclock.h"
#include "iras.h"
#include "bestintf.h"

#pragma warning ( default : 4115 4201 4214)


#ifdef FORCE_SERIALIZE_CALL_CONTROL
#define EnterCallControlTop()      {CCLOCK_AcquireLock();}

#define LeaveCallControlTop(f)     {HRESULT stat; \
	                                stat = f; \
									CCLOCK_RelinquishLock(); \
                                    return stat;}
#else
#define EnterCallControlTop()
#define LeaveCallControlTop(f) {HRESULT stat; \
	                                stat = f; \
									return stat;}
#endif



#define GKIMAN_BASE             WM_USER

#define MIN_BANDWIDTH           1
#define MAX_BANDWIDTH           (0xFFFFFFFF / 100)

#define GKI_ADMITTING_HANDLE    ((HANDLE)-1)
#define GKI_BYPASS_HANDLE       ((HANDLE)-2)

// GKI Manager state
#define STATE_START                0
#define STATE_CLASS_REGISTERED     1
#define STATE_WINDOW_CREATED       2
#define STATE_REGISTERING          3
#define STATE_REGISTERING_REREG    4
#define STATE_REGISTERING_UNREG    5
#define STATE_REGISTERED           6
#define STATE_ADMITTING            7
#define STATE_ADMITTING_REREG      8
#define STATE_ADMITTING_UNREG      9
#define STATE_DISENGAGING         10
#define STATE_DISENGAGING_REREG   11
#define STATE_UNREGISTERING       12
#define STATE_UNREGISTERING_REREG 13
#define STATE_REG_BYPASS          14



typedef HRESULT (*PGKI_RegistrationRequest)(long             lVersion,
                                    SeqTransportAddr     *pCallSignalAddr,
                                    EndpointType         *pTerminalType,
                                    SeqAliasAddr         *pAliasAddr,
                                    PCC_VENDORINFO       pVendorInfo,
                                    HWND                 hWnd,
                                    WORD                 wBaseMessage,
                                    unsigned short       usRegistrationTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_UnregistrationRequest)(void);

typedef HRESULT (*PGKI_LocationRequest)(SeqAliasAddr         *pLocationInfo);

typedef HRESULT (*PGKI_AdmissionRequest)(unsigned short      usCallTypeChoice,
                                    SeqAliasAddr         *pDestinationInfo,
                                    TransportAddress     *pDestCallSignalAddress,
                                    SeqAliasAddr         *pDextExtraCallInfo,
                       				LPGUID               pCallIdentifier,
                                    BandWidth            bandWidth,
                                    ConferenceIdentifier *pConferenceID,
                                    BOOL                 activeMC,
                                    BOOL                 answerCall,
                                    unsigned short       usCallTransport /* = ipAddress_chosen */);

typedef HRESULT (*PGKI_BandwidthRequest)(HANDLE              hModCall,
                                    unsigned short       usCallTypeChoice,
                                    BandWidth            bandWidth);

typedef HRESULT (*PGKI_DisengageRequest)(HANDLE hCall);
typedef HRESULT (*PGKI_Initialize)(void);
typedef HRESULT (*PGKI_CleanupRequest)(void);

HRESULT Q931CopyAliasNames(PCC_ALIASNAMES *ppTarget, PCC_ALIASNAMES pSource);
HRESULT Q931FreeAliasNames(PCC_ALIASNAMES pSource);
#define CopyAliasNames Q931CopyAliasNames
#define FreeAliasNames Q931FreeAliasNames
HRESULT CopyVendorInfo(				PCC_VENDORINFO			*ppDest,
									PCC_VENDORINFO			pSource);
HRESULT FreeVendorInfo(				PCC_VENDORINFO			pVendorInfo);




typedef struct _LISTEN
{
  struct _LISTEN *  pNext;
  PCC_ALIASNAMES    pAliasNames;
  CC_HLISTEN        hListen;
  DWORD             dwAddr;
  WORD              wPort;
} LISTEN, *PLISTEN;

//
// GKI Manager Global Data
//
CRITICAL_SECTION  GkiLock;
const char      szClassName[]         = "GkiManWndClass";
HWND            hwndGki               = 0;
ATOM            atomGki               = 0;
unsigned int    uGkiState             = STATE_START;
PLISTEN         pListenList           = NULL;
unsigned int    uGkiCalls             = 0;
unsigned int    uPendingDisengages    = 0;


BOOL            fGKConfigured   = FALSE;
BOOL            fGKEnabled      = FALSE;
PCC_ALIASNAMES  gpLocalAliasNames = NULL;
PCC_VENDORINFO  gpVendorInfo = NULL;
DWORD           g_dwMultipointConfiguration = 0;
RASNOTIFYPROC gpRasNotifyProc = NULL;

// HINSTANCE				   hGkiDll					  = 0;
PGKI_RegistrationRequest   pGKI_RegistrationRequest   = NULL;
PGKI_UnregistrationRequest pGKI_UnregistrationRequest = NULL;
PGKI_LocationRequest       pGKI_LocationRequest       = NULL;
PGKI_AdmissionRequest      pGKI_AdmissionRequest      = NULL;
PGKI_BandwidthRequest      pGKI_BandwidthRequest      = NULL;
PGKI_DisengageRequest      pGKI_DisengageRequest      = NULL;
PGKI_CleanupRequest		   pGKI_CleanupRequest        = NULL;
PGKI_Initialize            pGKI_Initialize          = NULL;

HRESULT ValidateCall(CC_HCALL hCall);
HRESULT	LastGkiError = CC_GKI_STATE;

//
// Forward declarations
//
LRESULT APIENTRY GkiWndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);



//
// Helper subroutines
//

#ifdef    _DEBUG

typedef struct _GKIMAP
{
  HRESULT       hResult;
  char *        pString;
} GKIMAP;

GKIMAP GkiErrorNames[] =
{
  GKI_OK,               "GKI_OK",
  GKI_EXIT_THREAD,      "GKI_EXIT_THREAD",
  GKI_REDISCOVER,       "GKI_REDISCOVER",
  GKI_DELETE_CALL,      "GKI_DELETE_CALL",
  GKI_GCF_RCV,          "GKI_GCF_RCV",
  GKI_NO_MEMORY,        "GKI_NO_MEMORY",
  GKI_NO_THREAD,        "GKI_NO_THREAD",
  GKI_HANDLE_ERROR,     "GKI_HANDLE_ERROR",
  GKI_ALREADY_REG,      "GKI_ALREADY_REG",
  GKI_VERSION_ERROR,    "GKI_VERSION_ERROR",
  GKI_ENCODER_ERROR,    "GKI_ENCODER_ERROR",
  GKI_NOT_REG,          "GKI_NOT_REG",
  GKI_BUSY,             "GKI_BUSY",
  GKI_NO_TA_ERROR,      "GKI_NO_TA_ERROR",
  GKI_NO_RESPONSE,      "GKI_NO_RESPONSE",
  GKI_DECODER_ERROR,    "GKI_DECODER_ERROR",
};

char *StateNames[] =
{
  "STATE_START",
  "STATE_CLASS_REGISTERED",
  "STATE_WINDOW_CREATED",
  "STATE_REGISTERING",
  "STATE_REGISTERING_REREG",
  "STATE_REGISTERING_UNREG",
  "STATE_REGISTERED",
  "STATE_ADMITTING",
  "STATE_ADMITTING_REREG",
  "STATE_ADMITTING_UNREG",
  "STATE_DISENGAGING",
  "STATE_DISENGAGING_REREG",
  "STATE_UNREGISTERING",
  "STATE_UNREGISTERING_REREG",
  "STATE_REG_BYPASS",
};

char *CallStateNames[] =
{
  "GCS_START",
  "GCS_WAITING",
  "GCS_ADMITTING",
  "GCS_ADMITTING_CLOSE_PENDING",
  "GCS_ADMITTED",
  "GCS_CHANGING",
  "GCS_CHANGING_CLOSE_PENDING",
  "GCS_DISENGAGING",
};

char szBuffer[128];

char * GkiErrorName(char *szFormat, HRESULT hResult)
{
  register int  nIndex = sizeof(GkiErrorNames) / sizeof(GkiErrorNames[0]);
  char          szTemp[32];

  while (nIndex > 0)
  {
    if (GkiErrorNames[--nIndex].hResult == hResult)
    {
      wsprintf(szBuffer, szFormat, GkiErrorNames[nIndex].pString);
      return szBuffer;
    }
  }

  wsprintf(szTemp, "Unknown(0x%x)", hResult);
  wsprintf(szBuffer, szFormat, szTemp);
  return szBuffer;
} // GkiErrorName()

char * StateName(char *szFormat, unsigned uState)
{
  char szTemp[32];
  if (uState < (sizeof(StateNames)/sizeof(StateNames[0])))
  {
    wsprintf(szBuffer, szFormat, StateNames[uState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // StateName()

char * CallStateName(char *szFormat, unsigned uCallState)
{
  char szTemp[32];
  if (uCallState <= (sizeof(CallStateNames)/sizeof(CallStateNames[0])))
  {
    wsprintf(szBuffer, szFormat, CallStateNames[uCallState]);
  }
  else
  {
    wsprintf(szTemp, "Unknown(%d)", uCallState);
    wsprintf(szBuffer, szFormat, szTemp);
  }
  return szBuffer;
} // CallStateName()

#else

#define GkiErrorName(x,y)   ""
#define StateName(x,y)      ""
#define CallStateName(x,y)  ""

#endif // _DEBUG



HRESULT MapRegistrationRejectReason(UINT uReason)
{
#if(0)  // this must have been coded by the department of redundancy department
   register HRESULT lReason;
 // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case discoveryRequired_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidCallSignalAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidRASAddress_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case duplicateAlias_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidTerminalType_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case RgstrtnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case transportNotSupported_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
#else
    return (MAKE_CUSTOM_HRESULT(SEVERITY_ERROR, TRUE, FACILITY_GKIREGISTRATION, (LOWORD(uReason))));
#endif
} // MapRegistrationRejectReason()


HRESULT MapUnregistrationRequestReason(UINT uReason)
{
    HRESULT lReason;
    lReason = MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKIUNREGREQ, ERROR_LOCAL_BASE_ID + (LOWORD(uReason)));
    return lReason;
}
HRESULT MapAdmissionRejectReason(register UINT uReason)
{
  register HRESULT lReason;
#if(0)
  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case AdmissionRejectReason_calledPartyNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case ARRn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rqstDnd_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmissionRejectReason_callerNotRegistered_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmissionRejectReason_routeCallToGatekeeper_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invldEndpntIdntfr_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case AdmssnRjctRsn_rsrcUnvlbl_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch
#else// last 8 bits are the reason code
    lReason = MAKE_CUSTOM_HRESULT(SEVERITY_ERROR,1,FACILITY_GKIADMISSION, ERROR_LOCAL_BASE_ID + (uReason & 0xff));
#endif
  return lReason;
} // MapAdmissionRejectReason()



HRESULT MapBandwidthRejectReason(register UINT uReason)
{
  register HRESULT lReason;

  // TBD - Map reason code into CC_xxx HRESULT
  switch (uReason)
  {
  case notBound_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case invalidConferenceID_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldPrmssn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case insufficientResources_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_invldRvsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  case BndRjctRsn_undfndRsn_chosen:
    lReason = CC_GATEKEEPER_REFUSED;
    break;
  default:
    lReason = CC_GATEKEEPER_REFUSED;
  } // switch

  return lReason;
} // MapBandwidthRejectReason()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenEnqueue(register PLISTEN pListen)
{
  pListen->pNext = pListenList;
  return pListenList = pListen;
} // ListenEnqueue()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

static PLISTEN ListenDequeue(CC_HLISTEN hListen)
{
  register PLISTEN      pListen = pListenList;
  register PLISTEN      pListenPrev;

  if (pListen)
  {
    if (pListen->hListen == hListen)
    {
      pListenList = pListen->pNext;
    }
    else
    {
      do
      {
        pListenPrev = pListen;
        pListen = pListen->pNext;
      } while (pListen && pListen->hListen != hListen);
      if (pListen)
      {
        pListenPrev->pNext = pListen->pNext;
      }
    }
  }

  return pListen;
} // ListenDequeue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqEnqueue(register PGKICALL pGkiCall, register PBWREQ pBwReq)
{
  pBwReq->pNext = NULL;
  if (pGkiCall->pBwReqHead)
  {
    pGkiCall->pBwReqTail->pNext = pBwReq;
  }
  else
  {
    pGkiCall->pBwReqHead = pBwReq;
  }
  return pGkiCall->pBwReqTail = pBwReq;
} // BwReqEnqueue()



/*
 *  NOTES
 *    Since the pGkiCall is locked, we don't need a critical section
 *    around the queue manipulation code.
 */

static PBWREQ BwReqDequeue(register PGKICALL pGkiCall)
{
  register PBWREQ pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    pGkiCall->pBwReqHead = pBwReq->pNext;
  }
  return pBwReq;
} // BwReqDequeue()



DWORD GetIpAddress(void)
{
  DWORD dwAddr;
  char szHostName[128];
  if (gethostname(szHostName, sizeof(szHostName)) == 0)
  {
    struct hostent *pHostent;
    pHostent = gethostbyname(szHostName);
    if (pHostent != NULL)
    {
      ASSERT(pHostent->h_addrtype == AF_INET);
      dwAddr = *((DWORD *)pHostent->h_addr_list[0]);
      return ntohl(dwAddr);
    }
  }

  return INADDR_ANY;
} // GetIpAddress()



// Caveat: *pAlias should be initialized to all 0 before calling!

static HRESULT CopyAliasItem(SeqAliasAddr *pAlias, PCC_ALIASITEM pAliasItem)
{
  unsigned int uDigit;
  unsigned int uPrefixLength;
  unsigned int uDataLength;

  if (pAliasItem->pData == NULL || pAliasItem->wDataLength == 0)
    return CC_BAD_PARAM;

  if (pAliasItem->pPrefix)
  {
    // Strip off terminating NULs if included in prefix length
    uPrefixLength = pAliasItem->wPrefixLength;
    while (uPrefixLength && pAliasItem->pPrefix[uPrefixLength - 1] == 0)
      --uPrefixLength;
  }
  else
  {
    uPrefixLength = 0;
  }

  uDataLength = pAliasItem->wDataLength;

  switch (pAliasItem->wType)
  {
  case CC_ALIAS_H323_ID:
    pAlias->value.choice = h323_ID_chosen;
    pAlias->value.u.h323_ID.value = MemAlloc((uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0]));
    if (pAlias->value.u.h323_ID.value == NULL)
    {
      ISRERROR(ghISRInst, "CopyAliasItem: Could not allocate %d bytes memory",
               (uPrefixLength + uDataLength) * sizeof(pAliasItem->pData[0]));
      return CC_NO_MEMORY;
    }
    if (uPrefixLength)
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pPrefix,
             uPrefixLength * sizeof(pAliasItem->pPrefix[0]));
      memcpy(&pAlias->value.u.h323_ID.value[uPrefixLength],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    else
    {
      memcpy(&pAlias->value.u.h323_ID.value[0],
             pAliasItem->pData,
             uDataLength * sizeof(pAliasItem->pData[0]));
    }
    pAlias->value.u.h323_ID.length = (unsigned short)(uPrefixLength + uDataLength);
    break;

  case CC_ALIAS_H323_PHONE:
    pAlias->value.choice = e164_chosen;
    if (uPrefixLength)
    {
      for (uDigit = 0; uDigit < uPrefixLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pPrefix[uDigit];
      }
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit + uPrefixLength] = (char)pAliasItem->pData[uDigit];
      }
    }
    else
    {
      for (uDigit = 0; uDigit < uDataLength; ++uDigit)
      {
        pAlias->value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
      }
    }
    break;

  default:
    ISRERROR(ghISRInst, "CopyAliasItem: Bad alias name type %d", pAliasItem->wType);
    return CC_BAD_PARAM;
  } // switch

  return NOERROR;
} // CopyAliasItem()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static void GkiAllocCall(PGKICALL pGkiCall, HANDLE hGkiCall)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(hGkiCall != 0);
  ASSERT(hGkiCall != GKI_ADMITTING_HANDLE);
  pGkiCall->hGkiCall = hGkiCall;
  pGkiCall->uGkiCallState = GCS_ADMITTED;
  ++uGkiCalls;
  ISRTRACE(ghISRInst, "GkiAllocCall: uGkiCalls = %d", uGkiCalls);
} // GkiAllocCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelCall(PGKICALL pGkiCall, void *pConference)
{
  CC_HCALL hCall;

  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  hCall = pGkiCall->hCall;

  ISRTRACE(ghISRInst, CallStateName("GkiCancelCall <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
    break;

  case GCS_WAITING:
    ASSERT(pGkiCall->hGkiCall == 0);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTING:
  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    if (pGkiCall->bAnswerCall)
      AcceptCallReject(pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    else
      PlaceCallReject (pGkiCall->pCall, pConference, CC_GATEKEEPER_REFUSED);
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    ASSERT(pGkiCall->hGkiCall != 0);
    ASSERT(pGkiCall->hGkiCall != GKI_ADMITTING_HANDLE);
    Disengage(pGkiCall->pCall);
    return NOERROR;

  default:
    ISRERROR(ghISRInst, "GkiCancelCall: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  if (ValidateCall(hCall) == NOERROR && pGkiCall->uGkiCallState != GCS_START)
  {
    GkiFreeCall(pGkiCall);
  }

  ISRTRACE(ghISRInst, CallStateName("GkiCancelCall -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCancelCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT GkiCancelAdmitting(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning

  ISRTRACE(ghISRInst, CallStateName("GkiCancelAdmitting <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_ADMITTING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    pGkiCall->hGkiCall = 0;
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(pGkiCall->hGkiCall == GKI_ADMITTING_HANDLE);
    GkiFreeCall(pGkiCall);
    break;

  } // switch

  ISRTRACE(ghISRInst, CallStateName("GkiCancelAdmitting -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCancelAdmitting()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall);

static HRESULT GatekeeperNotFound(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  ISRTRACE(ghISRInst, CallStateName("GatekeeperNotFound <- Call State = %s", pGkiCall->uGkiCallState), 0);

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_ADMITTED:
    break;

  case GCS_WAITING:
  case GCS_ADMITTING:
    GkiOpenCall(pGkiCall, pConference);
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    GkiCloseCall(pGkiCall);
    break;

  case GCS_CHANGING:
    pGkiCall->uGkiCallState = GCS_ADMITTED;
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    CheckPendingBandwidth(pGkiCall);
    break;

  default:
    ISRERROR(ghISRInst, "GatekeeperNotFound: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  ISRTRACE(ghISRInst, CallStateName("GatekeeperNotFound -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GatekeeperNotFound()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

HRESULT GkiRegister(void)
{
  register HRESULT      status = NOERROR;

  ASSERT(pListenList != NULL);

  switch (uGkiState)
  {
  case STATE_START:
    // Register window class
    {
      WNDCLASS wndclass = { 0, GkiWndProc, 0, 0, 0, 0, 0, 0, NULL, szClassName };
      atomGki = RegisterClass(&wndclass);
      if (atomGki == 0)
      {
        status = HRESULT_FROM_WIN32(GetLastError());
        ISRERROR(ghISRInst, "GkiRegister: Error 0x%x registering class", status);
        break;
      }
    }
    uGkiState = STATE_CLASS_REGISTERED;

  // Fall-through to next case

  case STATE_CLASS_REGISTERED:
    // Create window to receive GKI messages
    hwndGki = CreateWindow(szClassName, "", WS_OVERLAPPED, 0, 0, 0, 0, 0, 0, 0, NULL);
    if (hwndGki == 0)
    {
      status = HRESULT_FROM_WIN32(GetLastError());
      ISRERROR(ghISRInst, "GkiRegister: Error 0x%x creating window", status);
      break;
    }
    uGkiState = STATE_WINDOW_CREATED;

    // Fall-through to next case

  case STATE_WINDOW_CREATED:
    {
      PLISTEN           pListen;
      unsigned          uListens    = 0;
      unsigned          uAliasNames = 0;
      SeqTransportAddr *pTransportAddrs;
      SeqAliasAddr     *pAliasAddrs = NULL;
      SeqAliasAddr     *pRegistrationAliasAddrs = NULL;
      PCC_ALIASITEM     pAliasItem;
      unsigned          uIndex;
      unsigned          uDigit;
      EndpointType      TerminalType = {0};

      // Count Transport Addresses and Alias Names
      pListen = pListenList;
      while (pListen)
      {
        // Count the Transport Address
        ++uListens;

        if (pListen->pAliasNames)
        {
          // Count the Alias Names
          uAliasNames += pListen->pAliasNames->wCount;
        }
        pListen = pListen->pNext;
      }

      // if the separately configured alias names exist, override what was
      // in the listen list
      if(gpLocalAliasNames)
      {
        uAliasNames = gpLocalAliasNames->wCount;
      }

      pTransportAddrs = MemAlloc(uListens * sizeof(*pTransportAddrs));
      if (pTransportAddrs == NULL)
      {
        ISRERROR(ghISRInst, "GkiRegister: Could not allocate %d Transport Addresses", uListens);
        return CC_NO_MEMORY;
      }

      if (uAliasNames)
      {
        pAliasAddrs =
            MemAlloc(uAliasNames * sizeof(*pAliasAddrs));
        if (pAliasAddrs == NULL)
        {
          MemFree(pTransportAddrs);
          ISRERROR(ghISRInst, "GkiRegister: Could not allocate %d Alias Addresses", uAliasNames);
          return CC_NO_MEMORY;
        }
      }

      pListen     = pListenList;
      uListens    = 0;
      uAliasNames = 0;
      // if the separately configured alias names exist, override what was
      // in the listen list
      if(gpLocalAliasNames)
      {
          pAliasItem = gpLocalAliasNames->pItems;
          for (uIndex = 0; uIndex < gpLocalAliasNames->wCount; ++uIndex, ++pAliasItem)
          {
            pAliasAddrs[uAliasNames].next = &pAliasAddrs[uAliasNames + 1];
            switch (pAliasItem->wType)
            {
            case CC_ALIAS_H323_ID:
              pAliasAddrs[uAliasNames].value.choice = h323_ID_chosen;
              pAliasAddrs[uAliasNames].value.u.h323_ID.length = pAliasItem->wDataLength;
              pAliasAddrs[uAliasNames].value.u.h323_ID.value  = pAliasItem->pData;
              break;

            case CC_ALIAS_H323_PHONE:
              pAliasAddrs[uAliasNames].value.choice = e164_chosen;
              memset(pAliasAddrs[uAliasNames].value.u.e164, 0, sizeof(pAliasAddrs[uAliasNames].value.u.e164));
              for (uDigit = 0; uDigit < pAliasItem->wDataLength; ++uDigit)
              {
                pAliasAddrs[uAliasNames].value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
              }
              break;

            default:
              MemFree(pAliasAddrs);
              ISRERROR(ghISRInst, "GkiRegister: Bad alias name type %d",
                      pAliasItem->wType);
              return CC_BAD_PARAM;
            } // switch
            ++uAliasNames;
          } // for
      }
      while (pListen)
      {
        // Initialize a transport address
        // TBD - throw out duplicates
        pTransportAddrs[uListens].next = &pTransportAddrs[uListens + 1];
        pTransportAddrs[uListens].value.choice = ipAddress_chosen;
        pTransportAddrs[uListens].value.u.ipAddress.ip.length = 4;
        *((DWORD *)pTransportAddrs[uListens].value.u.ipAddress.ip.value) = pListen->dwAddr;
        pTransportAddrs[uListens].value.u.ipAddress.port = pListen->wPort;

        // Add any alias names to list (unless separately configured alias names exist)
        // TBD - throw out duplicates
        if ((gpLocalAliasNames == NULL) && pAliasAddrs && pListen->pAliasNames)
        {
          pAliasItem = pListen->pAliasNames->pItems;
          for (uIndex = 0; uIndex < pListen->pAliasNames->wCount; ++uIndex, ++pAliasItem)
          {
            pAliasAddrs[uAliasNames].next = &pAliasAddrs[uAliasNames + 1];
            switch (pAliasItem->wType)
            {
            case CC_ALIAS_H323_ID:
              pAliasAddrs[uAliasNames].value.choice = h323_ID_chosen;
              pAliasAddrs[uAliasNames].value.u.h323_ID.length = pAliasItem->wDataLength;
              pAliasAddrs[uAliasNames].value.u.h323_ID.value  = pAliasItem->pData;
              break;

            case CC_ALIAS_H323_PHONE:
              pAliasAddrs[uAliasNames].value.choice = e164_chosen;
              memset(pAliasAddrs[uAliasNames].value.u.e164, 0, sizeof(pAliasAddrs[uAliasNames].value.u.e164));
              for (uDigit = 0; uDigit < pAliasItem->wDataLength; ++uDigit)
              {
                pAliasAddrs[uAliasNames].value.u.e164[uDigit] = (char)pAliasItem->pData[uDigit];
              }
              break;

            default:
              MemFree(pAliasAddrs);
              MemFree(pTransportAddrs);
              ISRERROR(ghISRInst, "GkiRegister: Bad alias name type %d",
                      pAliasItem->wType);
              return CC_BAD_PARAM;
            } // switch
            ++uAliasNames;
          } // for
        } // if
        ++uListens;
        pListen = pListen->pNext;
      } // while
      pTransportAddrs[uListens - 1].next = NULL;
      if (pAliasAddrs)
      {
        pAliasAddrs[uAliasNames - 1].next = NULL;
      }

      // Initialize TerminalType
      TerminalType.bit_mask = terminal_present;
      TerminalType.mc = (g_dwMultipointConfiguration)?TRUE:FALSE;

      uGkiState = STATE_REGISTERING;
      ISRTRACE(ghISRInst, "GKI_RegistrationRequest called...", 0);
      status =
        pGKI_RegistrationRequest(GKI_VERSION,       // lVersion
                                 pTransportAddrs,   // pCallSignalAddr
                                 &TerminalType,     // pTerminalType
                                 pAliasAddrs,       // pRgstrtnRgst_trmnlAls
                                 gpVendorInfo,
                                 hwndGki,           // hWnd
                                 GKIMAN_BASE,       // wBaseMessage
                                 ipAddress_chosen); // usRegistrationTransport
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_RegistrationRequest returned %s", status), 0);
        uGkiState = STATE_WINDOW_CREATED;
      }
      if (pAliasAddrs)
        MemFree(pAliasAddrs);
      if (pTransportAddrs)
        MemFree(pTransportAddrs);
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
    uGkiState = STATE_REGISTERING_REREG;
    break;

  case STATE_REGISTERED:
    uGkiState = STATE_UNREGISTERING_REREG;
    ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
    status = pGKI_UnregistrationRequest();
    if (status == NOERROR)
    {
      ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
    }
    else
    {
      ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
    }
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING_UNREG:
    uGkiState = STATE_ADMITTING_REREG;
    break;

  case STATE_DISENGAGING:
    uGkiState = STATE_DISENGAGING_REREG;
    break;

  case STATE_DISENGAGING_REREG:
    break;

  case STATE_UNREGISTERING:
    uGkiState = STATE_UNREGISTERING_REREG;
    break;

  case STATE_UNREGISTERING_REREG:
    break;

  case STATE_REG_BYPASS:
    break;

  default:
    ISRERROR(ghISRInst, "GkiRegister: Invalid state %d", uGkiState);
    status = LastGkiError;
  } // switch

  return status;
} // GkiRegister()



/*
 *  NOTES
 *    GkiLock must be locked before calling this routine!
 */

HRESULT GkiCloseCallNoError(PGKICALL pGkiCall, void *pConference)
{
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  pConference = pConference;            // Disable compiler warning
  if (pGkiCall->uGkiCallState != GCS_START)
    GkiCloseCall(pGkiCall);
  return NOERROR;
} // GkiCloseCallNoError()

HRESULT GkiUnregister(void)
{
  register HRESULT      status = NOERROR;
  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ApplyToAllCalls(GkiCancelCall);
    uGkiState = STATE_WINDOW_CREATED;
    break;

  case STATE_UNREGISTERING_REREG:
    uGkiState = STATE_UNREGISTERING;
    break;

  case STATE_UNREGISTERING:
    break;

  case STATE_DISENGAGING_REREG:
    if (uGkiCalls != 0 || uPendingDisengages != 0)
    {
      uGkiState = STATE_DISENGAGING;
    }
    else
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_DISENGAGING:
    if (uGkiCalls == 0 && uPendingDisengages == 0)
    {
      uGkiState = STATE_REGISTERED;
      return GkiUnregister();
    }
    break;

  case STATE_ADMITTING_UNREG:
  case STATE_ADMITTING_REREG:
  case STATE_ADMITTING:
    uGkiState = STATE_ADMITTING_UNREG;
    break;

  case STATE_REGISTERING_UNREG:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING:
    uGkiState = STATE_REGISTERING_UNREG;
    break;

  case STATE_REGISTERED:
    if (uGkiCalls)
    {
      // Issue Disengage Request for every call
      uGkiState = STATE_DISENGAGING;
      ApplyToAllCalls(GkiCloseCallNoError);
      break;

    }
    else
    {
      // Issue Unregistration Request
      uGkiState = STATE_UNREGISTERING;
      ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
        uGkiState = STATE_WINDOW_CREATED;
      }
    }
    break;

  case STATE_WINDOW_CREATED:
  case STATE_CLASS_REGISTERED:
  case STATE_START:
    ISRWARNING(ghISRInst, StateName("GkiUnregister: Already in uninitialized state %s", uGkiState), 0);
    status = LastGkiError;
    break;

  default:
    ISRERROR(ghISRInst, "GkiUnregister: Invalid state %d", uGkiState);
    status = LastGkiError;
  } // switch

  return status;
} // GkiUnregister()



void DeInitGkiManager(void)
{
  register PLISTEN      pListen;

  if(!fGKConfigured)
        return;

  EnterCriticalSection(&GkiLock);

#if 0
  // TBD - When called from DllMain PROCESS_DETACH, this does not work because
  // apparently the socket to the Gatekeeper has already been closed.
  if (uGkiState != STATE_START)
  {
    GkiUnregister();
    uGkiState = STATE_START;
  }
#else
  uGkiState = STATE_START;
#endif

  while (pListenList)
  {
    pListen = pListenList;
    pListenList = pListenList->pNext;
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    MemFree(pListen);
  }

  pGKI_RegistrationRequest   = NULL;
  pGKI_UnregistrationRequest = NULL;
  pGKI_LocationRequest       = NULL;
  pGKI_AdmissionRequest      = NULL;
  pGKI_BandwidthRequest      = NULL;
  pGKI_DisengageRequest      = NULL;
  pGKI_Initialize            = NULL;

  if (pGKI_CleanupRequest)
	  pGKI_CleanupRequest();

  pGKI_CleanupRequest = NULL;

  LeaveCriticalSection(&GkiLock);
  DeleteCriticalSection(&GkiLock);

	if (NULL != hwndGki)
	{
		DestroyWindow(hwndGki);
	}
} // DeInitGkiManager()



HRESULT InitGkiManager(void)
{
    HRESULT hr = CC_GKI_LOAD;
    InitializeCriticalSection(&GkiLock);

    pGKI_RegistrationRequest   = (PGKI_RegistrationRequest)     GKI_RegistrationRequest;
    pGKI_UnregistrationRequest = (PGKI_UnregistrationRequest)   GKI_UnregistrationRequest;
    pGKI_LocationRequest       = (PGKI_LocationRequest)         GKI_LocationRequest;
    pGKI_AdmissionRequest      = (PGKI_AdmissionRequest)        GKI_AdmissionRequest;
    pGKI_BandwidthRequest      = (PGKI_BandwidthRequest)        GKI_BandwidthRequest;
    pGKI_DisengageRequest      = (PGKI_DisengageRequest)        GKI_DisengageRequest;
    pGKI_CleanupRequest        = (PGKI_CleanupRequest)          GKI_CleanupRequest;
    pGKI_Initialize            = (PGKI_Initialize)              GKI_Initialize;

    hr = pGKI_Initialize();
    if(hr != GKI_OK)
    {
        DeleteCriticalSection(&GkiLock);
        DeInitGkiManager();
    }
    else
    {
        fGKConfigured = TRUE;
    }
    return hr;
} // InitGkiManager()



//
// Entry Points
//

HRESULT GkiFreeCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState != GCS_START);
  pGkiCall->hGkiCall = 0;

  while (pGkiCall->pBwReqHead)
  {
    MemFree(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->pCalleeAliasNames)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeAliasNames);
    pGkiCall->pCalleeAliasNames = NULL;
  }

  if (pGkiCall->pCalleeExtraAliasNames != NULL)
  {
	Q931FreeAliasNames(pGkiCall->pCalleeExtraAliasNames);
    pGkiCall->pCalleeExtraAliasNames = NULL;
  }

  switch (pGkiCall->uGkiCallState)
  {
  case GCS_START:
  case GCS_WAITING:
    break;

  case GCS_ADMITTING:
    ASSERT(uGkiState == STATE_ADMITTING);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    } // switch
    break;

  case GCS_ADMITTING_CLOSE_PENDING:
    ASSERT(uGkiState == STATE_ADMITTING || uGkiState == STATE_ADMITTING_UNREG || uGkiState == STATE_ADMITTING_REREG);
    switch (uGkiState)
    {
    case STATE_ADMITTING:
      uGkiState = STATE_REGISTERED;
      break;
    case STATE_ADMITTING_UNREG:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_ADMITTING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch
    break;

  case GCS_ADMITTED:
  case GCS_CHANGING:
  case GCS_CHANGING_CLOSE_PENDING:
  case GCS_DISENGAGING:
    --uGkiCalls;
    ISRTRACE(ghISRInst, "GkiFreeCall: uGkiCalls = %d", uGkiCalls);
    break;

  default:
    ISRERROR(ghISRInst, "GkiFreeCall: Invalid call state %d", pGkiCall->uGkiCallState);
  } // switch

  pGkiCall->uGkiCallState = GCS_START;

  if (uGkiCalls == 0 && uPendingDisengages == 0)
  {
    switch (uGkiState)
    {
    case STATE_DISENGAGING:
      uGkiState = STATE_REGISTERED;
      status = GkiUnregister();
      break;
    case STATE_DISENGAGING_REREG:
      uGkiState = STATE_REGISTERED;
      status = GkiRegister();
      break;
    } // switch

  }

  return status;
} // GkiFreeCall()



HRESULT GkiCloseListen  (CC_HLISTEN hListen)
{
  register PLISTEN      pListen;
  register HRESULT      status;
  ISRTRACE(ghISRInst, StateName("GkiCloseListen <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  pListen = ListenDequeue(hListen);
  if (pListen == NULL)
  {
    status = CC_GKI_LISTEN_NOT_FOUND;
  }
  else
  {
    if (pListen->pAliasNames)
    {
      FreeAliasNames(pListen->pAliasNames);
    }
    MemFree(pListen);
    if (pListenList)
    {
      status = GkiRegister();
    }
    else
    {
      status = GkiUnregister();
    }
  }

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, StateName("GkiCloseListen -> State = %s", uGkiState), 0);
  return status;
} // GkiCloseListen()


HRESULT GkiSetVendorConfig(  PCC_VENDORINFO pVendorInfo,
    DWORD dwMultipointConfiguration)
{
    HRESULT status = CC_OK;

    EnterCriticalSection(&GkiLock);
    if(gpVendorInfo)
    {
        FreeVendorInfo(gpVendorInfo);
        gpVendorInfo = NULL;
    }
    if (!pVendorInfo)
    {
        // everything is cleaned up, so return
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    status = CopyVendorInfo(&gpVendorInfo, pVendorInfo);
    if (status != NOERROR)
    {
        ISRERROR(ghISRInst, "GkiSetRegistrationAliases: CopyVendorInfo returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    g_dwMultipointConfiguration = dwMultipointConfiguration;
    LeaveCriticalSection(&GkiLock);
    return status;
}

HRESULT GkiSetRegistrationAliases(PCC_ALIASNAMES pLocalAliasNames)
{
    HRESULT      status = CC_OK;

    EnterCriticalSection(&GkiLock);
    if(gpLocalAliasNames)
    {
        FreeAliasNames(gpLocalAliasNames);
        gpLocalAliasNames = NULL;
    }
    if (!pLocalAliasNames)
    {
        // everything is cleaned up, so return
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    status = CopyAliasNames(&gpLocalAliasNames, pLocalAliasNames);
    if (status != NOERROR)
    {
        ISRERROR(ghISRInst, "GkiSetRegistrationAliases: CopyAliasNames returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        return status;
    }
    LeaveCriticalSection(&GkiLock);
    return status;
}

HRESULT  GkiOpenListen  (CC_HLISTEN hListen, PCC_ALIASNAMES pAliasNames, DWORD dwAddr, WORD wPort)
{
  register PLISTEN      pListen;
  register HRESULT      status = NOERROR;
  ISRTRACE(ghISRInst, StateName("GkiOpenListen <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  // dwAddr, wPort are in host byte order
  // Check for invalid IP address
  if (dwAddr == INADDR_ANY || dwAddr == INADDR_NONE)
  {
    // this doesn't neccessarily get the correct IP address on a multi-homed
    // machine, but it at least tests to see if IP is configured on this
    // box.
    dwAddr = GetIpAddress();
    if (dwAddr == INADDR_ANY)
    {
         LeaveCriticalSection(&GkiLock);
         return CC_GKI_IP_ADDRESS;
    }
  }

  // Check for invalid alias list
  if (pAliasNames)
  {
    PCC_ALIASITEM       pAliasItem;
    unsigned int        uIndex;

    if (pAliasNames->wCount == 0)
    {
      ISRERROR(ghISRInst, "GkiOpenListen: Alias name wCount == 0", 0);
      return CC_BAD_PARAM;
    }
    pAliasItem = pAliasNames->pItems;
    for (uIndex = 0; uIndex < pAliasNames->wCount; ++uIndex, ++pAliasItem)
    {
      if (pAliasItem->wDataLength == 0 || pAliasItem->pData == NULL)
      {
        // Bad alias item
        ISRERROR(ghISRInst, "GkiOpenListen: Bad alias item (wDataLength = %d)",
                pAliasItem->wDataLength);
        return CC_BAD_PARAM;
      }
    }
  }

  pListen = (PLISTEN)MemAlloc(sizeof(*pListen));
  if (pListen)
  {
    if (pAliasNames)
    {
      status = CopyAliasNames(&pListen->pAliasNames, pAliasNames);
      if (status != NOERROR)
      {
        ISRERROR(ghISRInst, "GkiOpenListen: CopyAliasNames returned 0x%x", status);
        LeaveCriticalSection(&GkiLock);
        MemFree(pListen);
        return status;
      }
    }
    else
    {
      pListen->pAliasNames = NULL;
    }

    pListen->hListen = hListen;
    pListen->dwAddr  = htonl(dwAddr);
    pListen->wPort   = wPort;
    ListenEnqueue(pListen);
    if(GKIExists())
    {
        status = GkiRegister();
    }
  } // if
  else
  {
    ISRERROR(ghISRInst, "GkiOpenListen: Could not allocate listen structure", 0);
    status = CC_NO_MEMORY;
  } // else

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, StateName("GkiOpenListen -> State = %s", uGkiState), 0);
  return status;
} // GkiOpenListen()


HRESULT  GkiListenAddr (SOCKADDR_IN* psin)
{

  PLISTEN      pListen = pListenList;
  HRESULT      status = NOERROR;

  SOCKADDR_IN srem;
  SOCKADDR_IN sloc;

  ASSERT(psin);
  ASSERT(pListen != NULL);

  // try and get the best interface given the dwAddr passed in to us
  srem.sin_family = AF_INET;
  srem.sin_port = htons(7); // give echo a try since most GKs are unix-based
  srem.sin_addr.s_addr = psin->sin_addr.s_addr;

  status = NMGetBestInterface(&srem, &sloc);

  if (status == NOERROR)
  {
      EnterCriticalSection(&GkiLock);
      while (pListen)
      {
        pListen->dwAddr  = sloc.sin_addr.s_addr;
        pListen = pListen->pNext;
      }
      LeaveCriticalSection(&GkiLock);
  }
  return status;
} // GkiListenAddr()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseCall(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseCall <- Call State = %s", pGkiCall->uGkiCallState), 0);

  while (pGkiCall->pBwReqHead)
  {
    MemFree(BwReqDequeue(pGkiCall));
  }

  if (pGkiCall->uGkiCallState == GCS_START)
  {
    ISRWARNING(ghISRInst, CallStateName("GkiCloseCall: Call already in state %s", pGkiCall->uGkiCallState), 0);
    status = CC_GKI_CALL_STATE;
  }
  else
  {
    switch (uGkiState)
    {
    case STATE_START:
      break;

    case STATE_REG_BYPASS:
      status = GkiFreeCall(pGkiCall);
      break;

    default:
      switch (pGkiCall->uGkiCallState)
      {
      case GCS_WAITING:
        status = GkiFreeCall(pGkiCall);
        break;

      case GCS_ADMITTING:
        pGkiCall->uGkiCallState = GCS_ADMITTING_CLOSE_PENDING;
        break;

      case GCS_ADMITTING_CLOSE_PENDING:
      case GCS_CHANGING_CLOSE_PENDING:
      case GCS_DISENGAGING:
        ISRWARNING(ghISRInst, CallStateName("GkiCloseCall: Call already in closing state %s", pGkiCall->uGkiCallState), 0);
        status = CC_GKI_CALL_STATE;
        break;

      case GCS_ADMITTED:
        pGkiCall->uGkiCallState = GCS_DISENGAGING;
        ISRTRACE(ghISRInst, "GKI_DisengageRequest called...", 0);
        ++uPendingDisengages;
        status = pGKI_DisengageRequest(pGkiCall->hGkiCall);
        if (status == NOERROR)
        {
          ISRTRACE(ghISRInst, GkiErrorName("GKI_DisengageRequest returned %s", status), 0);
        }
        else
        {
          --uPendingDisengages;
          ISRERROR(ghISRInst, GkiErrorName("GKI_DisengageRequest returned %s", status), 0);
          GkiFreeCall(pGkiCall);
        }
        break;

      case GCS_CHANGING:
        pGkiCall->uGkiCallState = GCS_CHANGING_CLOSE_PENDING;
        break;

      default:
        ISRERROR(ghISRInst, CallStateName("GkiCloseCall: Call in invalid state %s", pGkiCall->uGkiCallState), 0);
        status = CC_GKI_CALL_STATE;
      } // switch
    } // switch
  } // else

  ISRTRACE(ghISRInst, StateName("GkiCloseCall -> State = %s", uGkiState), 0);
  return status;
} // GkiCloseCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT BandwidthRejected(PGKICALL pGkiCall, UINT Reason)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  CC_HCALL              hCall;

  ASSERT(pGkiCall != NULL);
  pBwReq = BwReqDequeue(pGkiCall);
  hCall  = pGkiCall->hCall;

  if (pBwReq)
  {
    if ((pGkiCall->uBandwidthUsed + pBwReq->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelConfirm  (pBwReq->hChannel);
      }
      else
      {
        AcceptChannelConfirm(pBwReq->hChannel);
      }
    }
    else
    {
      if (pBwReq->Type == TX)
      {
        OpenChannelReject   (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
      else
      {
        AcceptChannelReject (pBwReq->hChannel, MapBandwidthRejectReason(Reason));
      }
    }
    MemFree(pBwReq);
    if (ValidateCall(hCall) == NOERROR)
    {
      CheckPendingBandwidth(pGkiCall);
    }
  }

  return status;
} // BandwidthRejected()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingBandwidth(PGKICALL pGkiCall)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  CC_HCALL              hCall;

  ASSERT(pGkiCall != NULL);
  ASSERT(pGkiCall->uGkiCallState == GCS_ADMITTED);
  hCall = pGkiCall->hCall;

  while (pGkiCall->pBwReqHead != NULL &&
         (pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth) <= pGkiCall->uBandwidthAllocated)
  {
    pBwReq = BwReqDequeue(pGkiCall);
    ASSERT(pBwReq != NULL);
    pGkiCall->uBandwidthUsed += pBwReq->uChannelBandwidth;
    if (pBwReq->Type == TX)
    {
      OpenChannelConfirm(pBwReq->hChannel);
    }
    else
    {
      AcceptChannelConfirm(pBwReq->hChannel);
    }
    MemFree(pBwReq);
    if (ValidateCall(hCall) != NOERROR)
    {
      return status;
    }
  }

  if (pGkiCall->pBwReqHead != NULL)
  {
    pGkiCall->uGkiCallState = GCS_CHANGING;
    ISRTRACE(ghISRInst, "GKI_BandwidthRequest called...", 0);
    status = pGKI_BandwidthRequest(pGkiCall->hGkiCall,
                                   pGkiCall->usCallTypeChoice,
                                   pGkiCall->uBandwidthUsed + pGkiCall->pBwReqHead->uChannelBandwidth);
    if (status == NOERROR)
    {
      ISRTRACE(ghISRInst, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0);
    }
    else
    {
      ISRERROR(ghISRInst, GkiErrorName("GKI_BandwidthRequest returned %s", status), 0);
      BandwidthRejected(pGkiCall, BndRjctRsn_undfndRsn_chosen);
    }
  }

  return status;
} // CheckPendingBandwidth()



static void FreeAliasList(SeqAliasAddr *pAliasAddrs)
{
  register SeqAliasAddr *pAlias = pAliasAddrs;
  while (pAlias)
  {
    if (pAlias->value.choice == h323_ID_chosen && pAlias->value.u.h323_ID.value)
      MemFree(pAlias->value.u.h323_ID.value);
    pAlias = pAlias->next;
  }
  MemFree(pAlias);
} // FreeAliasList()



/*
 *  NOTES
 *    Must have Call locked before calling!
 *
 *    The following fields in the GKICALL structure must be properly filled
 *    in before calling this function:
 *      pCall                 Pointer back to containing CALL structure.
 *      CallType              Type of call.
 *      uBandwidthRequested   Initial bandwidth for call.
 *      pConferenceId         Pointer to conference ID buffer.
 *      bActiveMC             TRUE if calling party has an active MC.
 *      bAnswerCall           ???
 *      CallIdentifier  the GUID identifying this call. This must be the same
 *                      value as CallIdentifier of the Q.931 messages.
 */

HRESULT GkiOpenCall (PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;
  CC_HCALL              hCall;
  TransportAddress      DestCallSignalAddress;
  TransportAddress *    pDestCallSignalAddress;
  SeqAliasAddr *        pAliasAddrs;
  SeqAliasAddr *        pExtraAliasAddrs;
  SeqAliasAddr *        pAlias;
  PCC_ALIASITEM         pAliasItem;
  unsigned              uCount;
  unsigned              uIndex;
  ConferenceIdentifier  ConferenceId;

  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);
  ISRTRACE(ghISRInst, StateName("GkiOpenCall <- State = %s", uGkiState), 0);
  EnterCriticalSection(&GkiLock);

  switch (uGkiState)
  {
  case STATE_REG_BYPASS:
    ASSERT(pGkiCall->uGkiCallState == GCS_START || pGkiCall->uGkiCallState == GCS_WAITING || pGkiCall->uGkiCallState == GCS_ADMITTING);
    hCall = pGkiCall->hCall;
    GkiAllocCall(pGkiCall, GKI_BYPASS_HANDLE);
    pGkiCall->uBandwidthAllocated = MAX_BANDWIDTH;
    if (pGkiCall->bAnswerCall)
    {
      status = AcceptCallConfirm(pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    else if (pGkiCall->dwIpAddress == 0)
    {
      status = PlaceCallReject  (pGkiCall->pCall, pConference, CC_INVALID_WITHOUT_GATEKEEPER);
    }
    else
    {
      status = PlaceCallConfirm (pGkiCall->pCall, pConference);
      if (status == NOERROR && ValidateCall(hCall) == NOERROR)
      {
        CheckPendingBandwidth(pGkiCall);
      }
    }
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_ADMITTING:
    pGkiCall->uGkiCallState = GCS_WAITING;
    break;

  case STATE_REGISTERED:
    switch (pGkiCall->CallType)
    {
    case POINT_TO_POINT:
      pGkiCall->usCallTypeChoice = pointToPoint_chosen;
      break;
    case ONE_TO_MANY:
      pGkiCall->usCallTypeChoice = oneToN_chosen;
      break;
    case MANY_TO_ONE:
      pGkiCall->usCallTypeChoice = nToOne_chosen;
      break;
    case MANY_TO_MANY:
      pGkiCall->usCallTypeChoice = nToN_chosen;
      break;
    default:
      LeaveCriticalSection(&GkiLock);
      ISRERROR(ghISRInst, "GkiOpenCall -> Invalid CallType %d", pGkiCall->CallType);
      return CC_BAD_PARAM;
    } // switch

    pDestCallSignalAddress = NULL;
    pAliasAddrs            = NULL;
    pExtraAliasAddrs       = NULL;

    if (pGkiCall->dwIpAddress != 0 && pGkiCall->wPort != 0)
    {
      DestCallSignalAddress.choice = ipAddress_chosen;
      DestCallSignalAddress.u.ipAddress.ip.length = 4;
      *((DWORD *)DestCallSignalAddress.u.ipAddress.ip.value) = pGkiCall->dwIpAddress;
      DestCallSignalAddress.u.ipAddress.port = pGkiCall->wPort;
      pDestCallSignalAddress = &DestCallSignalAddress;
    }

    if (pGkiCall->pCalleeAliasNames)
    {
      uCount = pGkiCall->pCalleeAliasNames->wCount;
      pAliasAddrs = MemAlloc(uCount * sizeof(*pAliasAddrs));
      if (pAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        ISRERROR(ghISRInst, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount);
        return CC_NO_MEMORY;
      }
      memset(pAliasAddrs, 0, uCount * sizeof(*pAliasAddrs));
      pAlias = pAliasAddrs;
      pAliasItem = pGkiCall->pCalleeAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          ISRERROR(ghISRInst, "GkiOpenCall: CopyAliasItem returned %d", status);
          FreeAliasList(pAliasAddrs);
	  MemFree(pAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->pCalleeExtraAliasNames)
    {
      uCount = pGkiCall->pCalleeExtraAliasNames->wCount;
      pExtraAliasAddrs = MemAlloc(uCount * sizeof(*pExtraAliasAddrs));
      if (pExtraAliasAddrs == NULL)
      {
        LeaveCriticalSection(&GkiLock);
        ISRERROR(ghISRInst, "GkiOpenCall: Could not allocate %d Alias Addresses", uCount);
        if (pAliasAddrs)
	{
          FreeAliasList(pAliasAddrs);
	  MemFree(pAliasAddrs);
	}
        return CC_NO_MEMORY;
      }
      memset(pExtraAliasAddrs, 0, uCount * sizeof(*pExtraAliasAddrs));
      pAlias = pExtraAliasAddrs;
      pAliasItem = pGkiCall->pCalleeExtraAliasNames->pItems;
      for (uIndex = 0; uIndex < uCount; ++uIndex)
      {
        status = CopyAliasItem(pAlias, pAliasItem);
        if (status != NOERROR)
        {
          LeaveCriticalSection(&GkiLock);
          ISRERROR(ghISRInst, "GkiOpenCall: CopyAliasItem returned %d", status);
          if (pAliasAddrs)
	  {
            FreeAliasList(pAliasAddrs);
	    MemFree(pAliasAddrs);
	  }
          FreeAliasList(pExtraAliasAddrs);
	  MemFree(pExtraAliasAddrs);
          return status;
        }
        pAlias->next = pAlias + 1;
        ++pAlias;
        ++pAliasItem;
      } // for
      --pAlias;
      pAlias->next = NULL;
    }

    if (pGkiCall->uBandwidthRequested < MIN_BANDWIDTH)
    {
      pGkiCall->uBandwidthRequested = MIN_BANDWIDTH;
    }
    ASSERT(pGkiCall->uBandwidthAllocated == 0);
    ASSERT(pGkiCall->uBandwidthUsed == 0);

    memcpy(ConferenceId.value, pGkiCall->pConferenceId, 16);
    if (((DWORD *)pGkiCall->pConferenceId)[0] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[1] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[2] != 0 ||
        ((DWORD *)pGkiCall->pConferenceId)[3] != 0)
    {
      ConferenceId.length = 16;
    }
    else
    {
      ConferenceId.length = 0;
    }

    pGkiCall->hGkiCall = GKI_ADMITTING_HANDLE;
    if (pDestCallSignalAddress != NULL || pAliasAddrs != NULL)
    {
      uGkiState = STATE_ADMITTING;
      pGkiCall->uGkiCallState = GCS_ADMITTING;
      ISRTRACE(ghISRInst, "GKI_AdmissionRequest called...", 0);
      status = pGKI_AdmissionRequest(pGkiCall->usCallTypeChoice,    // usCallTypeChoice.
                                     pAliasAddrs,                   // pDestinationInfo,
                                     pDestCallSignalAddress,        // pDestCallSignalAddress
                                     pExtraAliasAddrs,              // pDestExtraCallInfo,
                                     &pGkiCall->CallIdentifier,     // H.225 call identifer
                                     pGkiCall->uBandwidthRequested, // bandWidth,
                                     &ConferenceId,                 // pConferenceID,
                                     pGkiCall->bActiveMC,           // activeMC,
                                     pGkiCall->bAnswerCall,         // answerCall,
                                     ipAddress_chosen);             // usCallTransport
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_AdmissionRequest returned %s", status), 0);
      }
    }
    else
    {
      pGkiCall->hGkiCall = 0;
      status = CC_BAD_PARAM;
    }

    if (status != NOERROR)
    {
      uGkiState = STATE_REGISTERED;
      GkiCancelCall(pGkiCall, pConference);
    }

    if (pAliasAddrs)
    {
      FreeAliasList(pAliasAddrs);
      MemFree(pAliasAddrs);
    }

    if (pExtraAliasAddrs)
    {
      FreeAliasList(pExtraAliasAddrs);
      MemFree(pExtraAliasAddrs);
    }
    break;

  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
    pGkiCall->uGkiCallState = GCS_WAITING;
        // not registered!!! attempt to register or reregister
      status = GkiRegister();
    break;

  default:
    ISRERROR(ghISRInst, StateName("GkiOpenCall: Invalid state %s", uGkiState), 0);
    status = LastGkiError;
  } // switch

  LeaveCriticalSection(&GkiLock);
  ISRTRACE(ghISRInst, CallStateName("GkiOpenCall -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return status;
} // GkiOpenCall()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiOpenChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel, CHANNELTYPE Type)
{
  HRESULT               status = NOERROR;
  PBWREQ                pBwReq;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiOpenChannel <- Call State = %s", pGkiCall->uGkiCallState), 0);

  pBwReq = (PBWREQ)MemAlloc(sizeof(*pBwReq));
  if (pBwReq == NULL)
  {
    ISRERROR(ghISRInst, "GkiOpenChannel: Memory allocation failed", 0);
    return CC_NO_MEMORY;
  }

  pBwReq->uChannelBandwidth = uChannelBandwidth / 100;
  pBwReq->hChannel          = hChannel;
  pBwReq->Type              = Type;
  BwReqEnqueue(pGkiCall, pBwReq);
  switch (pGkiCall->uGkiCallState)
  {
  case GCS_WAITING:
  case GCS_ADMITTING:
  case GCS_CHANGING:
    // Must wait for current operation to complete
    break;

  case GCS_ADMITTED:
    status = CheckPendingBandwidth(pGkiCall);
    break;

  default:
    ISRERROR(ghISRInst, "GkiOpenChannel: Invalid call state %d", pGkiCall->uGkiCallState);
    status = CC_GKI_CALL_STATE;
  } // switch

  ISRTRACE(ghISRInst, CallStateName("GkiOpenChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return status;
} // GkiOpenChannel()



/*
 *  NOTES
 *    Must have Call locked before calling!
 */

HRESULT GkiCloseChannel(PGKICALL pGkiCall, unsigned uChannelBandwidth, CC_HCHANNEL hChannel)
{
  PBWREQ                pBwReq;
  PBWREQ                pBwReq1;
  ASSERT(GKIExists());
  ASSERT(pGkiCall != NULL);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel <- Call State = %s", pGkiCall->uGkiCallState), 0);

  // If Bandwidth request is still in queue, bandwidth has not been allocated
  pBwReq = pGkiCall->pBwReqHead;
  if (pBwReq)
  {
    if (pBwReq->hChannel == hChannel)
    {
      MemFree(BwReqDequeue(pGkiCall));
      ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
      return NOERROR;
    }
    while ((pBwReq1 = pBwReq->pNext) != NULL)
    {
      if (pBwReq1->hChannel == hChannel)
      {
        if (pGkiCall->pBwReqTail == pBwReq1)
        {
          pGkiCall->pBwReqTail = pBwReq;
        }
        pBwReq->pNext = pBwReq1->pNext;
        MemFree(pBwReq1);
        ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
        return NOERROR;
      }
    }
  }

  pGkiCall->uBandwidthUsed -= (uChannelBandwidth / 100);
  ISRTRACE(ghISRInst, CallStateName("GkiCloseChannel -> Call State = %s", pGkiCall->uGkiCallState), 0);
  return NOERROR;
} // GkiCloseChannel()



unsigned GkiGetBandwidth(PGKICALL pGkiCall)
{
  ASSERT(pGkiCall != NULL);
  return pGkiCall->uBandwidthAllocated * 100;
} // GkiGetBandwidth()



//
// GkiWndProc subroutines
//

/*
 *  NOTES
 *    Must have Call locked before calling!
 */

static HRESULT CheckPendingOpen(PGKICALL pGkiCall, void *pConference)
{
  HRESULT               status = NOERROR;

  ASSERT(pGkiCall != NULL);
  ASSERT(pConference != NULL);

  switch (uGkiState)
  {
  case STATE_REGISTERED:
  case STATE_REG_BYPASS:
    // TBD - Can only open 1!!!
    ASSERT(pGkiCall->uGkiCallState != GCS_ADMITTING);
    if (pGkiCall->uGkiCallState == GCS_WAITING)
    {
      status = GkiOpenCall(pGkiCall, pConference);
    }
    break;

  default:
    status = LastGkiError;
  } // switch

  return status;
} // CheckPendingOpen()



static void GkiNoResponse(HWND hWnd)
{
  HRESULT               status;

  switch (uGkiState)
  {
  case STATE_START:
  case STATE_CLASS_REGISTERED:
  case STATE_WINDOW_CREATED:
  case STATE_REG_BYPASS:
    break;

  case STATE_REGISTERING:
  case STATE_REGISTERING_REREG:
  case STATE_REGISTERING_UNREG:
  #if(0)
    why did Intel *DO* this?????
    ISRTRACE(ghISRInst, "GkiWndProc: dummy GKI_REG_REJECT", 0);
    PostMessage(hWnd, GKIMAN_BASE + GKI_REG_REJECT, 0, 0);
  #else
    // there was no response to registration request, assume the GK is not there or dead.
      uGkiState = STATE_REG_BYPASS;
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_REG_TIMEOUT, 0);
      }
      ApplyToAllCalls(CheckPendingOpen);
  #endif
    break;

  case STATE_ADMITTING:
  case STATE_ADMITTING_REREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;

    // Fall-through to next case

  case STATE_REGISTERED:
    if (uGkiCalls == 0)
    {
      GkiRegister();
    }
    else
    {
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(GatekeeperNotFound);
      ISRTRACE(ghISRInst, "GKI_UnregistrationRequest called...", 0);
      status = pGKI_UnregistrationRequest();
      if (status == NOERROR)
      {
        ISRTRACE(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
      else
      {
        ISRERROR(ghISRInst, GkiErrorName("GKI_UnregistrationRequest returned %s", status), 0);
      }
    }
    break;

  case STATE_ADMITTING_UNREG:
    ApplyToAllCalls(GkiCancelAdmitting);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiUnregister();
    break;

  case STATE_DISENGAGING_REREG:
    ApplyToAllCalls(GatekeeperNotFound);
    ASSERT(uGkiCalls == 0);
    uGkiState = STATE_REGISTERED;
    GkiRegister();
    break;

  case STATE_UNREGISTERING:
  case STATE_UNREGISTERING_REREG:
    ISRTRACE(ghISRInst, "GkiWndProc: dummy GKI_UNREG_CONFIRM", 0);
    PostMessage(hWnd, GKIMAN_BASE + GKI_UNREG_CONFIRM, 0, 0);
    break;

  default:
    ISRERROR(ghISRInst, "GkiWndProc: Bad uGkiState %d", uGkiState);
  } // switch
} // GkiNoResponse()



LRESULT APIENTRY GkiWndProc(
  HWND hWnd,                /* window handle                   */
  UINT message,             /* type of message                 */
  WPARAM wParam,              /* additional information          */
  LPARAM lParam)              /* additional information          */
{
  CallReturnInfo *      pCallReturnInfo;
  PGKICALL              pGkiCall;
  void *                pConference;
  CC_HCALL              hCall;
  CC_HCONFERENCE        hConference;
  HRESULT               status;
  if (message < GKIMAN_BASE)
  {
    return DefWindowProc(hWnd, message, wParam, lParam);
  }

  EnterCallControlTop();

  ISRTRACE(ghISRInst, StateName("GkiWndProc <- State = %s", uGkiState), 0);

  switch (message)
  {
  case GKIMAN_BASE + GKI_REG_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_CONFIRM", 0);
    ASSERT(gpRasNotifyProc);  // we should never get messages if
                              // this is not configured
    if(gpRasNotifyProc)
    {
       (gpRasNotifyProc)(RAS_REG_CONFIRM, 0);
    }
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      uGkiState = STATE_REGISTERED;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REGISTERED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_REGISTERED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_CONFIRM in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_DISCOVERY:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_DISCOVERY", 0);
    ASSERT(uGkiState == STATE_REGISTERING || uGkiState == STATE_REGISTERING_REREG || uGkiState == STATE_REGISTERING_UNREG);
    break;

  case GKIMAN_BASE + GKI_UNREG_REQUEST:
      //  the GK kicked us out!
      // pass the unregistration request upward
      ASSERT(gpRasNotifyProc);  // we should never get messages if
                                // this is not configured
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_UNREG_REQ, MapUnregistrationRequestReason((UINT)wParam));
      }
  break;

  case GKIMAN_BASE + GKI_REG_REJECT:
    ISRERROR(ghISRInst, "GkiWndProc: GKI_REG_REJECT Reason = %d", (DWORD)wParam);
    switch (uGkiState)
    {
    case STATE_REGISTERING:
      ApplyToAllCalls(GkiCancelCall);
#if(0)
// leave the listen list intact so that subsequent registration attempts
// will work.
//
      EnterCriticalSection(&GkiLock);
      while (pListenList)
      {
        register PLISTEN pListen = pListenList;
        pListenList = pListen->pNext;
        LeaveCriticalSection(&GkiLock);
        ListenReject(pListen->hListen, MapRegistrationRejectReason((UINT)wParam));
        if (pListen->pAliasNames)
        {
            FreeAliasNames(pListen->pAliasNames);
        }
        MemFree(pListen);
        EnterCriticalSection(&GkiLock);
      }
      LeaveCriticalSection(&GkiLock);
 #endif
      uGkiState = STATE_WINDOW_CREATED;

      // pass the registration reject upward
      ASSERT(gpRasNotifyProc);  // we should never get messages if
                                // this is not configured
      if(gpRasNotifyProc)
      {
        (gpRasNotifyProc)(RAS_REJECTED, MapRegistrationRejectReason((UINT)wParam));
      }

      break;
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiRegister();
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_REJECT in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_REG_BYPASS:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_REG_BYPASS", 0);
    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
      uGkiState = STATE_REG_BYPASS;
      ApplyToAllCalls(CheckPendingOpen);
      break;
    case STATE_REGISTERING_UNREG:
      uGkiState = STATE_WINDOW_CREATED;
      GkiUnregister();
      break;
    default:
      ISRERROR(ghISRInst, StateName("GkiWndProc: GKI_REG_BYPASS in state %s", uGkiState), 0);
    } // switch
    break;

  case GKIMAN_BASE + GKI_UNREG_CONFIRM:
    ISRTRACE(ghISRInst, "GkiWndProc: GKI_UNREG_CONFIRM", 0);
    ASSERT(gpRasNotifyProc);  // we should never get messages if
                              // this is not configured
    if(gpRasNotifyProc)
    {
        (gpRasNotifyProc)(RAS_UNREG_CONFIRM, 0);
    }

    switch (uGkiState)
    {
    case STATE_REGISTERING:
    case STATE_REGISTERING_REREG:
    case STATE_REGISTERED:
    case STATE_ADMITTING:
    case STATE_ADMITTING_REREG:
    case STATE_DISENGAGING_REREG:
    case STATE_UNREGISTERING_REREG:
      uGkiState = STATE_WINDOW_