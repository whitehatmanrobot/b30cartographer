===
//#pragma title( "EnumVols.hpp - Volume Enumeration" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  enumvols.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes used to generate a list of pathnames, given a list of paths and/or 
               machine names.
Updates     -
===============================================================================
*/
#ifndef ENUMVOLS_HEADER
#define ENUMVOLS_HEADER 

#define MAXSIZE  30000  

#include <lmcons.h>
#include "EaLen.hpp"

#ifndef TNODEINCLUDED
   #include "Tnode.hpp"
   #define TNODEINCLUDED 
#endif

#define  VERIFY_EXISTS           (0x00000001)
#define  VERIFY_BACKUPRESTORE    (0x00000002)
#define  VERIFY_PERSISTENT_ACLS  (0x00000004)

/*******************************************************************************************
      class TPathNode is a TNode, containing a UNICODE pathname.  A TNode is constructed to
      hold each path in the TPathList list
********************************************************************************************/
   
class TPathNode:public TNode
{
protected:
   bool                      haswc;               // these three fields are set by Verify
   bool                      validalone;
   bool                      iscontainer;
   bool                      isFirstFromServer;   // This field is maintained by TPathList
   WCHAR                     path[MAX_PATH + 1];  // the pathname associated with this node
   WCHAR                     server[UNCLEN+1];    // server name for path
         
public:
                        TPathNode(const LPWSTR name); 
   WCHAR *              GetPathName() const { return ( LPWSTR ) path; } 
   WCHAR *              GetServerName() const { return (LPWSTR) server; }
   void                 SetServerName(UCHAR const * name);
   void                 Display() const;   
   bool                 ContainsWC() { return haswc; } 
   bool                 IsValidAlone() { return validalone; }
   void                 ContainsWC(bool val) { haswc = val; }
   void                 IsValidAlone(bool val) {validalone = val; }  
   void                 IsContainer(bool val) { iscontainer = val; }
   bool                 IsContainer() { return iscontainer; }               
   bool                 IsFirstPathFromMachine() { return isFirstFromServer; }
   void                 IsFirstPathFromMachine(bool val) { isFirstFromServer = val; }
   DWORD                VerifyExists();
   DWORD                VerifyBackupRestore();
   DWORD                VerifyPersistentAcls();
protected:
   void                 LookForWCChars(); // looks for wildcard, and sets value of haswc
   void                 FindServerName(); // looks for the name of the server
};

/*******************************************************************************************
      class TPathList 

         BuildPathList: takes an argument list, and builds a list of paths as follows:
                        for each path in the arglist, the path is added,
                        and for each machine-name, a path is added for the root
                        of each shared, security-enabled volume.
      
********************************************************************************************/


class TPathList : public TNodeList
{
protected:
   DWORD                     numServers;             // Stats: count the number of complete servers added  
   DWORD                     numPaths;               // Stats: the number of paths in the list
   TNodeListEnum             tenum;                  // used to enumerate the paths in the list (OpenEnum, Next, CloseEnum)
 
public:
                        TPathList();
                        ~TPathList();
   bool                 AddPath(const LPWSTR path,DWORD verifyFlags);         // adds a single path (from args)
                                                             // to the list                  

   void                 Clear(); // Removes all the paths in the list
   void                 Display() const;                    // printfs the pathname for each node
   DWORD                GetNumPaths() const { return numPaths; }
   DWORD                GetNumServers() const { return numServers; }
   void                 OpenEnum();                // To enumerate nodes in the list
   void                 CloseEnum();               // OpenEnum, GetItem for each node, CloseEnum
   LPWSTR               Next();                    // Returns the next pathname in the enumeration
   

protected:
   void                 AddPathToList(TPathNode * newNode); // Helper function

};

// TVolumeEnum enumerates the administrative shares on a server
class TVolumeEnum          
{
private:
   DWORD                     numread;           // number of volnames read this time
   DWORD                     total;             // total # vols
   DWORD                     resume_handle;
   DWORD                     curr;              // used to iterate through volumes
   LPBYTE                    pbuf;
   WCHAR                   * drivelist;
   LPBYTE                    shareptr;
   WCHAR                     currEntry[MAX_PATH];
   BOOL                      isOpen;
   BOOL                      verbose;
   UINT                      errmode;
   WCHAR                     server[32];
   DWORD                     verifyFlags;
   BOOL                      bLocalOnly;
   int                       nLeft;
public:
   TVolumeEnum() { nLeft = 0; bLocalOnly = FALSE; isOpen = FALSE; pbuf = NULL; numread = 0; }
   ~TVolumeEnum() { if ( isOpen ) Close(); }
   DWORD    Open(WCHAR const * server,DWORD verifyFlags,BOOL verbose);
   WCHAR *  Next();
   void     Close();

   void     SetLocalMode(BOOL bLocal) { bLocalOnly = bLocal; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\exchange.cpp ===
#include "stdafx.h"

#include "exchange.hpp"

#include "common.hpp"
#include "err.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"

#include "sidcache.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "exldap.h"

#include "Mcs.h"
#include "folders.h"
#include "treg.hpp"

using namespace nsFolders;

extern TErrorDct     err;

#define NOT_PT_ERROR(x) ( PROP_TYPE(x.ulPropTag) != PT_ERROR )

#define LDAP_PortNumber_DN_Part          L"/cn=Protocols/cn=LDAP"
#define ATT_OBJ_CLASS          L"Obj-Class"
#define ATT_DIST_NAME          L"Obj-Dist-Name"
#define ATT_LDAP_PORT          L"Port-Number"
#define LDAP_USE_SITE_VALUES     L"Use-Site-Values"


TGlobalDirectory::TGlobalDirectory()
{
   m_stat                     = NULL;
}

TGlobalDirectory::~TGlobalDirectory()
{
}

#define NDX_SID         3
#define NDX_SD          4

void 
   TGlobalDirectory::GetSiteNameForServer(
      WCHAR          const * server,                  // in - name of exchange server to use
      CLdapEnum            * e,                       // in - LDAP connection to use for query
      WCHAR                * siteName                 // out- distinguished name of exchange site for server
      )
{
   WCHAR                   * atts[6] = { L"distinguishedName", L"rdn",NULL };
   WCHAR                     query[200];
   DWORD                     rc;
   WCHAR                  ** values = NULL;
   siteName[0] = 0;
   
   swprintf(query,L"(&(objectClass=computer)(rdn=%ls))",server);
   rc = e->Open(query,L"",2,100,3,atts);
   // there should be only one server with this name
   if (! rc )
      rc = e->Next(&values);
   if (! rc )
   {
      if ( !UStrICmp(values[1],server) )
      {
         WCHAR       serverPrefix[LEN_Path];
         _snwprintf(serverPrefix,DIM(serverPrefix),L"cn=%ls,cn=Servers,cn=Configuration,",values[1]);
         serverPrefix[DIM(serverPrefix) - 1] = L'\0';
         if ( ! UStrICmp(values[0],serverPrefix,UStrLen(serverPrefix)) )
         {
            UStrCpy(siteName,values[0] + UStrLen(serverPrefix),LEN_Path);
         }
         else
         {
            err.MsgWrite(ErrE,DCT_MSG_GENERIC_S,values[0]);
         }
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_LDAP_CALL_FAILED_SD,server,ERROR_NOT_FOUND);
      }
      e->FreeData(values);
   }
   else
   {
      err.SysMsgWrite(ErrE,e->m_connection.LdapMapErrorToWin32(rc),DCT_MSG_LDAP_CALL_FAILED_SD,server,rc);
   }

}


BOOL 
   TGlobalDirectory::DoLdapTranslation(
      WCHAR                  * server,
      WCHAR                  * domain,
      WCHAR                  * user,
      WCHAR                  * password,
      SecurityTranslatorArgs * args,
      WCHAR                  * basept,
      WCHAR                  * query
   )
{
   CLdapEnum                 e;
   WCHAR                   * atts[6] = { L"distinguishedName", L"rdn", L"cn", L"Assoc-NT-Account",L"NT-Security-Descriptor",NULL };
   WCHAR                  ** values = NULL;
   DWORD ldapPort, sslPort;
   GetLDAPPort(&ldapPort, &sslPort);
   ULONG                     pageSize = 100;
   WCHAR                     basepoint[LEN_Path] = L"";

   e.m_connection.SetCredentials(domain,user,password);

   BOOL sslEnabled = FALSE;
   SetLastError(0);
   // try SSL port first
   DWORD rc  = e.InitSSLConnection(server,&sslEnabled,sslPort);

   if (rc || sslEnabled == FALSE)
   {
        WCHAR* serverName = (server == NULL) ? L"" : server;
        if (rc == 0)
            err.MsgWrite(ErrW, DCT_MSG_CANNOT_ESTABLISH_SSL_CONNECTION_WITH_EXCHANGE_SERVER_WITHOUT_RC_SD, serverName, sslPort);
        else
            err.SysMsgWrite(ErrW, rc, DCT_MSG_CANNOT_ESTABLISH_SSL_CONNECTION_WITH_EXCHANGE_SERVER_WITH_RC_SDD, serverName, sslPort,rc);
        err.MsgWrite(ErrI, DCT_MSG_USE_REGULAR_PORT_DS, ldapPort, serverName);
        rc = e.InitConnection(server, ldapPort);
   }
        
   BOOL                      anychange = FALSE;
   BOOL                      verbose = args->LogVerbose();
   BOOL						 bUseMapFile = args->UsingMapFile();


   if (! rc )
   {
      if ( ! basept )
      {
         GetSiteNameForServer(server,&e,basepoint);
      }
      else
      {
         // use the user-specified basepoint
         safecopy(basepoint,basept);
      }
      if ( query )
      {
         rc = e.Open(query,basepoint,2,pageSize,5,atts);  
      }
      else 
      {
         rc = e.Open(L"(objectClass=*)",basepoint,2,pageSize,5,atts);
      }
      if ( ! rc )
      {
         do 
         {
            rc = e.Next(&values);
            anychange = FALSE;
            if (! rc )
            {
               if ( args->Cache()->IsCancelled() )
               {
                  err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
                  return FALSE;
               }
               if ( m_stat )
               {
                  m_stat->DisplayPath(values[0]);
                  m_stat->IncrementExamined(mailbox);
               }

               // update the Assoc-NT-Account, if any
               if ( values[NDX_SID] && *values[NDX_SID] )
               {
                  // convert the SID to a binary value and look it up in the cache
                  BYTE              pSid[500];

                  if ( e.m_connection.StringToBytes(values[NDX_SID],pSid) )
                  {
                     
                     // check if the sid is one we need to change            
                     //TRACE (_T("DisplayName = %s "),pUserProperties[0].Value.lpszW);
                     PSID newSid = 0;
                     TAcctNode * node;

                     if ( IsValidSid(pSid) )
                     {
                        if (!bUseMapFile)
                           node = args->Cache()->Lookup(pSid); 
                        else
                           node = args->Cache()->LookupWODomain(pSid); 
                        if ( m_stat )
                        {
                           m_stat->IncrementOwnerExamined();
                           if ( verbose )
                              err.MsgWrite(0,DCT_MSG_EXAMINED_S,values[0]);
                        }
                        if ( node == (TAcctNode*)-1  && m_stat )
                           m_stat->IncrementOwnerNoTarget();

                        if ( node && (node != (TAcctNode *)-1) && node->IsValidOnTgt() )
                        {
	                    if (!bUseMapFile)
                              newSid = args->Cache()->GetTgtSid(node);
	                    else
                              newSid = args->Cache()->GetTgtSidWODomain(node);
                        }
                        else
                        {
                           newSid = NULL;
                           m_stat->IncrementOwnerNoTarget();
                        }
                     }
                     else
                     {
                        newSid = NULL;
                     }
                     if ( newSid )
                     {
                        //TRACE (_T("needs to be translated\n"));
                        MCSASSERT ( IsValidSid(newSid) );
                        WCHAR                newSidStr[1000];

                        if ( e.m_connection.BytesToString((BYTE*)newSid,newSidStr,GetLengthSid(newSid)) )
                        {
                           if ( !args->NoChange() )
                           {
                              rc = e.m_connection.UpdateSimpleStringValue(values[0],atts[NDX_SID],newSidStr);

                              if ( rc ) 
                              {
                                 err.SysMsgWrite(ErrE,rc,DCT_MSG_UPDATE_ACCOUNT_FAILED_D, rc);
                              }
                              else
                                anychange = TRUE;
                           }
                           if ( anychange && m_stat )
                           {
                              m_stat->IncrementOwnerChange(node,mailbox,NULL);
                           }

                        }
                     }
                  }
                  
               }

               // this variable determines whether we should continue mailbox translation
               DWORD dwContinueRC = ERROR_SUCCESS;
               
               // Update the NT-Security-Descriptor, if any
               // however, we do not try to roll back if anything wrong happens in this part
               if ( values[NDX_SD] && *values[NDX_SD] )
               {
                  // convert the SID to a binary value and look it up in the cache
                  BYTE            * pSD = new BYTE[UStrLen(values[NDX_SD])];
				  if (!pSD)
				    dwContinueRC = ERROR_OUTOFMEMORY;

                  if ( dwContinueRC == ERROR_SUCCESS && e.m_connection.StringToBytes(values[NDX_SD],pSD) )
                  {
                     TMapiSD   tMailbox((SECURITY_DESCRIPTOR *)pSD);
                     if ( tMailbox.HasSecurity() )
                     {
                        TSD               * pSD = tMailbox.GetSecurity();

                        bool  changes = tMailbox.ResolveSDInternal(args->Cache(),m_stat,verbose,args->TranslationMode(),mailbox, bUseMapFile);
         
                        if ( changes )
                        {
                           SECURITY_DESCRIPTOR * pRelSD = (SECURITY_DESCRIPTOR *)pSD->MakeRelSD();
                           if (pRelSD == NULL)
                            dwContinueRC = ERROR_OUTOFMEMORY;
                           
                           if ( dwContinueRC == ERROR_SUCCESS && ! args->NoChange() )
                           {     
                              DWORD                 dwSDLength = GetSecurityDescriptorLength(pRelSD);
                           
                              WCHAR * pSDString = new WCHAR[1 + dwSDLength * 2];
							  if (!pSDString)
							    dwContinueRC = ERROR_OUTOFMEMORY;

                              if  ( dwContinueRC == ERROR_SUCCESS && e.m_connection.BytesToString((BYTE*)pRelSD,pSDString,dwSDLength) )
                              {
                                 rc = e.m_connection.UpdateSimpleStringValue(values[0],atts[NDX_SD],pSDString);
                                 if ( rc )
                                 {
                                    err.SysMsgWrite(ErrE,rc,DCT_MSG_RECIP_SD_WRITE_FAILED_SD,values[0],rc);
                                    if ( rc == ERROR_INVALID_PARAMETER )
                                    {
                                       // this error occurs when the security descriptor is too large
                                       // don't abort in this case
                                       rc = 0;
                                    }
                                 }
                                 else
                                    anychange = TRUE;
                  
                              }
                              delete [] pSDString;
                           }

                           if (pRelSD)
                            free(pRelSD);
                        }
                     }
                  }
                  delete [] pSD;
               }
               
               if ( anychange && m_stat )
               {
                  m_stat->IncrementChanged(mailbox);
                  err.MsgWrite(0, DCT_MSG_MAILBOX_HAS_BEEN_UPDATED_S, values[0]);
               }

               if (dwContinueRC != ERROR_SUCCESS)
               {
                if (anychange)
                    err.SysMsgWrite(ErrE,dwContinueRC,DCT_MSG_MAILBOX_TRANSLATION_ABORTED_WITH_UPDATE_SD,values[0],dwContinueRC);
                else    
                    err.SysMsgWrite(ErrE,dwContinueRC,DCT_MSG_MAILBOX_TRANSLATION_ABORTED_SD,values[0],dwContinueRC);
                e.FreeData(values);
                return FALSE;
               }

               e.FreeData(values);

            }

         } while ( ! rc );
      }
      if ( rc && (rc != LDAP_COMPARE_FALSE) && (rc != ERROR_NOT_FOUND) )
      {
         err.SysMsgWrite(ErrE,e.m_connection.LdapMapErrorToWin32(rc),DCT_MSG_LDAP_CALL_FAILED_SD,server,rc);
      }
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_CANNOT_CONNECT_TO_EXCHANGE_SERVER_SSD,server,domain,user,rc);
   }         
   
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\lgtrans.h ===
DWORD                                           // ret- 0 or error code
   TranslateLocalGroup(
      WCHAR          const   * groupName,         // in - name of group to translate
      WCHAR          const   * serverName,        // in - name of server for local group
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

DWORD  
   TranslateLocalGroups(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\exchange.hpp ===
/*---------------------------------------------------------------------------
  File: Exchange.hpp

  Comments: Mailbox security translation functions.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: ...
  Revised on 2/8/98 6:32:13 PM

 ---------------------------------------------------------------------------
*/



#ifndef __EXCHANGE_HPP__
#define __EXCHANGE_HPP__

#define INITGUID

#include <winbase.h>
#include <objbase.h>
#include "stargs.hpp"
#include "sidcache.hpp"
#include "Ustring.hpp"
#include "sdstat.hpp"
#include "exldap.h"

class TGlobalDirectory
{ 

protected:
   TSDResolveStats   * m_stat;
      
public:
   TGlobalDirectory::TGlobalDirectory();
   TGlobalDirectory::~TGlobalDirectory();
   
public:
   void     SetStats(TSDResolveStats * s ) { m_stat = s; }
   BOOL     DoLdapTranslation(WCHAR * server, WCHAR *domain, WCHAR * creds, WCHAR * password,SecurityTranslatorArgs * args,WCHAR * basepoint,WCHAR * query = NULL );
   void GetSiteNameForServer(WCHAR const * server,CLdapEnum * e,WCHAR * siteName);
   
};


#endif //__EXCHANGE_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\lgtrans.cpp ===
/*---------------------------------------------------------------------------
  File: LGTranslator.cpp

  Comments: Routines to translate membership of local groups.
  Used to update local groups on member servers or in resource domains when 
  members of the groups have been moved during a domain consolidation.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01/27/99 09:13:18

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Common.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "Mcs.h"
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"

#include <lmaccess.h> 
#include <lmapibuf.h>

extern TErrorDct err;

// Translates the membership of a local group
DWORD                                           // ret- 0 or error code
   TranslateLocalGroup(
      WCHAR          const   * groupName,         // in - name of group to translate
      WCHAR          const   * serverName,        // in - name of server for local group
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   API_RET_TYPE              rc,
                             rcEnum;
   
   // Get the members of the local group
   LOCALGROUP_MEMBERS_INFO_0 * member,
                             * memBuf;
   DWORD                     memRead,
                             memTotal;
//                             memTotal,
//                             resume = 0;
   DWORD_PTR                 resume = 0;
   TAcctNode               * node;
   BOOL						 bUseMapFile = stArgs->UsingMapFile();

   
   // make a list of the group's members 
   do 
   { 
      rcEnum = NetLocalGroupGetMembers( serverName, 
                                     groupName, 
                                     0, 
                                     (LPBYTE *)&memBuf, 
                                     BUFSIZE, 
                                     &memRead, 
                                     &memTotal, 
                                     &resume );
      if ( rcEnum != ERROR_SUCCESS && rcEnum != ERROR_MORE_DATA )
         break;
      for ( member = memBuf;  member < memBuf + memRead;  member++ )
      {
         rc = 0;
         stat->IncrementExamined(groupmember);
		 if (!bUseMapFile)
            node = cache->Lookup(member->lgrmi0_sid);
		 else
            node = cache->LookupWODomain(member->lgrmi0_sid);
         if ( node == (TAcctNode*)-1 )
         {
            node = NULL;     
         }
         if ( node && node->IsValidOnTgt() )
         {
            // Found the account in the cache
            // remove this member from the group and add the target member
            if ( ! stArgs->NoChange() && ( stArgs->TranslationMode() == REPLACE_SECURITY || stArgs->TranslationMode() == REMOVE_SECURITY ) )
            {
               rc = NetLocalGroupDelMembers(serverName,groupName,0,(LPBYTE)member,1);
            }
            if ( rc )
            {
               err.SysMsgWrite(ErrE,rc,DCT_MSG_MEMBER_REMOVE_FAILED_SSSD,node->GetAcctName(),groupName,serverName,rc);
               stat->IncrementSkipped(groupmember);
            }
            else
            {
               node->AddAceChange(groupmember); 
               stat->IncrementChanged(groupmember);
               PSID sid = NULL;
	           if (!bUseMapFile)
                  sid = cache->GetTgtSid(node);
	           else
                  sid = cache->GetTgtSidWODomain(node);
               if ( sid )
               {
                  if ( !stArgs->NoChange() && (stArgs->TranslationMode() != REMOVE_SECURITY) )
                  {
                     rc = NetLocalGroupAddMembers(serverName,groupName,0,(LPBYTE)&sid,1);
                  }
                  if ( rc )
                  {
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_MEMBER_ADD_FAILED_SSSD,node->GetAcctName(),groupName,serverName,rc);
                  }
                  free(sid);
               }
            }
         }
      }
      NetApiBufferFree( memBuf );
   } while ( rcEnum == ERROR_MORE_DATA );
   if ( rcEnum != ERROR_SUCCESS )
   {
      err.SysMsgWrite(ErrE,rcEnum,DCT_MSG_GROUP_ENUM_FAILED_SS,groupName,serverName);
   }
   return rc;
}

DWORD  
   TranslateLocalGroups(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
   DWORD                       rc = 0;
   LOCALGROUP_INFO_0         * buf,
                             * groupInfo;
   DWORD                       numRead,
//                               numTotal,
//                               resume=0;
                               numTotal;
   DWORD_PTR                   resume=0;
   WCHAR                       currName[LEN_Computer + LEN_Group];

         
   // Get a list of all the local groups
   do 
   {
      if ( cache->IsCancelled() )
      {
         //err.MsgWrite(0,DCT_MSG_OPERATION_ABORTED);
         break;
      }
      rc = NetLocalGroupEnum(serverName,0,(LPBYTE*)&buf,BUFSIZE,&numRead,&numTotal,&resume);
      
      if ( rc != ERROR_SUCCESS && rc != ERROR_MORE_DATA )
         break;
      for ( groupInfo = buf ; groupInfo < buf + numRead ; groupInfo++ )
      {
         swprintf(currName,L"%s\\%s",serverName,groupInfo->lgrpi0_name);
         stat->DisplayPath(currName);
         TranslateLocalGroup(groupInfo->lgrpi0_name,serverName,stArgs,cache,stat);
      }
      NetApiBufferFree(buf);

   } while ( rc == ERROR_MORE_DATA );
   stat->DisplayPath(L"");
   return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\pluginfo.h ===
// PlugInInfo.h : Declaration of the CPlugInInfo

#ifndef __PLUGININFO_H_
#define __PLUGININFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPlugInInfo
class ATL_NO_VTABLE CPlugInInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CPlugInInfo, &CLSID_PlugInInfo>,
	public IDispatchImpl<IPlugInInfo, &IID_IPlugInInfo, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CPlugInInfo()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_PLUGININFO)
DECLARE_NOT_AGGREGATABLE(CPlugInInfo)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CPlugInInfo)
	COM_INTERFACE_ENTRY(IPlugInInfo)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IPlugInInfo
public:
	STDMETHOD(EnumeratePlugIns)(/*[out]*/ SAFEARRAY ** pPlugIns);
};

#endif //__PLUGININFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\pluginfo.cpp ===
/*---------------------------------------------------------------------------
  File: PlugInInfo.cpp

  Comments: COM Object to enumerate information about available plug-ins 
  and extensions.  These plug-ins are distributed with the agent to the remote
  machines to perform custom migration tasks.  

  This interface would be used by the dispatcher, and possibly by the GUI, to 
  enumerate the list of available plug-ins.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/ 
   // PlugInInfo.cpp : Implementation of CPlugInInfo
#include "stdafx.h"
#include "WorkObj.h"
#include "PlugInfo.h"
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "TNode.hpp"
#include "EaLen.hpp"

#include "McsPI.h" 
#include "McsPI_i.c" 
#include "ARExt_i.c"

#include "folders.h"
using namespace nsFolders;

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CPlugInInfo

// the PlugInNode is used to build a list of available plug-ins
class PlugInNode : public TNode
{
   WCHAR                     name[LEN_Guid];    // CLSID of the plug-in
public:
   PlugInNode(WCHAR const * n) { safecopy(name,n); }
   WCHAR const * GetName() { return name; }
};

// Checks the specified file to see if it implements any COM objects that implement the
// McsDomPlugIn interface -- if so, it appends them to the list of available plug-ins
void 
   AppendPlugInsToList(
      TNodeList            * pList, // in - list of plug-ins
      WCHAR          const * path   // in - file to examine for Plug-In COM objects
  )
{
   HRESULT                   hr = S_OK;
   ITypeLib                * pTlib = NULL;

   hr = LoadTypeLib(path,&pTlib);

   if ( SUCCEEDED(hr) )
   {
      UINT count = pTlib->GetTypeInfoCount();
      for ( UINT i = 0 ; i < count ; i++ )
      {
         ITypeInfo         * pInfo = NULL;
         hr = pTlib->GetTypeInfo(i,&pInfo);

         if ( SUCCEEDED(hr) )
         {
            TYPEATTR        * attr = NULL;

            hr = pInfo->GetTypeAttr(&attr);
            if ( SUCCEEDED(hr) )
            {
               if ( attr->typekind == TKIND_COCLASS )
               {
                  IMcsDomPlugIn        * pPlugIn = NULL;
                  // see if it supports IMcsDomPlugIn
                  hr = CoCreateInstance(attr->guid,NULL,CLSCTX_ALL,IID_IMcsDomPlugIn,(void**)&pPlugIn);
                  if ( SUCCEEDED(hr) )
                  {
                     pPlugIn->Release();   
                     // add the coclass to the list
                     LPOLESTR             strClsid = NULL;

                     hr = StringFromCLSID(attr->guid,&strClsid);
                     if ( SUCCEEDED(hr) ) 
                     {
                        PlugInNode * pNode = new PlugInNode(strClsid);
                        CoTaskMemFree(strClsid);
                        pList->InsertBottom(pNode);
                     }

                  }
               }
               pInfo->ReleaseTypeAttr(attr);   
            }
            pInfo->Release();
         }
      }
      pTlib->Release();
   }
}

SAFEARRAY *                                // ret- SAFEARRAY(BSTR) of filenames
   SafeArrayFromList(
      TNodeList            * pList         // in - list of filenames
   )
{
   SAFEARRAYBOUND            bound[1] = { pList->Count(),0 };
   SAFEARRAY               * pArray = SafeArrayCreate(VT_BSTR,1,bound);
   TNodeListEnum             tEnum;
   PlugInNode              * pNode;
   PlugInNode              * pNext;
   long                      ndx[1] = {0};

   for ( pNode = (PlugInNode *)tEnum.OpenFirst(pList) ; pNode ; pNode = pNext )
   {
      pNext = (PlugInNode *)tEnum.Next();

      SafeArrayPutElement(pArray,ndx,SysAllocString(pNode->GetName()));
      ndx[0]++;
      pList->Remove(pNode);
      delete pNode;
   }
   tEnum.Close();
   
   return pArray;
}

STDMETHODIMP 
   CPlugInInfo::EnumeratePlugIns(
      SAFEARRAY            ** pPlugIns     // out- safearray containing clsids of available migration plug-ins
   )
{
	HRESULT                   hr = S_OK;
   DWORD                     rc;
   TRegKey                   key;
   WCHAR                     directory[MAX_PATH];
   WCHAR                     path[MAX_PATH];
   WCHAR                     dllPath[MAX_PATH];
   TNodeList                 list;
   
   // Get the plug-ins directory from the registry
   rc = key.Open(REGKEY_ADMT,HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"PlugInDirectory",directory,(sizeof directory));
      if ( ! rc )
      {
         // Enumerate the files there that match the naming convention:
         WIN32_FIND_DATA     fDat;
         HANDLE              hFind;
         
         UStrCpy(path,directory);
         UStrCpy(path + UStrLen(path),L"\\McsPi*.Dll");

         hFind = FindFirstFile(path,&fDat);
         if ( hFind && hFind != INVALID_HANDLE_VALUE )
         {
            BOOL                 bRc = TRUE;
            for ( ; rc == 0 ; bRc = FindNextFile(hFind,&fDat) )
            {
               if ( bRc )
               {
                  UStrCpy(dllPath,directory);
                  UStrCpy(dllPath + UStrLen(dllPath),L"\\");
                  UStrCpy(dllPath + UStrLen(dllPath),fDat.cFileName);
                  // check each one to see if it is a plug-in
                  AppendPlugInsToList(&list,dllPath);
               }
               else
               {
                  rc = GetLastError();
               }
            }

            // create a safearray from the contents of the list
            (*pPlugIns) = SafeArrayFromList(&list);
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
   else
   {
      hr = HRESULT_FROM_WIN32(rc);
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\reboot.h ===
/*---------------------------------------------------------------------------
  File: RebootComputer.h

  Comments: Implementation class definition for COM object to reboot a computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:24:22

 ---------------------------------------------------------------------------
*/

// RebootComputer.h : Declaration of the CRebootComputer

#ifndef __REBOOTCOMPUTER_H_
#define __REBOOTCOMPUTER_H_

#include "resource.h"       // main symbols


/////////////////////////////////////////////////////////////////////////////
// CRebootComputer
class ATL_NO_VTABLE CRebootComputer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRebootComputer, &CLSID_RebootComputer>,
	public IDispatchImpl<IRebootComputer, &IID_IRebootComputer, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   BOOL                      m_bNoChange;
public:
	CRebootComputer()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_REBOOT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRebootComputer)
	COM_INTERFACE_ENTRY(IRebootComputer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IWorkNode
public:
   STDMETHOD(Process)(IUnknown *pWorkItem);

// IRebootComputer
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(Reboot)(BSTR Computer, DWORD delay);
};

#endif //__REBOOTCOMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\procexts.cpp ===
/*---------------------------------------------------------------------------
  File: ProcessExtensions.cpp

  Comments: implementation of the CProcessExtensions class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "workobj.h"
#include "TReg.hpp"
#include "ProcExts.h"
#include "ResStr.h"
#include "DCTStat.h"
#include "TxtSid.h"
#include "ARExt_i.c"
#include "folders.h"

using namespace nsFolders;

//#import "\bin\AdsProp.tlb" no_namespace
#import "AdsProp.tlb" no_namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const _bstr_t                sKeyExtension = REGKEY_EXTENSIONS;
const _bstr_t                sKeyBase      = REGKEY_ADMT;

extern TErrorDct                    err;

// Sort function for the list of interface pointers
int TExtNodeSortBySequence(TNode const * t1, TNode const * t2)
{
   TNodeInterface    const * p1 = (TNodeInterface const *)t1;
   TNodeInterface    const * p2 = (TNodeInterface const *)t2;

   if ( p1->GetSequence() < p2->GetSequence() )
      return -1;
   else if ( p1->GetSequence() > p2->GetSequence() )
      return 1;
   else 
      return 0;
}
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

//---------------------------------------------------------------------------
// CONSTRUCTOR : The constructor looks up all the registered COM extensions
//               from the registry. For each one it creates a com object and
//               puts it into a list as a IExtendAccountMigration *.
//---------------------------------------------------------------------------
CProcessExtensions::CProcessExtensions(
                                          IVarSetPtr pVs          //in -Pointer to the Varset with main settings.
                                      )
{
    // Store the varset that has the main settings.
    m_pVs = pVs;

    // GUI told us to run all the Extensions.
    // Now look through the registry to get all the registered extension object ClassIDs
    // for each one create a object and store the interface pointer in an array.
    TRegKey                   key;
    TCHAR                     sName[300];    // key name
    TCHAR                     sValue[300];   // value name
    DWORD                     valuelen;     // value length
    DWORD                     type;         // value type
    DWORD                     retval = 0;   // Loop sentinel
    CLSID                     clsid;
    HRESULT                   hr;
    IExtendAccountMigration * pExtTemp;
    retval = 0;

    // Open the Extensions registry key
    DWORD rc = key.Open(sKeyExtension);
    // if no extensions then we can leave now.
    if ( rc != ERROR_SUCCESS )
    {
        err.SysMsgWrite(ErrE, rc, DCT_MSG_REG_KEY_OPEN_FAILED_SD, (PCWSTR)sKeyExtension, rc);
        _com_issue_error(HRESULT_FROM_WIN32(rc));
    }

    valuelen = sizeof(sValue);
    // Go through all Name-Value pairs and try to create those objects
    // if successful then put it into the list to be processed.
    long ndx = 0;
    while (!retval)
    {
        retval = key.ValueEnum(ndx, sName, sizeof(sName)/sizeof(sName[0]), sValue, &valuelen, &type);
        if ( !retval )
        {
            // each name in here is a Object name for the class ID. we are going to use this to 
            // Create the object and then put the IExtendAccountRepl * in the list member0
            ::CLSIDFromProgID(sName, &clsid);
            hr = ::CoCreateInstance(clsid, NULL, CLSCTX_ALL, IID_IExtendAccountMigration, (void **) &pExtTemp);
            if ( SUCCEEDED(hr) )
            {
                TNodeInterface * pNode = new TNodeInterface(pExtTemp);
                long num;
                hr =  pExtTemp->get_SequenceNumber(&num);
                if ((pNode) && (SUCCEEDED(hr)))
                { 
                    pNode->SetSequence(num);
                }
                if (pNode)
                {
                    m_listInterface.InsertBottom(pNode);
                }
                else
                {
                    pExtTemp->Release();
                    _com_issue_error(E_OUTOFMEMORY);
                }
            }
            else
            {
                err.SysMsgWrite(ErrE, hr, DCT_MSG_CANNOT_CREATE_EXTENSION_S, sName);
                _com_issue_error(hr);
            }
        }
        if ((retval != ERROR_SUCCESS) && (retval != ERROR_NO_MORE_ITEMS))
        {
            err.SysMsgWrite(ErrE, retval, DCT_MSG_CANNOT_ENUM_REGISTRY_VALUES_S, (PCWSTR)sKeyExtension);
            _com_issue_error(HRESULT_FROM_WIN32(retval));
        }
        ndx++;
    }

    m_listInterface.Sort(&TExtNodeSortBySequence);
}

//---------------------------------------------------------------------------
// DESTRUCTOR : Clears the list of interfaces.
//---------------------------------------------------------------------------
CProcessExtensions::~CProcessExtensions()
{
   TNodeInterface * pNode;
   TNodeInterface * tempNode;

   pNode = (TNodeInterface *) m_listInterface.Head();
   while ( pNode )
   {
      tempNode = (TNodeInterface *)pNode->Next();
      delete pNode;
      pNode = tempNode;
   }
}

//---------------------------------------------------------------------------
// Process: This function is called by the account replicator for every 
//          object that is copied. This function sets up the parameters and
//          for every registered extension object it calls the Process method
//          on that extension.
//---------------------------------------------------------------------------
HRESULT CProcessExtensions::Process(
                                       TAcctReplNode * pAcctNode,    //in- Account replication node
                                       _bstr_t sTargetDomain,        //in- Name of the target domain
                                       Options * pOptions,           //in- Options as set by the user
                                       BOOL   bPreMigration          //in- Flag, whether to call pre or post task
                                   )
{
   IExtendAccountMigration * pExt;
   TNodeInterface          * pNode = NULL;
   HRESULT                   hr;
   IUnknown                * pSUnk = NULL;
   IUnknown                * pTUnk = NULL;
   IUnknown                * pMain = NULL;
   IUnknown                * pProps = NULL;
   IVarSetPtr                pVar(__uuidof(VarSet));
   IObjPropBuilderPtr        pProp(__uuidof(ObjPropBuilder));
   IADs                    * pSource = NULL;
   IADs                    * pTarget = NULL;
   _variant_t                var;
   IDispatch               * pDisp = NULL;

   // Get the IADs to both source and target accounts.
   hr = ADsGetObject(const_cast<WCHAR *>(pAcctNode->GetSourcePath()), IID_IADs, (void**) &pSource);
   if ( FAILED(hr))
      pSource = NULL;

   hr = ADsGetObject(const_cast<WCHAR *>(pAcctNode->GetTargetPath()), IID_IADs, (void**) &pTarget);
   if ( FAILED(hr))
      pTarget = NULL;

   // Get IUnknown * s to everything... Need to marshal it that way
   if ( pSource != NULL )
      pSource->QueryInterface(IID_IUnknown, (void **) &pSUnk);
   else
      pSUnk = NULL;

   if ( pTarget != NULL )
      pTarget->QueryInterface(IID_IUnknown, (void **) &pTUnk);
   else
      pTUnk = NULL;

   pVar->QueryInterface(IID_IUnknown, (void **) &pProps);
   m_pVs->QueryInterface(IID_IUnknown, (void **) &pMain);

   if ( pOptions->bSameForest )
      m_pVs->put(GET_BSTR(DCTVS_Options_IsIntraforest),GET_BSTR(IDS_YES));
   else
      m_pVs->put(GET_BSTR(DCTVS_Options_IsIntraforest),GET_BSTR(IDS_No));

   m_pVs->put(L"Options.SourceDomainVersion",(long)pOptions->srcDomainVer);
   m_pVs->put(L"Options.TargetDomainVersion",(long)pOptions->tgtDomainVer);
   // AccountNode into the Varset.
   PutAccountNodeInVarset(pAcctNode, pTarget, m_pVs);

   // Put the DB manager into the Varset
   pOptions->pDb->QueryInterface(IID_IDispatch, (void**)&pDisp);
   var.vt = VT_DISPATCH;
   var.pdispVal = pDisp;
   m_pVs->putObject(GET_BSTR(DCTVS_DBManager), var);
   // Call the Process Object method on all registered objects.that we created
   pNode  = (TNodeInterface *) m_listInterface.Head();
   while ( pNode )
   {
      try
      {
         if ( pOptions->pStatus )
         {
            LONG                status = 0;
            HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
            if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
               break;
         }
         pExt = pNode->GetInterface();
         if ( pOptions->bUndo )
         {
            EAMAccountStats eamAccountStats = { 0 };
            hr = pExt->ProcessUndo(pSUnk, pTUnk, pMain, &pProps, &eamAccountStats);
            BatchMark(eamAccountStats);
         }
         else
         {
            BSTR sName;
            pExt->get_sName(&sName);
            if ( bPreMigration )
			{
			    EAMAccountStats eamAccountStats = { 0 };
               hr = pExt->PreProcessObject(pSUnk, pTUnk, pMain, &pProps, &eamAccountStats);
               BatchMark(eamAccountStats);
			   if (hr == ERROR_OBJECT_ALREADY_EXISTS)
			      pAcctNode->SetHr(hr);
			}
            else
			{
			   /* we need to run the DisAcct extension last, so don't run it in this loop 
				  run it in the next loop by itself */
			      //if not DisAcct extension, process this extension 
			   if (wcscmp((WCHAR*)sName, L"Disable Accounts")) {
			    EAMAccountStats eamAccountStats = { 0 };
                hr = pExt->ProcessObject(pSUnk, pTUnk, pMain, &pProps, &eamAccountStats);
                BatchMark(eamAccountStats);
			    }
			}
         }
      }
      catch (...)
      {
         BSTR sName;
         pExt->get_sName(&sName);
         err.LogOpen(pOptions->logFile,1);
         err.MsgWrite(ErrE, DCT_MSG_Extension_Exception_SS, (WCHAR*) sName, pAcctNode->GetTargetName());
         err.LogClose();
         hr = S_OK;
      }
      pNode = (TNodeInterface *)pNode->Next();
   }

   /* now run the DisAcct extension here to ensure it is run last, if not undo or premigration */
   if ((!pOptions->bUndo) && (!bPreMigration))
   {
      bool bDone = false;
      pNode  = (TNodeInterface *) m_listInterface.Head();
      while ((pNode) && (!bDone))
	  {
         try
		 {
            if ( pOptions->pStatus )
			{
               LONG                status = 0;
               HRESULT             hr = pOptions->pStatus->get_Status(&status);
   
               if ( SUCCEEDED(hr) && status == DCT_STATUS_ABORTING )
                  break;
			}
            pExt = pNode->GetInterface();
            BSTR sName;
            pExt->get_sName(&sName);
			if (!wcscmp((WCHAR*)sName, L"Disable Accounts"))
			{
			   bDone = true;
			   EAMAccountStats eamAccountStats = { 0 };
               hr = pExt->ProcessObject(pSUnk, pTUnk, pMain, &pProps, &eamAccountStats);
               BatchMark(eamAccountStats);
			}
         }
         catch (...)
		 {
            BSTR sName;
            pExt->get_sName(&sName);
            err.LogOpen(pOptions->logFile,1);
            err.MsgWrite(ErrE, DCT_MSG_Extension_Exception_SS, (WCHAR*) sName, pAcctNode->GetTargetName());
            err.LogClose();
            hr = S_OK;
		 }
         pNode = (TNodeInterface *)pNode->Next();
	  }//end while not done and more
   }//end if not undo or premigration

   // Now we have the varset with all the settings that the user wants us to set.
   // So we can call the SetPropsFromVarset method in out GetProps object to set these
   // properties.
   hr = pProp->SetPropertiesFromVarset(pAcctNode->GetTargetPath(), /*sTargetDomain,*/ pProps, ADS_ATTR_UPDATE);

   // Update the AccountNode with any changes made by the extensions
   UpdateAccountNodeFromVarset(pAcctNode, pTarget, m_pVs);

   // Cleanup time ... 
   if ( pSUnk ) pSUnk->Release();
   if ( pTUnk ) pTUnk->Release();
   if ( pProps ) pProps->Release();
   if ( pMain ) pMain->Release();
   if ( pSource ) pSource->Release();
   if ( pTarget ) pTarget->Release();

   return hr;
}


//---------------------------------------------------------------------------
// PutAccountNodeInVarset : Transfers all the account node info into the 
//                          varset.
//---------------------------------------------------------------------------
void CProcessExtensions::PutAccountNodeInVarset(
                                                   TAcctReplNode *pNode,   //in -Replicated account node to get info
                                                   IADs * pTarget,         //in -IADs pointer to the target object for the GUID
                                                   IVarSet * pVS          //out-Varset to put the information in
                                               )
{
   _variant_t                var = L"";
   BSTR                      sGUID;
   DWORD                     lVal = 0;
   HRESULT                   hr;
   WCHAR                     strSid[MAX_PATH];
   DWORD                     lenStrSid = DIM(strSid);

   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceName),pNode->GetName());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourcePath),pNode->GetSourcePath());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceProfile),pNode->GetSourceProfile());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceRID),(long)pNode->GetSourceRid());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceSam),pNode->GetSourceSam());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Status),(long)pNode->GetStatus());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetName),pNode->GetTargetName());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetPath),pNode->GetTargetPath());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetProfile),pNode->GetTargetProfile());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetRID),(long)pNode->GetTargetRid());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_TargetSam),pNode->GetTargetSam());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Type),pNode->GetType());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_GroupType),(long)pNode->GetGroupType());
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Operations),(long)pNode->operations);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_ExpDate),pNode->lExpDate);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_UserFlags), pNode->lFlags);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceUPN),pNode->GetSourceUPN());
   GetTextualSid(pNode->GetSourceSid(),strSid,&lenStrSid);
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_SourceDomainSid),strSid);

   // Get the GUID
   if ( pTarget )
   {
      hr = pTarget->get_GUID(&sGUID);
      if ( SUCCEEDED(hr) )
      {
         var = sGUID;
         SysFreeString(sGUID);
      }
   }
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_GUID), var);

   // Get the status
   lVal = pNode->GetStatus();
   var.Clear();
   var.vt = VT_UI4;
   var.lVal = lVal;
   pVS->put(GET_WSTR(DCTVS_CopiedAccount_Status), var);
}

//---------------------------------------------------------------------------
// UpdateAccountNodeFromVarset : Updates the account node info with the data in the Transfers all the account node info into the 
//                          varset.
//---------------------------------------------------------------------------
void CProcessExtensions::UpdateAccountNodeFromVarset(
                                                   TAcctReplNode *pNode,   //in -Replicated account node to get info
                                                   IADs * pTarget,         //in -IADs pointer to the target object for the GUID
                                                   IVarSet * pVS          //out-Varset to put the information in
                                               )
{
   _variant_t                var = L"";
   DWORD                     lVal = 0;
   _bstr_t                   text;
   long                      val;

   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceName));
   pNode->SetName(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourcePath));
   pNode->SetSourcePath(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceProfile));
   pNode->SetSourceProfile(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceRID));
   pNode->SetSourceRid(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceSam));
   pNode->SetSourceSam(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Status));
   pNode->SetStatus(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetName));
   pNode->SetTargetName(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetPath));
   pNode->SetTargetPath(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetProfile));
   pNode->SetTargetProfile(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetRID));
   pNode->SetTargetRid(val);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_TargetSam));
   pNode->SetTargetSam(text);
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Type));
   pNode->SetType(text);
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_Operations));
   pNode->operations = val;
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_ExpDate));
   pNode->lExpDate = val;
   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_UserFlags));
   pNode->lFlags = val;
   text = pVS->get(GET_WSTR(DCTVS_CopiedAccount_SourceDomainSid));
   pNode->SetSourceSid(SidFromString((WCHAR*)text));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\pwdage.h ===
/*---------------------------------------------------------------------------
  File: ComputerPwdAge.h

  Comments: Definition of COM object to retrieve password age for computer 
  accounts (used to detect defunct accounts).

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:20:20

 ---------------------------------------------------------------------------
*/

// ComputerPwdAge.h : Declaration of the CComputerPwdAge

#ifndef __COMPUTERPWDAGE_H_
#define __COMPUTERPWDAGE_H_

#include "resource.h"       // main symbols
#include <comdef.h>
#include "Err.hpp"

/////////////////////////////////////////////////////////////////////////////
// CComputerPwdAge
class ATL_NO_VTABLE CComputerPwdAge : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CComputerPwdAge, &CLSID_ComputerPwdAge>,
	public IDispatchImpl<IComputerPwdAge, &IID_IComputerPwdAge, &LIBID_MCSDCTWORKEROBJECTSLib>
{
      _bstr_t                m_Domain;
      _bstr_t                m_DomainCtrl;

public:
	CComputerPwdAge()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_COMPPWDAGE)
DECLARE_NOT_AGGREGATABLE(CComputerPwdAge)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CComputerPwdAge)
	COM_INTERFACE_ENTRY(IComputerPwdAge)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

   // IWorkNode
public:
 	STDMETHOD(Process)(IUnknown *pWorkItem);

 

// IComputerPwdAge
public:
	STDMETHOD(ExportPasswordAgeNewerThan)(BSTR domain, BSTR filename, DWORD maxAge);
	STDMETHOD(ExportPasswordAgeOlderThan)(BSTR domain, BSTR filename, DWORD minAge);
	STDMETHOD(ExportPasswordAge)(BSTR domain, BSTR filename);
	STDMETHOD(GetPwdAge)(BSTR DomainName,BSTR ComputerName,DWORD * age);
	STDMETHOD(SetDomain)(BSTR domain);

protected:
   DWORD GetDomainControllerForDomain(WCHAR const * domain, WCHAR * domctrl);
   DWORD GetSinglePasswordAgeInternal(WCHAR const * domctrl, WCHAR const * computer, DWORD * pwdage);
   DWORD ExportPasswordAgeInternal(WCHAR const * domctrl, WCHAR const * filename, DWORD minOrMaxAge, BOOL bOlder);
};

#endif //__COMPUTERPWDAGE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\reboot.cpp ===
/*---------------------------------------------------------------------------
  File: RebootComputer.cpp

  Comments: Implementation of COM object to reboot a remote computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:21:40

 ---------------------------------------------------------------------------
*/

// RebootComputer.cpp : Implementation of CRebootComputer
#include "stdafx.h"
#include "WorkObj.h"
#include "Reboot.h"
#include "UString.hpp"
#include "ResStr.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CRebootComputer

#include "BkupRstr.hpp"

STDMETHODIMP 
   CRebootComputer::Reboot(
      BSTR                   Computer,       // in - name of computer to reboot
      DWORD                  delay           // in - delay in seconds before rebooting
   )
{
   HRESULT                   hr  = S_OK;
   DWORD                     rc;
   
   rc = ComputerShutDown((WCHAR*)Computer,NULL,delay,TRUE,m_bNoChange);

   if ( rc )
   {
      hr = HRESULT_FROM_WIN32(rc);
   }

   return hr;

}

STDMETHODIMP 
   CRebootComputer::get_NoChange(
      BOOL                 * pVal         // out- flag, whether to actually reboot when reboot is called (or to do dry-run)
   )
{
	(*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP 
   CRebootComputer::put_NoChange(
      BOOL                   newVal       // in - flag, whether to really reboot, or to do a dry run
   )
{
	m_bNoChange = newVal;
   return S_OK;
}

// RebootComputer WorkNode:  Reboots a remote computer, with an optional delay
// This function is not currently used by the domain migrator product, but provides
// and alternate way for clients to use this COM object
// 
// VarSet Syntax:
//  Input:
//       RebootComputer.Computer: <ComputerName>
//       RebootComputer.Message: <Message> (optional)
//       RebootComputer.Delay: <number-of-seconds> (optional, default=0)
//       RebootComputer.Restart: <Yes|No> (optional, default=Yes)

STDMETHODIMP 
   CRebootComputer::Process(
      IUnknown             * pWorkItem          // in - varset containing settings
   )
{
   HRESULT                    hr = S_OK;
   IVarSetPtr                 pVarSet = pWorkItem;
   DWORD                      delay = 0;
   BOOL                       restart = TRUE;

   _bstr_t                    computer = pVarSet->get(L"RebootComputer.Computer");
   _bstr_t                    message = pVarSet->get(L"RebootComputer.Message");
   _bstr_t                    text = pVarSet->get(L"RebootComputer.Restart");

   if ( !UStrICmp(text,GET_STRING(IDS_No)) )
   {
      restart = FALSE;
   }

   delay = (LONG)pVarSet->get(L"RebootComputer.Delay");

   if ( computer.length() )
   {
      DWORD                   rc = ComputerShutDown((WCHAR*)computer,(WCHAR*)message,delay,restart,FALSE);

      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
      
   return hr;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\procexts.h ===
/*---------------------------------------------------------------------------
  File: ProcessExtensions.h

  Comments: interface for the CProcessExtensions class..

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#if !defined(AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_)
#define AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "ARExt.h"
#include "TNode.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#include "sdstat.hpp" //include this to get a #import of VarSet.tlb
#include "iads.h"
#include "TARNode.hpp"
#include "ExtSeq.h"

class CProcessExtensions;
struct Options;

#include "usercopy.hpp"

class CProcessExtensions  
{
public:
	CProcessExtensions(IVarSetPtr pVs);
	virtual ~CProcessExtensions();
   HRESULT Process(TAcctReplNode * pAcctNode, _bstr_t sTargetDomain, Options * pOptions,BOOL bPreMigration);
private:
   IVarSetPtr                m_pVs;
   TNodeListSortable         m_listInterface;
protected:
	void PutAccountNodeInVarset(TAcctReplNode * pNode, IADs * pTarget, IVarSet * pVS);
   void UpdateAccountNodeFromVarset(TAcctReplNode * pNode, IADs * pTarget, IVarSet * pVS);
};

class TNodeInterface : public TNode
{
   IExtendAccountMigration * m_pExt;
   long                      m_Sequence;
public:
   TNodeInterface( IExtendAccountMigration * pExt ) { m_pExt = pExt; m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER; }
   ~TNodeInterface() { m_pExt->Release(); }
   IExtendAccountMigration * GetInterface() const { return m_pExt; }
   void SetInterface( const IExtendAccountMigration * pExt ) { m_pExt = const_cast<IExtendAccountMigration *>(pExt); }
   long GetSequence() const { return m_Sequence; }
   void SetSequence(long val) { m_Sequence = val; }
};

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif // !defined(AFX_PROCESSEXTENSIONS_H__B3C465A0_2E47_11D3_8C8E_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\pwdage.cpp ===
/*---------------------------------------------------------------------------
  File: ComputerPwdAge.cpp

  Comments: Implementation of COM object to retrieve password age for computer 
  accounts (used to detect defunct computer accounts.)

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:19:31

 ---------------------------------------------------------------------------
*/

// ComputerPwdAge.cpp : Implementation of CComputerPwdAge
#include "stdafx.h"
#include "WorkObj.h"
#include "PwdAge.h"
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "CommaLog.hpp"
#include "EaLen.hpp"
#include "GetDcName.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace, named_guids

#include <lm.h>

/////////////////////////////////////////////////////////////////////////////
// CComputerPwdAge


STDMETHODIMP 
   CComputerPwdAge::SetDomain(
      BSTR                   domain        // in - domain name to examine
   )
{
	HRESULT                   hr = S_OK;
   DWORD                     rc;
   WCHAR                     domctrl[LEN_Computer];

   if ( UStrICmp(m_Domain,domain) )
   {
      m_Domain = domain;

      rc = GetDomainControllerForDomain(domain,domctrl);

      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
      else
      {
         m_DomainCtrl = domctrl;
      }
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::GetPwdAge(
      BSTR                   domain,         // in - domain name to examine
      BSTR                   ComputerName,   // in - machine name of computer                               
      DWORD                * pPwdAge         // out- password age in seconds
   )
{
   HRESULT                   hr;
   DWORD                     rc;
   WCHAR                     computerAccountName[LEN_Account];
   DWORD                     pwdage = 0;

   hr = SetDomain(domain);
   if ( SUCCEEDED(hr) )
   {
      swprintf(computerAccountName,L"%s",ComputerName);      
      rc = GetSinglePasswordAgeInternal(m_DomainCtrl,computerAccountName,&pwdage);
      if ( ! rc )
      {
         (*pPwdAge) = pwdage;
      }
      else
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAge(
      BSTR                   domain,       // in - domain to export information from
      BSTR                   filename      // in - UNC name of file to write information to
   )
{
	HRESULT                   hr;

   hr = SetDomain(domain);
   if ( SUCCEEDED(hr) )
   {
      hr = ExportPasswordAgeOlderThan(domain,filename,0);
   }
   return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAgeOlderThan(
      BSTR                   domain,      // in - domain to export information from
      BSTR                   filename,    // in - filename to write information to
      DWORD                  minAge       // in - write only accounts with password age older than minAge
   )
{
	DWORD                     rc = 0;
   HRESULT                   hr; 

   hr = SetDomain(domain);
   
   if ( SUCCEEDED(hr) )
   {
      rc = ExportPasswordAgeInternal(m_DomainCtrl,filename,minAge,TRUE);
      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
	return hr;
}

STDMETHODIMP 
   CComputerPwdAge::ExportPasswordAgeNewerThan(
      BSTR                   domain,       // in - domain to export information from
      BSTR                   filename,     // in - filename to write information to
      DWORD                  maxAge        // in - write only computer accounts with password age less than maxAge
   )
{                                                	
   DWORD                     rc = 0;
   HRESULT                   hr; 

   hr = SetDomain(domain);
   
   if ( SUCCEEDED(hr) )
   {
      rc = ExportPasswordAgeInternal(m_DomainCtrl,filename,maxAge,FALSE);
      if ( rc )
      {
         hr = HRESULT_FROM_WIN32(rc);
      }
   }
	return hr;

}

DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::GetDomainControllerForDomain(
      WCHAR          const * domain,       // in - name of domain
      WCHAR                * domctrl       // out- domain controller for domain
   )
{
   DWORD                     rc;
   _bstr_t                   result;

   rc = GetAnyDcName4(domain, result);
   if ( ! rc )
   {
      wcscpy(domctrl,result);
   }
   return rc;
}

DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::ExportPasswordAgeInternal(
      WCHAR          const * domctrl,      // in - domain controller to query
      WCHAR          const * filename,     // in - filename to write results to  
      DWORD                  minOrMaxAge,  // in - optional min or max age to write 
      BOOL                   bOld          // in - TRUE-Age is min age, copies only old accounts
   )
{
   DWORD                     rc = 0;
   DWORD                     nRead;
   DWORD                     nTotal;
   DWORD                     nResume = 0;
   DWORD                     prefmax = 1000;
   USER_INFO_11            * buf;
   time_t                    pwdage;  // the number of seconds ago that the pwd was last changed
   time_t                    pwdtime; // the time when the pwd was last changed
   time_t                    now;     // the current time
   CommaDelimitedLog         log;
   IIManageDBPtr             pDB;
   WCHAR                     computerName[LEN_Account];

   rc = pDB.CreateInstance(CLSID_IManageDB);
   if ( SUCCEEDED(rc) )
   {
   
      time(&now);
      do 
      {
         rc = NetUserEnum(domctrl,11,FILTER_WORKSTATION_TRUST_ACCOUNT,(LPBYTE*)&buf,prefmax,&nRead,&nTotal,&nResume);
         if ( rc && rc != ERROR_MORE_DATA )
            break;
         for ( UINT i = 0 ; i < nRead ; i++ )
         {
            pwdage = buf[i].usri11_password_age;
            if ( ( pwdage >= (time_t)minOrMaxAge && bOld )  // inactive machines
               ||( pwdage <= (time_t)minOrMaxAge && !bOld ) ) // active machines
            {
               safecopy(computerName,buf[i].usri11_name);
               // strip off the $ from the end of the computer account
               computerName[UStrLen(computerName)-1] = 0; 
//               pDB->raw_SavePasswordAge(m_Domain,SysAllocString(computerName),SysAllocString(buf[i].usri11_comment),pwdage);
               pDB->raw_SavePasswordAge(m_Domain,SysAllocString(computerName),SysAllocString(buf[i].usri11_comment),(long)pwdage);

               pwdtime = now - pwdage;
            }
         }
         NetApiBufferFree(buf);

      } while ( rc == ERROR_MORE_DATA );

   }
   else 
   {
      rc = GetLastError();
   }
   return rc;
}


DWORD                                      // ret- WIN32 error code
   CComputerPwdAge::GetSinglePasswordAgeInternal(
      WCHAR          const * domctrl,      // in - domain controller to query
      WCHAR          const * computer,     // in - name of computer account
      DWORD                * pwdage        // out- password age in seconds
   )
{
   DWORD                     rc = 0;
   USER_INFO_11            * buf;
   
   rc = NetUserGetInfo(domctrl,computer,11,(LPBYTE*)&buf);

   if (! rc )
   {
      (*pwdage) = buf->usri11_password_age;
      NetApiBufferFree(buf);
   }
   return rc;
}


// ComputerPwdAge worknode
// Retrieves the password age (in seconds) for a computer account in a specified domain
// This can be used to identify defunct computer accounts
// 
// VarSet syntax
// Input:
//       ComputerPasswordAge.Domain:   <DomainName>
//       ComputerPasswordAge.Computer: <ComputerName>
// Output:
//       ComputerPasswordAge.Seconds : <number>

STDMETHODIMP 
   CComputerPwdAge::Process(
      IUnknown             * pWorkItem  // in - varset containing settings
   )
{
   HRESULT                    hr = S_OK;
   IVarSetPtr                 pVarSet = pWorkItem;
   _bstr_t                    domain;
   _bstr_t                    computer;
   DWORD                      age;
   
   domain = pVarSet->get(L"ComputerPasswordAge.Domain");
   computer = pVarSet->get(L"ComputerPasswordAge.Computer");
   if ( computer.length() && domain.length() )
   {
      hr = GetPwdAge(domain,computer,&age);
      if ( SUCCEEDED(hr) )
      {
         pVarSet->put(L"ComputerPasswordAge.Seconds",(LONG)age);
      }
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\recnode.hpp ===
/*---------------------------------------------------------------------------
  File: RecNode.hpp

  Comments: Definition of Membership node object.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 02/15/99 11:18:21

 ---------------------------------------------------------------------------
*/

	
// AcctRepl.h : Declaration of the CAcctRepl

#ifndef __RECNODE_HPP_
#define __RECNODE_HPP_

#include "WorkObj.h"
#include "TARNode.hpp"

class TRecordNode:public TNode
{
   _bstr_t             sMember;
   _bstr_t             sMemberSam;
   _bstr_t             sDN;
   TAcctReplNode     * pNode;
   BOOL                bMemberMoved;

public:
   TRecordNode() { pNode = NULL; bMemberMoved = FALSE; }
   const WCHAR * GetMember() const { return (WCHAR const *)sMember; }
   const WCHAR * GetMemberSam() const { return (WCHAR const *)sMemberSam; }
   const WCHAR * GetDN() const { return (WCHAR const *)sDN; }
   TAcctReplNode * GetARNode() const { return pNode; }
   BOOL          IsMemberMoved() { return bMemberMoved; }

   void SetMember(const WCHAR * pMember) { sMember = pMember; }
   void SetMemberSam(const WCHAR * pMemberSam) { sMemberSam = pMemberSam; }
   void SetDN(const WCHAR * pDN) { sDN = pDN; }
   void SetARNode(TAcctReplNode * p) { pNode = p; }
   void SetMemberMoved(BOOL bVal = TRUE) { bMemberMoved = bVal; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\regtrans.cpp ===
/*---------------------------------------------------------------------------
  File: RegTranslator.cpp

  Comments: Routines for translating security on the registry keys and files 
  that form a user profile.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/12/99 11:11:46

 ---------------------------------------------------------------------------
*/

#include "stdafx.h"

#include "stargs.hpp"
#include "sd.hpp"
#include "SecObj.hpp"   
#include "sidcache.hpp"
#include "sdstat.hpp"
#include "Common.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"   
#include "TReg.hpp"
#include "TxtSid.h"
#include "RegTrans.h"
#include <WinBase.h>
//#import "\bin\McsDctWorkerObjects.tlb"
#import "WorkObj.tlb"
#include "CommaLog.hpp"
#include "GetDcName.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#ifndef STATUS_OBJECT_NAME_NOT_FOUND
#define STATUS_OBJECT_NAME_NOT_FOUND ((NTSTATUS)0xC0000034L)
#endif

extern TErrorDct             err;

#define LEN_SID              200

#define ERROR_PROFILE_TRANSLATION_FAILED_DUE_TO_REPLACE_MODE_WHILE_LOGGED_ON ((DWORD) -1)

typedef UINT (WINAPI* MSINOTIFYSIDCHANGE)(LPCWSTR pOldSid, LPCWSTR pNewSid);

namespace
{

//-----------------------------------------------------------------------------
// CopyKey
//
// Synopsis
// Copies key from old name to new name by creating new key and then copying
// old key contents to new key.
//
// Parameters
// IN pszOld - old key name
// IN pszNew - new key name
//
// Return Value
// Win32 error code.
//-----------------------------------------------------------------------------

DWORD __stdcall CopyKey(PCWSTR pszOld, PCWSTR pszNew)
{
    TRegKey keyOld;

    DWORD dwError = keyOld.OpenRead(pszOld, HKEY_LOCAL_MACHINE);

    if (dwError == ERROR_SUCCESS)
    {
        TRegKey keyNew;
        DWORD dwDisposition;

        dwError = keyNew.Create(pszNew, HKEY_LOCAL_MACHINE, &dwDisposition, KEY_ALL_ACCESS);

        if (dwError == ERROR_SUCCESS)
        {
            //
            // Only copy if new key was created otherwise return
            // an access denied error per installer code.
            //

            if (dwDisposition == REG_CREATED_NEW_KEY)
            {
                dwError = keyNew.HiveCopy(&keyOld);
            }
            else
            {
                dwError = ERROR_ACCESS_DENIED;
            }
        }
    }
    else
    {
        //
        // It is not an error for the old key not to exist.
        //

        if (dwError == ERROR_FILE_NOT_FOUND)
        {
            dwError = ERROR_SUCCESS;
        }
    }

    return dwError;
}


//-----------------------------------------------------------------------------
// AdmtMsiNotifySidChange
//
// Synopsis
// A private implementation of MsiNotifySidChange which renames a key under the
// Microsoft Installer Managed and UserData keys which have the name of the
// user's SID. Note that this implementation is only to be used when the
// MsiNotifySidChange API is not available on the system.
//
// Parameters
// IN pOldSid - old SID
// IN pNewSid - new SID
//
// Return Value
// Win32 error code.
//-----------------------------------------------------------------------------

UINT __stdcall AdmtMsiNotifySidChange(LPCWSTR pOldSid, LPCWSTR pNewSid)
{
    static const _TCHAR KEY_MANAGED[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\Managed");
    static const _TCHAR KEY_USERDATA[] = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Installer\\UserData");

    _bstr_t strManaged(KEY_MANAGED);
    _bstr_t strUserData(KEY_USERDATA);

    //
    // Rename Managed key from old SID to new SID.
    //

    _bstr_t strOldManagedSid = strManaged + _T("\\") + _bstr_t(pOldSid);
    _bstr_t strNewManagedSid = strManaged + _T("\\") + _bstr_t(pNewSid);

    DWORD dwManagedError = CopyKey(strOldManagedSid, strNewManagedSid);

    //
    // Rename UserData key from old SID to new SID.
    //

    _bstr_t strOldUserDataSid = strUserData + _T("\\") + _bstr_t(pOldSid);
    _bstr_t strNewUserDataSid = strUserData + _T("\\") + _bstr_t(pNewSid);

    DWORD dwUserDataError = CopyKey(strOldUserDataSid, strNewUserDataSid);

    DWORD dwError;

    if (dwManagedError != ERROR_SUCCESS)
    {
        dwError = dwManagedError;
    }
    else if (dwUserDataError != ERROR_SUCCESS)
    {
        dwError = dwUserDataError;
    }
    else
    {
        //
        // If both keys were successfully copied then delete old keys.
        //

        TRegKey key;

        if (key.Open(strOldManagedSid, HKEY_LOCAL_MACHINE) == ERROR_SUCCESS)
        {
            key.HiveDel();
            key.Close();

            if (key.Open(strManaged, HKEY_LOCAL_MACHINE) == ERROR_SUCCESS)
            {
                key.SubKeyDel(pOldSid);
                key.Close();
            }
        }

        if (key.Open(strOldUserDataSid, HKEY_LOCAL_MACHINE) == ERROR_SUCCESS)
        {
            key.HiveDel();
            key.Close();

            if (key.Open(strUserData, HKEY_LOCAL_MACHINE) == ERROR_SUCCESS)
            {
                key.SubKeyDel(pOldSid);
                key.Close();
            }
        }

        dwError = ERROR_SUCCESS;
    }

    return dwError;
}

}


DWORD 
   TranslateRegHive(
      HKEY                     hKeyRoot,            // in - root of registry hive to translate
      const LPWSTR             keyName,             // in - name of registry key
      SecurityTranslatorArgs * stArgs,              // in - translation settings
      TSDRidCache            * cache,               // in - translation table
      TSDResolveStats        * stat,                // in - stats on items modified
      BOOL                     bWin2K               // in - flag, whether the machine is Win2K
   )
{
   DWORD                       rc = 0;

   // Translate the permissions on the root key
   TRegSD                      sd(keyName,hKeyRoot);

   
   if ( sd.HasDacl() )
   {
      TSD * pSD = sd.GetSecurity();
      sd.ResolveSD(stArgs,stat,regkey ,NULL);
   }
   // Recursively process any subkeys
   int                       n = 0;
   FILETIME                  writeTime;
   WCHAR                     name[MAX_PATH];
   DWORD                     lenName = DIM(name);
   WCHAR                     fullName[2000];
   HKEY                      hKey;

   do 
   {
      if (stArgs->Cache()->IsCancelled())
      {
        break;
      }
      lenName = DIM(name);
      rc = RegEnumKeyEx(hKeyRoot,n,name,&lenName,NULL,NULL,NULL,&writeTime);
      if ( rc && rc != ERROR_MORE_DATA )
      {
         if (rc == ERROR_NO_MORE_ITEMS)
            rc = ERROR_SUCCESS;
         break;
      }
      
      swprintf(fullName,L"%s\\%s",keyName,name);
      // Open the subkey
      rc = RegCreateKeyEx(hKeyRoot,name,0,L"",REG_OPTION_BACKUP_RESTORE,KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,NULL,&hKey,NULL);
      
      if (! rc )
      {
         // Process the subkey
         TranslateRegHive(hKey,fullName,stArgs,cache,stat,bWin2K);   
         RegCloseKey(hKey);
      }
      else
      {
         if  ( (rc != ERROR_FILE_NOT_FOUND) && (rc != ERROR_INVALID_HANDLE) )
         {
            err.SysMsgWrite(ErrS,rc,DCT_MSG_REG_KEY_OPEN_FAILED_SD,fullName,rc);
         }
      }
      n++;

   } while ( rc == ERROR_SUCCESS || rc == ERROR_MORE_DATA);
   if ( rc != ERROR_SUCCESS && rc != ERROR_NO_MORE_ITEMS && rc != ERROR_FILE_NOT_FOUND && rc != ERROR_INVALID_HANDLE )
   {
      err.SysMsgWrite(ErrS,rc,DCT_MSG_REGKEYENUM_FAILED_D,rc);
   }
   return rc;
}

DWORD 
   TranslateRegistry(
      WCHAR            const * computer,        // in - computername to translate, or NULL
      SecurityTranslatorArgs * stArgs,          // in - translation settings
      TSDRidCache            * cache,           // in - translation account mapping
      TSDResolveStats        * stat             // in - stats for items examined and modified
   )
{
    DWORD                       rc = 0;
    WCHAR                       comp[LEN_Computer];

    if (!stArgs->Cache()->IsCancelled())
    {
        if ( ! computer )
        {
          comp[0] = 0;
        }
        else
        {
          safecopy(comp,computer);
        }

        MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
        TRegKey                    hKey;
        DWORD                      verMaj,verMin,verSP;
        BOOL                       bWin2K = TRUE;  // assume win2k unless we're sure it's not

        // get the OS version - we need to know the OS version because Win2K can fail when registry keys 
        // have many entries
        HRESULT hr = pAccess->raw_GetOsVersion(_bstr_t(comp),&verMaj,&verMin,&verSP);
        if ( SUCCEEDED(hr) )
        {
          if ( verMaj < 5 )
             bWin2K = FALSE;
        }


        err.MsgWrite(0,DCT_MSG_TRANSLATING_REGISTRY);

        //
        // construct a computer name used for reporting error message
        //   if computer is defined, use it; otherwise, use the local computer name
        //

        WCHAR szComputerName[LEN_Computer];

        if (computer)
        {
            wcsncpy(szComputerName, computer, LEN_Computer);
            szComputerName[LEN_Computer - 1] = L'\0';
        }
        else
        {
            DWORD dwSize = LEN_Computer;

            if (!GetComputerName(szComputerName, &dwSize))
            {
                szComputerName[0] = L'\0';
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_CLASSES_ROOT,computer);
            if ( ! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_CLASSES_ROOT",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_CLASSES_ROOT",szComputerName,rc);
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_LOCAL_MACHINE,computer);
            if ( ! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_LOCAL_MACHINE",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_LOCAL_MACHINE",szComputerName,rc);
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_USERS,computer);
            if (! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_USERS",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_USERS",szComputerName,rc);
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_PERFORMANCE_DATA,computer);
            if ( ! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_PERFORMANCE_DATA",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_PERFORMANCE_DATA",szComputerName,rc);
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_CURRENT_CONFIG,computer);
            if ( ! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_CURRENT_CONFIG",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_CURRENT_CONFIG",szComputerName,rc);
            }
        }

        if (!stArgs->Cache()->IsCancelled())
        {
            rc = hKey.Connect(HKEY_DYN_DATA,computer);
            if ( ! rc )
            {
              rc = TranslateRegHive(hKey.KeyGet(),L"HKEY_DYN_DATA",stArgs,cache,stat,bWin2K);
              hKey.Close();
            }
            else
            {
                err.SysMsgWrite(ErrE,rc,DCT_MSG_UNABLE_TO_CONNECT_REGISTRY_SSD,L"HKEY_DYN_DATA",szComputerName,rc);
            }
        }
    }

    if (stArgs->Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_REGISTRY);

    return rc;
}


// -----------------------------------------------------------------------------
// Function:    GetUsrLocalAppDataPath
//
// Synopsis:    Given a registry handle to a user hive, finds
//              the local appdata path
//
// Arguments:
//   hKey       a registry handle to a loaded user hive
//
// Returns:     Returns a _bstr_t which contains the path to local appdata.
//              If the path is not found, an empty _bstr_t is returned.
// -----------------------------------------------------------------------------

_bstr_t GetUsrLocalAppDataPath(HKEY hKey)
{
    TRegKey usrHive;
    DWORD rc;
    WCHAR usrLocalAppDataPath[MAX_PATH] = L"";
    DWORD dwValueType;
    DWORD dwValueLen = sizeof(usrLocalAppDataPath);
    
    rc = usrHive.Open(L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders", hKey);

    if (rc == ERROR_SUCCESS)
    {
        rc = usrHive.ValueGet(L"Local AppData",
                              (void*)usrLocalAppDataPath,
                              &dwValueLen,
                              &dwValueType);
        if (!rc)
        {
            if (dwValueType != REG_EXPAND_SZ)
                rc = ERROR_FILE_NOT_FOUND;
            else
            {
                // make sure the path is NULL terminated
                usrLocalAppDataPath[DIM(usrLocalAppDataPath)-1] = L'\0';
            }
        }
    }

    _bstr_t bstrPath;

    try
    {
        if (!rc)
            bstrPath = usrLocalAppDataPath;
    }
    catch (_com_error& ce)
    {
    }
            
    return bstrPath;    
}

DWORD
    TranslateUserProfile(
        WCHAR            const * strSrcSid,         // in - the string for the registry key name under HKU
                                                   // in case the profile is already loaded
        WCHAR            const * profileName,       // in - name of file containing user profile
        SecurityTranslatorArgs * stArgs,            // in - translation settings
        TSDRidCache            * cache,             // in - translation table
        TSDResolveStats        * stat,              // in - stats on items modified
        WCHAR                  * sSourceName,       // in - Source account name
        WCHAR                  * sSourceDomainName,  // in - Source domain name
        BOOL                   * pbAlreadyLoaded,  // out - indicate whether the profile is already loaded
        _bstr_t&                 bstrUsrLocalAppDataPath,  // out - local appdata path
        BOOL                     bFindOutUsrLocalAppDataPath,  // in - indicates whether we need local appdata path or not
        BOOL                     bIsForUserHive,         // in - indicates whether it is for user hive or not
                                                         // TRUE -- user hive  FALSE -- user class hive
        BOOL                     bHasRoamingPart       // in - whether local profile has roaming counterpart
   )
{
    DWORD                       rc = 0;
    WCHAR                       oldName[MAX_PATH];
    WCHAR                       newName[MAX_PATH];
    WCHAR                       otherName[MAX_PATH];
    HKEY                        hKey;
    HRESULT                     hr = S_OK;
    BOOL                        bWin2K = TRUE;
    MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr            pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));

    safecopy(oldName,profileName);
    safecopy(newName,profileName);
    UStrCpy(newName+UStrLen(newName),".temp");
    safecopy(otherName,profileName);
    UStrCpy(otherName + UStrLen(otherName),".premigration");
      
    // check the OS version of the computer
    // if UNC name is specified, get the computer name
    if ( profileName[0] == L'\\' && profileName[1] == L'\\' )
    {
        bWin2K = TRUE; // if the profile is specified in UNC format (roaming profile) it can be used
        // from multiple machines.  There is no guarantee that the profile will not be loaded on a win2000 machine
    }
    else
    {
        DWORD                     verMaj;
        DWORD                     verMin;
        DWORD                     verSP;
        HRESULT                   hr = pAccess->raw_GetOsVersion(_bstr_t(L""),&verMaj,&verMin,&verSP);

        if ( SUCCEEDED(hr) )
        {
            if ( verMaj < 5 )
            {
                bWin2K = FALSE;
            }
        }
    }

    BOOL bRegAlreadyLoaded = TRUE;
    BOOL bSkipLoadTranslate = FALSE;

    // If it is local profile translation for a user with a roaming
    // profile, we cannot just load ntuser.dat to see if the user is 
    // logged on because if the user is not logged on the timestamp
    // will be changed upon unload.  Therefore, we need to make a copy
    // of ntuser.dat, load the new registry hive, read the path,
    // unload the hive and delete the copied hive
    if (strSrcSid && bHasRoamingPart && bIsForUserHive)
    {
        bSkipLoadTranslate = TRUE; // skip loading and translating ntuser.dat
        BOOL bSuccess = FALSE;     // indicate whether we successfully read local appdata path

        // we use ntuser.dat.admt for the copy
        safecopy(newName,profileName);
        UStrCpy(newName+UStrLen(newName),".admt");

        // we need to delete ntuser.dat.admt.log later on
        safecopy(otherName,profileName);
        UStrCpy(otherName + UStrLen(otherName),".admt.log");

        // try to open ntuser.dat with readonly
        // to test whether the file is loaded or not
        HANDLE hProfile = CreateFile(profileName,
                                      GENERIC_READ,
                                      FILE_SHARE_READ,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

        if (hProfile == INVALID_HANDLE_VALUE)
        {
            rc = GetLastError();
        }
        else
        {
            CloseHandle(hProfile);
        }

        // If rc == ERROR_SHARING_VIOLATION, the user might be logged on
        // so let it follow the logic to check HKEY_USERS\<strSrcSid>.
        // Otherwise, the user cannot be logged on.  We do the following
        // logic.
        if (rc != ERROR_SHARING_VIOLATION)
        {
            // the registry cannot be loaded at this moment
            if (pbAlreadyLoaded)
                *pbAlreadyLoaded = FALSE;

            // if we don't need to find out local appdata path
            // we don't need to do anything more with the registry hive
            if (!bFindOutUsrLocalAppDataPath)
                return ERROR_SUCCESS;
            
            rc = ERROR_SUCCESS;  // reset rc
            
            // we try to copy ntuser.dat to ntuser.dat.admt
            if (!CopyFile(profileName, newName, FALSE))
            {
                rc = GetLastError();
            }

            // if we're able to copy the file,
            // the user is not logged on
            if (rc == ERROR_SUCCESS)
            {
                rc = RegLoadKey(HKEY_USERS,L"OnePointTranslation",newName);
                if (rc == ERROR_SUCCESS)
                {
                    rc = RegOpenKeyEx(HKEY_USERS,
                                      L"OnePointTranslation",
                                      0,
                                      KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,
                                      &hKey);
                    if (rc == ERROR_SUCCESS)
                    {
                        bSuccess = TRUE;
                        bstrUsrLocalAppDataPath = GetUsrLocalAppDataPath(hKey);
                        RegCloseKey(hKey);
                    }
                    RegUnLoadKey(HKEY_USERS,L"OnePointTranslation");
                }
                if (!DeleteFile(newName) || !DeleteFile(otherName))
                {
                    err.MsgWrite(ErrW,
                                  DCT_MSG_PROFILE_TRANSLATION_UNABLE_TO_DELETE_TEMP_USER_HIVE_S,
                                  sSourceName);
                }
            }

            // if unable to read Local AppData, log an error
            if (!bSuccess)
            {
                err.SysMsgWrite(ErrE,
                                 rc,
                                 DCT_MSG_PROFILE_TRANSLATION_UNABLE_TO_RETRIEVE_USRCLASS_DAT_PATH_SD,
                                 sSourceName,
                                 rc);
            }

            return ERROR_SUCCESS;
        }
    }
    else
    {
        rc = RegLoadKey(HKEY_USERS,L"OnePointTranslation",profileName);
    }
    
    if ( ! rc && !bSkipLoadTranslate )
    {
        bRegAlreadyLoaded = FALSE;

        // Open the key
        rc = RegOpenKeyEx(HKEY_USERS,L"OnePointTranslation",0,KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,&hKey);
        if ( ! rc )
        {
            if (bFindOutUsrLocalAppDataPath)
                bstrUsrLocalAppDataPath = GetUsrLocalAppDataPath(hKey);

            // Process the registry hive 
            rc = TranslateRegHive(hKey,L"",stArgs,cache,stat,bWin2K);
            // Unload the registry hive
            if ( ! stArgs->NoChange() )
            {
                DeleteFile(newName);
                if (bIsForUserHive)
                    // this is for user hive only
                    hr = UpdateMappedDrives(sSourceName, sSourceDomainName, L"OnePointTranslation");
                rc = RegSaveKey(hKey,newName,NULL);
            }
            else
            {
                rc = 0;
            }
            if ( rc )
            {
                err.SysMsgWrite(ErrS,rc,DCT_MSG_SAVE_HIVE_FAILED_SD,newName,rc);
            }
            RegCloseKey(hKey);
        }
        rc = RegUnLoadKey(HKEY_USERS,L"OnePointTranslation");
        if ( rc )
        {
            err.SysMsgWrite(ErrE,rc,DCT_MSG_KEY_UNLOADKEY_FAILED_SD,profileName,rc);
        }
    }
    else if (rc == ERROR_SHARING_VIOLATION && strSrcSid)
    {
        // this profile could be loaded already, let's look in HK_USERS with the source sid string
        // note localRc is used to indicate whether the user is logged on or not and should not
        // be reported to the user
        DWORD localRc = RegOpenKeyEx(HKEY_USERS,strSrcSid,0,KEY_ALL_ACCESS | READ_CONTROL | ACCESS_SYSTEM_SECURITY,&hKey);
        if (localRc == ERROR_SUCCESS)
        {
            //
            // this means the user is logged on
            //

            // if the translation mode is REPLACE and the user is still logged on,
            // we try to switch to ADD mode
            if (stArgs->TranslationMode() == REPLACE_SECURITY
                && stArgs->AllowingToSwitchFromReplaceToAddModeInProfileTranslation())
            {
                stArgs->SetTranslationMode(ADD_SECURITY);
                err.MsgWrite(ErrW,
                              DCT_MSG_PROFILE_TRANSLATION_SWITCH_TO_ADD_MODE_FOR_LOGGED_ON_USER_S,
                              sSourceName);
            }

            if (stArgs->TranslationMode() == REPLACE_SECURITY)
            {
                // we cannot perform translation in REPLACE mode if the user is logged on
                rc = ERROR_PROFILE_TRANSLATION_FAILED_DUE_TO_REPLACE_MODE_WHILE_LOGGED_ON;
            }
            else
            {
                if (bFindOutUsrLocalAppDataPath)
                    bstrUsrLocalAppDataPath = GetUsrLocalAppDataPath(hKey);
                rc = TranslateRegHive(hKey,L"",stArgs,cache,stat,bWin2K);
                if (bIsForUserHive)
                    // this needs to be performed when the registry is already loaded
                    // and is for user hive only
                    UpdateMappedDrives(sSourceName,
                                         sSourceDomainName,
                                         const_cast<WCHAR*>(strSrcSid));
            }
        }
        else
        {
            err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_LOAD_FAILED_SD,profileName,rc);
        }
        RegCloseKey(hKey);
    }
    else
    {
        err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_LOAD_FAILED_SD,profileName,rc);
    }

    if (pbAlreadyLoaded)
        *pbAlreadyLoaded = bRegAlreadyLoaded;

    // the following needs to be done only when the profile is loaded by us not already loaded
    // due to logon
    // in case it is for local profile translation and the user has roaming profile as well
    // we will skip this part as well
    if ( ! rc && !bRegAlreadyLoaded && !(strSrcSid && bHasRoamingPart))
    {
        if (! stArgs->NoChange() )
        {
            // Switch out the filenames
            if ( MoveFileEx(oldName,otherName,MOVEFILE_REPLACE_EXISTING) )
            {
                if ( ! MoveFileEx(newName,oldName,0) )
                {
                    rc = GetLastError();
                    err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,newName,oldName,rc);
                }
            }
            else
            {
                rc = GetLastError();
                if ( rc == ERROR_ACCESS_DENIED )
                { 
                    // we do not have access to the directory
                    // temporarily grant ourselves access
                    // Set NTFS permissions for the results directory
                    WCHAR                     dirName[LEN_Path];

                    safecopy(dirName,oldName);
                    WCHAR * slash = wcsrchr(dirName,L'\\');
                    if ( slash )
                    {
                        (*slash) = 0;
                    }

                    TFileSD                fsdDirBefore(dirName);
                    TFileSD                fsdDirTemp(dirName);
                    TFileSD                fsdDatBefore(oldName);
                    TFileSD                fsdDatTemp(oldName);
                    TFileSD                fsdNewBefore(newName);
                    TFileSD                fsdNewTemp(newName);
                    BOOL                   dirChanged = FALSE;
                    BOOL                   datChanged = FALSE;
                    BOOL                   newChanged = FALSE;

                    // Temporarily reset the permissions on the directory and the appropriate files
                    if ( fsdDirTemp.GetSecurity() != NULL )
                    {
                        TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                        GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                        PACL             acl = NULL;

                        fsdDirTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
                        if (acl)
                        {
                            fsdDirTemp.GetSecurity()->SetDacl(acl,TRUE);

                            fsdDirTemp.WriteSD();
                            dirChanged = TRUE;
                        }
                    }

                    if ( fsdDatTemp.GetSecurity() != NULL )
                    {
                        TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                        GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                        PACL             acl = NULL;

                        fsdDatTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
                        if (acl)
                        {
                            fsdDatTemp.GetSecurity()->SetDacl(acl,TRUE);

                            fsdDatTemp.WriteSD();
                            datChanged = TRUE;
                        }
                    }

                    if ( fsdNewTemp.GetSecurity() != NULL )
                    {
                        TACE             ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,
                        GetWellKnownSid(stArgs->IsLocalSystem() ?  7/*SYSTEM*/ : 1/*ADMINISTRATORS*/));
                        PACL             acl = NULL;

                        fsdNewTemp.GetSecurity()->ACLAddAce(&acl,&ace,0);
                        if (acl)
                        {
                            fsdNewTemp.GetSecurity()->SetDacl(acl,TRUE);

                            fsdNewTemp.WriteSD();
                            newChanged = TRUE;
                        }
                    }
                    rc = 0;
                    // Now retry the operations
                    if ( MoveFileEx(oldName,otherName,MOVEFILE_REPLACE_EXISTING) )
                    {
                        if ( ! MoveFileEx(newName,oldName,0) )
                        {
                            rc = GetLastError();
                            err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,newName,oldName,rc);
                        }
                    }
                    else
                    {
                        rc = GetLastError();
                        err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,oldName,otherName,rc);
                    }
                    // now that we're done, set the permissions back to what they were
                    if ( dirChanged )
                    {
                        fsdDirBefore.Changed(TRUE);
                        fsdDirBefore.WriteSD();
                    }   
                    if ( datChanged )
                    {
                        fsdDatBefore.Changed(TRUE);
                        fsdDatBefore.WriteSD();
                    }
                    if ( newChanged )
                    {
                        fsdNewBefore.Changed(TRUE);
                        fsdNewBefore.WriteSD();
                    }
                }
                else
                {
                    err.SysMsgWrite(ErrS,rc,DCT_MSG_RENAME_DIR_FAILED_SSD,oldName,otherName,rc);
                }
            }
        }
    }
    return rc;
}

DWORD 
   UpdateProfilePermissions(
      WCHAR          const   * path,              // in - path for directory to update
      SecurityTranslatorArgs * globalArgs,        // in - path for overall job
      TRidNode               * pNode              // in - account to translate
   )
{
   DWORD                       rc = 0;
   SecurityTranslatorArgs      localArgs;
   TSDResolveStats             stat(localArgs.Cache());
   BOOL                        bUseMapFile = globalArgs->UsingMapFile();

   // set-up the parameters for the translation

   localArgs.Cache()->CopyDomainInfo(globalArgs->Cache());
   localArgs.Cache()->ToSorted();
   if (!bUseMapFile)
   {
      localArgs.SetUsingMapFile(FALSE);
      localArgs.Cache()->InsertLast(pNode->GetAcctName(),pNode->SrcRid(),pNode->GetTargetAcctName(),pNode->TgtRid(),pNode->Type());
   }
   else
   {
      localArgs.SetUsingMapFile(TRUE);
      localArgs.Cache()->InsertLastWithSid(pNode->GetAcctName(),pNode->GetSrcDomSid(),pNode->GetSrcDomName(),pNode->SrcRid(),
                                           pNode->GetTargetAcctName(),pNode->GetTgtDomSid(),pNode->GetTgtDomName(),pNode->TgtRid(),pNode->Type());
   }
   localArgs.TranslateFiles(TRUE);
   localArgs.SetTranslationMode(globalArgs->TranslationMode());
   localArgs.SetWriteChanges(!globalArgs->NoChange());
   localArgs.PathList()->AddPath(const_cast<WCHAR*>(path),0);
   localArgs.SetLogging(globalArgs->LogSettings());

   rc = ResolveAll(&localArgs,&stat);   

   return rc;
}


// if the specified node is a normal share, this attempts to convert it to a path
// using the administrative shares
void 
   BuildAdminPathForShare(
      WCHAR       const * sharePath,         // in - 
      WCHAR             * adminShare
   )
{
   // if all else fails, return the same name as specified in the node
   UStrCpy(adminShare,sharePath);

   SHARE_INFO_502       * shInfo = NULL;
   DWORD                  rc = 0;
   WCHAR                  shareName[LEN_Path];
   WCHAR                * slash = NULL;
   WCHAR                  server[LEN_Path];

   safecopy(server,sharePath);

   // split out just the server name
   slash = wcschr(server+3,L'\\');
   if ( slash )
   {
      (*slash) = 0;
   }

   // now get just the share name
   UStrCpy(shareName,sharePath + UStrLen(server) +1);
   slash = wcschr(shareName,L'\\');
   if ( slash )
      *slash = 0;


   rc = NetShareGetInfo(server,shareName,502,(LPBYTE*)&shInfo);
   if ( ! rc )
   {
      if ( *shInfo->shi502_path )
      {
         // build the administrative path name for the share
         UStrCpy(adminShare,server);
         UStrCpy(adminShare + UStrLen(adminShare),L"\\");
         UStrCpy(adminShare + UStrLen(adminShare),shInfo->shi502_path);
         WCHAR * colon = wcschr(adminShare,L':');
         if ( colon )
         {
            *colon = L'$';
            UStrCpy(adminShare + UStrLen(adminShare),L"\\");
            UStrCpy(adminShare + UStrLen(adminShare),slash+1);

         }
         else
         {
            // something went wrong -- revert to the given path
            UStrCpy(adminShare,sharePath);
         }

      }
      NetApiBufferFree(shInfo);
   }
}
                  
DWORD
   CopyProfileDirectoryAndTranslate(
      WCHAR          const   * strSrcSid,         //  in - the source sid string
      WCHAR          const   * directory,         // in - directory path for profile 
      WCHAR                  * directoryOut,      // out- new Profile Path (including environment variables)
      TRidNode               * pNode,             // in - node for account being translated
      SecurityTranslatorArgs * stArgs,            // in - translation settings 
      TSDResolveStats        * stat,               // in - stats on items modified
      BOOL                     bHasRoamingPart    // in - whether local profile has roaming counterpart
   )
{
   DWORD                       rc = 0;
   WCHAR                       fullPath[MAX_PATH];
   WCHAR                       targetPath[MAX_PATH];
   WCHAR                       profileName[MAX_PATH];
   int                         profileNameBufferSize = sizeof(profileName)/sizeof(profileName[0]);
   WCHAR                       targetAcctName[MAX_PATH];
   WCHAR                       sourceDomName[MAX_PATH];
   HANDLE                      hFind;
   WIN32_FIND_DATA             fDat;   

   rc = ExpandEnvironmentStrings(directory,fullPath,DIM(fullPath));
   if ( !rc )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_EXPAND_STRINGS_FAILED_SD,directory,rc);
   }
   else if (rc > MAX_PATH)
   {
      // we don' t have large enough buffer to hold it
      rc = ERROR_INSUFFICIENT_BUFFER;
      err.SysMsgWrite(ErrE,rc,DCT_MSG_EXPAND_STRINGS_FAILED_SD,directory,rc);
   }
   else
   {
      // Create a new directory for the target profile
       // Get the account name for target user
      wcscpy(targetAcctName, pNode->GetTargetAcctName());
      if ( wcslen(targetAcctName) == 0 )
      {
         // if target user name not specified then use the source name.
         wcscpy(targetAcctName, pNode->GetAcctName());
      }
      
      //stArgs->SetTranslationMode(ADD_SECURITY);

      // We are changing our stratergy. We are not going to copy the profile directories anymore.
      // we will be reACLing the directories and the Registry instead.
      BuildAdminPathForShare(fullPath,targetPath);

      wcscpy(sourceDomName, const_cast<WCHAR*>(stArgs->Cache()->GetSourceDomainName()));
         //if we are using a sID mapping file, try to get the src domain name from this node's information
      wcscpy(sourceDomName, pNode->GetSrcDomName());

      BOOL bRegAlreadyLoaded;
      BOOL bNeedToTranslateClassHive = FALSE;
      _bstr_t bstrUsrLocalAppDataPath;

      // for the local profile case, we determine whether it is necessary to translate
      // user class hive as this is only present on win2k or later
      if (strSrcSid)
      {
         // check OS version
         MCSDCTWORKEROBJECTSLib::IAccessCheckerPtr pAccess(__uuidof(MCSDCTWORKEROBJECTSLib::AccessChecker));
         DWORD                     verMaj;
         DWORD                     verMin;
         DWORD                     verSP;
         HRESULT                   hr = pAccess->raw_GetOsVersion(_bstr_t(L""),&verMaj,&verMin,&verSP);
  
         // we will handle usrclass.dat if the OS is Windows 2000 or above or we cannot determine the OS ver
         if (FAILED(hr) || (SUCCEEDED(hr) && verMaj >= 5))
         {
            bNeedToTranslateClassHive = TRUE;
         }
      }
        
      // Look for profile files in the target directory
      // look for NTUser.MAN
      _snwprintf(profileName,profileNameBufferSize,L"%s\\NTUser.MAN",targetPath);
      profileName[profileNameBufferSize - 1] = L'\0';
      hFind = FindFirstFile(profileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         err.MsgWrite(0,DCT_MSG_TRANSLATING_NTUSER_MAN_S,targetAcctName);
         rc = TranslateUserProfile(strSrcSid,
                                      profileName,
                                      stArgs,
                                      stArgs->Cache(),
                                      stat,
                                      pNode->GetAcctName(),
                                      sourceDomName,
                                      &bRegAlreadyLoaded,
                                      bstrUsrLocalAppDataPath,
                                      bNeedToTranslateClassHive,  // whether we need local appdata folder path or not
                                      TRUE,                        // for user hive
                                      bHasRoamingPart
                                      );
         FindClose(hFind);
      }
      else
      {
         // check for NTUser.DAT
         _snwprintf(profileName,profileNameBufferSize,L"%s\\NTUser.DAT",targetPath);
         profileName[profileNameBufferSize - 1] = L'\0';
         hFind = FindFirstFile(profileName,&fDat);
         if ( hFind != INVALID_HANDLE_VALUE )
         {
            err.MsgWrite(0,DCT_MSG_TRANSLATING_NTUSER_BAT_S,targetAcctName);
            rc = TranslateUserProfile(strSrcSid,
                                         profileName,
                                         stArgs,
                                         stArgs->Cache(),
                                         stat,
                                         pNode->GetAcctName(),
                                         sourceDomName,
                                         &bRegAlreadyLoaded,
                                         bstrUsrLocalAppDataPath,
                                         bNeedToTranslateClassHive,  // whether we need local appdata folder path or not
                                         TRUE,                        // for user hive
                                         bHasRoamingPart
                                         );
            FindClose(hFind);
         }
         else
         {
            err.MsgWrite(ErrS,DCT_MSG_PROFILE_REGHIVE_NOT_FOUND_SS,targetAcctName,targetPath);            
            rc = 2;  // File not found
         }
      }
      
      if (!rc && bNeedToTranslateClassHive && !bRegAlreadyLoaded)
      {
         //
         // fix up usrclass.dat if necessary
         //   1.  we only do this on Windows 2000 or above because there is no usrclass.dat on NT4
         //   2.  we only do this if ntuser.dat is not loaded.  If it has been loaded, the
         //       HKU\<sid>_Classes has been translated as HKU\<sid>\Software\Classes and
         //       will be written to usrclass.dat when the user logs off
         //
         if (bstrUsrLocalAppDataPath.length() == 0)
            rc = ERROR_FILE_NOT_FOUND;

         if (!rc)
         {
            // construct the usrclass.dat path
            // it is under Microsoft\Windows of the local appdata path
            WCHAR* pszUsrLocalAppDataPath = bstrUsrLocalAppDataPath;
            WCHAR* pszUserProfileVariable = L"%USERPROFILE%";
            int varlen = wcslen(pszUserProfileVariable);
            WCHAR* pszUsrClassHive = L"microsoft\\windows\\usrclass.dat";
            

            // check whether the path starts with %USERPROFILE%
            if (!UStrICmp(pszUsrLocalAppDataPath, pszUserProfileVariable, varlen))
            {
               // since we are not under the user's security context, we cannot
               // expand %USERPROFILE% variable
               // however, we already know user's profile directory (targetPath) so we can take the
               // rest of "local appdata" path and add it to targetPath
               pszUsrLocalAppDataPath += varlen;
               _snwprintf(profileName,profileNameBufferSize,L"%s%s\\%s",targetPath,pszUsrLocalAppDataPath,pszUsrClassHive);
               profileName[profileNameBufferSize - 1] = L'\0';
            }
            else
            {
               // otherwise, use the path directly
               _snwprintf(profileName,profileNameBufferSize,L"%s\\%s",pszUsrLocalAppDataPath,pszUsrClassHive);
               profileName[profileNameBufferSize - 1] = L'\0';
            }

            hFind = FindFirstFile(profileName,&fDat);
            if (hFind != INVALID_HANDLE_VALUE)
            {
               FindClose(hFind);
               _bstr_t strSrcSidClasses;
               try
               {
                  strSrcSidClasses = strSrcSid;
                  strSrcSidClasses += L"_Classes";
               }
               catch (_com_error& ce)
               {
                  rc = ERROR_OUTOFMEMORY;
               }
   
               if (rc == ERROR_SUCCESS)
                  rc = TranslateUserProfile(strSrcSidClasses,
                                               profileName,
                                               stArgs,
                                               stArgs->Cache(),
                                               stat,
                                               pNode->GetAcctName(),
                                               sourceDomName,
                                               NULL,
                                               _bstr_t(),
                                               FALSE,                  // don't need local appdata folder path
                                               FALSE,                  // for user class hive
                                               FALSE      // usrclass.dat does not have roaming counterpart
                                               );
            }
            else
                rc = GetLastError();
          }
  
          if (rc != ERROR_SUCCESS)
             err.MsgWrite(ErrE,DCT_MSG_PROFILE_CANNOT_TRANSLATE_CLASSHIVE_SD,targetAcctName,rc);
      }

      if (!rc)
         rc = UpdateProfilePermissions(targetPath,stArgs,pNode);

      wcscpy(directoryOut, fullPath);
   }
   return rc;
}

DWORD 
   TranslateLocalProfiles(
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
    DWORD   rc = 0;
    WCHAR   keyName[MAX_PATH];
    DWORD   lenKeyName = DIM(keyName);   
    TRegKey keyProfiles;
    BOOL    bUseMapFile = stArgs->UsingMapFile();

    // output this information only if the translation mode is REPLACE
    if (stArgs->TranslationMode() == REPLACE_SECURITY)
    {
        if (stArgs->AllowingToSwitchFromReplaceToAddModeInProfileTranslation())
        {
            err.MsgWrite(0,DCT_MSG_PROFILE_TRANSLATION_ALLOW_SWITCHING_FROM_REPLACE_TO_ADD);
        }
        else
        {
            err.MsgWrite(0,DCT_MSG_PROFILE_TRANSLATION_DISALLOW_SWITCHING_FROM_REPLACE_TO_ADD);
        }
    }
    
    if (!stArgs->Cache()->IsCancelled())
    {
        // find out the whether the system sets the policy to disallow the roaming profile
        TRegKey policyKey;
        BOOL noRoamingProfile = FALSE;  // first, we assume system allows roaming profile

        // system disallows roaming profile if SOFTWARE\Policies\Microsoft\Windows\System has a REG_DWORD value
        // LocalProfile and it is set to 1
        rc = policyKey.Open(L"SOFTWARE\\Policies\\Microsoft\\Windows\\System",HKEY_LOCAL_MACHINE);
        if (rc == ERROR_SUCCESS)
        {
            DWORD keyValue;
            DWORD keyValueType;
            DWORD keyValueLen = sizeof(keyValue);
            rc = policyKey.ValueGet(L"LocalProfile",(void *)&keyValue,&keyValueLen,&keyValueType);
            // make sure the value exists and it is REG_DWORD
            if (rc == ERROR_SUCCESS && keyValueType == REG_DWORD)
            {
                // now check whether it is set to 1; if it is, no roaming profile is allowed
                if (keyValue == 1)
                    noRoamingProfile = TRUE;
            }
            policyKey.Close();
        }

        rc = keyProfiles.Open(L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList",HKEY_LOCAL_MACHINE);

        if ( ! rc )
        {
            // get the number of subkeys
            // enumerate the subkeys
            DWORD                    ndx;
            DWORD                    nSubKeys = 0;

            rc = RegQueryInfoKey(keyProfiles.KeyGet(),NULL,0,NULL,&nSubKeys,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
            if ( ! rc )
            {
                // construct a list containing the sub-keys
                PSID                * pSids = NULL;
                pSids = new PSID[nSubKeys];
                if(!pSids)
                {
                    rc = ERROR_OUTOFMEMORY;
                    err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_ENTRY_TRANSLATE_FAILED,rc);
                    return rc;
                }

                for ( ndx = nSubKeys - 1 ; (long)ndx >= 0 ; ndx-- ) 
                { 
                    rc = keyProfiles.SubKeyEnum(ndx,keyName,lenKeyName);

                    if ( rc )
                        break;

                    pSids[ndx] = SidFromString(keyName);

                }
                if ( ! rc )
                {
                    //
                    // Attempt to load MsiNotifySidChange API for translating Installer related registry keys.
                    //

                    MSINOTIFYSIDCHANGE MsiNotifySidChange = NULL;
                    HMODULE hMsiModule = LoadLibrary(L"msi.dll");

                    if (hMsiModule)
                    {
                        MsiNotifySidChange = (MSINOTIFYSIDCHANGE) GetProcAddress(hMsiModule, "MsiNotifySidChangeW");
                    }

                    //
                    // process each profile
                    //
                    
                    // first record the translation mode so that we can switch
                    // from replace to add mode if needed
                    DWORD translationMode = stArgs->TranslationMode();
                    for ( ndx = 0 ; ndx < nSubKeys && !stArgs->Cache()->IsCancelled(); ndx++ )
                    {
                        // everytime we start with the original translation mode
                        stArgs->SetTranslationMode(translationMode);
                        do // once  
                        { 
                            if ( ! pSids[ndx] )
                                continue;
                            // see if this user needs to be translated
                            TRidNode  * pNode = NULL;
                            if (!bUseMapFile)
                                pNode = (TRidNode*)cache->Lookup(pSids[ndx]);
                            else
                                pNode = (TRidNode*)cache->LookupWODomain(pSids[ndx]);

                            if ( pNode == (TRidNode *)-1 )
                                pNode = NULL;

                            if ( pNode && pNode->IsValidOnTgt() )  // need to translate this one
                            {
                                PSID                 pSidTgt = NULL;
                                WCHAR                strSourceSid[200];
                                WCHAR                strTargetSid[200];
                                DWORD                dimSid = DIM(strSourceSid);
                                TRegKey              srcKey;
                                TRegKey              tgtKey;
                                DWORD                disposition;
                                WCHAR                keyPath[MAX_PATH];
                                WCHAR                targetPath[MAX_PATH];
                                DWORD                lenValue;
                                DWORD                typeValue;

                                if (!bUseMapFile)
                                    pSidTgt = cache->GetTgtSid(pSids[ndx]);
                                else
                                    pSidTgt = cache->GetTgtSidWODomain(pSids[ndx]);
                                if(!GetTextualSid(pSids[ndx],strSourceSid,&dimSid))
                                {
                                    rc = GetLastError();
                                    err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_ENTRY_TRANSLATE_SD_FAILED,rc );
                                    break;

                                }
                                dimSid = DIM(strTargetSid);
                                if(!GetTextualSid(pSidTgt,strTargetSid,&dimSid))
                                {
                                    rc = GetLastError();
                                    err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_ENTRY_TRANSLATE_SD_FAILED,rc );
                                    break;

                                }

                                rc = srcKey.Open(strSourceSid,&keyProfiles);
                                if ( rc )
                                {
                                    err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_ENTRY_OPEN_FAILED_SD,pNode->GetAcctName(),rc );
                                    break;
                                }

                                // check whether this is a local profile:
                                //  if policy says no roaming profile, it is always local profile
                                //  otherwise, if CentralProfile has a non-empty value and or not by looking at CentralProfile value
                                BOOL isLocalProfile = TRUE;
                                if (noRoamingProfile == FALSE)
                                {
                                    DWORD localRc;
                                    lenValue = (sizeof keyPath);
                                    localRc = srcKey.ValueGet(L"CentralProfile",(void *)keyPath,&lenValue,&typeValue);

                                    // if CentralProfile is set to some value, check the UserPreference
                                    if (localRc == ERROR_SUCCESS && typeValue == REG_SZ && keyPath[0] != L'\0')
                                    {
                                        DWORD keyValue;
                                        DWORD keyValueType;
                                        DWORD keyValueLen = sizeof(keyValue);
                                        localRc = srcKey.ValueGet(L"UserPreference",(void*)&keyValue,&keyValueLen,&keyValueType);
                                        // the user wants to use the roaming profile if UserPreference (REG_DWORD) 
                                        // is either set to 1 or missing
                                        if (localRc == ERROR_FILE_NOT_FOUND
                                            || (localRc == ERROR_SUCCESS && keyValueType != REG_DWORD))
                                        {
                                            // if UserPreference is missing, we have to check
                                            // Preference\UserPreference
                                            TRegKey srcPreferenceKey;
                                            localRc = srcPreferenceKey.Open(L"Preference", &srcKey);
                                            if (localRc == ERROR_FILE_NOT_FOUND)
                                            {
                                                isLocalProfile = FALSE;
                                            }
                                            else if (localRc == ERROR_SUCCESS)
                                            {
                                                keyValueLen = sizeof(keyValue);
                                                localRc = srcPreferenceKey.ValueGet(L"UserPreference",
                                                                                    (void*)&keyValue,
                                                                                    &keyValueLen,
                                                                                    &keyValueType);
                                                if (localRc == ERROR_FILE_NOT_FOUND
                                                    || (localRc == ERROR_SUCCESS
                                                        && (keyValueType != REG_DWORD || keyValue == 1)))
                                                {
                                                    isLocalProfile = FALSE;
                                                }
                                            }
                                            
                                        }
                                        else if (localRc == ERROR_SUCCESS 
                                                  && keyValueType == REG_DWORD
                                                  && keyValue == 1)
                                        {
                                            isLocalProfile = FALSE;
                                        }
                                    }

                                    // if localRc is an error other than ERROR_FILE_NOT_FOUND,
                                    // we cannot determine whether it is a local profile or not
                                    // so we need to log an error and continue with the next profile
                                    if (localRc != ERROR_SUCCESS && localRc != ERROR_FILE_NOT_FOUND)
                                    {
                                        err.SysMsgWrite(ErrS,
                                                         localRc,
                                                         DCT_MSG_PROFILE_CANNOT_DETERMINE_TYPE_SD,
                                                         strSourceSid,
                                                         localRc);
                                        break;
                                    }
                                }

                                if ((stArgs->TranslationMode() == ADD_SECURITY) || (stArgs->TranslationMode() == REPLACE_SECURITY) )
                                {
                                    // make a copy of this registry key, so the profile will refer to the new user
                                    if ( ! stArgs->NoChange() )
                                    {
                                        rc = tgtKey.Create(strTargetSid,&keyProfiles,&disposition);                               
                                    }
                                    else
                                    {
                                        // We need to see if the key already exists or not and set the DISPOSITION accordingly.
                                        rc = tgtKey.OpenRead(strTargetSid, &keyProfiles);
                                        if ( rc ) 
                                        {
                                            disposition = REG_CREATED_NEW_KEY;
                                            rc = 0;
                                        }
                                        tgtKey.Close();
                                    }
                                    if ( rc )
                                    {
                                        err.SysMsgWrite(ErrS,rc,DCT_MSG_PROFILE_CREATE_ENTRY_FAILED_SD,pNode->GetTargetAcctName(),rc);
                                        break;
                                    }
                                    if ( disposition == REG_CREATED_NEW_KEY || (stArgs->TranslationMode() == REPLACE_SECURITY))
                                    {
                                        // copy the entries from the source key
                                        if ( ! stArgs->NoChange() )
                                        {
                                            rc = tgtKey.HiveCopy(&srcKey);
                                        }
                                        else 
                                        {
                                            rc = 0;
                                            tgtKey = srcKey;
                                        }
                                        if ( rc )
                                        {
                                            // Since the translation failed and we created the key we should delete it.
                                            if ( disposition == REG_CREATED_NEW_KEY )
                                            {
                                                if ( ! stArgs->NoChange() )
                                                    keyProfiles.SubKeyRecursiveDel(strTargetSid);
                                            }
                                            err.SysMsgWrite(ErrS,rc,DCT_MSG_COPY_PROFILE_FAILED_SSD,pNode->GetAcctName(),pNode->GetTargetAcctName(),rc);
                                            break;
                                        }
                                        // now get the profile path ...
                                        lenValue = (sizeof keyPath);
                                        rc = tgtKey.ValueGet(L"ProfileImagePath",(void *)keyPath,&lenValue,&typeValue);
                                        if ( rc )
                                        {
                                            // Since the translation failed and we created the key we should delete it.
                                            if ( disposition == REG_CREATED_NEW_KEY )
                                            {
                                                if ( ! stArgs->NoChange() )
                                                    keyProfiles.SubKeyRecursiveDel(strTargetSid);
                                            }
                                            err.SysMsgWrite(ErrS,rc,DCT_MSG_GET_PROFILE_PATH_FAILED_SD,pNode->GetAcctName(),rc);
                                            break;
                                        }
                                        //copy the profile directory and its contents, and translate the profile registry hive itself
                                        rc = CopyProfileDirectoryAndTranslate(strSourceSid,keyPath,targetPath,pNode,stArgs,stat,!isLocalProfile);                               
                                        if ( rc )
                                        {
                                            if (rc == ERROR_PROFILE_TRANSLATION_FAILED_DUE_TO_REPLACE_MODE_WHILE_LOGGED_ON)
                                            {
                                                err.MsgWrite(ErrE,
                                                              DCT_MSG_PROFILE_TRANSLATION_FAILED_DUE_TO_REPLACE_MODE_WHILE_LOGGED_ON_S,
                                                              pNode->GetAcctName());
                                                rc = ERROR_SUCCESS;  // reset the error code
                                            }
                                            
                                            // Since the translation failed and we created the key we should delete it.
                                            if ( disposition == REG_CREATED_NEW_KEY )
                                            {
                                                if ( ! stArgs->NoChange() )
                                                    keyProfiles.SubKeyRecursiveDel(strTargetSid);
                                            }
                                            break;
                                        }
                                        // Update the ProfileImagePath key
                                        if ( !stArgs->NoChange() )
                                            rc = tgtKey.ValueSet(L"ProfileImagePath",(void*)targetPath,(1+UStrLen(targetPath)) * (sizeof WCHAR),typeValue);
                                        else
                                            rc = 0;
                                        if ( rc )
                                        {
                                            // Since the translation failed and we created the key we should delete it.
                                            if ( disposition == REG_CREATED_NEW_KEY )
                                            {
                                                if ( ! stArgs->NoChange() )
                                                    keyProfiles.SubKeyRecursiveDel(strTargetSid);
                                            }
                                            err.SysMsgWrite(ErrS,rc,DCT_MSG_SET_PROFILE_PATH_FAILED_SD,pNode->GetTargetAcctName(),rc);
                                            break;
                                        }

                                        // update the SID property
                                        if ( !stArgs->NoChange() )
                                            rc = tgtKey.ValueSet(L"Sid",(void*)pSidTgt,GetLengthSid(pSidTgt),REG_BINARY);
                                        else
                                            rc = 0;
                                        if ( rc )
                                        {
                                            // Since the translation failed and we created the key we should delete it.
                                            if ( disposition == REG_CREATED_NEW_KEY )
                                            {
                                                if ( ! stArgs->NoChange() )
                                                    keyProfiles.SubKeyRecursiveDel(strTargetSid);
                                            }
                                            rc = GetLastError();
                                            err.SysMsgWrite(ErrS,rc,DCT_MSG_UPDATE_PROFILE_SID_FAILED_SD,pNode->GetTargetAcctName(),rc);
                                            break;
                                        }
                                    }
                                    else
                                    {                               
                                        err.MsgWrite(ErrW,DCT_MSG_PROFILE_EXISTS_S,pNode->GetTargetAcctName());
                                        break;
                                    }
                                }
                                else  // this is for remove mode
                                {
                                    // check whether the user is logged on or not
                                    // by looking at HKEY_USERS\<user-sid>
                                    // if the key is present, the user is logged on
                                    // and we log an error for profile translation
                                    // if we cannot open the key, we assume it is not
                                    // there
                                    HKEY hUserKey;
                                    DWORD localRc = RegOpenKeyEx(HKEY_USERS,
                                                                  strSourceSid,
                                                                  0,
                                                                  READ_CONTROL,
                                                                  &hUserKey);

                                    if (localRc == ERROR_SUCCESS)
                                    {
                                        err.MsgWrite(ErrE,
                                                      DCT_MSG_PROFILE_TRANSLATION_FAILED_DUE_TO_REMOVE_MODE_WHILE_LOGGED_ON_S,
                                                      pNode->GetAcctName());
                                        RegCloseKey(hUserKey);
                                        break;
                                    }
                                }
                                
                                if ( (stArgs->TranslationMode() == REPLACE_SECURITY) || (stArgs->TranslationMode() == REMOVE_SECURITY) )
                                {
                                    // delete the old registry key
                                    if ( ! stArgs->NoChange() )
                                        rc = keyProfiles.SubKeyRecursiveDel(strSourceSid);
                                    else
                                        rc = 0;
                                    if ( rc )
                                    {
                                        err.SysMsgWrite(ErrS,rc,DCT_MSG_DELETE_PROFILE_FAILED_SD,pNode->GetAcctName(),rc);
                                        rc = ERROR_SUCCESS;
                                        break;
                                    }
                                    else
                                    {
                                        err.MsgWrite(0, DCT_MSG_DELETED_PROFILE_S, pNode->GetAcctName());
                                    }
                                }

                                //
                                // If translation mode is replace then translate Installer related registry keys.
                                //

                                if (!stArgs->NoChange() && stArgs->TranslationMode() == REPLACE_SECURITY)
                                {
                                    //
                                    // If MsiNotifySidChange API was loaded use it otherwise use private implementation
                                    // which will make necessary updates for older Installer versions.
                                    //

                                    DWORD dwError;

                                    if (MsiNotifySidChange)
                                    {
                                        dwError = MsiNotifySidChange(strSourceSid, strTargetSid);

                                        // on both Win2K SP3 and WinXP, if any part of the source key
                                        // is missing, STATUS_OBJECT_NAME_NOT_FOUND is returned
                                        // we specifically suppress this error message since,
                                        // according to installer folks, it does not indicate
                                        // any migration failure
                                        if (dwError == STATUS_OBJECT_NAME_NOT_FOUND)
                                            dwError = ERROR_SUCCESS;
                                    }
                                    else
                                    {
                                        dwError = AdmtMsiNotifySidChange(strSourceSid, strTargetSid);
                                    }

                                    if (dwError == ERROR_SUCCESS)
                                    {
                                        err.MsgWrite(0, DCT_MSG_TRANSLATE_INSTALLER_SS, strSourceSid, strTargetSid);
                                    }
                                    else
                                    {
                                        err.SysMsgWrite(ErrW, dwError, DCT_MSG_NOT_TRANSLATE_INSTALLER_SSD, strSourceSid, strTargetSid, dwError);
                                    }
                                }
                            }
                        } while ( FALSE ); 
                    }

                    //
                    // Unload MSI module.
                    //

                    if (hMsiModule)
                    {
                        FreeLibrary(hMsiModule);
                    }

                    // clean up the list
                    for ( ndx = 0 ; ndx < nSubKeys ; ndx++ )
                    {
                        if ( pSids[ndx] )
                            FreeSid(pSids[ndx]);
                        pSids[ndx] = NULL;
                    }
                    delete [] pSids;
                }         
            }
            if ( rc && rc != ERROR_NO_MORE_ITEMS )
            {
                err.SysMsgWrite(ErrS,rc,DCT_MSG_ENUM_PROFILES_FAILED_D,rc);
            }
        }
        else
        {
            err.SysMsgWrite(ErrS,rc,DCT_MSG_OPEN_PROFILELIST_FAILED_D,rc);
        }
    }

    if (stArgs->Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_LOCAL_PROFILES);

    return rc;
}

DWORD 
   TranslateRemoteProfile(
      WCHAR          const * sourceProfilePath,   // in - source profile path
      WCHAR                * targetProfilePath,   // out- new profile path for target account
      WCHAR          const * sourceName,          // in - name of source account
      WCHAR          const * targetName,          // in - name of target account
      WCHAR          const * srcDomain,           // in - source domain
      WCHAR          const * tgtDomain,           // in - target domain
      IIManageDB           * pDb,                 // in - pointer to DB object
      long                   lActionID,           // in - action ID of this migration
      PSID                   sourceSid,           // in - source sid from MoveObj2K
      BOOL                   bNoWriteChanges      // in - No Change mode.
   )
{
    DWORD                     rc = 0;
    BYTE                      srcSid[LEN_SID];
    PSID                      tgtSid[LEN_SID];
    SecurityTranslatorArgs    stArgs;
    TSDResolveStats           stat(stArgs.Cache());
    TRidNode                * pNode = NULL;
    WCHAR                     domain[LEN_Domain];
    DWORD                     lenDomain = DIM(domain);
    DWORD                     lenSid = DIM(srcSid);
    DWORD                     srcRid=0;
    DWORD                     tgtRid=0;
    SID_NAME_USE              snu;
    IVarSetPtr                pVs(__uuidof(VarSet));
    IUnknown                * pUnk = NULL;
    HRESULT                   hr = S_OK;
    WCHAR                     sActionInfo[MAX_PATH];
    _bstr_t                   sSSam;
    long                      lrid;

    stArgs.Cache()->SetSourceAndTargetDomains(srcDomain,tgtDomain);

    if ( stArgs.Cache()->IsInitialized() )
    {
        // Get the source account's rid
        if (! LookupAccountName(stArgs.Cache()->GetSourceDCName(),sourceName,srcSid,&lenSid,domain,&lenDomain,&snu) )
        {
            rc = GetLastError();
        }
        else
        {
            _bstr_t strDnsName;
            _bstr_t strFlatName;

            rc = GetDomainNames4(domain, strFlatName, strDnsName);

            if ( (rc == ERROR_SUCCESS) && ((UStrICmp(strDnsName, srcDomain) == 0) || (UStrICmp(strFlatName, srcDomain) == 0)) )
            {
                PUCHAR              pCount = GetSidSubAuthorityCount(srcSid);
                if ( pCount )
                {
                    DWORD            nSub = (DWORD)(*pCount) - 1;
                    DWORD          * pRid = GetSidSubAuthority(srcSid,nSub);

                    if ( pRid )
                    {
                        srcRid = *pRid;
                    }

                }
            }
        }
        //if we couldn't get the src Rid, we are likely doing an intra-forest migration.
        //In this case we will lookup the src Rid in the Migrated Objects table
        if (!srcRid)
        {
            if (sourceSid && IsValidSid(sourceSid))
            {
                CopySid(sizeof(srcSid), srcSid , sourceSid);
            }
            else
            {
                memset(srcSid, 0, sizeof(srcSid));
            }
            hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
            if ( SUCCEEDED(hr) )
                hr = pDb->raw_GetMigratedObjects(lActionID, &pUnk);

            if ( SUCCEEDED(hr) )
            {
                long lCnt = pVs->get("MigratedObjects");
                bool bFound = false;
                for ( long l = 0; (l < lCnt) && (!bFound); l++)
                {
                    wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceSamName));      
                    sSSam = pVs->get(sActionInfo);
                    if (_wcsicmp(sourceName, (WCHAR*)sSSam) == 0)
                    {
                        wsprintf(sActionInfo, L"MigratedObjects.%d.%s", l, GET_STRING(DB_SourceRid));      
                        lrid = pVs->get(sActionInfo);
                        srcRid = (DWORD)lrid;
                        bFound = true;
                    }
                }
            }
        }

        lenSid = DIM(tgtSid);
        lenDomain = DIM(domain);
        // Get the target account's rid
        if (! LookupAccountName(stArgs.Cache()->GetTargetDCName(),targetName,tgtSid,&lenSid,domain,&lenDomain,&snu) )
        {
            rc = GetLastError();
        }
        else
        {
            _bstr_t strDnsName;
            _bstr_t strFlatName;

            rc = GetDomainNames4(domain, strFlatName, strDnsName);

            if ( (rc == ERROR_SUCCESS) && ((UStrICmp(strDnsName, tgtDomain) == 0) || (UStrICmp(strFlatName, tgtDomain) == 0)) )
            {
                PUCHAR              pCount = GetSidSubAuthorityCount(tgtSid);
                if ( pCount )
                {
                    DWORD            nSub = (DWORD)(*pCount) - 1;
                    DWORD          * pRid = GetSidSubAuthority(tgtSid,nSub);

                    if ( pRid )
                    {
                        tgtRid = *pRid;
                    }
                }
            }
        }
    }

    if ( ((srcRid && tgtRid) || !stArgs.NoChange()) && (!bNoWriteChanges) )
    {
        stArgs.Cache()->InsertLast(const_cast<WCHAR * const>(sourceName), srcRid, const_cast<WCHAR * const>(targetName), tgtRid);         
        pNode = (TRidNode*)stArgs.Cache()->Lookup(srcSid);

        if ( pNode )
        {
            // Set up the security translation parameters
            stArgs.SetTranslationMode(ADD_SECURITY);
            stArgs.TranslateFiles(FALSE);
            stArgs.TranslateUserProfiles(TRUE);
            stArgs.SetWriteChanges(!bNoWriteChanges);
            //copy the profile directory and its contents, and translate the profile registry hive itself
            // note: for remote profile translation, we cannot handle the case 
            //       where the user is currently logged on
            rc = CopyProfileDirectoryAndTranslate(NULL,sourceProfilePath,targetProfilePath,pNode,&stArgs,&stat,FALSE);
        }
    }                        
    return rc;
}

HRESULT UpdateMappedDrives(WCHAR * sSourceSam, WCHAR * sSourceDomain, WCHAR * sRegistryKey)
{
   TRegKey                   reg;
   TRegKey                   regDrive;
   DWORD                     rc = 0;
   WCHAR                     netKey[LEN_Path];
   int                       len = LEN_Path;
   int                       ndx = 0;
   HRESULT                   hr = S_OK;
   WCHAR                     sValue[LEN_Path];
   WCHAR                     sAcct[LEN_Path];
   WCHAR                     keyname[LEN_Path];

   // Build the account name string that we need to check for
   wsprintf(sAcct, L"%s\\%s", (WCHAR*) sSourceDomain, (WCHAR*) sSourceSam);
   // Get the path to the Network subkey for this users profile.
   wsprintf(netKey, L"%s\\%s", (WCHAR*) sRegistryKey, L"Network");
   rc = reg.Open(netKey, HKEY_USERS);
   if ( !rc ) 
   {
      while ( !reg.SubKeyEnum(ndx, keyname, len) )
      {
         rc = regDrive.Open(keyname, reg.KeyGet());
         if ( !rc ) 
         {
            // Get the user name value that we need to check.
            rc = regDrive.ValueGetStr(L"UserName", sValue, LEN_Path);
            if ( !rc )
            {
               if ( !_wcsicmp(sAcct, sValue) )
               {
                  // Found this account name in the mapped drive user name.so we will set the key to ""
                  regDrive.ValueSetStr(L"UserName", L"");
                  err.MsgWrite(0, DCT_MSG_RESET_MAPPED_CREDENTIAL_S, sValue);
               }
            }
            else
               hr = HRESULT_FROM_WIN32(GetLastError());
            regDrive.Close();
         }
         else
            hr = HRESULT_FROM_WIN32(GetLastError());
         ndx++;
      }
      reg.Close();
   }
   else
      hr = HRESULT_FROM_WIN32(GetLastError());

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by WorkObj.rc
//
#define IDS_PROJNAME                    100
#define IDR_ACCTREPL                    101
#define IDR_COMPPWDAGE                  102
#define IDR_CHANGEDOMAIN                103
#define IDR_RENAMECOMPUTER              104
#define IDR_REBOOT                      105
#define IDR_PWDCOPY                     106
#define IDR_USERRIGHTS                  107
#define IDR_STATUSOBJ                   108
#define IDR_SECTRANSLATOR               109
#define IDR_ACCESSCHECKER               110
#define IDR_PLUGININFO                  111

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\rename.h ===
/*---------------------------------------------------------------------------
  File: RenameComputer.h

  Comments: Implementation class definition for COM object to rename the local computer.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:25:06

 ---------------------------------------------------------------------------
*/

// RenameComputer.h : Declaration of the CRenameComputer

#ifndef __RENAMECOMPUTER_H_
#define __RENAMECOMPUTER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CRenameComputer
class ATL_NO_VTABLE CRenameComputer : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CRenameComputer, &CLSID_RenameComputer>,
	public IDispatchImpl<IRenameComputer, &IID_IRenameComputer, &LIBID_MCSDCTWORKEROBJECTSLib>
{  
   BOOL                      m_bNoChange;
public:
	CRenameComputer()
	{
	   m_bNoChange = FALSE;
   }

DECLARE_REGISTRY_RESOURCEID(IDR_RENAMECOMPUTER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CRenameComputer)
	COM_INTERFACE_ENTRY(IRenameComputer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IRenameComputer
public:
	STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
	STDMETHOD(RenameLocalComputer)(BSTR NewName);
};

#endif //__RENAMECOMPUTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\rightstr.h ===
#ifndef __RIGHTSTRANSLATOR_H__
#define __RIGHTSTRANSLATOR_H__
/*---------------------------------------------------------------------------
  File: RightsTranslator.h

  Comments: Functions to translate user rights.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/25/99 19:56:44

 ---------------------------------------------------------------------------
*/




DWORD  
   TranslateUserRights(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

#endif //__RIGHTSTRANSLATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\regtrans.h ===
#ifndef __REGTRANSLATOR_H__
#define __REGTRANSLATOR_H__
/*---------------------------------------------------------------------------
  File: RegTranslator.h    

  Comments: Functions to translate registry hives, specifically, user profiles

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/12/99 11:11:49

 ---------------------------------------------------------------------------
*/
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"
#import  "DBMgr.tlb" no_namespace, named_guids


DWORD 
   TranslateLocalProfiles(
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

DWORD 
   TranslateRemoteProfile(
      WCHAR          const * sourceProfilePath,   // in - source profile path
      WCHAR                * targetProfilePath,   // out- new profile path for target account
      WCHAR          const * sourceName,          // in - name of source account
      WCHAR          const * targetName,          // in - name of target account
      WCHAR          const * srcDomain,           // in - source domain
      WCHAR          const * tgtDomain,           // in - target domain      
      IIManageDB           * pDb,				  // in - pointer to DB object
	  long					 lActionID,           // in - action ID of this migration
	  PSID                   sourceSid,           // in - source sid from MoveObj2K
      BOOL                   bWriteChanges        // in - No Change mode.
   );


DWORD 
   TranslateRegistry(
      WCHAR            const * computer,          // in - computername to translate registry on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   );

HRESULT UpdateMappedDrives(WCHAR * sSourceSam, WCHAR * sSourceDomain, WCHAR * sRegistryKey);

#endif //__REGTRANSLATOR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\rightstr.cpp ===
/*---------------------------------------------------------------------------
  File: RightsTranslator.cpp

  Comments: Functions to translate user rights

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/25/99 19:57:16

 ---------------------------------------------------------------------------
*/


#include "StdAfx.h"
#include "Mcs.h"
#include "WorkObj.h"
#include "SecTrans.h"
#include "STArgs.hpp"
#include "SidCache.hpp"
#include "SDStat.hpp"
#include "TxtSid.h"
#include "ErrDct.hpp"

//#import "\bin\McsDctWorkerObjects.tlb"
#import "WorkObj.tlb"

extern TErrorDct err;

DWORD  
   TranslateUserRights(
      WCHAR            const * serverName,        // in - name of server to translate groups on
      SecurityTranslatorArgs * stArgs,            // in - translation settings
      TSDRidCache            * cache,             // in - translation table
      TSDResolveStats        * stat               // in - stats on items modified
   )
{
//   DWORD                       rc = 0;
   HRESULT                     hr;
   SAFEARRAY                 * pRights = NULL;
   SAFEARRAY                 * pUsers = NULL;
   TAcctNode                 * node = NULL;
   _bstr_t                     server = serverName;
   MCSDCTWORKEROBJECTSLib::IUserRightsPtr pLsa(CLSID_UserRights);
   WCHAR                       currPath[500];
   DWORD                       mode = stArgs->TranslationMode();
   BOOL						   bUseMapFile = stArgs->UsingMapFile();

   //
   // If server name is not null then use specified name for generated messages. If specified
   // server name is null that means the user rights translation is being performed on the
   // local machine therefore retrieve the local machine name and use it for generated messages.
   //

   WCHAR szServerName[LEN_Computer];

   if (serverName && *serverName)
   {
       wcsncpy(szServerName, serverName, LEN_Computer);
       szServerName[LEN_Computer - 1] = L'\0';
   }
   else
   {
      DWORD dwSize = LEN_Computer;

      if (!GetComputerName(szServerName, &dwSize))
      {
          szServerName[0] = L'\0';
      }
   }

   if ( pLsa == NULL )
   {
      return E_FAIL;
   }
   pLsa->NoChange = stArgs->NoChange();
   
   if ( stArgs->TranslationMode() == REPLACE_SECURITY || stArgs->TranslationMode() == REMOVE_SECURITY )
   {
      err.MsgWrite(0,DCT_MSG_USER_RIGHTS_ONLY_ADDS);
      stArgs->SetTranslationMode(ADD_SECURITY);
   }
   // Get a list of all the rights
   hr = pLsa->raw_GetRights(server,&pRights);
   if ( SUCCEEDED(hr) )
   {
      LONG                   nRights = 0;
      long                   ndx[1];
      hr = SafeArrayGetUBound(pRights,1,&nRights);
      if ( SUCCEEDED(hr) )
      {
         for ( long i = 0 ; i <= nRights && !stArgs->Cache()->IsCancelled(); i++ )
         {
            BSTR             right;
            
            ndx[0] = i;
            hr = SafeArrayGetElement(pRights,ndx,&right);
            if ( SUCCEEDED(hr) )
            {
               swprintf(currPath,L"%s\\%s",szServerName,(WCHAR*)right);
               if( stat )
               {
                  stat->DisplayPath(currPath);
               }
               // Get a list of users who have this right
               hr = pLsa->raw_GetUsersWithRight(server,right,&pUsers);
               if ( SUCCEEDED(hr))
               {
                  LONG       nUsers = 0;
                  
                  hr = SafeArrayGetUBound(pUsers,1,&nUsers);
                  if ( SUCCEEDED(hr) )
                  {
                     BSTR    user;
                     PSID    pSid = NULL;
//                     PSID    pTgt = NULL;
                     
                     for ( long j = 0 ; j <= nUsers ; j++ )
                     {
                        ndx[0] = j;
                        hr = SafeArrayGetElement(pUsers,ndx,&user);
                        if ( SUCCEEDED(hr)) 
                        {
                           // Get the user's sid
                           pSid = SidFromString(user);
                           if ( pSid )
                           {
                              stat->IncrementExamined(userright);
                              // Lookup the user in the cache
							  if (!bUseMapFile)
                                 node = cache->Lookup(pSid);
							  else
                                 node = cache->LookupWODomain(pSid);
                              if ( node )
                              {
                                 if ( node == (TAcctNode*)-1 )
                                 {
                                    node = NULL;     
                                 }
                                 if ( node && node->IsValidOnTgt() )
                                 {
                                    // Found the account in the cache
                                    // remove the right from the source user
                                    
                                    if ( (stArgs->TranslationMode() == REMOVE_SECURITY ||stArgs->TranslationMode() == REPLACE_SECURITY) )
                                    {
                                       hr = pLsa->raw_RemoveUserRight(server,user,right);
                                       if ( FAILED(hr))
                                       {
                                          err.SysMsgWrite(ErrE,hr,DCT_MSG_REMOVE_RIGHT_FAILED_SSSD,
                                                   (WCHAR*)right,node->GetAcctName(),szServerName,hr);
                                          stat->IncrementSkipped(userright);
                                       }
                                       else
                                       {
                                          err.MsgWrite(0,DCT_MSG_REMOVED_RIGHT_SSSS,szServerName,right,stArgs->Source(),node->GetAcctName());
                                       }
                                    }
                                    if ( SUCCEEDED(hr) )
                                    {
                                       stat->IncrementChanged(userright);
                                       PSID sid = NULL;
	                                   if (!bUseMapFile)
                                          sid = cache->GetTgtSid(node);
	                                   else
                                          sid = cache->GetTgtSidWODomain(node);
                                       if ( sid )
                                       {
                                          WCHAR          strSid[200];
                                          DWORD          lenStrSid = DIM(strSid);
                                          GetTextualSid(sid,strSid,&lenStrSid);
                                          
                                          if ( (stArgs->TranslationMode() != REMOVE_SECURITY) )
                                          {
                                             hr = pLsa->raw_AddUserRight(server,SysAllocString(strSid),right);
                                             if ( FAILED(hr) )
                                             {
                                                err.SysMsgWrite(ErrE,hr,DCT_MSG_ADD_RIGHT_FAILED_SSSD,
                                                         (WCHAR*)right,node->GetAcctName(),szServerName,hr);
                                                
                                             }
                                             else
                                             {
                                                err.MsgWrite(0,DCT_MSG_ADDED_RIGHT_SSSS,szServerName,right,stArgs->Target(),node->GetAcctName());
                                             }
                                          }
                                          free(sid);
                                       }
                                    }
                                 }
                              }
                              FreeSid(pSid);
                           }
                           else
                           {
                              err.MsgWrite(ErrW,DCT_MSG_INVALID_SID_STRING_S,user);
                           }
                           SysFreeString(user);
                        }
                     }
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,hr,DCT_MSG_USERS_WITH_RIGHT_COUNT_FAILED_SSD,(WCHAR*)right,szServerName,hr);
                  }
                  SafeArrayDestroy(pUsers);
               }
               else
               {
                  err.MsgWrite(ErrE,DCT_MSG_GET_USERS_WITH_RIGHT_FAILED_SSD,(WCHAR*)right,szServerName,hr);
               }
               SysFreeString(right);
            }
            else
            {
               err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,szServerName,hr);
               break;
            }
         }
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,szServerName,hr);
      }
      SafeArrayDestroy(pRights);   
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_LIST_RIGHTS_FAILED_SD,szServerName,hr);
   }
   if( stat )
   {
      stat->DisplayPath(L"");
   }

   // set the translation mode back to its original value
   stArgs->SetTranslationMode(mode);
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\rename.cpp ===
/*---------------------------------------------------------------------------
  File: RenameComputer.cpp

  Comments: Implementation of COM object to change the name of a computer.
  This must be run locally on the computer to be renamed.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:22:41

 ---------------------------------------------------------------------------
*/

// RenameComputer.cpp : Implementation of CRenameComputer
#include "stdafx.h"
#include "WorkObj.h"
#include "Rename.h"
#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"
#include <lm.h>
#include "TReg.hpp"


typedef WINBASEAPI BOOL (WINAPI* PSETCOMPUTERNAMEEXW)
    (
    IN COMPUTER_NAME_FORMAT NameType,
    IN LPCWSTR lpBuffer
    );


/////////////////////////////////////////////////////////////////////////////
// CRenameComputer

STDMETHODIMP CRenameComputer::RenameLocalComputer(BSTR bstrNewName)
{
    USES_CONVERSION;

    HRESULT hr = S_OK;

    //
    // validate argument - a new name must be passed
    //

    UINT cchNewName = SysStringLen(bstrNewName);

    if (cchNewName == 0)
    {
        return E_INVALIDARG;
    }

    //
    // only perform if not in test mode
    //

    if (!m_bNoChange)
    {
        //
        // remove leading backslash characters
        //

        PCWSTR pszNewName = OLE2CW(bstrNewName);

        WCHAR szNewName[LEN_Computer];

        if ((cchNewName >= 2) && ((pszNewName[0] == L'\\') && (pszNewName[1] == L'\\')))
        {
            wcsncpy(szNewName, &pszNewName[2], sizeof(szNewName)/sizeof(szNewName[0]));
        }
        else
        {
            wcsncpy(szNewName, pszNewName, sizeof(szNewName)/sizeof(szNewName[0]));
        }
        szNewName[sizeof(szNewName)/sizeof(szNewName[0]) - 1] = L'\0';

        //
        // convert the new name to lowercase
        //
        // the NetBIOS name is passed to this function which is uppercase
        // if this name is passed to the SetComputerName functions the DNS
        // name will also be uppercase which is not desired the NetBIOS name
        // is always converted to uppercase by SetComputerName functions
        //

        _wcslwr(szNewName);

        //
        // Attempt to use the SetComputerEx function which sets both the NetBIOS
        // and DNS names but is only available with Windows 2000 and later.
        //

        bool bUseSetComputer = false;

        HMODULE hKernel32 = LoadLibrary(L"Kernel32.dll");

        if (hKernel32)
        {
            PSETCOMPUTERNAMEEXW pSetComputerNameExW = (PSETCOMPUTERNAMEEXW) GetProcAddress(hKernel32, "SetComputerNameExW");

            if (pSetComputerNameExW)
            {
                //
                // set both the DNS hostname and NetBIOS name to the same value
                //

                if (!pSetComputerNameExW(ComputerNamePhysicalDnsHostname, szNewName))
                {
                    DWORD dwError = GetLastError();
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
            else
            {
                bUseSetComputer = true;
            }

            FreeLibrary(hKernel32);
        }
        else
        {
            bUseSetComputer = true;
        }

        //
        // SetComputerNameEx is not available with Windows NT 4.0 and earlier
        // therefore use SetComputerName which only sets the NetBIOS name.
        // The DNS hostname must then be set by directly updating registry.
        //

        if (bUseSetComputer)
        {
            if (SetComputerName(szNewName))
            {
                TRegKey key(L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters");

                DWORD dwError = key.ValueSetStr(L"Hostname", szNewName);

                hr = HRESULT_FROM_WIN32(dwError);
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
    }

    return hr;
}

STDMETHODIMP CRenameComputer::get_NoChange(BOOL *pVal)
{
   (*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP CRenameComputer::put_NoChange(BOOL newVal)
{
	m_bNoChange = newVal;
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdrcmn.cpp ===
//#pragma title( "SDRCommon.cpp - SDResolve:  Common routines for sdresolve" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdrCommon.cpp
System      -  Domain Consolidation Toolkit
Author      -  Christy Boles
Created     -  97/07/11
Description -  Command line parsing, help text, and utilities for EADCFILE and EADCEXCH
Updates     -
===============================================================================
*/

#include "stdafx.h"

#include <stdlib.h>
#include <stdio.h>
#include <iostream.h>
#include <fstream.h>
#include <assert.h>
#include <lm.h>
#include <lmwksta.h>
#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "sidcache.hpp"
#include "enumvols.hpp"
#include "ealen.hpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct                      err;
bool                                  ignoreall;
extern  bool                          enforce;
bool                                  silent;

extern bool ContainsWildcard(WCHAR const * name);

#define MAX_BUFFER_LENGTH             10000

int ColonIndex(TCHAR * str)
{
   if ( ! str )
      return 0;
   int                     i;

   for (i = 0 ; str[i] && str[i] != ':' ; i++)
   ;
   if ( str[i] != ':' )
      i = 0;
 
   return i;
} 


WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   )
{
   int                       i;
   WCHAR                   * machinename = NULL; 
   if (    pathname
        && pathname[0] == L'\\'
        && pathname[1] == L'\\'
      )
   {
      for ( i = 2 ; pathname[i] && pathname[i] != L'\\' ; i++ ) 
      ;
      machinename = new WCHAR[i+2];
      if(!machinename)
      {
          // memory allocation failed, just return NULL
          return machinename;
      }
      UStrCpy(machinename,pathname,i+1);
      machinename[i] = 0;
   }
   return machinename;
}

   

int EqualSignIndex(char * str)
{
   if ( ! str )
      return 0;
   int                     i;

   for (i = 0 ; str[i] && str[i] != '=' ; i++)
   ;
   if ( str[i] != '=' )
      i = 0;
 
   return i;
} 

BOOL BuiltinRid(DWORD rid)
{
   // returns TRUE if rid is the rid of a builtin account
   
   BOOL                      result;
   // 500 Administrator
   // 501 Guest
   // 512 Domain Admins
   // 513 Domain Users
   // 514 Domain Guests
   // 544 Administrators
   // 545 Users
   // 546 Guests
   // 547 Power Users
   // 548 Account Operators
   // 549 Server Operators
   // 550 Print Operators
   // 551 Backup Operators
   // 552 Replicator 
   if ( rid < 500 )
      return TRUE;

   switch ( rid )
   {
      case DOMAIN_USER_RID_ADMIN:
      case DOMAIN_USER_RID_GUEST:          
      case DOMAIN_ALIAS_RID_ADMINS:        
      case DOMAIN_ALIAS_RID_USERS:         
      case DOMAIN_ALIAS_RID_GUESTS:        
      case DOMAIN_ALIAS_RID_POWER_USERS:   
      case DOMAIN_ALIAS_RID_ACCOUNT_OPS:   
      case DOMAIN_ALIAS_RID_SYSTEM_OPS:    
      case DOMAIN_ALIAS_RID_PRINT_OPS:     
      case DOMAIN_ALIAS_RID_BACKUP_OPS:    
      case DOMAIN_ALIAS_RID_REPLICATOR:
         result = TRUE;
         break;
      default:
         result = FALSE;
   }
   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdresolv.cpp ===
//#pragma title( "SDResolve.cpp - SDResolve:  A Domain Migration Utility" )

/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdresolve.cpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/07/11
Description -  Routines to iterate through files, shares, and printers
               when processing security on a machine.    
Updates     -
===============================================================================
*/

#include "stdafx.h"

#include <stdlib.h>
#include <stdio.h>
#include <iostream.h>
#include <fstream.h>
#include <assert.h>

#include "Common.hpp"
#include "ErrDct.hpp"
#include "UString.hpp"
#include "sd.hpp"
          
#include "sidcache.hpp"
#include "enumvols.hpp"
#include "SecObj.hpp"
#include "ealen.hpp"
#include "BkupRstr.hpp"
#include "TxtSid.h"
#include "array.h"

// this makes sure the funciton name IteratePathUnderlying is not mangled by C++
extern "C" {
#include "sdresolv_stkoflw.h"
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

bool enforce;
extern TErrorDct err;
extern bool silent;
extern bool IsMachineName(const LPWSTR name);
extern bool IsShareName(const LPWSTR name);
extern bool ContainsWildcard( WCHAR const * name);

struct SSeException
{
    SSeException(UINT uCode) : uCode(uCode)
    {
    }

    UINT uCode;
};

void SeTranslator(unsigned int u, EXCEPTION_POINTERS* pepExceptions)
{
    throw SSeException(u);
}

#define MAX_BUFFER_LENGTH 10000
#define PRINT_BUFFER_SIZE 2000

//******************************************************************************************************
//         Main routine for SDResolve

// Iterates files and directories to be resolved


void
   IteratePath(
      WCHAR                  * path,          // in -path to start iterating from
      SecurityTranslatorArgs * args,          // in -translation settings
      TSDResolveStats        * stats,         // in -stats (to display pathnames & pass to ResolveSD)
      TSecurableObject       * LC,            // in -last container
      TSecurableObject       * LL,            // in -last file
      bool                     haswc          // in -indicates whether path contains a wc character
   )
{
    _se_translator_function pfnSeTranslatorOld = _set_se_translator((_se_translator_function)SeTranslator);

    try
    {
        IteratePathUnderlying(path,(void*)args,(void*)stats,(void*)LC,(void*)LL,haswc ? TRUE : FALSE);
    }
    catch (SSeException sse)
    {
        _set_se_translator(pfnSeTranslatorOld);
        _com_issue_error(HRESULT_FROM_WIN32(sse.uCode));
    }
    catch (...)
    {
        _set_se_translator(pfnSeTranslatorOld);
        throw;
    }

    _set_se_translator(pfnSeTranslatorOld);
}

#define safecopy_wc_array(trg,src) ((src) ? UStrCpy((WCHAR*)trg,src,trg.size()) : *((WCHAR*)trg) = 0)

void
   IteratePathUnderlying(
      WCHAR                  * path,          // in -path to start iterating from
      void                   * argsC,          // in -translation settings
      void                   * statsC,         // in -stats (to display pathnames & pass to ResolveSD)
      void                   * LCC,            // in -last container
      void                   * LLC,            // in -last file
      BOOL                     haswc          // in -indicates whether path contains a wc character
   )
{
       SecurityTranslatorArgs *args = (SecurityTranslatorArgs *) argsC;
       TSDResolveStats        *stats = (TSDResolveStats *) statsC;
       TSecurableObject       *LC = (TSecurableObject*) LCC;
       TSecurableObject       *LL = (TSecurableObject*) LLC;
       
       HANDLE                    hFind;
       WIN32_FIND_DATA           findEntry;              
       BOOL                      b;
       TFileSD                 * currSD;
       bool                      changeLastCont;
       bool                      changeLastLeaf;
       WCHAR                   * appendPath = NULL;
       c_array<WCHAR>            safepath(LEN_Path + 10);
       TFileSD                 * LastContain = (TFileSD*) LC;
       TFileSD                 * LastLeaf = (TFileSD*) LL;
       c_array<WCHAR>            localPath(LEN_Path);
          // this is the first (for this) dir
       
       safecopy_wc_array(safepath,path);
       safecopy_wc_array(localPath,path);
        
       // Check to see if path is longer than MAX_PATH
       // if so, add \\?\ to the beginning of it to 
       // turn off path parsing
       if ( UStrLen(path) >= MAX_PATH && path[2] != L'?' )
       {
          WCHAR                   temp[LEN_Path];

          if ( (path[0] == L'\\') && (path[1] == L'\\') ) // UNC name
          {
             UStrCpy(temp,L"\\\\?\\UNC\\");
          }
          else
          {
             UStrCpy(temp,L"\\\\?\\");
          }
          UStrCpy(temp + UStrLen(temp),path);
          safecopy_wc_array(localPath,temp);
       }
       appendPath = (WCHAR*)localPath + UStrLen((WCHAR*)localPath);

       if ( *(appendPath-1) == L'\\' )   // if there's already a backslash on the end of the path, don't add another one
          appendPath--;
       if ( ! haswc )
          UStrCpy(appendPath, "\\*.*");
       if ( args->LogVerbose() )
          err.DbgMsgWrite(0,L"Starting IteratePath: %ls",path);
      
       for ( b = ((hFind = FindFirstFile((WCHAR*)localPath, &findEntry)) != INVALID_HANDLE_VALUE)
             ; b ; b = FindNextFile(hFind, &findEntry) )
       {
          if ( ! haswc) 
             appendPath[1] = '\0';      // restore path -- remove \*.* append
          if ( ! UStrCmp((LPWSTR)findEntry.cFileName,L".") || ! UStrCmp((LPWSTR)findEntry.cFileName,L"..") )
             continue;                        // ignore names '.' and '..'
          if ( ! haswc )
             UStrCpy(appendPath+1, findEntry.cFileName);
          else
          {
             for ( WCHAR * ch = appendPath-1; ch >= path && *ch != L'\\' ; ch-- )
             ;
             UStrCpy(ch+1,findEntry.cFileName);
          }
          if ( ((TAccountCache *)args->Cache())->IsCancelled() )
          {
            break;
          }
          currSD = new TFileSD(localPath, (findEntry.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM) != 0);
          stats->DisplayPath(localPath);
          if ( !currSD || !currSD->HasSecurity() )
          {
             //err.MsgWrite(0,"Error:  Couldn't get the SD");
          }
          else
          {
             if ( findEntry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ) // if dir
             {
                // resolve this container & iterate next container
                changeLastCont = currSD->ResolveSD(args,stats,directory,LastContain);
                if ( changeLastCont )
                {
                   if ( LastContain && LastContain != LC )
                   {
                      delete LastContain;
                   }
                   LastContain = currSD;
                }
                else
                {
                   delete currSD;
                }
                try
                {
                    BOOL bLogError;
                    UINT status = IteratePathUnderlyingNoObjUnwinding(localPath,(void*)args,(void*)stats,(void*)LastContain,(void*)LastLeaf,FALSE,&bLogError);
                    if (bLogError)
                        err.SysMsgWrite(ErrE,
                                         HRESULT_FROM_WIN32(STATUS_STACK_OVERFLOW),
                                         DCT_MSG_CANNOT_TRANSLATE_DIRECTORY_SD,
                                         (WCHAR*)localPath,
                                         HRESULT_FROM_WIN32(STATUS_STACK_OVERFLOW));
    
                    if (status != 0)
                        _com_issue_error(HRESULT_FROM_WIN32(status));
                }
                catch (SSeException sse)
                {
                    err.SysMsgWrite(ErrE,
                                     HRESULT_FROM_WIN32(sse.uCode),
                                     DCT_MSG_CANNOT_TRANSLATE_DIRECTORY_SD,
                                     (WCHAR*)localPath,
                                     HRESULT_FROM_WIN32(sse.uCode));
                    _com_issue_error(HRESULT_FROM_WIN32(sse.uCode));
                }
             }
             else
             {
                           // iterate this file with last 
                changeLastLeaf = currSD->ResolveSD(args,stats,file,LastLeaf); 
                if ( changeLastLeaf )
                {
                   if ( LastLeaf && LastLeaf != LL )
                   {
                      delete LastLeaf;
                   }
                   LastLeaf = currSD;
                }
                else
                {
                   delete currSD;
                }
             }
          }
       }
       if ( LastContain && LastContain != LC )
       {
          delete LastContain;
       }
       if ( LastLeaf && LastLeaf != LL )
       {
          delete LastLeaf;
       }
       appendPath[0] = '\0';
       DWORD                     rc = GetLastError();

       if ( args->LogVerbose() )
          err.DbgMsgWrite(0,L"Closing IteratePath %S",(WCHAR*)safepath);
       FindClose(hFind);
       switch ( rc )
       {
          case ERROR_NO_MORE_FILES:
          case 0:
             break;
          default:
             err.SysMsgWrite(ErrE, rc,  DCT_MSG_FIND_FILE_FAILED_SD, path, rc);
       }
}       

DWORD 
   ResolvePrinter(
      PRINTER_INFO_4         * pPrinter,     // in - printer information
      SecurityTranslatorArgs * args,      // in - translation settings
      TSDResolveStats        * stats      // in - stats
   )
{
   DWORD                    rc = 0;
//   DWORD                    needed = 0;
   
   TPrintSD            sd(pPrinter->pPrinterName);

   if ( sd.GetSecurity() )
   {
      sd.ResolveSD(args,stats,printer,NULL);
   }

   return rc;
}

int 
   ServerResolvePrinters(
      WCHAR          const * server,      // in -translate the printers on this server
      SecurityTranslatorArgs * args,      // in -translation settings
      TSDResolveStats      * stats        // in -stats 
   )
{
    DWORD                     rc = 0;
    PRINTER_INFO_4          * pInfo = NULL;
    BYTE                    * buffer = new BYTE[PRINT_BUFFER_SIZE];
    DWORD                     cbNeeded = PRINT_BUFFER_SIZE;
    DWORD                     nReturned = 0;

    if (!buffer)
    {
        rc = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (!rc && !EnumPrinters(PRINTER_ENUM_LOCAL,NULL,4,buffer,PRINT_BUFFER_SIZE,&cbNeeded,&nReturned) )
    {
        rc = GetLastError();
        if ( rc == ERROR_INSUFFICIENT_BUFFER )
        {
            // try again with a bigger buffer size
            delete [] buffer;
            buffer = NULL;

            buffer = new BYTE[cbNeeded];
            if (!buffer)
            {
                rc = ERROR_NOT_ENOUGH_MEMORY;
            }
            else if (! EnumPrinters(PRINTER_ENUM_LOCAL,NULL,4,buffer,cbNeeded,&cbNeeded,&nReturned) )
            {
                rc = GetLastError();
            }
            else
                rc = ERROR_SUCCESS;
        }
    }

    if ( ! rc )
    {
        pInfo = (PRINTER_INFO_4 *)buffer;
        for ( DWORD i = 0 ; i < nReturned && !args->Cache()->IsCancelled(); i++ )
        {
            ResolvePrinter(&(pInfo[i]),args,stats);
        }
    }
    else
    {
        err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_ENUMERATING_LOCAL_PRINTERS_D,rc);
    }

    if (args->Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_PRINTERS);

    delete [] buffer;

    return rc;
}
int 
   ServerResolveShares(
      WCHAR          const * server,      // in -enumerate and translate the shares on this server
      SecurityTranslatorArgs * args,      // in -translation settings
      TSDResolveStats      * stats        // in -stats (to display pathnames & pass to ResolveSD)
   )
{
    DWORD                     rc           = 0;
    DWORD                     numRead      = 0;
    DWORD                     totalEntries = 0;
    DWORD                     resumeHandle = 0;
    SHARE_INFO_0            * bufPtr       = NULL;
    WCHAR                     serverName[LEN_Computer];
    WCHAR                     fullPath[LEN_Path];
    WCHAR                   * pServerName = serverName;
    DWORD                     ttlRead = 0;

    if (!args->Cache()->IsCancelled())
    {
        if ( server )
        {
          safecopy(serverName,server);
        }
        else
        {
          pServerName = NULL;

        }

        do 
        {
          if (args->Cache()->IsCancelled())
            break;
          rc = NetShareEnum(pServerName,0,(LPBYTE *)&bufPtr,MAX_BUFFER_LENGTH,&numRead,&totalEntries,&resumeHandle);   
          
          if ( ! rc || rc == ERROR_MORE_DATA )
          {
             for ( UINT i = 0 ; i < numRead ; i++ )
             {
                // Process the SD   
                if ( pServerName )
                {
                   swprintf(fullPath,L"%s\\%s",pServerName,bufPtr[i].shi0_netname);
                }
                else
                {
                   swprintf(fullPath,L"%s",bufPtr[i].shi0_netname);
                }
               

                TShareSD             tSD(fullPath);

                if ( tSD.HasSecurity() )
                {   
                   stats->DisplayPath(fullPath,TRUE);          
                   tSD.ResolveSD(args,stats,share,NULL);
                }
             }
             ttlRead += numRead;
             resumeHandle = ttlRead;
             NetApiBufferFree(bufPtr);
          }
        } while ( rc == ERROR_MORE_DATA && numRead < totalEntries);

        if ( rc && rc != ERROR_MORE_DATA )
          err.SysMsgWrite(ErrE,rc,DCT_MSG_SHARE_ENUM_FAILED_SD,server,rc);
    }

    if (args->Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_SHARES);
    
    return rc;
}

void 
   ResolveFilePath(
      SecurityTranslatorArgs * args,          // in - translation options
      TSDResolveStats        * Stats,         // in - class to display stats
      WCHAR                  * path,          // in - path name
      bool                     validAlone,    // in - whether this object exists (false for share names and volume roots)
      bool                     containsWC,    // in - true if path contains wildcard
      bool                     iscontainer    // in - whether the starting path is a container
   )
{
   TFileSD                * pSD;
   
   if ( args->LogVerbose() ) 
      err.MsgWrite(0,DCT_MSG_PROCESSING_S,path);
  
   Stats->DisplayPath(path);
   
   if ( validAlone && ! containsWC )
   {
      pSD = new TFileSD(path);
	  if (!pSD)
	     return;
      if ( pSD->HasSecurity() )
         pSD->ResolveSD(args,
                        Stats,
                        iscontainer?directory:file,
                        NULL);
      delete pSD;
   }
   if  ( iscontainer || containsWC )
   {
      IteratePath(path,
                  args,
                  Stats,
                  NULL,
                  NULL,
                  containsWC);
   }

   if (args->Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_FILES);
      
}

void WriteOptions(SecurityTranslatorArgs * args)
{
//*   WCHAR                     cmd[1000] = L"SecurityTranslation ";;
   WCHAR                     cmd[1000];
   WCHAR                     arg[300];

   
   UStrCpy(cmd, GET_STRING(IDS_STOptions_Start));
   
   if ( args->NoChange() )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"WriteChanges:No ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_WriteChng));
   }   
   if ( args->TranslateFiles() )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"Files:Yes ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_Files));
   }
   if ( args->TranslateShares() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"Shares:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Shares));
   }
   if ( args->TranslateLocalGroups() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"LGroups:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_LocalGroup));
   }
   if ( args->TranslateUserRights() )
   {
//      UStrCpy(cmd + UStrLen(cmd),L"UserRights:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_URights));
   }
   if ( args->TranslatePrinters() )
   {
//      UStrCpy(cmd + UStrLen(cmd),L"UserRights:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Printers));
   }
   if ( args->TranslateUserProfiles() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"Profiles:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_Profiles));
   }
   if ( args->TranslateRecycler() )
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"RecycleBin:Yes ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_RBin));
   }
   
   if ( *args->LogFile() )
   {
//*      wsprintf(arg,L"LogFile:%S ",args->LogFile());
      wsprintf(arg,GET_STRING(IDS_STOptions_LogName),args->LogFile());
      UStrCpy(cmd +UStrLen(cmd), arg);
   }
   if ( args->TranslationMode() == ADD_SECURITY )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"TranslationMode:Add ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_AddMode));
   }
   else if ( args->TranslationMode() == REMOVE_SECURITY )
   {
//*      UStrCpy(cmd +UStrLen(cmd), L"TranslationMode:Remove ");
      UStrCpy(cmd +UStrLen(cmd), GET_STRING(IDS_STOptions_RemoveMode));
   }
   else 
   {
//*      UStrCpy(cmd + UStrLen(cmd),L"TranslationMode:Replace ");
      UStrCpy(cmd + UStrLen(cmd),GET_STRING(IDS_STOptions_ReplaceMode));
   }
   wsprintf(arg,L"%s %s ",args->Source(), args->Target());
   UStrCpy(cmd +UStrLen(cmd), arg);

   err.MsgWrite(0,DCT_MSG_GENERIC_S,&*cmd);
}

void 
   TranslateRecycler(
      SecurityTranslatorArgs * args,          // in - translation options
      TSDResolveStats        * Stats,         // in - class to display stats
      WCHAR                  * path           // in - drive name
   )
{
   err.MsgWrite(0,DCT_MSG_PROCESSING_RECYCLER_S,path);
   WCHAR                        folder[LEN_Path];
   WCHAR                const * recycler = L"RECYCLER";
   WCHAR                        strSid[200];
   WCHAR                        srcPath[LEN_Path];
   WCHAR                        tgtPath[LEN_Path];
   DWORD                        lenStrSid = DIM(strSid);
   _wfinddata_t                 fData;
//   long                         hRecycler;
   LONG_PTR                     hRecycler;
   PSID                         pSidSrc = NULL, pSidTgt = NULL;
   TRidNode                   * pNode;
   DWORD                        rc = 0;
   BOOL                         bUseMapFile = args->UsingMapFile();

   swprintf(folder,L"%s\\%s\\*",path,recycler);

   long                         mode = args->TranslationMode();

   // Windows 2000 checks the SD for the recycle bin when the recycle bin is opened.  If the SD does not match the 
   // default template (permissions for user, admin, and system), Windows displays a message that the recycle bin is corrupt.
   // This change may also be in NT 4 SP 7.  To avoid causing this corrupt recycle bin message, we will always translate the 
   // recycle bins in replace mode.   We will not change if we are doing a remove.
   if (args->TranslationMode() != REMOVE_SECURITY)
      args->SetTranslationMode(REPLACE_SECURITY);
   
   // use _wfind to look for hidden files in the folder
   for ( hRecycler = _wfindfirst(folder,&fData) ; hRecycler != -1 && ( rc == 0 ); rc = (DWORD)_wfindnext(hRecycler,&fData) )
   {
      pSidSrc = SidFromString(fData.name);
      if ( pSidSrc )
      {
         err.MsgWrite(0,DCT_MSG_PROCESSING_RECYCLE_FOLDER_S,fData.name);
         if (!bUseMapFile)
           pNode = (TRidNode*)args->Cache()->Lookup(pSidSrc);
         else
           pNode = (TRidNode*)args->Cache()->LookupWODomain(pSidSrc);
         if ( pNode && pNode != (TRidNode*)-1 )
         {
            if (!bUseMapFile)
                pSidTgt = args->Cache()->GetTgtSid(pNode);
            else
                pSidTgt = args->Cache()->GetTgtSidWODomain(pNode);
            // get the target directory name
            GetTextualSid(pSidTgt,strSid,&lenStrSid);
            if ( args->LogVerbose() )
               err.DbgMsgWrite(0,L"Target sid is: %ls",strSid);
            if ( ! args->NoChange() && args->TranslationMode() != REMOVE_SECURITY )
            {
               // rename the directory
               swprintf(srcPath,L"%s\\%s\\%s",path,recycler,fData.name);
               swprintf(tgtPath,L"%s\\%s\\%s",path,recycler,strSid);
               if ( ! MoveFile(srcPath,tgtPath) )
               {
                  rc = GetLastError();
                  if ( (rc == ERROR_ALREADY_EXISTS) && (args->TranslationMode() == REPLACE_SECURITY) )
                  {
                     // the target recycle bin already exists 
                     // attempt to rename it with a suffix, so we can rename the new bin to the SID
                     WCHAR         tmpPath[LEN_Path];
                     long          ndx = 0;

                     do 
                     {
                        swprintf(tmpPath,L"%ls%ls%ld",tgtPath,GET_STRING(IDS_RenamedRecyclerSuffix),ndx);   
                        if (! MoveFile(tgtPath,tmpPath) )
                        {
                           rc = GetLastError();
                           ndx++;
                        }
                        else
                        {
                           rc = 0;
                           err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,tgtPath,tmpPath);
                        }
                     } while ( rc == ERROR_ALREADY_EXISTS );
                     if ( ! rc )
                     {
                        // we have moved the pre-existing target recycler out of the way
                        // now retry the rename
                        if (! MoveFile(srcPath,tgtPath) )
                        {
                           err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                        }
                        else
                        {
                           err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,srcPath,tgtPath);
                           // run security translation on the new folder
                           ResolveFilePath(args,Stats,tgtPath,TRUE,FALSE,TRUE);      
                        }
                     }
                     else
                     {
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                     }
                  }
                  else
                  {
                     err.SysMsgWrite(ErrE,rc,DCT_MSG_RECYCLER_RENAME_FAILED_SD,pNode->GetAcctName(),rc);
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_RECYCLER_RENAMED_SS,srcPath,tgtPath);
                  // run security translation on the new folder
                  ResolveFilePath(args,Stats,tgtPath,TRUE,FALSE,TRUE);      
               }

            }
            free(pSidTgt);
         }
         FreeSid(pSidSrc);
      }   
   }
   // set the translation mode back to its original value
   args->SetTranslationMode(mode);
}

// if the specified node is a normal share, this attempts to convert it to a path
// using the administrative shares
void 
   BuildAdminPathForShare(
      TPathNode         * tnode,
      WCHAR             * adminShare
   )
{
   // if all else fails, return the same name as specified in the node
   UStrCpy(adminShare,tnode->GetPathName());

   SHARE_INFO_502       * shInfo = NULL;
   DWORD                  rc = 0;
   WCHAR                  shareName[LEN_Path];
   WCHAR                * slash = NULL;

   UStrCpy(shareName,tnode->GetPathName() + UStrLen(tnode->GetServerName()) +1);
   slash = wcschr(shareName,L'\\');
   if ( slash )
      *slash = 0;


   rc = NetShareGetInfo(tnode->GetServerName(),shareName,502,(LPBYTE*)&shInfo);
   if ( ! rc )
   {
      if ( *shInfo->shi502_path )
      {
         // build the administrative path name for the share
         UStrCpy(adminShare,tnode->GetServerName());
         UStrCpy(adminShare + UStrLen(adminShare),L"\\");
         UStrCpy(adminShare + UStrLen(adminShare),shInfo->shi502_path);
         WCHAR * colon = wcschr(adminShare,L':');
         if ( colon )
         {
            *colon = L'$';
            UStrCpy(adminShare + UStrLen(adminShare),L"\\");
            UStrCpy(adminShare + UStrLen(adminShare),slash+1);

         }
         else
         {
            // something went wrong -- revert to the given path
            UStrCpy(adminShare,tnode->GetPathName());
         }

      }
      NetApiBufferFree(shInfo);
   }
}
                              

// Main routine for resolving file and directory SD's.
int
   ResolveAll(
      SecurityTranslatorArgs * args,            // in- translation settings
      TSDResolveStats        * Stats            // in- counts of examined, changed objects, etc.
   )
{
   WCHAR                   * warg;
   WCHAR                   * machine;
   UINT                      errmode;                 
   int                       retcode = 0;
   TPathNode               * tnode;
   
   errmode = SetErrorMode(SEM_FAILCRITICALERRORS); 
  
   if ( ! retcode )
   {
      WriteOptions(args);
      Stats->InitDisplay(args->NoChange());

      err.MsgWrite(0,DCT_MSG_FST_STARTING);
      
      // Process Files and Directories
      if (! args->IsLocalSystem() )
      {
         TNodeListEnum        tenum;
         for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)args->PathList()) ; tnode && !args->Cache()->IsCancelled(); tnode = (TPathNode *)tenum.Next() )
         {
            DWORD               rc;
            BOOL                needToGetBR = FALSE;
//            BOOL                abort = FALSE;
//            BOOL                firstTime = TRUE;

            warg = tnode->GetPathName();
            machine = GetMachineName(warg);
         
            needToGetBR = ( args->TranslateFiles() );

            if ( *tnode->GetServerName() && ! args->IsLocalSystem() )
            {
               warg = tnode->GetPathName();
               err.MsgWrite(0,DCT_MSG_PROCESSING_S,warg);
               if ( args->TranslateFiles() && !args->Cache()->IsCancelled())
               {
                  if ( needToGetBR )
                  {
			            //get needed privileges and keep them until the agent removes itself
                     GetBkupRstrPriv(tnode->GetServerName());
                  }
                  if ( IsMachineName(warg) )
                  {
                     // need to process each drive on this machine
                     TVolumeEnum          vEnum;
      
                     rc = vEnum.Open(warg,VERIFY_PERSISTENT_ACLS,args->LogVerbose());
                     if ( rc ) 
                     {
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_ACCESSING_DRIVES_SD,warg,rc);
                     }
                     else
                     {
                        while ( (warg = vEnum.Next()) && !args->Cache()->IsCancelled())
                        {

                           ResolveFilePath(args,
                                           Stats,
                                           warg,
                                           false,     // not valid alone
                                           false,     // no wildcard
                                           true );    // container
                        }
                        warg = machine;
                     }
                     vEnum.Close();
                  }
                  else
                  {
                     WCHAR                   adminShare[LEN_Path];
                     
                     // Verify that the volume is NTFS
                     rc = tnode->VerifyPersistentAcls();
                     switch ( rc )
                     {
                     case ERROR_SUCCESS:   
                        // Process the path
                     
                        // if it's a share name, process the root of the share
                        if( IsShareName(tnode->GetPathName()) ) 
                        {
                           WCHAR       sharePath[LEN_Path];
                        
                           swprintf(sharePath,L"%s\\.",tnode->GetPathName());
                           TFileSD     sd(sharePath);
                           if ( sd.HasSecurity() )
                           {  
                              sd.ResolveSD(args,
                                             Stats,
                                             directory,
                                             NULL);
                           }
                        }
                        // if this is a normal share, convert it to an administrative share 
                        // path, so that we can take advantage of backup/restore privileges
                        BuildAdminPathForShare(tnode,adminShare);
                        ResolveFilePath(args,
                                        Stats,
                                        adminShare,
                                        !IsShareName(tnode->GetPathName()),
                                        ContainsWildcard(tnode->GetPathName()),
                                        tnode->IsContainer() || IsShareName(tnode->GetPathName()));
                        break;
                     case ERROR_NO_SECURITY_ON_OBJECT:
                        err.MsgWrite(ErrW,DCT_MSG_SKIPPING_FAT_VOLUME_S,warg);
                        break;
                     default:
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_SKIPPING_PATH_SD,warg,rc );
                        break;
                     }
                  }         
               }
               // Process the shares for this machine
               if ( args->TranslateShares() && !args->Cache()->IsCancelled())
               {
                  if ( IsMachineName(warg) )
                  {
                     err.MsgWrite(0,DCT_MSG_PROCESSING_SHARES_S,tnode->GetServerName());
                     ServerResolveShares(tnode->GetServerName(),args,Stats);
                  }
                  else if  ( IsShareName(warg) )
                  {
                     TShareSD      sd(warg);
         
                     if ( sd.HasSecurity() )
                     {
                        if ( args->LogVerbose() )
                        {
                           err.MsgWrite(0,DCT_MSG_PROCESSING_SHARE_S,warg);
                        }
                        sd.ResolveSD(args,
                                    Stats,
                                    share,
                                    NULL);
                     }
                  }
               }
            }
            else 
            {
               // this is a local path
               // Verify that the volume is NTFS
               DWORD            rc2;
         
			      //get needed privileges and keep them until the agent removes itself
               GetBkupRstrPriv((WCHAR*)NULL);
               
               rc2 = tnode->VerifyPersistentAcls();
               switch ( rc2 )
               {
               case ERROR_SUCCESS:   
                  // Process the path
                  if ( args->TranslateFiles() )
                  {
                     ResolveFilePath(args,
                                  Stats,
                                  tnode->GetPathName(),
                                  true,      // isValidAlone
                                  ContainsWildcard(tnode->GetPathName()),
                                  tnode->IsContainer() );
                  }
                  break;
               case ERROR_NO_SECURITY_ON_OBJECT:
                  err.MsgWrite(ErrW,DCT_MSG_SKIPPING_FAT_VOLUME_S,warg);
                  break;
               default:
                  err.SysMsgWrite(ErrE,rc2,DCT_MSG_SKIPPING_PATH_SD,warg,rc2 );
                  break;
               }
      
            }
            if ( machine ) 
            {
               delete machine;
               machine = NULL;
            }
         }
         tenum.Close();
      }
      else
      {
         // Translate the entire machine
         err.MsgWrite(0,DCT_MSG_LOCAL_TRANSLATION);
         if ((args->TranslateFiles() || args->TranslateRecycler()) && !args->Cache()->IsCancelled() )
         {
			   //get needed privileges and keep them until the agent removes itself
            GetBkupRstrPriv((WCHAR const*)NULL);
            // need to process each drive on this machine
            TVolumeEnum          vEnum;

            vEnum.SetLocalMode(TRUE);

            DWORD rc2 = vEnum.Open(NULL,VERIFY_PERSISTENT_ACLS,args->LogVerbose());
            if ( rc2 ) 
            {
               err.SysMsgWrite(ErrE,rc2,DCT_MSG_ERROR_ACCESSING_LOCAL_DRIVES_D,rc2);
            }
            else
            {
               while ( (warg = vEnum.Next()) && !args->Cache()->IsCancelled())
               {
                  err.MsgWrite(0,DCT_MSG_PROCESSING_S,warg);
                  
                  if ( args->TranslateFiles() )
                  {
                     ResolveFilePath(args,
                                  Stats,
                                  warg,
                                  false,     // not valid alone
                                  false,     // no wildcard
                                  true );    // container
                  }
                  if ( args->TranslateRecycler() )
                  {
                     TranslateRecycler(args,Stats,warg);
                  }
               }
               warg = NULL;
            }
            vEnum.Close();
         }
         if ( args->TranslateShares() && !args->Cache()->IsCancelled())
         {
            err.MsgWrite(0,DCT_MSG_PROCESSING_LOCAL_SHARES,NULL);
            ServerResolveShares(NULL,args,Stats);
         }
         if ( args->TranslatePrinters() && !args->Cache()->IsCancelled())
         {
            // for printer security translation, we also need to turn on the privilege
            if (GetBkupRstrPriv(NULL, TRUE) == FALSE)
                err.MsgWrite(ErrE, DCT_MSG_UNABLE_TO_OBTAIN_BACKUP_RESTORE_PRIVILEGES, GetLastError());
            err.MsgWrite(0,DCT_MSG_PROCESSING_LOCAL_PRINTERS,NULL);
            ServerResolvePrinters(NULL,args,Stats);
            // turn off the privilege
            if (GetBkupRstrPriv(NULL, FALSE) == FALSE)
                err.MsgWrite(ErrW, DCT_MSG_UNABLE_TO_RELEASE_BACKUP_RESTORE_PRIVILEGES, GetLastError());
         }
      }
      Stats->DisplayPath(L"");
   } // end if ( ! retcode)

   SetErrorMode(errmode);
   
   return retcode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdresolv_stkoflw.h ===
#include <windows.h>

void
   IteratePathUnderlying(
      WCHAR                  * path,          /* in -path to start iterating from */
      void                   * args,          /* in -translation settings */
      void                   * stats,         /* in -stats (to display pathnames & pass to ResolveSD) */
      void                   * LC,            /* in -last container */
      void                   * LL,            /* in -last file */
      BOOL                     haswc          /* in -indicates whether path contains a wc character */
   );

UINT
   IteratePathUnderlyingNoObjUnwinding(
      WCHAR                  * path,          /* in -path to start iterating from */
      void                   * args,          /* in -translation settings */
      void                   * stats,         /* in -stats (to display pathnames & pass to ResolveSD) */
      void                   * LC,            /* in -last container */
      void                   * LL,            /* in -last file */
      BOOL                     haswc,          // in -indicates whether path contains a wc character
      BOOL                   * logError
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdresolv_stkoflw.c ===
// due to a problem in resetstk_downlevel.c, this .c file
// has to be created to avoid a compilation error

#include <resetstk_downlevel.c>
#include "sdresolv_stkoflw.h"

UINT
   IteratePathUnderlyingNoObjUnwinding(
      WCHAR                  * path,          // in -path to start iterating from
      void                   * args,          // in -translation settings
      void                   * stats,         // in -stats (to display pathnames & pass to ResolveSD)
      void                   * LC,            // in -last container
      void                   * LL,            // in -last file
      BOOL                     haswc,          // in -indicates whether path contains a wc character
      BOOL                   * logError
   )
{
    UINT status = 0;
    *logError = FALSE;
    __try
    {
        IteratePathUnderlying(path,args,stats,LC,LL,haswc);
    }
    __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
    {
        if (_resetstkoflw_downlevel()) 
		    *logError = TRUE;
        else
            status = STATUS_STACK_OVERFLOW;
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\secobj_stub.cpp ===
/* This is a stub to include common\commonlib\secobj.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "secobj.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdstat.hpp ===
//#pragma title ("SDStat.hpp -- Statistical information for SDResolve")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdstat.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Statistical information for SDResolve
Updates     -
===============================================================================
*/

#ifndef SDSTAT_HEADER 
#define SDSTAT_HEADER

#include "stdafx.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

#include "ResStr.h"

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif

class TSidCache;
class TSDRidCache;
class TPathList;
class TSecurableObject;
class TAcctNode;

enum objectType { file = 1,directory,share,mailbox,container,groupmember, userright, regkey, printer };


typedef DWORD StatCell ;
struct TSDFileDirCell
{  
   StatCell                  file;
   StatCell                  dir;
   StatCell                  share;
   StatCell                  mailbox;
   StatCell                  container;
   StatCell                  member;
   StatCell                  userright;
   StatCell                  regkey;
   StatCell                  printer;
};
   
struct TSDFileActions
{
   TSDFileDirCell            examined;
   TSDFileDirCell            changed;
   TSDFileDirCell            skipped;
   TSDFileDirCell            error;
   TSDFileDirCell            cachehit;
};
struct TSDPartActions
{
   StatCell                   examined;
   StatCell                   changed;
   StatCell                   notselected;
   StatCell                   unknown;
   StatCell                   notarget;
 
};
struct TSDPartStats
{
   TSDPartActions            owner;
   TSDPartActions            group;
   TSDPartActions            dacl;
   TSDPartActions            sacl;
   TSDPartActions            dace;
   TSDPartActions            sace;
};

#define FILE_ROW         1
#define DIR_ROW          2
#define DACL_ROW         3
#define SACL_ROW         4
#define OWNER_ROW        6
#define GROUP_ROW        7
#define DACE_ROW         8
#define SACE_ROW         9

#define EXAMINED_COL     1
#define CHANGED_COL      2
#define NOTARGET_COL     3
#define NOTSELECTED_COL  4
#define UNKNOWN_COL      5

class TStatNode:public TNode
{
public:
   TAcctNode                * acctnode;
   BOOL                       changed;
   enum ChangeType { owner , group, dace, sace } changetype;
   
   
   TStatNode(TAcctNode * acct, ChangeType type, BOOL bChanged) { acctnode = acct; changetype = type; changed = bChanged; }
};

class TSDResolveStats 
{
protected:

   TSDPartStats              part;
   TSDFileActions            unit;
 
   WORD                      background;                        
   WORD                      frame_foreground;
   WORD                      data_foreground;
   WORD                      message_foreground ;

   TSDRidCache             * pCache;
   const TPathList         * pPList;
   HANDLE                    csbuffer;
   USHORT                    len;
//   CStatsWnd               * wnd;
   IVarSet                 * m_pVarSet;
   
public:
      TSDResolveStats(TSDRidCache * cache, const TPathList * plist, IVarSet * pVarSet);
      TSDResolveStats(TSDRidCache * cache);
   

//   void SetWindow(CStatsWnd *w ) { wnd = w; }
   void IncrementOwnerChange(TAcctNode * acct, objectType type, TSecurableObject *file); 
   void IncrementGroupChange(TAcctNode * acct, objectType type, TSecurableObject *file);
   void IncrementDACEChange (TAcctNode * acct, objectType type, TSecurableObject *file);  
   void IncrementSACEChange (TAcctNode * acct, objectType type, TSecurableObject *file);  
   void IncrementOwnerExamined () { part.owner.examined++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Examined),(LONG)part.owner.examined);} 
   void IncrementGroupExamined () { part.group.examined++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Examined),(LONG)part.group.examined);}
   void IncrementDACLExamined () { part.dacl.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Examined),(LONG)part.dacl.examined);}
   void IncrementSACLExamined () { part.sacl.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Examined),(LONG)part.sacl.examined);}
   void IncrementDACEExamined () { part.dace.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Examined),(LONG)part.dace.examined);}
   void IncrementSACEExamined () { part.sace.examined++; if ( m_pVarSet )   m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Examined),(LONG)part.sace.examined);}
   
   void IncrementOwnerNoTarget () { part.owner.notarget++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NoTarget),(LONG)part.owner.notarget);}
   void IncrementGroupNoTarget () { part.group.notarget++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NoTarget),(LONG)part.group.notarget);}
   void IncrementDACENoTarget (TSecurableObject *file);
   void IncrementSACENoTarget (TSecurableObject *file);

   void IncrementOwnerNotSelected () { part.owner.notselected++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NotSelected),(LONG)part.owner.notselected);}
   void IncrementGroupNotSelected () { part.group.notselected++; if ( m_pVarSet )  m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NotSelected),(LONG)part.group.notselected);}
   void IncrementDACENotSelected  (TSecurableObject *file);
   void IncrementSACENotSelected  (TSecurableObject *file);

   void IncrementOwnerUnknown () { part.owner.unknown++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Unknown),(LONG)part.owner.unknown);}
   void IncrementGroupUnknown () { part.group.unknown++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Unknown),(LONG)part.group.unknown);}
   void IncrementDACEUnknown (TSecurableObject *file);
   void IncrementSACEUnknown (TSecurableObject *file);


   void IncrementLastFileChanges(const TSecurableObject *lastfile, objectType container);
   void IncrementCacheHit(objectType type) { 
      switch ( type )
      {
      case file:
         unit.cachehit.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_CacheHits),(LONG)unit.cachehit.file); 
            break;
      case directory:
         unit.cachehit.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_CacheHits),(LONG)unit.cachehit.dir);
            break;
      case share:
         unit.cachehit.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_CacheHits),(LONG)unit.cachehit.share);
            break;
      case mailbox:
         unit.cachehit.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_CacheHits),(LONG)unit.cachehit.mailbox);
            break;
      case container:
         unit.cachehit.container++; 
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_CacheHits),(LONG)unit.cachehit.container);
            break;
      case groupmember:
         unit.cachehit.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_CacheHits),(LONG)unit.cachehit.member);
            break;
      case userright:
         unit.cachehit.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_CacheHits),(LONG)unit.cachehit.userright);
         break;
      case regkey:
         unit.cachehit.regkey++;
         // TODO:  if (m_pVarSet ) ...
         break;
      case printer:
         unit.cachehit.printer++;
         // TODO:  if (m_pVarSet ) ...
         break;         
      default:
         MCSASSERT(FALSE); // invalid type
         if ( m_pVarSet ) 
            break;
      }
   }
   void IncrementChanged(objectType type) { 
      switch ( type)
      {
      case file:
         unit.changed.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Changed),(LONG)unit.changed.file);
         break;
      case directory:
         unit.changed.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Changed),(LONG)unit.changed.dir);
            break;
      case share:
         unit.changed.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Changed),(LONG)unit.changed.share);
            break;
      case mailbox:
         unit.changed.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Changed),(LONG)unit.changed.mailbox);
            break;
      case container:
         unit.changed.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Changed),(LONG)unit.changed.container);
            break;
      case groupmember:
         unit.changed.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Changed),(LONG)unit.changed.member);
            break;
      case userright:
         unit.changed.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Changed),(LONG)unit.changed.userright);
            break;
      case regkey:
         unit.changed.regkey++;
         // TODO: if ( m_pVarSet ) ...
         break;
      case printer:
         unit.changed.printer++;
         // TODO: if ( m_pVarSet ) ...
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementExamined(objectType type) { 
      switch ( type)
      {
      case file:
         unit.examined.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Examined),(LONG)unit.examined.file);
         break;
      case directory:
         unit.examined.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Examined),(LONG)unit.examined.dir); 
         break;
      case share:
         unit.examined.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Examined),(LONG)unit.examined.share);
         break;
      case mailbox:
         unit.examined.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Examined),(LONG)unit.examined.mailbox);
         break;
      case container:
         unit.examined.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Examined),(LONG)unit.examined.container);
         break;
      case groupmember:
         unit.examined.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Examined),(LONG)unit.examined.member);
         break;
      case userright:
         unit.examined.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Examined),(LONG)unit.examined.userright);
         break;
      case regkey:
         unit.examined.regkey++;
         //TODO:  if ( m_pVarSet ) m_pVarSet->put(
         break;
      case printer:
         unit.examined.printer++;
         //TODO:  if ( m_pVarSet ) m_pVarSet->put(
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementSkipped(objectType type) { 
      switch ( type)
      {
      case file:
         unit.skipped.file++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Skipped),(LONG)unit.skipped.file);
         break;
      case directory:
         unit.skipped.dir++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Skipped),(LONG)unit.skipped.dir);
         break;
      case share:
         unit.skipped.share++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Skipped),(LONG)unit.skipped.share);
         break;
      case mailbox:
         unit.skipped.mailbox++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Skipped),(LONG)unit.skipped.mailbox);
         break;
      case container:
         unit.skipped.container++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Skipped),(LONG)unit.skipped.container);
         break;
      case groupmember:
         unit.skipped.member++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_Members_Skipped),(LONG)unit.skipped.member);
         break;
      case userright:
         unit.skipped.userright++;
         if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_UserRights_Skipped),(LONG)unit.skipped.userright);
         break;
      case regkey:
         unit.skipped.regkey++;
         // TODO:  if ( m_pVarSet ) ...
         break;
      case printer:
         unit.skipped.printer++;
         // TODO:  if ( m_pVarSet ) ...
         break;
      default:
         MCSASSERT(FALSE); // invalid type
         break;
      }
   }
   void IncrementDACLChanged()   { part.dacl.changed++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Changed),(LONG)part.dacl.changed);} //DisplayStatItem(DACL_ROW,CHANGED_COL,part.dacl.changed); }
   void IncrementSACLChanged()   { part.sacl.changed++; if ( m_pVarSet ) m_pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Changed),(LONG)part.sacl.changed);} //DisplayStatItem(SACL_ROW,CHANGED_COL,part.sacl.changed); }
   void Report(BOOL summary,BOOL acct_detail,BOOL pathdetail) const;  
   void InitDisplay(BOOL nochange);
   void DisplayStatFrame(BOOL nochange);
   void DisplayStatItem(SHORT row, SHORT col, DWORD val, BOOL forceRedraw = FALSE);
   void DisplayBox(SHORT x1, SHORT y1, SHORT x2, SHORT y2); 
   void DisplayPath(LPWSTR str,BOOL forceRedraw = FALSE);
   void SetFrameText(WCHAR * msg);

   void ReportToVarSet(IVarSet * pVarSet,DWORD verbnum) const;
  
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sdstat.cpp ===
//#pragma title ("SDStat.hpp -- Statistical information for SDResolve")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sdstat.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Statistical information for SDResolve
Updates     -
===============================================================================
*/

#include "stdafx.h"
#include <stdio.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "sidcache.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "enumvols.hpp"
#include "sdstat.hpp"

#include "Mcs.h"


extern TErrorDct        err;

   TSDResolveStats::TSDResolveStats(
      TSDRidCache          * cache,       // in - cache containing mapping of accounts for the translation
      const TPathList      * plist,       // in - list of paths being translated
      IVarSet              * pVarSet      // in - varset to store stats in
   )
{
   memset(&unit,0,sizeof TSDFileActions);
   memset(&part,0,sizeof TSDPartStats);
   pPList = plist;
   len = 0;
   frame_foreground =FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN ;                        
   background = BACKGROUND_BLUE ;
   data_foreground =frame_foreground | FOREGROUND_INTENSITY ;
   message_foreground = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
   pCache = cache;
   m_pVarSet = pVarSet;
   }



   TSDResolveStats::TSDResolveStats(
      TSDRidCache          * cache        // in - cache containing mapping of accounts for translation
   )  
{
   memset(&unit,0,sizeof TSDFileActions);
   memset(&part,0,sizeof TSDPartStats);
   pPList = NULL;
   len = 0;
   frame_foreground =FOREGROUND_BLUE | FOREGROUND_RED | FOREGROUND_GREEN ;                        
   background = BACKGROUND_BLUE ;
   data_foreground =frame_foreground | FOREGROUND_INTENSITY ;
   message_foreground = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_INTENSITY;
   pCache = cache;
	//Added by Sham : Initialize m_pVarSet
	IVarSetPtr pVarSet(__uuidof(VarSet));
	m_pVarSet = pVarSet;
	// Need to add code to release this interface once we are done. In the destructor maybe
	m_pVarSet->AddRef();
}
void 
   TSDResolveStats::IncrementOwnerChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed 
   ) 
{ 
    acct->AddOwnerChange(type);
    part.owner.changed++;
    if ( file )
        file->LogOwnerChange(acct);
}

void 
   TSDResolveStats::IncrementGroupChange(
      TAcctNode            * acct,                    // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                     // in -file changed
   ) 
{ 
    acct->AddGroupChange(type); 
    part.group.changed++;
    if ( file )
        file->LogGroupChange(acct);
}
   
void 
   TSDResolveStats::IncrementDACEChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed
   )  
{ 
    acct->AddAceChange(type); 
    part.dace.changed++;
    if ( file )
        file->LogDACEChange(acct); 
}

void 
   TSDResolveStats::IncrementSACEChange(
      TAcctNode            * acct,                // in -account changed
      objectType             type,                // in -type of object
      TSecurableObject     * file                 // in -file changed
   )  
{ 
    acct->AddSaceChange(type); 
    part.sace.changed++;
    if ( file )
        file->LogSACEChange(acct); 
}

void 
   TSDResolveStats::IncrementDACENotSelected(
      TSecurableObject *file               // in - object to increment stats for
   ) 
{ 
   file->daceNS++;  
   part.dace.notselected++; 
}
void 
   TSDResolveStats::IncrementSACENotSelected(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->saceNS++;  
   part.sace.notselected++; 
}

void 
   TSDResolveStats::IncrementDACEUnknown(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->daceU++;  
   part.dace.unknown++; 
}
void 
   TSDResolveStats::IncrementSACEUnknown(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if  ( file )
      file->saceU++;  
   part.sace.unknown++; 
}

void 
   TSDResolveStats::IncrementDACENoTarget(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->daceNT++;  
   part.dace.notarget++; 
}
void 
   TSDResolveStats::IncrementSACENoTarget(
      TSecurableObject *file              // in - object to increment stats for
   ) 
{ 
   if ( file )
      file->saceNT++;  
   part.sace.notarget++; 
}

/***************************************************************************************************/
/* IncrementLastFileChanges: used in conjunction with last-seen heuristic.  When a SD matches the 
                          last-seen SD, this routine repeats all the stat-updates 
                          that were done for the last-seen SD, so that we have accurate stats 
                          (especially ACE changes per account)
/**************************************************************************************************/
void 
   TSDResolveStats::IncrementLastFileChanges(
      const TSecurableObject            * lastfile,                 // in -file to repeat change stats from
      objectType                       objType                   // in -type of object
   )
{
   TNodeListEnum             tenum;
   TStatNode               * snode;
   
   // make modifications except changes
   // owner
   IncrementOwnerExamined();
   IncrementGroupExamined();
   
   if ( lastfile->UnknownOwner() )
      part.owner.unknown++;
  
   // group
   if ( lastfile->UnknownGroup() )
      part.group.unknown++;
   // dacl
   if ( lastfile->HasDacl() )
      IncrementDACLExamined();
   // sacl 
   if ( lastfile->HasSacl() )
      IncrementSACLExamined();
   // aces
   part.dace.notarget+=lastfile->daceNT;
   part.sace.notarget+=lastfile->saceNT;
   part.dace.unknown+=lastfile->daceU;
   part.sace.unknown+=lastfile->saceU;
   part.dace.notselected+=lastfile->daceNS;
   part.sace.notselected+=lastfile->saceNS;
   if ( lastfile->Changed() )
   {
      IncrementChanged(objType);
   }
     
   if ( lastfile->Changed() || (lastfile->GetChangeLog())->Count() )
   {
      if ( lastfile->IsDaclChanged() )
      {
         IncrementDACLChanged();
      }
      if ( lastfile->IsSaclChanged() )
      {
         IncrementSACLChanged();
      }
      for ( snode = (TStatNode *)tenum.OpenFirst(lastfile->GetChangeLog()) ; 
            snode ;
            snode = (TStatNode *)tenum.Next()
          )
      {             
         switch ( snode->changetype )
         {
            case TStatNode::owner: 
               IncrementOwnerChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::group: 
               IncrementGroupChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::dace: 
               IncrementDACEChange(snode->acctnode,objType,NULL);
               break;
            case TStatNode::sace: 
               IncrementSACEChange(snode->acctnode,objType,NULL);
               break;
           default: 
               MCSASSERT( false );
         }
      }
      tenum.Close();
   }
}

void 
   TSDResolveStats::ReportToVarSet(
      IVarSet              * pVarSet,     // in -varset to write data to
      DWORD                  verbnum      // in -which info to log
   ) const
{        
   BOOL                      summary = verbnum & SUMMARYSTATS;
   BOOL                      accts   = verbnum & ACCOUNTSTATS;
//   BOOL                      file    = verbnum & FILESTATS;
   BOOL                      paths   = verbnum & PATHSTATS;
     
   if ( summary )
   {
      if ( paths && pPList )
      {
         pVarSet->put(GET_BSTR(DCTVS_Stats_Paths),(LONG)pPList->GetNumPaths() );
      
         pVarSet->put(GET_BSTR(DCTVS_Stats_Servers),(LONG)pPList->GetNumServers() );
      }
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Examined),(LONG)unit.examined.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Examined),(LONG)unit.examined.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Examined),(LONG)unit.examined.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Examined),(LONG)unit.examined.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Examined),(LONG)unit.examined.container);
      
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_CacheHits),(LONG)unit.cachehit.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_CacheHits),(LONG)unit.cachehit.dir);
      
      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Skipped),(LONG)unit.skipped.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Skipped),(LONG)unit.skipped.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Skipped),(LONG)unit.skipped.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Skipped),(LONG)unit.skipped.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Skipped),(LONG)unit.skipped.container);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Files_Changed),(LONG)unit.changed.file);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Directories_Changed),(LONG)unit.changed.dir);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Shares_Changed),(LONG)unit.changed.share);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Mailboxes_Changed),(LONG)unit.changed.mailbox);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Containers_Changed),(LONG)unit.changed.container);

      

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Examined),(LONG)part.owner.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Examined),(LONG)part.group.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Examined),(LONG)part.dacl.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Examined),(LONG)part.sacl.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Examined),(LONG)part.dace.examined);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Examined),(LONG)part.sace.examined);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Changed),(LONG)part.owner.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Changed),(LONG)part.group.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACL_Changed),(LONG)part.dacl.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACL_Changed),(LONG)part.sacl.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Changed),(LONG)part.dace.changed);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Changed),(LONG)part.sace.changed);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_NoTarget),(LONG)part.owner.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_NoTarget),(LONG)part.group.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_NoTarget),(LONG)part.dace.notarget);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_NoTarget),(LONG)part.sace.notarget);

      pVarSet->put(GET_BSTR(DCTVS_Stats_Owners_Unknown),(LONG)part.owner.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Groups_Unknown),(LONG)part.group.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_DACE_Unknown),(LONG)part.dace.unknown);
      pVarSet->put(GET_BSTR(DCTVS_Stats_SACE_Unknown),(LONG)part.sace.unknown);

   }  
   if ( accts ) 
      pCache->ReportToVarSet(pVarSet,false, true);

}


void 
   TSDResolveStats::Report(
      BOOL                   summary,     // in -flag, whether to report summary information
      BOOL                   accts,       // in -flag, whether to report account detail information
      BOOL                   paths        // in -flag, whether to report path detail information
   ) const
{        
   if ( accts ) 
      pCache->Display(summary!=0, accts!=0);
#ifdef FST
   if ( paths & pPList )
      pPList->Display();
#endif
     if ( summary )
   {
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_HEADER);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_FILES_DDD,unit.examined.file, unit.changed.file, unit.examined.file - unit.changed.file);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_DIRS_DDD,unit.examined.dir, unit.changed.dir, unit.examined.dir - unit.changed.dir);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_SHARES_DDD,unit.examined.share, unit.changed.share, unit.examined.share - unit.changed.share);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_MEMBERS_DDD,unit.examined.member, unit.changed.member, unit.examined.member - unit.changed.member);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_RIGHTS_DDD,unit.examined.userright, unit.changed.userright, unit.examined.userright - unit.changed.userright);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_MAILBOXES_DDD,unit.examined.mailbox, unit.changed.mailbox, unit.examined.mailbox - unit.changed.mailbox);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_CONTAINERS_DDD,unit.examined.container, unit.changed.container, unit.examined.container - unit.changed.container);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_DACLS_DDD,part.dacl.examined, part.dacl.changed, part.dacl.examined - part.dacl.changed);
      err.MsgWrite(0,DCT_MSG_SUMMARY_REPORT_SACLS_DDD,part.sacl.examined, part.sacl.changed, part.sacl.examined - part.sacl.changed);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_HEADER);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_OWNERS_DDDDD,part.owner.examined, part.owner.changed, part.owner.notarget, part.owner.examined - part.owner.changed - part.owner.notarget - part.owner.unknown, part.owner.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_GROUPS_DDDDD,part.group.examined, part.group.changed, part.group.notarget, part.group.examined - part.group.changed - part.group.notarget - part.group.unknown ,part.group.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_DACES_DDDDD,part.dace.examined, part.dace.changed, part.dace.notarget,part.dace.notselected,part.dace.unknown);
      err.MsgWrite(0,DCT_MSG_SUMMARY_PARTS_REPORT_SACES_DDDDD,part.sace.examined, part.sace.changed, part.sace.notarget,part.sace.notselected,part.sace.unknown);
   }

}
#define HDR1ITEMS  2
#define HDRCOL1    8
#define HDRROW1    4
#define COLWIDTH   12
#define HDRCOL2    ( HDRCOL1 + COLWIDTH )
#define HDRROW2    ( HDRROW1 + ( 2 * HDR1ITEMS + 1) + 1)

void 
   TSDResolveStats::InitDisplay(
      BOOL                   nochange        
   )
{
}

// no longer used
void 
   TSDResolveStats::DisplayStatFrame(
      BOOL                   nochange
)
{
   
}
// no longer used 
void TSDResolveStats::DisplayStatItem(SHORT row, SHORT col, DWORD val, BOOL forceUpdate)
{

}

DWORD             dwLastUpdate = 0;

void 
   TSDResolveStats::DisplayPath(LPWSTR str,BOOL forceUpdate)
{
   DWORD                     now = GetTickCount();

   if ( m_pVarSet )
   {
      m_pVarSet->put(GET_BSTR(DCTVS_CurrentPath),str);
      if ( now - dwLastUpdate > 1000 ) 
      {
         ReportToVarSet(m_pVarSet,SUMMARYSTATS);
         dwLastUpdate = GetTickCount();
      }
   }
}
void 
   TSDResolveStats::DisplayBox(SHORT x1, SHORT y1, SHORT x2, SHORT y2)
{
}
   
void 
TSDResolveStats::SetFrameText(WCHAR * msg)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sectrans.cpp ===
/*Copyright (c) 1995-1999, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecTranslator.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  97/06/27
Description -  COM object that controls the security translation process.
               Reads the settings for the translation and performs the necessary
               operations.  

Updates     -
===============================================================================
*/
// SecTranslator.cpp : Implementation of CSecTranslator
#include "stdafx.h"
#include "WorkObj.h"
#include "SecTrans.h"

#include "Mcs.h"     
#include "EaLen.hpp"     
#include "BkupRstr.hpp"
#include "exchange.hpp"            
#include "ErrDct.hpp"

#include "SDStat.hpp" 
#include "sd.hpp"
#include "SecObj.hpp"
#include "LGTrans.h"
#include "RightsTr.h"
#include "RegTrans.h"
#include "BkupRstr.hpp"
#include "TReg.hpp"
#include "TxtSid.h"
#include "GetDcName.h"
#include "folders.h"

using namespace nsFolders;

#include "LSAUtils.h"
#include "Checker.h"
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids
#import "WorkObj.tlb"
#include "varset_i.c"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#if (_WIN32_WINNT < 0x0500)
#define LOGON32_LOGON_NEW_CREDENTIALS 9
#define LOGON32_PROVIDER_WINNT50 3
#endif

#ifndef IStatusObjPtr
_COM_SMARTPTR_TYPEDEF(IStatusObj, __uuidof(IStatusObj));
#endif


/////////////////////////////////////////////////////////////////////////////
// CSecTranslator

#define BACKUP_FAILED   5
#define BAD_PATH        6
#define BAD_LOG         2
#define LEN_SID         200

extern TErrorDct   err;
extern TErrorDct  errAlt;  // this is used for logging errors that occur after dispatcher is launched; use migration.log
extern bool useErrAlt;      // whether to use errAlt

// Defined in EnumVols.cpp
bool                                   // ret -true if name begins with "\\" has at least 3 total chars, and no other '\'
   IsMachineName(
      const LPWSTR           name      // in -possible machine name to check
   );

DWORD                                      // ret- OS return code
   GetProgramFilesDirectory(
      WCHAR                * directory,    // out- location of program files directory
      WCHAR          const * computer      // in - computer to find PF directory on
   )
{
   TRegKey                   hklm;
   TRegKey                   key;
   DWORD                     rc;

   rc = hklm.Connect(HKEY_LOCAL_MACHINE,computer);
   if ( ! rc )
   {
      rc = key.Open(REGKEY_CURRENT_VERSION,&hklm);
   }
   if ( !rc )
   {
      rc = key.ValueGetStr(REGVAL_PROGRAM_FILES_DIRECTORY,directory,MAX_PATH * (sizeof WCHAR));
   }
   return rc;
}


BOOL 
   IsLocallyInstalled()
{
   BOOL                      bFound;
   TRegKey                   key;
   DWORD                     rc;


   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key));
   if ( ! rc )
   {
      bFound = TRUE;
   }
   else
   {
      bFound = FALSE;
   }
   return bFound;
}


DWORD                                      // ret- OS return code
   GetLocalMachineName(WCHAR * computer)
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * buf = NULL;

   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&buf);
   if ( ! rc )
   {
      UStrCpy(computer,L"\\\\");
      UStrCpy(computer+2,buf->wki100_computername);
      NetApiBufferFree(buf);
   }
   return rc;
}

BOOL 
   IsThisDispatcherMachine(IVarSet * pVarSet)
{
   BOOL                     bIsIt = FALSE;
   _bstr_t                  dispatcher = pVarSet->get(GET_BSTR(DCTVS_Options_Credentials_Server));
   WCHAR                    localComputer[LEN_Computer] = L"";
   
   GetLocalMachineName(localComputer);

   if ( ! UStrICmp(dispatcher,localComputer) )
   {
      bIsIt = TRUE;
   }
   return bIsIt;
}

class TSession : public TNode
{
   WCHAR                     server[LEN_Computer];
public:
   TSession(WCHAR const * s) { safecopy(server,s); }
   WCHAR             const * ServerName() { return server;} 
};


BOOL 
   CSecTranslator::EstablishASession(
      WCHAR          const * serverName   // in - computer to establish a session to
   )
{
   BOOL                      bSuccess = TRUE;
   TSession                * pSession = new TSession(serverName);

   if (!pSession)
	  return FALSE;

   if ( EstablishSession(serverName,m_domain,m_username,m_password,TRUE) )
   {
      m_ConnectionList.InsertBottom(pSession);
   }
   else
   {
	  delete pSession;
      bSuccess = FALSE;
      err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_NO_SESSION_SD,serverName,GetLastError());
   }
   return bSuccess;
}

void 
   CSecTranslator::CleanupSessions()
{
   TNodeListEnum             e;
   TSession                * s;
   TSession                * snext;

   for ( s = (TSession*)e.OpenFirst(&m_ConnectionList) ; s ; s = snext )
   {
      snext = (TSession*) e.Next();
      m_ConnectionList.Remove(s);
      // close the session
      EstablishSession(s->ServerName(),NULL,NULL,NULL,FALSE);
      delete s;
   }
   e.Close();


}

STDMETHODIMP 
   CSecTranslator::Process(
      IUnknown             * pWorkItem     // in - varset describing translation options
   )
{
    HRESULT hr = S_OK;

    try
    {
        IVarSetPtr                pVarSet = pWorkItem;
        IStatusObjPtr             pStatus = pVarSet->get(GET_BSTR(DCTVS_StatusObject));
        BOOL                      bReallyDoEverything = FALSE; // this (though not implemented yet) can be used
                                                              // to provide a way to override the default behavior 
                                                              // of only processing file, etc. security when running as 
                                                              // local system.  This would allow selective translation of items
                                                              // on the local machine
        _bstr_t                   text = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
        _bstr_t text1 = pVarSet->get(GET_BSTR(DCTVS_Options_AlternativeLogfile));

        m_Args.LogFile(text);


        // Open the log file
        // use append mode since other processes may also be using this file
        if ( ! err.LogOpen(m_Args.LogFile(),1 /*append*/,0) )
        {
          return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }

        // open the alternative log file if necessary
        useErrAlt = false;
        if (!text1 == false && text1.length() != 0)
        {
            if (!errAlt.LogOpen(text1, 1, 0))
                return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            useErrAlt = true;
        }
            

        LoadSettingsFromVarSet(pVarSet);

        // Set up the cache
        TSDResolveStats     stat(m_Args.Cache(),m_Args.PathList(),pVarSet);

        if ( pStatus )
        {   
          m_Args.Cache()->SetStatusObject(pStatus);
        }

        if ( m_Args.Cache()->IsTree() )
        {
          m_Args.Cache()->ToSorted();
        }
        m_Args.Cache()->SortedToScrambledTree();
        m_Args.Cache()->Sort(&RidComp);
        m_Args.Cache()->Balance();
        m_Args.Cache()->UnCancel();

        //
        // Verify that the Cache got the source and target domain information it needs
        //
        // Note that source and target domain sids are not initialized when using a sid
        // mapping file therefore do not need to check the initialized status as the
        // initialized status is only checking whether the source and target domain
        // sids have been set to a non null value.
        //

        if ( !m_Args.UsingMapFile() && !m_Args.Cache()->IsInitialized() )
        {
          err.MsgWrite(ErrS,DCT_MSG_NO_CACHE_INFO);
          if (useErrAlt)
            errAlt.MsgWrite(ErrS,DCT_MSG_NO_CACHE_INFO);
        }
        else
        {
  
          if ( m_Args.IsLocalSystem() || bReallyDoEverything ) 
          {// Do the required translations
             if ( (m_Args.TranslateFiles() || m_Args.TranslateShares() || m_Args.TranslatePrinters() || m_Args.TranslateRecycler())
                    && !m_Args.Cache()->IsCancelled())
             {
                // This runs the old FST code
                pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_FST_OPERATION_TEXT));
                DoResolution(&stat);
             }

             if ( m_Args.TranslateLocalGroups() && !m_Args.Cache()->IsCancelled() )
             {
                pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_LGST_OPERATION_TEXT));
                DoLocalGroupResolution(&stat);
             }

             if ( m_Args.TranslateUserRights() && !m_Args.Cache()->IsCancelled() )
             {
                pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_URST_OPERATION_TEXT));
                DoUserRightsTranslation(&stat);
             }

             if ( m_Args.TranslateRegistry() && !m_Args.Cache()->IsCancelled() )
             {
                pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_REGST_OPERATION_TEXT));
			        //get needed privileges and keep them until the agent removes itself
                GetBkupRstrPriv((WCHAR*)NULL);
       	        GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
                TranslateRegistry(NULL,&m_Args,m_Args.Cache(),&stat);
             }
             if ( m_Args.TranslateUserProfiles() && !m_Args.Cache()->IsCancelled() )
             {
                // set the flag to indicate whether we want to allow switching from REPLACE to ADD
                // mode for profile translation while the user is logged on
                _bstr_t bstrFlag = pVarSet->get(GET_BSTR(DCTVS_Options_AllowSwitchingFromReplaceToAddInProfileTranslation));
                if (!bstrFlag == false && !UStrICmp(bstrFlag, GET_STRING(IDS_No)))
                {
                    m_Args.SetAllowingToSwitchFromReplaceToAddModeInProfileTranslation(FALSE);
                }

			    //get needed privileges and keep them until the agent removes itself
                GetBkupRstrPriv((WCHAR*)NULL);
                GetPrivilege((WCHAR*)NULL,SE_SECURITY_NAME);
                TranslateLocalProfiles(&m_Args,m_Args.Cache(),&stat);
             }
          }
          else
          {
             // do exchange translation

             if ( (m_Args.TranslateMailboxes() ||  m_Args.TranslateContainers()) && !m_Args.Cache()->IsCancelled() )
             {
                // This will run the old EST code
                pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),GET_BSTR(IDS_EST_OPERATION_TEXT));
                DoExchangeResolution(&stat,pVarSet);
             }
          }
        }

        // indicate the operation is aborted if necessary
        if (m_Args.Cache()->IsCancelled())
            err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED);
        
        pVarSet->put(GET_BSTR(DCTVS_CurrentOperation),"");
  
        ExportStatsToVarSet(pVarSet,&stat);

        if ( *m_CacheFile )
        {
          BuildCacheFile(m_CacheFile);
        }

        // Record whether errors occurred
        long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
        if ( level < err.GetMaxSeverityLevel() )
        {
          pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
        }
         
        err.LogClose();
        if (useErrAlt)
        {
            errAlt.LogClose();
            useErrAlt = false;
        }
        CleanupSessions();
    }
    catch (_com_error& ce)
    {
        hr = ce.Error();
        err.SysMsgWrite(ErrS, hr, DCT_MSG_SECURITY_TRANSLATOR_UNABLE_TO_CONTINUE);
    }
    catch (...)
    {
        hr = E_UNEXPECTED;
        err.SysMsgWrite(ErrS, hr, DCT_MSG_SECURITY_TRANSLATOR_UNABLE_TO_CONTINUE);
    }

    return hr;
}


void 
   CSecTranslator::LoadSettingsFromVarSet(
      IVarSet              * pVarSet      // in - varset containing settings
   )
{
   MCSASSERT(pVarSet);
   
   _bstr_t                   text;
   _bstr_t                   text2;
   
   DWORD                     val;

   try 
   {
      m_Args.Reset();

      text = pVarSet->get(GET_BSTR(DCTVS_Options_LocalProcessingOnly));
      if ( !text == false && !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         err.MsgWrite(0,DCT_MSG_LOCAL_MODE);
         m_LocalOnly = TRUE;
         m_Args.SetLocalMode(TRUE);
         text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomainSid));
         safecopy(m_SourceSid,(WCHAR const *)text);
         text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomainSid));
         safecopy(m_TargetSid,(WCHAR const *)text);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
      m_Args.Source(text);

      text = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
      m_Args.Target(text);

      val = (LONG)pVarSet->get(GET_BSTR(DCTVS_Options_LogLevel));
      if ( val )
         m_Args.SetLogging(val);
   
      val = (LONG)pVarSet->get(L"Security.DebugLogLevel");
      if ( val )
         m_Args.SetLogging(val);

      text = pVarSet->get(GET_BSTR(DCTVS_Options_NoChange));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.SetWriteChanges(FALSE);
      }
      else
      {
         m_Args.SetWriteChanges(TRUE);
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));

      if ( !UStrICmp(text,GET_STRING(IDS_Add)) )
      {
         m_Args.SetTranslationMode(ADD_SECURITY);
      }
      else if (! UStrICmp(text,GET_STRING(IDS_Replace)) )
      {
         m_Args.SetTranslationMode(REPLACE_SECURITY);
      }
      else if ( ! UStrICmp(text,GET_STRING(IDS_Remove)) )
      {
         m_Args.SetTranslationMode(REMOVE_SECURITY);
      }
      else
      {
         // Incorrect value - don't need to log this, just use replace
         // the log will show replace as the translation mode
         // err.MsgWrite(ErrE,DCT_MSG_BAD_TRANSLATION_MODE_S,(WCHAR*)text);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateFiles));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateFiles(TRUE);
      }
      else
      {
         m_Args.TranslateFiles(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateShares));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateShares(TRUE);
      }
      else
      {
         m_Args.TranslateShares(FALSE);
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslatePrinters));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslatePrinters(TRUE);
      }
      else
      {
         m_Args.TranslatePrinters(FALSE);  
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserProfiles));
      if ( ! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateUserProfiles(TRUE);
         m_Args.TranslateRecycler(TRUE);
      }
      else
      {
         m_Args.TranslateUserProfiles(FALSE); 
         m_Args.TranslateRecycler(FALSE);
      }
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateLocalGroups));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateLocalGroups(TRUE);
      }
      else
      {
         m_Args.TranslateLocalGroups(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateRegistry));
      if (! UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateRegistry(TRUE);
      }
      else
      {
         m_Args.TranslateRegistry(FALSE);
      }

      val = (LONG)pVarSet->get(GET_BSTR(DCTVS_Servers_NumItems));
      for ( int i = 0 ; i < (int)val ; i++ )
      {
         WCHAR                  key[MAX_PATH];
         DWORD                  flags = 0;
         _bstr_t                bStr;

         swprintf(key,GET_STRING(DCTVSFmt_Servers_D),i);

         bStr = key;

         text = pVarSet->get(bStr);
         if ( text.length() )
         {
            m_Args.PathList()->AddPath(text,flags);
         }
      }
   
      text = pVarSet->get(GET_BSTR(DCTVS_Security_GatherInformation));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.Cache()->AddIfNotFound(TRUE);
         m_Args.SetWriteChanges(FALSE);
         m_Args.SetLogging(m_Args.LogSettings() & ~FILESTATS);
      }
      else
      {
         m_Args.Cache()->AddIfNotFound(FALSE);
      }

      // Exchange Security Translation settings
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateMailboxes));
      if ( text.length() )
      {
         m_Args.TranslateMailboxes(TRUE);
         safecopy(m_Container,(WCHAR*)text);

         text = pVarSet->get(GET_BSTR(DCTVS_Security_MapiProfile));
         safecopy(m_Profile,(WCHAR*)text);

      }
      else
      {
         m_Args.TranslateMailboxes(FALSE);
      }

      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateContainers));
      if ( text.length() )
      {
         m_Args.TranslateContainers(TRUE);
         if ( ((WCHAR*)text)[0] == L'\\' && ((WCHAR*)text)[1] == L'\\' )
            safecopy(m_exchServer,(WCHAR*)text+2);
         else
            safecopy(m_exchServer,(WCHAR*)text);
      }
      else
      {
         m_Args.TranslateContainers(FALSE);
      }
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_TranslateUserRights));
      if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
      {
         m_Args.TranslateUserRights(TRUE);
      }
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      if ( text.length() )
      {
         safecopy(m_CacheFile,(WCHAR*)text);
      }
      // Check for inconsistent arguments
      
      // Load the cache
      // There are 4 possible ways to populate the cache
      // 1.  Use the list from the migrated objects table in our database
      // 2.  We are given a list of accounts in the VarSet, under "Accounts.".  This allows for renaming, but requires the most space
      // 3.  We are given an input file that was generated by AR, in "Accounts.InputFile".  This also allows for renaming, with less overall memory use.
	  // 4.  We are given a sid mapping, comma-seperated, file with source and target sids.
      
      text = pVarSet->get(GET_BSTR(DCTVS_Security_BuildCacheFile));
      text2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
         //if list is in the migrated objects table
      if ((!m_LocalOnly) && (!UStrICmp(text2,GET_STRING(IDS_YES)))) 
      {
         LoadMigratedObjects(pVarSet);
      }
	     //else if a sid mapping file is being used
      else if ((!m_LocalOnly) && (UStrICmp(text2,GET_STRING(IDS_YES)))) 
      {
         m_Args.SetUsingMapFile(TRUE); //set the arg flag to indicate use of map file
         text2 = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityMapFile));
         if (!LoadCacheFromMapFile(text2, pVarSet))
            _com_issue_error(E_FAIL);
      }
      //  took out the not because gather information sets this to false.
      //else if ( !m_Args.Cache()->AddIfNotFound() ) // skip loading the cache if we're gathering information
      else if ( m_Args.Cache()->AddIfNotFound() ) // skip loading the cache if we're gathering information
      {
         if ( m_LocalOnly )
         {
            m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
         }
         else
         {
            m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
         }
      }
      else
      {
         text = pVarSet->get(GET_BSTR(DCTVS_Accounts_InputFile));
         if ( text.length() )
         {
            LoadCacheFromFile(text,pVarSet);
         }
         else
         {
            LoadCacheFromVarSet(pVarSet);
         }
      }
   }
   catch ( ... )
   {
      err.MsgWrite(ErrS,DCT_MSG_EXCEPTION_READING_VARSET);
      throw;
   }
}
 
void 
   CSecTranslator::ExportStatsToVarSet(
      IVarSet              * pVarSet,        // in - varset to write stats to
      TSDResolveStats      * stat            // in - object containing stats
   )
{
   _bstr_t                   filename;

   filename = pVarSet->get(GET_BSTR(DCTVS_Security_ReportAccountReferences));

   stat->Report(m_Args.LogSummary(),m_Args.LogAccountDetails(),m_Args.LogPathDetails());
   
   if ( m_Args.NoChange() )
   {
      err.MsgWrite(0,DCT_MSG_NO_CHANGE_MODE);
   }
   
   stat->ReportToVarSet(pVarSet,m_Args.LogSettings() & SUMMARYSTATS);
   
   if ( filename.length() )
   {
      err.MsgWrite(0,DCT_MSG_EXPORTING_ACCOUNT_REFS_S,(WCHAR*)filename);
      m_Args.Cache()->ReportAccountReferences((WCHAR*)filename);
   }

   long                     level = pVarSet->get(GET_BSTR(DCTVS_Results_ErrorLevel));
   if ( level < err.GetMaxSeverityLevel() )
   {
      pVarSet->put(GET_BSTR(DCTVS_Results_ErrorLevel),(LONG)err.GetMaxSeverityLevel());
   }
}

void 
   CSecTranslator::DoResolution(
      TSDResolveStats      * stat         // in - object to write translation stats to
   )
{
    // display confirmation message if writing changes 
    int                       result;
    if (!m_Args.Cache()->IsCancelled())
        result = ResolveAll(&m_Args,stat);
}

void 
   CSecTranslator::DoLocalGroupResolution(
      TSDResolveStats      * stat         // in - object to write translation stats to
  )
{
    DWORD                     rc;
    TNodeListEnum             tenum;
    TPathNode               * tnode;

    if (!m_Args.Cache()->IsCancelled())
    {
        if ( m_LocalOnly )
        {
          err.MsgWrite(0,DCT_MSG_TRANSLATING_LOCAL_GROUPS);
          rc = TranslateLocalGroups(NULL,&m_Args,m_Args.Cache(),stat);
        }
        else
        {   // Enumerate the machines in the pathlist
          for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)m_Args.PathList()) 
             ; tnode && !m_Args.Cache()->IsCancelled()
             ; tnode = (TPathNode *)tenum.Next() )
          {
             if ( IsMachineName(tnode->GetPathName()) )
             {
                err.MsgWrite(0,DCT_MSG_TRANSLATING_LOCAL_GROUPS_ON_S,tnode->GetPathName());
                rc = TranslateLocalGroups(tnode->GetPathName(),&m_Args,m_Args.Cache(),stat);
             }
          }
        }
    }
    if (m_Args.Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_LOCAL_GROUPS);
    tenum.Close();
}              

void 
   CSecTranslator::DoUserRightsTranslation(
      TSDResolveStats      * stat         // in - object to write stats to
  )
{
    DWORD                     rc;
    TNodeListEnum             tenum;
    TPathNode               * tnode;

    if (!m_Args.Cache()->IsCancelled())
    {
        if ( m_LocalOnly )
        {
          err.MsgWrite(0,DCT_MSG_TRANSLATING_USER_RIGHTS);
          rc = TranslateUserRights(NULL,&m_Args,m_Args.Cache(),stat);
        }
        else
        {   // Enumerate the machines in the pathlist
          for (tnode = (TPathNode *)tenum.OpenFirst((TNodeList *)m_Args.PathList()) 
             ; tnode && !m_Args.Cache()->IsCancelled()
             ; tnode = (TPathNode *)tenum.Next() )
          {
             if ( IsMachineName(tnode->GetPathName()) )
             {
                err.MsgWrite(0,DCT_MSG_TRANSLATING_RIGHTS_ON_S,tnode->GetPathName());
                rc = TranslateUserRights(tnode->GetPathName(),&m_Args,m_Args.Cache(),stat);
             }
          }
        }
    }
    if (m_Args.Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_USER_RIGHTS);
    tenum.Close();
}


BOOL 
   CSecTranslator::LoadCacheFromVarSet(
      IVarSet              * pVarSet      // in - varset containing account mapping
   )
{
   BOOL                      bSuccess = TRUE;
   _bstr_t                   text;

   if ( m_LocalOnly )
   {
      m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
   }
   else
   {
      m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
   }
   m_Args.Cache()->ToSorted();
   // no wildcard filter specified.  Use the explicit list of accounts
   long numAccounts = pVarSet->get(GET_BSTR(DCTVS_Accounts_NumItems));
   for ( int i = 0 ; i < numAccounts ; i++ )
   {
      WCHAR                  key[LEN_Path];
      WCHAR                  name[LEN_Account];
      WCHAR                  targetName[LEN_Account];
      WCHAR                  type[LEN_Path];
      short                  sType;

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_D),i);
      text = pVarSet->get(key);
      safecopy(name,(WCHAR*)text);

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_TargetName_D),i);
      text = pVarSet->get(key);
      safecopy(targetName,(WCHAR*)text);

      swprintf(key,GET_STRING(DCTVSFmt_Accounts_Type_D),i);
      text = pVarSet->get(key);
      safecopy(type,(WCHAR*)text);


      if (!UStrICmp(type,L"user") || !UStrICmp(type,L"inetOrgPerson"))
         sType = EA_AccountUser;
      else if (! UStrICmp(type,L"group") )
         sType = EA_AccountGroup;
      else
         sType = 0;
      m_Args.Cache()->InsertLast(name,0,targetName,0,sType);
   }
   
   if ( bSuccess && ! m_LocalOnly )
   {
      bSuccess = GetRIDsFromEA();
   }

   m_Args.Cache()->VerifyTargetSids();
   
   return bSuccess;
}


// this reads the migrated objects table from the database, and 
// constructs a mapping file to be used for security translation

HRESULT CSecTranslator::LoadMigratedObjects(IVarSet* pVarSetIn)
{
    HRESULT hr = S_OK;

    if ( m_LocalOnly )
    {
        m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
    }
    else
    {
        m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
    }

    m_Args.Cache()->ToSorted();

    //
    // Create instance of database manager.
    //

    IIManageDBPtr spDB;
    hr = spDB.CreateInstance(CLSID_IManageDB);

    if  (SUCCEEDED(hr))
    {
        //
        // Retrieve objects that have been migrated from the source domain to the target domain.
        //

        IVarSetPtr spVarSet(CLSID_VarSet);

        hr = spDB->raw_GetMigratedObjectsForSecurityTranslation(
            _bstr_t(m_Args.Source()),
            _bstr_t(m_Args.Target()),
            IUnknownPtr(spVarSet)
        );

        if (SUCCEEDED(hr))
        {
            //
            // Retrieve data for each object and insert into cache.
            //

            WCHAR szKey[MAX_PATH];
            long lCount = spVarSet->get(L"MigratedObjects");

            for (long lIndex = 0; lIndex < lCount; lIndex++)
            {
                // retrieve object's data from VarSet

                swprintf(szKey, L"MigratedObjects.%ld.SourceSamName", lIndex);
                _bstr_t strSrcSam = spVarSet->get(szKey);

                swprintf(szKey, L"MigratedObjects.%ld.TargetSamName", lIndex);
                _bstr_t strTgtSam = spVarSet->get(szKey);

                swprintf(szKey, L"MigratedObjects.%ld.Type", lIndex);
                _bstr_t strType = spVarSet->get(szKey);

                swprintf(szKey, L"MigratedObjects.%ld.SourceRid", lIndex);
                long lSrcRid = spVarSet->get(szKey);

                swprintf(szKey, L"MigratedObjects.%ld.TargetRid", lIndex);
                long lTgtRid = spVarSet->get(szKey);

                // convert type to cache specific type

                short sType;

                if (UStrICmp(strType, L"user") == 0)
                {
                    sType = EA_AccountUser;
                }
                else if (UStrICmp(strType, L"group") == 0)
                {
                    sType = EA_AccountGroup;
                }
                else
                {
                    sType = 0;
                }

                // insert object's data into cache

                m_Args.Cache()->InsertLast(strSrcSam, lSrcRid, strTgtSam, lTgtRid, sType);
            }
        }
    }

    m_Args.Cache()->VerifyTargetSids();
    
    return hr;
}

BOOL 
   CSecTranslator::BuildCacheFile(
      WCHAR          const * filename        // in - file to write account mapping to
   )
{
   BOOL                      bSuccess = TRUE;
   FILE                    * pFile;
   
   m_Args.Cache()->ToSorted();

   TNodeListEnum             e;
   TRidNode                * node;
   WCHAR                     type[LEN_Path];


   pFile = _wfopen(filename,L"wb");
   
   if ( pFile )
   {
      for ( node = (TRidNode*) e.OpenFirst(m_Args.Cache() ); node ; node = (TRidNode*)e.Next() )
      {
      
         switch ( node->Type() )
         {
         case EA_AccountUser:
            safecopy(type,L"user");
            break;
         case EA_AccountGroup:
         case EA_AccountGGroup:
         case EA_AccountLGroup:
            safecopy(type,L"group");
            break;
        default:
            type[0] = 0;
            break;
         }

//         if (!UStrICmp(node->GetAcctName(),node->GetTargetAcctName()))
         if ((UStrICmp(node->GetSrcDomSid(),L"")) && (UStrICmp(node->GetTgtDomSid(),L"")))
         {
		       //account and domain names could be empty when using a sid
		       //mapping file for security translation.  A later scanf by
		       //the agent will fail on a NULL name, so we will store "(UnKnown)"
		       //instead and deal with that on the scanf-side
		    WCHAR ssname[MAX_PATH];
			wcscpy(ssname, node->GetAcctName());
		    if (!wcslen(ssname))
		       wcscpy(ssname, GET_STRING(IDS_UnknownSid));
		    WCHAR stname[MAX_PATH];
			wcscpy(stname, node->GetTargetAcctName());
		    if (!wcslen(stname))
		       wcscpy(stname, GET_STRING(IDS_UnknownSid));
		    WCHAR ssdname[MAX_PATH];
			wcscpy(ssdname, node->GetSrcDomName());
		    if (!wcslen(ssdname))
		       wcscpy(ssdname, GET_STRING(IDS_UnknownSid));
		    WCHAR stdname[MAX_PATH];
			wcscpy(stdname, node->GetTgtDomName());
		    if (!wcslen(stdname))
		       wcscpy(stdname, GET_STRING(IDS_UnknownSid));
         
            fwprintf(pFile,L"%s\t%s\t%s\t%lx\t%lx\t%lx\t%s\t%s\t%s\t%s\r\n",ssname,stname,type,
                                                   node->GetStatus(), node->SrcRid(), node->TgtRid(), node->GetSrcDomSid(), node->GetTgtDomSid(), 
												   ssdname, stdname);
         }
         else
         {
            fwprintf(pFile,L"%s\t%s\t%s\t%lx\t%lx\t%lx\r\n",node->GetAcctName(),node->GetTargetAcctName(),type,
                                                   (DWORD)node->GetStatus(), node->SrcRid(), node->TgtRid());
         }
      }
      e.Close();
      fclose(pFile);
   }
   else
   {
      bSuccess = FALSE;
//      DWORD rc = GetLastError();
   }
   return bSuccess;
}
BOOL 
   CSecTranslator::LoadCacheFromFile(
      WCHAR          const * filename,       // in - file to read account mapping from
      IVarSet              * pVarSet         // in - pointer to varset
   )
{
   BOOL                      bSuccess = TRUE;
   _bstr_t                   text;
   FILE                    * pFile;
   WCHAR                     sourceName[LEN_Account];
   WCHAR                     targetName[LEN_Account];
   WCHAR                     sourceDomSid[MAX_PATH];
   WCHAR                     targetDomSid[MAX_PATH];
   WCHAR                     sourceDomName[MAX_PATH];
   WCHAR                     targetDomName[MAX_PATH];
   WCHAR                     type[LEN_Account];
   DWORD                     status;
   int                       count = 0;
   BOOL                      bNeedRids = FALSE;
   WCHAR                     path[MAX_PATH];
   WCHAR                     temp[MAX_PATH];
   BOOL						 bUseMapFile = FALSE;
   WCHAR*                    pFullPathBuffer = NULL;
   
   text = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SecurityInputMOT));
   if (!text || UStrICmp(text,GET_STRING(IDS_YES)))
   {
      m_Args.SetUsingMapFile(TRUE); //set the arg flag to indicate use of map file
      bUseMapFile = TRUE;
   }
   
   if ( m_LocalOnly )
   {
      // we need to set source and target domain information for the cache
      // if we're not using migrated object table
      if (!bUseMapFile)
        m_Args.Cache()->SetSourceAndTargetDomainsWithSids(m_Args.Source(),m_SourceSid,m_Args.Target(),m_TargetSid);  
      
      // find the module path
      DWORD          rc = GetModuleFileName(NULL,temp,DIM(temp));
      if ( rc )
      {
         // Generally, our DCTCache file will be in the same directory as our EXE.
         // This is true 1) when agent is dispatched to clean machine (all will be in OnePointDomainAgent directory)
         // and also 2) when agent is dispatched to the local ADMT machine (all will be in Program Files\ADMT directory)
         // The exception is when the agent is dispatched to a remote machine where ADMT is also installed.
         WCHAR * slash = wcsrchr(temp,L'\\');
         UStrCpy(slash+1,filename);
         // Check whether ADMT is locally installed here
         if ( IsLocallyInstalled() && !IsThisDispatcherMachine(pVarSet) )
         {
            // ADMT is installed here, so we're running from the binaries
            // in the Program files\ADMT directory
            // However, our cache file should be in %Program Files%\\OnePOintDomainAgent
            GetProgramFilesDirectory(temp,NULL);
            UStrCpy(temp+UStrLen(temp),L"\\OnePointDomainAgent\\");
            UStrCpy(temp+UStrLen(temp),filename);
         }
      }
      else
      {
         rc = GetLastError();
         err.DbgMsgWrite(0,L"Couldn't get the module filename, rc=%ld",rc);
         swprintf(temp,L"..\\OnePointDomainAgent\\%ls",filename);
      }
      pFullPathBuffer = _wfullpath(path,temp,MAX_PATH);     
      if(!pFullPathBuffer)
      {
          // we should bail out here, since we could not get the file path name
          err.MsgWrite(0, DCT_MSG_GET_FULL_PATH_FAILED, temp);
          return FALSE;
       
      }
   }
   else
   {
      // we need to set source and target domain information for the cache
      // if we're not using migrated object table
      if (!bUseMapFile)
          m_Args.Cache()->SetSourceAndTargetDomains(m_Args.Source(),m_Args.Target());
      pFullPathBuffer = _wfullpath(path,filename,MAX_PATH);

      if(!pFullPathBuffer)
      {
          // we should bail out here, since we could not get the file path name
          err.MsgWrite(0, DCT_MSG_GET_FULL_PATH_FAILED, filename);
          return FALSE;
       
      }
   }
   m_Args.Cache()->ToSorted();
   
   // The input file should have the format:
   // SourceName, TargetName, Type, Status [,rid1, rid2]
   
   pFile = _wfopen(path,L"rb");
   if ( pFile )
   {
      int result;
      do 
      {
         DWORD rid1 = 0;
         DWORD rid2 = 0;
         if (!bUseMapFile)
		 {
            result = fwscanf(pFile,L"%[^\t]\t%[^\t]\t%[^\t]\t%lx\t%lx\t%lx\r\n",
			                 sourceName,targetName,type,&status,&rid1,&rid2);

            if ( result < 4 )
               break;
		 }
		 else
		 {
            result = fwscanf(pFile,L"%[^\t]\t%[^\t]\t%[^\t]\t%lx\t%lx\t%lx\t%[^\t]\t%[^\t]\t%[^\t]\t%[^\r]\r\n",
			                 sourceName,targetName,type,&status,&rid1,&rid2,sourceDomSid,targetDomSid,
						     sourceDomName, targetDomName);

            if ( result < 8 )
               break;
		 }

         
         short lType = 0;
         if ( !UStrICmp(type,L"user") )
            lType = EA_AccountUser;
         else if ( ! UStrICmp(type,L"group") )
            lType = EA_AccountGroup;

         if (!bUseMapFile)
			m_Args.Cache()->InsertLast(sourceName,rid1,targetName,rid2,lType, status);
		 else
            m_Args.Cache()->InsertLastWithSid(sourceName,sourceDomSid,sourceDomName,rid1,
			                                  targetName,targetDomSid,targetDomName,rid2,lType, status);
         count++;
         if ( ! rid1 | ! rid2 )
         {
            bNeedRids = TRUE;
         }
      } while ( result >= 4 ); // 4 fields read and assigned

      if ( result )
      {
         err.MsgWrite(ErrS,DCT_MSG_ERROR_READING_INPUT_FILE_S,path);
      }
      err.MsgWrite(0,DCT_MSG_ACCOUNTS_READ_FROM_FILE_DS,count,path);
      fclose(pFile);
   }
   else
   {
      err.MsgWrite(ErrS,DCT_MSG_ERROR_OPENING_FILE_S,path);
      bSuccess = FALSE;
   }

   if ( bSuccess && bNeedRids && ! m_LocalOnly)
   {
      bSuccess = GetRIDsFromEA();
   }
  
   return bSuccess;
}

// This doesn't get RIDs from EA any more, since we have removed dependencies on MCS products.
// Instead, we use the Net APIs to get this information
BOOL CSecTranslator::GetRIDsFromEA()
{
   BOOL                      bSuccess = TRUE;

   // set the cache to a tree sorted by name
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompN);

   // do NQDI to get RIDS for accounts
   DWORD                     rc = 0;
   NET_DISPLAY_USER        * pUser = NULL;
   NET_DISPLAY_GROUP       * pGroup = NULL;
   DWORD                     count = 0;
   DWORD                     resume = 0;
   TRidNode                * pNode = NULL;

   // Get source rids for users
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetSourceDCName(),1,resume,5000,100000,&count,(void**)&pUser);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vNameComp,pUser[i].usri1_name);
            if ( pNode )
            {
               pNode->SrcRid(pUser[i].usri1_user_id);   
            }
         }
         if ( count )
         {
            resume = pUser[count-1].usri1_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pUser);
      }
   } while ( rc == ERROR_MORE_DATA );

   count = 0;
   resume = 0;

   // Get source rids for global groups
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetSourceDCName(),3,resume,5000,100000,&count,(void**)&pGroup);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vNameComp,pGroup[i].grpi3_name);
            if ( pNode )
            {
               pNode->SrcRid(pGroup[i].grpi3_group_id);   
            }
         }
         if ( count )
         {
            resume = pGroup[count-1].grpi3_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pGroup);
      }
   } while ( rc == ERROR_MORE_DATA );

   count = 0;
   resume = 0;
   
   // Get target rids for users
   // set the cache to a tree sorted by target name
   m_Args.Cache()->ToSorted();
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompTargetN);

   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetTargetDCName(),1,resume,5000,100000,&count,(void**)&pUser);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vTargetNameComp,pUser[i].usri1_name);
            if ( pNode )
            {
               pNode->TgtRid(pUser[i].usri1_user_id);   
            }
         }
         if ( count )
         {
            resume = pUser[count-1].usri1_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pUser);
      }
   } while ( rc == ERROR_MORE_DATA );


   
   // TODO:  Add error message if rc != 0

   count = 0;
   resume = 0;
   // Get target rids for global groups
   do 
   {
      rc = NetQueryDisplayInformation(m_Args.Cache()->GetTargetDCName(),3,resume,5000,100000,&count,(void**)&pGroup);
      if ( 0 == rc || ERROR_MORE_DATA == rc )
      {
         for ( DWORD i = 0 ; i < count ; i++ )
         {
            // see if this account is in the cache
            pNode = (TRidNode*)m_Args.Cache()->Find(&vTargetNameComp,pGroup[i].grpi3_name);
            if ( pNode )
            {
               pNode->TgtRid(pGroup[i].grpi3_group_id);   
            }
         }
         if ( count )
         {
            resume = pGroup[count-1].grpi3_next_index;
         }
         else
         {
            // no items were returned - get out of here
            break;
         }
         NetApiBufferFree(pGroup);
      }
   } while ( rc == ERROR_MORE_DATA );


   // sort back to regular source name order
   m_Args.Cache()->ToSorted();
   m_Args.Cache()->SortedToScrambledTree();
   m_Args.Cache()->Sort(&CompN);


   // get source and target rids for local groups
   TNodeTreeEnum             tEnum;
   BYTE                      sid[LEN_SID];
   DWORD                     lenSid;
   WCHAR                     domain[LEN_Domain];
   DWORD                     lenDomain;
   SID_NAME_USE              snu;

   
   for ( pNode = (TRidNode*)tEnum.OpenFirst(m_Args.Cache()) ; pNode ; pNode = (TRidNode*) tEnum.Next() )
   {
      if ( ! pNode->SrcRid() )
      {
         // we don't have a rid for this account, possibly because it is a local group
         lenSid = DIM(sid);
         lenDomain = DIM(domain);
         if ( LookupAccountName(m_Args.Cache()->GetSourceDCName(),pNode->GetAcctName(),sid,&lenSid,domain,&lenDomain,&snu) )
         {
            if (! UStrICmp(m_Args.Source(),domain) )
            {
               // found the source SID
               // get the last sub-id
               PUCHAR        pCount = GetSidSubAuthorityCount(&sid);
               if ( pCount )
               {
                  LPDWORD    pRid = GetSidSubAuthority(&sid,(*pCount) - 1 );
                  if ( pRid )
                  {
                     pNode->SrcRid(*pRid);
                  }
               }
            }
         }
      }

      if ( pNode->SrcRid() && !pNode->TgtRid() )
      {
         // we got the source RID, now try to get the target RID
         lenSid = DIM(sid);
         lenDomain = DIM(domain);
         if ( LookupAccountName(m_Args.Cache()->GetTargetDCName(),pNode->GetTargetAcctName(),sid,&lenSid,domain,&lenDomain,&snu) )
         {
            if (! UStrICmp(m_Args.Target(),domain) )
            {
               // found the source SID
               // get the last sub-id
               PUCHAR        pCount = GetSidSubAuthorityCount(&sid);

               if ( pCount )
               {
                  LPDWORD    pRid = GetSidSubAuthority(&sid,(*pCount) - 1 );

                  if ( pRid )
                  {
                     pNode->TgtRid(*pRid);
                  }
               }
            }
         }
      }
   }
   tEnum.Close();

   return bSuccess;
}

// We remove the Exchange server service accont from the cache before translating, 
// since it is not recommended to change the service account from exchange
// in any event, the service account for exchange cannot be changed simply by granting
// exchange permissions to the new account.  It also requires configuration changes within
// exchange that must be performed manually
BOOL 
   CSecTranslator::RemoveExchangeServiceAccountFromCache()
{
   WCHAR          const    * exServiceName = L"MSExchangeDS";
   SC_HANDLE                 hSCM; 
   DWORD                     rc = 0;           // return code
   BOOL                      result = FALSE;
   BOOL						 bUseMapFile = m_Args.UsingMapFile();

   if ( m_Args.TranslateContainers() )
   {
      // get the service account name for the exchange directory service on exchServer
//      BOOL                      retval=FALSE; // returned value
      SC_HANDLE                 hSvc;         // Service handle
      DWORD                     lenQsc;       // required qsc info len
     
      union
      {
         QUERY_SERVICE_CONFIG   qsc;          // Exchange Directory service information
         BYTE                   padding[1000];
      }                         bufQsc;
      
      hSCM = OpenSCManager( m_exchServer, NULL, GENERIC_READ );
      if ( !hSCM )
      {
         rc = GetLastError();
         err.SysMsgWrite( ErrW, rc,
               DCT_MSG_SCM_OPEN_FAILED_SD, m_exchServer,rc );
         
      }
      else
      {
         hSvc = OpenService( hSCM, exServiceName, SERVICE_QUERY_CONFIG );
         if ( !hSvc )
         {
            rc = GetLastError();
            switch ( rc )
            {
               case ERROR_SERVICE_DOES_NOT_EXIST: // 1060
               default:
                  err.SysMsgWrite( ErrW, rc, DCT_MSG_OPEN_SERVICE_FAILED_SSD,
                       m_exchServer , exServiceName, rc );
                  break;
            }
         }
         else 
         {
            if ( !QueryServiceConfig( hSvc, &bufQsc.qsc, sizeof bufQsc, &lenQsc ) )
            {
               rc = GetLastError();
               err.SysMsgWrite( ErrW, rc, DCT_MSG_QUERY_SERVICE_CONFIG_FAILED_SSD,
                     m_exchServer, exServiceName, rc );
            }
            else
            {
               // We've found the account
               result = TRUE;
               // bufQsc.qsc.lpServiceStartName is DOMAIN\Account or .\Account
               WCHAR       * domAcct = bufQsc.qsc.lpServiceStartName;
               WCHAR       * domName;  // domain-name
               WCHAR       * acctName; // account-name

               for ( domName = domAcct ; *domName && *domName != _T('\\') ; domName++ )
                  ;
               if ( *domName == _T('\\') )
               {
                  *domName = 0;
                  acctName = domName+1;
                  domName = domAcct;
               }
               // Is the account from the source domain?
               WCHAR szSourceDomain[LEN_Domain];
               WCHAR wszAccountName[LEN_Account];
               
               safecopy(wszAccountName,acctName);
               
			      //use the domain name from the cache if we are not using a sID mapping
			      //file
               if (!bUseMapFile)
			   {
                  safecopy(szSourceDomain,m_Args.Cache()->GetSourceDomainName());
                  if ( !UStrICmp(domName,szSourceDomain ) )
				  {
                     // if so, is it in the cache?
                     TAcctNode * tnode;
                     TNodeTreeEnum  tEnum;
                     // the cache is a tree, sorted by RID
                     for ( tnode = (TAcctNode *)tEnum.OpenFirst(m_Args.Cache()) ; tnode ; tnode = (TAcctNode *)tEnum.Next() )
					 {
                        if ( !UStrICmp(tnode->GetAcctName(),wszAccountName) )
						{
                           // remove it from the cache, and notify the user
                           err.MsgWrite(ErrW,DCT_MSG_SKIPPING_EXCHANGE_ACCOUNT_SS,domName,acctName);
                           m_Args.Cache()->Remove(tnode);
						}
					 }
                     tEnum.Close();
				  }
			   }//end if not using mapping file
			   else //else using sID mapping file, get the source domain name from the
			   {    //node itself
                     //is this account in the cache?
                  TAcctNode * tnode;
                  TNodeTreeEnum  tEnum;
                     // the cache is a tree, sorted by RID
                  for ( tnode = (TAcctNode *)tEnum.OpenFirst(m_Args.Cache()) ; tnode ; tnode = (TAcctNode *)tEnum.Next() )
				  {
                     if (( !UStrICmp(tnode->GetAcctName(),wszAccountName) ) &&
						 ( !UStrICmp(((TRidNode*)tnode)->GetSrcDomName(),domName) ))
					 {
                           // remove it from the cache, and notify the user
                        err.MsgWrite(ErrW,DCT_MSG_SKIPPING_EXCHANGE_ACCOUNT_SS,domName,acctName);
                        m_Args.Cache()->Remove(tnode);
					 }
				  }
                  tEnum.Close();
			   }//end if using mapping file
               CloseServiceHandle( hSvc );
            }
         }
         CloseServiceHandle(hSCM);
      }
   }
   if ( !result ) 
   {
      // couldn't get the service account name
      err.SysMsgWrite(ErrW,rc,DCT_MSG_CANT_FIND_EXCHANGE_ACCOUNT_SD,
         m_exchServer,rc);
   }
   return result;
}

void 
   CSecTranslator::DoExchangeResolution(
      TSDResolveStats      * stat,          // in - stats object to record stats
      IVarSet              * pVarSet
   )
{

    if (!m_Args.Cache()->IsCancelled())
    {
      TGlobalDirectory          m_exDir;
      _bstr_t                   domain = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Domain));
      _bstr_t                   username = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_UserName));
      _bstr_t                   password = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_SidHistoryCredentials_Password));
      _bstr_t                   mode = pVarSet->get(GET_BSTR(DCTVS_Security_TranslationMode));
      _bstr_t                   mbquery = pVarSet->get(L"ExchangeMigration.LdapQuery");
      WCHAR                     query[LEN_Path] = L"(objectClass=*)";
      if ( m_exchServer[0] )
      {
         if (! RemoveExchangeServiceAccountFromCache() )
            goto end;
      }

      if ( mbquery.length() )
      {
         UStrCpy(query,(WCHAR*)mbquery);
      }
      if ( m_Args.TranslateMailboxes() || m_Args.TranslateContainers() )
      {
          // make sure we have some accts in the cache
         m_exDir.SetStats(stat);
         m_Args.Cache()->UnCancel();      
         err.MsgWrite(0,DCT_MSG_EXCHANGE_TRANSLATION_MODE_S,(WCHAR*)mode);
         m_exDir.DoLdapTranslation(m_exchServer,domain,username,password,&m_Args,NULL,query);
         stat->DisplayPath(L"");
         
      } 
    }
    
    if (m_Args.Cache()->IsCancelled())
        err.MsgWrite(0, DCT_MSG_OPERATION_ABORTED_EXCHANGE);
end:
   return;
}


//----------------------------------------------------------------------------
// GetLine Function
//
// Retrieves a single line from a SID mapping file.
//
// Author
// moluper 2001-10-08
//
// Arguments
// IN fp      - pointer to stream i/o file structure
// IN pszLine - pointer to buffer in which a null terminated line from file
//              will be written
// IN cchLine - size of buffer in characters
//
// Return Value
// The return value is true if a valid line from the file was retrived
// otherwise the return value is false.
//----------------------------------------------------------------------------

inline bool __stdcall GetLine(FILE* fp, PTSTR pszLine, int cchLine)
{
    bool bGet = false;

    //
    // until a valid line is retrieved
    //

    while (bGet == false)
    {
        //
        // retrieve line from file
        //

        if (_fgetts(pszLine, cchLine, fp) == NULL)
        {
            break;
        }

        //
        // check if line length is valid
        //

        int cch = _tcslen(pszLine);

        if ((cch < (cchLine - 1)) || (pszLine[cch - 1] == L'\r') || (pszLine[cch - 1] == L'\n'))
        {
            //
            // the line is less than or equal to the maximum length
            // remove carriage return and linefeed characters from end of line
            //

            while ((cch > 0) && ((pszLine[cch - 1] == L'\r') || (pszLine[cch - 1] == L'\n')))
            {
                pszLine[--cch] = _T('\0');
            }

            bGet = true;
        }
        else
        {
            //
            // the line is greater than maximum length
            //
            // only display beginning of line with trailing ...
            //

            int ich = cchLine / 4;

            pszLine[ich++] = _T('.');
            pszLine[ich++] = _T('.');
            pszLine[ich++] = _T('.');
            pszLine[ich++] = _T('\0');

            err.MsgWrite(ErrW, DCT_MSG_SID_MAPPING_FILE_LINE_TOO_LONG_S, pszLine);

            if (useErrAlt)
            {
                errAlt.MsgWrite(ErrW, DCT_MSG_SID_MAPPING_FILE_LINE_TOO_LONG_S, pszLine);
            }

            // skip rest of line

            do
            {
                if (_fgetts(pszLine, cchLine, fp) != NULL)
                {
                    cch = _tcslen(pszLine);
                }
                else
                {
                    break;
                }
            }
            while ((pszLine[cch - 1] != L'\r') && (pszLine[cch - 1] != L'\n'));
        }
    }

    return bGet;
}

//----------------------------------------------------------------------------
// TrimTrailingSpaces
//
// Removes white space characters from end of string.
//
// Author
// moluper 2001-10-08
//
// Arguments
// IN psz - pointer to buffer in which trailing whitespace characters are
//          replaced with null characters in place
//----------------------------------------------------------------------------

inline void __stdcall TrimTrailingSpaces(PTSTR psz)
{
    for (PTSTR pch = psz + _tcslen(psz) - 1; (pch >= psz) && _istspace(*pch); pch--)
    {
        *pch = L'\0';
    }
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 OCT 2000                                                  *
 *                                                                   *
 *     This function is responsible for retrieving account sIDs from *
 * the given sID mapping file and adding these sids to the cache.    *
 *                                                                   *
 *********************************************************************/

//BEGIN LoadCacheFromMapFile
BOOL 
CSecTranslator::LoadCacheFromMapFile(
    WCHAR          const * filename,       // in - file to read sid mapping from
    IVarSet              * pVarSet         // in - pointer to varset
)
{
    FILE                    * pFile = NULL;
    WCHAR                     szLine[2 * MAX_PATH];
    WCHAR                     path[MAX_PATH];
    WCHAR                     szFmt1[64];
    WCHAR                     szFmt2[64];
    WCHAR                     sourceSid[MAX_PATH];
    WCHAR                     targetSid[MAX_PATH];
    int                       count = 0;
    BOOL                      bSuccess = TRUE;

    if (useErrAlt)
        errAlt.MsgWrite(0, DCT_MSG_PROCESSING_SID_MAPPING_FILE, filename);

    _wfullpath(path,filename,MAX_PATH);

    m_Args.Cache()->ToSorted();

    // The input file should have the format:
    // srcSid,tgtSid
    pFile = OpenMappingFile(path);   

    if ( pFile )
    {
        //
        // initialize format strings so that scanf does not exceed
        // size of sourceSid and targetSid buffers
        //

        wsprintf(szFmt1, L" %%%d[^,\r\n]", MAX_PATH - 1);
        wsprintf(szFmt2, L" %%%d[^,] , %%%d[^\r\n]", MAX_PATH - 1, MAX_PATH - 1);

        //
        // read account mapping entries until the end of the file is reached
        //

        bool bRemoveMode = (m_Args.TranslationMode() == REMOVE_SECURITY);

        for (;;) 
        {
            //
            // retrieve line from file
            //

            if (GetLine(pFile, szLine, sizeof(szLine) / sizeof(szLine[0]) - 1) == false)
            {
                // if an error reading the file occurred log an error message
                // and set return value to unsuccessful

                int nError = ferror(pFile);

                if (nError != 0)
                {
                    err.MsgWrite(ErrE, DCT_MSG_ERROR_READING_INPUT_FILE_S, path);
                    if (useErrAlt)
                        errAlt.MsgWrite(ErrE, DCT_MSG_ERROR_READING_INPUT_FILE_S, path);
                    bSuccess = FALSE;
                }
                break;
            }

            //
            // parse account name(s) or SID(s)
            // the comma character is the only valid separator between the source and target accounts
            //

            int cFields = 0;

            if (bRemoveMode)
            {
                //
                // remove mode only requires source account
                //

                cFields = swscanf(szLine, szFmt1, sourceSid);

                if (cFields >= 1)
                {
                    TrimTrailingSpaces(sourceSid);
                    targetSid[0] = L'\0';
                }
                else
                {
                    continue;
                }
            }
            else
            {
                //
                // add and replace modes require both source and target accounts
                //

                cFields = swscanf(szLine, szFmt2, sourceSid, targetSid);

                if (cFields >= 2)
                {
                    TrimTrailingSpaces(sourceSid);
                    TrimTrailingSpaces(targetSid);
                }
                else
                {
                    // only log error if not blank line

                    if (cFields == 1)
                    {
                        err.MsgWrite(ErrW, DCT_MSG_SID_MAPPING_FILE_UNABLE_TO_PARSE_S, szLine);
                        if (useErrAlt)
                            errAlt.MsgWrite(ErrW, DCT_MSG_SID_MAPPING_FILE_UNABLE_TO_PARSE_S, szLine);
                    }

                    continue;
                }
            }

            short lType = EA_AccountUser;

            //divide the sids into domain sids and rids
            WCHAR    srcDomainSid[MAX_PATH] = L"";
            WCHAR    tgtDomainSid[MAX_PATH] = L"";
            _bstr_t  srcDomainName = L"";
            _bstr_t  tgtDomainName = L"";
            DWORD    srcRid = 0;
            DWORD    tgtRid = 0;
            _bstr_t  srcName = L"";
            _bstr_t  tgtName = L"";
            WCHAR	  userName[MAX_PATH] = L"";
            WCHAR	  domainName[MAX_PATH] = L"";
            DWORD	  cb = MAX_PATH;
            DWORD    cbDomain = MAX_PATH;
            SID_NAME_USE	sid_Use;
            PSID     srcSid = NULL;
            PSID	  tgtSid = NULL;
            WCHAR  * slash;
            _bstr_t  DCName;
            BYTE     ssid[200];
            BYTE     tsid[200];
            DWORD    lenSid = DIM(ssid);
            BOOL	  bNeedToFreeSrc = FALSE;
            BOOL	  bNeedToFreeTgt = FALSE;

            //see if the source is given by domain\account format or 
            //decimal-style sid format
            if (wcschr(sourceSid,L'\\'))
            {
                //seperate domain and account names
                srcDomainName = sourceSid;
                srcName = sourceSid;
                slash = wcschr((WCHAR*)srcDomainName,L'\\');
                if ( slash )
                    *slash = 0;
 
                //get a DC for the given domain
                DCName = GetADC(srcDomainName); 
                if (!DCName.length())
                {
                    err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    if (useErrAlt)
                        errAlt.MsgWrite(ErrW,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    continue;
                }

                  //get the sid for this account
                if(!LookupAccountName(DCName,srcName,(PSID)ssid,&lenSid,domainName,&cbDomain,&sid_Use))
                {
                    err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    if (useErrAlt)
                        errAlt.MsgWrite(ErrW,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    continue;
                }

                srcSid = (PSID)ssid;

                if (sid_Use == SidTypeGroup)
                    lType = EA_AccountGroup;
                else
                    lType = EA_AccountUser;
            }//end if domain\account format
            else
            {
                srcSid = SidFromString(sourceSid);
                if (!srcSid)
                {
                    err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    if (useErrAlt)
                        errAlt.MsgWrite(ErrW,DCT_MSG_SRC_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, sourceSid);
                    continue;
                }

                bNeedToFreeSrc = TRUE;

                if (LookupAccountSid(NULL, srcSid, userName, &cb, domainName, &cbDomain, &sid_Use))
                {
                    srcName = userName;
                    srcDomainName = domainName;
                    if (sid_Use == SidTypeGroup)
                        lType = EA_AccountGroup;
                    else
                        lType = EA_AccountUser;
                }
            }//end else sid format

            //if target given
            if (cFields > 1)
            {
                //see if the target is given by domain\account format or 
                //decimal-style sid format
                lenSid = DIM(tsid);
                cb = cbDomain = MAX_PATH;
                if (wcschr(targetSid,L'\\'))
                {
                    //seperate domain and account names
                    tgtDomainName = targetSid;
                    tgtName = targetSid;
                    slash = wcschr((WCHAR*)tgtDomainName,L'\\');
                    if ( slash )
                        *slash = 0;

                    //get a DC for the given domain
                    DCName = GetADC(tgtDomainName); 
                    if (!DCName.length())
                    {
                        if (bNeedToFreeSrc)
                            FreeSid(srcSid);
                        err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        if (useErrAlt)
                            errAlt.MsgWrite(ErrW,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        continue;
                    }

                    //get the sid for this account
                    if(!LookupAccountName(DCName,tgtName,(PSID)tsid,&lenSid,domainName,&cbDomain,&sid_Use))
                    {
                        if (bNeedToFreeSrc)
                            FreeSid(srcSid);
                        err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        if (useErrAlt)
                            errAlt.MsgWrite(ErrW,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        continue;
                    }

                    tgtSid = (PSID)tsid;

                    if (sid_Use == SidTypeGroup)
                        lType = EA_AccountGroup;
                    else
                        lType = EA_AccountUser;
                }//end if domain\account format
                else
                {
                    tgtSid = SidFromString(targetSid);
                    if (!tgtSid)
                    {
                        if (bNeedToFreeSrc)
                            FreeSid(srcSid);
                        err.MsgWrite(0,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        if (useErrAlt)
                            errAlt.MsgWrite(ErrW,DCT_MSG_TGT_ACCOUNT_NOT_READ_FROM_FILE_DS, sourceSid, targetSid, path, targetSid);
                        continue;
                    }

                    bNeedToFreeTgt = TRUE;

                    if (LookupAccountSid(NULL, tgtSid, userName, &cb, domainName, &cbDomain, &sid_Use))
                    {
                        tgtName = userName;
                        tgtDomainName = domainName;
                        if (sid_Use == SidTypeGroup)
                            lType = EA_AccountGroup;
                        else
                            lType = EA_AccountUser;
                    }
                }//end else sid format
            }//end if given target account
            else if (m_Args.TranslationMode() == REMOVE_SECURITY) //else if REMOVE mode set target to use source
            {
                tgtSid = srcSid;
                bNeedToFreeTgt = FALSE;
                wcscpy(targetSid, sourceSid);
                tgtName = srcName;
                tgtDomainName = srcDomainName;
            }

            //if the source account is not already in the cache, then add it
            if ((m_Args.Cache()->GetNumAccts() == 0) || (m_Args.Cache()->LookupWODomain(srcSid) == NULL))
            {
                //get the domain sids and account rids from the account sids
                SplitAccountSids(srcSid, srcDomainSid, &srcRid, tgtSid, tgtDomainSid, &tgtRid);

                //insert this node into the cache
                m_Args.Cache()->InsertLastWithSid(srcName,srcDomainSid,srcDomainName,srcRid,tgtName,
                                                                      tgtDomainSid,tgtDomainName,tgtRid,lType);
                count++;
            }
            else
                err.MsgWrite(0,DCT_MSG_SRC_ACCOUNT_DUPLICATE_IN_FILE_DS, sourceSid, targetSid, path, sourceSid);

            if (bNeedToFreeSrc)
                FreeSid(srcSid);
            if (bNeedToFreeTgt)
                FreeSid(tgtSid);
        }

        err.MsgWrite(0,DCT_MSG_ACCOUNTS_READ_FROM_FILE_DS,count,path);
        fclose(pFile);
    }
    else
    {
        err.MsgWrite(ErrS,DCT_MSG_ERROR_OPENING_FILE_S,path);
        if (useErrAlt)
            errAlt.MsgWrite(ErrS,DCT_MSG_ERROR_OPENING_FILE_S,path);
        bSuccess = FALSE;
    }

    return bSuccess;
}
//END LoadCacheFromMapFile 


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for opening the sid mapping file *
 * whether it is anm ANSI or UNICODE file and return the file        *
 * pointer.                                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN OpenMappingFile
FILE* CSecTranslator::OpenMappingFile(LPCTSTR pszFileName)
{
	// open in binary mode first in order to check for UNICODE byte order
	// mark if the file is UNICODE then it must be read in binary mode
	// with the stream i/o functions

	FILE* fp = _tfopen(pszFileName, _T("rb"));

	if (fp == NULL)
	{
		return NULL;
//		_com_issue_error(E_INVALIDARG);
	}

	// check if file is ANSI or UNICODE or UTF-8

	BYTE byteSignature[3];

	if (fread(byteSignature, sizeof(BYTE), 3, fp) == 3)
	{
		static BYTE byteUtf8[] = { 0xEF, 0xBB, 0xBF };
		static BYTE byteUnicodeLE[] = { 0xFF, 0xFE };
		static BYTE byteUnicodeBE[] = { 0xFE, 0xFF };

		// check for signature or byte order mark

		if (memcmp(byteSignature, byteUtf8, sizeof(byteUtf8)) == 0)
		{
			// UTF-8 signature
			// TODO: not currently supported
		    return NULL;
//			_com_issue_error(E_INVALIDARG);
		}
		else if (memcmp(byteSignature, byteUnicodeLE, sizeof(byteUnicodeLE)) == 0)
		{
			// UNICODE Little Endian Byte Order Mark
			// supported
			// must read in binary mode
			// move file pointer back one byte because we read 3 bytes
			if (fseek(fp, -1, SEEK_CUR))
			{
			    // if unable to move file pointer back, we bail
			    fclose(fp);
			    fp = NULL;
			}
		}
		else if (memcmp(byteSignature, byteUnicodeBE, sizeof(byteUnicodeBE)) == 0)
		{
			// UNICODE Big Endian Byte Order Mark
			// TODO: not currently supported
		    return NULL;
//			_com_issue_error(E_INVALIDARG);
		}
		else
		{
			// assume ANSI
			// re-open file in text mode as the stream i/o functions will
			// treat the file as multi-byte characters and will convert them
			// to UNICODE

			fclose(fp);

			fp = _tfopen(pszFileName, _T("rt"));
		}
	}
	else
	{
		return NULL;
//		_com_issue_error(E_INVALIDARG);
	}

	return fp;
}
//END OpenMappingFile 


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 10 JUNE 2001                                                *
 *                                                                   *
 *     This function is responsible for retrieving a DC from the     *
 * given domain.                                                     *
 *     This function returns the DCName, if retrieved, or an empty   *
 * string.                                                           *
 *                                                                   *
 *********************************************************************/

//BEGIN GetADC
_bstr_t CSecTranslator::GetADC(_bstr_t sDomainName)
{
    _bstr_t strDcName;

    DWORD dwError = GetDcName4(sDomainName, DS_DIRECTORY_SERVICE_PREFERRED, strDcName);

    return (dwError == ERROR_SUCCESS) ? strDcName : _T("");
}
//END GetADC
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sectrans.h ===
// SecTranslator.h : Declaration of the CSecTranslator

#ifndef __SECTRANSLATOR_H_
#define __SECTRANSLATOR_H_

#include "resource.h"       // main symbols

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty") //#imported via sdstat.hpp below
#include "STArgs.hpp"
#include "SDStat.hpp"
#include "EaLen.hpp"
#include "TNode.hpp"

/////////////////////////////////////////////////////////////////////////////
// CSecTranslator
class ATL_NO_VTABLE CSecTranslator : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSecTranslator, &CLSID_SecTranslator>,
	public ISecTranslator
{
public:
	CSecTranslator()
	{
		m_pUnkMarshaler = NULL;
      m_exchServer[0] = 0;
      m_Profile[0] = 0;
      m_Container[0] = 0;
      m_CacheFile[0] = 0;
      m_domain[0] = 0;
      m_username[0] = 0;
      m_password[0] = 0;
      m_LocalOnly = FALSE;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SECTRANSLATOR)
DECLARE_NOT_AGGREGATABLE(CSecTranslator)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSecTranslator)
	COM_INTERFACE_ENTRY(ISecTranslator)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISecTranslator
public:
	STDMETHOD(Process)(IUnknown * pWorkItemIn);

protected:
   SecurityTranslatorArgs    m_Args;
   WCHAR                     m_exchServer[LEN_Computer];
   WCHAR                     m_Profile[LEN_DistName];
   WCHAR                     m_Container[LEN_DistName];
   WCHAR                     m_CacheFile[MAX_PATH];
   WCHAR                     m_domain[LEN_Domain];
   WCHAR                     m_username[LEN_Account];
   WCHAR                     m_password[LEN_Password];
   WCHAR                     m_SourceSid[LEN_Account];
   WCHAR                     m_TargetSid[LEN_Account];
   BOOL                      m_LocalOnly;
   TNodeList                 m_ConnectionList;

   void LoadSettingsFromVarSet(IVarSet * pVarSet);
   void ExportStatsToVarSet(IVarSet * pVarSet, TSDResolveStats * stat);
   void DoResolution(TSDResolveStats * stat);
   void DoLocalGroupResolution(TSDResolveStats * stat);
   void DoExchangeResolution(TSDResolveStats * stat, IVarSet * pVarSet);
   void DoUserRightsTranslation(TSDResolveStats * stat);
   void CleanupSessions();
   BOOL LoadCacheFromVarSet(IVarSet * pVarSet);
   BOOL LoadCacheFromFile(WCHAR const * filename, IVarSet * pVarSet);
   BOOL GetRIDsFromEA();
   BOOL BuildCacheFile(WCHAR const * filename);
   BOOL RemoveExchangeServiceAccountFromCache();
   BOOL EstablishASession(WCHAR const * serverName);
   HRESULT LoadMigratedObjects(IVarSet * pVarSetIn);
   BOOL LoadCacheFromMapFile(WCHAR const * filename, IVarSet * pVarSet);
   FILE* OpenMappingFile(LPCTSTR pszFileName);
   _bstr_t GetADC(_bstr_t sDomainName);
};

#endif //__SECTRANSLATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sidflags.h ===
/*---------------------------------------------------------------------------
  File: SidFlags.h

  Comments: Flags that are used by access checker to return from the
            CanAddSidHistory function.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Created : 9/24/1999 Sham Chauthani
  ---------------------------------------------------------------------------
*/

#ifndef SIDFLAG_H
#define SIDFLAG_H

#define  F_WORKS                    0x00000000
#define  F_WRONGOS                  0x00000001
#define  F_NO_REG_KEY               0x00000002
#define  F_NO_AUDITING_SOURCE       0x00000004
#define  F_NO_AUDITING_TARGET       0x00000008
#define  F_NO_LOCAL_GROUP           0x00000010

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sidcache.cpp ===
//#pragma title ("SidCache.hpp -- Cache, Tree of SIDs")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sidcache.cpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Cache of SIDs.  Implemented using TNode derived classes, Cache is 
               organized as a tree, sorted by Domain B RID.  Each node contains 
               Domain A RID, Domain B RID, Account Name, and counters for stats.  
Updates     -
===============================================================================
*/
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

#include "stdafx.h"

#include <malloc.h>
#include <winbase.h>
#include <lm.h>
#include <lmaccess.h>
#include <assert.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "Ustring.hpp"
#include "sidcache.hpp"

#include "CommaLog.hpp"
#include "TxtSid.h"
#include "ResStr.h"
#include "EaLen.hpp"
#include "GetDcName.h"

// from sdresolve.hpp
extern BOOL BuiltinRid(DWORD rid);
extern DWORD OpenDomain(WCHAR const * domain);

extern TErrorDct err;
extern TErrorDct errAlt;
extern bool useErrAlt;

extern bool silent;

/***************************************************************************************************/
/* vRidComp is used as a compare function for TSidNode Trees
// It searches for v1 in the ridA field.  The Tree must be sorted with RidComp before using this 
// search fn.
// Return values:  0   tn->ridA == v1
//                 1   tn->ridA < v1   
//                -1   tn->ridA > v1  
// 
/**************************************************************************************************/
int
   vRidComp(
      const TNode           * tn,           // in -TSidNode 
      const void            * v1            // in -DWORD ridA value to look for
   )
{
   DWORD                     rid1;
   DWORD                     rid2;
   TRidNode                * n2;
   int                       retval;
   assert( tn );                    // we should always be given valid inputs
   assert( v1 );
   
   n2 = (TRidNode *)tn;
   rid1 = n2->SrcRid();
   rid2 = *(DWORD *)v1;
   if ( rid1 < rid2 )
   {
      retval = -1;
   }
   if (rid1 > rid2)
   {
      retval = 1;
   }
   if ( rid1 == rid2)  // ( rid1 == rid2 )
   {
      retval = 0;
   }
   return retval;
}
/***************************************************************************************************/
/* RidComp:  used as a compare function for TSidNode Trees
     
   It compares the ridA fields of SIDTNodes
   
   Return Values:
                  0     t1->ridA == t2->ridA
                  1     t1->ridA >  t2->ridA
                 -1     t1->ridA <  t2->ridA

/***************************************************************************************************/

int RidComp(
   const TNode             * t1,     //in -first node to compare
   const TNode             * t2      //in -second node to compare
   )
{
   assert( t1 );
   assert( t2 );

   TRidNode                * st1 = (TRidNode *) t1;
   TRidNode                * st2 = (TRidNode *) t2;
   DWORD                     rid1 = st1->SrcRid();
   DWORD                     rid2 = st2->SrcRid();
   int                       retval;

   if ( rid1 < rid2 )
   {
      retval = -1;
   }
   if (rid1 > rid2)
   {
      retval = 1;
   }
   if ( rid1 == rid2 ) // (rid1 == rid2)
   {
      retval = 0;
   }
   return retval;
}
/***************************************************************************************************
 vNameComp: used as a compare function for TSidNode trees

   It compares a UNICODE string, with the acct_name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/

int 
   vNameComp(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )

{
   assert( tn );
   assert( actname );

   LPWSTR                    str1 = ((TRidNode *)tn)->GetAcctName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
/***************************************************************************************************/
/* CompN:  used as a compare function for TSidNode Trees
     
   It compares the acct_name fields of SIDTNodes
   
   Return Values:
                  0     t1->acct_name == t2->acct_name
                  1     t1->acct_name >  t2->acct_name
                 -1     t1->acct_name <  t2->acct_name

   Error Handling:
      if given bad inputs, CompN displays an error message and returns 0
/***************************************************************************************************/

int 
   CompN(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  
   assert( v1 );
   assert( v2 );

   TRidNode                * t1 = (TRidNode *)v1;
   TRidNode                * t2 = (TRidNode *)v2;
  
   return UStrICmp(t1->GetAcctName(),t2->GetAcctName());
} 

int 
   vTargetNameComp(
      const TNode          * tn,          //in -tree node  
      const void           * actname      //in -name to look for  
   )

{
   assert( tn );
   assert( actname );

   LPWSTR                    str1 = ((TRidNode *)tn)->GetTargetAcctName();
   LPWSTR                    str2 = (LPWSTR) actname;
  
   return UStrICmp(str1,str2);
}
int 
   CompTargetN(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{  
   assert( v1 );
   assert( v2 );

   TRidNode                * t1 = (TRidNode *)v1;
   TRidNode                * t2 = (TRidNode *)v2;
  
   return UStrICmp(t1->GetTargetAcctName(),t2->GetTargetAcctName());
} 

int 
   TSidCompare(
      PSID const             sid1,     // in - first sid to compare
      PSID const             sid2      // in - second sid to compare
   )
{
   DWORD                     len1,
                             len2;
   int                       retval = 0;

   len1 = GetLengthSid(sid1);
   len2 = GetLengthSid(sid2);

   if ( len1 < len2 )
   {
      retval = -1;
   }
   if ( len1 > len2 )
   {
      retval = 1;
   }
   if ( len1 == len2 )
   {
      retval = memcmp(sid1,sid2,len1);
   }

   return retval;
}
/**************************************************************************************************
 vSidComp: used as a compare function for TSidNode trees

   It compares a UNICODE string, with the acct_name field in the node
   
   Return Values:
                     0    tn->acct_name == actname 
                     1    tn->acct_name <  actname
                    -1    tn->acct_name >  actname 

/***************************************************************************************************/
int 
   vSidComp(
      const TNode          * tn,          //in -tree node  
      const void           * val         //in -sid to look for  
   )
{
   PSID                     sid1 = ((TGeneralSidNode *)tn)->SrcSid();
   PSID                     sid2 = (PSID)val;

   return TSidCompare(sid1,sid2);
}


int 
   nSidComp(
      const TNode          * v1,       //in -first node to compare
      const TNode          * v2        //in -second node to compare
   )
{
   TGeneralSidNode                * t1 = (TGeneralSidNode *)v1;
   TGeneralSidNode                * t2 = (TGeneralSidNode *)v2;
  
   return TSidCompare(t1->SrcSid(), t2->SrcSid());
}
   

/*******************************************************************************************************/
//                                 TSidNode Implementation
/*******************************************************************************************************/

TGeneralCache::TGeneralCache()
{
   CompareSet(&nSidComp);
   TypeSetTree();
}

TGeneralCache::~TGeneralCache()
{
   DeleteAllListItems(TGeneralSidNode);
}

void * TRidNode::operator new(size_t sz, const LPWSTR oldname, const LPWSTR newname)
{
   int                       nlen = UStrLen(newname) + UStrLen(oldname) + 1;
   void                    * node = malloc(sz + nlen * (sizeof WCHAR) );

   return node;
}

   TAcctNode::TAcctNode()
{
   owner_changes = 0;
   group_changes = 0; 
   ace_changes   = 0;
   sace_changes  = 0; 
}

WCHAR *                                   // ret- domain part of name 
   GetDomainName(
   WCHAR *                   name         // in - domain\\account name
   )
{
   assert (name);

   int                       i;
   int                       len = UStrLen(name);
   WCHAR                   * domain;
   
   for (i = 2 ; name[i] != '\\' && i < len ; i++ )
   ;
   if ( i < len )
   {
      domain = new WCHAR[i+1];
	  if (!domain)
	     return NULL;
      UStrCpy(domain,name,i);
   }
   else
   {
      domain = NULL;
   }
   return domain;
}

   TGeneralSidNode::TGeneralSidNode(
      const LPWSTR           name1,        // in - account name on source domain
      const LPWSTR           name2         // in - account name on target domain
  )
{
   assert (name1 && name2);
   assert (*name1 && *name2);
   
   WCHAR                   * domname = NULL;

   memset(&ownerStats,0,(sizeof ownerStats));
   memset(&groupStats,0,(sizeof ownerStats));
   memset(&daclStats,0,(sizeof ownerStats));
   memset(&saclStats,0,(sizeof ownerStats));

   src_acct_name = new WCHAR[UStrLen(name1)+1];
   if (!src_acct_name)
      return;
   safecopy(src_acct_name,name1);
   tgt_acct_name = new WCHAR[UStrLen(name2) + 1];
   if (!tgt_acct_name)
      return;
   safecopy(tgt_acct_name,name2);
   SDRDomainInfo             info;
   domname = GetDomainName(name1);
   if (!domname)
      return;
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )
   {
      src_domain = new WCHAR[UStrLen(info.domain_name)];
      if (!src_domain)
         return;
      safecopy(src_domain, info.domain_name);
      // src_dc = info.dc_name;
      src_nsubs = info.nsubs;
      src_sid = info.domain_sid;
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_DOMAIN_NOT_FOUND_S,domname);
      src_domain = NULL;
      //   src_dc = NULL;
      src_nsubs = 0;
      src_sid = NULL;
   }
   if(domname)
   {
      delete [] domname;
   }
   domname = NULL;
   
   domname = GetDomainName(name2);
   if (!domname)
      return;
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )
   {
      tgt_domain = new WCHAR[UStrLen(info.domain_name)];
      if (!tgt_domain)
         return;
      safecopy(tgt_domain, info.domain_name);
      tgt_nsubs = info.nsubs;
      tgt_sid = info.domain_sid;
   }
   else
   {
      err.MsgWrite(ErrE,DCT_MSG_DOMAIN_NOT_FOUND_S,domname);
      tgt_domain = NULL;
      tgt_nsubs = 0;
      tgt_sid = NULL;
   }
   sizediff = GetSidLengthRequired(tgt_nsubs) - GetSidLengthRequired(src_nsubs);

   if(domname)
   {
       delete [] domname;
   }

}


WCHAR *                                      // ret- textual representation of sid
   BuildSidString(
      PSID                   pSid            // in - sid
   )
{
   WCHAR                   * buf = NULL;
   DWORD                     bufLen = 0;

   GetTextualSid(pSid,NULL,&bufLen);

   buf = new WCHAR[bufLen+1];
   if (!buf)
      return NULL;

   if ( ! GetTextualSid(pSid,buf,&bufLen) )
   {
      wcscpy(buf,L"<Unknown>");
   }
   return buf;
}
   
TGeneralSidNode::TGeneralSidNode(
   const PSID                pSid1,          // in - source domain sid
   const PSID                pSid2           // in - target domain sid
   )
{
   WCHAR                     domain[LEN_Domain];
   WCHAR                     account[LEN_Account];
   DWORD                     lenDomain = DIM(domain);
   DWORD                     lenAccount = DIM(account);
   SID_NAME_USE              snu;
   DWORD                     nBytes;
   
   memset(&ownerStats,0,(sizeof ownerStats));
   memset(&groupStats,0,(sizeof ownerStats));
   memset(&daclStats,0,(sizeof ownerStats));
   memset(&saclStats,0,(sizeof ownerStats));

   
   // Source domain
   if ( pSid1 )
   {
      // Make a copy of the SID 
      src_nsubs = *GetSidSubAuthorityCount(pSid1);
      nBytes = GetSidLengthRequired(src_nsubs);
      src_sid = new BYTE[nBytes];
	  if (!src_sid)
	     return;
      CopySid(nBytes,src_sid,pSid1);
      // Look up name for source SID
      if ( LookupAccountSid(NULL,pSid1,account,&lenAccount,domain,&lenDomain,&snu) )
      {
         if ( lenAccount == 0 && snu == SidTypeDeletedAccount )
         {
            WCHAR * buf = BuildSidString(pSid1);
			if (!buf)
		       return;
            swprintf(account,L"<Deleted Account (%s)>",buf);
            delete [] buf;
         }
         src_acct_name = new WCHAR[UStrLen(domain) + 1 + UStrLen(account)+1];
	     if (!src_acct_name)
	        return;
         swprintf(src_acct_name,L"%s\\%s",domain,account);
         src_domain = NULL;
      }
      else
      {
         src_acct_name = BuildSidString(pSid1);
		 if (!src_acct_name)
		    return;
         src_domain = NULL;
      }
   }
   else
   {
      src_nsubs = 0;
      src_sid = NULL;
      src_acct_name = NULL;
      src_domain = NULL;
   }

   // Target domain
   if ( pSid2 )
   {
      tgt_nsubs = *GetSidSubAuthorityCount(pSid2);
      nBytes = GetSidLengthRequired(tgt_nsubs);
      tgt_sid = new BYTE[nBytes];
	  if (!tgt_sid)
	     return;
      CopySid(nBytes,tgt_sid,pSid2);
      if ( LookupAccountSid(NULL,pSid2,account,&lenAccount,domain,&lenDomain,&snu) )
      {
         tgt_acct_name = new WCHAR[UStrLen(domain) + 1 + UStrLen(account)+1];
	     if (!tgt_acct_name)
	        return;
         swprintf(tgt_acct_name,L"%s\\%s",domain,account);
         tgt_domain = NULL;
      }
      else
      {
         tgt_acct_name = NULL;
         tgt_domain = NULL;
      }
   }
   else
   {
      tgt_nsubs = 0;
      tgt_sid = NULL;
      tgt_acct_name = NULL;
      tgt_domain = NULL;
   }
   sizediff = GetSidLengthRequired(src_nsubs) - GetSidLengthRequired(tgt_nsubs);
}
   
   TGeneralSidNode::~TGeneralSidNode()
{
   if ( src_acct_name )
      delete [] src_acct_name;
   if ( tgt_acct_name )
      delete [] tgt_acct_name;
   if ( src_sid )
      delete [] src_sid;
   if ( tgt_sid )
      delete [] tgt_sid;
   if ( src_domain )
      delete [] src_domain;
   if ( tgt_domain )
      delete [] tgt_domain;
}    

   TRidNode::TRidNode(
      const LPWSTR           oldacctname,       // in -source account name
      const LPWSTR           newacctname        // in -target account name
   )
{
   assert(tgtDomSid.c_str() == NULL);
   srcRid = 0;
   tgtRid = 0; 
   status = DEFAULT;
   
   if ( ! newacctname )
   {
      acct_len = -1;
      swprintf(acct_name,L"%s",oldacctname);
      acct_name[UStrLen(acct_name)+1] = 0;
   }
   else
   {
      acct_len = UStrLen(oldacctname);
      swprintf(acct_name,L"%s:%s",oldacctname,newacctname);
      acct_name[acct_len] = 0; 
   }
}
   TRidNode::~TRidNode()
{
   
}

/*******************************************************************************************************/
//                                 TSidCache Implementation
/*******************************************************************************************************/

void 
   TSDRidCache::ReportAccountReferences(
      WCHAR          const * filename              // in - filename to record account references
   )
{
   if ( m_otherAccounts )
   {
      CommaDelimitedLog      resultLog;

      if ( resultLog.LogOpen(filename,FALSE) )
      {

         TGeneralSidNode   * gnode;
         TNodeTreeEnum       tEnum;

         for ( gnode = (TGeneralSidNode *)tEnum.OpenFirst(m_otherAccounts) ; gnode ; gnode = (TGeneralSidNode*)tEnum.Next() )
         {
            TSDFileDirCell       * pOwner = gnode->GetOwnerStats();
            TSDFileDirCell       * pGroup = gnode->GetGroupStats();
            TSDFileDirCell       * pDacl = gnode->GetDaclStats();
            TSDFileDirCell       * pSacl = gnode->GetSaclStats();
            WCHAR * sAccountSid = BuildSidString(gnode->SrcSid());
			if (!sAccountSid)
		       return;

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_File),
                                                          pOwner->file,
                                                          pGroup->file,
                                                          pDacl->file,
                                                          pSacl->file );
            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Dir),
                                                          pOwner->dir,
                                                          pGroup->dir,
                                                          pDacl->dir,
                                                          pSacl->dir );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Share),
                                                          pOwner->share,
                                                          pGroup->share,
                                                          pDacl->share,
                                                          pSacl->share );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Mailbox),
                                                          pOwner->mailbox,
                                                          pGroup->mailbox,
                                                          pDacl->mailbox,
                                                          pSacl->mailbox );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Container),
                                                          pOwner->container,
                                                          pGroup->container,
                                                          pDacl->container,
                                                          pSacl->container );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Member),
                                                          pOwner->member,
                                                          pGroup->member,
                                                          pDacl->member,
                                                          pSacl->member );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_UserRight),
                                                          pOwner->userright,
                                                          pGroup->userright,
                                                          pDacl->userright,
                                                          pSacl->userright );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_RegKey),
                                                          pOwner->regkey,
                                                          pGroup->regkey,
                                                          pDacl->regkey,
                                                          pSacl->regkey );

            resultLog.MsgWrite(L"%s,%s,%s,%ld,%ld,%ld,%ld",gnode->GetAcctName(),
														  sAccountSid,
														  GET_STRING(IDS_STReference_Printer),
                                                          pOwner->printer,
                                                          pGroup->printer,
                                                          pDacl->printer,
                                                          pSacl->printer );

			if (sAccountSid)
               delete sAccountSid;
         }
         tEnum.Close();
         resultLog.LogClose();
      }
      else
      {
         err.MsgWrite(ErrE,DCT_MSG_COULD_NOT_OPEN_RESULT_FILE_S,filename);
      }
   }
}
      
//----------------------------------------------------------------------------
// Function:   VerifyTargetSids
//
// Synopsis:   This function checks all target sids in the cache.  If a target sid is not valid,
//                  the particular TRidNode will be marked with TRidNode::TARGETSIDISINVALID.
//                  We only concern about the case where the target domain sid is defined in
//                  the TSDRidCache.
//
// Arguments:  none
//
// Returns:    none
//
// Modifies:   mark the TRidNode status to TRidNode::TARGETSIDISINVALID 
//                 if the target sid is not valid
//
//----------------------------------------------------------------------------

void TSDRidCache::VerifyTargetSids()
{
    TNodeListEnum cacheEnumerator;

    TRidNode* aRidNode;

    // We only concern about the case where the target domain sid is defined in TSDRidCache
    // If it is not defined, TRidNode's are probably inserted with InsertLastWithSid, which
    // means the sid has been verified to be valid already (sid mapping file).
    if (to_sid != NULL)
    {
        DWORD dwSidSize = GetSidLengthRequired(to_nsubs);
        PSID targetSid = (PSID) new byte[dwSidSize];
        if (targetSid == NULL)
            _com_issue_error(E_OUTOFMEMORY);
        
        CopySid(dwSidSize, targetSid, to_sid);                          // copy the target domain sid
        PDWORD rid = GetSidSubAuthority(targetSid,to_nsubs -1);
        
        // go through each Node to check the target sid
        for (aRidNode = (TRidNode *) cacheEnumerator.OpenFirst(this);
               aRidNode != NULL && aRidNode->TgtRid() != 0;
               aRidNode = (TRidNode *) cacheEnumerator.Next())
        {
            // make sure that the TRidNode object is not using its own target domain sid
            // if it is using its own, we assume that the target sid has been verified
            // if target domain sid string is not empty, the TRidNode object uses its own target domain sid
            PCWSTR pszRidNodeOwnTgtDomSid = aRidNode->GetTgtDomSid();
            if (pszRidNodeOwnTgtDomSid != NULL && *pszRidNodeOwnTgtDomSid != L'\0')
                continue;
            
            (*rid) = aRidNode->TgtRid();                                 // replace last sub with this node's RID

            // look up the sid
            BOOL bIsTargetSidValid = TRUE;
            if (!aRidNode->IsValidOnTgt())
            {
                // if target rid is 0 or already verified before, we don't need to verify it again
                bIsTargetSidValid = FALSE;
            }
            else
            {
                WCHAR name[MAX_PATH];
                WCHAR domainName[MAX_PATH];
                DWORD cbName = MAX_PATH;
                DWORD cbDomainName = MAX_PATH;
                SID_NAME_USE sid_use;
                if (!LookupAccountSid(NULL, targetSid, name, &cbName, domainName, &cbDomainName, &sid_use))
                {
                    bIsTargetSidValid = FALSE;
                    aRidNode->SetStatus(aRidNode->GetStatus() | TRidNode::TARGETSIDISINVALID);
                }
            }
        }
        
        if (targetSid)
            delete[] ((byte*)targetSid);
    }
}

void 
   TSDRidCache::ReportToVarSet(
      IVarSet              * pVarSet,           // in -varset to write information to
      bool                   summary,           // in -flag: whether to print summary information 
      bool                   detail             // in -flag: whether to print detailed stats
   ) 
{
   TNodeTreeEnum             tEnum;
   TRidNode                * tnode;
   long                      users=0;
   long                      lgroups=0;
   long                      ggroups=0;
   long                      other=0;
   long                      unres_users=0;
   long                      unres_lg=0;
   long                      unres_gg=0;
   long                      unres_other=0;
   long                      total=0;
   long                      n = 0;    
  // sort the cache by names before printing the report
   if (IsTree())
   {
       ToSorted();
   }
   SortedToScrambledTree();
   Sort(&CompN);
   Balance();
   if ( detail )
   {
      for ( tnode = (TRidNode *)tEnum.OpenFirst(this) ; tnode ; tnode = (TRidNode *)tEnum.Next() )
      {
         if( tnode->ReportToVarSet(pVarSet,n) )
         {
            n++;
         }
         switch ( tnode->Type() )
         {
            case EA_AccountGroup: ggroups++; break;
            case EA_AccountGGroup: ggroups++; break;
            case EA_AccountLGroup: lgroups++; break;
            case EA_AccountUser: users++; break;
            default:
               other++;
               err.MsgWrite(0,DCT_MSG_BAD_ACCOUNT_TYPE_SD,tnode->GetAcctName(),tnode->Type() );
         }
   
      }

      tEnum.Close();

      if ( m_otherAccounts )
      {
         TGeneralSidNode   * gnode;

         for ( gnode = (TGeneralSidNode *)tEnum.OpenFirst(m_otherAccounts) ; gnode ; gnode = (TGeneralSidNode*)tEnum.Next() )
         {
            if( gnode->ReportToVarSet(pVarSet,n) )
            {
               n++;
            }
            other++;
         }
      }
      total = users+lgroups+ggroups+other + unres_gg + unres_lg + unres_users + unres_other;

      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumUsers),users);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumGlobalGroups),ggroups);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumLocalGroups),lgroups);
      pVarSet->put(GET_BSTR(DCTVS_Stats_Accounts_NumOther),other);

   }
   // re-sort by rid after printing the report
   if (IsTree())
   {
       ToSorted();
   }
   SortedToScrambledTree();
   Sort(&RidComp);
   Balance();
}

/***************************************************************************************************/
/* TSidCache::Display: Displays the summary information, and/or contents of the TSidCache tree

  
/***************************************************************************************************/
void 
   TSDRidCache::Display(
      bool                   summary,           // in -flag: whether to print summary information 
      bool                   detail             // in -flag: whether to print detailed stats
   ) 
{
   TNodeTreeEnum             tEnum;
   TRidNode                * tnode;
   long                      users=0;
   long                      lgroups=0;
   long                      ggroups=0;
   long                      other=0;
   long                      unres_users=0;
   long                      unres_lg=0;
   long                      unres_gg=0;
   long                      unres_other=0;
   long                      total=0;
 
   //     
   // sort the cache by names before printing the report
   //
   // Note that the tree generated during the Sort method may become grossly un-balanced if
   // the data is already in the same order that the Sort method sorts the data. A stack
   // overflow may occur in the Balance method when it tries to convert the un-balanced tree
   // into a linked list before generating a balanced tree.
   //
   // Therefore it is necessary to generate a random 'scrambled' tree before re-sorting. If
   // already a tree the data must be converted to a list before generating the random tree.
   //

   if (IsTree())
   {
       ToSorted();
   }
   SortedToScrambledTree();
   Sort(&CompN);
   Balance();
   if ( detail )
   {
      err.MsgWrite(0,DCT_MSG_ACCOUNT_DETAIL_HEADER);
      err.MsgWrite(0, DCT_MSG_ACCOUNT_DETAIL_FORMAT);
      for ( tnode = (TRidNode *)tEnum.OpenFirst(this) ; tnode ; tnode = (TRidNode *)tEnum.Next() )
      {
         tnode->DisplayStats();
         switch ( tnode->Type() )
         {
            case EA_AccountGroup: ggroups++; break;
            case EA_AccountGGroup: ggroups++; break;
            case EA_AccountLGroup: lgroups++; break;
            case EA_AccountUser: users++; break;
            default:
               other++;
               err.MsgWrite(0,DCT_MSG_BAD_ACCOUNT_TYPE_SD,tnode->GetAcctName(),tnode->Type() );
         }
   
      }
      total = users+lgroups+ggroups+other + unres_gg + unres_lg + unres_users + unres_other;

      err.MsgWrite(0,DCT_MSG_ACCOUNT_DETAIL_FOOTER);
   }
   if ( summary )
   {
      err.MsgWrite(0,DCT_MSG_ACCOUNT_USER_GROUP_COUNT_DD,users+unres_users,ggroups+unres_gg+lgroups+unres_lg);
      err.MsgWrite(0,DCT_MSG_ACCOUNT_STATUS_COUNT_DDD,accts,accts_resolved,accts - accts_resolved);
   }
   // re-sort by rid after printing the report
   if (IsTree())
   {
       ToSorted();
   }
   SortedToScrambledTree();
   Sort(&RidComp);
   Balance();
}
/***************************************************************************************************/
/* GetSidB: 

         Builds a sid containing the Identifier Authority from the target-domain SID, along with the 
         RID from the ridB field of the supplied node.   

/***************************************************************************************************/

PSID                                // ret -the domain B sid for the account referenced in tnode
   TSDRidCache::GetTgtSid(
      const TAcctNode       * anode // in -node to copy RID from
   ) 
{
   
   TRidNode                * tnode = (TRidNode *)anode; 
   
   assert( tnode );                         
   assert( tnode->TgtRid() != 0);     
   assert( to_sid );                // we can't resolve if we don't have domain B sid
   
   PDWORD                    rid;
   DWORD                     sidsize = GetSidLengthRequired(to_nsubs);
   PSID                      newsid  = malloc(sidsize);
   
   if (newsid)
   {
      CopySid(sidsize,newsid,to_sid);                          // copy the domain B sid
      rid = GetSidSubAuthority(newsid,to_nsubs -1);
      
      assert( (*rid) == -1 );                                  // FillCache makes sure to_sid always ends with -1(f...f)
                                                             
      (*rid)=tnode->TgtRid();                                 // replace last sub with this node's RID
   }

   return newsid;
}

// GetTgtSidWODomain:
//    Returns the target sid for this node without having the target domain information
// filled in (like when we reACl using a sID mapping file).
PSID                                // ret -the domain B sid for the account referenced in tnode
   TSDRidCache::GetTgtSidWODomain(
      const TAcctNode       * anode // in -node to copy RID from
   ) 
{
   
   TRidNode                * tnode = (TRidNode *)anode;
   
   assert( tnode );                         
   assert( tnode->TgtRid() != 0);     
   
   PDWORD                    rid;

      //get and convert the target domain sid stored in the node to a PSID
   PSID pTgtSid = MallocedSidFromString(tnode->GetTgtDomSid());
   if (pTgtSid)
   {
      PUCHAR pCount = GetSidSubAuthorityCount(pTgtSid);
      DWORD nSub = (DWORD)(*pCount) - 1;
   
      rid = GetSidSubAuthority(pTgtSid,nSub);
   
      assert( (*rid) == -1 );                                  // FillCache makes sure to_sid always ends with -1(f...f)
                                                          
      (*rid)=tnode->TgtRid();                                 // replace last sub with this node's RID
   }
   return pTgtSid;
}

// GetTgtSidWODomain:
//    Returns the target sid for this node without having the target domain information
// filled in (like when we reACl using a sID mapping file).
PSID
   TSDRidCache::GetTgtSidWODomain(
      const PSID psid                     // in - the source sid
   ) 
{
    TAcctNode* tn = LookupWODomain(psid);
    if (tn)
        return GetTgtSidWODomain(tn);
    else
        return NULL;
}

/***************************************************************************************************/
/*  Display sid - Displays the contents of a SID.
    The sid given is assumed to be a valid SID
/***************************************************************************************************/
void 
   DisplaySid(
      const PSID             ps                 // in -pointer to the sid to display
   ) 
{
   assert( ps );

   PUCHAR                    ch = GetSidSubAuthorityCount(ps);
   DWORD                     nsubs = *ch;
   DWORD                     i;
   PSID_IDENTIFIER_AUTHORITY ida = GetSidIdentifierAuthority(ps);
   
   for ( i = 0 ; i < 6 ; i++ )                               // 6 value fields in IA
   {
      printf("%ld, ",ida->Value[i]);
   }
   printf("\n%ld Subs: ",nsubs);
   for ( i = 0 ; i < nsubs ; i++ )                           // print subauthority values
   {
      printf("\nS[%d]= %ld  ",i,*GetSidSubAuthority(ps,i));
   }
   printf("\n");
}
/***************************************************************************************************/
/* DisplaySid:  If the sid is found in the cache, display the associated name, otherwise display 
                the sid contents.
   ps and C are assumed to be valid.
/***************************************************************************************************/
void 
   DisplaySid(
      const PSID             ps,                // in- sid to display
      TAccountCache        * C                  // in- TSidCache to look for sid in
   )
{
   assert ( ps );

   if ( !C )  
   {
      DisplaySid(ps);
   }
   else 
   {
      WCHAR                * name = C->GetName(ps);
      if ( name )
      {
         err.MsgWrite(0,DCT_MSG_GENERIC_S,name);
      }
      else 
      {
         DisplaySid(ps);
      }
   }
}
/***************************************************************************************************/
//DispSidInfo:  Displays contents of the TSidNode

/***************************************************************************************************/
void 
   TRidNode::DisplaySidInfo() const
{
   err.DbgMsgWrite(0,L"\nRid A= %ld \nName= %S \nRid B= %ld\n",srcRid,acct_name,tgtRid);
   err.DbgMsgWrite(0,L"Owner changes:  %ld\n",owner_changes);
   err.DbgMsgWrite(0,L"Group changes:  %ld\n",group_changes);
   err.DbgMsgWrite(0,L"ACE changes:    %ld\n",ace_changes);
   err.DbgMsgWrite(0,L"SACE changes:   %ld\n",sace_changes);
   if ( !IsValidOnTgt() ) 
      err.DbgMsgWrite(0,L"Target RID is not valid\n"); 
}
void 
   TAcctNode::DisplayStats() const
{
   LPWSTR res;
   if ( IsValidOnTgt() )
      res = L"";
   else
      res = (WCHAR*)GET_BSTR(IDS_UNRESOLVED);
   if (owner_changes || group_changes || ace_changes || sace_changes)
      err.MsgWrite(0,DCT_MSG_ACCOUNT_REFS_DATA_SDDDDS,owner_changes,group_changes,ace_changes,sace_changes,res);
}
void 
   TRidNode::DisplayStats() const
{
   LPWSTR res;
   if ( IsValidOnTgt() )
      res = L"";
   else
      res = (WCHAR*)GET_BSTR(IDS_UNRESOLVED);
#ifndef _DEBUG
   if (owner_changes || group_changes || ace_changes || sace_changes )
      err.MsgWrite(0,DCT_MSG_ACCOUNT_REFS_DATA_SDDDDS,acct_name,owner_changes,group_changes,ace_changes,sace_changes,res);
#else
   if (owner_changes || group_changes || ace_changes || sace_changes || true)
      err.DbgMsgWrite(0,L"%-35ls (%ld, %ld, %ld, %ld) %ls [%ld,%ld]",acct_name,owner_changes,group_changes,ace_changes,sace_changes,res,srcRid,tgtRid);
#endif
}


BOOL                                        // ret- TRUE if details reported, FALSE if skipped blank record 
   TAcctNode::ReportToVarSet(
      IVarSet              * pVarSet       ,// in - VarSet to write data to
      DWORD                  n              // in - index of account in varset
   ) 
{
   BOOL                      bRecorded = FALSE;

   if ( owner_changes || group_changes || ace_changes || sace_changes )
   {
      WCHAR                  key[200];

      swprintf(key,L"Stats.Accounts.%ld.Name",n);
      pVarSet->put(key,GetAcctName());

      swprintf(key,L"Stats.Accounts.%ld.Owners",n);
      pVarSet->put(key,(LONG)owner_changes);
            
      swprintf(key,L"Stats.Accounts.%ld.Groups",n);
      pVarSet->put(key,(LONG)group_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.ACEs",n);
      pVarSet->put(key,(LONG)ace_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.SACEs",n);
      pVarSet->put(key,(LONG)sace_changes);
      
      swprintf(key,L"Stats.Accounts.%ld.Resolved",n);
      if ( IsValidOnTgt() )
      {
         pVarSet->put(key,L"Yes");
      }
      else
      {
         pVarSet->put(key,L"No");
      }

      bRecorded = TRUE;
   }
   return bRecorded;
}

/****************************************************************************************************/
/*                SIDTCache Implementation */
/***************************************************************************************************/
   TSDRidCache::TSDRidCache()
{
   from_sid       = NULL;
   to_sid         = NULL;
   from_domain[0] = 0;
   to_domain[0]   = 0;
   from_dc[0]     = 0;
   to_dc[0]       = 0;
   from_nsubs     = 0;
   to_nsubs       = 0;
   accts          = 0;
   accts_resolved = 0;
   m_otherAccounts = NULL;
   CompareSet(&CompN);       //start with an empty tree, to be sorted by acct_name
   TypeSetTree();
}

void 
   TSDRidCache::CopyDomainInfo( 
      TSDRidCache const    * other
   )
{
   from_nsubs = other->from_nsubs;
   to_nsubs = other->to_nsubs;
   from_sid = NULL;
   to_sid = NULL;

   if ( other->from_sid )
      from_sid = malloc(GetSidLengthRequired(from_nsubs));
   if ( other->to_sid )
      to_sid = malloc(GetSidLengthRequired(to_nsubs));

   if ( from_sid )
      CopySid(GetSidLengthRequired(from_nsubs),from_sid,other->from_sid);
   if ( to_sid )
      CopySid(GetSidLengthRequired(to_nsubs),to_sid,other->to_sid);
   
   safecopy(from_domain,other->from_domain);
   safecopy(to_domain,other->to_domain);
   safecopy(from_dc,other->from_dc);
   safecopy(to_dc,other->to_dc);
}

void 
   TSDRidCache::Clear()
{
   TRidNode               * node;
   
   for ( node = (TRidNode *)Head() ;  node ; Remove(node) , free(node), node = (TRidNode *)Head() )
   ;

   accts = 0;
   accts_resolved = 0;
}
   
   TSDRidCache::~TSDRidCache()
{
   if ( from_sid ) 
   {
      free(from_sid);
      from_sid = NULL;
   }
   if ( to_sid )
   {
      free(to_sid);
      to_sid = NULL;
   }
   // empty the list, and free each node
   TRidNode               * node;
   for ( node = (TRidNode *)Head() ;  node ; Remove(node) , free(node), node = (TRidNode *)Head() )
   ;
   if ( m_otherAccounts )
      delete m_otherAccounts;
   }
/***************************************************************************************************/
/* SizeDiff: 
            Returns (Length of Domain B SID) - (Length of Domain A SID)
                     if Domain B sids are longer, otherwise returns 0
         This is used to figure out how much space to allocate for new SIDs in the ACEs
         This function assumes that from_sid and to_sid (from_nsubs and to_nsubs) are valid
/***************************************************************************************************/ 
DWORD 
   TSDRidCache::SizeDiff(
      const TAcctNode *  tnode      // in -this parameter is not used for TSDRidCache
   ) const 
{
   assert( from_sid );        // not having from_sid or to_sid should abort the program
   assert( to_sid );

   DWORD                     fromsize = GetSidLengthRequired(from_nsubs);
   DWORD                     tosize   = GetSidLengthRequired(to_nsubs);
   DWORD                     retval;
   if ( fromsize >= tosize )
   {
      retval = 0;
   }
   else 
   {
      retval = tosize - fromsize;
   }
   return retval;
}

/*****************************************************************************************************/
/*   DomainizeSidFst: 
         Takes a domain sid, and verifies that its last subauthority value is -1.  If the RID is not 
         -1, DomainizeSid adds a -1 to the end. 
/*****************************************************************************************************/
PSID                                            // ret -the sid with RID = -1
   DomainizeSidFst(
      PSID                   psid,               // in -sid to check and possibly fix
      BOOL                   freeOldSid          // in -whether to free the old sid 
   ) 
{
   assert (psid);

   UCHAR                     len = (* GetSidSubAuthorityCount(psid));
   PDWORD                    sub = GetSidSubAuthority(psid,len-1);
   
   if ( *sub != -1 )
   {
      DWORD                  sdsize = GetSidLengthRequired(len+1);  // sid doesn't already have -1 as rid
      PSID                   newsid = (SID *)malloc(sdsize); // copy the sid, and add -1 to the end
	  if (!newsid)
	  {
         assert(false);
	     return psid;
	  }
   
      if ( ! InitializeSid(newsid,GetSidIdentifierAuthority(psid),len+1) )  // make a bigger sid w/same IA
      {
         err.SysMsgWrite(ErrU,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         assert (false);
      }
      for ( DWORD i = 0 ; i < len ; i++ )
      {
         sub = GetSidSubAuthority(newsid,i);                        // copy subauthorities
         (*sub) = (*GetSidSubAuthority(psid,i));
      }
      sub = GetSidSubAuthority(newsid,len);
      *sub = -1;                                                  // set rid =-1
      if ( freeOldSid )
      {
         free(psid);
      }
      psid = newsid;
      len++;
   }
  return psid;   
}            

void 
   SetDomainInfoStructFromSid(
      PSID                  pSid,          // in -sid for domain
      SDRDomainInfo       * info           // out-struct containing information
   )
{
//   if ( (pSid) )
   if ( IsValidSid(pSid) )
   {
      info->domain_name[0] = 0;
      info->dc_name[0] = 0;
      info->domain_sid = DomainizeSidFst(pSid,FALSE/*don't free old sid*/);
      info->nsubs = *GetSidSubAuthorityCount(info->domain_sid);
      info->valid = TRUE;
   }
   else
   {
//      info->domain_name[0] = 0;
//      info->dc_name[0] = 0;
//      info->valid = TRUE;
      err.MsgWrite(ErrE,DCT_MSG_INVALID_DOMAIN_SID);
      info->valid = FALSE;
   }

}
void                                         
   SetDomainInfoStruct(
      WCHAR const *         domname,        // in -name of domain
      SDRDomainInfo       * info            // in -struct to put info into
   )
{
   DWORD                    rc = 0;
   WCHAR                    domain[LEN_Computer];
   BOOL                     found = FALSE;
   _bstr_t                  computer;


   safecopy(domain,domname);
   
   info->valid = FALSE;
   safecopy(info->domain_name, domname);
   // get the domain controller name
   rc = GetAnyDcName4(domain, computer);
   if ( rc == ERROR_SUCCESS )
   {
      safecopy(info->dc_name,(PCWSTR)computer);
   }

   if ( ! rc )
   {
      // Get the SID for the domain
      WCHAR                  strDomain[LEN_Domain];
      DWORD                  lenStrDomain = DIM(strDomain);
      SID_NAME_USE           snu;
      BYTE                   sid[200];
      DWORD                  lenSid = DIM(sid);

      if ( LookupAccountName(info->dc_name,info->domain_name,sid,&lenSid,strDomain,&lenStrDomain,&snu) )
      {
         info->domain_sid = DomainizeSidFst(sid, FALSE /*don't free sid*/);
         info->nsubs = *GetSidSubAuthorityCount(info->domain_sid);
         info->valid = TRUE;
         found = TRUE;
      }
      else 
      {
         rc = GetLastError();
      }
   }
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_DOMAIN_GET_INFO_FAILED_S,domain);
   }
} 

int 
   TSDRidCache::SetDomainInfoWithSid(
      WCHAR          const * strDomain,    // in -domain name
      WCHAR          const * strSid,       // in -textual representation of sid
      bool                   firstdom      // in -flag:  (true => source domain),  (false => target domain)
   )
{
   SDRDomainInfo             info;
   PSID                      pSid = SidFromString(strSid);

   SetDomainInfoStructFromSid(pSid,&info);
   if ( info.valid )
   {
      if ( firstdom )
      {
         safecopy(from_domain,strDomain);
         from_sid = info.domain_sid;
         from_dc[0] = 0;
         from_nsubs = info.nsubs;
      
      }
      else
      {
         safecopy(to_domain,strDomain);
         to_sid = info.domain_sid;
         to_dc[0] =0;
         to_nsubs = info.nsubs;
      }


   }
   FreeSid(pSid);
   return info.valid;
}
/*****************************************************************************************************/
/* SetDomainInfo: 
         sets either ( from_domain, from_sid, from_dc, from_nsubs) if ( firstdom )
              or     ( to_domain, to_sid, to_dc, to_nsubs)         if ( ! firstdom)
/*****************************************************************************************************/
int                                         // ret -true if members were set, false otherwise 
   TSDRidCache::SetDomainInfo(
      WCHAR const *          domname,       // in -name of domain
      bool                   firstdom       // in -flag:  (true => source domain),  (false => target domain)
   )
{
   
   SDRDomainInfo           info;
   
   SetDomainInfoStruct(domname,&info);
   if ( info.valid )                                  // we have good information to store
   {
      if ( firstdom )
      {
         safecopy(from_domain,info.domain_name);
         from_sid = info.domain_sid;
         safecopy(from_dc,info.dc_name);
         from_nsubs = info.nsubs;
      }
      else
      {
         safecopy(to_domain,info.domain_name);
         to_sid = info.domain_sid;
         safecopy(to_dc,info.dc_name);
         to_nsubs = info.nsubs;
      }
   }
   return info.valid;                           
}

LPWSTR
   TGeneralCache::GetName(
      const PSID             psid      // in - SID to lookup account name for
   ) 
{     
   TGeneralSidNode         * tn = (TGeneralSidNode*)Lookup(psid);

   if ( tn ) 
      return tn->GetAcctName();
   else 
      return NULL;
}

TAcctNode * 
   TGeneralCache::Lookup( 
      const PSID             psid      // in - SID to lookup account name for
   )
{
   TGeneralSidNode         * tn = (TGeneralSidNode*)Find(&vSidComp,psid);

   return (TAcctNode *)tn;   
}
/***************************************************************************************************/
/* Lookup: takes a sid, checks whether it came from domain A.  If so, it finds the corresponding entry
           in the cache, and returns that node.
   
   Returns:  Pointer to TSidNode whose domain A rid matches asid's rid,
             or NULL if not a domain A sid, or not found in the cache
/***************************************************************************************************/ 
TAcctNode *
   TSDRidCache::Lookup(
      const PSID             psid // in -sid to search for 
   )  
                                                   
{
   TRidNode                * tn = NULL;
   DWORD                     rid = 0;
   BOOL                      bFromSourceDomain;
   UCHAR                   * pNsubs;
   DWORD                     nsubs;
   TAcctNode               * anode = NULL;
   assert( IsValidSid(psid) );
   assert ( IsValidSid(from_sid) );
   
   pNsubs = GetSidSubAuthorityCount(psid);
   if ( pNsubs )
   {
      nsubs = (*pNsubs);
   }
   else
   {
      assert(false);
      return NULL;
   }

   rid = (* GetSidSubAuthority(psid,nsubs - 1) );
      
//   if ((!from_sid) || (EqualPrefixSid(psid,from_sid)))   // first check whether asid matches the from-domain
   if ( EqualPrefixSid(psid,from_sid) )   // first check whether asid matches the from-domain
   {
      bFromSourceDomain = TRUE;
      tn = (TRidNode *)Find(&vRidComp,&rid);
      anode = tn;
   }
   else
   {
      bFromSourceDomain = FALSE;
   }
   if (! tn )
   {
      tn = (TRidNode *)-1;
      if ( AddIfNotFound() && ! BuiltinRid(rid) )  // Don't lookup builtin accounts
      {
         if ( ! m_otherAccounts )
         {
            m_otherAccounts = new TGeneralCache();
			if (!m_otherAccounts)
			{
               assert(false);
               return NULL;
			}
         }
         TGeneralSidNode * sn = (TGeneralSidNode *)m_otherAccounts->Lookup(psid);
         if ( ! sn )
         {
            sn = new TGeneralSidNode(psid,NULL);
			if (!sn)
			{
               assert(false);
               return NULL;
			}
            m_otherAccounts->TreeInsert(sn);
         }
         anode = (TAcctNode*)sn;
      }
   }
   
   return anode;
}
/***************************************************************************************************/
/* GetName:  Calls SidCache::Lookup, and returns the acct name from the resulting node
/***************************************************************************************************/
LPWSTR                        // ret -acct_name, or NULL if not found
   TSDRidCache::GetName(
      const PSID             psid               // in -sid to look for
   ) 
{
   TAcctNode               * tn = Lookup(psid);
   LPWSTR                    retval;

   if ( tn )
      retval = tn->GetAcctName();
   else 
      retval = NULL;
   return retval;
}

/***************************************************************************************************/
/* LookupWODomain: takes a sid, checks whether it came from domain A.  If so, it finds the corresponding entry
           in the cache, and returns that node.  This lookup function is used if the
		   src domain sid has not been recorded (like in the case of using a sID mapping file).
   
   Returns:  Pointer to TSidNode whose domain A rid matches asid's rid,
             or NULL if not a domain A sid, or not found in the cache
/***************************************************************************************************/ 

TAcctNode* TSDRidCache::LookupWODomain(const PSID psid)
{
	TAcctNode* pAcctNode = NULL;

	// if map is empty then construct rid to node map

	if (m_mapRidToNode.empty())
	{
		TNodeTreeEnum nte(this);

		for (TRidNode* pNode = (TRidNode*)nte.First(); pNode; pNode = (TRidNode*)nte.Next())
		{
			m_mapRidToNode.insert(CRidToNodeMap::value_type(pNode->SrcRid(), pNode));
		}
	}

	// retrieve RID from given SID

	assert(IsValidSid(psid));

	PUCHAR pCount = GetSidSubAuthorityCount(psid);

	if (pCount)
	{
		DWORD rid = (*GetSidSubAuthority(psid, *pCount - 1));

		// retrieve range of nodes with matching RID

		CRidToNodeMap::_Pairii pairii = m_mapRidToNode.equal_range(rid);

		// for each node in range...

		for (CRidToNodeMap::iterator it = pairii.first; it != pairii.second; it++)
		{
			// retrieve RID node and compare domain SIDs

			TRidNode* pNode = it->second;

			if (pNode)
			{
				PSID psidSrc = SidFromString(pNode->GetSrcDomSid());

				if (psidSrc)
				{
					// if domain SIDs are equal...

					if (EqualPrefixSid(psid, psidSrc))
					{
						// a match has been found
						pAcctNode = pNode;
					}

					FreeSid(psidSrc);

					if (pAcctNode)
					{
						break;
					}
				}
			}
		}
	}

	return pAcctNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\stargs.hpp ===
/*---------------------------------------------------------------------------
  File: STArgs.hpp

  Comments: Arguments that define the settings for FST or EST translation.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 10/14/98 15:35:59

 ---------------------------------------------------------------------------
*/

#ifndef __STARGS_HPP__
#define __STARGS_HPP__

#define REPLACE_SECURITY         (1)
#define ADD_SECURITY             (2)
#define REMOVE_SECURITY          (3)


#define SUMMARYSTATS             (0x00000001)
#define ACCOUNTSTATS             (0x00000002)
#define FILESTATS                (0x00000004)
#define PATHSTATS                (0x00000008)
#define MORESTATS                (0x00000010)
#define MASSIVEINFO              (0x00000020)

#define TRANSLATE_FILES          (0x00000001)
#define TRANSLATE_SHARES         (0x00000002)
#define TRANSLATE_MAILBOXES      (0x00000004)
#define TRANSLATE_CONTAINERS     (0x00000008)  
#define TRANSLATE_LGROUPS        (0x00000010) 
#define TRANSLATE_USERRIGHTS     (0x00000020)
#define TRANSLATE_USERPROFILES   (0x00000040)
#define TRANSLATE_PRINTERS       (0x00000080)
#define TRANSLATE_RECYCLER       (0x00000100)
#define TRANSLATE_REGISTRY       (0x00000200)

#include "sidcache.hpp"
#include "EnumVols.hpp"
#include "Common.hpp"
#include "UString.hpp"

class SecurityTranslatorArgs
{
   WCHAR                     m_source[LEN_Computer];
   WCHAR                     m_target[LEN_Computer];
   WCHAR                     m_logfile[LEN_Path];
   DWORD                     m_verbnum;

   BOOL                      m_nochange;
   DWORD                     m_translationMode;
   DWORD                     m_whichObjects;

   TPathList                 m_pathlist;
   
   TSDRidCache               m_cache;
   
   bool                      m_needtoverify;
   bool                      m_invalid;
   bool                      m_IsLocalSystem;
   bool                      m_bUseMapFile;
   BOOL                      m_bAllowToSwitchFromReplaceToAddModeInProfileTranslation;

public:
   bool                      m_bUndo;

   SecurityTranslatorArgs() { Reset(); }

   WCHAR const *  Source() const { return m_source; }
   WCHAR const *  Target() const { return m_target; }
   WCHAR const *  LogFile() const { return m_logfile; }
   TSDRidCache *  Cache() { return &m_cache; }
   TPathList   *  PathList() { return &m_pathlist; }
   BOOL           NoChange() const { return m_nochange;}
   BOOL           Verified() const { return !m_needtoverify; }
   BOOL           IsLocalSystem() const { return m_IsLocalSystem; }
   BOOL           LogFileDetails() { return m_verbnum & FILESTATS; }
   BOOL           LogVerbose() { return m_verbnum & MORESTATS; }
   BOOL           LogMassive() { return m_verbnum & MASSIVEINFO; }
   BOOL           LogSummary() { return m_verbnum & SUMMARYSTATS; }
   BOOL           LogAccountDetails() { return m_verbnum & ACCOUNTSTATS; }
   BOOL           LogPathDetails() { return m_verbnum & PATHSTATS; }
   DWORD          LogSettings() { return m_verbnum; }
   
   DWORD          TranslationMode() { return m_translationMode; }

   BOOL           TranslateFiles() { return m_whichObjects & TRANSLATE_FILES; }
   BOOL           TranslateShares() { return m_whichObjects & TRANSLATE_SHARES; }
   BOOL           TranslateMailboxes() { return m_whichObjects & TRANSLATE_MAILBOXES; }
   BOOL           TranslateContainers() { return m_whichObjects & TRANSLATE_CONTAINERS; }
   BOOL           TranslateLocalGroups() { return m_whichObjects & TRANSLATE_LGROUPS; }
   BOOL           TranslateUserRights() { return m_whichObjects & TRANSLATE_USERRIGHTS; }
   BOOL           TranslateUserProfiles() { return m_whichObjects & TRANSLATE_USERPROFILES; }
   BOOL           TranslatePrinters() { return m_whichObjects & TRANSLATE_PRINTERS; }
   BOOL           TranslateRecycler() { return m_whichObjects & TRANSLATE_RECYCLER; }
   BOOL           TranslateRegistry() { return m_whichObjects & TRANSLATE_REGISTRY; }
   BOOL           UsingMapFile() const { return m_bUseMapFile; }
   BOOL           AllowingToSwitchFromReplaceToAddModeInProfileTranslation() const { return m_bAllowToSwitchFromReplaceToAddModeInProfileTranslation; }

   void Source(WCHAR const * source) { safecopy(m_source,source); }
   void Target(WCHAR const * target) { safecopy(m_target,target); }
   void LogFile(WCHAR const * logfile) { safecopy(m_logfile,logfile); }
   void Verified(BOOL done) { m_needtoverify = !done; }
   void SetLogging(DWORD vn) { m_verbnum = vn; }
   void SetTranslationMode(DWORD mode) { m_translationMode = mode; }
   void SetWriteChanges(BOOL write) { m_nochange = !write; }
   void SetInvalid() { m_invalid = true; }
   void TranslateFiles(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_FILES : m_whichObjects &= ~TRANSLATE_FILES; }
   void TranslateShares(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_SHARES : m_whichObjects &= ~TRANSLATE_SHARES; }
   void TranslateMailboxes(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_MAILBOXES : m_whichObjects &= ~TRANSLATE_MAILBOXES; }
   void TranslateContainers(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_CONTAINERS : m_whichObjects &= ~TRANSLATE_CONTAINERS; }
   void TranslateLocalGroups(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_LGROUPS : m_whichObjects &= ~TRANSLATE_LGROUPS; }
   void TranslateUserRights(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_USERRIGHTS : m_whichObjects &= ~TRANSLATE_USERRIGHTS; }
   void TranslateUserProfiles(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_USERPROFILES : m_whichObjects &= ~TRANSLATE_USERPROFILES; }
   void TranslatePrinters(BOOL bTranslate) { bTranslate ? m_whichObjects |= TRANSLATE_PRINTERS : m_whichObjects &= ~TRANSLATE_PRINTERS; }
   void TranslateRecycler(BOOL bTranslate)  { bTranslate ? m_whichObjects |= TRANSLATE_RECYCLER : m_whichObjects &= ~TRANSLATE_RECYCLER; }
   void TranslateRegistry(BOOL bTranslate)  { bTranslate ? m_whichObjects |= TRANSLATE_REGISTRY : m_whichObjects &= ~TRANSLATE_REGISTRY; }
   void SetLocalMode(BOOL bLocal) { m_IsLocalSystem = ( bLocal == TRUE); }

   void Reset() { m_invalid = FALSE; m_needtoverify = TRUE; m_source[0]=0; m_target[0]=0;
                  m_IsLocalSystem = FALSE; m_logfile[0]=0; m_verbnum = SUMMARYSTATS | ACCOUNTSTATS | FILESTATS; 
                  m_nochange = FALSE; m_translationMode = REPLACE_SECURITY; 
                  m_whichObjects = TRANSLATE_FILES; m_pathlist.Clear(); m_cache.Clear();
                  m_cache.TypeSetTree(); m_bUndo = false; m_bUseMapFile = false;
                  m_bAllowToSwitchFromReplaceToAddModeInProfileTranslation = TRUE;
   }

   BOOL        IsValid() { return (*m_source && *m_target && m_pathlist.Count() && !m_invalid) ; }
   void SetUsingMapFile(BOOL bUsing) { m_bUseMapFile = ( bUsing == TRUE); }
   void SetAllowingToSwitchFromReplaceToAddModeInProfileTranslation(BOOL bAllowing) { m_bAllowToSwitchFromReplaceToAddModeInProfileTranslation = bAllowing; }
};


#endif //__STARGS_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\statobj.h ===
/*---------------------------------------------------------------------------
  File: StatusObj.h

  Comments: COM object used internally by the engine to track whether a job
  is running, or finished, and to provide a mechanism for aborting a job.

  The agent will set the status to running, or finished, as appropriate.
  If the client cancels the job, the engine's CancelJob function will change the 
  status to 'Aborting'. 

  Each helper object that performs a lengthy operation, such as account replication, or 
  security translation is responsible for periodically checking the status object to see
  if it needs to abort the task in progress.  The engine itself will check between migration
  tasks to see if the job has been aborted.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/18/99 

 ---------------------------------------------------------------------------
*/ 
	
// StatusObj.h : Declaration of the CStatusObj

#ifndef __STATUSOBJ_H_
#define __STATUSOBJ_H_

#include "resource.h"       // main symbols
#include "DCTStat.h"
/////////////////////////////////////////////////////////////////////////////
// CStatusObj
class ATL_NO_VTABLE CStatusObj : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CStatusObj, &CLSID_StatusObj>,
	public IDispatchImpl<IStatusObj, &IID_IStatusObj, &LIBID_MCSDCTWORKEROBJECTSLib>
{
public:
	CStatusObj()
	{
		m_pUnkMarshaler = NULL;
      m_Status = 0;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STATUSOBJ)
DECLARE_NOT_AGGREGATABLE(CStatusObj)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStatusObj)
	COM_INTERFACE_ENTRY(IStatusObj)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// IStatusObj
public:
	STDMETHOD(get_Status)(/*[out, retval]*/ LONG *pVal);
	STDMETHOD(put_Status)(/*[in]*/ LONG newVal);

protected:
   LONG                      m_Status;
   CComAutoCriticalSection   m_cs;
   
};

#endif //__STATUSOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\statobj.cpp ===
/*---------------------------------------------------------------------------
  File: StatusObj.h

  Comments: COM object used internally by the engine to track whether a job
  is running, or finished, and to provide a mechanism for aborting a job.

  This COM object simply has a single property which reflects the state of a
  migration job (Not started, Running, Aborted, Finished, etc.)

  The agent will set the status to running, or finished, as appropriate.
  If the client cancels the job, the engine's CancelJob function will change the 
  status to 'Aborting'. 

  Each helper object that performs a lengthy operation, such as account replication, or 
  security translation is responsible for periodically checking the status object to see
  if it needs to abort the task in progress.  The engine itself will check between migration
  tasks to see if the job has been aborted.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 05/18/99 

 ---------------------------------------------------------------------------
*/  
// StatusObj.cpp : Implementation of CStatusObj
#include "stdafx.h"
#include "WorkObj.h"
#include "StatObj.h"

/////////////////////////////////////////////////////////////////////////////
// CStatusObj


STDMETHODIMP CStatusObj::get_Status(LONG *pVal)
{
	m_cs.Lock();
   (*pVal) = m_Status;
   m_cs.Unlock();

   return S_OK;
}

STDMETHODIMP CStatusObj::put_Status(LONG newVal)
{
	m_cs.Lock();
   m_Status = newVal;
   m_cs.Unlock();
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\sidcache.hpp ===
//#pragma title ("SidCache.hpp -- Cache, Tree of SIDs")
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  sidcache.hpp
System      -  SDResolve
Author      -  Christy Boles
Created     -  97/06/27
Description -  Cache of SIDs.  Implemented using TNode derived classes, Cache is 
               organized as a tree, sorted by Domain B RID.  Each node contains 
               Domain A RID, Domain B RID, Account Name, and counters for stats.  
Updates     -
===============================================================================
*/
#ifndef TSIDCACHE_HEADER 
#define TSIDCACHE_HEADER

#ifndef TNODEINCLUDED
#include "Tnode.hpp"
#define TNODEINCLUDED 
#endif

//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "VarSet.tlb" no_namespace rename("property", "aproperty")//#imported below via sdstat.hpp

#include "DCTStat.h"
#include "WorkObj.h"
#include "sdstat.hpp"

#include <map>
#include <string>

#ifndef IStatusObjPtr
_COM_SMARTPTR_TYPEDEF(IStatusObj, __uuidof(IStatusObj));
#endif

//#define ACCOUNT_NAME_LENGTH 256
#define NUM_IN_BUF 5000  /* the number of accounts to get at one time NetQueryDisplayInfo()*/
#define BUFSIZE  100000  /* preferred max size of buffer for receiving accounts NetQueryDisplayInfo()*/ 
#define DEFAULT_SID_SIZE 500


#define EALB_OCX_LOCAL_USER      13
#define EALB_OCX_GLOBAL_USER     14
#define EALB_OCX_LOCAL_GROUP     16
#define EALB_OCX_GLOBAL_GROUP    17
 


#define FST_CACHE_SOME_SOURCE 1
#define FST_CACHE_NO_TARGET   2
#define FST_CACHE_SOME_TARGET 4
#define FST_CACHE_NO_DOMAIN   8
   
class TAcctNode:public TNode
{

protected:
   DWORD                     owner_changes;	    // Stats for each node
   DWORD                     group_changes;       
   DWORD                     ace_changes;
   DWORD                     sace_changes;                     
 
public:
                     TAcctNode();
   virtual WCHAR *   GetAcctName()  = 0;
   virtual  bool     IsValidOnTgt() const = 0;
   
   virtual void      AddOwnerChange(objectType type) { owner_changes++; }             // Stats functions 
   virtual void      AddGroupChange(objectType type) { group_changes++; }
   virtual void      AddAceChange(objectType type)   { ace_changes++;   }
   virtual void      AddSaceChange(objectType type)  { sace_changes++;  }
   virtual void      DisplayStats() const;    
   DWORD             OwnerChanges() { return owner_changes; }
   DWORD             GroupChanges() { return group_changes; }
   DWORD             DACEChanges() { return ace_changes; }
   DWORD             SACEChanges() { return sace_changes; }
   BOOL              ReportToVarSet(IVarSet * pVarSet, DWORD n);
};                              
class TRidNode:public TAcctNode
{
public:
   typedef enum _STATUS { DEFAULT = 0, TARGETSIDISINVALID = 1 } STATUS;
    
protected:
   DWORD                     srcRid;               // RID for domain A
   DWORD                     tgtRid;               // RID for domain B
   DWORD status;
   short                     acct_type;
   int                       acct_len;              // length of account name
   std::wstring              srcDomSid;             // source domain sid
   std::wstring              tgtDomSid;             // target domain sid
   std::wstring              srcDomName;            // source domain name
   std::wstring              tgtDomName;            // target domain name
   WCHAR                     acct_name[1];          // source account name \0 target account name
  
public:
   void *                operator new(size_t sz,const LPWSTR name1,const LPWSTR name2);
                     TRidNode(const LPWSTR oldacctname, const LPWSTR newacctname);     
                     ~TRidNode();                                               
   WCHAR *           GetAcctName() { return acct_name; }   // member "Get" functions
   WCHAR *           GetTargetAcctName() { return acct_name + acct_len + 1; }
   DWORD             SrcRid() const { return srcRid; }
   DWORD             TgtRid() const { return tgtRid; }
   DWORD GetStatus() { return status; }
   void SetStatus(DWORD newStatus) { status = newStatus; }
   bool              IsValidOnTgt() const { return tgtRid != 0 && !(status & TARGETSIDISINVALID); }
   short             Type() { return acct_type; }
   void              Type(short newtype) { acct_type = newtype; }
   void              SrcRid(DWORD const val) { srcRid=val; }             // member "Set" functions
   void              TgtRid(DWORD const val) { tgtRid=val; } 
   void              DisplayStats() const;    
   void              DisplaySidInfo() const;
   PCWSTR            GetSrcDomSid() { return srcDomSid.c_str(); }     // member "Get" function
   PCWSTR            GetTgtDomSid() { return tgtDomSid.c_str(); }     // member "Get" function
   void              SrcDomSid(PCWSTR sSid) { if (sSid) srcDomSid = sSid; else srcDomSid.erase(); } // member "Set" function
   void              TgtDomSid(PCWSTR sSid) { if (sSid) tgtDomSid = sSid; else tgtDomSid.erase(); } // member "Set" function
   PCWSTR            GetSrcDomName() { return srcDomName.c_str(); }   // member "Get" function
   PCWSTR            GetTgtDomName() { return tgtDomName.c_str(); }   // member "Get" function
   void              SrcDomName(PCWSTR sName) { if (sName) srcDomName = sName; else srcDomName.erase(); } // member "Set" function
   void              TgtDomName(PCWSTR sName) { if (sName) tgtDomName = sName; else tgtDomName.erase(); } // member "Set" function
   
protected:
   
};

class TGeneralSidNode:public TAcctNode
{
protected:
   LPWSTR                  src_acct_name;
   LPWSTR                  tgt_acct_name;
   PSID                    src_sid;
   PSID                    tgt_sid;
   UCHAR                   src_nsubs;
   UCHAR                   tgt_nsubs;
   WCHAR                 * src_domain;
   WCHAR                 * tgt_domain;
   DWORD                   sizediff;
   TSDFileDirCell          ownerStats;
   TSDFileDirCell          groupStats;
   TSDFileDirCell          daclStats;
   TSDFileDirCell          saclStats;

public:   
                     TGeneralSidNode(const LPWSTR name1, const LPWSTR name2);
                     TGeneralSidNode(const PSID pSid1, const PSID pSid2);
                     ~TGeneralSidNode();
   LPWSTR            GetAcctName() { return src_acct_name; }
   PSID              SrcSid() { return src_sid; }
   PSID              TgtSid() { return src_sid; /* this is a hack to allow for counting all references to accounts */ }
                                                   
   bool              IsValidOnTgt() const { return TRUE;/*tgt_sid != NULL;*/ }
   void              DisplaySidInfo() const;    
   DWORD             SizeDiff() const { return 0; } 
   TSDFileDirCell  * GetOwnerStats() { return &ownerStats; }
   TSDFileDirCell  * GetGroupStats() { return &groupStats; }
   TSDFileDirCell  * GetDaclStats() { return &daclStats; }
   TSDFileDirCell  * GetSaclStats() { return &saclStats; }
   virtual void      AddOwnerChange(objectType type) 
   { 
      switch (type) 
      {
         case file:        ownerStats.file++;      break;
         case directory:   ownerStats.dir++;       break;
         case mailbox:     ownerStats.mailbox++;   break;
         case container:   ownerStats.container++; break;
         case share:       ownerStats.share++;     break;
         case groupmember: ownerStats.member++;    break;
         case userright:   ownerStats.userright++; break;
         case regkey:      ownerStats.regkey++;    break;
         case printer:     ownerStats.printer++;   break;
          default:
            break;
      };
   }
   
   virtual void      AddGroupChange(objectType type)
   {
      switch (type) 
      {
         case file:        groupStats.file++;      break;
         case directory:   groupStats.dir++;       break;
         case mailbox:     groupStats.mailbox++;   break;
         case container:   groupStats.container++; break;
         case share:       groupStats.share++;     break;
         case groupmember: groupStats.member++;    break;
         case userright:   groupStats.userright++; break;
         case regkey:      groupStats.regkey++;    break;
         case printer:     groupStats.printer++;   break;
          default:
            break;
      };
   }

   virtual void      AddAceChange(objectType type)  
   {
      switch (type) 
      {
         case file:        daclStats.file++;      break;
         case directory:   daclStats.dir++;       break;
         case mailbox:     daclStats.mailbox++;   break;
         case container:   daclStats.container++; break;
         case share:       daclStats.share++;     break;
         case groupmember: daclStats.member++;    break;
         case userright:   daclStats.userright++; break;
         case regkey:      daclStats.regkey++;    break;
         case printer:     daclStats.printer++;   break;
          default:
            break;
      };
   }
   virtual void      AddSaceChange(objectType type) 
   {
      switch (type) 
      {
         case file:        saclStats.file++;      break;
         case directory:   saclStats.dir++;       break;
         case mailbox:     saclStats.mailbox++;   break;
         case container:   saclStats.container++; break;
         case share:       saclStats.share++;     break;
         case groupmember: saclStats.member++;    break;
         case userright:   saclStats.userright++; break;
         case regkey:      saclStats.regkey++;    break;
         case printer:     saclStats.printer++;   break;
          default:
            break;
      };
   }
   
};

   
/**************************************************************************************************/
/*       TSidCache:  Cache for SIDs.  
         
         The cache is filled by calling FillCache(name_of_domain_A, name_of_domain_B)
         
         Lookup, and GetName search the tree for a domain B SID value.  
         Lookup returns a pointer to the node, while GetName returns the account
                name for the node.
         
         GetSidB( tsidnode *) builds and returns the domain B SID for the node (the node contains only the RID)

         SizeDiff() returns the answer to "How much bigger are domain B sids than domain A sids?"
                    this information is needed when allocating space for ACES.
                    
/**************************************************************************************************/

class TAccountCache: public TNodeListSortable
{
   IStatusObjPtr            m_pStatus;
public:
 
   TAccountCache() { m_cancelled = false; m_bAddIfNotFound = FALSE; }
   ~TAccountCache() {}
virtual TAcctNode       * Lookup(const PSID psid) = 0;                        // sid lookup functions
virtual LPWSTR            GetName(const PSID psid) = 0;
//virtual BOOL              Insert(const LPWSTR acctname,DWORD srcSid, DWORD tgtSid) = 0;
virtual PSID              GetTgtSid(const TAcctNode* tnode) = 0;
virtual DWORD             SizeDiff(const TAcctNode *tnode) const = 0;            // returns max( 0 , (length(to_sid) - length(from_sid)) )     
   bool                   IsCancelled() 
   { 
      if ( m_pStatus ) 
      {
         LONG    status = 0;
//         HRESULT hr = m_pStatus->get_Status(&status);
         m_pStatus->get_Status(&status);

         return (status == DCT_STATUS_ABORTING);
      }
      else 
      {
         return m_cancelled; 
      }
   }
   void                   Cancel() { m_cancelled = true; if ( m_pStatus ) m_pStatus->put_Status(DCT_STATUS_ABORTING); }
   void                   UnCancel() { m_cancelled = false; }
   void                   AddIfNotFound(BOOL val) { m_bAddIfNotFound = val; }
   BOOL                   AddIfNotFound() { return m_bAddIfNotFound; }
   void                   SetStatusObject(IStatusObj * pS) { m_pStatus = pS; }
protected:
   bool                   m_cancelled;
   BOOL                   m_bAddIfNotFound;   
};

class TGeneralCache;

class TSDRidCache: public TAccountCache
{
protected:
   WCHAR                     from_domain[MAX_PATH + 1];             // domain names
   WCHAR                     to_domain[MAX_PATH + 1];
   WCHAR                     from_dc[MAX_PATH + 1];                 // domain controller (machine) names
   WCHAR                     to_dc[MAX_PATH + 1];
   PSID                      from_sid;                                 // domain sids (dynamically allocated)
   PSID                      to_sid;                        
   UCHAR                     from_nsubs;                               // # subauthorities in domain sids
   UCHAR                     to_nsubs;
   DWORD                     accts;                                    // statistical stuff
   DWORD                     accts_resolved;
   TGeneralCache           * m_otherAccounts;
   typedef std::multimap<DWORD, TRidNode*> CRidToNodeMap;
   CRidToNodeMap m_mapRidToNode;
public: 
                     TSDRidCache();
                     ~TSDRidCache();
                        // filling methods
   WCHAR     const * GetSourceDomainName() { return from_domain; }
   WCHAR     const * GetTargetDomainName() { return to_domain; }
   WCHAR     const * GetSourceDCName() { return from_dc; }
   WCHAR     const * GetTargetDCName() { return to_dc; }
   void              InsertLast(const LPWSTR acctname,DWORD rida, const LPWSTR newname, DWORD ridb, short type = 0, DWORD status = TRidNode::DEFAULT)
						{ TRidNode * tn = new (acctname,newname) TRidNode(acctname,newname); if (tn){ tn->SetStatus(status); tn->SrcRid(rida); tn->TgtRid(ridb);
						tn->Type(type); if ( ridb != 0 ) accts_resolved++; accts++; TNodeListSortable::InsertBottom((TNode *)tn); }}
   void              InsertLastWithSid(const LPWSTR acctname, LPCWSTR srcdomainsid, LPCWSTR srcdomainname, DWORD rida, const LPWSTR newname, 
	                                   LPCWSTR tgtdomainsid, LPCWSTR tgtdomainname, DWORD ridb, short type = 0, DWORD status = TRidNode::DEFAULT)
						{ TRidNode * tn = new (acctname,newname) TRidNode(acctname,newname); if (tn){ tn->SetStatus(status); tn->SrcRid(rida); tn->TgtRid(ridb);
					   tn->SrcDomSid(srcdomainsid); tn->TgtDomSid(tgtdomainsid); tn->SrcDomName(srcdomainname); tn->TgtDomName(tgtdomainname);
                       tn->Type(type); if ( ridb != 0 ) accts_resolved++; accts++; TNodeListSortable::InsertBottom((TNode *)tn); }}
                     
   TAcctNode       * Lookup(const PSID psid);                           // sid lookup functions
   TAcctNode       * LookupWODomain(const PSID psid);                           // sid lookup functions
   LPWSTR            GetName(const PSID psid);
   
   // helper methods
   PSID              GetTgtSid(TAcctNode const * tnode) ;                   // "Get" functions
   DWORD             SizeDiff(const TAcctNode *tnode) const ;                        // returns max( 0 , (length(to_sid) - length(from_sid)) )     
   void              Display(bool summary, bool detail);
   void              ReportToVarSet(IVarSet * pVarSet,bool summary, bool detail);
   PSID              GetTgtSid(const PSID psid) { return GetTgtSid(Lookup(psid)); }
   void              CopyDomainInfo( TSDRidCache const * other);
   PSID              GetTgtSidWODomain(TAcctNode const * tnode);                   // "Get" functions
   PSID              GetTgtSidWODomain(const PSID psid);                           // "Get" functions 
  
   DWORD             GetNumAccts() const {return accts; }
   DWORD             GetNumResolvedAccts() const { return accts_resolved; } 
   void              Clear();
   void              SetSourceAndTargetDomains(WCHAR const * src, WCHAR const * tgt) { SetDomainInfo(src,true); SetDomainInfo(tgt,false); }
   void              SetSourceAndTargetDomainsWithSids(WCHAR const * src, WCHAR const * srcSid, WCHAR const * tgt,WCHAR const * tgtSid)
                     { SetDomainInfoWithSid(src,srcSid,true); SetDomainInfoWithSid(tgt,tgtSid,false); }
   void              ReportAccountReferences(WCHAR const * filename);
   BOOL              IsInitialized() { return from_sid!=NULL && to_sid!=NULL; }
   void VerifyTargetSids();
   
protected: 
   int               SetDomainInfo(WCHAR const * domname, bool firstdom);   
   int               SetDomainInfoWithSid(WCHAR const * domainName, WCHAR const * domainSid, bool firstdom);
   
};

class TGeneralCache : public TAccountCache
{
protected:
   DWORD                     accts;                                    // statistical stuff
   DWORD                     accts_resolved;
public:
   TGeneralCache();
   ~TGeneralCache();
   TAcctNode       * Lookup(const PSID psid) ;                        // sid lookup functions
   LPWSTR            GetName(const PSID psid) ;
   BOOL              Insert(const LPWSTR acctname1,const LPWSTR acctname2,PSID sid1, PSID sid2);
   PSID              GetTgtSid(const TAcctNode* tnode)  { return ((TGeneralSidNode *)tnode)->TgtSid(); }
   DWORD             SizeDiff(const TAcctNode *tnode) const { return ((TGeneralSidNode *)tnode)->SizeDiff(); }            // returns max( 0 , (length(to_sid) - length(from_sid)) )     

};

// Global Functions
struct SDRDomainInfo
{
   bool                      valid;
   PSID                      domain_sid;
   WCHAR                     domain_name[80];
   WCHAR                     dc_name[80];
   UCHAR                     nsubs;
};
int vRidComp(const TNode * tn, const void * v1);
int vNameComp(const TNode * tn, const void * v1);
int vTargetNameComp(const TNode * tn, const void * v1);
int RidComp(const TNode * n1, const TNode * n2);
int CompN(const TNode * n1, const TNode * n2);
int CompTargetN(const TNode * n1, const TNode * n2);

void DisplaySid(const PSID);                        // displays the contents of a SID 
void DisplaySid(const PSID,TAccountCache *);  // displays the acct name if in cache, or 
void                                         
   SetDomainInfoStruct(
      WCHAR const         * domname,        // in -name of domain
      SDRDomainInfo       * info            // in -struct to put info into
   );

void                                         
   SetDomainInfoStructFromSid(
      PSID                  pSid,           // in -sid for domain
      SDRDomainInfo       * info            // in -struct to put info into
   );

PSID              DomainizeSid(PSID psid,BOOL freeOldSid);                                                   
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0351
#endif
#define _ATL_FREE_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__DF98CEEB_B5F4_11D2_A1DE_00A0C9AFE114__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\tarnode.hpp ===
/*---------------------------------------------------------------------------
  File: TAcctReplNode.hpp

  Comments: implementation/Definition of the TAcctReplNode class.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#ifndef __TACCTREPLNODE_HPP__
#define __TACCTREPLNODE_HPP__
//#pragma title("TAcctReplNode.hpp- class definitions for Account replication code")

#include <lmcons.h>
#include "Common.hpp"
#include "EaLen.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "CommaLog.hpp"
#include "WorkObj.h"
#include <COMDEF.h>
#include <map>

#define AR_Status_Created           (0x00000001)
#define AR_Status_Replaced          (0x00000002)
#define AR_Status_AlreadyExisted    (0x00000004)
#define AR_Status_RightsUpdated     (0x00000008)
#define AR_Status_DomainChanged     (0x00000010)
#define AR_Status_Rebooted          (0x00000020)
#define AR_Status_Special           (0x00000040)
#define AR_Status_Critical          (0x00000080)
#define AR_Status_GroupScopeChanged (0x00000100)
#define AR_Status_PasswordCopied    (0x00000200)
#define AR_Status_PasswordError     (0x00000400)
#define AR_Status_Warning           (0x40000000)
#define AR_Status_Error             (0x80000000)

// Opertation flags to be performed on the Account
#define OPS_Create_Account          (0x00000001)
#define OPS_Copy_Properties         (0x00000002)
#define OPS_Process_Members         (0x00000004)
#define OPS_Process_MemberOf        (0x00000008)
#define OPS_Call_Extensions         (0x00000010)
#define OPS_Move_Object             (0x00000020)

#define OPS_All                     OPS_Create_Account | OPS_Copy_Properties | OPS_Process_Members | OPS_Process_MemberOf | OPS_Call_Extensions
#define OPS_Copy                    OPS_Create_Account | OPS_Copy_Properties

typedef std::map<_bstr_t,_bstr_t> CGroupMemberMap;

class TAcctReplNode:public TNode
{
   _bstr_t                   name;
   _bstr_t                   newName;
   _bstr_t                   sourcePath;
   _bstr_t                   targetPath;
   _bstr_t                   type;  // Account Type
   DWORD                     status;
   DWORD                     ridSrc;
   DWORD                     ridTgt;
   _bstr_t                   sSourceSamName;
   _bstr_t                   sTargetSamName;
   _bstr_t                   sSrcProfilePath;
   _bstr_t                   sTgtProfilePath;
   _bstr_t                   sTargetGUID;
   _bstr_t                   sSourceUPN;
   PSID                      srcSid;
   HRESULT                   hr;
   long                      lGroupType;
public:
   DWORD                     operations;     // BitMask Specifies what operations to perform on a pirticular account
   bool                      IsFilled;       // Tells us if we need to process this account node any further to fill in required info
   bool                      IsProfPathFilled;
   bool                      bExpanded;
   bool                      bChangedType;
   // following map property is added to support UpdateMemberToGroups function to just be able to add
   // migrated objects to the groups that they belong to. This map contains all member name\type pair that are
   // members of this group account node
   CGroupMemberMap           mapGrpMember;
   long                      lFlags;
   long                      lExpDate;
   BOOL                      bUPNConflicted;
   SAFEARRAY*                psaUserRights;

public:
   TAcctReplNode() :
      status(0),
      ridSrc(0),
      ridTgt(0),
      srcSid(NULL),
      hr(-1),
      lGroupType(0),
      operations(OPS_All),
      IsFilled(false),
      IsProfPathFilled(false),
      bExpanded(false),
      bChangedType(false),
      lFlags(0),
      lExpDate(0),
      bUPNConflicted(FALSE),
      psaUserRights(NULL)
   {
         //make sure the member map is empty
      mapGrpMember.clear();
   }

   TAcctReplNode(const TAcctReplNode *pAcctNode) :
        name(pAcctNode->name),
        newName(pAcctNode->newName),
        sourcePath(pAcctNode->sourcePath),
        targetPath(pAcctNode->targetPath),
        type(pAcctNode->type),
        status(pAcctNode->status),
        ridSrc(pAcctNode->ridSrc),
        ridTgt(pAcctNode->ridTgt),
        sSourceSamName(pAcctNode->sSourceSamName),
        sTargetSamName(pAcctNode->sTargetSamName),
        sSrcProfilePath(pAcctNode->sSrcProfilePath),
        sTgtProfilePath(pAcctNode->sTgtProfilePath),
        sTargetGUID(pAcctNode->sTargetGUID),
        sSourceUPN(pAcctNode->sSourceUPN),
        srcSid(pAcctNode->srcSid),
        hr(pAcctNode->hr),
        lGroupType(pAcctNode->lGroupType),
        operations(pAcctNode->operations),
        IsFilled(pAcctNode->IsFilled),
        IsProfPathFilled(pAcctNode->IsProfPathFilled),
        bExpanded(pAcctNode->bExpanded),
        bChangedType(pAcctNode->bChangedType),
        lFlags(pAcctNode->lFlags),
        lExpDate(pAcctNode->lExpDate),
        bUPNConflicted(pAcctNode->bUPNConflicted),
        psaUserRights(NULL)
   {
           //copy the member map
        mapGrpMember = pAcctNode->mapGrpMember;

        if (pAcctNode->psaUserRights)
        {
            SafeArrayCopy(pAcctNode->psaUserRights, &psaUserRights);
        }
   }

   ~TAcctReplNode()
   {
       if (psaUserRights)
       {
           SafeArrayDestroy(psaUserRights);
       }
   }

   WCHAR const *        GetName() const { return !name ? L"" : name; }
   WCHAR const *        GetTargetName() const { return !newName ? !name ? L"" : name : newName; }
   WCHAR const *        GetTargetPath() const { return !targetPath ? L"" : targetPath; }
   WCHAR const *        GetSourcePath() const { return !sourcePath ? L"" : sourcePath; }
   WCHAR const *        GetType() const { return !type ? L"" : type; }
   WCHAR const *        GetSourceSam() const { return !sSourceSamName ? L"" : sSourceSamName; }
   WCHAR const *        GetTargetSam() const { return !sTargetSamName ? L"" : sTargetSamName; }
   WCHAR const *        GetTargetProfile() const { return !sTgtProfilePath ? L"" : sTgtProfilePath; }
   WCHAR const *        GetSourceProfile() const { return !sSrcProfilePath ? L"" : sSrcProfilePath; }
   WCHAR const *        GetTargetGUID() const { return !sTargetGUID ? L"" : sTargetGUID; }
   WCHAR const *        GetSourceUPN() const { return !sSourceUPN ? L"" : sSourceUPN; }
   PSID                 GetSourceSid() { return srcSid; }
   
   DWORD                GetStatus() const { return status; }
   DWORD                GetSourceRid() const { return ridSrc; }
   DWORD                GetTargetRid() const { return ridTgt; }
   long                 GetGroupType() { return lGroupType; }
   HRESULT              GetHr() const { return hr; }
   
   void                 SetName(const TCHAR * newname) { name = newname; }
   void                 SetTargetName(const WCHAR * name) { newName = name; }
   void                 SetTargetPath(const WCHAR * sPath) { targetPath = sPath; } 
   void                 SetSourcePath(const WCHAR * sPath) { sourcePath = sPath; }
   void                 SetSourceSam(const WCHAR * sName) { sSourceSamName = sName; }
   void                 SetTargetSam(const WCHAR * sName) { sTargetSamName = sName; }
   void                 SetSourceProfile(const WCHAR * sPath) { sSrcProfilePath = sPath; IsProfPathFilled = true; }
   void                 SetTargetProfile(const WCHAR * sPath) { sTgtProfilePath = sPath; }
   void                 SetTargetGUID(const WCHAR * sGUID) { sTargetGUID = sGUID; }
   void                 SetType(const WCHAR * newtype) { type = newtype; }
   void                 SetSourceUPN(const WCHAR * sName) { sSourceUPN = sName; }
   void                 SetSourceSid(PSID sSid) { srcSid = sSid; }
   
   void                 SetStatus(DWORD val) { status = val; }
   void                 SetGroupType(long type) { lGroupType = type; }
   void                 SetSourceRid(DWORD val) { ridSrc = val; }
   void                 SetTargetRid(DWORD val) { ridTgt = val; }
   void                 SetHr(const HRESULT hrRes) { hr = hrRes; }
   
   void                 MarkCreated() { status |= AR_Status_Created; }
   void                 MarkReplaced() { status |= AR_Status_Replaced; }
   void                 MarkAlreadyThere() { status |= AR_Status_AlreadyExisted; }
   void                 MarkError() { status |= AR_Status_Error; }
   void                 MarkWarning() { status |= AR_Status_Warning; }
   void                 MarkRightsUpdated() { status |= AR_Status_RightsUpdated; }
   void                 MarkDomainChanged() { status |= AR_Status_DomainChanged; }
   void                 MarkRebooted() { status |= AR_Status_Rebooted; }
   void                 MarkCritical() { status = AR_Status_Critical; }
   void                 MarkGroupScopeChanged() { status |= AR_Status_GroupScopeChanged; }
 
   BOOL                 WasCreated() { return status & AR_Status_Created; }
   BOOL                 WasReplaced() { return status & AR_Status_Replaced; }
   BOOL                 IsCritical() { return status & AR_Status_Critical; }
   BOOL                 WasGroupScopeChanged() { return status & AR_Status_GroupScopeChanged; }
   BOOL                 CreateAccount() { return operations & OPS_Create_Account; }
   BOOL                 CopyProps() { return operations & OPS_Copy_Properties; }
   BOOL                 ProcessMem() { return operations & OPS_Process_Members; }
   BOOL                 ProcessMemOf() { return operations & OPS_Process_MemberOf; }
   BOOL                 CallExt() { return operations & OPS_Call_Extensions; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\usercopy.cpp ===
//#pragma title("usercopy- copies user accounts")
/*
================================================================================

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

 Program    - usercopy
 Class      - LAN Manager Utilities
 Author     - Tom Bernhardt
 Created    - 05/08/91
 Description- Merges the NetUser information from the specified source
              server with the target system (or the current system if no
              target is specified).  Group information is also merged if
              the /g option is given.   Existing entries on the target system
              are not overwritten unless the /r option is used.

 Syntax     - USERCOPY source [target] [/u] [/l] [/g] [/r]
        where:
           source   source server
           target   destination server
           /g       copies global group information
           /l       copies local group information

           /u       copies user information
           /r       replaces existing target entries with source entries
           /AddTo:x Adds all newly created users (/u) to group "x"

 Updates    - 
 91/06/17 TPB General code cleanup and change so that all stdout i/o lines up 
              nicely on-screen for reporting.
 93/06/12 TPB Port to Win32
 96/06/21 TPB Support for local groups
 97/09/20 CAB Added subset of accounts option for GUI
 98/06    TPB/CAB Support for computer accounts
 99/01    COM-ization of DCT.
================================================================================
*/
#include "StdAfx.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <ntdsapi.h>
#include <lm.h>
#include <iads.h>
#include "TxtSid.h"

#define INCL_NETUSER
#define INCL_NETGROUP
#define INCL_NETERRORS
#include <lm.h>

#include "Common.hpp"                    
#include "UString.hpp"                   

#include "WorkObj.h"

//#include "Usercopy.hpp" //#included by ARUtil.hpp below

#include "ARUtil.hpp"
#include "BkupRstr.hpp"

#include "DCTStat.h"
#include "ErrDct.hpp"
#include "RegTrans.h"
#include "TEvent.hpp"
#include "LSAUtils.h"
#include "GetDcName.h"
#include <sddl.h>


//#import "\bin\NetEnum.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "NetEnum.tlb" no_namespace
//#import "DBMgr.tlb" no_namespace, named_guids //already #imported via ARUtil.hpp

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct             err;
extern TErrorDct           & errC;


bool                         abortall;
extern bool						  g_bAddSidWorks = false;

// global counts of accounts processed
AccountStats                 warnings =  { 0,0,0,0 };
AccountStats                 errors =    { 0,0,0,0 };
AccountStats                 created =   { 0,0,0,0 };
AccountStats                 replaced =  { 0,0,0,0 };
AccountStats                 processed = { 0,0,0,0 };

BOOL                         machineAcctsCreated = FALSE;
BOOL                         otherAcctsCreated = FALSE;
PSID                         srcSid = NULL;      // SID for source domain


typedef UINT (CALLBACK* DSBINDFUNC)(TCHAR*, TCHAR*, HANDLE*);
typedef UINT (CALLBACK* DSADDSIDHISTORY)(HANDLE, DWORD, LPCTSTR, LPCTSTR, LPCTSTR, RPC_AUTH_IDENTITY_HANDLE,LPCTSTR,LPCTSTR);

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif


int TNodeCompareSourceName(TNode const * t1,TNode const * t2)
{
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   TAcctReplNode     const * n2 = (TAcctReplNode *)t2;

   return UStrICmp(n1->GetName(),n2->GetName());
}

int TNodeCompareSourceNameValue(TNode const * t1, void const * v)
{
   TAcctReplNode     const * n1 = (TAcctReplNode *)t1;
   WCHAR             const * name = (WCHAR const *)v;

   return UStrICmp(n1->GetName(),name);
}


bool BindToDS(Options* pOpt)
{
    // Get the handle to the Directory service.
    DSBINDFUNC DsBind;
    HINSTANCE hInst = LoadLibrary(L"NTDSAPI.DLL");
    if ( hInst )
    {
        DsBind = (DSBINDFUNC) GetProcAddress(hInst, "DsBindW");
        if (DsBind)
        {
            //
            // If source domain controllers are running W2K or later then specify
            // DNS name of target domain controller otherwise must specify flat
            // (NetBIOS) name of target domain controller.
            //
            // Note that this is a requirement of the DsAddSidHistory implementation
            // when the source domain is NT4 and explicit source domain credentials
            // are not supplied. As ADMT does not supply explicit credentials this
            // will always be the case when the source domain is NT4.
            //

            PWSTR strDestDC = (pOpt->srcDomainVer > 4) ? pOpt->tgtCompDns : pOpt->tgtCompFlat;

            DWORD rc = DsBind(strDestDC, NULL, &pOpt->dsBindHandle);

            if ( rc != 0 ) 
            {
                err.SysMsgWrite( ErrE, rc, DCT_MSG_DSBIND_FAILED_S, strDestDC);
                Mark(L"errors", L"generic");
                FreeLibrary(hInst);
                return false;
            }
        }
        else
        {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_GET_PROC_ADDRESS_FAILED_SSD,L"NTDSAPI.DLL",L"DsBindW",GetLastError());
            Mark(L"errors", L"generic");
            FreeLibrary(hInst);
            return false;
        }
    }
    else
    {
        err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_LOAD_LIBRARY_FAILED_SD,L"NTDSAPI.DLL",GetLastError());
        Mark(L"warnings", L"generic");
        return false;
    }
    FreeLibrary(hInst);
    return true;
}

// The following function is used to get the actual account name from the source domain
// instead of account that contains the SID in its SID history.
DWORD GetName(PSID pObjectSID, WCHAR * sNameAccount, WCHAR * sDomain)
{
    DWORD		    cb = 255;
    DWORD           cbDomain = 255;
    DWORD           tempVal;
    PDWORD          psubAuth;
    PUCHAR          pVal;
    SID_NAME_USE	sid_Use;
    _bstr_t         sDC;
    DWORD           rc = 0;

    if ((pObjectSID == NULL) || !IsValidSid(pObjectSID))
    {
        return ERROR_INVALID_PARAMETER;
    }
    // Copy the Sid to a temp SID
    DWORD    sidLen = GetLengthSid(pObjectSID);
    PSID     pObjectSID1 = new BYTE[sidLen];
    if (!pObjectSID1)
        return ERROR_NOT_ENOUGH_MEMORY;

    if (!CopySid(sidLen, pObjectSID1, pObjectSID))
    {
        delete pObjectSID1;
        return GetLastError();
    }
    if (!IsValidSid(pObjectSID1))
    {
        rc = GetLastError();
        err.SysMsgWrite(ErrE, rc,DCT_MSG_DOMAIN_LOOKUP_FAILED_D,rc);
        try
        {
            Mark(L"errors", L"generic");
        }
        catch (...)
        {
        }
        delete pObjectSID1;
        return rc;
    }

    // Get the RID out of the SID and get the domain SID
    pVal = GetSidSubAuthorityCount(pObjectSID1);
    (*pVal)--;
    psubAuth = GetSidSubAuthority(pObjectSID1, *pVal);
    tempVal = *psubAuth;
    *psubAuth = -1;

    //Lookup the domain from the SID 
    if (!LookupAccountSid(NULL, pObjectSID1, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use))
    {
        rc = GetLastError();
        err.SysMsgWrite(ErrE, rc,DCT_MSG_DOMAIN_LOOKUP_FAILED_D,rc);
        Mark(L"errors", L"generic");
        delete pObjectSID1;
        return rc;
    }

    // Get a DC for the domain

    rc = GetAnyDcName4(sDomain, sDC);

    if ( rc )
    {
        err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_DCNAME_FAILED_SD,sDomain,rc);
        Mark(L"errors", L"generic");
        delete pObjectSID1;
        return rc;
    }

    // Reset the sizes
    cb = 255;
    cbDomain = 255;

    // Lookup the account on the PDC that we found above.
    if ( LookupAccountSid(sDC, pObjectSID, sNameAccount, &cb, sDomain, &cbDomain, &sid_Use) == 0)
    {
        delete pObjectSID1;
        return GetLastError();
    }

    delete pObjectSID1;

    return 0;
}

/* This is a list of specific error codes that can be returned by DsAddSidHistory.
This was obtained from Microsoft via email

  > ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED
>     The operation requires that destination domain auditing be enabled for
>     Success and Failure auditing of account management operations.
> 
> ERROR_DS_UNWILLING_TO_PERFORM
>     It may be that the user account is not one of UF_NORMAL_ACCOUNT,
>     UF_WORKSTATION_TRUST_ACCOUNT, or UF_SERVER_TRUST_ACCOUNT.
> 
>     It may be that the source principal is a built in account.
> 
>     It may be that the source principal is a well known RID being added
>     to a destination principal that is a different RID. In other words,
>     Administrators of the source domain can only be assigned to
>     Administrators of the destination domain.
> 
> ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER
>     The source object must be a group or user.
> 
> ERROR_DS_SRC_SID_EXISTS_IN_FOREST
>     The source object's SID already exists in destination forest.
> 
> ERROR_DS_INTERNAL_FAILURE;
>     The directory service encountered an internal failure. Shouldn't
> happen.
> 
> ERROR_DS_MUST_BE_RUN_ON_DST_DC
>     For security reasons, the operation must be run on the destination DC.
>     Specifically, the connection between the client and server
> (destination
>     DC) requires 128-bit encryption when credentials for the source domain
>     are supplied.
> 
> ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION
>     The connection between client and server requires packet privacy or
> better.
> 
> ERROR_DS_SOURCE_DOMAIN_IN_FOREST
>     The source domain may not be in the same forest as destination.
> 
> ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST
>     The destination domain must be in the forest.
> 
> ERROR_DS_MASTERDSA_REQUIRED
>     The operation must be performed at a master DSA (writable DC).
> 
> ERROR_DS_INSUFF_ACCESS_RIGHTS
>     Insufficient access rights to perform the operation. Most likely
>     the caller is not a member of domain admins for the dst domain.
> 
> ERROR_DS_DST_DOMAIN_NOT_NATIVE
>     Destination domain must be in native mode.
> 
> ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN
>     The operation couldn't locate a DC for the source domain.
> 
> ERROR_DS_OBJ_NOT_FOUND
>     Directory object not found. Most likely the FQDN of the 
>     destination principal could not be found in the destination
>     domain.
> 
> ERROR_DS_NAME_ERROR_NOT_UNIQUE
>     Name translation: Input name mapped to more than one
>     output name. Most likely the destination principal mapped
>     to more than one FQDN in the destination domain.
> 
> ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH
>     The source and destination object must be of the same type.
> 
> ERROR_DS_OBJ_CLASS_VIOLATION
>     The requested operation did not satisfy one or more constraints
>     associated with the class of the object. Most likely because the
>     destination principal is not a user or group.
> 
> ERROR_DS_UNAVAILABLE
>     The directory service is unavailable. Most likely the
>     ldap_initW() to the NT5 src DC failed.
> 
> ERROR_DS_INAPPROPRIATE_AUTH
>     Inappropriate authentication. Most likely the ldap_bind_sW() to
>     the NT5 src dc failed.
> 
> ERROR_DS_SOURCE_AUDITING_NOT_ENABLED
>     The operation requires that source domain auditing be enabled for
>     Success and Failure auditing of account management operations.
> 
> ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER
>     For security reasons, the source DC must be Service Pack 4 or greater.
> 
*/


HRESULT 
   CopySidHistoryProperty(
      Options              * pOptions,
      TAcctReplNode        * pNode,
      IStatusObj              * pStatus
   )
{
   HRESULT                   hr = S_OK;
   IADs                    * pAds = NULL;
   _variant_t                var;
//   long                      ub = 0, lb = 0;

   // fetch the SIDHistory property for the source account
   // for each entry in the source's SIDHistory, call DsAddSidHistory

   // Get the IADs pointer to the object and get the SIDHistory attribute.
   hr = ADsGetObject(const_cast<WCHAR*>(pNode->GetSourcePath()), IID_IADs, (void**)&pAds);
   if ( SUCCEEDED(hr) )
   {
      hr = pAds->Get(L"sIDHistory", &var);
   }

   if ( SUCCEEDED(hr) )
   {
      // This is a multivalued property so we need to get all the values
      // for each one get the name and the domain of the object and then call the 
      // add sid history function to add the SID to the target objects SIDHistory.
		_variant_t		        var;
		DWORD rc = pAds->GetEx(L"sIDHistory", &var);
		if ( !rc )
		{
			if ( V_VT(&var) == (VT_ARRAY | VT_VARIANT) )
         {
            // This is the array type that we were looking for.
            void HUGEP *pArray;
			   VARIANT var2;
			   ULONG dwSLBound = -1; 
			   ULONG dwSUBound = -1;
			   
			   hr = SafeArrayGetLBound( V_ARRAY(&var),
                                     1,
                                     (long FAR  *) &dwSLBound );
            hr = SafeArrayGetUBound( V_ARRAY(&var),
                                      1,
                                      (long FAR  *) &dwSUBound );
            if (SUCCEEDED(hr))
            {
               // Each element in this array is a SID in form of a VARIANT
               hr = SafeArrayAccessData( V_ARRAY(&var), &pArray );
				   for ( long x = (long)dwSLBound; x <= (long)dwSUBound; x++)
				   {
					   hr = SafeArrayGetElement(V_ARRAY(&var), &x, &var2);
                  // Get the SID from the Variant in a ARRAY form
					   hr = SafeArrayAccessData( V_ARRAY(&var2), &pArray );
					   PSID pObjectSID = (PSID)pArray;
					   //Convert SID to string.
					   if (pObjectSID) 
					   {
						   WCHAR		sNameAccount[255];
						   WCHAR		sDomain[255];
                     WCHAR    sNetBIOS[255];
                     DWORD    rc = 0;

                     rc = GetName(pObjectSID, sNameAccount, sDomain);
                     if (!rc)
                     {
                        WCHAR               sTemp[LEN_Path];
                        WCHAR               sSourceDNS[LEN_Path];
                        // We are going to temporarily change the Domain DNS to the domain of the SID we are adding
                        wcscpy(sTemp, pOptions->srcDomainDns);
                        if ( GetDnsAndNetbiosFromName(sDomain, sNetBIOS, sSourceDNS) )
                        {
                           wcscpy(pOptions->srcDomainDns, sSourceDNS);
                           AddSidHistory(pOptions, sNameAccount, pNode->GetTargetSam(), NULL, FALSE);
                           // Replace the original domain dns.
                           wcscpy(pOptions->srcDomainDns, sTemp);
                        }
                        else
                        {
                           err.SysMsgWrite(ErrE, GetLastError(),DCT_MSG_DOMAIN_DNS_LOOKUP_FAILED_SD, sDomain,GetLastError());
                           Mark(L"errors", pNode->GetType());
                        }
                     }
						   else
                     {
						      // Get name failed we need to log a message.
                        WCHAR                       sSid[LEN_Path];
                        DWORD                       len = LEN_Path;
                        GetTextualSid(pObjectSID, sSid, &len);
                        err.SysMsgWrite(ErrE,rc,DCT_MSG_ERROR_CONVERTING_SID_SSD,
                                        pNode->GetTargetName(), sSid, rc);
                        Mark(L"errors", pNode->GetType());
                     }
					   }
                  SafeArrayUnaccessData(V_ARRAY(&var2));
				   }
               SafeArrayUnaccessData(V_ARRAY(&var));
            }           
         }              
		}
		else
		{
         // No SID History to copy.
		}
   }
   return hr;
}


bool AddSidHistory( const Options * pOptions,
						  const WCHAR   * strSrcPrincipal,
						  const WCHAR   * strDestPrincipal,
                    IStatusObj    * pStatus,
                    BOOL            isFatal)
{
    //Add the sid to the history
    // Authentication Structure 
    SEC_WINNT_AUTH_IDENTITY		auth;
    DWORD                      rc = 0;
    WCHAR                      szPassword[LEN_Password];

    auth.Domain = const_cast<WCHAR*>(pOptions->authDomain);
    auth.DomainLength = wcslen(pOptions->authDomain);
    auth.User = const_cast<WCHAR*>(pOptions->authUser);
    auth.UserLength = wcslen(pOptions->authUser);

    //
    // If credentials were supplied then retrieve password.
    //

    if ((auth.DomainLength > 0) && (auth.UserLength > 0))
    {
        DWORD dwError = RetrievePassword(pOptions->authPassword, szPassword, sizeof(szPassword) / sizeof(szPassword[0]));

        if (dwError == ERROR_SUCCESS)
        {
            auth.Password = szPassword;
            auth.PasswordLength = wcslen(szPassword);
        }
        else
        {
            err.SysMsgWrite(ErrE, dwError, DCT_MSG_UNABLE_TO_RETRIEVE_PASSWORD);
            g_bAddSidWorks = FALSE;

            // log a message indicating that SIDHistory will not be tried for the rest of the accounts
            err.MsgWrite(ErrW,DCT_MSG_SIDHISTORY_FATAL_ERROR);
            Mark(L"warnings", L"generic");
            // we are going to set the status to abort so that we don't try to migrate anymore.
            if ( pStatus )
            {
                pStatus->put_Status(DCT_STATUS_ABORTING);
            }

            return false;
        }
    }
    else
    {
        auth.Password = NULL;
        auth.PasswordLength = 0;
    }

    auth.Flags  = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    // Auth Identity handle
    // if source domain credentials supplied use them
    // otherwise credentials of caller will be used
    RPC_AUTH_IDENTITY_HANDLE pHandle = ((auth.DomainLength > 0) && (auth.UserLength > 0)) ? &auth : NULL;

    DSADDSIDHISTORY	DsAddSidHistory;
    HINSTANCE hInst = LoadLibrary(L"NTDSAPI.DLL");


    if ( hInst )
    {
        DsAddSidHistory = (DSADDSIDHISTORY) GetProcAddress(hInst, "DsAddSidHistoryW");
        if (DsAddSidHistory)
        {
            if ( !pOptions->nochange )
            {
                int loopCount = 0;
                rc = RPC_S_SERVER_UNAVAILABLE;
                // If we get the RPC server errors we need to retry 5 times.
                while ( (((rc == RPC_S_SERVER_UNAVAILABLE) || (rc == RPC_S_CALL_FAILED) || (rc == RPC_S_CALL_FAILED_DNE)) && loopCount < 5)
                    || ( (rc == ERROR_INVALID_HANDLE) && loopCount < 3 ) )      // In case of invalid handle we try it 3 times now.
                {
                    // Make the API call to add Sid to the history
                    rc = DsAddSidHistory( 
                        pOptions->dsBindHandle,		//DS Handle
                        NULL,							// flags
                        pOptions->srcDomain,			// Source domain
                        strSrcPrincipal,				// Source Account name
                        NULL,			// Source Domain Controller
                        pHandle,						// RPC_AUTH_IDENTITY_HANDLE
                        pOptions->tgtDomainDns,			   // Target domain
                        strDestPrincipal);			// Target Account name
                    if ( loopCount > 0 ) Sleep(500);
                    loopCount++;
                }
            }

            SecureZeroMemory(szPassword, sizeof(szPassword));

            if ( rc != 0 )
            {
                switch ( rc )
                {
                    // these are the error codes caused by permissions or configuration problems
                case ERROR_NONE_MAPPED:
                    err.MsgWrite(ErrE, DCT_MSG_ADDSIDHISTORY_FAIL_BUILTIN_SSD,strSrcPrincipal, strDestPrincipal, rc); 
                    break;
                case ERROR_DS_UNWILLING_TO_PERFORM:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DS_UNWILLING_TO_PERFORM_SSSSD,strDestPrincipal,pOptions->srcDomain, strSrcPrincipal, pOptions->tgtDomain,rc);
                    break;
                case ERROR_DS_INSUFF_ACCESS_RIGHTS:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INSUFF_ACCESS_SD,strDestPrincipal,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_INVALID_HANDLE:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INVALID_HANDLE_SSD,pOptions->srcDomainDns,strDestPrincipal,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOAUDIT_SSD,strDestPrincipal,pOptions->tgtDomainDns,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_MUST_BE_RUN_ON_DST_DC:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DST_DC_SD,strDestPrincipal,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_PKT_PRIVACY_SD,strDestPrincipal,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_SOURCE_DOMAIN_IN_FOREST:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_SOURCE_IN_FOREST_S,strDestPrincipal);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DEST_WRONG_FOREST_S,strDestPrincipal);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_MASTERDSA_REQUIRED:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NO_MASTERDSA_S,strDestPrincipal);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_ACCESS_DENIED:
                    g_bAddSidWorks = FALSE;
                    if (pHandle)
                    {
                        err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INSUFF2_SSS,strDestPrincipal,pOptions->authDomain,pOptions->authUser);
                    }
                    else
                    {
                        err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_INSUFF2_S,strDestPrincipal);
                    }
                    break;
                case ERROR_DS_DST_DOMAIN_NOT_NATIVE:
                    g_bAddSidWorks = FALSE;
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOT_NATIVE_S,strDestPrincipal);
                    break;
                case ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN:
                    g_bAddSidWorks = FALSE;
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NO_SOURCE_DC_S,strDestPrincipal);
                    break;
                    //            case ERROR_DS_INAPPROPRIATE_AUTH:
                case ERROR_DS_UNAVAILABLE:
                    g_bAddSidWorks = FALSE;
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_DS_UNAVAILABLE_S,strDestPrincipal);
                    break;
                case ERROR_DS_SOURCE_AUDITING_NOT_ENABLED:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_NOAUDIT_SSD,strDestPrincipal,pOptions->srcDomain,rc);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_SOURCE_NOT_SP4_S,strDestPrincipal);
                    g_bAddSidWorks = FALSE;
                    break;
                case ERROR_SESSION_CREDENTIAL_CONFLICT:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_CREDENTIALS_CONFLICT_SSSS,strDestPrincipal,pOptions->srcDomain,pOptions->authDomain,pOptions->authUser);
                    g_bAddSidWorks = FALSE;
                    break;
                    // these are error codes that only affect this particular account
                case ERROR_SUCCESS:
                    g_bAddSidWorks = TRUE;
                    // no error message needed for success case!
                    break;

                case ERROR_DS_SRC_SID_EXISTS_IN_FOREST:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_IN_FOREST_SD,strDestPrincipal,rc);
                    g_bAddSidWorks = TRUE;
                    break;

                case ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER:
                    err.MsgWrite(ErrE,DCT_MSG_SID_HISTORY_WRONGTYPE_SD,strDestPrincipal,rc);
                    g_bAddSidWorks = TRUE;
                    break;
                case ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH:
                    err.MsgWrite(ErrE, DCT_MSG_SID_HISTORY_CLASS_MISMATCH_SSD, strDestPrincipal, strSrcPrincipal, rc);
                    g_bAddSidWorks = TRUE;
                    break;
                default:
                    err.MsgWrite(ErrE,DCT_MSG_ADDSID_FAILED_SSD,strSrcPrincipal, strDestPrincipal,rc);
                    g_bAddSidWorks = TRUE;
                    break;
                }

                Mark(L"errors", L"generic");

                // This may or may not be a fatal error depending on weather we are Adding
                // sid history or copying sid history
                g_bAddSidWorks |= !(isFatal);

                if (! g_bAddSidWorks )
                {
                    // log a message indicating that SIDHistory will not be tried for the rest of the accounts
                    err.MsgWrite(ErrW,DCT_MSG_SIDHISTORY_FATAL_ERROR);
                    Mark(L"warnings", L"generic");
                    // we are going to set the status to abort so that we don't try to migrate anymore.
                    if ( pStatus )
                    {
                        pStatus->put_Status(DCT_STATUS_ABORTING);
                    }

                }
                FreeLibrary(hInst);
                return false;
            }
            else
            {
                err.MsgWrite(0, DCT_MSG_ADD_SID_SUCCESS_SSSS, pOptions->srcDomainFlat, strSrcPrincipal, pOptions->tgtDomainFlat, strDestPrincipal);
                FreeLibrary(hInst);
                return true;
            }
        }
        else
        {
            SecureZeroMemory(szPassword, sizeof(szPassword));
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_NO_ADDSIDHISTORY_FUNCTION);
            Mark(L"errors", L"generic");
            FreeLibrary(hInst);
            return false;
        }
    }
    else
    {
        SecureZeroMemory(szPassword, sizeof(szPassword));
        err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_NO_NTDSAPI_DLL);
        Mark(L"errors", L"generic");
        return false;
    }
}

//--------------------------------------------------------------------------
// FillupNamingContext : This function fills in the target Naming context
//                       for NT5 domain.
//--------------------------------------------------------------------------
void FillupNamingContext(
                     Options * options  //in,out- Options to fill up
                   )
{
   WCHAR                     sPath[LEN_Path];
   IADs                    * pAds;
   _variant_t                var;
   HRESULT                   hr;

   wsprintf(sPath, L"LDAP://%s/rootDSE", options->tgtDomain);
   hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr) )
   {
      wcscpy(options->tgtNamingContext, L"");
      return;
   }

   hr = pAds->Get(L"defaultNamingContext", &var);
   if ( FAILED(hr) )
   {
      wcscpy(options->tgtNamingContext, L"");
      return;
   }
   pAds->Release();
   wcscpy(options->tgtNamingContext, (WCHAR*) V_BSTR(&var));
}

//--------------------------------------------------------------------------
// MakeFullyQualifiedAdsPath : Makes a LDAP sub path into a fully qualified 
//                             LDAP path name.
//--------------------------------------------------------------------------
void MakeFullyQualifiedAdsPath(
                                 WCHAR * sPath,          //out- Fully qulified LDAP path to the object
								 DWORD	 nPathLen,		 //in - MAX size, in characters, of the sPath buffer
                                 WCHAR * sSubPath,       //in- LDAP subpath of the object
                                 WCHAR * tgtDomain,      //in- Domain name where object exists.
                                 WCHAR * sDN             //in- Default naming context for the Domain 
                              )
{
   if ((!sPath) || (!sSubPath) || (!tgtDomain) || (!sDN))
      return;

   _bstr_t sTempPath;
   if (wcsncmp(sSubPath, L"LDAP://", 7) == 0)
   {
      //it is already a fully qualified LDAP path so lets copy it and return it
      wcsncpy(sPath, sSubPath, nPathLen-1);
      sPath[nPathLen - 1] = L'\0';
      return;
   }

   //We need to build this path so lets get to work
   if ( wcslen(sDN) )
   {
	  sTempPath = L"LDAP://";
	  sTempPath += tgtDomain;
	  sTempPath += L"/";
	  sTempPath += sSubPath;
	  sTempPath += L",";
	  sTempPath += sDN;
   }
   else
   {
	  sTempPath = L"LDAP://";
	  sTempPath += tgtDomain;
	  sTempPath += L"/";
	  sTempPath += sSubPath;
   }

   if (sTempPath.length() > 0)
   {
	  wcsncpy(sPath, sTempPath, nPathLen - 1);
      sPath[nPathLen - 1] = L'\0';
   }
   else
   {
      *sPath = L'\0';
   }
}


//--------------------------------------------------------------------------
// IsAccountMigrated : Function checks if the account has been migrated in
//                     the past. If it has it returns true filling in the
//                     name of the target object in case it was renamed.
//                     Otherwise it returns FALSE and Empty string for the 
//                     target name.
//--------------------------------------------------------------------------
bool IsAccountMigrated( 
                        TAcctReplNode * pNode,     //in -Account node that contains the Account info
                        Options       * pOptions,  //in -Options as specified by the user.
                        IIManageDBPtr   pDb,       //in -Pointer to DB manager. We dont want to create this object for every account we process
                        WCHAR         * sTgtSam    //in,out - Name of the target object that was copied if any.
                     )
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;

   pVs->QueryInterface(IID_IUnknown, (void**) &pUnk);

   HRESULT hrFind = pDb->raw_GetAMigratedObject(const_cast<WCHAR*>(pNode->GetSourceSam()), pOptions->srcDomain, pOptions->tgtDomain, &pUnk);
   pUnk->Release();
   if ( hrFind != S_OK )
   {
      wcscpy(sTgtSam,L"");
      return false;
   }
   else
   {
      _bstr_t     sText;
      sText = pVs->get(L"MigratedObjects.TargetSamName");
	  if (!(WCHAR*)sText)
	  {
         wcscpy(sTgtSam,L"");
	     return false;
	  }
      wcscpy(sTgtSam, (WCHAR*) sText);
      return true;
   }
}

bool CheckifAccountExists(
                        Options const * options,   //in-Options as set by the user
                        WCHAR * acctName     //in-Name of the account to look for
                     )
{
   USER_INFO_0             * buf;
   long                      rc = 0;
   if ( (rc = NetUserGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }
   
   if ( (rc = NetGroupGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }

   if ( (rc = NetLocalGroupGetInfo(const_cast<WCHAR*>(options->tgtComp), acctName, 0, (LPBYTE *) &buf)) == NERR_Success )
   {
      NetApiBufferFree(buf);
      return true;
   }

   return false;
}

//--------------------------------------------------------------------------
// Mark : Increments appropriate counters depending on the arguments.
//--------------------------------------------------------------------------
void Mark( 
                        _bstr_t sMark,    //in- Represents the type of marking { processed, errors, replaced, created }
                        _bstr_t sObj      //in- Type of object being marked { user, group, computer }
                     )
{
   if (!UStrICmp(sMark,L"processed"))
   {
      if ( !UStrICmp(sObj,L"user") || !UStrICmp(sObj,L"inetOrgPerson") ) processed.users++;
      else if ( !UStrICmp(sObj,L"group")) processed.globals++;
      else if ( !UStrICmp(sObj,L"computer")) processed.computers++;
      else if ( !UStrICmp(sObj,L"generic")) processed.generic++;
   }
   else if (!UStrICmp(sMark,L"errors"))
   {
      if ( !UStrICmp(sObj,L"user") || !UStrICmp(sObj,L"inetOrgPerson") ) errors.users++;
      else if ( !UStrICmp(sObj,L"group")) errors.globals++;
      else if ( !UStrICmp(sObj,L"computer")) errors.computers++;
      else if ( !UStrICmp(sObj,L"generic")) errors.generic++;
   }
   else if (!UStrICmp(sMark,L"warnings"))
   {
      if ( !UStrICmp(sObj,L"user") || !UStrICmp(sObj,L"inetOrgPerson") ) warnings.users++;
      else if ( !UStrICmp(sObj,L"group")) warnings.globals++;
      else if ( !UStrICmp(sObj,L"computer")) warnings.computers++;
      else if ( !UStrICmp(sObj,L"generic")) warnings.generic++;
   }
   else if (!UStrICmp(sMark,L"replaced"))
   {
      if ( !UStrICmp(sObj,L"user") || !UStrICmp(sObj,L"inetOrgPerson") ) replaced.users++;
      else if ( !UStrICmp(sObj,L"group")) replaced.globals++;
      else if ( !UStrICmp(sObj,L"computer")) replaced.computers++;
      else if ( !UStrICmp(sObj,L"generic")) replaced.generic++;
   }
   else if (!UStrICmp(sMark,L"created"))
   {
      if ( !UStrICmp(sObj,L"user") || !UStrICmp(sObj,L"inetOrgPerson") ) created.users++;
      else if ( !UStrICmp(sObj,L"group")) created.globals++;
      else if ( !UStrICmp(sObj,L"computer")) created.computers++;
      else if ( !UStrICmp(sObj,L"generic")) created.generic++;
   }
}

//
// This function batch-marks one category of AccountStats based on an EAMAccountStatItem struct.
//  statItem: the EAMAccountStatItem struct
//  aStat:   the AccountStats struct; should be one of errors, warnings, replaced, created, processed
//
static void BatchMarkCategory(const EAMAccountStatItem& statItem, AccountStats& aStat)
{
    aStat.locals += statItem.locals;
    aStat.users += statItem.users;
    aStat.globals += statItem.globals;
    aStat.computers += statItem.computers;
    aStat.generic += statItem.generic;
}

//
// This function batch-marks all categories of AccountStats based on an EAMAccountStats struct.
//  stats: the EAMAccountStats struct
//
void BatchMark(const EAMAccountStats& stats)
{
    BatchMarkCategory(stats.errors, errors);
    BatchMarkCategory(stats.warnings, warnings);
    BatchMarkCategory(stats.replaced, replaced);
    BatchMarkCategory(stats.created, created);
    BatchMarkCategory(stats.processed, processed);
}


HRESULT __stdcall GetRidPoolAllocator(Options* pOptions)
{
    WCHAR szADsPath[LEN_Path];

    //
    // Bind to source Domain object and retrieve distinguished name of RID Manager object.
    //

    IADsPtr spDomain;
    _bstr_t strRIDManagerReference;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    int cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        pOptions->srcComp + 2,
        pOptions->srcNamingContext
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    HRESULT hr = ADsGetObject(szADsPath, IID_IADs, (VOID**)&spDomain);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varRIDManagerReference;
    VariantInit(&varRIDManagerReference);

    hr = spDomain->Get(L"rIDManagerReference", &varRIDManagerReference);

    if (FAILED(hr))
    {
        return hr;
    }

    strRIDManagerReference = _variant_t(varRIDManagerReference, false);

    //
    // Bind to RID Manager object and retrieve distinguished name of the FSMO Role Owner.
    //

    IADsPtr spRIDManager;
    _bstr_t strFSMORoleOwner;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        pOptions->srcComp + 2,
        (PCWSTR)strRIDManagerReference
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    hr = ADsGetObject(szADsPath, IID_IADs, (VOID**)&spRIDManager);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varFSMORoleOwner;
    VariantInit(&varFSMORoleOwner);

    hr = spRIDManager->Get(L"fSMORoleOwner", &varFSMORoleOwner);

    if (FAILED(hr))
    {
        return hr;
    }

    strFSMORoleOwner = _variant_t(varFSMORoleOwner, false);

    //
    // Bind to NTDS-DSA object and retrieve ADsPath of parent Server object.
    //

    IADsPtr spNTDSDSA;
    _bstr_t strServer;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        pOptions->srcComp + 2,
        (PCWSTR)strFSMORoleOwner
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    hr = ADsGetObject(szADsPath, IID_IADs, (VOID**)&spNTDSDSA);

    if (FAILED(hr))
    {
        return hr;
    }

    BSTR bstrServer;

    hr = spNTDSDSA->get_Parent(&bstrServer);

    if (FAILED(hr))
    {
        return hr;
    }

    strServer = _bstr_t(bstrServer, false);

    //
    // Bind to Server object and retrieve distinguished name of Computer object.
    //

    IADsPtr spServer;
    _bstr_t strServerReference;

    hr = ADsGetObject(strServer, IID_IADs, (VOID**)&spServer);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varServerReference;
    VariantInit(&varServerReference);

    hr = spServer->Get(L"serverReference", &varServerReference);

    if (FAILED(hr))
    {
        return hr;
    }

    strServerReference = _variant_t(varServerReference, false);

    //
    // Bind to Computer object and retrieve DNS host name and SAM account name.
    //

    IADsPtr spComputer;
    _bstr_t strDNSHostName;
    _bstr_t strSAMAccountName;

    szADsPath[countof(szADsPath) - 1] = L'\0';

    cch = _snwprintf(
        szADsPath,
        countof(szADsPath),
        L"LDAP://%s/%s",
        pOptions->srcComp + 2,
        (PCWSTR)strServerReference
    );

    if ((cch < 0) || (szADsPath[countof(szADsPath) - 1] != L'\0'))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    szADsPath[countof(szADsPath) - 1] = L'\0';

    hr = ADsGetObject(szADsPath, IID_IADs, (VOID**)&spComputer);

    if (FAILED(hr))
    {
        return hr;
    }

    VARIANT varDNSHostName;
    VariantInit(&varDNSHostName);

    hr = spComputer->Get(L"dNSHostName", &varDNSHostName);

    if (FAILED(hr))
    {
        return hr;
    }

    strDNSHostName = _variant_t(varDNSHostName, false);

    VARIANT varSAMAccountName;
    VariantInit(&varSAMAccountName);

    hr = spComputer->Get(L"SAMAccountName", &varSAMAccountName);

    if (FAILED(hr))
    {
        return hr;
    }

    strSAMAccountName = _variant_t(varSAMAccountName, false);

    if ((strDNSHostName.length() == 0) || (strSAMAccountName.length() == 0))
    {
        return E_OUTOFMEMORY;
    }

    //
    // Update source domain controller names.
    //

    if ((2 + strDNSHostName.length() >= countof(pOptions->srcComp)) ||
        (2 + strDNSHostName.length() >= countof(pOptions->srcCompDns)) ||
        (2 + strSAMAccountName.length() >= countof(pOptions->srcCompFlat)))
    {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    wcscpy(pOptions->srcComp, L"\\\\");
    wcscat(pOptions->srcComp, strDNSHostName);
    wcscpy(pOptions->srcCompDns, pOptions->srcComp);
    wcscpy(pOptions->srcCompFlat, L"\\\\");
    wcscat(pOptions->srcCompFlat, strSAMAccountName);

    // Remove trailing $ character.

    pOptions->srcCompFlat[wcslen(pOptions->srcCompFlat) - 1] = L'\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\userrts.h ===
// UserRights.h : Declaration of the CUserRights

#ifndef __USERRIGHTS_H_
#define __USERRIGHTS_H_

#include "resource.h"       // main symbols
#include <comdef.h>

#include "ntsecapi.h"

#include "CommaLog.hpp"

class PrivNode;
class PrivList;

/////////////////////////////////////////////////////////////////////////////
// CUserRights
class ATL_NO_VTABLE CUserRights : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUserRights, &CLSID_UserRights>,
    public IDispatchImpl<IUserRights, &IID_IUserRights, &LIBID_MCSDCTWORKEROBJECTSLib>
{
   BOOL                      m_bNoChange;
   BOOL                      m_bUseDisplayName;
   BOOL                      m_bRemove;
   _bstr_t                   m_SourceComputer;
   _bstr_t                   m_TargetComputer;
   LSA_HANDLE                m_SrcPolicy;
   LSA_HANDLE                m_TgtPolicy;
public:
    CUserRights()
    {
      m_bNoChange = FALSE;
      m_bUseDisplayName = FALSE;
      m_bRemove = FALSE;
      m_SrcPolicy = 0;
      m_TgtPolicy = 0;
   }
   ~CUserRights();
   
DECLARE_REGISTRY_RESOURCEID(IDR_USERRIGHTS)
DECLARE_NOT_AGGREGATABLE(CUserRights)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUserRights)
    COM_INTERFACE_ENTRY(IUserRights)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


// IUserRights
public:
    STDMETHOD(GetRightsOfUser)(BSTR server, BSTR user, SAFEARRAY ** rights);
    STDMETHOD(GetUsersWithRight)(BSTR server, BSTR right, /*[out]*/ SAFEARRAY ** users);
    STDMETHOD(GetRights)(BSTR server, /*[out]*/ SAFEARRAY ** rights);
    STDMETHOD(RemoveUserRight)(BSTR server, BSTR username, BSTR right);
    STDMETHOD(AddUserRight)(BSTR server, BSTR username, BSTR right);
    STDMETHOD(ExportUserRights)(BSTR server, BSTR filename, BOOL bAppendToFile);
    STDMETHOD(get_RemoveOldRightsFromTargetAccounts)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_RemoveOldRightsFromTargetAccounts)(/*[in]*/ BOOL newVal);
    STDMETHOD(get_NoChange)(/*[out, retval]*/ BOOL *pVal);
    STDMETHOD(put_NoChange)(/*[in]*/ BOOL newVal);
    STDMETHOD(CopyUserRights)(BSTR sourceUserName, BSTR targetUserName);
    STDMETHOD(OpenTargetServer)(BSTR computerName);
    STDMETHOD(OpenSourceServer)(BSTR serverName);
    STDMETHOD(CopyUserRightsWithSids)(BSTR sourceUserName, BSTR sourceSID,BSTR targetUserName,BSTR targetSID);
    STDMETHOD(AddUserRights)(BSTR bstrServer, BSTR bstrSid, SAFEARRAY* psaRights);
    STDMETHOD(RemoveUserRights)(BSTR bstrServer, BSTR bstrSid, SAFEARRAY* psaRights);

protected:
   DWORD CopyUserRightsInternal(WCHAR * sourceUserName,WCHAR * tgtUserName, WCHAR * sourceSid, WCHAR * targetSid,BOOL noChange, BOOL remove);
   DWORD EnumerateAccountsWithRight(LSA_HANDLE policy, WCHAR * server,LSA_UNICODE_STRING * pRight, CommaDelimitedLog * pLog);
   DWORD SafeArrayFromPrivList(PrivList * privList, SAFEARRAY ** pArray);
   HRESULT SetRights(PWSTR pszServer, PSID pSid, SAFEARRAY* psaRights, bool bEnable);
};

#endif //__USERRIGHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\userrts.cpp ===
/*---------------------------------------------------------------------------
  File: UserRights.cpp

  Comments: COM object to update user rights.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:34:35

 ---------------------------------------------------------------------------
*/

// UserRights.cpp : Implementation of CUserRights
#include "stdafx.h"
#include "WorkObj.h"
#include "UserRts.h"
#include "Common.hpp"
#include "TNode.hpp"
#include "UString.hpp"
#include "ErrDct.hpp"
#include "TxtSid.h"
#include "LSAUtils.h"
#include "EaLen.hpp"
#include "ntsecapi.h"

#include <lm.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern TErrorDct err;
#define LEN_SID      200


#ifndef SE_DENY_INTERACTIVE_LOGON_NAME 
#define SE_DENY_INTERACTIVE_LOGON_NAME      TEXT("SeDenyInteractiveLogonRight")
#endif
#ifndef SE_DENY_NETWORK_LOGON_NAME
#define SE_DENY_NETWORK_LOGON_NAME          TEXT("SeDenyNetworkLogonRight")
#endif
#ifndef SE_DENY_BATCH_LOGON_NAME
#define SE_DENY_BATCH_LOGON_NAME            TEXT("SeDenyBatchLogonRight")
#endif
#ifndef SE_DENY_SERVICE_LOGON_NAME
#define SE_DENY_SERVICE_LOGON_NAME          TEXT("SeDenyServiceLogonRight")
#endif

//

// this function wasn't defined in the header file.
extern "C" {
NTSTATUS
   NTAPI
   LsaEnumeratePrivileges(
    LSA_HANDLE PolicyHandle,
    LSA_ENUMERATION_HANDLE * eHandle,
    LPVOID * enumBuffer,
    ULONG prefMaxLen,
    ULONG * countReturned
   );
   
};
//The following definition was in ntsecapi.h but was mistakenly taken out
//in the W2K build version.
//
// The following data type is used to return information about privileges
// defined on a system.
//

typedef struct _POLICY_PRIVILEGE_DEFINITION {

    LSA_UNICODE_STRING Name;
    LUID LocalValue;

} POLICY_PRIVILEGE_DEFINITION, *PPOLICY_PRIVILEGE_DEFINITION;


class PrivNode : public TNode
{
   WCHAR                     name[200];

public:
   PrivNode(WCHAR * str, USHORT length ) { UStrCpy(name,str,length+1); name[length] = 0; }

   WCHAR * Name() { return name; }
};

class PrivList : public TNodeListSortable
{
protected:
   static TNodeCompare(CompareName) 
   { 
      PrivNode             * p1 = (PrivNode *)v1;
      PrivNode             * p2 = (PrivNode *)v2;

      return UStrICmp(p1->Name(),p2->Name());
   }
   static TNodeCompareValue(CompareValue)
   {
      PrivNode             * p   = (PrivNode *)tnode;
      WCHAR                * str = (WCHAR *)value;

      return UStrICmp(p->Name(),str);
   }
public:
   PrivList() { TypeSetSorted(); CompareSet(&CompareName); }
   ~PrivList() { DeleteAllListItems(PrivNode); }
   void InsertPrivilege(PrivNode * p) { SortedInsertIfNew((TNode *)p); }
   BOOL Contains(WCHAR * priv) { return ( NULL != Find(&CompareValue,(void*)priv) ); }

};

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,   // in - handle to LSA
      WCHAR                * account,  // in - account to list privileges for
      WCHAR                * strSid,   // in - textual form of account's sid, if known
      WCHAR                * computer, // in - computer name
      PrivList             * privList, // i/o- list of privileges
      PSID                 * ppSid     // out- SID for the account
   );

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,   // in - handle to LSA
      PSID                   pSid,     // in - sid of account to list privileges for
      PrivList             * privList  // i/o- list of privileges
   );

NTSTATUS
   OpenPolicy(
      LPWSTR ServerName,          // machine to open policy on (Unicode)
      DWORD DesiredAccess,        // desired access to policy
      PLSA_HANDLE PolicyHandle    // resultant policy handle
    );

BOOL
   GetAccountSid(
      LPTSTR SystemName,          // where to lookup account
      LPTSTR AccountName,         // account of interest
      PSID *Sid                   // resultant buffer containing SID
    );

NTSTATUS
   SetPrivilegeOnAccount(
      LSA_HANDLE PolicyHandle,    // open policy handle
      PSID AccountSid,            // SID to grant privilege to
      LPWSTR PrivilegeName,       // privilege to grant (Unicode)
      BOOL bEnable                // enable or disable
    );


/////////////////////////////////////////////////////////////////////////////
// CUserRights

CUserRights::~CUserRights()
{
   if ( m_SrcPolicy )
   {
      LsaClose(m_SrcPolicy);
   }
   if ( m_TgtPolicy )
   {
      LsaClose(m_TgtPolicy);
   }
}

STDMETHODIMP 
   CUserRights::OpenSourceServer(
      BSTR                   serverName      // in - computer name (DC) for source domain
  )
{
    DWORD                     rc;
   
   if ( m_SrcPolicy )
   {
      LsaClose(m_SrcPolicy);
      m_SrcPolicy = NULL;
   }
   rc = OpenPolicy( serverName, POLICY_LOOKUP_NAMES, &m_SrcPolicy );
   m_SourceComputer = serverName;

  return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::OpenTargetServer(
      BSTR                   computerName    // in - computer name (DC) for target domain
   )
{  
   DWORD                     rc;

   if ( m_TgtPolicy )
   {
      LsaClose(m_TgtPolicy);
      m_TgtPolicy = NULL;
   }
   rc = OpenPolicy( computerName,POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES ,&m_TgtPolicy);
   m_TargetComputer = computerName;

    return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::CopyUserRights(
      BSTR                   sourceUserName,       // in - source domain account to copy rights from
      BSTR                   targetUserName        // in - target domain account to copy rights to
   )
{
   HRESULT                   hr = S_OK;
   DWORD                     rc;

   // Make sure source and target are open
   if ( m_SrcPolicy && m_TgtPolicy )
   {
      rc = CopyUserRightsInternal(sourceUserName,targetUserName,L"",L"",m_bNoChange,m_bRemove);
      hr = HRESULT_FROM_WIN32(rc);
   }
   else 
   {
      hr = E_FAIL;
   }

    return S_OK;
}


STDMETHODIMP 
   CUserRights::CopyUserRightsWithSids(
      BSTR                   sourceUserName,       // in - source domain account to copy rights from
      BSTR                   sourceSID,            // in - source account SID (in string format)
      BSTR                   targetUserName,       // in - target domain account to copy rights to
      BSTR                   targetSID             // in - target account SID (in string format)
   )
{
   HRESULT                   hr = S_OK;
   DWORD                     rc;

   // Make sure source and target are open
   if ( m_SrcPolicy && m_TgtPolicy )
   {
      rc = CopyUserRightsInternal(sourceUserName,targetUserName,sourceSID,targetSID,m_bNoChange,m_bRemove);
      hr = HRESULT_FROM_WIN32(rc);
   }
   else 
   {
      hr = E_FAIL;
   }

    return S_OK;
}
STDMETHODIMP CUserRights::get_NoChange(BOOL *pVal) // out- value
{
    (*pVal) = m_bNoChange;
   return S_OK;
}

STDMETHODIMP CUserRights::put_NoChange(BOOL newVal)   // in - new value
{
    m_bNoChange = newVal;
   return S_OK;
}

STDMETHODIMP CUserRights::get_RemoveOldRightsFromTargetAccounts(BOOL *pVal)   // out- value
{
   (*pVal) = m_bRemove;
   return S_OK;
}

STDMETHODIMP CUserRights::put_RemoveOldRightsFromTargetAccounts(BOOL newVal)  // in - new value
{
    m_bRemove = newVal;
   return S_OK;
}
                                   


STDMETHODIMP 
   CUserRights::ExportUserRights(
      BSTR                   server,            // in - computer to read rights from
      BSTR                   filename,          // in - filename to export list of rights to
      BOOL                   bAppendToFile      // in - flag, append or overwrite file if it exists
   )
{
   LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   if ( ! rc )
   {
      CommaDelimitedLog      log;

      if ( log.LogOpen(filename,FALSE,bAppendToFile) )
      {
         // Enumerate the privileges on this machine
         
         // arguments for LsaEnumeratePrivileges
         ULONG                         countOfRights;
         DWORD                         prefMax = 0xffffffff;
         LSA_ENUMERATION_HANDLE        handle = 0;
         POLICY_PRIVILEGE_DEFINITION * pRights = NULL;
         
         do 
         {
            rc = LsaEnumeratePrivileges(policy,&handle,(LPVOID*)&pRights,prefMax,&countOfRights);
            if ( rc ) 
            {
               rc = LsaNtStatusToWinError(rc);
               if ( rc == ERROR_NO_MORE_ITEMS )
                  rc = 0;
               break;
            }
               // For each right, enumerate the accounts that have that right
            if ( ! rc )
            {
               
               for ( UINT right = 0 ;right < countOfRights ; right++ )
               {
                  rc = EnumerateAccountsWithRight(policy,server,&pRights[right].Name,&log);
               }
               LsaFreeMemory(pRights);

               LSA_UNICODE_STRING      lsaRight;
               // For some reason, LsaEnumeratePrivileges doesn't return these rights
               // They are defined in "ntsecapi.h", and not with the rest of the privileges in "winnt.h"
               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_INTERACTIVE_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_NETWORK_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_BATCH_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }

               if ( ! rc )
               {
                  InitLsaString(&lsaRight,SE_SERVICE_LOGON_NAME);
                  rc = EnumerateAccountsWithRight(policy,server,&lsaRight,&log);
               }
            }
            else
            {
               rc = LsaNtStatusToWinError(rc);
            }
         }
         while ( ! rc );
         log.LogClose();
      }
      else
      {
         rc = GetLastError();
      }
      LsaClose(policy);
   }
    
   hr = HRESULT_FROM_WIN32(rc);
   return hr;
}


DWORD 
   CUserRights::EnumerateAccountsWithRight(
      LSA_HANDLE             policy,               // in - handle to LSA
      WCHAR                * server,               // in - computer name
      LSA_UNICODE_STRING   * pRight,               // in - user right
      CommaDelimitedLog    * pLog                  // in - pointer to log object to log information to
   )
{

   DWORD                         rc = 0;
   WCHAR                         account[LEN_Account];
   WCHAR                         domain[LEN_Domain];
   WCHAR                         domacct[LEN_Domain + LEN_Account];
   WCHAR                         szRight[LEN_Account];
   WCHAR                         szDisplayName[LEN_DisplayName];
   DWORD                         lenAccount = DIM(account);
   DWORD                         lenDomain = DIM(domain);
   DWORD                         lenDisplayName = DIM(szDisplayName);
   SID_NAME_USE                  snu;
   DWORD                         lid;            
   BOOL                          bUseDisplayName;

   // arguments for LsaEnumerateAccountsWithUserRight
   ULONG                         countOfUsers;
   LSA_ENUMERATION_INFORMATION * pInfo = NULL;
           
   UStrCpy(szRight,pRight->Buffer,pRight->Length/(sizeof WCHAR) + 1);
   bUseDisplayName = m_bUseDisplayName && LookupPrivilegeDisplayName(server,szRight,szDisplayName,&lenDisplayName,&lid);
               
                  
   rc = LsaEnumerateAccountsWithUserRight(policy,pRight,(PVOID*)&pInfo,&countOfUsers);

   if ( ! rc )
   {
      for ( UINT user = 0 ; user < countOfUsers ; user++ )
      {
         if ( ! pInfo[user].Sid )
         {
            break; // something is wrong
         }
         domain[0] = 0;
         account[0] = 0;
         lenDomain = DIM(domain);
         lenAccount = DIM(account);
         if ( LookupAccountSid(server,pInfo[user].Sid,account,&lenAccount,domain,&lenDomain,&snu) )
         {
            if ( *account )
            {
               swprintf(domacct,L"%s\\%s",domain,account);
            }
            else
            {
               lenAccount = DIM(account);
               GetTextualSid(pInfo[user].Sid,account,&lenAccount);
               if ( snu == SidTypeDeletedAccount )
               {
                  swprintf(domacct,L"%s\\<Deleted Account: %s>",domain,account);
               }
               else
               {
                  swprintf(domacct,L"%s\\<%s>",domain,account);
               }
            }
         }
         else
         {
            lenAccount = DIM(account);
            GetTextualSid(pInfo[user].Sid,domacct,&lenAccount);
         }
         if ( bUseDisplayName )
         {
            pLog->MsgWrite(L"%s, %s, %s",server,domacct,szDisplayName);   
         }
         else
         {
            pLog->MsgWrite(L"%s, %s, %s",server,domacct,szRight);
         }
      }
      LsaFreeMemory(pInfo);
   }
   else
   {
      rc = LsaNtStatusToWinError(rc);
      if ( rc == ERROR_NO_MORE_ITEMS )
         rc = 0;
   }

   return rc;
}

DWORD 
   CUserRights::CopyUserRightsInternal(
      WCHAR                * srcAccount,        // in - source account to copy rights from
      WCHAR                * tgtAccount,        // in - account to copy rights to
      WCHAR                * srcSidStr,         // in - sid for source account, in string format
      WCHAR                * tgtSidStr,         // in - sid for target account, in string format
      BOOL                   bNoChange,         // in - flag, whether to write changes
      BOOL                   bRemove            // in - flag, whether to revoke rights from target if not held by source
   )
{
   DWORD                     rc = 0;
   PrivList                  srcList;
   PrivList                  tgtList;
   PSID                      pSidSrc = NULL;
   PSID                      pSidTgt = NULL;
   
   // Get a list of the privileges held by srcAccount
   rc = BuildPrivilegeList(m_SrcPolicy,srcAccount,srcSidStr,m_SourceComputer,&srcList,&pSidSrc);
   if ( ! rc )
   {
      rc = BuildPrivilegeList(m_TgtPolicy,tgtAccount,tgtSidStr,m_TargetComputer,&tgtList,&pSidTgt);
      if ( ! rc )
      {
         if ( bRemove )
         {
            // Get a list of privileges held by tgtAccount
            // Remove old privileges
            TNodeListEnum    tEnum;
            PrivNode       * p;
         
            for ( p = (PrivNode *)tEnum.OpenFirst(&tgtList) ; p ; p = (PrivNode*)tEnum.Next() )
            {
               if ( ! srcList.Contains(p->Name()) )
               {
                  // The source account doesn't have this privilege - remove it
                  if (! bNoChange )
                  {
                     rc = SetPrivilegeOnAccount(m_TgtPolicy,pSidTgt,p->Name(),FALSE);
                  }
                  if ( rc )
                  {
                     rc = LsaNtStatusToWinError(rc);
                     err.MsgWrite(ErrE,DCT_MSG_REMOVE_RIGHT_FAILED_SSD,p->Name(),tgtAccount,rc);
                     break;
                  }
                  else
                  {
                     err.MsgWrite(0,DCT_MSG_REMOVED_RIGHT_SS,p->Name(), tgtAccount);
                  }
               }
               else
               {
                  err.MsgWrite(0,DCT_MSG_USER_HAS_RIGHT_SS,tgtAccount,p->Name());
               }
            }
         }
         // Grant privileges to new account
         TNodeListEnum       tEnum;
         PrivNode          * p;

         for ( p = (PrivNode *)tEnum.OpenFirst(&srcList) ; p ; p = (PrivNode*)tEnum.Next() )
         {
            if ( ! tgtList.Contains(p->Name()) )
            {
               if ( ! bNoChange )
               {
                  rc = SetPrivilegeOnAccount(m_TgtPolicy,pSidTgt,p->Name(),TRUE);
                  if ( rc )
                  {
                     rc = LsaNtStatusToWinError(rc);
                     err.MsgWrite(ErrE,DCT_MSG_ADD_RIGHT_FAILED_SSD,p->Name(),tgtAccount,rc);
                     break;
                  }
                  else
                  {
                     err.MsgWrite(0,DCT_MSG_RIGHT_GRANTED_SS,p->Name(),tgtAccount);
                  }
               }
            }
         }
      }
   }
   
   // Clean up SIDs
   if(pSidSrc != NULL) 
   {
      FreeSid(pSidSrc);      
   }

   if(pSidTgt != NULL) 
   {
      FreeSid(pSidTgt);      
   }

   return rc;
}





/*++

Managing user privileges can be achieved programmatically using the
following steps:

1. Open the policy on the target machine with LsaOpenPolicy(). To grant
   privileges, open the policy with POLICY_CREATE_ACCOUNT and
   POLICY_LOOKUP_NAMES access. To revoke privileges, open the policy with
   POLICY_LOOKUP_NAMES access.

2. Obtain a SID (security identifier) representing the user/group of
   interest. The LookupAccountName() and LsaLookupNames() APIs can obtain a
   SID from an account name.

3. Call LsaAddAccountRights() to grant privileges to the user(s)
   represented by the supplied SID.

4. Call LsaRemoveAccountRights() to revoke privileges from the user(s)
   represented by the supplied SID.

5. Close the policy with LsaClose().

To successfully grant and revoke privileges, the caller needs to be an
administrator on the target system.

The LSA API LsaEnumerateAccountRights() can be used to determine which
privileges have been granted to an account.

The LSA API LsaEnumerateAccountsWithUserRight() can be used to determine
which accounts have been granted a specified privilege.

Documentation and header files for these LSA APIs is provided in the
Windows 32 SDK in the MSTOOLS\SECURITY directory.


--*/




#define RTN_OK 0
#define RTN_USAGE 1            
#define RTN_ERROR 13

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,         // in - handle to LSA
      PSID                   pSid,           // in - SID for account
      PrivList             * privList        // i/o- list of rights held by the account
   )      
{
   DWORD                     rc = 0;
   ULONG                     countOfRights = 0;
   PLSA_UNICODE_STRING       pUserRights = NULL;

   rc = LsaEnumerateAccountRights(policy,pSid,&pUserRights,&countOfRights);
   rc = LsaNtStatusToWinError(rc);
   if ( rc == ERROR_FILE_NOT_FOUND )
   {
      // This account has no privileges
      rc = 0;
      countOfRights = 0;
   }
   if ( ! rc )
   {
      for ( UINT i = 0 ; i < countOfRights ; i++ )
      {
         PrivNode * p = new PrivNode(pUserRights[i].Buffer,pUserRights[i].Length/2);
         privList->InsertPrivilege(p);
      }
      LsaFreeMemory(pUserRights);
   }

   return rc; 
}

DWORD 
   BuildPrivilegeList(
      LSA_HANDLE             policy,      // in - handle to LSA
      WCHAR                * account,     // in - account name to list rights for
      WCHAR                * strSid,      // in - text format of the accounts SID, if known
      WCHAR                * computer,    // in - computer to list rights on
      PrivList             * privList,    // i/o- list of rights held by account
      PSID                 * ppSid        // out- SID for account
   )
{
   DWORD                     rc = 0;
   PSID                      pSid = NULL;
   
   if ( strSid && (*strSid) )
   {
      // use the provided SID
      pSid = SidFromString(strSid);
      if ( ! pSid )
      {
         rc = GetLastError();
      }
   }
   else
   {
      // no SID provided, so look it up on the domain
      if ( !GetAccountSid(computer,account,&pSid) )
      {
         rc = GetLastError();
      }
   }

   if ( rc )
   {
      (*ppSid) = NULL;
      if(pSid != NULL) 
      {
         FreeSid(pSid);
         pSid = NULL;
      }
   }
   else
   {
      (*ppSid) = pSid;
   }
   
   if ( pSid )
   {
      rc = BuildPrivilegeList(policy,pSid,privList);
   }

   return rc;
}


BOOL
GetAccountSid(
    LPTSTR SystemName,           // in - computer name to lookup sid on
    LPTSTR AccountName,          // in - account name
    PSID *Sid                    // out- SID for account
    )
{
    WCHAR  ReferencedDomain[LEN_Domain];
    DWORD cbSid=128;    // initial allocation attempt
    DWORD cbReferencedDomain=DIM(ReferencedDomain); // initial allocation size
    SID_NAME_USE peUse;
    BOOL bSuccess=FALSE; // assume this function will fail
    PSID pTempSid = NULL;

    *Sid = NULL;    

    __try {

    //
    // initial memory allocations
    //
    if((pTempSid=HeapAlloc(
                    GetProcessHeap(),
                    0,
                    cbSid
                    )) == NULL) __leave;

    //
    // Obtain the SID of the specified account on the specified system.
    //
    while(!LookupAccountName(
                    SystemName,         // machine to lookup account on
                    AccountName,        // account to lookup
                    pTempSid,               // SID of interest
                    &cbSid,             // size of SID
                    ReferencedDomain,   // domain account was found on
                    &cbReferencedDomain,
                    &peUse
                    )) {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
            //
            // reallocate memory
            //

            PSID psid = HeapReAlloc(GetProcessHeap(), 0, pTempSid, cbSid);

            if (psid != NULL)
            {
                pTempSid = psid;
            }
            else
            {
                __leave;
            }
        }
        else __leave;
    }

    //
    // Indicate success.
    //
    bSuccess=TRUE;

    } // finally
    __finally {

    //
    // Cleanup and indicate failure, if appropriate.
    //

    if(!bSuccess) {
        if(pTempSid!= NULL) {
            HeapFree(GetProcessHeap(), 0, pTempSid);
            pTempSid = NULL;
        }
    }

    } // finally

    // we need to copy the sid over if previous operation succeeded
    if(bSuccess)
    {
        *Sid = SafeCopySid(pTempSid);
        if(!(*Sid))
        {
            // safecopysid failed for some reason, we need to update the return value
            bSuccess = FALSE;
        }

        // need to free the temporary sid
        if(pTempSid)
        {
            HeapFree(GetProcessHeap(), 0, pTempSid);
        }
        
    }


    return bSuccess;
}

NTSTATUS
SetPrivilegeOnAccount(
    LSA_HANDLE PolicyHandle,    // open policy handle
    PSID AccountSid,            // SID to grant privilege to
    LPWSTR PrivilegeName,       // privilege to grant (Unicode)
    BOOL bEnable                // enable or disable
    )
{
    LSA_UNICODE_STRING PrivilegeString;

    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, PrivilegeName);

    //
    // grant or revoke the privilege, accordingly
    //
    if(bEnable) {
        return LsaAddAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
    else {
        return LsaRemoveAccountRights(
                PolicyHandle,       // open policy handle
                AccountSid,         // target SID
                FALSE,              // do not disable all rights
                &PrivilegeString,   // privileges
                1                   // privilege count
                );
    }
}



STDMETHODIMP 
   CUserRights::AddUserRight(
      BSTR                   server,         // in - computer to grant right on
      BSTR                   strSid,         // in - textual form of sid for account to grant right to
      BSTR                   right           // in - right to grant to account
   )
{
   LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   PSID                      pSid = SidFromString(strSid);

   rc = OpenPolicy(server, POLICY_LOOKUP_NAMES|POLICY_CREATE_ACCOUNT, &policy);
   if ( ! rc )
   {
      if ( ! m_bNoChange )
      {
         rc = SetPrivilegeOnAccount(policy,pSid,right,TRUE);
      }
      if ( rc )
      {
         rc = LsaNtStatusToWinError(rc);
         hr = HRESULT_FROM_WIN32(rc);
      }
      LsaClose(policy);   
   }
   FreeSid(pSid);

   return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::RemoveUserRight(
      BSTR                   server,         // in - computer to revoke right on
      BSTR                   strSid,         // in - textual sid of account to revoke right for
      BSTR                   right           // in - right to revoke
  )
{
   LSA_HANDLE                policy;
   HRESULT                   hr = S_OK;
   DWORD                     rc;
   PSID                      pSid = SidFromString(strSid);
  
   rc = OpenPolicy(server, POLICY_LOOKUP_NAMES|POLICY_CREATE_ACCOUNT, &policy);
   if ( ! rc )
   {
      if ( ! m_bNoChange )
      {
         rc = SetPrivilegeOnAccount(policy,pSid,right,FALSE);
      }
      if ( rc )
      {
         rc = LsaNtStatusToWinError(rc);
         hr = HRESULT_FROM_WIN32(rc);
      }
      LsaClose(policy);   
   }
   FreeSid(pSid);

   return HRESULT_FROM_WIN32(rc);
}

DWORD 
   CUserRights::SafeArrayFromPrivList(
      PrivList             * privList,       // in - list of user rights
      SAFEARRAY           ** pArray          // out- safearray containing list contents
   )
{
   DWORD                     rc = 0;
   HRESULT                   hr;
   TNodeListEnum             e;
   SAFEARRAYBOUND            bound;
   LONG                      ndx[1];

   bound.lLbound = 0;
   bound.cElements = privList->Count();
   
   (*pArray) = SafeArrayCreate(VT_BSTR,1,&bound);
   
   if ( (*pArray) )
   {
      PrivNode             * p;
      UINT                   i;

      for ( p=(PrivNode*)e.OpenFirst(privList) , i = 0 ; 
            p ; 
            p = (PrivNode*)e.Next() , i++ )
      {
         ndx[0] = i;
         
         hr = SafeArrayPutElement((*pArray),ndx,SysAllocString(p->Name()));
         if ( FAILED(hr) )
         {
            rc = hr;
            break;
         }
      }
      e.Close();
   }
   else
   {
      rc = GetLastError();
   }
   return rc;
}

STDMETHODIMP 
   CUserRights::GetRights(
      BSTR                   server,         // in - computer
      SAFEARRAY           ** pRightsArray    // out- list of rights on computer
   )
{
   HRESULT                   hr = S_OK;
   PrivList                  priv;
   DWORD                     rc = 0;
    
    LSA_HANDLE                policy = NULL;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
     // Enumerate the privileges on this machine
         
   // arguments for LsaEnumeratePrivileges
   ULONG                         countOfRights;
   DWORD                         prefMax = 0xffffffff;
   LSA_ENUMERATION_HANDLE        handle = 0;
   POLICY_PRIVILEGE_DEFINITION * pRights = NULL;
   
   do 
   {
      if ( rc ) 
         break;
      rc = LsaEnumeratePrivileges(policy,&handle,(LPVOID*)&pRights,prefMax,&countOfRights);
      if ( rc ) 
      {
         rc = LsaNtStatusToWinError(rc);
         if ( rc == ERROR_NO_MORE_ITEMS )
            rc = 0;
         break;
      }
      if ( ! rc )
      {
         
         PrivNode          * p = NULL;

         for ( UINT right = 0 ;right < countOfRights ; right++ )
         {
            // Length is in bytes
            p = new PrivNode(pRights[right].Name.Buffer,pRights[right].Name.Length/2);
            
            priv.InsertPrivilege(p);
         }
         LsaFreeMemory(pRights);

         LSA_UNICODE_STRING      lsaRight;
         // For some reason, LsaEnumeratePrivileges doesn't return these rights
         // They are defined in "ntsecapi.h", and not with the rest of the privileges in "winnt.h"
         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_INTERACTIVE_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_NETWORK_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);

         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_BATCH_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }

         if ( ! rc )
         {
            InitLsaString(&lsaRight,SE_SERVICE_LOGON_NAME);
            p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
            priv.InsertPrivilege(p);
         }
       
         // Check the OS version on the server
         WKSTA_INFO_100       * pInfo;
         BOOL                   bIsWin2K = TRUE;
         DWORD                  rcInfo = NetWkstaGetInfo(server,100,(LPBYTE*)&pInfo);

          if ( ! rcInfo )
          {
            if ( pInfo->wki100_ver_major < 5 )
            {
               bIsWin2K = FALSE;
            }
            NetApiBufferFree(pInfo);
          }
         
         // The 4 "deny" rights are only defined on Windows 2000.
         if ( bIsWin2K )
         {
            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_INTERACTIVE_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_NETWORK_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);

            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_BATCH_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }

            if ( ! rc )
            {
               InitLsaString(&lsaRight,SE_DENY_SERVICE_LOGON_NAME);
               p = new PrivNode(lsaRight.Buffer,lsaRight.Length/2);
               priv.InsertPrivilege(p);
            }
         }
      }
      else
      {
         rc = LsaNtStatusToWinError(rc);
      }
   } while ( false);

   if ( policy )
   {
      LsaClose(policy);
   }
   // Build a safearray of BSTRs from the priv-list
   rc = SafeArrayFromPrivList(&priv,pRightsArray);
  
   hr = HRESULT_FROM_WIN32(rc);
   
   return hr;
}

STDMETHODIMP 
   CUserRights::GetUsersWithRight(
      BSTR                   server,      // in - computer name
      BSTR                   right,       // in - right to lookup
      SAFEARRAY           ** users        // out- list of accounts that hold right
  )
{
   DWORD                     rc = 0;
   LSA_UNICODE_STRING        Right;
   WCHAR                     strSid[LEN_SID];
   DWORD                     lenStrSid = DIM(strSid);
   PrivList                  plist;
   LSA_HANDLE                policy = NULL;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   
   // arguments for LsaEnumerateAccountsWithUserRight
   ULONG                         countOfUsers;
   LSA_ENUMERATION_INFORMATION * pInfo = NULL;
   
   InitLsaString(&Right,right);        
   
   rc = LsaEnumerateAccountsWithUserRight(policy,&Right,(PVOID*)&pInfo,&countOfUsers);

   if ( ! rc )
   {
      for ( UINT user = 0 ; user < countOfUsers ; user++ )
      {
         if ( ! pInfo[user].Sid )
         {
            continue; // something is wrong
         }
         
         GetTextualSid(pInfo[user].Sid,strSid,&lenStrSid);
         PrivNode             * p = new PrivNode(strSid,(USHORT) UStrLen(strSid));
         
         plist.InsertPrivilege(p);
      }
      LsaFreeMemory(pInfo);
   }
   else
   {
      rc = LsaNtStatusToWinError(rc);
      if ( rc == ERROR_NO_MORE_ITEMS )
         rc = 0;
   }
   if ( ! rc )
   {
      rc = SafeArrayFromPrivList(&plist,users);
   }
   if ( policy )
      LsaClose(policy);

   return HRESULT_FROM_WIN32(rc);
}

STDMETHODIMP 
   CUserRights::GetRightsOfUser(
      BSTR                   server,      // in - computer name
      BSTR                   strSid,      // in - textual sid for account
      SAFEARRAY           ** rights       // out- list of rights held by account on server
  )
{
   DWORD                     rc = 0;
   PSID                      pSid = SidFromString(strSid);
   LSA_HANDLE                policy = NULL;
   PrivList                  plist;
  
   rc = OpenPolicy(server,POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION,&policy);
   if ( ! rc )
   {
      rc = BuildPrivilegeList(policy,pSid,&plist);
      if ( ! rc )
      {
         rc = SafeArrayFromPrivList(&plist,rights);
      }
      LsaClose(policy);
   }

   return HRESULT_FROM_WIN32(rc);
}


//---------------------------------------------------------------------------
// AddUserRights Method
//
// Synopsis
// Add user rights for specified account.
//
// Arguments
// IN bstrServer - domain controller to perform operation on
// IN bstrSid    - SID of account
// IN psaRights  - list of rights
//
// Return
// Standard HRESULT error status.
//---------------------------------------------------------------------------

STDMETHODIMP CUserRights::AddUserRights(BSTR bstrServer, BSTR bstrSid, SAFEARRAY* psaRights)
{
    USES_CONVERSION;

    HRESULT hr;

    if ((bstrServer != NULL) && (bstrSid != NULL) && (psaRights != NULL))
    {
        PSID pSid = SidFromString(OLE2W(bstrSid));

        if (pSid != NULL)
        {
            hr = SetRights(OLE2W(bstrServer), pSid, psaRights, true);

            FreeSid(pSid);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//---------------------------------------------------------------------------
// RemoveUserRights Method
//
// Synopsis
// Remove user rights for specified account.
//
// Arguments
// IN bstrServer - domain controller to perform operation on
// IN bstrSid    - SID of account
// IN psaRights  - list of rights
//
// Return
// Standard HRESULT error status.
//---------------------------------------------------------------------------

STDMETHODIMP CUserRights::RemoveUserRights(BSTR bstrServer, BSTR bstrSid, SAFEARRAY* psaRights)
{
    USES_CONVERSION;

    HRESULT hr;

    if ((bstrServer != NULL) && (bstrSid != NULL) && (psaRights != NULL))
    {
        PSID pSid = SidFromString(OLE2W(bstrSid));

        if (pSid != NULL)
        {
            hr = SetRights(OLE2W(bstrServer), pSid, psaRights, false);

            FreeSid(pSid);
        }
        else
        {
            hr = E_INVALIDARG;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}


//---------------------------------------------------------------------------
// SetRights Method
//
// Synopsis
// Add or remove user rights for specified account.
//
// Arguments
// IN pszServer - domain controller to perform operation on
// IN pSid      - SID of account
// IN psaRights - list of rights
// IN bEnable   - whether to add or remove rights
//
// Return
// HRESULT error status.
//---------------------------------------------------------------------------

HRESULT CUserRights::SetRights(PWSTR pszServer, PSID pSid, SAFEARRAY* psaRights, bool bEnable)
{
    HRESULT hr = S_OK;

    //
    // Open LSA policy object on specified server with access required to add or remove rights.
    //

    LSA_HANDLE hPolicy = NULL;
    NTSTATUS ntsStatus = OpenPolicy(pszServer, POLICY_CREATE_ACCOUNT|POLICY_LOOKUP_NAMES, &hPolicy);

    if (ntsStatus == STATUS_SUCCESS)
    {
        //
        // Generate array of unicode strings from BSTR array.
        //

        BSTR* pbstrRight;
        hr = SafeArrayAccessData(psaRights, (void**)&pbstrRight);

        if (SUCCEEDED(hr))
        {
            ULONG ulCount = psaRights->rgsabound[0].cElements;

            if (ulCount > 0)
            {
                PLSA_UNICODE_STRING plsausRights = new LSA_UNICODE_STRING[ulCount];

                if (plsausRights)
                {
                    for (ULONG ulIndex = 0; ulIndex < ulCount; ulIndex++)
                    {
                        InitLsaString(&plsausRights[ulIndex], pbstrRight[ulIndex]);
                    }

                    //
                    // If not test mode, add or remove rights.
                    //

                    if (!m_bNoChange)
                    {
                        NTSTATUS ntsStatus;

                        if (bEnable)
                        {
                            ntsStatus = LsaAddAccountRights(hPolicy, pSid, plsausRights, ulCount);
                        }
                        else
                        {
                            ntsStatus = LsaRemoveAccountRights(hPolicy, pSid, FALSE, plsausRights, ulCount);
                        }

                        if (ntsStatus != STATUS_SUCCESS)
                        {
                            DWORD dwError = LsaNtStatusToWinError(ntsStatus);
                            hr = HRESULT_FROM_WIN32(dwError);
                        }
                    }

                    delete [] plsausRights;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }

            SafeArrayUnaccessData(psaRights);
        }

        LsaClose(hPolicy);
    }
    else
    {
        DWORD dwError = LsaNtStatusToWinError(ntsStatus);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\workobj.cpp ===
/*---------------------------------------------------------------------------
  File: WorkerObjects.cpp

  Comments: Library of COM objects to perform DCT tasks
  This file was mostly generated by the ATL wizard.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/// WorkerObjects.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for WorkerObjects.idl by adding the following 
//      files to the Outputs.
//          WorkerObjects_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f WorkerObjectsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "WorkObj.h"
#include "dlldatax.h"

#include "WorkObj_i.c"

#include "AcctRepl.h"
#include "PwdAge.h"
#include "Reboot.h"
#include "ChDom.h"
#include "Rename.h"
#include "StatObj.h"
#include "UserRts.h"
#include "SecTrans.h"
#include "Checker.h"
#include "PlugInfo.h"
#include "ResStr.h"

StringLoader gString;

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;


BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AcctRepl, CAcctRepl)
OBJECT_ENTRY(CLSID_ComputerPwdAge, CComputerPwdAge)
OBJECT_ENTRY(CLSID_RebootComputer, CRebootComputer)
OBJECT_ENTRY(CLSID_ChangeDomain, CChangeDomain)
OBJECT_ENTRY(CLSID_RenameComputer, CRenameComputer)
OBJECT_ENTRY(CLSID_StatusObj, CStatusObj)
OBJECT_ENTRY(CLSID_UserRights, CUserRights)
OBJECT_ENTRY(CLSID_SecTranslator, CSecTranslator)
OBJECT_ENTRY(CLSID_AccessChecker, CAccessChecker)
OBJECT_ENTRY(CLSID_PlugInInfo, CPlugInInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsDctWorkerObjects.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSDCTWORKEROBJECTSLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsDctWorkerObjects.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
		_Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\_entryid.h ===
/*
** --_entryid.h----------------------------------------------------------------
**
**  Header file describing internal structure of EntryIDs returned
**  by Exchange Address Book provider.
**
**
**  Copyright (c) Microsoft Corp. 1986-1996.  All Rights Reserved.
**
** ----------------------------------------------------------------------------
*/

#ifndef _ENTRYID_
#define _ENTRYID_

/*
 *  The version of this ABPs entryids
 */
#define EMS_VERSION         0x000000001

/*
 * The version of the entryids supported by the CreateEntry method in this 
 * ABP.
 */
#define NEW_OBJ_EID_VERSION 0x00000002

/*
 *  Valid values for the entry id's Type field are Mapi Display Types, plus:
 */
#define AB_DT_CONTAINER     0x000000100
#define AB_DT_TEMPLATE      0x000000101
#define AB_DT_OOUSER        0x000000102
#define AB_DT_SEARCH        0x000000200

/*
 *  The EMS ABPs MAPIUID
 *
 *  This MAPIUID must be unique (see the Service Provider Writer's Guide on
 *  Constructing Entry IDs)
 */
#define MUIDEMSAB {0xDC, 0xA7, 0x40, 0xC8, 0xC0, 0x42, 0x10, 0x1A, \
		       0xB4, 0xB9, 0x08, 0x00, 0x2B, 0x2F, 0xE1, 0x82}

/*
 *  Directory entry id structure
 *
 *  This entryid is permanent.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _dir_entryid
#else
typedef struct _dir_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
} DIR_ENTRYID, FAR * LPDIR_ENTRYID;

#define CBDIR_ENTRYID sizeof(DIR_ENTRYID)

/*
 *  Mail user entry id structure
 *
 *  This entryid is ephemeral.
 */
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_entryid
#else
typedef struct _usr_entryid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    DWORD dwEph;
} USR_ENTRYID, FAR * LPUSR_ENTRYID;

/*
 *  This entryid is permanent.
 */
/* turn off the warning for the unsized array */
#pragma warning (disable:4200)
#ifdef TEMPLATE_LCID
typedef UNALIGNED struct _usr_permid
#else
typedef struct _usr_permid
#endif
{
    BYTE abFlags[4];
    MAPIUID muid;
    ULONG ulVersion;
    ULONG ulType;
    char  szAddr[];
} USR_PERMID, FAR * LPUSR_PERMID;
#pragma warning (default:4200)

#define CBUSR_ENTRYID sizeof(USR_ENTRYID)
#define CBUSR_PERMID sizeof(USR_PERMID)

#define EPHEMERAL   (UCHAR)(~(  MAPI_NOTRECIP      \
                              | MAPI_THISSESSION   \
                              | MAPI_NOW           \
                              | MAPI_NOTRESERVED))


#endif  /* _ENTRYID_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\admt\workobj\usercopy.hpp ===
#ifndef __USERCOPY_HPP__
#define __USERCOPY_HPP__
//#pragma title("usercopy.hpp- class definitions for usercopy")
/*
================================================================================

   (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

 Program    - usercopy
 Class      - LAN Manager Utilities
 Author     - Christy Boles
 Created    - 09/04/97
 Description- class definitions to allow usercopy to process subsets of accounts.
              The list of accounts will be generated by the GUI, and will consist 
              of a TNodeList of TAcctNodes.  Users will be added from the front of 
              the list, and groups will be added at the end.


 Updates    - 01/30/98 CAB Added strong password generation


================================================================================
*/

#include <lmcons.h>

#include "TNode.hpp"
#include <share.h>              // for _SH_DENYNO
#include "EaLen.hpp"
#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "CommaLog.hpp"
#include "TARNode.hpp"
#include "WorkObj.h"
#include "ProcExts.h"
//#import  "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb"
#import  "DBMgr.tlb" no_namespace, named_guids
#import  "WorkObj.tlb"

#define AR_BUFSIZE        ((size_t)16000)
#define AR_NUM_IN_BUF 5000  

#define F_REPLACE             0x00000001  // replace account info
#define F_GROUP               0x00000002  // copy global groups
#define F_LGROUP              0x00000004  // copy local groups
#define F_USERS               0x00000008  // copy users
#define F_DISABLE_ALL         0x00000010  // disable all accounts
#define F_DISABLE_SPECIAL     0x00000020  // disable Account Ops, Backup Ops, Administrators, Domain Admins
#define F_STRONGPW_ALL        0x00000040  // generate strong passwords for all accounts
#define F_STRONGPW_SPECIAL    0x00000080  // generate strong passwords for Account Ops, Backup Ops, Admins, and Domain Admins
#define F_MACHINE             0x00000100  // copy computer accounts
#define F_REMOVE_OLD_MEMBERS  0x00000200  // remove old members from replaced groups
#define F_DISABLESOURCE       0x00000400  // disable copied user accounts on source domain
#define F_AddToSrcGroupLocal  0x00000800  // indicates that the add-to group is on the target domain
#define F_AddToGroupLocal     0x00001000  // add to group is a local group
#define F_INTERACT            0x00002000  // use command-line parms to initiate interactive gui session
#define F_WARN_FULLNAME       0x00004000  // warn before replacing accounts w/different fullname 
#define F_WARN_COMMENT        0x00008000  // warn before replacing accounts w/different comment
#define F_CopyPasswords       0x00010000  // copy passwords
#define F_RevokeOldRights     0x00020000  // removes old user rights from copied accounts
#define F_AddSidHistory       0x00040000  // Add SID of source account to the SID history of the target account.
#define F_TranslateProfiles   0x00080000  // Translate roaming profiles
#define F_OUS                 0x00100000  // Process the organizational units.
#define F_COMPUTERS           0x00200000  // Process the computer accounts in Acct replication
#define F_COPY_CONT_CONTENT   0x00400000  // Copy the container contents along with the container when copying accounts.
#define F_COPY_MIGRATED_ACCT  0x00800000  // When expanding containers/membership include accounts that have already been migrated.
#define F_MOVE_REPLACED_ACCT  0x01000000  // move a replaces account to the user-specified OU.
    
#define AR_AccountComputer    (0x80000000)
#define AR_AccountComputerPdc (0x40000000)


#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define DOMAIN_USERS       6
#define DOMAIN_CONTROLLERS 7
#define DOMAIN_COMPUTERS   8

struct AccountStats
{
   long                      users;
   long                      globals;
   long                      locals;
   long                      computers;
   long                      generic;
};

class TANode:public TNode
{
   BOOL           bMarked;
   PSID           pSid;
   WCHAR          name[LEN_Account];
   
public:
   TANode() { name[0] = 0; bMarked = FALSE; pSid = NULL;}
   TANode(WCHAR const * n)
   {
      safecopy(name,n);
      bMarked = FALSE;
      pSid = NULL;
   }
   ~TANode() 
   {
      if ( pSid )
         delete pSid;
   }
   BOOL     Marked() { return bMarked; }
   void     Mark() { bMarked = TRUE; }
   void     SetSid(PSID p) { pSid = p; }
   void     SetName(WCHAR const * n){ safecopy(name,n); }
   WCHAR  * GetName() { return name; }
   PSID     GetSid() { return pSid;}
};

// Password generation service
#define PWGEN_MIN_LENGTH    8    // enforced minimum password length
#define PWGEN_MAX_LENGTH   14    // enforced maximum password length

struct EaPwdFilterInfo
{
   DWORD                     bEnforce;
   DWORD                     bAllowName;
   DWORD                     minLower;
   DWORD                     minUpper;
   DWORD                     minDigits;
   DWORD                     minSpecial;
   DWORD                     maxConsecutiveAlpha;
};



struct Options
{
    WCHAR                     srcDomain[LEN_Domain];
    WCHAR                     srcDomainDns[LEN_Domain];
    WCHAR                     srcDomainFlat[LEN_Domain];
    WCHAR                     tgtDomain[LEN_Domain];
    WCHAR                     tgtDomainDns[LEN_Domain];
    WCHAR                     tgtDomainFlat[LEN_Domain];
    WCHAR                     srcComp[LEN_Account];     // source computername
    WCHAR                     srcCompDns[LEN_Account];  // DNS source computername
    WCHAR                     srcCompFlat[LEN_Account]; // flat source computername
    WCHAR                     tgtComp[LEN_Account];     // target computername
    WCHAR                     tgtCompDns[LEN_Account];  // DNS target computername
    WCHAR                     tgtCompFlat[LEN_Account]; // flat target computername
    PSID                      srcSid;
    PSID                      tgtSid;
    DWORD                     srcDomainVer;
    DWORD                     srcDomainVerMinor;
    DWORD                     tgtDomainVer;
    DWORD                     tgtDomainVerMinor;
    WCHAR                     prefix[UNLEN];     // prefix for added users
    WCHAR                     suffix[UNLEN];     // suffix for added users
    WCHAR                     globalPrefix[UNLEN];
    WCHAR                     globalSuffix[UNLEN];
    WCHAR                     addToGroup[GNLEN+1]; // optional group name to add new users to
    WCHAR                     addToGroupSource[GNLEN+1]; // optional group name to add source users to
    WCHAR                     logFile[MAX_PATH+1];
    EaPwdFilterInfo           policyInfo;
    DWORD                     minPwdLength;
    CommaDelimitedLog         passwordLog;
    DWORD                     flags;             // operation flags
    BOOL                      nochange;
    WCHAR					 authUser[UNLEN+1];	//User name for source authentication
    WCHAR					 authPassword[UNLEN+1];	//Password for Authentication.
    WCHAR					 authDomain[LEN_Domain+1];	// Domain for the user passed for authentication
    HANDLE					 dsBindHandle;	// Handle to the directory service. Should be init by DsBind.
    WCHAR                     srcNamingContext[LEN_Path]; // Naming context for the Adsi path
    WCHAR                     tgtNamingContext[LEN_Path]; // Naming context for the Target domain
    WCHAR                     tgtOUPath[LEN_Path];       // path for the OU container that is to be used to create objects in
    BOOL                      expandContainers;          // Whether or not we want to expand the containers.
    BOOL                      expandMemberOf;
    BOOL                      fixMembership;
    IIManageDB              * pDb;
    HRESULT                  openDBResult;
    BOOL                      bUndo;
    BOOL                      bSameForest;
    long                      lActionID;
    long                      lUndoActionID;
    MCSDCTWORKEROBJECTSLib::IStatusObjPtr             pStatus;
    WCHAR                     sDomUsers[UNLEN+1];               // Name of the domain users group in the source domain
    _bstr_t					 sExcSystemProps;                  // system properties to exclude from migration
    _bstr_t					 sExcUserProps;                    // user properties to exclude from migration
    _bstr_t					 sExcInetOrgPersonProps;           // InetOrgPerson properties to exclude from migration
    _bstr_t					 sExcGroupProps;                   // group properties to exclude from migration
    _bstr_t					 sExcCmpProps;                     // computer properties to exclude from migration
    BOOL						 bExcludeProps;
    _bstr_t					 sWizard;


    Options() {
        srcDomain[0] = 0;
        srcDomainDns[0] = 0;
        srcDomainFlat[0] = 0;
        tgtDomain[0] = 0;
        tgtDomainDns[0] = 0;
        tgtDomainFlat[0] = 0;
        srcComp[0] = 0;
        srcCompDns[0] = 0;
        srcCompFlat[0] = 0;
        tgtComp[0] = 0;
        tgtCompDns[0] = 0;
        tgtCompFlat[0] = 0;
        prefix[0] = 0;
        suffix[0] = 0;
        globalPrefix[0] = 0;
        globalSuffix[0] = 0;
        addToGroup[0] = 0;
        addToGroupSource[0] = 0;
        logFile[0] = 0;
        minPwdLength = 0;
        flags = 0;
        nochange = TRUE;
        authUser[0] = 0;
        authPassword[0] = 0;
        authDomain[0] = 0;
        srcNamingContext[0] = 0;
        tgtNamingContext[0] = 0;
        tgtOUPath[0] = 0;
        expandContainers = FALSE;
        fixMembership = TRUE;
        pDb = NULL;
        openDBResult = CoCreateInstance(CLSID_IManageDB,NULL,CLSCTX_ALL,IID_IIManageDB,(void**)&pDb);
        bUndo = FALSE;
        srcDomainVer = -1;
        srcDomainVerMinor = -1;
        tgtDomainVer = -1;
        tgtDomainVerMinor = -1;
        srcSid = NULL;
        tgtSid = NULL;
        lUndoActionID = 0;
        pStatus = NULL;
        bSameForest = FALSE;
        sDomUsers[0] = 0;
        bExcludeProps = FALSE;
    }
    ~Options()
    {
        if( pDb )
        {
            pDb->Release();
        }
        if ( srcSid )
            FreeSid(srcSid);
        if ( tgtSid )
            FreeSid(tgtSid);
    }
};


typedef void ProgressFn(WCHAR const * mesg);



int 
   UserCopy(
      Options              * options,       // in - options
      TNodeListSortable    * acctlist,      // in - list of accounts to process
      ProgressFn           * progress,      // in - function called to log current progress
      TError               & error,         // in - TError to write messages to      
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   fn (void ),    // in - window update function
      CProcessExtensions   * pExts          // in - pointer to extensions
  );


int 
   UserRename(
      Options              * options,      // in -options
      TNodeListSortable    * acctlist,     // in -list of accounts to process
      ProgressFn           * progress,     // in -window to write progress messages to
      TError               & error,        // in -window to write error messages to
      IStatusObj           * pStatus,      // in -status object to support cancellation
      void                   WindowUpdate (void )    // in - window update function
  );


bool AddSidHistory( 
		  const Options * pOptions,
		  const WCHAR   * strSrcPrincipal,
		  const WCHAR   * strDestPrincipal,
        IStatusObj       * pStatus = NULL,
        BOOL            isFatal = TRUE
		);

bool BindToDS( 
			Options * pOpt
		 );

bool AddToOU (
				  Options              * options,      // in -options
				  TNodeListSortable    * acctlist     // in -list of accounts to process
			 );

void MakeFullyQualifiedAdsPath(
                                             WCHAR * sPath,          //out- Fully qulified LDAP path to the object
											 DWORD	 nPathLen,		 //in - MAX size, in characters, of the sPath buffer
                                             WCHAR * sSubPath,       //in- LDAP subpath of the object
                                             WCHAR * tgtDomain,      //in- Domain name where object exists.
                                             WCHAR * sDN             //in- Deafault naming context for the Domain 
                                          );

void FillupNamingContext(Options * options);

bool IsAccountMigrated( 
                        TAcctReplNode * pNode,     //in -Account node that contains the Account info
                        Options       * pOptions,  //in -Options as specified by the user.
                        IIManageDBPtr   pDb,       //in -Pointer to DB manager. We dont want to create this object for every account we process
                        WCHAR         * sTgtSam    //in,out - Name of the target object that was copied if any.
                     );

bool CheckifAccountExists(
                        Options const* options,    //in-Options as set by the user
                        WCHAR * acctName           //in-Name of the account to look for
                     );

bool CallExtensions(
                     CProcessExtensions   * pExt,         // in - Extension handler.
                     Options              * options,      // in -options
                     TNodeListSortable    * acctlist,     //in -Accounts to be copied.
                     IStatusObj           * pStatus,      // in -status object to support cancellation
                     ProgressFn           * progress      //in- Progress function.
                   );

void
   CopyGlobalGroupMembers(
      Options const        * options      ,// in -options
      TAcctReplNode        * acct         ,// in -account to copy
      TNodeListSortable    * acctlist     ,// in -list of accounts being copied
      void                   WindowUpdate (void )    // in - window update function
   );

void
   CopyLocalGroupMembers(
      Options const        * options      ,// in -options
      TAcctReplNode        * acct         ,// in -account to copy
      TNodeListSortable    * acctlist     ,// in -list of accounts being copied
      void                   WindowUpdate (void )    // in - window update function
   );

HRESULT 
   CopySidHistoryProperty(
      Options              * pOptions,
      TAcctReplNode        * pNode,
      IStatusObj              * pStatus
   );

HRESULT
   __stdcall
   GetRidPoolAllocator(
      Options              * pOptions
   );

void Mark( _bstr_t sMark,   _bstr_t sObj);
void BatchMark(const EAMAccountStats& stats);

DWORD GetName(PSID pObjectSID, WCHAR * sNameAccount, WCHAR * sDomain);

typedef HRESULT (CALLBACK * ADSGETOBJECT)(LPWSTR, REFIID, void**);
extern ADSGETOBJECT            ADsGetObject;

#endif //__USERCOPY_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\coreutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// core utility functions
//
// 30 Nov 1999 sburns



#include "headers.hxx"



HINSTANCE
Burnslib::GetResourceModuleHandle()
{
   ASSERT(hResourceModuleHandle);

   return hResourceModuleHandle;
}



// Attempt to locate a message in a given module.  Return the message string
// if found, the empty string if not.
// 
// flags - FormatMessage flags to use
// 
// module - module handle of message dll to look in, or 0 to use the system
// message table.
// 
// code - message code to look for.  This could be an HRESULT, or a win32
// error code.

String
GetMessageHelper(DWORD flags, HMODULE module, DWORD code)
{
   // REVIEWED-2002/03/29-sburns no unbounded allocation error here.
   // If I pass nSize = 0 and FORMAT_MESSAGE_ALLOCATE_BUFFER in dwFlags,
   // the max result size is 32K - 1 characters.  Looking at the code in
   // message.c, it looks like the reserve space is whatever the user asked
   // as a maximum rounded up to the nearest 64K. That makes sense given my
   // test, since 32K chars = 64K bytes.  Experimentally, even if I ask for
   // a max buffer size > 0x87FFF chars, it looks like the most I can get
   // is 0x87FFE chars. 

   flags |= FORMAT_MESSAGE_ALLOCATE_BUFFER;
   String message;

   TCHAR* sysMessage = 0;
   DWORD result =
      ::FormatMessage(
         flags,
         module,
         code,
         0,
         reinterpret_cast<PTSTR>(&sysMessage),
         0,
         0);
   if (result)
   {
      ASSERT(sysMessage);
      if (sysMessage)
      {
         message = sysMessage;

         ASSERT(result == message.length());

         ::LocalFree(sysMessage);

         message.replace(L"\r\n", L" ");
      }
   }

   return message;
}



// Attempts to locate message strings for various facility codes in the
// HRESULT

String
Burnslib::GetErrorMessage(HRESULT hr)
{
   LOG_FUNCTION2(GetErrorMessage, String::format(L"%1!08X!", hr));

   if (!FAILED(hr) && hr != S_OK)
   {
      // no messages for success codes other than S_OK

      ASSERT(false);

      return String();
   }

   String message;

   // default is the system error message table

   HMODULE module = 0;

   do
   {
      WORD code = static_cast<WORD>(HRESULT_CODE(hr));
      if (code == -1)
      {
         // return "unknown" message

         break;
      }

      DWORD flags =
            FORMAT_MESSAGE_ALLOCATE_BUFFER
         |  FORMAT_MESSAGE_IGNORE_INSERTS
         |  FORMAT_MESSAGE_FROM_SYSTEM;

      if (!HRESULT_FACILITY(hr) && (code >= 0x5000 && code <= 0x50FF))
      {
         // It's an ADSI error

         flags |= FORMAT_MESSAGE_FROM_HMODULE;

         module =
            ::LoadLibraryEx(
               L"activeds.dll",
               0,
               LOAD_LIBRARY_AS_DATAFILE | DONT_RESOLVE_DLL_REFERENCES);
         if (!module)
         {
            // return "unknown" message

            LOG_HRESULT(Win32ToHresult(::GetLastError()));

            break;
         }
      }

      // try FormatMessage with the full HRESULT first

      message = GetMessageHelper(flags, module, hr);

      if (message.empty())
      {
         // try again with just the error code

         message = GetMessageHelper(flags, module, code);
      }
   }
   while (0);

   if (message.empty())
   {
      message = String::load(IDS_UNKNOWN_ERROR_CODE);
   }

   if (module)
   {
      BOOL unused = ::FreeLibrary(module);

      ASSERT(unused);
   }

   return message.strip(String::BOTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\assert.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// ASSERT macro
//
// 3 Mar 2000 sburns



#include "headers.hxx"



int
AddStackTraceLine(
   DWORD64 traceAddress,
   char*   buffer,
   size_t  bufferMax)
{
   if (!buffer || ! traceAddress || !bufferMax)
   {
      return 0;
   }

   char      ansiSymbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
   char      ansiModule[Burnslib::StackTrace::MODULE_NAME_MAX];
   char      ansiSource[MAX_PATH];                           
   DWORD64   displacement = 0;
   DWORD     line         = 0;

   // REVIEWED-2002/03/05-sburns correct byte counts passed.
   
   ::ZeroMemory(ansiSymbol, Burnslib::StackTrace::SYMBOL_NAME_MAX);
   ::ZeroMemory(ansiModule, Burnslib::StackTrace::MODULE_NAME_MAX);
   ::ZeroMemory(ansiSource, MAX_PATH);                             

   Burnslib::StackTrace::LookupAddress(
      traceAddress,
      ansiModule,
      0,
      ansiSymbol,
      &displacement,
      &line,
      ansiSource);

   return 

      // ISSUE-2002/03/05-sburns consider strsafe.h replacement
      
      _snprintf(
         buffer,
         bufferMax,
         " %016I64X %s%!%s+0x%I64X %s (%d)\n",
         traceAddress,
         ansiModule,
         ansiSymbol,
         displacement,
         ansiSource,
         line);
}



bool
Burnslib::FireAssertionFailure(const char* file, int line, const char* expr)
{
   //
   // DON'T CALL ASSERT() IN THIS FUNCTION! 
   //
   // also don't call new, or any other code that could call ASSERT.

   bool result = false;

   char processName[128];
   char* pProcessName = processName;

   if (!::GetModuleFileNameA(0, processName, 128))
   {
      pProcessName = "Unknown";
   }

   static const int MAX_MSG = 2047;

   // NTRAID#NTBUG9-541418-2002/03/28-sburns
   
   char details[MAX_MSG + 1];

   // REVIEWED-2002/03/05-sburns correct byte count passed.
   
   ::ZeroMemory(details, MAX_MSG + 1);
   
   DWORD tid = ::GetCurrentThreadId();
   DWORD pid = ::GetCurrentProcessId();

   int used = 

      // ISSUE-2002/03/05-sburns consider strsafe.h replacement

      _snprintf(
         details,

         // reserve space so that we can guarantee null-termination
         
         MAX_MSG - 1,
         " Expression: %s \n"
         "\n"
         " File   \t : %s \n"
         " Line   \t : %d \n"
//         " Module \t : %s \n"
         " Process\t : 0x%X (%d) %s\n"
         " Thread \t : 0x%X (%d)\n"
         "\n"
         " Click Retry to debug.\n"
         "\n",
         expr,
         file,
         line,
//          pModuleName,
         pid,
         pid,
         pProcessName,
         tid,
         tid);
   if (used < 0)
   {
      // ISSUE-2002/03/05-sburns consider strsafe.h replacement, use 'n'
      // variant

      strcpy(details, "details too detailed.\n");
   }
   else
   {
      // grab a stack trace

      static const size_t TRACE_MAX = 10;
      DWORD64 stackTrace[TRACE_MAX];

      Burnslib::StackTrace::Trace(stackTrace, TRACE_MAX);

      // build a stack trace dump

      // skip the first entry, which corresponds to this function, so that
      // the dump reflects the call stack at the point of assertion failure.
      // so there will be at most TRACE_MAX - 1 lines output.

      for (int i = 1; stackTrace[i] && i < TRACE_MAX; ++i)
      {
         int used2 =
            AddStackTraceLine(
               stackTrace[i],
               details + used,
               MAX_MSG - used);

         if (used2 < 0)
         {
            break;
         }

         used += used2;
      }
   }

   static const char* TITLE = "Assertion Failed!";
   ::OutputDebugStringA(TITLE);
   ::OutputDebugStringA("\n");
   ::OutputDebugStringA(details);

   switch (
      ::MessageBoxA(
         0,
         details,
         TITLE,
            MB_SETFOREGROUND                       

         // ICONHAND + SYSTEMMODAL gets us the special low-memory
         // message box.
         // NTRAID#NTBUG9-556530-2002/03/28-sburns
         
         |  MB_ICONHAND
         |  MB_SYSTEMMODAL
         
         |  MB_ABORTRETRYIGNORE))
   {
      case IDABORT:
      {
         _exit(3);
      }
      case IDRETRY:
      {
         // user wants to drop into the debugger.
         
         result = true;
         break;
      }
      case IDIGNORE:
      case IDCANCEL:
      default:
      {
         // do nothing
         break;
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\heap.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)



#include "headers.hxx"


//
// Debug and Retail build
//



static const int RES_STRING_SIZE = 512;
static TCHAR LOW_MEMORY_MESSAGE[RES_STRING_SIZE];
static TCHAR LOW_MEMORY_TITLE[RES_STRING_SIZE];

// we declare a static instance of bad_alloc so that the loader allocates
// space for it.  Otherwise, we'd have to allocate an instance during failure
// of operator new, which we obviously can't do, since we're out-of-memory at
// that point.

static const std::bad_alloc nomem;



// Called when OperatorNew cannot satisfy an allocation request.
//
// Brings up a dialog to inform the user to free up some memory then retry the
// allocation, or cancel.  The dialog can appear in low-memory conditions.
//
// Returns IDRETRY if the allocation should be re-attempted, IDCANCEL
// otherwise.  Returns IDCANCEL if the module resource handle has not been
// set (see burnslib.hpp).

int
DoLowMemoryDialog()
{
   static bool initialized = false;

   if (!initialized)
   {
      HINSTANCE hinstance = GetResourceModuleHandle();
      if (!hinstance)
      {
         // DLL/WinMain has not set the handle.  So just throw.

         return IDCANCEL;
      }

      // This will work, even in low memory, as it just returns a pointer
      // to the string in the exe image.

      int result1 =

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         ::LoadString(
            hinstance,
            IDS_LOW_MEMORY_MESSAGE,
            LOW_MEMORY_MESSAGE,
            RES_STRING_SIZE);

      int result2 =

         // REVIEWED-2002/03/06-sburns correct character count passed
      
         ::LoadString(
            hinstance,
            IDS_LOW_MEMORY_TITLE,
            LOW_MEMORY_TITLE,
            RES_STRING_SIZE);
      if (result1 && result2)
      {
         initialized = true;
      }
   }

   return
      ::MessageBox(
         ::GetDesktopWindow(),
         LOW_MEMORY_MESSAGE,
         LOW_MEMORY_TITLE,

         // ICONHAND + SYSTEMMODAL gets us the special low-memory
         // message box.

         MB_RETRYCANCEL | MB_ICONHAND | MB_SYSTEMMODAL);
}



// Include the code for the debug or retail variations of the replacement
// operator new and delete

#ifdef DBG

   // debug code

   #include "heapdbg.cpp"

#else

   // retail code

   #include "heapretl.cpp"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\heapdbg.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)
//
// This file is #include'd from mem.cpp
// DO NOT include in the sources file list
//
// this is the checked (debug) version:



#ifndef DBG
   #error This file must be compiled with the DBG symbol defined
#endif



static const int   TRACE_MAX              = 10;        
static const DWORD SAFETY_FILL            = 0xDEADDEAD;
static const DWORD DEFAULT_HEAP_FLAGS     = 0;         
static const DWORD HEAP_TRACE_ALLOCATIONS = (1 << 0);
static       DWORD heapFlags              = 0;



struct AllocationPrefix
{
   LONG    serialNumber;
   DWORD   status;
   DWORD64 stackTrace[TRACE_MAX];
   DWORD   safetyFill;

   // status bitmasks

   static const DWORD STATUS_REPORTED_LEAKED = 0x00000001;
};


// ISSUE-2002/03/06-sburns consider replacing this with the strsafe equivalent.

inline
void
SafeStrncat(char* dest, const char* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      // ISSUE-2002/03/06-sburns consider strsafe function
      
      strncat(dest, src, bufmax - strlen(dest) - 1);
   }
}



// ISSUE-2002/03/06-sburns consider replacing this with the strsafe equivalent.

inline
void
SafeStrncat(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   ASSERT(dest && src);

   if (dest && src)
   {
      // ISSUE-2002/03/06-sburns consider strsafe functions

      wcsncat(dest, src, bufmax - wcslen(dest) - 1);
   }
}



// ISSUE-2002/03/06-sburns consider replacing this with the strsafe equivalent.

// strncpy that will not overflow the buffer.

inline
void
SafeStrncpy(wchar_t* dest, const wchar_t* src, size_t bufmax)
{
   ::ZeroMemory(dest, bufmax * sizeof wchar_t);

   // ISSUE-2002/03/06-sburns consider strsafe functions

   wcsncpy(dest, src, bufmax - 1);
}




void
ReadHeapFlags()
{
   // don't call new in this routine, it may be called as a result of doing
   // a stack trace as part of OperatorNew

   do
   {
      wchar_t keyname[MAX_PATH];

      // ISSUE-2002/03/06-sburns replace these with strsafe calls
      
      SafeStrncpy(keyname, REG_ADMIN_RUNTIME_OPTIONS, MAX_PATH);
      SafeStrncat(keyname, RUNTIME_NAME, MAX_PATH);
         
      HKEY hKey = 0;
      LONG result =
         ::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            keyname,
            0,
            0,
            REG_OPTION_NON_VOLATILE,

            // ISSUE-2002/03/06-sburns this is too much permission
            
            KEY_ALL_ACCESS,
            0,
            &hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      static const wchar_t* HEAP_FLAG_VALUE_NAME = L"HeapFlags";

      DWORD dataSize = sizeof(heapFlags);
      result =

         // REVIEWED-2002/03/06-sburns no null termination issue here
         
         ::RegQueryValueEx(
            hKey,
            HEAP_FLAG_VALUE_NAME,
            0,
            0,
            reinterpret_cast<BYTE*>(&heapFlags),
            &dataSize);
      if (result != ERROR_SUCCESS)
      {
         heapFlags = DEFAULT_HEAP_FLAGS;

         // create the value for convenience

         result =
            
            // REVIEWED-2002/03/06-sburns no null termination issue here

            ::RegSetValueEx(
               hKey,
               HEAP_FLAG_VALUE_NAME,
               0,
               REG_DWORD,
               reinterpret_cast<BYTE*>(&heapFlags),
               dataSize);
         ASSERT(result == ERROR_SUCCESS);
      }

      ::RegCloseKey(hKey);
   }
   while (0);
}



void
Burnslib::Heap::Initialize()
{
   ReadHeapFlags();

   // You should pass -D_DEBUG to the compiler to get this extra heap
   // checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
   // in your build environment)

   _CrtSetDbgFlag(
      0
//      |  _CRTDBG_CHECK_ALWAYS_DF       // check heap every allocation
      |  _CRTDBG_ALLOC_MEM_DF          // use debug heap allocator
      |  _CRTDBG_DELAY_FREE_MEM_DF);   // delay free: helps find overwrites
}



bool
ShouldTraceAllocations()
{
   return (heapFlags & HEAP_TRACE_ALLOCATIONS) ? true : false;
}



// The debug version of myOperatorNew/Delete prepends the allocation with an
// array to hold the stack backtrace at the point this function is called.  If
// the stack trace debugging option is active, then this stack trace array is
// filled in.  Then, upon termination, that array is used to dump the stack
// trace of any allocation that has not been freed.

void*
Burnslib::Heap::OperatorNew(
   size_t      size,

#ifdef _DEBUG

   // these are only used when DEBUG_CRTS=1

   const char* file,
   int         line
#else
   const char* /* file */ ,
   int         /* line */ 
#endif

)
throw (std::bad_alloc)
{
   static LONG allocationNumber = 0;

   AllocationPrefix* ptr = 0;

   for (;;)
   {
      // NOTE: if some other user of the CRT has used _set_new_mode or
      // _CrtSetAllocHook, then they may circumvent our careful arrangement
      // and hose us.  The really sad part is that the only way to prevent
      // that problem is for us to not use any CRT heap functions.

      size_t mallocSize = sizeof(AllocationPrefix) + size;

      ptr =

#ifdef _DEBUG            

         reinterpret_cast<AllocationPrefix*>(
            _malloc_dbg(
               mallocSize,
               _CLIENT_BLOCK,
               file,
               line));
#else
         reinterpret_cast<AllocationPrefix*>(malloc(mallocSize));
#endif

      if (ptr)
      {
         break;
      }

      // the allocation failed.  Give the user the opportunity to try to
      // free some, or throw an exception.
      if (DoLowMemoryDialog() == IDRETRY)
      {
         continue;
      }

      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"  myOperatorNew: user opted to throw bad_alloc\n");

      throw nomem;
   }

   ptr->serialNumber = allocationNumber;
   ::InterlockedIncrement(&allocationNumber);

   ptr->status = 0;

   // REVIEWED-2002/03/07-sburns correct byte count passed
   
   ::ZeroMemory(ptr->stackTrace, TRACE_MAX * sizeof DWORD64);

   if (ShouldTraceAllocations())
   {
      Burnslib::StackTrace::Trace(ptr->stackTrace, TRACE_MAX);
   }

   ptr->safetyFill = SAFETY_FILL;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   memset(ptr + 1, 0xFF, size);

   // return the address of the byte just beyond the prefix
   return reinterpret_cast<void*>(ptr + 1);
}



void
Burnslib::Heap::OperatorDelete(void* ptr)
throw ()
{
   if (ptr)
   {
      // note that ptr will be the address of the byte just after the prefix,
      // so we need to back up to include the prefix.

      AllocationPrefix* realptr = reinterpret_cast<AllocationPrefix*>(ptr) - 1;
      ASSERT(realptr->safetyFill == SAFETY_FILL);

      _free_dbg(realptr, _CLIENT_BLOCK);
   }
}



// This bit is cleared on allocation, and set on leak report.  This is to
// handle the case that more than 1 module (say an exe and a dll) link with
// blcore.
// 
// In that situation, each module's allocations are made from a
// common crt heap, but there are two static copies of the Burnslib::Heap code
// -- one per module.   This means the leak dumper will run twice over the
// same heap.
// 
// If the leak is in a dll, then dumped, then the dll is unloaded, when the
// same leak is dumped by the exe, the dll static data which includes the
// filename of the code that leaked will no longer be available, and the dump
// code will throw an exception.  Then, the crt will catch the exception, and
// call the leak dumper routine.  The routine checks the "already reported"
// bit and emits a message to ignore the second report.
// 
// We could eliminate the second report entirely if _CrtDoForAllClientObjects
// weren't broken.

void
leakDumper(void* ptr, void*)
{
   AllocationPrefix* prefix     = reinterpret_cast<AllocationPrefix*>(ptr);
   DWORD64*          stackTrace = prefix->stackTrace;                      
   LONG              serial     = prefix->serialNumber;
   DWORD&            status     = prefix->status;

   static const int BUF_MAX = MAX_PATH * 2;
   char output[BUF_MAX];
   char buf[BUF_MAX];

   // REVIEWED-2002/03/06-sburns correct byte count passed.
   
   ::ZeroMemory(output, BUF_MAX);
   SafeStrncat(output, "allocation ", BUF_MAX);

   // REVIEWED-2002/03/06-sburns correct byte count passed.

   ::ZeroMemory(buf, BUF_MAX);

   // REVIEWED-2002/03/06-sburns sufficient buffer space for result
   
   _ltoa(serial, buf, 10);
   
   SafeStrncat(output, buf, BUF_MAX);

   SafeStrncat(output, "\r\n", BUF_MAX);
   ::OutputDebugStringA(output);

   if (status & AllocationPrefix::STATUS_REPORTED_LEAKED)
   {
      ::OutputDebugString(
         L"NOTE: this allocation has already been reported as a leak.");
   }

   for (int i = 0; i < TRACE_MAX; i++)
   {
      if (!stackTrace[i])
      {
         break;
      }

      char      symbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
      char      image[MAX_PATH];                              
      char      module[Burnslib::StackTrace::MODULE_NAME_MAX];
      char      fullpath[MAX_PATH];                           
      DWORD64   displacement = 0;
      DWORD     line         = 0;

      // REVIEWED-2002/03/06-sburns correct byte counts passed
      
      ::ZeroMemory(symbol,   Burnslib::StackTrace::SYMBOL_NAME_MAX);
      ::ZeroMemory(image,    MAX_PATH);                             
      ::ZeroMemory(module,   Burnslib::StackTrace::MODULE_NAME_MAX);
      ::ZeroMemory(fullpath, MAX_PATH);                             

      Burnslib::StackTrace::LookupAddress(
         stackTrace[i],
         module,
         image,
         symbol,
         &displacement,
         &line,
         fullpath);

      // REVIEWED-2002/03/06-sburns correct byte count passed.
      
      ::ZeroMemory(output, BUF_MAX);
      SafeStrncat(output, "   ", BUF_MAX);
      SafeStrncat(output, module, BUF_MAX);
      SafeStrncat(output, "!", BUF_MAX);
      SafeStrncat(output, symbol, BUF_MAX);
      SafeStrncat(output, "+0x", BUF_MAX);

      // REVIEWED-2002/03/06-sburns correct byte count passed.
   
      ::ZeroMemory(buf, BUF_MAX);

      // ISSUE-2002/03/06-sburns consider strsafe function
      
      sprintf(buf, "%I64X", displacement);
      SafeStrncat(output, buf, BUF_MAX);

      if (line)
      {
         SafeStrncat(output, " line ", BUF_MAX);

         // REVIEWED-2002/03/06-sburns correct byte count passed.
      
         ::ZeroMemory(buf, BUF_MAX);

         // REVIEWED-2002/03/06-sburns sufficient buffer space for result
         
         _ultoa(line, buf, 10);
         SafeStrncat(output, buf, BUF_MAX);
      }

      SafeStrncat(output, "   ", BUF_MAX);
      ::OutputDebugStringA(output);

      // REVIEWED-2002/03/06-sburns correct byte count passed.
      
      ::ZeroMemory(output, BUF_MAX);

      if (strlen(fullpath))
      {
         SafeStrncat(output, fullpath, BUF_MAX);
      }

      SafeStrncat(output, "\r\n", BUF_MAX);
      ::OutputDebugStringA(output);
   }

   status = status | AllocationPrefix::STATUS_REPORTED_LEAKED;
}



void __cdecl
leakDumper2(void* ptr, size_t)
{
   leakDumper(ptr, 0);
}



void
Burnslib::Heap::DumpMemoryLeaks()
{

#ifdef _DEBUG
   
   _CrtMemState heapState;

   _CrtMemCheckpoint(&heapState);

   if (heapState.lCounts[_CLIENT_BLOCK] != 0)
   {
      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"   dumping leaked CLIENT blocks -- "
         L"Only blocks with type CLIENT are actual leaks\r\n");
      _CrtSetDumpClient(leakDumper2);

   //   _CrtDoForAllClientObjects(leakDumper, 0);  // ideal, but broken

      _CrtMemDumpAllObjectsSince(0);
   }

#endif   // _DEBUG

}



#ifdef _DEBUG

Burnslib::Heap::Frame::Frame(const wchar_t* file_, unsigned line_)
   :
   file(file_),
   line(line_)
{
   LOG(
      String::format(
         L"Heap frame opened at %1, line %2!d!",
         file,
         line));

   _CrtMemCheckpoint(&checkpoint);
}



Burnslib::Heap::Frame::~Frame()
{
   LOG(
      String::format(
         L"Dumping alloations for HeapFrame opened at %1, line %2!d!",
         file,
         line));

   _CrtMemDumpAllObjectsSince(&checkpoint);

   file = 0;

   LOG(L"Heap frame closed");
}

#endif   // _DEBUG






// // log this allocation to disk, along with a stack trace.  We write directly
// // to a separate log file instead of using LOG() because LOG() makes
// // (many) heap allocations, which would result in an infinite loop.
// //
// // CODEWORK: unfortunately, one effect of this is that LOG() adds white
// // noise to the allocation log.
// //
//
// void
// logAllocation(long requestNumber, size_t dataSize, const char* file, int line)
// {
//    static HANDLE logfile = 0;
//
//    if (!logfile)
//    {
//       do
//       {
//          TCHAR buf[MAX_PATH + 1];
//          memset(buf, 0, sizeof(TCHAR) * (MAX_PATH + 1));
//
//          UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
//          if (result == 0 || result > MAX_PATH)
//          {
//             break;
//          }
//
//          _tcsncat(buf, L"\\debug\\alloc.log", MAX_PATH - result);
//
//          DWORD attrs = ::GetFileAttributes(buf);
//          if (attrs != -1)
//          {
//             // file already exists.  Delete it.
//             if (!::DeleteFile(buf))
//             {
//                break;
//             }
//          }
//
//          logfile =
//             ::CreateFile(
//                buf,
//                GENERIC_READ | GENERIC_WRITE,
//                FILE_SHARE_READ | FILE_SHARE_WRITE,
//                0,
//                OPEN_ALWAYS,
//                FILE_ATTRIBUTE_NORMAL,
//                0);
//       }
//       while (0);
//    }
//
//    if (logfile && logfile != INVALID_HANDLE_VALUE)
//    {
//       // we write the log in ascii
//       static const int BUF_MAX = MAX_PATH * 2;
//       char output[BUF_MAX];
//       char buf[BUF_MAX];
//       memset(output, 0, BUF_MAX);
//       memset(buf, 0, BUF_MAX);
//
//       _ltoa(requestNumber, output, 10);
//       SafeStrncat(output, "\r\n   ", BUF_MAX);
//
//       SafeStrncat(output, file ? file : "<no file>", BUF_MAX);
//
//       if (line)
//       {
//          _ltoa(line, buf, 10);
//          SafeStrncat(output, " line ", BUF_MAX);
//          SafeStrncat(output, buf, BUF_MAX);
//       }
//       else
//       {
//          SafeStrncat(output, " <no line>", BUF_MAX);
//       }
//
//       SafeStrncat(output, "\r\n", BUF_MAX);
//
//       DWORD bytesWritten = 0;
//       ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//
//       static const int TRACE_MAX = 20;
//       DWORD stackTrace[TRACE_MAX];
//       GetStackTrace(stackTrace, TRACE_MAX);
//
//       for (int i = 0; i < TRACE_MAX; i++)
//       {
//          if (stackTrace[i])
//          {
//             char  symbol[SYMBOL_NAME_MAX];
//             char  image[MAX_PATH];
//             char  module[MODULE_NAME_MAX];
//             char  fullpath[MAX_PATH];
//             DWORD displacement = 0;
//             DWORD line = 0;
//
//             memset(symbol, 0, SYMBOL_NAME_MAX);
//             memset(image, 0, MAX_PATH);
//             memset(module, 0, MODULE_NAME_MAX);
//             memset(fullpath, 0, MAX_PATH);
//
//             LookupStackTraceSymbol(
//                stackTrace[i],
//                module,
//                image,
//                symbol,
//                &displacement,
//                &line,
//                fullpath);
//
//             memset(output, 0, BUF_MAX);
//             SafeStrncat(output, "   ", BUF_MAX);
//             SafeStrncat(output, module, BUF_MAX);
//             SafeStrncat(output, "!", BUF_MAX);
//             SafeStrncat(output, symbol, BUF_MAX);
//             SafeStrncat(output, "+0x", BUF_MAX);
//
//             memset(buf, 0, BUF_MAX);
//             _ltoa(displacement, buf, 16);
//             SafeStrncat(output, buf, BUF_MAX);
//
//             if (line)
//             {
//                SafeStrncat(output, " line ", BUF_MAX);
//                memset(buf, 0, BUF_MAX);
//                _ltoa(line, buf, 10);
//                SafeStrncat(output, buf, BUF_MAX);
//             }
//
//             SafeStrncat(output, "   ", BUF_MAX);
//             ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//
//             memset(output, 0, BUF_MAX);
//
//             if (strlen(fullpath))
//             {
//                SafeStrncat(output, fullpath, BUF_MAX);
//             }
//
//             SafeStrncat(output, "\r\n", BUF_MAX);
//             ::WriteFile(logfile, output, strlen(output), &bytesWritten, 0);
//          }
//       }
//    }
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\init.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Initialization stuff
// 
// 9-25-97 sburns



#include "headers.hxx"



unsigned Burnslib::InitializationGuard::counter = 0;
const wchar_t* REG_ADMIN_RUNTIME_OPTIONS = 0;


Burnslib::InitializationGuard::InitializationGuard()
{
   if (!counter)
   {
      REG_ADMIN_RUNTIME_OPTIONS =
         L"Software\\Microsoft\\Windows\\CurrentVersion\\AdminDebug\\";

      // cause assertion failures to appear in the debugger and the UI

      _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_WNDW | _CRTDBG_MODE_DEBUG);

      Heap::Initialize();
   }

   counter++;
}



Burnslib::InitializationGuard::~InitializationGuard()
{
   if (--counter == 0)
   {

#ifdef LOGGING_BUILD
      Log::Cleanup();
#endif

      // we have to dump leaks ourselves, as the CRT explicitly disables the
      // client dump function before it dumps leaks (if you set the
      // _CRTDBG_LEAK_CHECK_DF flag).  The downside is that we will also see
      // normal blocks that were allocated during static initialization.

      // You should pass -D_DEBUG to the compiler to get this extra heap
      // checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
      // in your build environment)

      Heap::DumpMemoryLeaks();

      // this must come after the leak dump, as the leak dump resolves symbols

      StackTrace::Cleanup();
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\heapretl.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 22-Nov-1999 sburns (refactored)
//
// This file is #include'd from mem.cpp
// DO NOT include in the sources file list
//
// this is the retail version:



#ifdef DBG
   #error This file must NOT be compiled with the DBG symbol defined
#endif



//
// Retail build only
//



void
Burnslib::Heap::Initialize()
{
   // we do not make available instrumented heap in retail builds, so there
   // is nothing to do here.
}



void*
Burnslib::Heap::OperatorNew(
   size_t      size,
   const char* /* file */ ,
   int         /* line */ )
throw (std::bad_alloc)
{
   void* ptr = 0;

   for (;;)
   {
      // NOTE: if some other user of the CRT has used _set_new_mode or
      // _CrtSetAllocHook, then they may circumvent our careful arrangement
      // and hose us.  The really sad part is that the only way to prevent
      // that problem is for us to not use any CRT heap functions.

      ptr = malloc(size);

      if (ptr)
      {
         break;
      }

      // the allocation failed.  Give the user the opportunity to try to
      // free some, or throw an exception.

      if (DoLowMemoryDialog() == IDRETRY)
      {
         continue;
      }

      ::OutputDebugString(RUNTIME_NAME);
      ::OutputDebugString(
         L"  Burnslib::Heap::OperatorNew: user opted to throw bad_alloc\n");

      throw nomem;
   }

   return ptr;
}



void
Burnslib::Heap::OperatorDelete(void* ptr)
throw ()
{
   free(ptr);
}



void
Burnslib::Heap::DumpMemoryLeaks()
{
   // does nothing in the retail (free) build.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\log.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Debugging tools
//
// 8-13-97 sburns




#include "headers.hxx"



#ifdef LOGGING_BUILD



//
// Logging build only
//



static Burnslib::Log* logInstance = 0;

// # of spaces per indentation level

static const int TAB = 2;



Burnslib::Log*
Burnslib::Log::GetInstance()
{
   do
   {
      if (!logInstance)
      {
         static bool initialized = false;

         if (initialized)
         {
            ASSERT(false);
            break;
         }

         // this might fail with a thrown exception if Log::Log can't
         // init it's critical section.  In that case, we can't allocate
         // an instance.  We don't handle that exception, but let it
         // propagate to the caller

         // ISSUE-2002/03/06-sburns we should handle the exception and
         // leave the log uninitialized
               
         logInstance = new Burnslib::Log(RUNTIME_NAME);
         initialized = true;
      }
   }
   while (0);

   return logInstance;
}



// read the debugging options from the registry

void
Burnslib::Log::ReadLogFlags()
{
   do
   {
      static String keyname =
         String(REG_ADMIN_RUNTIME_OPTIONS) + RUNTIME_NAME;
         
      HKEY hKey = 0;
      LONG result =
         ::RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            keyname.c_str(),
            0,
            0,
            REG_OPTION_NON_VOLATILE,

            // ISSUE-2002/03/05-sburns should be KEY_SET_VALUE | KEY_READ
            
            KEY_ALL_ACCESS,

            // ISSUE-2002/03/05-sburns should set a restrictive ACL here
            // see NTRAID#NTBUG9-535841-2002/03/05-sburns
            
            0,
            &hKey,
            0);
      if (result != ERROR_SUCCESS)
      {
         break;
      }

      static const wchar_t* FLAG_VALUE_NAME = L"LogFlags";

      DWORD dataSize = sizeof(flags);

      // REVIEWED-2002/03/05-sburns no null-termination issue here
      
      result =
         ::RegQueryValueEx(
            hKey,
            FLAG_VALUE_NAME,
            0,
            0,
            reinterpret_cast<BYTE*>(&flags),
            &dataSize);
      if (result != ERROR_SUCCESS)
      {
         flags = DEFAULT_LOGGING_OPTIONS;

         // create the value for convenience

         result =

         // REVIEWED-2002/03/05-sburns no null-termination issue here
         
            ::RegSetValueEx(
               hKey,
               FLAG_VALUE_NAME,
               0,
               REG_DWORD,
               reinterpret_cast<BYTE*>(&flags),
               dataSize);
      }

      ::RegCloseKey(hKey);
   }
   while (0);
}



Burnslib::Log::~Log()
{
   WriteLn(Burnslib::Log::OUTPUT_LOGS, L"closing log");

   ::DeleteCriticalSection(&critsec);

   ::TlsFree(logfileMarginTlsIndex);

   if (IsOpen())
   {
      ::CloseHandle(fileHandle);
      fileHandle = INVALID_HANDLE_VALUE;

      ::CloseHandle(spewviewHandle);
      spewviewHandle = INVALID_HANDLE_VALUE;
   }
}



void
Burnslib::Log::Cleanup()
{
   delete logInstance;
   logInstance = 0;
}



// Returns the string name of the platform

String
OsName(OSVERSIONINFO& info)
{
   switch (info.dwPlatformId)
   {
      case VER_PLATFORM_WIN32s:
      {
         return L"Win32s on Windows 3.1";
      }
      case VER_PLATFORM_WIN32_WINDOWS:
      {
         switch (info.dwMinorVersion)
         {
            case 0:
            {
               return L"Windows 95";
            }
            case 1:
            {
               return L"Windows 98";
            }
            default:
            {
               return L"Windows 9X";
            }
         }
      }
      case VER_PLATFORM_WIN32_NT:
      {
         return L"Windows NT";
      }
      // case VER_PLATFORM_WIN32_CE:
      // {
      //    return L"Windows CE";
      // }
      default:
      {
         ASSERT(false);
         break;
      }
   }

   return L"Some Unknown Windows Version";
}



// locate the log file with the highest-numbered extension, then add 1 and
// return the result.

int
DetermineNextLogNumber(const String& logDir, const String& logBaseName)
{
   ASSERT(!logDir.empty());
   ASSERT(!logBaseName.empty());

   int largest = 0;

   String filespec = logDir + L"\\" + logBaseName + L".*.log";

   WIN32_FIND_DATA findData;
   HANDLE ff = ::FindFirstFile(filespec.c_str(), &findData);

   if (ff != INVALID_HANDLE_VALUE)
   {
      for (;;)
      {
         String current = findData.cFileName;

         // grab the text between the dots: "nnn" in foo.nnn.ext

         // first dot

         size_t pos = current.find(L".");
         if (pos == String::npos)
         {
            continue;
         }

         String extension = current.substr(pos + 1);

         // second dot

         pos = extension.find(L".");
         if (pos == String::npos)
         {
            continue;
         }
   
         extension = extension.substr(0, pos);

         int i = 0;
         extension.convert(i);
         largest = max(i, largest);

         if (!::FindNextFile(ff, &findData))
         {
            BOOL success = ::FindClose(ff);
            ASSERT(success);

            break;
         }
      }
   }

   // roll over after 255
   
   return (++largest & 0xFF);
}



// Writes the Unicode BOM to the first two bytes of the
// file specified by handle

HRESULT
WriteUnicodeBOMToFile(HANDLE handle)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;
   
   static const int BYTES_TO_WRITE = 2;
   BYTE buffer[BYTES_TO_WRITE];
   buffer[0] = 0xFF;
   buffer[1] = 0xFE;

   DWORD numberOfBytesWritten = 0;
   BOOL succeeded =
      ::WriteFile(
         handle,
         buffer,
         BYTES_TO_WRITE,
         &numberOfBytesWritten,
         0);
   if (!succeeded)
   {
      hr = HRESULT_FROM_WIN32(::GetLastError());
   }

   ASSERT(SUCCEEDED(hr));
   ASSERT(numberOfBytesWritten == BYTES_TO_WRITE);

   return hr;
}



HANDLE
OpenLogFile(const String& logName)
{
   HANDLE result =
      ::CreateFile(
         logName.c_str(),

         // ISSUE-2002/03/06-sburns don't need read, do we?
         
         GENERIC_READ | GENERIC_WRITE,

         // Leave shared read so that we can look at the file while the
         // program is still running.
         
         FILE_SHARE_READ,
         0,
         OPEN_ALWAYS,
         FILE_ATTRIBUTE_NORMAL,
         0);

   // don't assert that the create worked: the current user may not have
   // rights to open the log file.

   if (result != INVALID_HANDLE_VALUE)
   {
      LARGE_INTEGER li;
      LARGE_INTEGER newpos;

      // REVIEWED-2002/03/06-sburns correct byte counts passed
      
      ::ZeroMemory(&li,     sizeof li);    
      ::ZeroMemory(&newpos, sizeof newpos);

      BOOL success = ::SetFilePointerEx(result, li, &newpos, FILE_END);
      ASSERT(success);

      // NTRAID#NTBUG9-494875-2001/11/14-JeffJon
      // If the newpos is at the beginning of the file, this means
      // its a new file and we should write the Unicode BOM so
      // that apps know the file is in Unicode.

      if (newpos.QuadPart == 0)
      {
         HRESULT unused = WriteUnicodeBOMToFile(result);
         ASSERT(SUCCEEDED(unused));
      }
   }

   return result;
}



// Determine the name of the log file.  If a log file of that name already
// exists, rename the existing file to a numbered backup.  Create the new
// log file, return a handle to it.

HANDLE
OpenNewLogFile(const String& logBaseName, String& logName)
{
   wchar_t buf[MAX_PATH + 2];

   ::ZeroMemory(buf, (MAX_PATH + 2) * sizeof wchar_t);
   
   // +1 per MSDN docs.
   // NTRAID#NTBUG9-550315-2002/03/28-sburns
   
   UINT err = ::GetSystemWindowsDirectory(buf, MAX_PATH + 1);
   ASSERT(err != 0 && err <= MAX_PATH);

   String logDir = String(buf) + L"\\debug";
   logName = logDir + L"\\" + logBaseName + L".log";

   if (::GetFileAttributes(logName.c_str()) != 0xFFFFFFFF)
   {
      // file already exists.  rename the existing file

      int logNumber = DetermineNextLogNumber(logDir, logBaseName);
      String newName =
            logDir
         +  L"\\"
         +  logBaseName
         +  String::format(L".%1!03d!.log", logNumber);

      if (::GetFileAttributes(newName.c_str()) != 0xFFFFFFFF)
      {
         // could exist, as the log numbers roll over

         BOOL success = ::DeleteFile(newName.c_str());
         ASSERT(success);
      }

      // Don't assert that the move is successful.  The user may not have
      // rights to rename the file.  If this is the case, then we will attempt
      // to re-open the old log file and append to it.

      // REVIEWED-2002/03/06-sburns keeping the same ACLs as the source
      // is what we want
                                                         
      ::MoveFile(logName.c_str(), newName.c_str());
   }

   HANDLE result = OpenLogFile(logName);

   return result;
}



// Opens the specified log file or creates one if it doesn't
// already exist.

HANDLE
AppendLogFile(const String& logBaseName, String& logName)
{
   wchar_t buf[MAX_PATH + 1];

   UINT err = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(err != 0 && err <= MAX_PATH);

   String logDir = String(buf) + L"\\debug";
   logName = logDir + L"\\" + logBaseName + L".log";

   return OpenLogFile(logName);
}





// This wrapper function required to make prefast shut up.

void
ExceptionPropagatingInitializeCriticalSection(LPCRITICAL_SECTION critsec)
{
   __try
   {
      // REVIEWED-2002/03/06-sburns propagating the exception that might
      // occur in low memory is what we want.
      
      ::InitializeCriticalSection(critsec);
   }

   // propagate the exception to our caller.  This will cause Log::Log
   // to abort prematurely, and jump to the handler in Log::GetInstance
      
   __except (EXCEPTION_CONTINUE_SEARCH)
   {
   }
}
   
   

// Create a new log.
//
// logBaseName - base name of the log.  If logging-to-file is active, then a
// file in the %windir%\debug folder will be created/used.  The name of the
// file is of the form %windir%\debug\logBaseName.log.  If a file by that name
// already exists, then the existing file will be renamed
// %windir%\debug\logBaseName.xxx.log, where xxx is an integer 1 greater than
// the last so-numbered file in that directory.

Burnslib::Log::Log(const String& logBaseName)
   :
   baseName(logBaseName),
   fileHandle(INVALID_HANDLE_VALUE),
   flags(0),
   spewviewHandle(INVALID_HANDLE_VALUE),
   spewviewPipeName(),
   traceLineNumber(0),
   logfileMarginTlsIndex(0)
{
   ASSERT(!logBaseName.empty());

   ReadLogFlags();

   ExceptionPropagatingInitializeCriticalSection(&critsec);

   // create thread-local storage for per-thread debugging state.  We keep
   // the output margin in the slot.

   logfileMarginTlsIndex = ::TlsAlloc();
   ASSERT(logfileMarginTlsIndex != 0xFFFFFFFF);

   // spewview setup is done on-demand in WriteLn, so that spewview will
   // be used as soon as the server sets up the connection.

   if (ShouldLogToFile())
   {
      String logName;
      fileHandle = OpenNewLogFile(logBaseName, logName);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(L"opening log file %1", logName.c_str()));
   }
   else if (ShouldAppendLogToFile())
   {
      String logName;
      fileHandle = AppendLogFile(logBaseName, logName);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(L"appending to log file %1", logName.c_str()));
   }

   WriteHeader();
}



void
Burnslib::Log::WriteHeaderModule(HMODULE moduleHandle)
{
   do
   {
      wchar_t filename[MAX_PATH + 1];

      // REVIEWED-2002/03/06-sburns correct byte count passed.
      
      ::ZeroMemory(filename, sizeof filename);

      // ISSUE-2002/03/06-sburns This call is problematic for large paths:
      // it may truncate the result
      
      if (::GetModuleFileNameW(moduleHandle, filename, MAX_PATH) == 0)
      {
         break;
      }

      WriteLn(Burnslib::Log::OUTPUT_HEADER, filename);

      // add the timestamp of the file

      WIN32_FILE_ATTRIBUTE_DATA attr;

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(&attr, sizeof attr);
      
      if (
         ::GetFileAttributesEx(
            filename,
            GetFileExInfoStandard,
            &attr) == 0)
      {
         break;
      }

      FILETIME localtime;
      ::FileTimeToLocalFileTime(&attr.ftLastWriteTime, &localtime);
      SYSTEMTIME systime;
      ::FileTimeToSystemTime(&localtime, &systime);

      WriteLn(
         Burnslib::Log::OUTPUT_HEADER,
         String::format(
            L"file timestamp %1!02u!/%2!02u!/%3!04u! "

            // NTRAID#NTBUG9-550381-2002/03/05-sburns
            
            L"%4!02u!:%5!02u!:%6!02u!.%7!03u!", 
            systime.wMonth,
            systime.wDay,
            systime.wYear,
            systime.wHour,
            systime.wMinute,
            systime.wSecond,
            systime.wMilliseconds));
   }
   while (0);
}



void
Burnslib::Log::WriteHeader()
{
   // Log the name and timestamp of the file that created the process.

   WriteHeaderModule(0);

   // Log the name and timestamp of the file that corresponds to the
   // resource module handle, if there is one.

   if (hResourceModuleHandle)
   {
      WriteHeaderModule(hResourceModuleHandle);
   }

   SYSTEMTIME localtime;
   ::GetLocalTime(&localtime);
   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"local time %1!02u!/%2!02u!/%3!04u! "

         // NTRAID#NTBUG9-550381-2002/03/05-sburns
         
         L"%4!02u!:%5!02u!:%6!02u!.%7!03u!",
         localtime.wMonth,
         localtime.wDay,
         localtime.wYear,
         localtime.wHour,
         localtime.wMinute,
         localtime.wSecond,
         localtime.wMilliseconds));

   OSVERSIONINFO info;
   info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

   BOOL success = ::GetVersionEx(&info);
   ASSERT(success);

   // Get the whistler build lab version

   String labInfo;
   do
   {
      HKEY key = 0;
      LONG err =
         ::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"Software\\Microsoft\\Windows NT\\CurrentVersion",
            0,
            KEY_READ,
            &key);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      wchar_t buf[MAX_PATH + 1];

      // REVIEWED-2002/03/12-sburns correct byte count passed.
      
      ::ZeroMemory(buf, sizeof buf);
      
      DWORD type = 0;

      // -2 to guarantee terminating null
      // NTRAID#NTBUG9-541959-2002/03/12-sburns
      
      DWORD bufSize = sizeof(buf) - 2;

      err =
         ::RegQueryValueEx(
            key,
            L"BuildLab",
            0,
            &type,
            reinterpret_cast<BYTE*>(buf),

            // REVIEWED-2002/03/12-sburns correct byte count passed.
            
            &bufSize);
      if (err != ERROR_SUCCESS)
      {
         break;
      }

      labInfo = buf;
   }
   while (0);

   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"running %1 %2!d!.%3!d! build %4!d! %5 (BuildLab:%6) "

#if defined(_M_IX86)
         L"i386",

#elif defined(_M_AMD64)
         L"amd64",

#elif defined(_M_IA64)
         L"ia64",

#else
   #error( "unknown target machine" );
#endif

         OsName(info).c_str(),
         info.dwMajorVersion,
         info.dwMinorVersion,
         info.dwBuildNumber,
         info.szCSDVersion,
         labInfo.c_str()));

   WriteLn(
      Burnslib::Log::OUTPUT_HEADER,
      String::format(
         L"logging flags %1!08X!",
         flags));
}



HRESULT
Log::AdjustLogMargin(int delta)
{
   // extract the current value in this thread's slot

   HRESULT hr = S_OK;   
   do
   {
      PVOID margin = ::TlsGetValue(logfileMarginTlsIndex);
      if (!margin)
      {
         DWORD err = ::GetLastError();
         if (err != NO_ERROR)
         {
            hr = HRESULT_FROM_WIN32(err);
            break;
         }
      }

      // indent by adding to the margin

      ULONG_PTR marginTemp = reinterpret_cast<ULONG_PTR>(margin);

      // marginTemp will always be >= 0, as it is unsigned.

      marginTemp += delta;

      margin = reinterpret_cast<PVOID>(marginTemp);

      // save the new margin in this thread's slot

      BOOL succeeded = ::TlsSetValue(logfileMarginTlsIndex, margin);
      if (!succeeded)
      {
         DWORD lastErr = ::GetLastError();
         hr = HRESULT_FROM_WIN32(lastErr);
         break;
      }
   }
   while (0);

   return hr;
}



// guarded by caller

void
Burnslib::Log::Indent()
{
   HRESULT hr = AdjustLogMargin(TAB);
   ASSERT(SUCCEEDED(hr));
}



// guarded by caller

void
Burnslib::Log::Outdent()
{
   HRESULT hr = AdjustLogMargin(-TAB);
   ASSERT(SUCCEEDED(hr));
}



size_t
Burnslib::Log::GetLogMargin()
{
   PVOID margin = ::TlsGetValue(logfileMarginTlsIndex);
   if (!margin)
   {
      DWORD err = ::GetLastError();
      if (err != NO_ERROR)
      {
         ASSERT(false);
         return 0;
      }
   }

   return   
      static_cast<size_t>(
         reinterpret_cast<ULONG_PTR>(margin));
}



// I've commented out the spewview stuff because it's so rarely used.
// 
// // Examine the registry key for the name of the pipe, append our debugging
// // baseName to make it specific to this binary, and return the result.  Return
// // an empty string on error (most likely cause: the registry keys are not yet
// // present)
// // 
// // baseName - the logfile base name used to identify this binary.
// 
// String
// DetermineSpewviewPipeName(const String& baseName)
// {
//    String result;
// 
//    do
//    {
//       HKEY key = 0;
//       LONG err =
//          ::RegOpenKeyEx(
//             HKEY_LOCAL_MACHINE,
//             (String(REG_ADMIN_RUNTIME_OPTIONS) + L"Spewview\\" + baseName).c_str(),
//             0,
//             KEY_READ,
//             &key);
//       if (err != ERROR_SUCCESS)
//       {
//          break;
//       }
// 
//       wchar_t buf[MAX_PATH + 1];
// 
//       // REVIEWED-2002/03/12-sburns correct byte count passed.
//       
//       ::ZeroMemory(buf, sizeof buf);
//       
//       DWORD type = 0;
// 
//       // -2 to guarantee terminating null
//       // NTRAID#NTBUG9-541959-2002/03/12-sburns
//       
//       DWORD bufSize = sizeof(buf) - 2;
// 
//       err =
//          ::RegQueryValueEx(
//             key,
//             L"Server",
//             0,
//             &type,
//             reinterpret_cast<BYTE*>(buf),
// 
//             // REVIEWED-2002/03/12-sburns correct byte count passed.
//             
//             &bufSize);
//       if (err != ERROR_SUCCESS)
//       {
//          break;
//       }
// 
//       result = 
//             L"\\\\"
//          +  String(buf)
//          +  L"\\pipe\\spewview\\"
//          +  baseName;
//    }
//    while (0);
// 
//    return result;
// }
// 
// 
// 
// // Attempts to connect to the spewview application that is running elsewhere.
// // Sets the spewviewHandle parameter to a valid handle on success, or
// // INVALID_HANDLE_VALUE on error.
// //
// // baseName - the logfile base name used to identify this binary.
// //
// // spewviewPipeName - if empty, set to the name of the pipe.  If not empty,
// // used as the name of the pipe that the handle will be opened on.
// //
// // spewviewHandle - handle to the named pipe that spewage will be written to.
// // On success, this is set to a valid handle.  On failure, this is set to
// // INVALID_HANDLE_VALUE.
// 
// void
// AttemptConnectToSpewPipe(
//    const String&  baseName,
//    String&        spewviewPipeName,
//    HANDLE&        spewviewHandle)
// {
//    ASSERT(!baseName.empty());
//    ASSERT(spewviewHandle == INVALID_HANDLE_VALUE);
// 
//    spewviewHandle = INVALID_HANDLE_VALUE;
// 
//    // only attempt to determine the pipe name as long as we haven't been
//    // successful determining it so far.
// 
//    if (spewviewPipeName.empty())
//    {
//       spewviewPipeName = DetermineSpewviewPipeName(baseName);
//    }
// 
//    do
//    {
//       // wait a very short time for the pipe to become available
// 
//       BOOL err = ::WaitNamedPipe(spewviewPipeName.c_str(), 500);
//       if (!err)
//       {
//          // pipe not available
// 
//          // DWORD lastErr = ::GetLastError();
// 
//          break;
//       }
// 
//       spewviewHandle =
//          ::CreateFile(
//             spewviewPipeName.c_str(),
//             GENERIC_WRITE,
//             0,
//             0,
//             OPEN_EXISTING,
//             FILE_ATTRIBUTE_NORMAL,
//             0);
// 
//       if (spewviewHandle == INVALID_HANDLE_VALUE)
//       {
//          // DWORD lastErr = ::GetLastError();
// 
//          break;
//       }
//    }
//    while (0);
// 
//    return;
// }



String
Burnslib::Log::ComposeSpewLine(const String& text)
{
   // This needs to be a wchar_t*, not a String, as this function will be
   // called by Log::~Log, which is called when the process is being cleaned
   // up.  Part of the cleanup is to delete all static objects created since
   // the program started, in reverse order of construction.  This includes
   // the InitializationGuard instances.
   //
   // The final invocation of the Initialization dtor will cause the single
   // Log instance to be deleted, which will log a message, which will call
   // this routine, so SPEW_FMT better still exist. If SPEW_FMT were an
   // object, it would be instanciated after the InitializationGuard objects,
   // and destroyed before them, and so would not exist at that point.
   //
   // (you may rightly suspect that I discovered this after I had declared
   // SPEW_FMT a String instance.)

   static const wchar_t* SPEW_FMT = 
      L"%1 "         // base name
      L"%2!03X!."    // process id
      L"%3!03X! "    // thread id
      L"%4!04X! "    // spew line number
      L"%5"          // time of day
      L"%6"          // run time (time since process start)
      L"%7"          // margin whitespace
      L"%8"          // text
      L"\r\n";

   size_t margin = GetLogMargin();
   String white(margin, L' ');

   String tod;
   if (ShouldLogTimeOfDay())
   {
      SYSTEMTIME localtime;
      ::GetLocalTime(&localtime);

      tod = 
         String::format(
            L"%1!02u!:%2!02u!:%3!02u!.%4!03u! ",
            localtime.wHour,
            localtime.wMinute,
            localtime.wSecond,
            localtime.wMilliseconds);
   }

   String rt;
   if (ShouldLogRunTime())
   {
      static DWORD MILLIS_PER_SECOND = 1000;
      static DWORD MILLIS_PER_MINUTE = 60000;
      static DWORD MILLIS_PER_HOUR   = 3600000;
      static DWORD MILLIS_PER_DAY    = 86400000;

      DWORD tics = ::GetTickCount();

      unsigned days = tics / MILLIS_PER_DAY;
      tics -= days * MILLIS_PER_DAY;

      unsigned hours = tics / MILLIS_PER_HOUR;
      tics -= hours * MILLIS_PER_HOUR;

      unsigned minutes = tics / MILLIS_PER_MINUTE;
      tics -= minutes * MILLIS_PER_MINUTE;

      unsigned seconds = tics / MILLIS_PER_SECOND;
      tics -= seconds * MILLIS_PER_SECOND;

      rt =
         String::format(
            L"%1!02u!:%2!02u!:%3!02u!:%4!02u!.%5!04u! ",
            days,
            hours,
            minutes,
            seconds,
            tics);
   }

   String t =
      String::format(
         SPEW_FMT,
         RUNTIME_NAME,
         ::GetCurrentProcessId(),
         ::GetCurrentThreadId(),
         traceLineNumber,
         tod.c_str(),
         rt.c_str(),
         white.c_str(),
         text.c_str() );

   return t;
}



// Spews output to the log according to the current logging type and
// output options in effect.
//
// type - log output type of this output spewage.
//
// text - the spewage.  This is prefaced with the log name, thread id, spewage
// line number, and current indentation.

void
Burnslib::Log::UnguardedWriteLn(DWORD type, const String& text)
{
   // guarded by caller

   // CODEWORK: could circumvent this with a registry change notification
   // (re-read only if changed)

   // ReadLogFlags();

   if (
         !ShouldLogToFile()
      && !ShouldLogToDebugger()
      && !ShouldLogToSpewView() )
   {
      // nothing to do

      return;
   }

   if (type & DebugType())
   {
      String t = ComposeSpewLine(text);

      if (ShouldLogToDebugger())
      {
         ::OutputDebugString(t.c_str());
      }

      if (ShouldLogToFile())
      {
         if (IsOpen())
         {
            // write disk output as unicode text.

            DWORD bytesToWrite =
               static_cast<DWORD>(t.length() * sizeof(wchar_t));
            DWORD bytesWritten = 0;
            
            BOOL success =

               // REVIEWED-2002/03/06-sburns correct byte count passed
               
               ::WriteFile(
                  fileHandle,
                  reinterpret_cast<void*>(const_cast<wchar_t*>(t.data())),
                  bytesToWrite,
                  &bytesWritten,
                  0);

            // NTRAID#NTBUG9-465946-2001/09/10-sburns
            // ASSERT(success);

#ifdef DBG
            if (success)
            {
               ASSERT(bytesToWrite == bytesWritten);
            }
#endif
            
         }
      }


// I've commented out the spewview stuff because it's so rarely used.
//       if (ShouldLogToSpewView())
//       {
//          if (spewviewHandle == INVALID_HANDLE_VALUE)
//          {
//             AttemptConnectToSpewPipe(
//                baseName,
//                spewviewPipeName,
//                spewviewHandle);
//          }
// 
//          if (spewviewHandle != INVALID_HANDLE_VALUE)
//          {
//             // the connect attempt worked, and we have a valid handle.
//                
//             DWORD bytesToWrite =
//                static_cast<DWORD>(t.length() * sizeof(wchar_t));
//             DWORD bytesWritten = 0;
// 
//             BOOL result =
//                ::WriteFile(
//                   spewviewHandle,
//                   t.c_str(),
//                   bytesToWrite,
//                   &bytesWritten,
//                   0);
//             if (!result)
//             {
//                // write failed, so disconnect.  On the next call to this
//                // function, we will attempt to reconnect.
// 
//                ::CloseHandle(spewviewHandle);
//                spewviewHandle = INVALID_HANDLE_VALUE;
//             }
//          }
//       }

      ++traceLineNumber;
   }
}



void
Burnslib::Log::WriteLn(
   WORD           type,
   const String&  text)
{
   ::EnterCriticalSection(&critsec);
   UnguardedWriteLn(type, text);
   ::LeaveCriticalSection(&critsec);
}



Burnslib::Log::ScopeTracer::ScopeTracer(
   DWORD          type_,
   const String&  message_)
   :
   message(message_),
   type(type_)
{
   // build this string once, instead of using the string literal in the
   // below expression (which would implicitly build the string on each
   // evaluation of that expression) as a slight performance gain.

   static const String ENTER(L"Enter ");

   Burnslib::Log* li = Burnslib::Log::GetInstance();

   ASSERT(li);

   if (!li)
   {
      return;
   }

   if (type & li->DebugType())
   {
      ::EnterCriticalSection(&li->critsec);

      li->UnguardedWriteLn(type, ENTER + message);
      li->Indent();

      ::LeaveCriticalSection(&li->critsec);
   }
}



Burnslib::Log::ScopeTracer::~ScopeTracer()
{
   // build this string once, instead of using the string literal in the
   // below expression (which would implicitly build the string on each
   // evaluation of that expression) as a slight performance gain.

   static const String EXIT(L"Exit  ");

   Burnslib::Log* li = Burnslib::Log::GetInstance();

   ASSERT(li);

   if (!li)
   {
      return;
   }

   DWORD dt = li->DebugType();
   if ((type & dt))
   {
      ::EnterCriticalSection(&li->critsec);

      li->Outdent();

      if (OUTPUT_SCOPE_EXIT & dt)
      {
         li->UnguardedWriteLn(type, EXIT + message);
      }

      ::LeaveCriticalSection(&li->critsec);
   }
}



#endif   // LOGGING_BUILD
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\sources.inc ===
TARGETPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETLIBPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

UMTYPE=windows
C_DEFINES = -DUNICODE -D_UNICODE

# USE_MSVCRT or USE_LIBCMT is set in the subordinate sources files

USE_NATIVE_EH=1
USE_RTTI=1
USE_STD=1
USE_STL=1

PRECOMPILED_INCLUDE=..\headers.hxx
PRECOMPILED_CXX=1

INCLUDES=..\;$(PROJECT_ROOT)\burnslib\inc;$(NET_INC_PATH)

BLCORE_BASE_NAME=blcore

SOURCES= \
	..\Assert.cpp	\
	..\coreutil.cpp \
	..\init.cpp     \
	..\log.cpp      \
	..\heap.cpp     \
	..\stacktr.cpp  \
	..\string.cpp   \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-assert.cpp ===
// test Burnslib ASSERT macro



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
f3()
{
   LOG_FUNCTION(f3);

   LOG_LAST_WINERROR();

   {
      LOG_SCOPE(L"nested scope");
   }

   class Foo
   {
      public:

      Foo()
      {
         LOG_CTOR(Foo);
      }

      ~Foo()
      {
         LOG_DTOR(Foo);
      }

      void
      Method()
      {
         LOG_FUNCTION(Foo::Method);

         ASSERT(false);
      }
   };

   Foo afoo;
   afoo.Method();
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the games begin");

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-heap.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



// set the HeapFlags to trace allocations to see the leak detection

void
f3()
{
   LOG_FUNCTION(f3);

   int* leak4 = new int[2];
   leak4[0] = 1;
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   String* leak3 = new String;
   *leak3 = L"jello";

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   char* leak1 = new char[100];
   leak1[0] = 'S';

   f2();

   char* leak2 = new char[45];
   leak2[0] = 'B';
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the leaks begin");

   f1();

   wchar_t* leak5 = new wchar_t;
   *leak5 = L'X';

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\stacktr.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// stack backtracing stuff
//
// 22-Nov-1999 sburns (refactored)



#include "headers.hxx"
#include <strsafe.h>



// prevent us from calling ASSERT in this file: use RTLASSERT instead

#ifdef ASSERT
#undef ASSERT
#endif


// Since we call some of this code from Burnslib::FireAssertionFailure,
// we use our own even more private ASSERT

#if DBG

#define RTLASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else
#define RTLASSERT( exp )
#endif // DBG



static HMODULE  imageHelpDll = 0;              



// function pointers to be dynamically resolved by the Initialize function.

typedef DWORD (*SymSetOptionsFunc)(DWORD);
static SymSetOptionsFunc MySymSetOptions = 0;

typedef BOOL (*SymInitializeFunc)(HANDLE, PSTR, BOOL);
static SymInitializeFunc MySymInitialize = 0;

typedef BOOL (*SymCleanupFunc)(HANDLE);
static SymCleanupFunc MySymCleanup = 0;

typedef BOOL (*SymGetModuleInfoFunc)(HANDLE, DWORD64, PIMAGEHLP_MODULE64);
static SymGetModuleInfoFunc MySymGetModuleInfo = 0;

typedef BOOL (*SymGetLineFromAddrFunc)(HANDLE, DWORD64, PDWORD, PIMAGEHLP_LINE64);
static SymGetLineFromAddrFunc MySymGetLineFromAddr = 0;

typedef BOOL (*StackWalkFunc)(
   DWORD, HANDLE, HANDLE, LPSTACKFRAME64, PVOID,
   PREAD_PROCESS_MEMORY_ROUTINE64, PFUNCTION_TABLE_ACCESS_ROUTINE64,
   PGET_MODULE_BASE_ROUTINE64, PTRANSLATE_ADDRESS_ROUTINE64);
static StackWalkFunc MyStackWalk = 0;

typedef BOOL (*SymGetSymFromAddrFunc)(
   HANDLE, DWORD64, PDWORD64, PIMAGEHLP_SYMBOL64);
static SymGetSymFromAddrFunc MySymGetSymFromAddr = 0;

typedef PVOID (*SymFunctionTableAccess64Func)(HANDLE, DWORD64);
static SymFunctionTableAccess64Func MySymFunctionTableAccess64 = 0;

typedef DWORD64 (*SymGetModuleBase64Func)(HANDLE, DWORD64);
static SymGetModuleBase64Func MySymGetModuleBase64 = 0;


namespace Burnslib
{

namespace StackTrace
{
   // This must be called before any of the other functions in this
   // namespace

   void
   Initialize();

   bool
   IsInitialized()
   {
      return imageHelpDll != 0;
   }
}

}  // namespace Burnslib



// Determines the path to the parent folder of the binary from whence this
// process was loaded.
//
// returns 0 on failure.
//
// Caller needs to free the result with delete[].

char*
GetModuleFolderPath()
{
   HRESULT hr = S_OK;
   char* result = 0;

   do
   {
      result = new char[MAX_PATH + 1];
      ::ZeroMemory(result, MAX_PATH + 1);

      char tempBuf[MAX_PATH + 1] = {0};
   
      DWORD res = ::GetModuleFileNameA(0, tempBuf, MAX_PATH);
      if (res != 0)
      {
         char driveBuf[_MAX_DRIVE] = {0};
         char folderBuf[_MAX_DIR]  = {0};

         _splitpath(tempBuf, driveBuf, folderBuf, 0, 0);

         char* end1 = 0;
         hr = StringCchCatExA(result, MAX_PATH, driveBuf, &end1, 0, 0);
         BREAK_ON_FAILED_HRESULT(hr);

         RTLASSERT(end1 < result + MAX_PATH);

         char* end2 = 0;
         hr = StringCchCatExA(result, MAX_PATH, folderBuf, &end2, 0, 0);
         BREAK_ON_FAILED_HRESULT(hr);

         RTLASSERT(end2 < result + MAX_PATH);

         if (end2 - end1 > 1 && *(end2 - 1) == '\\')
         {
            // the folder is not the root folder, which means it also has a
            // trailing \ which we want to remove
            
            *(end2 - 1) = 0;
         }
      }
      else
      {
         hr = HRESULT_FROM_WIN32(::GetLastError());
      }
   }
   while (0);

   if (FAILED(hr))
   {
      delete[] result;
      result = 0;
   }

   return result;
}



// Expands an environment variable.  Returns 0 on error.  Caller must free
// the result with delete[]

char*
ExpandEnvironmentVar(const char* var)
{
   RTLASSERT(var);
   RTLASSERT(*var);

   // determine the length of the expanded string
   
   DWORD len = ::ExpandEnvironmentStringsA(var, 0, 0);
   RTLASSERT(len);

   if (!len)
   {
      return 0;
   }

   char* result = new char[len + 1];

   // REVIEWED-2002/03/14-sburns correct byte count passed
   
   ::ZeroMemory(result, len + 1);

   DWORD len1 =
      ::ExpandEnvironmentStringsA(
         var,
         result,

         // REVIEWED-2002/03/14-sburns correct character count passed
         
         len);
   RTLASSERT(len1 + 1 == len);

   if (!len1)
   {
      delete[] result;
      return 0;
   }

   return result;
}

   


void
InitHelper()
{
   // we want to look for symbols first in the folder the app started from,
   // then on %_NT_SYMBOL_PATH%;%_NT_ALTERNATE_SYMBOL_PATH%;

   // MAX_PATH * 3 for load + sym + alt sym, + 2 for semis, and +1 for null
   
   static const size_t PATH_BUF_SIZE = MAX_PATH * 3 + 2 + 1;
   char* symSearchPath = new char[PATH_BUF_SIZE];

   // REVIEWED-2002/03/14-sburns correct byte count passed
   
   ::ZeroMemory(symSearchPath, PATH_BUF_SIZE);

   HRESULT hr = S_OK;
   do
   {
      char* moduleFolderPath = GetModuleFolderPath();
      char* end = 0;
      hr =
         StringCchCatExA(
            symSearchPath,

            // -1 to make sure that there's space for a semi at the end

            PATH_BUF_SIZE - 1,
            moduleFolderPath,
            &end,
            0,
            STRSAFE_IGNORE_NULLS);

      delete[] moduleFolderPath;

      BREAK_ON_FAILED_HRESULT(hr);

      // Since we know there will be space for it, just poke in a semi

      *end = ';';

      char* env = ExpandEnvironmentVar("%_NT_SYMBOL_PATH%");
      if (env)
      {
         end = 0;      
         hr =
            StringCchCatExA(
               symSearchPath,

               // -1 to make sure that there's space for a semi at the end
   
               PATH_BUF_SIZE - 1,
               env,
               &end,
               0,
               STRSAFE_IGNORE_NULLS);

         delete[] env;

         if (SUCCEEDED(hr))
         {
            // Since we know there will be space for it, just poke in a semi
   
            *end = ';';
         }
         else
         {
            // even if this part of the path is absent, use the others
            
            hr = S_OK;
         }
      }

      env = ExpandEnvironmentVar("%_NT_ALTERNATE_SYMBOL_PATH%");
      if (env)
      {
         end = 0;

         // return code unchecked because even if this part of the path is
         // absent, we will use the others
         
         (void) StringCchCatExA(
            symSearchPath,
            PATH_BUF_SIZE,
            env,
            &end,
            0,
            STRSAFE_IGNORE_NULLS);

         delete[] env;
      }
   }
   while (0);

   BOOL succeeded =
      MySymInitialize(
         ::GetCurrentProcess(),
         SUCCEEDED(hr) ? symSearchPath : 0,
         TRUE);

   RTLASSERT(succeeded);

   delete[] symSearchPath;
}



void
Burnslib::StackTrace::Initialize()
{
   RTLASSERT(!IsInitialized());

   // load the dbghelp dll -- not the imagehlp dll. The latter is merely a
   // delayload-enabled wrapper of dbghelp, and in low-resource situations
   // loading imagehlp will succeed, but the its delayload of dbghelp will
   // fail, leading to calls to stubs that do nothing.
   // NTRAID#NTBUG9-572904-2002/03/12-sburns
   
   imageHelpDll = static_cast<HMODULE>(::LoadLibrary(L"dbghelp.dll"));
   if (!imageHelpDll)
   {
      return;
   }

   // resolve the function pointers

   MySymSetOptions =
      reinterpret_cast<SymSetOptionsFunc>(
         ::GetProcAddress(imageHelpDll, "SymSetOptions"));

   MySymInitialize =
      reinterpret_cast<SymInitializeFunc>(
         ::GetProcAddress(imageHelpDll, "SymInitialize"));

   MySymCleanup =
      reinterpret_cast<SymCleanupFunc>(
         ::GetProcAddress(imageHelpDll, "SymCleanup"));

   MySymGetModuleInfo =
      reinterpret_cast<SymGetModuleInfoFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetModuleInfo64"));

   MySymGetLineFromAddr =
      reinterpret_cast<SymGetLineFromAddrFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetLineFromAddr64"));

   MyStackWalk =
      reinterpret_cast<StackWalkFunc>(
         ::GetProcAddress(imageHelpDll, "StackWalk64"));

   MySymGetSymFromAddr =
      reinterpret_cast<SymGetSymFromAddrFunc>(
         ::GetProcAddress(imageHelpDll, "SymGetSymFromAddr64"));

   MySymFunctionTableAccess64 =
      reinterpret_cast<SymFunctionTableAccess64Func>(
         ::GetProcAddress(imageHelpDll, "SymFunctionTableAccess64"));
      
   MySymGetModuleBase64 =
      reinterpret_cast<SymGetModuleBase64Func>(
         ::GetProcAddress(imageHelpDll, "SymGetModuleBase64"));
      
   if (
         !MySymSetOptions
      || !MySymInitialize
      || !MySymCleanup
      || !MySymGetModuleInfo
      || !MySymGetLineFromAddr
      || !MyStackWalk
      || !MySymGetSymFromAddr
      || !MySymFunctionTableAccess64
      || !MySymGetModuleBase64)
   {
      return;
   }

   // Init the stack trace facilities

   //lint -e(534) we're not interested in the return value.

   MySymSetOptions(
         SYMOPT_DEFERRED_LOADS
      |  SYMOPT_UNDNAME
      |  SYMOPT_LOAD_LINES);

   InitHelper();
}



void
Burnslib::StackTrace::Cleanup()
{
   if (IsInitialized())
   {
      BOOL succeeded = MySymCleanup(::GetCurrentProcess());

      RTLASSERT(succeeded);

      ::FreeLibrary(imageHelpDll);
      imageHelpDll = 0;
   }
}



// a SEH filter function that walks the stack, and stuffs the offset pointers
// into the provided array.

DWORD
GetStackTraceFilter(
   DWORD64 stackTrace[],
   size_t    traceMax,    
   CONTEXT*  context,
   size_t    levelsToSkip)     
{
   RTLASSERT(Burnslib::StackTrace::IsInitialized());
   RTLASSERT(MyStackWalk);
   RTLASSERT(context);

   // REVIEWED: correct byte count passed
   
   ::ZeroMemory(stackTrace, traceMax * sizeof DWORD64);

   if (!MyStackWalk)
   {
      // initialization failed in some way, so do nothing.

      return EXCEPTION_EXECUTE_HANDLER;
   }

   STACKFRAME64 frame;
   DWORD dwMachineType;

   // REVIEWED: correct byte count passed
   
   ::ZeroMemory(&frame, sizeof frame);

#if defined(_M_IX86)
   dwMachineType             = IMAGE_FILE_MACHINE_I386;
   frame.AddrPC.Offset       = context->Eip;
   frame.AddrPC.Mode         = AddrModeFlat;
   frame.AddrFrame.Offset    = context->Ebp;
   frame.AddrFrame.Mode      = AddrModeFlat;
   frame.AddrStack.Offset    = context->Esp;
   frame.AddrStack.Mode      = AddrModeFlat;

#elif defined(_M_AMD64)
   dwMachineType             = IMAGE_FILE_MACHINE_AMD64;
   frame.AddrPC.Offset       = context->Rip;
   frame.AddrPC.Mode         = AddrModeFlat;
   frame.AddrStack.Offset    = context->Rsp;
   frame.AddrStack.Mode      = AddrModeFlat;

#elif defined(_M_IA64)
   dwMachineType             = IMAGE_FILE_MACHINE_IA64;
   frame.AddrPC.Offset       = context->StIIP;
   frame.AddrPC.Mode         = AddrModeFlat;
   frame.AddrStack.Offset    = context->IntSp;
   frame.AddrStack.Mode      = AddrModeFlat;

#else
#error( "unknown target machine" );
#endif

   HANDLE process = ::GetCurrentProcess();
   HANDLE thread = ::GetCurrentThread();

   // On ia64, the context struct can be whacked by StackWalk64 (thanks to
   // drewb for cluing me in to that subtle point). If the context record is a
   // pointer to the one gathered from GetExceptionInformation, whacking it is
   // a Very Bad Thing To Do. Stack corruption results. So in order to get
   // successive calls to work, we have to copy the struct, and let the copy
   // get whacked.
   
   CONTEXT dupContext;

   // REVIEWED-2002/03/06-sburns correct byte count passed.
   
   ::CopyMemory(&dupContext, context, sizeof dupContext);
   
   for (size_t i = 0, top = 0; top < traceMax; ++i)
   {
      BOOL result = 
         MyStackWalk(
            dwMachineType,
            process,
            thread,
            &frame,
            &dupContext,
            0,
            MySymFunctionTableAccess64,
            MySymGetModuleBase64,
            0);
      if (!result)
      {
         break;
      }

      // skip the n most recent frames

      if (i >= levelsToSkip)
      {
         stackTrace[top++] = frame.AddrPC.Offset;
      }
   }

   return EXCEPTION_EXECUTE_HANDLER;
}



DWORD
Burnslib::StackTrace::TraceFilter(
   DWORD64  stackTrace[],
   size_t   traceMax,    
   CONTEXT* context)     
{
   RTLASSERT(stackTrace);
   RTLASSERT(traceMax);
   RTLASSERT(context);

   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   return 
      GetStackTraceFilter(stackTrace, traceMax, context, 0);
}
   


void
Burnslib::StackTrace::Trace(DWORD64 stackTrace[], size_t traceMax)
{
   RTLASSERT(stackTrace);
   RTLASSERT(traceMax);

   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   // the only way to get the context of a running thread is to raise an
   // exception....

   __try
   {
      RaiseException(0, 0, 0, 0);
   }
   __except (
      GetStackTraceFilter(
         stackTrace,
         traceMax,

         //lint --e(*) GetExceptionInformation is like a compiler intrinsic

         (GetExceptionInformation())->ContextRecord,

         // skip the 2 most recent function calls, as those correspond to
         // this function itself.

         2))
   {
      // do nothing in the handler
   }
}


// ISSUE-2002/03/06-sburns consider replacing with strsafe function
// strncpy that will not overflow the buffer.

inline
void
SafeStrncpy(char* dest, const char* src, size_t bufmax)
{
   ::ZeroMemory(dest, bufmax);
   strncpy(dest, src, bufmax - 1);
}



void
Burnslib::StackTrace::LookupAddress(
   DWORD64  traceAddress,   
   char     moduleName[],   
   char     fullImageName[],
   char     symbolName[],    // must be SYMBOL_NAME_MAX bytes
   DWORD64* displacement,   
   DWORD*   line,           
   char     fullpath[])      // must be MAX_PATH bytes
{
   if (!Burnslib::StackTrace::IsInitialized())
   {
      Burnslib::StackTrace::Initialize();
   }

   RTLASSERT(traceAddress);

   HANDLE process = ::GetCurrentProcess();

   if (moduleName || fullImageName)
   {
      IMAGEHLP_MODULE64 module;

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(&module, sizeof module);
      module.SizeOfStruct = sizeof(module);
      if (MySymGetModuleInfo(process, traceAddress, &module))
      {
         if (moduleName)
         {
            SafeStrncpy(moduleName, module.ModuleName, MODULE_NAME_MAX);
         }
         if (fullImageName)
         {
            SafeStrncpy(
               fullImageName,
               module.LoadedImageName,
               MAX_PATH);
         }
      }
   }

   if (symbolName || displacement)
   {

   // CODEWORK: use SymFromAddr instead?

   
      // +1 for paranoid terminating null
      
      BYTE buf[SYMBOL_NAME_MAX + sizeof IMAGEHLP_SYMBOL64 + 1];

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(buf, SYMBOL_NAME_MAX + sizeof IMAGEHLP_SYMBOL64 + 1);

      IMAGEHLP_SYMBOL64* symbol = reinterpret_cast<IMAGEHLP_SYMBOL64*>(buf);
      symbol->SizeOfStruct = sizeof(IMAGEHLP_SYMBOL64);
      symbol->MaxNameLength = SYMBOL_NAME_MAX;

      if (MySymGetSymFromAddr(process, traceAddress, displacement, symbol))
      {
         if (symbolName)
         {
            SafeStrncpy(symbolName, symbol->Name, SYMBOL_NAME_MAX);
         }
      }
   }

   if (line || fullpath)
   {
      DWORD disp2 = 0;
      IMAGEHLP_LINE64 lineinfo;

      // REVIEWED-2002/03/06-sburns correct byte count passed

      ::ZeroMemory(&lineinfo, sizeof lineinfo);
      
      lineinfo.SizeOfStruct = sizeof(lineinfo);

      if (MySymGetLineFromAddr(process, traceAddress, &disp2, &lineinfo))
      {
         // disp2 ?= displacement

         if (line)
         {
            *line = lineinfo.LineNumber;
         }
         if (fullpath)
         {
            SafeStrncpy(fullpath, lineinfo.FileName, MAX_PATH);
         }
      }
   }
}



String
Burnslib::StackTrace::LookupAddress(
   DWORD64 traceAddress,
   const wchar_t* format)
{
   RTLASSERT(traceAddress);
   RTLASSERT(format);

   String result;

   if (!format || !traceAddress)
   {
      return result;
   }

   char      ansiSymbol[Burnslib::StackTrace::SYMBOL_NAME_MAX];
   char      ansiModule[Burnslib::StackTrace::MODULE_NAME_MAX];
   char      ansiSource[MAX_PATH];                           
   DWORD64   displacement = 0;
   DWORD     line         = 0;

   // REVIEWED-2002/03/06-sburns correct byte counts passed
   
   ::ZeroMemory(ansiSymbol, Burnslib::StackTrace::SYMBOL_NAME_MAX);
   ::ZeroMemory(ansiModule, Burnslib::StackTrace::MODULE_NAME_MAX);
   ::ZeroMemory(ansiSource, MAX_PATH);                             

   Burnslib::StackTrace::LookupAddress(
      traceAddress,
      ansiModule,
      0,
      ansiSymbol,
      &displacement,
      &line,
      ansiSource);

   String module(ansiModule);
   String symbol(ansiSymbol);
   String source(ansiSource);

   result =
      String::format(
         format,
         module.c_str(),
         symbol.c_str(),
         source.c_str(),
         line);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-string.cpp ===
// Test string class

#include "headers.hxx"
#include <containers.hpp>
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   String s(L"a list of tokens all in a row");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens));
   ASSERT(token_count == tokens.size());

   for (
      StringList::iterator i = tokens.begin();
      i != tokens.end();
      ++i)
   {
      AnsiString ansi;
      i->convert(ansi);
      std::cout << ansi << std::endl;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-log.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
f3()
{
   LOG_FUNCTION(f3);

   LOG_LAST_WINERROR();

   {
      LOG_SCOPE(L"nested scope");
   }

   class Foo
   {
      public:

      Foo()
      {
         LOG_CTOR(Foo);
      }

      ~Foo()
      {
         LOG_DTOR(Foo);
      }

      void
      Method()
      {
         LOG_FUNCTION(Foo::Method);

         HRESULT hr = CO_E_RUNAS_LOGON_FAILURE;
         LOG_HRESULT(hr);
      }
   };

   Foo afoo;
   afoo.Method();
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   LOG(L"Let the games begin");

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-stacktrace.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



// set the HeapFlags to trace allocations to see the leak detection



void
raise()
{
   // force an AV

   char* null = 0;
   *null = 'X';
}



void
DumpStack(DWORD64 stackTrace[], size_t traceMax)
{

   for (int i = 0; stackTrace[i] and (i <= traceMax); ++i)
   {
      ::OutputDebugString(
         StackTrace::LookupAddress(stackTrace[i]).c_str());
      ::OutputDebugString(L"\r\n");
   }
}



void
f3()
{
   const size_t TRACE_MAX = 10;
   DWORD64 stackTrace[TRACE_MAX];
   size_t traceMax = TRACE_MAX;

   wchar_t* leak = new wchar_t;
   *leak = L'X';

   __try
   {
      raise();
   }
   __except(
      StackTrace::TraceFilter(
         stackTrace,
         traceMax,
         (GetExceptionInformation())->ContextRecord))
   {
      DumpStack(stackTrace, traceMax);
   }
}



void
f2()
{
   LOG_FUNCTION2(f2, L"this is f2");

   f3();
}



void
f1()
{
   LOG_FUNCTION(f1);

   f2();
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   f1();

   LOG(L"now ending main");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\string.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// string class
//
// 8-14-97 sburns
 
  

#include "headers.hxx"



String::String(PCSTR lpsz)
   :
   base()
{
   // ISSUE-2002/03/06-sburns consider strsafe function
   
   size_t len = lpsz ? static_cast<size_t>(lstrlenA(lpsz)) : 0;

   if (len)
   {
      assignFromAnsi(lpsz, len);
   }
}



String::String(const AnsiString& s)
   :
   base()
{
   size_t len = s.length();

   if (len)
   {
      assignFromAnsi(s.data(), len);
   }
}



void
String::assignFromAnsi(PCSTR lpsz, size_t len)
{
   ASSERT(lpsz);
   ASSERT(len);

   // add 1 to allow for trailing null

   wchar_t* buf = new wchar_t[len + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, (len + 1) * sizeof wchar_t);

   size_t result =
      static_cast<size_t>(

         // REVIEWED-2002/03/06-sburns correct byte/char counts
         
         ::MultiByteToWideChar(
            CP_ACP,
            0,
            lpsz,

            // len bytes in the source ansi string (not incl trailing null)

            static_cast<int>(len),
            buf,

            // len characters in the result wide string (not incl trailing
            // null)

            static_cast<int>(len)));

   if (result)
   {
      ASSERT(result <= len);
      assign(buf);
   }

   delete[] buf;
}
      


HRESULT
String::as_OLESTR(LPOLESTR& oleString) const
{
   size_t len = length();

   oleString =
      reinterpret_cast<LPOLESTR>(
         ::CoTaskMemAlloc((len + 1) * sizeof(wchar_t)));
   if (oleString)
   {
      copy(oleString, len);
      oleString[len] = 0;
      return S_OK;
   }

   return E_OUTOFMEMORY;
}



String
String::load(unsigned resID, HINSTANCE hInstance)
{
   if (!hInstance)
   {
      hInstance = GetResourceModuleHandle();
   }

#ifdef DBG

   // pick a silly small buffer size to make sure our resize logic gets
   // exercised.
   
   static const int TEMP_LEN = 7;
#else
   static const int TEMP_LEN = 512;
#endif   

   wchar_t temp[TEMP_LEN];

   // ISSUE-2002/02/25-sburns why is tempLen needed?  just use TEMP_LEN?
   
   int tempLen = TEMP_LEN;

   // REVIEWED-2002/03/06-sburns correct character count passed
   
   int len = ::LoadString(hInstance, resID, temp, tempLen);

   // we expect that if the caller is loading a string, the string is non-
   // empty. An empty string probably indicates something is broken in the
   // caller's program. It is legal, but silly, to put empty strings in a
   // resource table.
   
   ASSERT(len);

   if (len == 0)
   {
      return String();
   }

   if (tempLen - len > 1)
   {
      // the string fit into the temp buffer with at least 1 character to
      // spare.  If the load failed, len == 0, and we return the empty
      // string.

      return String(temp);
   }

   // the string did not fit.  Try larger buffer sizes until the string does
   // fit with at least 1 character to spare

   int newLen = tempLen;
   wchar_t* newTemp = 0;
   do
   {
      delete[] newTemp;
      newLen += TEMP_LEN;
      newTemp = new wchar_t[static_cast<size_t>(newLen)];

      // REVIEWED-2002/03/06-sburns correct character count passed

      len = ::LoadString(hInstance, resID, newTemp, newLen);
   }

   // ISSUE-2002/02/25-sburns growth is unbounded here...
   
   while (newLen - len <= 1);   // repeat until at least 1 char to spare

   String r(newTemp);
   delete[] newTemp;
   return r;
}



String&
String::replace(const String& from, const String& to)
{
   if (from.empty())
   {
      return *this;
   }

   _copy();
   String::size_type i = 0;
   String::size_type fl = from.length();
   String::size_type tl = to.length();
   String::size_type len = length();
   const wchar_t* td = to.data();

   do
   {
      i = find(from, i);
      if (i == String::npos)
      {
         return *this;
      }
      base::replace(i, fl, td, tl);
      i += tl;
   }
   while (i <= len);

   return *this;
}

String&
String::replace_each_of(const String& from, const String& to)
{
   if (from.empty())
   {
      return *this;
   }

   _copy();
   String::size_type i = 0;
   String::size_type fl = from.length();
   String::size_type tl = to.length();
   String::size_type len = length();
   const wchar_t* td = to.data();

   do
   {
      i = find_first_of(from, i);
      if (i == String::npos)
      {
         return *this;
      }
      base::replace(i, 1, td, tl);
      i += tl;
   }
   while (i <= len);

   return *this;
}


String&
String::strip(StripType type, wchar_t charToStrip)
{
   String::size_type start = 0;
   String::size_type stop = length();
   const wchar_t* p = data();

   if (type & LEADING)
   {
      while (start < stop && p[start] == charToStrip)
      {
         ++start;
      }
   }

   if (type & TRAILING)
   {
      while (start < stop && p[stop - 1] == charToStrip)
      {
         --stop;
      }
   }

   if (stop == start)
   {
      assign(String());
   }
   else
   {
      // this goofiness due to a bug in basic_string where you can't assign
      // a piece of yourself, because you delete yourself before you copy!
      // assign(p + start, stop - start);

      String s(p + start, stop - start);
      assign(s);
   }

   return *this;
}



String&
String::to_lower()
{
   if (length())
   {
      _copy();

      // ISSUE-2002/03/06-sburns consider strsafe function
      
      _wcslwr(const_cast<wchar_t*>(c_str()));
   }
   return *this;
}



String&
String::to_upper()
{
   if (length())
   {
      _copy();

      // ISSUE-2002/03/06-sburns consider strsafe function
      
      _wcsupr(const_cast<wchar_t*>(c_str()));
   }
   return *this;
}



void
String::_copy() 
{
   size_type len = length();

   if (len)
   {
      value_type* buf = new value_type[len + 1];
      copy(buf, len);
      buf[len] = 0;
      assign(buf);
      delete[] buf;
   }
}



//
// static functions
//



#if defined(ALPHA) || defined(IA64)
   String __cdecl
   String::format(
      const String& qqfmt,
      ...)
#else

   // the x86 compiler won't allow the first parameter to be a reference
   // type.  This is a compiler bug.

   String __cdecl
   String::format(
      const String qqfmt,
      ...)
#endif

{
// ISSUE-2002/03/06-sburns should assert that qqfmt is not empty (I'd
// just add it now, but I'm not entirely confident it wouldn't hose the
// varargs   
//    ASSERT(!qqfmt.empty());
   
   String result;

   va_list argList;
   va_start(argList, qqfmt);

   PTSTR temp = 0;
   PCTSTR f = qqfmt.c_str();

   if (
      // REVIEWED-2002/03/06-sburns no char/byte or buffer size issues: we ask
      // the API to allocate for us.

      // REVIEWED-2002/03/29-sburns no unbounded allocation error here.
      // If I pass nSize = 0 and FORMAT_MESSAGE_ALLOCATE_BUFFER in dwFlags,
      // the max result size is 32K - 1 characters.  Looking at the code in
      // message.c, it looks like the reserve space is whatever the user asked
      // as a maximum rounded up to the nearest 64K. That makes sense given my
      // test, since 32K chars = 64K bytes.  Experimentally, even if I ask for
      // a max buffer size > 0x87FFF chars, it looks like the most I can get
      // is 0x87FFE chars. 
      
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         f,
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(
   const wchar_t* qqfmt,
   ...)
{
   ASSERT(qqfmt);

   String result;

   va_list argList;
   va_start(argList, qqfmt);

   PTSTR temp = 0;

   if (
      // REVIEWED-2002/03/06-sburns no char/byte or buffer size issues: we ask
      // the API to allocate for us.
   
      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         qqfmt,
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(unsigned formatResID, ...)
{
   String fmt = String::load(formatResID);
   String result;

   va_list argList;
   va_start(argList, formatResID);
   PTSTR temp = 0;
   if (
      // REVIEWED-2002/03/06-sburns no char/byte or buffer size issues: we ask
      // the API to allocate for us.

      // REVIEWED-2002/03/29-sburns no unbounded allocation error here.
      // If I pass nSize = 0 and FORMAT_MESSAGE_ALLOCATE_BUFFER in dwFlags,
      // the max result size is 32K - 1 characters.  Looking at the code in
      // message.c, it looks like the reserve space is whatever the user asked
      // as a maximum rounded up to the nearest 64K. That makes sense given my
      // test, since 32K chars = 64K bytes.  Experimentally, even if I ask for
      // a max buffer size > 0x87FFF chars, it looks like the most I can get
      // is 0x87FFE chars. 

      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         fmt.c_str(),
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      result = temp;
      ::LocalFree(temp);
   }

   va_end(argList);
   return result;
}



String __cdecl
String::format(int formatResID, ...)
{
   String fmt = String::load(formatResID);

   va_list argList;
   va_start(argList, formatResID);
   PTSTR temp = 0;
   if (
      // REVIEWED-2002/03/06-sburns no char/byte or buffer size issues: we ask
      // the API to allocate for us.
   
      // REVIEWED-2002/03/29-sburns no unbounded allocation error here.
      // If I pass nSize = 0 and FORMAT_MESSAGE_ALLOCATE_BUFFER in dwFlags,
      // the max result size is 32K - 1 characters.  Looking at the code in
      // message.c, it looks like the reserve space is whatever the user asked
      // as a maximum rounded up to the nearest 64K. That makes sense given my
      // test, since 32K chars = 64K bytes.  Experimentally, even if I ask for
      // a max buffer size > 0x87FFF chars, it looks like the most I can get
      // is 0x87FFE chars. 

      ::FormatMessage(
         FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ALLOCATE_BUFFER,
         fmt.c_str(),
         0,
         0,
         reinterpret_cast<PTSTR>(&temp),
         0,
         &argList))
   {
      String retval(temp);
      ::LocalFree(temp);
      va_end(argList);
      return retval;
   }

   va_end(argList);
   return String();
}



int
String::icompare(const String& str) const
{
   int i =
      ::CompareString(
         LOCALE_USER_DEFAULT,
            NORM_IGNORECASE

            // these flags necessary for Japanese strings

         |  NORM_IGNOREKANATYPE  
         |  NORM_IGNOREWIDTH,
         c_str(),
         static_cast<int>(length()),
         str.c_str(),
         static_cast<int>(str.length()));
   if (i)
   {
      // convert to < 0, == 0, > 0 C runtime convention

      return i - 2;
   }

   // this will be wrong, but what option do we have?

   return i; 
}
   


HRESULT
WideCharToMultiByteHelper(
   UINT           codePage,
   DWORD          flags,
   const String&  str,
   char*          buffer,
   size_t         bufferSizeInBytes,
   size_t&        result)
{
   ASSERT(!str.empty());

   result = 0;

   HRESULT hr = S_OK;

   int r =

      // REVIEWED-2002/03/06-sburns correct character/byte counts passed.
      
      ::WideCharToMultiByte(
         codePage, 
         flags,
         str.c_str(),

         // the character count count
         
         static_cast<int>(str.length()),
         buffer,

         // the buffer size in bytes
         
         static_cast<int>(bufferSizeInBytes),
         0,
         0);
   if (!r)
   {
      hr = Win32ToHresult(::GetLastError());
   }

   ASSERT(SUCCEEDED(hr));

   result = static_cast<size_t>(r);

   return hr;
}



String::ConvertResult
String::convert(AnsiString& ansi, UINT codePage) const
{
   ansi.erase();

   ConvertResult result = CONVERT_FAILED;

   do
   {
      if (empty())
      {
         // nothing else to do.

         result = CONVERT_SUCCESSFUL;
         break;
      }

      // determine the size of the buffer required to hold the ANSI string

      const wchar_t* wide = c_str();

      size_t bufferSizeInBytes = 0;
      HRESULT hr =
         ::WideCharToMultiByteHelper(
            codePage,
            0,
            wide,
            0,
            0,

            // REVIEWED-2002/03/06-sburns correct byte count passed.
         
            bufferSizeInBytes);
      BREAK_ON_FAILED_HRESULT(hr);
   
      if (bufferSizeInBytes > 0)
      {
         // +1 for extra null-termination paranoia
         
         AnsiString a(bufferSizeInBytes + 1, 0);
         char* p = const_cast<char*>(a.c_str());

         size_t r = 0;

         hr =
            ::WideCharToMultiByteHelper(
               codePage,
               0,
               wide,
               p,

               // REVIEWED-2002/03/06-sburns correct byte count passed.
      
               bufferSizeInBytes,
               r);
         BREAK_ON_FAILED_HRESULT(hr);

         ansi = a;
         result = CONVERT_SUCCESSFUL;
      }
   }
   while (0);

   return result;
}



template<class UnsignedType>
class UnsignedConvertHelper
{
   public:

   // at first glance, one might think that this is a job for a template
   // member function.  That's what I thought.  Unfortunately, the combination
   // of freely convertible integer types and the binding rules for resolving
   // function templates results in ambiguity.  Using a static class method,
   // though, allows the caller to specify the template parameter types, and
   // avoid the abiguity.
   
   static
   String::ConvertResult
   doit(const String& s, UnsignedType& u, int radix, UnsignedType maxval)
   {
      // call the long version, then truncate as appropriate
   
      unsigned long ul = 0;
      u = 0;
      String::ConvertResult result = s.convert(ul, radix);

      if (result == String::CONVERT_SUCCESSFUL)
      {
         if (ul <= maxval)
         {
            // ul will fit into an unsigned int.
            u = static_cast<UnsignedType>(ul);
         }
         else
         {
            result = String::CONVERT_OVERFLOW;
         }
      }

      return result;
   }
};



template<class IntType>
class IntegerConvertHelper
{
   public:

   static
   String::ConvertResult
   doit(const String& s, IntType& u, int radix, IntType minval, IntType maxval)
   {
      long l = 0;
      u = 0;
      String::ConvertResult result = s.convert(l, radix);

      if (result == String::CONVERT_SUCCESSFUL)
      {
         if (l <= maxval)
         {
            if (l >= minval)
            {
               // l will fit into an IntType.
               u = static_cast<IntType>(l);
            }
            else
            {
               result = String::CONVERT_UNDERFLOW;
            }
         }
         else
         {
            result = String::CONVERT_OVERFLOW;
         }
      }

      return result;
   }
};




String::ConvertResult
String::convert(short& s, int radix) const
{
   return
      IntegerConvertHelper<short>::doit(*this, s, radix, SHRT_MIN, SHRT_MAX);
}



String::ConvertResult
String::convert(int& i, int radix) const
{
   return
      IntegerConvertHelper<int>::doit(*this, i, radix, INT_MIN, INT_MAX);
}



String::ConvertResult
String::convert(unsigned short& us, int radix) const
{
   return
      UnsignedConvertHelper<unsigned short>::doit(
         *this,
         us,
         radix,
         USHRT_MAX);
}



String::ConvertResult
String::convert(unsigned& ui, int radix) const
{
   return
      UnsignedConvertHelper<unsigned int>::doit(
         *this,
         ui,
         radix,
         UINT_MAX);
}



String::ConvertResult
String::convert(long& l, int radix) const
{
   l = 0;
   if (radix != 0 && (radix < 2 || radix > 36))
   {
      ASSERT(false);
      return CONVERT_BAD_RADIX;
   }

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   long result = wcstol(begptr, &endptr, radix);
   if (errno == ERANGE)
   {
      return result == LONG_MAX ? CONVERT_OVERFLOW : CONVERT_UNDERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   l = result;
   return CONVERT_SUCCESSFUL;
}



String::ConvertResult
String::convert(unsigned long& ul, int radix) const
{
   ul = 0;
   if (radix != 0 && (radix < 2 || radix > 36))
   {
      ASSERT(false);
      return CONVERT_BAD_RADIX;
   }

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   unsigned long result = wcstoul(begptr, &endptr, radix);
   if (errno == ERANGE)
   {
      // overflow is the only possible range error for an unsigned type.
      return CONVERT_OVERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   ul = result;
   return CONVERT_SUCCESSFUL;
}



String::ConvertResult
String::convert(double& d) const
{
   d = 0.0;

   String::const_pointer begptr = c_str();
   String::pointer endptr = 0;
   errno = 0;
   double result = wcstod(begptr, &endptr);
   if (errno == ERANGE)
   {
      // result is +/-HUGE_VAL on overflow, 0 on underflow.

      return result ? CONVERT_OVERFLOW : CONVERT_UNDERFLOW;
   }
   if (begptr == endptr)
   {
      // no valid characters found
      return CONVERT_BAD_INPUT;
   }
   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      return CONVERT_FAILED;
   }
   
   d = result;
   return CONVERT_SUCCESSFUL;
}

/* This was commented out because it is no longer in use. If
   it is to be used it must be fixed to work with non Arabic
   digits

#define MAX_DECIMAL_STRING_LENGTH_FOR_LARGE_INTEGER 20

String::ConvertResult
String::convert(LARGE_INTEGER& li) const
{
   li.QuadPart = 0;

   if (size() > MAX_DECIMAL_STRING_LENGTH_FOR_LARGE_INTEGER)
   {
      // string is too long
      return CONVERT_OVERFLOW;
   }

   String::const_pointer begptr = c_str();
   String::const_pointer endptr = begptr;
   errno = 0;

	BOOL bNeg = FALSE;
	if (*endptr == L'-')
	{
		bNeg = TRUE;
		endptr++;
	}
	while (*endptr != L'\0')
	{
      if (!iswctype(*endptr,_DIGIT))
      {
         return CONVERT_BAD_INPUT;
      }
		li.QuadPart = 10 * li.QuadPart + (*endptr-L'0');
		endptr++;
	}
	if (bNeg)
	{
		li.QuadPart *= -1;
	}

   if (begptr == endptr)
   {
      // no valid characters found
      li.QuadPart = 0;
      return CONVERT_BAD_INPUT;
   }

   if (endptr)
   {
      if (*endptr != 0)
      {
         // the conversion stopped before the null terminator => bad
         // characters in input
         li.QuadPart = 0;
         return CONVERT_BAD_INPUT;
      }
   }
   else
   {
      // I doubt this is reachable
      li.QuadPart = 0;
      return CONVERT_FAILED;
   }
   
   return CONVERT_SUCCESSFUL;
}
*/


bool
String::is_numeric() const
{
   if (empty())
   {
      return false;
   }

   size_t len = length();
   WORD* charTypeInfo = new WORD[len];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(charTypeInfo, len * sizeof WORD);

   bool result = false;

   do
   {
      BOOL success =
         ::GetStringTypeEx(
            LOCALE_USER_DEFAULT,
            CT_CTYPE1,
            c_str(),
            static_cast<int>(length()),
            charTypeInfo);

      ASSERT(success);

      if (!success)
      {
         break;
      }

      // look thru the type info array, ensure that all chars are digits.

      bool nonDigitFound = false;
      for (size_t i = 0; i < len; ++i)
      {
         // We only consider decimal digits, not C2_EUROPENUMBER and
         // C2_ARABICNUMBER.  I wonder if that is correct?

         if (!(charTypeInfo[i] & C1_DIGIT))
         {
            nonDigitFound = true;
            break;
         }
      }

      // a string is numeric if no non-digit characters are found.

      result = !nonDigitFound;
   }
   while (0);

   delete[] charTypeInfo;
   charTypeInfo = 0;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-tokenize.cpp ===
// Test String class

#include "headers.hxx"
#include <containers.hpp>
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
DumpList(const StringList& tokens)
{   
   for (
      StringList::iterator i = tokens.begin();
      i != tokens.end();
      ++i)
   {
      AnsiString ansi;
      i->convert(ansi);
      std::cout << ansi << std::endl;
   }
}



void
test1()
{
   // use default whitespace delimiter

   String s(L"a list of\ttokens \tall  in  a\t\trow");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens));
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



void
test2()
{
   // use custom delimiters, end with delimiter

   String s(L"mydomain.in-addr.arpa.");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens), L".");
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



void
test3()
{
   // use custom delimiters

   String s(L"mydomain.ipv6.int");
   StringList tokens;

   size_t token_count = s.tokenize(std::back_inserter(tokens), L".");
   ASSERT(token_count == tokens.size());

   DumpList(tokens);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   test1();
   test2();
   test3();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\args.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// argument parsing
// 
// 3-3-99 sburns

                           

#ifndef ARGS_HPP_INCLUDED
#define ARGS_HPP_INCLUDED



// args of the form "/argname:value" create an entry such that
// (argmap["argname"] == value) is true. '/' or '-' are treated synonymously.
// 
// args of the form "argspec" creates an entry such that
// argmap.find(arg) != argmap.end().
//
// args are case-preserving but not case sensitive, so
// argmap["myarg"], argmap["MYARG"], and argmap["MyArG"] all are equivalent.
// 
// To test for the presence of a arg in a map, use std::map::find().
//

typedef
   std::map<
      String,
      String,
      String::LessIgnoreCase,
      Burnslib::Heap::Allocator<String> >
   ArgMap;



// Populates a map of command line arguments and their values from the
// command line arguements of the currently executing program.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.
//
// The first command-line argument is the command used to start the program.
// This value is mapped to the key "_command"

void
MapCommandLineArgs(ArgMap& argmap);



// Populates a map of arguments and their values from the given
// string.
//
// args - text containing args separated by spaces/tabs.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.

void
MapArgs(const String& args, ArgMap& argmap);



// Populates a map of command line arguments and their values from the list
//
//
// args - list of Strings, where each node is an arg.
//
// argmap - map to receive the key/value pairs.  Prior contents are not
// changed.

void
MapArgsHelper(const String& arg, ArgMap& argmap);

template <class InputIterator>
void
MapArgs(InputIterator first, const InputIterator& last, ArgMap& argmap)
{
   for (
      ;
      first != last;
      ++first)
   {
      MapArgsHelper(*first, argmap);
   }
}



#endif   // ARGS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\core\test\test-warning.cpp ===
#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* RUNTIME_NAME = L"coretest";

DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_TYPICAL;



void
trigger4244()
{

#ifdef COMPILE_WARNINGS

   // trigger warning 4244 with assignment

   __int64 yyyy = 5678;
   int* leak6 = new int;
   *leak6 = yyyy;

   // and again with initialization

   int xxxx = yyyy;
   xxxx -= 100;

#endif

}




VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   trigger4244();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\assert.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// ASSERT macro
//
// 3 Mar 2000 sburns


// to be #included from blcore.hpp


// Using the CRT assert or _ASSERTE turned into a hassle, as the CRT has
// it's own notions of debug building.

#undef ASSERT

#ifdef DBG

   #define ASSERT(expr)                                                   \
      { /* open scope */                                                  \
         if (!(expr))                                                     \
         {                                                                \
            if (Burnslib::FireAssertionFailure(__FILE__, __LINE__, #expr)) \
            {                                                             \
               DebugBreak();                                              \
            }                                                             \
         }                                                                \
      }  /* close scope */                                                \


#else

   #define ASSERT(expr) ((void)0)

#endif

namespace Burnslib
{

// Returns true to indicate that the user has requested to drop into
// the debugger, false to ignore the assertion failure
//
// If the user chooses to abort the app, this function will call exit(3)
// and not return.

bool
FireAssertionFailure(const char* file, int line, const char* expr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\autotokenprivileges.hpp ===
// Copyright (C) 2002 Microsoft Corporation
// 
// AutoTokenPrivileges class - for enabling and automatically restoring
// process token privileges
//
// 29 April 2002 sburns



#ifndef AUTOTOKENPRIVILEGES_HPP_INCLUDED
#define AUTOTOKENPRIVILEGES_HPP_INCLUDED



// class AutoTokenPrivileges is a convenient way to scope a process token
// privilege elevation to just the piece of code that requires the elevation,
// and restore it again when the scope exits.
//
// It is generally a good idea to only enable the privileges that are
// absolutely required, and only for as long as they are required.  See
// Howard, Michael. Writing Secure Code. Ch. 5. Microsoft Press. ISBN
// 0-7356-1588-8
// 
// Example:
// 
// {  // open scope
//    // enable the SE_RESTORE_NAME priv, required to set owers in an sd.
// 
//    AutoTokenPrivileges autoPrivs(SE_RESTORE_NAME);
//    hr = autoPrivs.Enable();
//    if (SUCCEEDED(hr))
//    {
//       // make the calls that require the priv.
//    }
// }  // close scope -- the old state of the enabled privs will be restored



class
AutoTokenPrivileges
{
   public:



   // Create a new instance that will enable the named privilege in the
   // process token when Enable is called, and restore the prior state of the
   // privilege when either Restore is called, or the instance is destroyed.
   // 
   // privName - an SE_ privilege name string, like SE_SHUTDOWN_NAME.
   
   explicit 
   AutoTokenPrivileges(const String& privName);


   
   // CODEWORK: another ctor that takes a vector of priv names


   // Restores the privileges to their state prior to calling Enable, unless
   // Restore has been called, in which case the privileges are untouched.
   
   ~AutoTokenPrivileges();
   


   // Enable the privileges that were identified in the ctor.  May return
   // Win32ToHresult(ERROR_NOT_ALL_ASSIGNED)
   
   HRESULT
   Enable();



   // Restore the privileges that were enabled to their prior state.
   
   HRESULT
   Restore();



   private:

   HRESULT
   InternalRestore();

   
   StringList privNames;   

   // cached data:

   mutable HANDLE            processToken;
   mutable TOKEN_PRIVILEGES* newPrivs;
   mutable TOKEN_PRIVILEGES* oldPrivs;    
};



#endif   // AUTOTOKENPRIVILEGES_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\burnslib.h ===
// Copyright (c) 1997-1999 Microsoft Corporation



#define IDC_STATIC_HELPLESS             13 
#define IDC_STATIC_HELPLESS2            14 
#define IDC_STATIC_HELPLESS3            15 
#define IDC_STATIC_HELPLESS4            16 
#define IDC_STATIC_HELPLESS5            17 
#define IDC_STATIC_HELPLESS6            18 
#define IDC_STATIC_HELPLESS7            19 
#define IDC_STATIC_HELPLESS8            20 
#define IDC_STATIC_HELPLESS9            21 
#define IDS_SYSTEM32                    202
#define IDS_HRESULT_SANS_MESSAGE        227
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\bits.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// bit twiddling stuff
// 
// 8-5-98 sburns



// One would think that after n decades of C, these would be builtin
// keywords...



// Returns state of bit n: true if it is set, false if not
//
// bits - set of bits
//
// n - bit to test

inline
bool
getbit(ULONG bits, unsigned int n)
{
   if (bits & (1 << n))
   {
      return true;
   }

   return false;
}


// flips bit n (sets it to the opposite state), returns new state of bit n
//
// bits - set of bits.
//
// n - bit to flip

inline
bool
flipbit(ULONG& bits, unsigned int n)
{
   return getbit((bits ^= (1 << n)), n);
}


// sets bit n to 1
//
// bits - set of bits
//
// n - bit to set

inline
void
setbit(ULONG& bits, unsigned int n)
{
   bits |= (1 << n);
}



// sets bit n to 0
//
// bits - set of bits
//
// n - bit to clear

inline
void
clearbit(ULONG& bits, unsigned int n)
{
   ULONG mask = (1 << n);
   bits &= ~mask;
}



// Sets all bits in mask.  Returns result
//
// bits - holds bits to be set
// 
// mask - mask of bits to set

inline
DWORD 
setbits(ULONG& bits, ULONG mask)
{
   ASSERT(mask);

   bits |= mask;
   return bits;
}



// Clears all bits in mask.  Returns result.
//
// bits - holds bits to be cleared
// 
// mask - mask of bits to clear

inline
DWORD
clearbits(ULONG& bits, ULONG mask)
{
   ASSERT(mask);

   bits &= ~mask;
   return bits;
}



// Toggles all bits in mask.  bits that were set are cleared, and vice-
// versa.  Returns result.
//
// bits - holds bits to be toggled
// 
// mask - mask of bits to toggled

inline
DWORD
flipbits(ULONG& bits, ULONG mask)
{
   bits ^= mask;
   return bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\blcore.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// core library header files
//
// 30 Nov 1999 sburns



#ifndef BLCORE_HPP_INCLUDED
#define BLCORE_HPP_INCLUDED



#if !defined(__cplusplus)
   #error This module must be compiled as C++
#endif
#if !defined(UNICODE)
   #error This module must be compiled UNICODE. (add -DUNICODE to C_DEFINES in sources file)
#endif



// Include system headers before the burnslib headers.  This is necessary
// because the burnslib headers redefine things like operator new, which may
// appear in system headers.  We don't want to change the behavior of code
// outside this library (and users of this library).

#ifdef BURNSLIB_HPP_INCLUDED

   // This file is being included as part of burnslib.hpp, so include the
   // full set of system headers

   #include "sysfull.hpp"
#else 

   #include "syscore.hpp"
#endif



#include "PragmaWarning.hpp"



// include Assert.hpp after syscore.hpp, as it redefines ASSERT()

#include "Assert.hpp"



namespace Burnslib
{
   // For an explanation of the initialization guard thing, see Meyers,
   // Scott. "Effective C++ pp. 178-182  Addison-Wesley 1992.  Basically, it
   // guarantees that this library is properly initialized before any code
   // that uses it is called.

   class InitializationGuard
   {
      public:

      InitializationGuard();
      ~InitializationGuard();

      private:

      static unsigned counter;

      // not defined

      InitializationGuard(const InitializationGuard&);
      const InitializationGuard& operator=(const InitializationGuard&);
   };
}



//lint -e(1502) ok that InitializationGuard has no members: we use it for
// the side effects of static initialization calling the ctor

static Burnslib::InitializationGuard guard;



// we put mem.hpp at the top of our header list, as it redefines new.  If
// any project header includes code that calls new, that code will see the
// redefinition.  For the same reason, we #include mem.hpp after all the
// system headers, as we are uninterested in calls to new that they might
// make.

#include "mem.hpp"
#include "string.hpp"
#include "stacktr.hpp"
#include "log.hpp"
#include "smartptr.hpp"
#include "comstuff.hpp"
#include "coreutil.hpp"
#include "coreres.h"



using namespace Burnslib;



// this is defined in init.cpp

extern const wchar_t* REG_ADMIN_RUNTIME_OPTIONS;



//
// Things you must define in your code:
//



// CODEWORK Putting these externs in a namespace seems to confuse the
// linker.

// namespace Burnslib
// {


// your DllMain or WinMain must set this to the HINSTANCE of the module
// containing all string and other resources.  Without this, no function that
// loads a resource will operate correctly.

extern HINSTANCE hResourceModuleHandle;

// The name of the log file where LOG output is sent.  This file is
// placed in the %systemroot%\debug directory.  The extension will be ".log"

extern const wchar_t* RUNTIME_NAME;

// The default debugging control options to be used, unless overriden in the
// registry DWORD value LogFlags under the key
// HKLM\Software\Microsoft\Windows\CurrentVersion\AdminDebug\\ + RUNTIME_NAME.
// The LOWORD is a set of flag specifing output destinations, the HIWORD is
// the debugging output options in effect.

extern DWORD DEFAULT_LOGGING_OPTIONS;


// }; // namespace Burnslib



#endif   // BLCORE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\callback.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Generic callback mechanism
//
// 8-14-97 sburns



#ifndef CALLBACK_HXX_INCLUDED
#define CALLBACK_HXX_INCLUDED



// abstract base class representing a callback function.  To create
// your own callback, subclass this class.

class Callback
{
   public:

   // returns a status code that may have meaning to the invoker.
   //
   // param - a user-defined value.

   virtual
   int
   Execute(void* param) = 0;
};



#endif   // CALLBACK_HXX_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\burnslib.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// all library header files
//
// 12-12-97 sburns



#ifndef BURNSLIB_HPP_INCLUDED
#define BURNSLIB_HPP_INCLUDED


#if !defined(__cplusplus)
   #error This module must be compiled as C++
#endif
#if !defined(UNICODE)
   #error This module must be compiled UNICODE. (add -DUNICODE to C_DEFINES in sources file)
#endif



#include "blcore.hpp"

#include "EncryptedString.hpp"
#include "containers.hpp"
#include "error.hpp"
#include "win.hpp"
#include "callback.hpp"
#include "filesys.hpp"
#include "extract.hpp"
#include "computer.hpp"
#include "dialog.hpp"
#include "proppage.hpp"
#include "wizpage.hpp"
#include "wizard.hpp"
#include "dns.hpp"
#include "registry.hpp"
#include "bits.hpp"
#include "popup.hpp"
#include "safedll.hpp"
#include "service.hpp"
#include "args.hpp"
#include "dsutil.hpp"
#include "netutil.hpp"
#include "dllref.hpp"
#include "tempfact.hpp"
#include "utility.hpp"
#include "burnslib.h"
#include "AutoTokenPrivileges.hpp"



// Your DllMain or WinMain must initialize this data to the name of the
// helpfile containing context help (help the popup up in response to right
// clicking a control, or pressing F1) for classes derived from Dialog.
// 
// The path is relative to the System Windows Directory, so you will
// typically need to include the help subdirectory.
// 
// e.g. HELPFILE_NAME = L"\\help\\myhelp.hlp";

extern const wchar_t* HELPFILE_NAME;



#endif   // BURNSLIB_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\comstuff.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// COM utility code
//
// 2-3-99 sburns



#ifndef COMSTUFF_HPP_INCLUDED
#define COMSTUFF_HPP_INCLUDED



// Ensures that the type of the pointer to receive the interface pointer
// matches the IID of the interface.  If it doesn't, the static_cast will
// cause a compiler error.
// 
// Example:
// IFoo* fooptr = 0;
// HRESULT hr = punk->QueryInterface(QI_PARAMS(IFoo, &fooptr));
// 
// From Box, D. Essential COM.  pp 60-61.  Addison-Wesley. ISBN 0-201-63446-5

#define QI_PARAMS(Interface, ppvExpression)  \
   IID_##Interface, reinterpret_cast<void**>(static_cast<Interface**>(ppvExpression))




namespace Burnslib
{



// A BSTR wrapper that frees itself upon destruction.
//
// From Box, D. Essential COM.  pp 80-81.  Addison-Wesley. ISBN 0-201-63446-5

class AutoBstr
{
   public:

   explicit
   AutoBstr(const String& s)
      :
      bstr(::SysAllocString(const_cast<wchar_t*>(s.c_str())))
   {
   }
         
   explicit         
   AutoBstr(const wchar_t* s)
      :
      bstr(::SysAllocString(s))
   {
   }

   ~AutoBstr()
   {
      ::SysFreeString(bstr);
      bstr = 0;
   }

   operator BSTR () const
   {
      return bstr;
   }

   private:

   BSTR bstr;
};



class AutoCoInitialize
{
   public:

   AutoCoInitialize()
   {
      hr = ::CoInitialize(0);
   }


   
   // uncomment if this ever becomes necessary
   // AutoCoInitialize(DWORD dwCoInit)
   // {
   //    hr = ::CoInitializeEx(0, dwCoInit);
   // }



   ~AutoCoInitialize()
   {
      if (SUCCEEDED(hr))
      {
         ::CoUninitialize();
      }
   }

   

   HRESULT
   Result() const
   {
      return hr;
   }



   private:

   HRESULT hr;
};
        


}  // namespace Burnslib



#endif   // COMSTUFF_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\computer.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Computer naming tool
//
// 12-1-97 sburns



#ifndef COMPUTER_HPP_INCLUDED
#define COMPUTER_HPP_INCLUDED



// An object representing the name, domain membership state, and other
// interesting properties of a machine.

class Computer
{
   public:



   // Constructs a new instance.  The new instance is not usable until the
   // Refresh method is called.
   // 
   // name - name of the computer.  May have leading backslashes.  May be
   // an IP address, DNS, or NetBIOS computer name.  empty means the local
   // computer.

   explicit
   Computer(const String& name = String());

   ~Computer();



   // Returns the NetBIOS name of the computer.

   String
   GetNetbiosName() const;



   // Returns the Fully-Qualified DNS name of the computer, taking into
   // account the policy-imposed DNS suffix (if any).  Returns the empty
   // string if the computer does not have a DNS name (most likely because
   // TCP/IP is not installed or properly configured on the machine).

   String
   GetFullDnsName() const;



   // Returns the DNS name of the domain the computer is joined to, or the
   // empty string if the computer is not joined to a DS domain.

   String
   GetDomainDnsName() const;



   // Returns the NetBIOS name of the domain the computer is joined to, if
   // the computer is joined to a domain, or the NetBIOS name of the
   // workgroup the computer is joined to, if the computer is joined to a
   // workgroup.  See IsJoinedToDomain(), IsJoinedToWorkgroup().

   String
   GetDomainNetbiosName() const;



   // Returns the name of the forest the machine is joined to, or the empty
   // string if the machine is not joined to a DS domain.
   // 
   // (The forest name is the dns domain name of the first domain in the
   // forest.)

   String
   GetForestDnsName() const;



   // Returns the major version number of the operating system the machine is
   // running.  For Windows NT 4, this is 4.  For Windows 2000, this is 5.

   DWORD
   GetOsMajorVersion() const;



   // Returns the minor version number of the operating system the machine is
   // running.

   DWORD
   GetOsMinorVersion() const;



   enum Role
   {
      STANDALONE_WORKSTATION = DsRole_RoleStandaloneWorkstation,  
      MEMBER_WORKSTATION     = DsRole_RoleMemberWorkstation,      
      STANDALONE_SERVER      = DsRole_RoleStandaloneServer,       
      MEMBER_SERVER          = DsRole_RoleMemberServer,           
      PRIMARY_CONTROLLER     = DsRole_RolePrimaryDomainController,
      BACKUP_CONTROLLER      = DsRole_RoleBackupDomainController  
   };

   // Returns a value indicating the role of the computer.  This value is
   // always the "true" role of the computer, regardless of the safe boot
   // mode of the computer.

   Role
   GetRole() const;



   // Returns true if the machine is a domain controller, false if not.

   bool
   IsDomainController() const;



   // Returns true if the instance refers to the local computer, false if
   // it refers to another computer on the network.  "Local Computer" means
   // the computer on which this process is running.

   bool
   IsLocal() const;



   // Returns true if the machine is joined to any domain, false if not.
   // (Note that IsJoinedToWorgroup == !IsJoinedToDomain, and vice-versa).

   bool
   IsJoinedToDomain() const;



   // Returns true if the machine is joined to the given DS domain, false if
   // not -- the machine is joined to a non-DS domain, not joined to a domain,
   // or joined to a DS domain of another name.
   //
   // domainDnsName - DNS name of the domain to test membership against.

   bool
   IsJoinedToDomain(const String& domainDnsName) const;



   // Returns true if the machine is joined to any workgroup, false if not.
   // (Note that IsJoinedToWorgroup == !IsJoinedToDomain, and vice-versa).
   //
   // If this function returns true, then the name returned by
   // GetDomainNetbiosName is actually the name of the workgroup.

   bool
   IsJoinedToWorkgroup() const;



   // Re-evaluates all computer info.  Returns S_OK if all info was refreshed,
   // or a standard error code if not.  Typical errors include access denied
   // and network path not found.

   HRESULT
   Refresh();



   //
   // static functions
   //



   // Combines the hostname and suffix to form a fully-qualified DNS computer
   // name, and returns that result.  E.g. hostname.dns.domain.suffix.com
   //    
   // hostname - the hostname component of the name.  This string should not
   // be empty.
   //    
   // domainSuffix - the DNS domain suffix portion of the name.  This portion
   // may be empty, in which case the hostname is considered to be in the root
   // domain ".".  Or the suffix may be a single "." to indicate the root
   // domain.  Or the suffix may be a more typical sequence of labels
   // separated by "."

   static
   String
   ComposeFullDnsComputerName(
      const String& hostname,
      const String& domainSuffix);



   // Retreives the netbios computer name that is currently in effect.
   
   static
   String
   GetActivePhysicalNetbiosName();


   
   // Retreives the fully-qualified DNS computer name that is currently in
   // effect.  May return the empty string if no DNS name exists (e.g. tcp/ip
   // is not installed).

   static
   String
   GetActivePhysicalFullDnsName();



   // Retreives the netbios computer name that will take effect upon next
   // reboot, or the current active name if no name change is pending.

   static 
   String
   GetFuturePhysicalNetbiosName();

   
   // Retreives the fully-qualified DNS computer name that will be in effect
   // when the computer is rebooted.  If a future name is not set, then the
   // result is the current active name (as that will still be the name in the
   // future).  Can return the empty string if the active name is not set
   // either (e.g. tcp/ip is not installed)
   
   static 
   String
   GetFuturePhysicalFullDnsName();


   // Determine the safeboot option that the machine is currently running
   // under, or return 0 if the machine is running in normal boot mode.
   // Returns S_OK on success, or an error code on failure.
   // 
   // regHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of a
   // remote computer, or the special HKEY value of HKEY_LOCAL_MACHINE to
   // evaluate the result for the local computer.
   // 
   // result - the safeboot option.  See sdk\inc\safeboot.h for the possible
   // values.

   static
   HRESULT
   GetSafebootOption(HKEY regHKLM, DWORD& result);



   // Returns the product type like RtlGetNtProductType, except that the value
   // is read directly from the registry.  This is preferred to
   // RtlGetNtProductType, because when booted in safe mode,
   // RtlGetNtProductType is caused to lie such that a DC returns a result as
   // though it were a normal server.   Returns S_OK on success, or an error
   // code on failure.
   //
   // regHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of a
   // remote computer, or the special HKEY value of HKEY_LOCAL_MACHINE to
   // evaluate the result for the local computer.
   //
   // result - the product type code.

   static
   HRESULT
   GetProductTypeFromRegistry(HKEY regHLKM, NT_PRODUCT_TYPE& result);



   // Determine if the Dns suffix portion of the local computer name is forced
   // to be a certain value by policy.  If so, return true.  If the
   // determination cannot be made, or if the policy is not in effect, return
   // false.
   // 
   // policyDnsSuffix - out, if there is a policy in effect, this parameter
   // will receive the suffix (which may be the empty string).

   static
   bool
   IsDnsSuffixPolicyInEffect(String& policyDnsSuffix);


   
   // Removes the leading backslashes from a UNC-style computer name, if
   // present, and returns the result.  For example, a name "\\mycomputer"
   // would be returned as "mycomputer".
   // 
   // computerName - the name from which leading backslashes are to be
   // removed. If this name does not have leading backslashes, then this name
   // is returned.

   static 
   String
   RemoveLeadingBackslashes(const String& computerName);



   private:



   // not implemented

   Computer(const Computer& c);
   const Computer& operator=(const Computer& c);

   friend struct ComputerState;

   String         ctorName;   
   bool           isRefreshed;
   ComputerState* state;      
};













#endif   // COMPUTER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\containers.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// common container classes
//
// 13 Jan 2000 sburns



#ifndef CONTAINERS_HPP_INCLUDED
#define CONTAINERS_HPP_INCLUDED



namespace Burnslib
{

typedef
   std::list<String, Burnslib::Heap::Allocator<String> >
   StringList;

typedef
   std::vector<String, Burnslib::Heap::Allocator<String> >
   StringVector;

}  // namespace Burnslib


#endif   // CONTAINERS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\coreres.h ===
// Copyright (c) 1997-1999 Microsoft Corporation

#define IDS_UNKNOWN_ERROR_CODE          224
#define IDS_LOW_MEMORY_MESSAGE          225
#define IDS_LOW_MEMORY_TITLE            226
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\controlsubclasser.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// windows control subclassing wrapper
//
// 22 Nov 2000 sburns



#ifndef CONTROLSUBCLASSER_HPP_INCLUDED
#define CONTROLSUBCLASSER_HPP_INCLUDED



// Class for hooking the window proc of a control.

class ControlSubclasser
{
   protected:

   ControlSubclasser();

   // reverses the subclassing by calling UnhookWindowProc.
   
   virtual   
   ~ControlSubclasser();



   // Hooks the window proc of the supplied window so that all future messages
   // are routed to the OnMessage method.  The OnInit of the parent dialog
   // where the control resides is a good place to call this method.
   //
   // The hook requires that that the GWLP_USERDATA portion of the window
   // be overwritten with the this pointer to this instance.  If you need
   // that data, then you could derive a class from this one, and add
   // members for your extra data.
   //
   // Your overrided Init method must call this base method.
   // 
   // control - in, handle to the control to be hooked.
   
   virtual
   HRESULT
   Init(HWND editControl);



   // Invoked upon receipt of any window message.  The default implementation
   // calls the control's original window procedure.  When you derive a new
   // class from this one, be sure to call this base class method from your
   // derived method for any messages your derived method doesn't handle.
   // 
   // message - in, the message code passed to the dialog window.
   // 
   // wparam - in, the WPARAM parameter accompanying the message.
   // 
   // lparam - in, the LPARAM parameter accompanying the message.

   virtual   
   LRESULT
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

      

   // the handle to the subclassed control.  Only valid after Init has
   // been called.
   
   HWND hwnd;              



   private:

   // restore the original window proc to the window

   void
   UnhookWindowProc();


   
   // a static Windows Proc that acts as a dispatcher to the non-static
   // OnMessage method.
   
   static
   LRESULT CALLBACK
   WindowProc(
      HWND   window,
      UINT   message,       
      WPARAM wParam,        
      LPARAM lParam);



   // not implemented: no copying allowed

   ControlSubclasser(const ControlSubclasser&);
   const ControlSubclasser& operator=(const ControlSubclasser&);

   WNDPROC originalWindowProc;
};



#endif   // CONTROLSUBCLASSER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\coreutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// core utility functions
//
// 30 Nov 1999 sburns

                           

#ifndef COREUTIL_HPP_INCLUDED
#define COREUTIL_HPP_INCLUDED



#define BREAK_ON_FAILED_HRESULT(hr)                               \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



#define BREAK_ON_FAILED_HRESULT2(hr,msg)                          \
   if (FAILED(hr))                                                \
   {                                                              \
      LOG(msg)                                                    \
      LOG_HRESULT(hr);                                            \
      break;                                                      \
   }



namespace Burnslib
{



// Loads various message dlls in an an attempt to resolve the HRESULT into
// an error message.  Returns a "unknown error" string on failure.

String
GetErrorMessage(HRESULT hr);



// Returns the HINSTANCE of the DLL designated to contain all resources. 
//
// This function requires that the first module loaded (whether it be a DLL or
// EXE) set the global variable hResourceModuleHandle to the HINSTANCE of the
// module (DLL or EXE) that contains all of the program's binary resources.
// This should be done as early as possible in the module's startup code.

HINSTANCE
GetResourceModuleHandle();



// a safe version of HRESULT_FROM_WIN32 that doesn't repeatedly evaluate
// it's arguement.  The problem with using the macro directly is that the
// argument -- the win32 error to convert -- will be evaluated more than
// once.  So, if you use an expression as the argument, at best you get
// an inefficiency, at worst you get unexpected side effects.

inline 
HRESULT
Win32ToHresult(DWORD win32Error)
{
   ASSERT(win32Error < 0xFFFF);

   // If win32Error is really an HRESULT, then this will preserve that 
   // HRESULT, rather than whack off the error code part and change the
   // facility code.  See winerror.h
   
   return HRESULT_FROM_WIN32(win32Error);
}



// unsigned version

inline 
HRESULT
Win32ToHresult(LONG win32Error)
{
   ASSERT(win32Error < 0xFFFF);
      
   return HRESULT_FROM_WIN32(win32Error);
}



inline
HRESULT
NtStatusToHRESULT(NTSTATUS status)
{
   return Win32ToHresult(::RtlNtStatusToDosError(status));
}



}  // namespace Burnslib



#endif   // COREUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\diagnosedcnotfound.h ===
// Copyright (C) 2000 Microsoft Corporation
//
// resources to be included in programs that use ShowDcNotFoundErrorDialog
//
// 9 October 2000 sburns


#define IDS_NO_ADDRESSES                     3201
#define IDS_ROOT_ZONE                        3202
#define IDS_DC_NOT_FOUND_DIAG_ERROR_CODE     3203
#define IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE 3204
#define IDI_BIGX                             3205
#define IDS_DC_NOT_FOUND_TIMEOUT             3206
#define IDC_DETAILS_BUTTON                   3207
#define IDC_DETAILS_TEXT                     3208
#define IDD_DC_NOT_FOUND                     3209
#define IDS_SHOW_DETAILS_LABEL               3210
#define IDS_GENERIC_DC_NOT_FOUND_PARAM       3211
#define IDC_ERROR_MESSAGE                    3212
#define IDS_DC_NOT_FOUND_DIAG_NO_RESULTS     3213
#define IDS_DC_NOT_FOUND_NETBIOS_PREFACE     3214
#define IDS_DC_NOT_FOUND_NAME_ERROR          3215
#define IDS_DC_NOT_FOUND_NO_RESULTS          3216   
#define IDS_DC_NOT_FOUND_NO_ERROR_1          3217
#define IDS_DC_NOT_FOUND_NO_ERROR_2          3218
#define IDS_DC_NOT_FOUND_DEFAULT             3219
#define IDS_HIDE_DETAILS_LABEL               3220
#define IDC_HORIZONTAL_LINE                  3221
#define IDS_DC_NOT_FOUND_TITLE               3222
#define IDS_DC_NOT_FOUND_SOOTHING_PREFACE_PARAM 3223
#define IDS_DC_NOT_FOUND_SOOTHING_PREFACE 3224
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\diagnosedcnotfound.hpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// diagnose domain controller not found problems, offer a popup dialog to
// assail the user with the results.
//
// 9 October 2000 sburns



#ifndef DIAGNOSEDCNOTFOUND_HPP_INCLUDED
#define DIAGNOSEDCNOTFOUND_HPP_INCLUDED




// Bring up a modal error message dialog that shows the user an error message
// and offers to run some diagostic tests and point the user at some help to
// try to resolve the problem.
// 
// parent - in, the handle to the parent of this dialog.
// 
// editResId - in, the resource id of the edit box that contains the domain
// name.  If -1 is passed, then this parameter is ignored.  Otherwise, when
// the dialog is closed, window messages will be sent to the control such that
// the contents will be selected.  It is assumed the control is a child of the
// window identified by the parent parameter.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  This name may be a DNS or netbios domain name.
// 
// dialogTitle - in, the title of the error dialog.
// 
// errorMessage - in, the error message to be displayed in the dialog
// 
// domainNameIsNotNetbios - in, if the caller knows that the domain named in
// the domainName parameter can't possibly be a netbios domain name, then this
// value should be true.  If the caller is not sure, then false should be
// passed.
//
// userIsDomainSavvy - in, true if the end user is expected to be an
// administrator or somesuch that might have an inkling what DNS is and how to
// configure it.  If false, then the function will preface the diagnostic text
// with calming words that hopefully prevent the non-administrator from
// weeping.

void
ShowDcNotFoundErrorDialog(
   HWND          parent,
   int           editResId,
   const String& domainName,
   const String& dialogTitle,
   const String& errorMessage,
   bool          domainNameIsNotNetbios,
   bool          userIsDomainSavvy = true);

  

#endif   // DIAGNOSEDCNOTFOUND_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\dllref.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// DLL object instance and server lock utility class
// 
// 8-19-97 sburns
// concept stolen from DavidMun, who stole it from RaviR, who ...



#ifndef __DLLREF_HPP_INCLUDED
#define __DLLREF_HPP_INCLUDED



// Maintains a instance counter and lock counter, with methods to manipulate
// both in a thread-safe fashion.   This is useful in implementing
// DllCanUnloadNow.
// 
// Each class that is instanciated and passed outside of the control of the
// DLL should contain an instance of ComServerReference.  This will automatically
// increment and decrement the ComServerLockState instance counter in step with the
// instance's lifetime.  Typically, this includes all class factory instances,
// and instances of classes that are created by those class factories.
// 
// Calls to a class factory's LockServer method should be deferred to
// this class.
// 
// Calls to DllCanUnloadNow should defer to this class' CanUnloadNow method.

class ComServerLockState
{
   public:

   static
   void
   IncrementInstanceCounter()
   {
      ::InterlockedIncrement(&instanceCount);
   }

   static
   void
   DecrementInstanceCounter()
   {
      ::InterlockedDecrement(&instanceCount);
   }

   static
   void
   LockServer(bool lock)
   {
      lock
      ? ::InterlockedIncrement(&lockCount)
      : ::InterlockedDecrement(&lockCount);
   }

   static
   bool
   CanUnloadNow()
   {
      return (instanceCount == 0 && lockCount == 0) ? true : false;
   }

   private:

   static long instanceCount;
   static long lockCount;

   // not implemented
   ComServerLockState();
   ComServerLockState(const ComServerLockState&);
   const ComServerLockState& operator=(const ComServerLockState&);
};  



class ComServerReference
{
   public:

   ComServerReference()
   {
      ComServerLockState::IncrementInstanceCounter();
   }

   ~ComServerReference()
   {
      ComServerLockState::DecrementInstanceCounter();
   }

   private:

   // not implemented; no instance copying allowed.
   ComServerReference(const ComServerReference&);
   const ComServerReference& operator=(const ComServerReference&);
}; 



#endif   // __DLLREF_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\dialog.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Dialog class
// 
// 10-15-97 sburns



#ifndef DIALOG_HPP_INCLUDED
#define DIALOG_HPP_INCLUDED



// Wraps a Windows dialog box, cracks and demuxes the dialog messages, and
// provides a mechanism for tracking the control IDs that have been touched
// over a given period.  Also provides what-is help.
//
// May only be used as a base class.

class Dialog
{
   public:

   // can't use an enum 'cause the type needs to be DWORD
   #define NO_HELP (static_cast<DWORD>(-1))
      
   // Executes the dialog modally via the Win DialogBox API.  Blocks until the
   // Win EndDialog API is called; returns the value passed to EndDialog.
   // Derived classes must call EndDialog in their message processing to
   // terminate the execution of the dialog.
   //
   // parent - handle to the parent window, which will be disabled during
   // the execution of the dialog.

   INT_PTR
   ModalExecute(HWND parent);

   INT_PTR
   ModalExecute(const Dialog& parent);

   // Executes the dialog box modelessly, returning immediately.  Derived
   // classes should call EndModelessExecution to close a Dialog executing
   // modelessly, or, destroy the Dialog instance.
   // 
   // Example:
   // 
   // MyFooDialog* dlg = new MyFooDialog(....);
   // dlg->ModlessExecute();
   // 
   // // ... later
   // 
   // dlg->EndModelessExecution();
   // 
   // // or just:
   // 
   // delete dlg;
   // 
   // parent - handle to the parent window of this dialog, for establishing
   // z-order.

   void
   ModelessExecute(HWND parent);

   void
   ModelessExecute(const Dialog& parent);

   // Terminates the modeless execution of a dialog that has been started
   // with ModalExecute.  It is illegal to call this method before calling
   // ModalExecute.

   void
   EndModelessExecution();

   // Returns the window handle of the dialog.  This method is only valid
   // after the window has been created and initialized by receiving
   // WM_INITDIALOG (which will be the case before any virtual message
   // handling functions are invoked).

   HWND
   GetHWND() const;

   // Returns the resource ID with which this instance was created.

   unsigned
   GetResID() const;

   // Returns a pointer to the Dialog instance that has been previously
   // stashed in the DWL_USER portion of the window structure.  This method is
   // only valid after the window has been created and initialized by
   // receiving WM_INITDIALOG (which will be the case before any virtual
   // message handling functions are invoked).
   // 
   // dialog - handle to initialized dialog window.

   static
   Dialog*
   GetInstance(HWND dialog);

   protected:

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // resID - resource identifier of the dialog template resource.
   // 
   // helpMap - array mapping dialog control IDs to context help IDs.  The
   // array must be in the following form:
   // {
   //    controlID1, helpID1,
   //    controlID2, helpID2,
   //    controlIDn, helpIDn,
   //    0, 0
   // }
   // 
   // To indicate that a control does not have help, the value of its
   // corresponding help ID should be NO_HELP.  This array is copied
   // by the constructor.

   Dialog(
      unsigned    resID,
      const DWORD helpMap[]);

   // Destroys an instance.  If the ModelessExecute method has been called,
   // and the EndModlessExecution method has not yet been called,
   // EndModelessExecution is called.

   virtual ~Dialog();

   // Resets the control ID change map.

   void
   ClearChanges();

   // Marks a control ID as changed.  Derived classes should call this from
   // their processing of OnCommand or OnNotify as appropriate to indicate
   // that a control has changed state.  This is useful for keeping track of
   // the fields in a database that need to be changed, etc.
   //
   // controlResID - the resource ID of the control that changed.

   void
   SetChanged(UINT_PTR controlResID);

   // Queries the control ID change map, returning true if the specified
   // control ID was previously marked as changed (with SetChanged), false
   // if not.
   //
   // controlResID - the resource ID of the control that changed.

   bool
   WasChanged(UINT_PTR controlResID) const;

   // Returns true if SetChanged was called for any control on the dialog,
   // false if not.

   bool
   WasChanged() const;

   // (For debugging) dumps the state of the control ID change map using
   // OutputDebugString.  For non-debug builds, a no-op.

   void
   DumpChangeMap() const;

   // Invoked upon receipt of WM_DESTROY.  The default implementation does
   // nothing.

   virtual
   void
   OnDestroy();

   // Invoked upon receipt of WM_COMMAND.  Derived class' implementation
   // should return true they handle the message, false if not.  The default
   // implementation returns false.
   //
   // windowFrom - the HWND of the child window (control) that originated the
   // message.
   // 
   // controlIDFrom - The resource ID of the child window corresponding to the
   // window indicated in the windowFrom parameter.   
   // 
   // code - the notification code.

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIdFrom,
      unsigned    code);

   // Invoked upon receipt of WM_INITDIALOG, after having set things up such
   // that GetHWND and GetInstance will work correctly.  The default
   // implementation does nothing.

   virtual
   void
   OnInit();

   // Invoked upon receipt of any window message that is not dispatched to
   // other member functions of this class, including user-defined messages.
   // Derived class' implementation should return true they handle the
   // message, false if not.  The default implementation returns false.
   // 
   // message - the message code passed to the dialog window.
   // 
   // wparam - the WPARAM parameter accompanying the message.
   // 
   // lparam - the LPARAM parameter accompanying the message.
   
   virtual
   bool
   OnMessage(
      UINT     message,
      WPARAM   wparam,
      LPARAM   lparam);

   // Invoked upon receipt of WM_NOTIFY.  Derived class' implementation should
   // return true they handle the message, false if not.  The default
   // implementation returns false.
   //
   // windowFrom - the HWND of the child window (control) that originated the
   // message.
   // 
   // controlIDFrom - The resource ID of the child window corresponding to the
   // window indicated in the windowFrom parameter.   
   // 
   // code - the notification code.
   //
   // lparam - the LPARAM parameter of the WM_NOTIFY message, which may,
   // depending on the window that originated the message, be a pointer to a
   // structure indicating other parameters to the notification.

   virtual
   bool
   OnNotify(
      HWND     windowFrom,
      UINT_PTR controlIDFrom,
      UINT     code,
      LPARAM   lparam);

   // Invoked upon receipt of WM_CTLCOLORDLG.  Derived class' implementation
   // should return a handle to a brush if they want to paint the dialog's 
   // background. It is the responsibility of the derived class to destroy 
   // the brush when it is no longer needed.
   // The default implementation returns NULL.
   //
   // deviceContext - the device context of the dialog box
   // 
   // dialog - the HWND of the dialog box

   virtual
   HBRUSH
   OnCtlColorDlg(
      HDC   deviceContext, 
      HWND  dialog);

   // Invoked upon receipt of WM_CTLCOLORSTATIC.  Derived class' implementation
   // should return a handle to a brush if they want to paint the dialog's 
   // background. It is the responsibility of the derived class to destroy the 
   // brush when it is no longer needed.
   // The default implementation returns NULL.
   //
   // deviceContext - the device context of the dialog box
   // 
   // dialog - the HWND of the dialog box

   virtual
   HBRUSH
   OnCtlColorStatic(
      HDC   deviceContext, 
      HWND  dialog);

   // Invoked upon receipt of WM_CTLCOLOREDIT.  Derived class' implementation
   // should return a handle to a brush if they want to paint the dialog's 
   // background. It is the responsibility of the derived class to destroy the 
   // brush when it is no longer needed.
   // The default implementation returns NULL.
   //
   // deviceContext - the device context of the dialog box
   // 
   // dialog - the HWND of the dialog box

   virtual
   HBRUSH
   OnCtlColorEdit(
      HDC   deviceContext, 
      HWND  dialog);

   // Invoked upon receipt of WM_CTLCOLORLISTBOX.  Derived class' implementation
   // should return a handle to a brush if they want to paint the dialog's 
   // background. It is the responsibility of the derived class to destroy the 
   // brush when it is no longer needed.
   // The default implementation returns NULL.
   //
   // deviceContext - the device context of the dialog box
   // 
   // dialog - the HWND of the dialog box

   virtual
   HBRUSH
   OnCtlColorListbox(
      HDC   deviceContext, 
      HWND  dialog);

   // Invoked upon receipt of WM_CTLCOLORSCROLLBAR.  Derived class' implementation
   // should return a handle to a brush if they want to paint the dialog's 
   // background. It is the responsibility of the derived class to destroy the 
   // brush when it is no longer needed.
   // The default implementation returns NULL.
   //
   // deviceContext - the device context of the dialog box
   // 
   // dialog - the HWND of the dialog box

   virtual
   HBRUSH
   OnCtlColorScrollbar(
      HDC   deviceContext, 
      HWND  dialog);

   // Stores the window handle of the dialog in this instance, so that it can
   // be later retrieved by GetHWND.  This is typically called by derived
   // classes that are doing their own processing of WM_INITDIALOG.  This
   // function may be legally called only once in the lifetime of any Dialog
   // instance.
   // 
   // window - handle to the dialog window.

   void
   SetHWND(HWND window);

   // The window handle of corresponding to this instance.  Only valid after
   // WM_INITDIALOG has been received.

   HWND hwnd;

   // accessible to PropertyPage, etc.

   static
   INT_PTR CALLBACK
   dialogProc(HWND dialog, UINT message, WPARAM wparam, LPARAM lparam);

   private:

   // not implemented: no copying allowed
   Dialog(const Dialog&);
   const Dialog& operator=(const Dialog&);

   typedef
      std::map<
         UINT_PTR,
         bool,
         std::less<UINT_PTR>,
         Burnslib::Heap::Allocator<bool> >
      ChangeMap;

   // 'mutable' required for non-const map<>::operator[].  
   mutable ChangeMap changemap;
   DWORD*            helpMap;
   bool              isEnded;
   bool              isModeless;
   unsigned          resID;
};



#endif   // DIALOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\encryptedstring.hpp ===
// Copyright (c) 2002 Microsoft Corporation
// 
// Encrypted string class
// 
// 18 March 2002 



#ifndef ENCRYPTEDSTRING_HPP_INCLUDED
#define ENCRYPTEDSTRING_HPP_INCLUDED



// A class that has a similar public interface as class Burnslib::String, but
// is represented as an encrypted blob, produced by CryptProtectMemory.
// 
// This class can be used to represent sensitive data like password strings
// in-memory, instead of holding them as cleartext, which is a security hole
// if the memory pages are swapped to disk, the machine is hibernated, etc.
// 
// You should convert any cleartext data into an instance of this class, then
// scribble out your cleartext source copy with SecureZeroMemory.

class EncryptedString
{
   public:

   // no string may be longer than this many characters, not including the
   // terminating null, or it will be truncated.
   
   static const size_t MAX_CHARACTER_COUNT = 1024 * 2 - 1;


   
   // constructs an empty string.

   explicit
   EncryptedString();


   
   // constructs a copy of an existing, already encoded string

   EncryptedString(const EncryptedString& rhs);



   // scribbles out the text, and deletes it.
   
   ~EncryptedString()
   {
      // when the object dies, it had better not have any outstanding
      // cleartext copies.
      
      ASSERT(cleartextCopyCount == 0);
      
      Reset();
   }



   // disposes of the encrypted text, and sets the string to be empty.
   
   void
   Clear()
   {
      // when the object dies, it had better not have any outstanding
      // cleartext copies.
      
      ASSERT(cleartextCopyCount == 0);

      Reset();
   }


   // Scribbles out and de-allocates a clear text copy of the string. The
   // caller is required to balance each call to GetClearTextCopy with a call
   // to DestroyClearTextCopy lest he leak memory and leave cleartext hanging
   // around.
   // 
   // cleartext - the same pointer returned by a previous call to
   // GetClearTextCopy on the same instance.
   
   void
   DestroyClearTextCopy(WCHAR* cleartext) const;

   

   // thrown by GetClearTextCopy if decryption fails.
   
   class DecryptionFailureException
   {
      public:

      DecryptionFailureException()
      {
      }
   };

   
         
   // Extracts the decoded cleartext representation of the text, including
   // null terminator.  The caller must invoke DestroyClearTextCopy on the
   // result, even if the result is null.
   //
   // Throws a DecryptionFailureException on failure.
   //
   // Example:
   // WCHAR* cleartext = encoded.GetDecodedCopy();
   // if (cleartext)
   // {
   //    // ... use the cleartext
   // }
   // encoded.DestroyClearTextCopy();
   
   WCHAR* 
   GetClearTextCopy() const;


   
   // Returns true if the string is zero-length, false if not.
   
   bool
   IsEmpty() const
   {
      return (GetLength() == 0);
   }



   // Sets the contents of self to the encoded representation of the
   // cleartext, replacing the previous value of self.  The encoded
   // representation will be the same length, in characters, as the
   // cleartext.
   //
   // clearText - in, un-encoded text to be encoded.  May be empty string,
   // but not a null pointer.
   
   void
   Encrypt(const WCHAR* cleartext);
      

   
   // Returns the length, in unicode characters, of the cleartext, not
   // including the null terminator.

   size_t
   GetLength() const;


   
   // Replaces the contents of self with a copy of the contents of rhs.
   // Returns *this.
   
   const EncryptedString&
   operator= (const EncryptedString& rhs);



   // Compares the cleartext representations of self and rhs, and returns
   // true if they are lexicographically the same: the lengths are the same
   // and all the characters are the same.
      
   bool
   operator== (const EncryptedString& rhs) const;



   bool
   operator!= (const EncryptedString& rhs) const
   {
      return !(operator==(rhs));
   }
   

   
   private:

   
   void
   Clone(const EncryptedString& rhs);

   void
   Init(const WCHAR* clearText);

   WCHAR*
   InternalDecrypt() const;
   
   void
   InternalDestroy(WCHAR* cleartext) const;
   
   void
   Reset();

   
      
   // We deliberately do not implement conversion to or from WCHAR* or
   // String.  This is to force the user of the class to be very deliberate
   // about decoding the string.  class String is a copy-on-write shared
   // reference implementation, and we don't want to make it easy to create
   // "hidden" copies of cleartext, or move from one representation to
   // another, or accidentally get a string filled with encrypted text.

   // deliberately commented out
   // explicit
   // EncryptedString(const String& cleartext);

   // deliberately commented out
   // operator WCHAR* ();
   // operator String ();



   size_t clearTextLength;
   
   // In the course of en[de]crypting, and assigning to the instance, we
   // may reallocate the memory pointed to here, but logically the string
   // is still "const"   

   mutable WCHAR* cypherText;
   
   // a logically const instance may have cleartext copies made

   mutable int cleartextCopyCount;

   // indicates that the encryption worked.
   
   bool isEncrypted;
};



#endif   // ENCRYPTEDSTRING_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\dns.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DNS API wrappers
//
// 12-16-97 sburns



#ifndef DNS_HPP_INCLUDED
#define DNS_HPP_INCLUDED



// A collection of DNS related names.

namespace Dns
{
   // the number of bytes in a full DNS name to reserve for stuff
   // netlogon pre-/appends to DNS names when registering them

   const size_t SRV_RECORD_RESERVE = 100;



   // the max lengths, in bytes, of strings when represented in the UTF-8
   // character set.  These are the limits we expose to the user

   const size_t MAX_NAME_LENGTH = DNS_MAX_NAME_LENGTH - SRV_RECORD_RESERVE;
   const size_t MAX_LABEL_LENGTH = DNS_MAX_LABEL_LENGTH;



   // Compares DNS names with DnsNameCompareEx (see private\inc\dnsapi.h),
   // returning the result.

   DNS_NAME_COMPARE_STATUS
   CompareNames(const String& dnsNameLeft, const String& dnsNameRight);



   // Returns the name of the parent DNS domain.  E.g. if "foo.bar.com" is
   // passed, then "bar.com" is the result.  If "com" is passed, then "."
   // (the root zone) is the result.
   //
   // domainName - the name of the domain
   
   String
   GetParentDomainName(const String& domainName);

   

   // Returns corresponding NetBIOS name, or empty string if mapping failed.
   // Not for domain names -- just computer names!
   // 
   // hostname - the name to be mapped to a NetBIOS name.  This name must be a
   // valid DNS name.
   //
   // err - ptr to a variable that will accept the win error code returned if
   // the conversion fails.  If the conversion fails, the return value is
   // the empty string.

   String
   HostnameToNetbiosName(const String& hostname, HRESULT* err=0);



   // returns true if the DNS client is configured, false if not.

   bool
   IsClientConfigured();



   // returns true if the Microsoft DNS server is installed on this computer,
   // false if not.

   bool
   IsServiceInstalled();



   // returns true if the Microsoft DNS server is currently running on this
   // computer, false if not.

   bool
   IsServiceRunning();



   enum ValidateResult
   {
      VALID,
      INVALID,
      NON_RFC,
      TOO_LONG,
      NUMERIC,
      BAD_CHARS
   };

   // Validates a single DNS label for proper length (in the UTF-8
   // character set) and syntax.
   //
   // candidateDNSLabel - the label to be validated

   ValidateResult
   ValidateDnsLabelSyntax(const String& candidateDNSLabel);



   // Validates the format, not the existence, of a DNS name.  Checks for
   // proper length in the UTF-8 character set, and proper syntax.
   //
   // candidateDNSName - in, the DNS name to verify.
   //
   // maxUnicodeCharacters - in, maximum number of uncode characters to
   // allow in the name.  If the name contains more characters than this,
   // TOO_LONG is returned.
   //
   // maxUTF8Bytes - in, maximum number of bytes allowed to represent the name
   // in the UTF-8 character set.  Since a unicode character requires at
   // least one byte in UTF-8, this value must be >= maxUnicodeCharacters.

   ValidateResult
   ValidateDnsNameSyntax(
      const String&  candidateDNSName,
      size_t         maxUnicodeCharacters = Dns::MAX_NAME_LENGTH,
      size_t         maxUTF8Bytes = Dns::MAX_NAME_LENGTH);
}



DNS_STATUS
MyDnsValidateName(const String& name, DNS_NAME_FORMAT format);



String
MyDnsStatusString(DNS_STATUS status);



// caller must free the result with MyDnsRecordListFree

DNS_STATUS
MyDnsQuery(
   const String& name,
   WORD          type,
   DWORD         options,
   DNS_RECORD*&  result);



void
MyDnsRecordListFree(DNS_RECORD* rl);


#endif   // DNS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\dsutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS utility functions
//
// 3-11-99 sburns



#ifndef DSUTIL_HPP_INCLUDED
#define DSUTIL_HPP_INCLUDED



// Returns true if the dcpromo wizard UI is running on the local machine,
// false if not.

bool
IsDcpromoRunning();



// Returns true if a domain controller for the domain can be contacted, false
// if not.

bool
IsDomainReachable(const String& domainName);



// Returns true if the directory service is running on this computer, false
// if not.

bool
IsDSRunning();



// Caller must unbind the handle with DsUnbind

HRESULT
MyDsBind(const String& dcName, const String& dnsDomain, HANDLE& hds);



// username may be empty, which means use null, default credentials

HRESULT
MyDsBindWithCred(
   const String&          dcName,    
   const String&          dnsDomain, 
   const String&          username,  
   const String&          userDomain,
   const EncryptedString& password,  
   HANDLE&                hds);



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcName(
   const TCHAR*               machine,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info);



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcNameWithAccount(
   const TCHAR*               machine,
   const String&              accountName,
   ULONG                      allowedAccountFlags,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info);



// Caller needs to delete info with (My)DsFreeDomainControllerInfo

HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W*&   info);



// Caller needs to delete info with (My)DsFreeDomainControllerInfo

HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W*&   info);



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W* info);



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W* info);


// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info);



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_OPERATION_STATE_INFO*& info);



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_UPGRADE_STATUS_INFO*&  info);



#endif   // DSUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\error.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// abstract pure virtual base class for all Error objects,
// defining the services all Error objects must supply.
// 
// 8-14-97 sburns



#ifndef ERROR_HPP_INCLUDED
#define ERROR_HPP_INCLUDED



// this really could be anything.  Someday I might actually use this
// HelpContext stuff.

typedef LONG_PTR HelpContext;



// class Error is a pure virtual base class used to encapsulate error
// information in to a single unit which may participate in exception
// handling or be passed between functions in lieu of a simple error
// code. 
// 
// It is the base class of a taxonomy of Error classes.  Rather than
// attempt to reuse an existing type, a new component should consider
// defining a new type suitable for the semantics of that component's
// function.  (implementation, of course, can be re-used). Introducing
// types in this fashion facilitates selection of error handlers in a
// try..catch blocks, beyond the OO-wholesomeness of the practice.
// 
// Another characteristic of this abstraction is the ability to
// support cross-locale exception propagation.  This is the problem
// where an exception is thrown in a system which is in a different
// locale than the system catching the exception.  A remoteable
// implementation of this class could account for crossing locales (by
// utilizing locale-independent representations of the error, and
// providing translation capabilities for each supported locale, for
// instance).
// 
// At some point in the future, this class could subclass
// std::exception in some useful way, when the semantics of the C++
// exception hierarchy finally stabilize in practice.

class Error
{
   public:

//    // Error::Details expresses the truly gritty bits of an occurrence
//    // of an error, which user interfaces may or may not wish to expose
//    // to the end user.
// 
//    class Details
//    {
//       public:
// 
//       // Constructs an instance.
//       // 
//       // body - The gritty details text.
//       // 
//       // fileName - The source file of the code that produced the
//       // error
//       // 
//       // lineNumber - The location within the source file of the code
//       // that produced the error.
// 
//       Details(
//          const String&  body,
//          const String&  fileName,
//          unsigned       lineNumber);
// 
//       // default dtor, copy ctor, op= used.  This class is cheap to
//       // copy
// 
//       // Returns the body text with which the instance was created.
// 
//       String
//       GetBody() const;
// 
//       // Returns the file name with which the instance was created.
// 
//       String
//       GetFileName() const;
// 
//       // Returns the line number with which the instance was created.
// 
//       unsigned
//       GetLineNumber() const;
// 
//       private:
//      
//       String  body_;
//       String  file;
//       int     line;
//    };

   // a pure virtual dtor ensures abstractness
   virtual ~Error() = 0;

//    // return a Details object containing additional trivia, such as
//    // context information.
// 
//    virtual 
//    Details
//    GetDetails() const = 0;

   // return the HelpContext that will point the user to assistance
   // in deciphering the error message and details.

   virtual 
   HelpContext
   GetHelpContext() const = 0;

   // return the human readable error message.

   virtual 
   String
   GetMessage() const = 0;

   // return a 1-line summary: The essence of the error, suitable for
   // use as the title of a reporting dialog, for instance.

   virtual 
   String
   GetSummary() const = 0;
};



#endif   // ERROR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\extract.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// class Extractor
// 
// 11-12-97 sburns



#ifndef EXTRACT_HPP_INCLUDED
#define EXTRACT_HPP_INCLUDED



// Extractor encapsulates clipboard extraction buffers, allocating and
// initializing them upon construction, deallocating them upon deletion. By
// keeping a single (static) instance of an Extractor around, one can avoid
// allocation/deallocation for each extraction operation, and be assured that
// cleanup occurs properly.

class Extractor
{
   protected:

   // Creates a new instance.  Declared protected so as to function only 
   // as a base class.
   //
   // clipFormatID - clipboard format ID returned from Win
   // RegisterClipboardFormat.
   // 
   // bufSize - the buffer size, in bytes, required to extract the data in the
   // clipboard format expressed by the clipFormatID parameter.

   Extractor(CLIPFORMAT clipFormatID, size_t bufSize);

   virtual ~Extractor();

   // Calls GetDataHere on the data object, returning a pointer to the buffer
   // if the call was successful, or 0 if the call failed.  The invoker should
   // NOT free the returned HGLOBAL, as this is managed by the object.
   // 
   // dataObject - the data object from which the clipboard data should be
   // extracted.

   HGLOBAL
   ExtractData(IDataObject& dataObject);

   private:

   // not implemented: no copying allowed
   
   Extractor(const Extractor&);
   const Extractor& operator=(const Extractor&);

   FORMATETC formatetc;
   STGMEDIUM stgmedium;
   size_t    bufSize;
};



#endif   // EXTRACT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\filesys.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// File System services.
//
// 8-14-97 (sburns)
      


#ifndef FILESYS_HPP_INCLUDED
#define FILESYS_HPP_INCLUDED



// CODEWORK: remove exceptions in favor of an HRESULT orientation.


namespace Burnslib
{
   
namespace FS
{
   // Facilitates walking a directory tree.

   // CODEWORK: add methods to extract current file data beyond just the
   // name.

   class Iterator
   {
      public:

      enum 
      {
         INCLUDE_FILES     = 0x0001,
         INCLUDE_FOLDERS   = 0x0002,
         INCLUDE_DOT_PATHS = 0x0004,

// CODEWORK:
//         EXPAND_SUBDIRS      = 0x0008,

         RETURN_FULL_PATHS = 0x0010
      };

      // Constructs a new instance of an Iterator.
      // 
      // startingPathSpec - fully-qualified path specification of the
      // files/directories to be iterated upon.  A wildcard
      // specification is allowed at the end of the path.  E.g.
      // "C:\dir\*.txt"
      // 
      // (Without a wildcard expression of some kind, the iteration set will
      // be the single file or folder that matches startingPathSpec.  This set
      // may be further reduced to the empty set if the optionMask eliminates
      // the single match.)
      // 
      // optionMask - Options, OR'ed together.

      explicit
      Iterator(
         const String&  startingPathSpec,
         unsigned       optionMask =
               INCLUDE_FILES
            |  INCLUDE_FOLDERS
            |  INCLUDE_DOT_PATHS
            /* | EXPAND_SUBDIRS */
            |  RETURN_FULL_PATHS);

      ~Iterator();

      // Restores the iterator to the state that it had upon
      // construction. 

      void
      Reset();

      // Retrieve the name of the file at the current iterator position.  If
      // the iterator was constructed with the RETURN_FULL_PATHS Option, then
      // the returned string is a fully-qualified path, instead of a path
      // relative to the starting path the Iterator was constructed with.
      // Returns S_OK on success, S_FALSE if the iteration is empty (there are
      // no files), or an error code.
      // 
      // If AtEnd() is true, then the empty string is returned.
      //
      // result - receives the file path at the current position of the
      // iterator, or the empty string if the iteration set is empty, or
      // an error occurred.

      HRESULT
      GetCurrent(String& result);

      // Move the current position to the next file, according to the
      // iterator filtering options.  May cause the iterator to become
      // invalid, which can be tested with AtEnd().  Returns S_OK on success
      // S_FALSE when the iteration is complete, or an error code.

      HRESULT
      Increment();

      private:

      WIN32_FIND_DATA*  findData;
      HANDLE            findHandle;
      bool              finished;
      unsigned          options;
      String            parentFolder;
      String            startSearchSpec;

      void
      Finish();

      bool
      IsNotStarted();

      String
      ReturnPath();

      bool
      ShouldSkipCurrent();

      HRESULT
      Start();

      HRESULT
      SkipFilteredPaths();

      // copying not implemented in the interest of simplicity (could be done
      // in theory)

      Iterator(const Iterator&);
      const Iterator& operator=(const Iterator&);
   };



   // Simple file-to-file copy.
   //   
   // sourceFile - Fully-qalified path of the file to be copied.  This
   // path must reference an existing file.
   // 
   // destinationFile - Fully-qualified path of the file to be
   // created.  This file is always overwritten, if it exists.  All
   // intermediate subdirectories required are created.
   // 
   // progressCallback - Callback object to receive progress
   // notifications.  The param argument to the callback's Execute
   // method will be an instance of CopyCallbackParam.  The method
   // should return !0 to abort the copy.

   struct CopyCallbackParam
   {
      String         sourceFile;
      String         destinationFile;
      int            percentCopied;
   };

   HRESULT
   CopyFile(
      const String&  sourceFile,
      const String&  destinationFile,
      Callback*      progressCallback);



   // Creates a directory, including all intermediate subdirectories,
   // as necessary.  Returns S_FALSE if the path already exists.
   //
   // path - Fully-qualified path to be created.  It must not
   // already exist.

   HRESULT
   CreateFolder(const String& path);



   // Opens a file for shared read/write access with normal attributes,
   // creating it if it does not already exist.
   // 
   // path - Fully-qualified path of file to open.  If path doesn't
   // exist, it is created, including intermediate subdirectories.
   //
   // result - receives the resulting file handle, on success.  On falure,
   // this is set to INVALID_HANDLE_VALUE
   //
   // REVIEWED-2002/02/26-sburns we require full absolute or unc file paths,
   // else we assert and return E_INVALIDARG.

   HRESULT
   CreateFile(
      const String&  path,
      HANDLE&        result,
      DWORD          desiredAccess,
      DWORD          shareMode           = 0,

      // we don't require all callers to specify an SD in case the call 
      // just to open the file.
            
      DWORD          creationDisposition = OPEN_ALWAYS,
      DWORD          flagsAndAttributes  = FILE_ATTRIBUTE_NORMAL);



   // Deletes a file. Returns S_OK on success, or an error code on failure.
   // 
   // path - Fully-qualified path of file to delete.

   HRESULT
   DeleteFile(const String&  path);



   // Splits a fully-qualified path into its constituent parts.
   //          
   // drive - receives the volume portion (in the form "X:")
   //       
   // parentFolderPath - receives the path of the folder containing the leaf
   // file or folder.
   //      
   // leafName - receives the base name of the last file or folder on the
   // path.
   //
   // extension - receives the extension, of the last file or folder on the
   // path, including the dot (".ext")

   void
   SplitPath(
      const String&  fullpath,
      String&        drive,
      String&        parentFolderPath,
      String&        leafName,
      String&        extension);


   // Appends an unqualified relative path (i.e.  system32\cys.exe) to the
   // the base path supplied and returns the full path.  A '\' will be added
   // between the parts if needed.  If the base path is not normalized the
   // result will not be normalized either.
   //
   // base - fully-qualified path which will be appended to
   //
   // additional - unqualified relative path which will be appended
   
   String
   AppendPath(
      const String& base, 
      const String& additional);

   // Returns the leaf portion of a fully-qualified path, including the
   // extension.  The path may refer to either a file or a folder.  For
   // example, "x:\foo\bar.ext" returns "bar.ext"
   //   
   // fullpath - fully-qualified filename.

   String
   GetPathLeafElement(const String& fullpath);



   // Removes the last component of a fully-qualified file name or folder
   // name. Includes trailing path separator only if the parent folder is the
   // root folder on a volume.
   //
   // e.g. "x:\foo" returns "x:\", but "x:\foo\bar" returns "x:\foo" (not
   // "x:\foo\")
   //
   // fullpath - fully-qualified filename.

   String
   GetParentFolder(const String& fullpath);



   // Returns the available space, in bytes, to the current user of the
   // calling thread (i.e. takes into account user quotas)
   // 
   // path - Fully-qualified path of file/directory for which attributes will
   // be retrieved.  This need not be the root directory of the volume in
   // question.
   //
   // result - receives the result, the available space in bytes.  Set to
   // 0 on error.
   
   HRESULT
   GetAvailableSpace(const String& path, ULONGLONG& result);



   // Returns the root folder path of the given full path, e.g. for
   // "C:\foo\bar" returns "C:\"
   //
   // fullpath - Fully-qualified path of file/directory

   String
   GetRootFolder(const String& fullpath);



   // Reports the current position of the file read/write pointer.  Returns
   // S_OK on success, or an error code on failure.
   //
   // handle - valid handle to an opened file
   //
   // result - receives the file position, set to 0 on error

   HRESULT
   GetFilePosition(HANDLE handle, LONGLONG& result);



   // Returns the total size, in bytes, of the file opened on the provided
   // handle.
   //
   // handle - valid handle to an opened file
   //
   // result - receives the file size, or 0 on error.

   HRESULT
   GetFileSize(HANDLE handle, LONGLONG& result);



   // Returns the type of the file system of the volume on which the path
   // refers.  Non-existant paths are considered to have the FAT file system.
   //
   // path - fully-qualified path, which contains the drive letter of the
   // volume

   // CODEWORK: how does this behave in the presence of mount points?  For
   // example, what if a FAT volume is mounted as a subdirectory of an
   // NTFS volume?

   enum FSType
   {
      FAT,
      CDFS,
      NTFS4,
      NTFS5
   };

   FSType
   GetFileSystemType(const String& path);



   enum PathSyntax
   {
      SYNTAX_ABSOLUTE_DRIVE,              // d:\foo\bar 
      SYNTAX_ABSOLUTE_DRIVE_WILDCARD,     // d:\foo\*.*
      SYNTAX_ABSOLUTE_NO_DRIVE,           // \foo\bar
      SYNTAX_ABSOLUTE_NO_DRIVE_WILDCARD,  // \foo\*.*
      SYNTAX_RELATIVE_DRIVE,              // d:foo\bar
      SYNTAX_RELATIVE_DRIVE_WILDCARD,     // d:foo\*.*
      SYNTAX_RELATIVE_NO_DRIVE,           // foo\bar
      SYNTAX_RELATIVE_NO_DRIVE_WILDCARD,  // foo\*.*
      SYNTAX_UNC,                         // \\machine\share
      SYNTAX_UNC_WILDCARD,                // \\machine\share\*.*
      SYNTAX_UNRECOGNIZED
   };

   // Parses the supplied string an attempts to validate its syntax.  The
   // string need not refer to an existing file or directory.
   // 
   // str - the string to be analysed.

   PathSyntax
   GetPathSyntax(const String& str);



   // Populates the given DriveList with elements representing the valid
   // drive letters on the local machine.  Each element is a string of the
   // form "X:" where X is a drive letter.
   //
   // BackInsertableContainer - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // bii - a reference to a back_insert_iterator of the
   // BackInsertableContainer template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // hr = FS::GetValidDrives(std::back_inserter(container));
   //
   // StringVector container2;
   // hr = FS::GetValidDrives(std::back_inserter(container2));

   template <class BackInsertableContainer>
   HRESULT
   GetValidDrives(std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      HRESULT hr = S_OK;
      WCHAR* buf = 0;
      do
      {
         // first call determines the size of the buffer we need.

         DWORD bufchars = 0;
         hr = Win::GetLogicalDriveStrings(0, 0, bufchars);
         BREAK_ON_FAILED_HRESULT(hr);

         // add 1 for extra-safe null terminator

         ++bufchars;
         buf = new WCHAR[bufchars];
         ::ZeroMemory(buf, bufchars * sizeof WCHAR);

         // second call actually retrieves the strings

         DWORD unused = 0;
         hr = Win::GetLogicalDriveStrings(bufchars - 1, buf, unused);
         BREAK_ON_FAILED_HRESULT(hr);

         // walk thru buf and chop it into substrings.
         
         for (

         // ISSUE-2002/02/22-sburns consider using safe version of wcschr, if
         // there is one
         
            WCHAR* sub = wcschr(buf, 0), *buf2 = buf;
            sub && buf2 && buf2[0];
            buf2 = sub + 1, sub = wcschr(buf2, 0))
         {
             *bii++ = buf2;
         }
      }
      while (0);

      delete[] buf;

      return hr;
   }



   // Wrapper of the Win32 API of the same name
   //
   // path - Fully-qualified path.  This path need not exist.

   HRESULT
   GetVolumePathName(const String& path, String&);



   // Returns true if the path refers to an empty or non-existent directory.
   //
   // path - Fully-qualified path 

   bool
   IsFolderEmpty(const String& path);



   // Returns true if parent is the name of a parent directory of the given
   // child directory, false if not.  A parent directory is defined as one
   // that appears closer to the root than a child on the same branch.  A
   // parent may be any superior directory (e.g. grandparent,
   // great-grandparent), not just the immediate superior.
   // 
   // parent - valid, fully-qualified path of supposed parent directory.  Need
   // not exist.
   // 
   // child - valid, fully-qualified path of child directory.  Need not exist.

   bool
   IsParentFolder(const String& parent, const String& child);



   // Checks the validity, but not the existence of, the specified
   // file or directory.  the path must be absolute and include the
   // drive specifier.
   //
   // path - Fully-qualified path.

   bool
   IsValidPath(const String& path);



   // Moves or renames an existing file or directory.
   //
   // sourcePath - Fully-qualified path of the file/directory to be
   // moved/renamed. This file or directory must exist.  If the path refers to
   // a directory, the directory and all of its children are moved.
   //
   // destinationPath - Fully-qualified path of the destination
   // file/directory.  This path need not be on the same volume as the
   // sourcePath, but if it is not, the move will result in a recursive copy
   // of the sourcePath.
   //
   // replaceExisting - If the destinationPath refers to an existing
   // file/directory, and this parameter is true, the destinationPath is
   // overwritten.  Otherwise, if the destinationPath exists, an error is
   // returned.

   HRESULT
   MoveFile(
      const String&  sourcePath,
      const String&  destinationPath);

// CODEWORK:
//      bool           replaceExisting = false);



   // "Normalize" a path by parsing any relative path components (like . and
   // ..), and return the resulting path.  If there are no relative
   // components, or if an error occurred, return the same string as the
   // input.
   // 
   // The result is not guaranteed to be syntactically correct, or to refer to
   // and existing file. For that, use IsValidPath() and PathExists()
   // 
   // Example:
   // L"c:\\.\\.\\..\\.\\temp\\.\\foo\\bar\\..\\baz" results in
   // L"c:\\temp\\foo\\baz"
   //    
   // abnormalPath - path to parse.

   String
   NormalizePath(const String& abnormalPath);



   // Returns true if the specified file or directory exists.
   //
   // path - Fully-qualified path.

   bool
   PathExists(const String& path);



   // Returns true if the specified file exists, i.e. the path exists and
   // it refers to a file (as opposed to a folder)

   bool
   FileExists(const String& filePath);
   


   // Reads bytes from the current file pointer of the handle as Unicode
   // text (2 bytes/character).
   //    
   // handle - valid, open file handle, with read/write pointer positioned
   // to the first byte of the first character to be read.
   //    
   // charactersToRead - number of characters to read.  -1 to read all
   // characters up to the end of the file or the first null character
   // encountered.  If this number would cause a read past the end of the
   // file, or past a null character, the read will stop at the end of the
   // file or null character.  In the case of a null character, the file
   // read/write pointer will be positioned at the byte following the null
   // character.
   // 
   // text - the characters read.  A truncated read operation can be detected
   // by comparing the length of this string to the charactersToRead
   // parameter.

   HRESULT
   Read(HANDLE handle, int charactersToRead, String& text);



   // Reads bytes from the current file pointer of the handle as ANSI
   // text.
   //
   // handle - valid, open file handle, with read/write pointer positioned
   // to the first byte of the first character to be read.
   //
   // bytesToRead - count of the number of bytes (*NOT* characters) to read
   //
   // text - the bytes read.

   HRESULT
   Read(HANDLE handle, int bytesToRead, AnsiString& text);



   // Positions the file read/write pointer.
   //
   // handle - Valid, open file handle.
   //
   // position - new position of the pointer, from the beginning of the
   // file.

   HRESULT
   Seek(HANDLE handle, LONGLONG position);



   // Moves the file read/write pointer to the end of the file.
   // 
   // handle - Valid, open file handle.

   HRESULT
   SeekToEnd(HANDLE handle);



   // Writes the supplied string as Unicode text to the file.
   // 
   // handle - Valid, open file handle.
   //
   // text - the text to be written

   HRESULT
   Write(HANDLE handle, const String& text);



   // appends a crlf

   HRESULT
   WriteLine(HANDLE handle, const String& text);




   // Writes the supplied buffer to the file.
   //
   // handle - Valid, open file handle.
   //
   // buf - buffer to write.  This is an instance of basic_string<char>

   HRESULT
   Write(HANDLE handle, const AnsiString& buf);



   // appends a crlf

   HRESULT
   WriteLine(HANDLE handle, const AnsiString& text);
}

}





#endif   // FILESYS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\mem.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// memory management stuff
//
// 7-30-98 sburns



namespace Burnslib
{

namespace Heap
{
   // cause calls to new to capture the call stack at the point of
   // allocation.

   const WORD TRACE_ALLOCATIONS = (1 << 6);


   void
   DumpMemoryLeaks();



   // called by the InitializationGuard.  Read flags from registry,
   // sets heap options.

   void
   Initialize();



   // our replacement operator new implementation

   void*
   OperatorNew(size_t size, const char* file, int line)
   throw (std::bad_alloc);



   // ... and the corresponding replacement operator delete
   // implementation

   void
   OperatorDelete(void* ptr)
   throw ();

}  // namespace Heap

}  // namespace Burnslib



// Replace the global new and delete operators.
//
// If the allocation fails, the user is given a system modal retry/cancel
// window.  If the user opts for retry, re-attempt the allocation.  Otherwise
// throw bad_alloc.
//
// Note that the CRT heap APIs are used, and that the debug heap APIs are
// also available.  This implies that other modules linking to the same CRT
// dll can install hooks that may break our implementation!


//lint -e(1727) ok that our re-definition is inline

inline
void* __cdecl
operator new(size_t size)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, 0, 0);
}



//lint -e(1548) ok that our redefinition throw spec doesn't match the CRT

inline
void* __cdecl
operator new[](size_t size)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, 0, 0);
}



// placement versions of operator new.  Although we use the placement syntax,
// we use the additional parameters to record debug information about the
// allocation, rather than indicating a location to allocate memory.

inline
void* __cdecl
operator new(size_t size, const char* file, int line)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, file, line);
}



inline
void* __cdecl
operator new[](size_t size, const char* file, int line)
throw (std::bad_alloc)
{
   return Burnslib::Heap::OperatorNew(size, file, line);
}



inline
void __cdecl
operator delete(void* ptr)
throw ()
{
   // check for 0, since deleting the null pointer is legal.

   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



inline
void __cdecl
operator delete[](void* ptr)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



// placement versions of operator delete.  We must provide placement versions
// of operator delete with corresponding signatures to the placement versions
// of operator new that we have declared, even though we don't use those
// parameters.

inline
void __cdecl
operator delete(void* ptr, const char*, int)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



inline
void __cdecl
operator delete[](void* ptr, const char*, int)
throw ()
{
   if (ptr)
   {
      Burnslib::Heap::OperatorDelete(ptr);
   }
}



namespace Burnslib
{

namespace Heap
{
   // An STL-compatible allocator class that uses our replacement new
   // and delete operators.  We define this class after redefining our
   // operator new and delete, above, so that it uses our redefinition.
   // @@ (is that necessary, as construct uses placement new?)

   template <class T>
   class Allocator
   {
      public:

      typedef size_t    size_type;
      typedef ptrdiff_t difference_type;
      typedef T*        pointer;
      typedef const T*  const_pointer;
      typedef T&        reference;
      typedef const T&  const_reference;
      typedef T         value_type;

      pointer
      address(reference x) const
      {
         return &x;
      }

      const_pointer
      address(const_reference x) const
      {
         return &x;
      }

      // allocate enough storage for n elements of type T

      pointer
      allocate(size_type n, const void * /* hint */ )
      {
         size_t size = n * sizeof(T);
         return
            reinterpret_cast<pointer>(
               Burnslib::Heap::OperatorNew(size, 0, 0));
      }

      void
      deallocate(void* p, size_type /* n */ )
      {
         if (p)
         {
            Burnslib::Heap::OperatorDelete(p);
         }
      }

      void
      construct(pointer p, const T& val)
      {
         // this calls placement new, which just insures that T's copy ctor
         // is executed on memory at address p (so that the p becomes the
         // this pointer of the new instance.

         //lint -e534 -e522 ignore the return value, which is just p.

         new (reinterpret_cast<void*>(p)) T(val);
      }

      void
      destroy(pointer p)
      {
         ASSERT(p);

         (p)->~T();
      }

      size_type
      max_size() const
      {
         return size_t (-1) / sizeof (T);
      }

      char*
      _Charalloc(size_type n)
      {
         size_t size = n * sizeof(char*);
            
         return reinterpret_cast<char*>(
            Burnslib::Heap::OperatorNew(size, 0, 0));
      }

      // use default ctor, op=, copy ctor, which do nothing, as this class
      // has no members.

   };

   template<class T, class U>
   inline
   bool
   operator==(
      const Burnslib::Heap::Allocator<T>&,
      const Burnslib::Heap::Allocator<U>&)
   {
      return (true);
   }

   template<class T, class U>
   inline
   bool
   operator!=(
      const Burnslib::Heap::Allocator<T>&,
      const Burnslib::Heap::Allocator<U>&)
   {
      return (false);
   }

}  // namespace Heap

}  // namespace Burnslib



#ifdef DBG

   // redefine new to call our version that offers file and line number
   // tracking.  This causes calls to new of the form:
   // X* px = new X;
   // to expand to:
   // X* px = new (__FILE__, __LINE__) X;
   // which calls operator new(size_t, const char*, int)

   #define new new(__FILE__, __LINE__)

#endif



// You should pass -D_DEBUG to the compiler to get this extra heap
// checking behavior.  (The correct way to do this is to set DEBUG_CRTS=1
// in your build environment)

#ifdef _DEBUG

   // A HeapFrame is an object that, upon destruction, dumps to the debugger a
   // snapshot of the heap allocations that were made since its construction.
   // This only works on chk builds.  HeapFrame instances may overlap.  Place
   // one at the beginning of a lexical scope, and you will get a dump of all
   // the allocations made in that scope.
   // 
   // See HEAP_FRAME.

   namespace Burnslib
   {
      namespace Heap
      {
         class Frame
         {
            public:

            // Constructs a new instance.  The object will track all allocations
            // made after this ctor executes.
            //
            // file - name of the source file to be dumped with the allocation
            // report.  ** This pointer is aliased, so it should point to a
            // static address. **
            //
            // line - line number in the above source file to be dumped with the
            // allocation report.

            Frame(const wchar_t* file, unsigned line);

            // Dumps the allocations made since construction.

            ~Frame();

            private:

            const wchar_t* file;
            unsigned       line;

            _CrtMemState   checkpoint;
         };
      }
   }

   #define HEAP_FRAME() Burnslib::Heap::Frame __frame(__FILE__, __LINE__)

#else

   #define HEAP_FRAME()

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\log.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// debug logging tools
//
// 8-13-97 sburns



#ifndef LOG_HPP_INCLUDED
#define LOG_HPP_INCLUDED



// Log provides an interface to a singleton application logging facility.

namespace Burnslib
{

class Log
{
   public:
   
   // use these to set DEFAULT_LOGGING_OPTIONS
   //
   // During CRT startup of our module (i.e. before main, WinMain, or
   // DllMain), the debug code examines the DWORD LogFlags value under the
   // registry key named by REG_ADMIN_RUNTIME_OPTIONS\LOGFILE_NAME.  If the
   // value is not present, it is created and DEFAULT_LOGGING_OPTIONS is
   // written there. If the value is present, it is read.
   //
   // The HIWORD is a bit mask specifying the destination of the logging
   // output.
   //
   // The LOWORD of that value contains a bitmask of the various debug
   // message types to be output:


   // cause LOG output to go to a log file named RUNTIME_NAME.log

   static const DWORD OUTPUT_TO_FILE = (1 << 16);

   // cause LOG output to go to OutputDebugString

   static const DWORD OUTPUT_TO_DEBUGGER = (1 << 17);

   // cause LOG output to go to SpewView application

   static const DWORD OUTPUT_TO_SPEWVIEW = (1 << 18);

   // cause LOG output to be appended to a log file named RUNTIME_NAME.log

   static const DWORD OUTPUT_APPEND_TO_FILE = (1 << 19);


   // output object construction/destruction

   static const DWORD OUTPUT_CTORS = (1 << 0);

   // output calls to AddRef/Release   

   static const DWORD OUTPUT_ADDREFS = (1 << 1);

   // output function call entry

   static const DWORD OUTPUT_FUNCCALLS = (1 << 2);

   // output trace messages

   static const DWORD OUTPUT_LOGS = (1 << 3);

   // output log header

   static const DWORD OUTPUT_HEADER = (1 << 4);

   // output error messages

   static const DWORD OUTPUT_ERRORS = (1 << 5);

   // output time-of-day on each log line

   static const DWORD OUTPUT_TIME_OF_DAY = (1 << 6);

   // output time-since-start on each log line

   static const DWORD OUTPUT_RUN_TIME = (1 << 7);

   // output function/scope exits 

   static const DWORD OUTPUT_SCOPE_EXIT = (1 << 8);



   static const DWORD OUTPUT_MUTE = 0;

   static const DWORD OUTPUT_FULL_VOLUME =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_TO_DEBUGGER
      |  Log::OUTPUT_TO_SPEWVIEW
      |  Log::OUTPUT_CTORS
      |  Log::OUTPUT_ADDREFS
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_ERRORS
      |  Log::OUTPUT_TIME_OF_DAY
      |  Log::OUTPUT_RUN_TIME
      |  Log::OUTPUT_SCOPE_EXIT;

   static const DWORD OUTPUT_TYPICAL =
         Log::OUTPUT_TO_FILE
      |  Log::OUTPUT_TO_DEBUGGER
      |  Log::OUTPUT_FUNCCALLS
      |  Log::OUTPUT_LOGS
      |  Log::OUTPUT_HEADER
      |  Log::OUTPUT_ERRORS;


   // Returns a pointer to the single Burnslib::Log instance.

   static
   Log*
   GetInstance();



   // Called by the initialization machinery to tear down the debugging setup.
   // This takes place during static de-initialization, after
   // main/WinMain/DllMain(DLL_PROCESS_DETACH) has returned.

   static
   void
   Cleanup();



   // Dumps text to the log for the given logging type.
   //
   // type - log type of text.
   // 
   // text - text to dump.
   // 
   // file - filename of source file producing text.
   // 
   // line - line number in source file producing text.

   void
   WriteLn(
      WORD           type,
      const String&  text);
      // const String&  file,
      // unsigned       line);



   // A ScopeTracer object emits text to the log upon construction and
   // destruction.  Place one at the beggining of a lexical scope, and it
   // will log when the scope is entered and exited.
   
   // See LOG_SCOPE, LOG_CTOR, LOG_DTOR, LOG_FUNCTION,
   // LOG_FUNCTION2

   class ScopeTracer
   {
      public:

      // Constructs a new instance, and logs it's creation.
      // 
      // type - the logging type for the log output
      // 
      // message - the text to be emited on construction and destruction

      ScopeTracer(
         DWORD          type,
         const String&  message);

      ~ScopeTracer();

      private:

      String message;
      DWORD   type;
   };


   friend class ScopeTracer;



   private:



   explicit Log(const String& logBaseName);
   ~Log();



   HRESULT
   AdjustLogMargin(int delta);



   String
   ComposeSpewLine(const String& text);



   // Closes and deletes the single Burnslib::Log instance.  If GetInstance
   // is called after this point, then a new instance will be created.

   static
   void
   KillInstance();



   size_t
   GetLogMargin();



   void
   Indent();



   // Returns true if the log file is open, false if not.

   bool
   IsOpen() const
   {
      return fileHandle != INVALID_HANDLE_VALUE;
   }



   void
   Outdent();



   void
   ReadLogFlags();



   // This does all the work, really.

   void
   UnguardedWriteLn(DWORD type, const String& text);



   DWORD
   DebugType()
   {
      // mask off the HIWORD for now.

      return LOWORD(flags);
   }



   bool
   ShouldLogToFile()
   {
      return (flags & OUTPUT_TO_FILE) ? true : false;
   }


   bool
   ShouldAppendLogToFile()
   {
      return (flags & OUTPUT_APPEND_TO_FILE) ? true : false;
   }

   bool
   ShouldLogToDebugger()
   {
      return (flags & OUTPUT_TO_DEBUGGER) ? true : false;
   }



   bool
   ShouldLogToSpewView()
   {
      return (flags & OUTPUT_TO_SPEWVIEW) ? true : false;
   }



   bool
   ShouldLogTimeOfDay()
   {
      return (flags & OUTPUT_TIME_OF_DAY) ? true : false;
   }



   bool
   ShouldLogRunTime()
   {
      return (flags & OUTPUT_RUN_TIME) ? true : false;
   }



   void
   WriteHeader();


   void
   WriteHeaderModule(HMODULE moduleHandle);



   String           baseName;             
   HANDLE           fileHandle;           
   DWORD            flags;                
   HANDLE           spewviewHandle;
   String           spewviewPipeName;
   unsigned         traceLineNumber;      
   CRITICAL_SECTION critsec;              
   DWORD            logfileMarginTlsIndex;

   // not implemented; no instance copying allowed.
   Log(const Log&);
   const Log& operator=(const Log&);
};



// CODEWORK: purge these aliases

const DWORD OUTPUT_MUTE = Log::OUTPUT_MUTE;

const DWORD OUTPUT_FULL_VOLUME = Log::OUTPUT_FULL_VOLUME;

const DWORD OUTPUT_TYPICAL = Log::OUTPUT_TYPICAL;



} // namespace Burnslib
   


#ifdef LOGGING_BUILD


// The logging feature offers the ability to cause output spew at the opening
// and closing of a lexical scope.  This can be done at arbitrary scope with
// the LOG_SCOPE macro, or (more commonly) at function scope with the
// LOG_FUNCTION/2 macros.  Specializations of LOG_FUNCTION include LOG_CTOR/2,
// LOG_DTOR/2, LOG_ADDREF, and LOG_RELEASE.  Refer to the following table:
//    
// Spew macro				      Output spewed (spewn?) when this flag is set
//
// LOG_SCOPE				      OUTPUT_LOGS
// LOG_FUNCTION 			      OUTPUT_FUNCCALLS
// LOG_FUNCTION2			      OUTPUT_FUNCCALLS
// LOG_CTOR				         OUTPUT_CTORS	
// LOG_CTOR2				      OUTPUT_CTORS
// LOG_DTOR				         OUTPUT_CTORS
// LOG_DTOR2				      OUTPUT_CTORS
// LOG_ADDREF				      OUTPUT_ADDREFS
// LOG_RELEASE				      OUTPUT_ADDREFS
// LOG_LOG_EGGS_AND_SPAM_LOG	To be implemented
//       
// At the point where the LOG macro is executed, if the corresponding flag
// is set, a line starting with "Enter " is output.  Subsequent output is then
// indented.  At the point where the lexical scope enclosing the macro ends,
// if the OUTPUT_SCOPE_EXIT flag is set, a line starting with "Exit" is
// output.  Subsequent output is aligned with the next most recent Enter, i.e.
// outdented.
//          
// If the flag corresponding to a LOG macro is not set, then no "Enter" or
// "Exit" lines are output.


   #define LOGT(type, msg)                                                \
   {  /* open scope */                                                    \
      Burnslib::Log* _dlog = Burnslib::Log::GetInstance();                \
      if (_dlog)                                                          \
      {                                                                   \
         _dlog->WriteLn(type, msg);                                       \
      }                                                                   \
   }  /* close scope */                                                   \



   #define LOG(msg) LOGT(Burnslib::Log::OUTPUT_LOGS, msg)



   #define LOG_LAST_WINERROR()                                            \
      LOGT(                                                               \
         Burnslib::Log::OUTPUT_ERRORS,                                    \
         String::format(                                                  \
            L"GetLastError = 0x%1!08X!",                                  \
            ::GetLastError()))                                            \
                                                                          \


   #define LOG_SCOPET(type, msg)                                          \
   Burnslib::Log::ScopeTracer __tracer(type, msg)                  



   #define LOG_SCOPE(msg)                                                 \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_LOGS,                                         \
      msg)



   #define LOG_CTOR(classname)                                            \
   LOG_SCOPET(Burnslib::Log::OUTPUT_CTORS, L"ctor: " TEXT(#classname))



   #define LOG_CTOR2(classname, msg)                                      \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_CTORS,                                        \
         String(L"ctor: " TEXT(#classname) L" ")                          \
      +  String(msg))



   #define LOG_DTOR(classname)                                            \
   LOG_SCOPET(Burnslib::Log::OUTPUT_CTORS, L"dtor: " TEXT(#classname))



   #define LOG_DTOR2(classname, msg)                                      \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_CTORS,                                        \
         String(L"dtor: " TEXT(#classname) L" ")                          \
      +  String(msg))



   #define LOG_ADDREF(classname)                                          \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ADDREFS,                                      \
      L"AddRef: " TEXT(#classname))



   #define LOG_RELEASE(classname)                                         \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ADDREFS,                                      \
      L"Release: " TEXT(#classname))



   #define LOG_FUNCTION(func)                                             \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_FUNCCALLS,                                    \
      TEXT(#func))                                                        



   #define LOG_FUNCTION2(func, s)                                         \
   LOG_SCOPET(                                                            \
      Burnslib::Log::OUTPUT_FUNCCALLS,                                    \
      String(TEXT(#func) L" ").append(s))                                 



   #define LOG_HRESULT(hr)                                                \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_ERRORS,                                       \
      String::format(L"HRESULT = 0x%1!08X!", hr))



   #define LOG_BOOL(boolexpr)                                             \
   LOGT(                                                                  \
      Burnslib::Log::OUTPUT_LOGS,                                         \
      String::format(                                                     \
         L"%1 = %2",                                                      \
         TEXT(#boolexpr),                                                 \
         (boolexpr) ? L"true" : L"false"))                                
      


#else    // LOGGING_BUILD

   #define LOGL(type, msg)
   #define LOG(msg)
   #define LOG_LAST_WINERROR()

   #define LOG_SCOPEL(type, msg)
   #define LOG_SCOPE(msg)

   #define LOG_CTOR(classname)
   #define LOG_CTOR2(classname, msg)
   #define LOG_DTOR(classname)
   #define LOG_DTOR2(classname, msg)

   #define LOG_ADDREF(classname)
   #define LOG_RELEASE(classname)

   #define LOG_FUNCTION(func)

   #define LOG_FUNCTION2(func, s)

   #define LOG_HRESULT(hr)
   #define LOG_BOOL(boolexpr)

#endif   // LOGGING_BUILD



#endif   // LOG_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\pragmawarning.hpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// pragma warnings
//
// 8 Feb 2000 sburns



#define PRAGMAWARNING_HPP_INCLUDED



// disable "exception specification ignored" warning: we use exception
// specifications

#pragma warning (disable: 4290)



// we frequently use constant conditional expressions: do/while(0), etc.

#pragma warning (disable: 4127)



// we like this extension

#pragma warning (disable: 4239)



// often, we have local variables for the express purpose of ASSERTion.
// when compiling retail, those assertions disappear, leaving our locals
// as unreferenced.

#ifndef DBG

#pragma warning (disable: 4189)
#pragma warning (disable: 4100)

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\netutil.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Net utility functions
//
// 11-4-1999 sburns



#ifndef NETUTIL_HPP_INCLUDED
#define NETUTIL_HPP_INCLUDED



// Returns true if some form of networking support is installed on the
// machine, false if not.

bool
IsNetworkingInstalled();



// Returns true if tcp/ip protocol is installed and bound to at least 1
// adapter.

bool
IsTcpIpInstalled();



HRESULT
MyNetJoinDomain(
   const String&          domain,  
   const String&          username,
   const EncryptedString& password,
   ULONG                  flags);



HRESULT
MyNetRenameMachineInDomain(
   const String&          newNetbiosName,
   const String&          username,      
   const EncryptedString& password,      
   DWORD                  flags);



HRESULT
MyNetUnjoinDomain(
   const String&          username,
   const EncryptedString& password,
   DWORD                  flags);



HRESULT
MyNetValidateName(
   const String&        name,
   NETSETUP_NAME_TYPE   nameType);



// Caller must delete info with NetApiBufferFree.

HRESULT
MyNetWkstaGetInfo(const String& serverName, WKSTA_INFO_100*& info);




#endif   // NETUTIL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\proppage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Property Page base class
// 
// 9-9-97 sburns



#ifndef PROPPAGE_HPP_INCLUDED
#define PROPPAGE_HPP_INCLUDED



// PropertyPage extends the Dialog class to provide message cracking for
// property page notifications.

class PropertyPage : public Dialog
{
   public:

   // Calls CreatePropertySheetPage and returns the resulting HPROPSHEETPAGE.
   // Normally, the HPROPSHEETPAGE is deleted by a later call to the Win32
   // API ::PropertySheet.  If the HPROPSHEETPAGE is not passed to
   // PropertySheet, or PropertySheet fails, it should be deleted with
   // ::DestroyPropertySheetPage.

   virtual 
   HPROPSHEETPAGE
   Create();

   protected:

   // Invoked upon receipt of the PSN_APPLY notification message.  Return true
   // if you handle the messages, false if you do not.  The default
   // implementation returns false.
   //
   // isClosing - true if the sheet is closing (OK was pressed), false if
   // not (Apply was pressed).

   virtual
   bool
   OnApply(bool isClosing);

   // Invoked upon receipt of the PSN_HELP notification message.  Return true
   // if you handle the message, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnHelp();

   // Invoked upon receipt of the PSN_KILLACTIVE notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.
   
   virtual
   bool
   OnKillActive();

   // Invoked upon receipt of the PSN_SETACTIVE notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnSetActive();

   // Invoked upon receipt of the PSN_QUERYCANCEL notification message.
   // Return true if you handle the messages, false if you do not.  The
   // default implementation returns false.

   virtual
   bool
   OnQueryCancel();

   // Invoked upon receipt of the PSN_RESET notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnReset();

   // Invoked upon receipt of the PSN_WIZBACK notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnWizBack();

   // Invoked upon receipt of the PSN_WIZNEXT notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.

   virtual
   bool
   OnWizNext();

   // Invoked upon receipt of the PSN_WIZFINISH notification message.  Return
   // true if you handle the messages, false if you do not.  The default
   // implementation returns false.
   // The handler must set the DWLP_MSGRESULT by calling Win::SetWindowLongPtr
   // to tell the sheet whether or not to shutdown the wizard.  

   virtual
   bool
   OnWizFinish();

   // Constructs a new instance.  Declared protected so that this class
   // only functions as base class
   // 
   // dialogResID - resource identifier of the dialog template resource.
   // 
   // helpMap - array mapping dialog control IDs to context help IDs.  The
   // array must be in the following form:
   // {
   //    controlID1, helpID1,
   //    controlID2, helpID2,
   //    controlIDn, helpIDn,
   //    0, 0
   // }
   // 
   // To indicate that a control does not have help, the value of its
   // corresponding help ID should be -1.  This array is copied by the
   // constuctor.
   //
   // deleteOnRelease - true to delete the instance when the Win32
   // ::PropertySheet function is about to destroy the sheet, and sends the
   // PSPCB_RELEASE message to each page's callback.  false if the page
   // instance will be deleted at a later point.

   PropertyPage(
      unsigned    dialogResID,
      const DWORD helpMap[],
      bool        deleteOnRelease = true);

   // protected dtor so that the dtors of derived classes can call this,
   // the base class' dtor, and to suggest that prop pages are self-deleting.

   virtual ~PropertyPage();

   static
   INT_PTR APIENTRY
   propPageDialogProc(
      HWND   dialog, 
      UINT   message,
      WPARAM wparam, 
      LPARAM lparam);

   static
   UINT CALLBACK 
   PropSheetPageCallback(HWND hwnd,	UINT uMsg, PROPSHEETPAGE* page);

   private:

   static
   PropertyPage*
   getPage(HWND pageDialog);

   // not implemented: no copying allowed
   PropertyPage(const PropertyPage&);
   const PropertyPage& operator=(const PropertyPage&);

   bool deleteOnRelease;
};




#endif   // PROPPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\registry.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// System Registry Class
//
// 7-9-98 sburns



#ifndef REGISTRY_HPP_INCLUDED
#define REGISTRY_HPP_INCLUDED



class RegistryKey
{
   public:

   RegistryKey();
   ~RegistryKey();

   HRESULT
   Close();

   HRESULT
   Create(
      HKEY                 parentKey,
      const String&        subkeyName,
      DWORD                options = REG_OPTION_NON_VOLATILE,
      REGSAM               desiredAccess = KEY_WRITE,
      SECURITY_ATTRIBUTES* securityAttrs = 0,
      DWORD*               disposition = 0);

   HRESULT
   Open(
      HKEY           parentKey,
      const String&  subkeyName,
      REGSAM         desiredAccess = KEY_READ);

   // Returns Win32ToHresult(ERROR_INVALID_FUNCTION) if the type of the value
   // is not REG_DWORD, REG_DWORD_LITTLE_ENDIAN, or REG_DWORD_BIG_ENDIAN.

   HRESULT
   GetValue(
      const String&  valueName,
      DWORD&         value);

   // Retrieves the contents of the named value, and whether the type of the
   // key is REG_SZ or REG_EXPAND_SZ.  Returns
   // Win32ToHresult(ERROR_INVALID_FUNCTION) if the type of the value is not
   // REG_SZ or REG_EXPAND_SZ
   //
   // valueName - name of the value.
   //
   // value - receives the contents of the value, if the read was successful.
   // cleared on failure.
   //
   // isExpandSz - set to true if the value is of type REG_EXPAND_SZ, false
   // if the type is REG_SZ (or an error ocurred).

   HRESULT
   GetValue(
      const String&  valueName,
      String&        value,
      bool&          isExpandSz);

   // Calls GetValue(), and throws away the isExpandSz result.

   HRESULT
   GetValue(
      const String&  valueName,
      String&        value);

   // Inserts strings from a REG_MULTI_SZ value into any container from
   // which a std::BackInsertionSequence can be constructed, the elements
   // of which must be constructable from an PWSTR.
   //
   // BackInsertionSequence - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // valueName - name of REG_MULTI_SZ value to retrieve.
   // 
   // bii - a reference to a back_insert_iterator of the
   // BackInsertionSequence template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // hr = key.GetValue(L"myValue", back_inserter(container));
   //
   // StringVector container;
   // hr = key.GetValue(L"myValue", back_inserter(container));

   template <class BackInsertableContainer>
   HRESULT
   GetValue(
      const String& valueName,
      std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      LOG_FUNCTION2(RegistryKey::GetValue-MultiString, valueName);
      ASSERT(!valueName.empty());
      ASSERT(key);

      DWORD type = 0;
      DWORD size = 0;

      // REVIEWED-2002/02/22-sburns This QueryValue call is ok.
      
      HRESULT hr = Win::RegQueryValueEx(key, valueName, &type, 0, &size);
      if (SUCCEEDED(hr))
      {
         if (type == REG_MULTI_SZ)
         {
            // now that we know the size, read the contents
            // add space for two null characters
      
            BYTE* buf = new BYTE[size + (2 * sizeof WCHAR)];

            // REVIEWED-2002/04/03-sburns correct byte count passed.
            
            ::ZeroMemory(buf, size + (2 * sizeof WCHAR));

            type = 0;

            hr = Win::RegQueryValueEx(key, valueName, &type, buf, &size);
            if (SUCCEEDED(hr))
            {
               // pull off each of the null-terminated strings

               // the container values can be any type that can be constructed
               // from PWSTR...

               wchar_t* newbuf = reinterpret_cast<PWSTR>(buf);
               while (*newbuf)
               {
                  // REVIEWED-2002/04/03-sburns this wcslen call is safe
                  // because we arranged for the buffer to be null-terminated
                  
                  size_t len = wcslen(newbuf);

                  //lint --e(*)  lint does not grok back_insert_iterator
                  *bii++ = String(newbuf, len);

                  // move to the next string, + 1 to skip the terminating null
                  newbuf += len + 1;
               };

               delete[] buf;
            }
         }
         else
         {
            // caller requested a string from a non-multi-string key
            hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
         }
      }

      return hr;
   }

   // Calls GetValue and returns the result, or an empty string on failure.

   String
   GetString(const String& valueName);

   // Creates and/or sets a value under the currently open key.  Returns
   // S_OK on success.
   // 
   // valueName - name of the value.  If the value is not already present, it
   // is created with a REG_DWORD type.
   // 
   // value - the value to br written.

   HRESULT
   SetValue(
      const String&  valueName,
      DWORD          value);

   // Creates and/or sets a value under the currently open key.  Returns
   // S_OK on success.
   // 
   // valueName - name of the value.  If the value is not already present, it
   // is created.
   // 
   // value - the value to br written.
   //
   // expand - if true, the value type is REG_EXPAND_SZ, if false, the value
   // type is REG_SZ.

   HRESULT
   SetValue(
      const String&  valueName,
      const String&  value,
      bool           expand = false);

   template<class ForwardIterator>
   HRESULT
   SetValue(
      const String& valueName,
      ForwardIterator first,
      ForwardIterator last)
   {
      LOG_FUNCTION2(RegistryKey::SetValue--MultiString, valueName);
      ASSERT(!valueName.empty());

      // determine the size of the buffer to write
      
      size_t bufSizeInBytes = 0;
      for (
         ForwardIterator f = first, l = last;
         f != l;
         ++f)
      {
         // + 1 for null terminator
         
         bufSizeInBytes += (f->length() + 1) * sizeof(wchar_t);
      }

      // + 2 bytes for double-null terminator at very end
      
      bufSizeInBytes += 2;

      BYTE* buf = new BYTE[bufSizeInBytes];

      // REVIEWED-2002/02/27-sburns correct byte count passed. I know
      // BYTE is size 1, but what if that changed due to some screw up?

      ::ZeroMemory(buf, bufSizeInBytes * sizeof BYTE);

      // copy the elements of the container into the buffer
      
      wchar_t* newbuf  = reinterpret_cast<wchar_t*>(buf);
      wchar_t* copyPos = newbuf;                        
      for (
         f = first, l = last;
         f != l;
         ++f)
      {
         copyPos = std::copy(f->begin(), f->end(), copyPos);

         // skip a character for terminating null
         
         copyPos++;
      }

      // write the buffer to the registry
      // REVIEWED-2002/02/27-sburns correct byte count passed.
      
      HRESULT hr = 
         Win::RegSetValueEx(
            key,
            valueName,
            REG_MULTI_SZ,
            buf,
            bufSizeInBytes);

      delete[] buf;

      return hr;
   }

   private:

   HKEY     key;
};



#endif   // REGISTRY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\richeditstreamer.hpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Rich Edit streaming helper 
//
// 28 Sep 2001 sburns



#ifndef RICHEDITSTREAMER_HPP_INCLUDED
#define RICHEDITSTREAMER_HPP_INCLUDED



// Facilities streaming text into/out of a riched edit control.  This is a
// abstract base class.  Derived classes need to provide an implementation of
// the StreamCallback method.  See class RichEditStringStreamer for an
// example.

class RichEditStreamer
{
   public:
   

   // Returns the error state last returned by StreamCallback.
   
   virtual
   HRESULT
   ErrorResult();



   // Streams text into the rich edit control.
   
   int
   StreamIn(DWORD formatOptions = SF_RTF);


   
//    int
//    StreamOut(DWORD formatOptions = SF_RTF);



   protected:


   
   RichEditStreamer(HWND richEdit_);

   virtual
   ~RichEditStreamer();

   virtual
   HRESULT
   StreamCallback(
      PBYTE     buffer,
      LONG      bytesToTransfer,
      LONG*     bytesTransferred) = 0;
   
   HWND        richEdit;
   EDITSTREAM  editStream;
   LONG        bytesCopiedSoFar;
   
   enum StreamDirection
   {
      TO_CONTROL,    // stream in
      FROM_CONTROL   // stream out
   };

   StreamDirection direction;

   

   private:
   
   HRESULT
   StreamCallbackHelper(
      PBYTE     buffer,
      LONG      bytesToTransfer,
      LONG*     bytesTransferred);
   
   static
   DWORD CALLBACK
   StaticStreamCallback(
      DWORD_PTR cookie,
      PBYTE     buffer,
      LONG      bytesToTransfer,
      LONG*     bytesTransferred);
};



#endif   // RICHEDITSTREAMER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\popup.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Popup message box class
// 
// 8-31-98 sburns



#ifndef POPUP_HPP_INCLUDED
#define POPUP_HPP_INCLUDED


// Augments MessageBox with useful behavior

class Popup
{
   public:

   // Constuct an instance.
   //
   // titleStringResID - resource ID of the string to be used as the title
   // for all message dialogs raised by invoking methods of the instance.
   //
   // systemModal - true to indicate that message dialogs should have
   // system modal behavior

   explicit
   Popup(UINT titleStringResID, bool systemModal = false);

   // Constuct an instance.
   //
   // title - the string to be used as the title for all message dialogs
   // raised by invoking methods of the instance.
   //
   // systemModal - true to indicate that message dialogs should have
   // system modal behavior

   explicit
   Popup(const String& title, bool systemModal = false);

   // default dtor used.

   // Present a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.
   // 
   // parentDialog - the parent window containing the control to receive focus.
   //
   // editResID - Resource ID of the edit box to which focus will be set.
   // 
   // messageStringResID - Resource ID of the message text to be shown in the
   // dialog.  The title of the dialog is "Error".

   void
   Gripe(
      HWND  parentDialog,
      int   editResID,
      UINT  messageStringResID) const;

   // Presents a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.
   // 
   // parentDialog - the parent window containing the control to receive focus.

   // editResID - Resource ID of the edit box to which focus will be set.
   //
   // message - Text to appear in the dialog.  

   void
   Gripe(
      HWND           parentDialog,
      int            editResID,
      const String&  message) const;

   // Presents a message box dialog, set input focus back to a given edit
   // box when the dialog is dismissed.  The message is followed with the
   // description of the provided HRESULT.
   // 
   // parentDialog - the parent window containing the control to receive focus.

   // editResID - Resource ID of the edit box to which focus will be set.
   //
   // hr - HRESULT indicating the error description text to appear after the
   // message text.
   //
   // message - Text to appear in the dialog.  The title is "Error".

   void
   Gripe(
      HWND           parentDialog,
      int            editResID,
      HRESULT        hr,
      const String&  message) const;

   void
   Gripe(
      HWND    parentDialog,       
      int     editResID,          
      HRESULT hr,                 
      UINT    messageStringResID) const;

   // variation on the theme that does not have an associated edit box.

   void
   Gripe(
      HWND           parentDialog,
      const String&  message) const;

   // Presents a message box

   void
   Error(
      HWND           parentDialog,
      HRESULT        hr,
      const String&  message) const;

   void
   Error(
      HWND    parentDialog,       
      HRESULT hr,                 
      UINT    messageStringResID) const;

   void
   Error(
      HWND parentDialog,       
      UINT messageStringResID) const;

   void
   Error(
      HWND           parentDialog,
      const String&  message) const;

   void
   Info(
      HWND parentDialog,       
      UINT messageStringResID) const;
   
   void
   Info(
      HWND           parentDialog,
      const String&  message) const;

   int
   MessageBox(
      HWND           parentDialog,
      const String&  message,
      UINT           flags) const;

   int
   MessageBox(
      HWND parentDialog,      
      UINT messageStringResID,
      UINT flags) const;            

   private:

   void
   checkInit() const;

   UINT
   getStyleMask() const;

   mutable  bool     initialized;
   mutable  String   title;
   UINT     titleResId;
   bool     systemModal;
};



#endif   // POPUP_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\safedll.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Self-freeing DLL class
// 
// 10-9-98 sburns



#ifndef SAFEDLL_HPP_INCLUDED
#define SAFEDLL_HPP_INCLUDED



class SafeDLL
{
   public:

   // Constructs an instance that will on-demand load the named dll.
   //
   // dllName - name of the dll to be loaded.

   explicit
   SafeDLL(const String& dllName);

   // calls FreeLibrary on the DLL

   ~SafeDLL();

   HRESULT
   GetProcAddress(const String& functionName, FARPROC& result) const;
   
   private:

   mutable HMODULE   module;
   String            name;
};



#endif   // SAFEDLL_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\richeditstringstreamer.hpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Rich Edit streaming helper for strings.
//
// 28 Sep 2001 sburns



#ifndef RICHEDITSTRINGSTREAMER_HPP_INCLUDED
#define RICHEDITSTRINGSTREAMER_HPP_INCLUDED



#include "RichEditStreamer.hpp"



// An implelemtation of RichEditStreamer for classes derived from
// std::basic_string, which includes Burnslib::AnsiString and Burnslib::String.
// 
// example use:
// 
// HWND richEdit = your rich edit control
// String streamMe(L"hello world.");
// 
// RichEditStringStreamer<String> streamer(richEdit, streamMe);
// streamer.StreamIn();
// ASSERT(SUCCEEDED(streamer.ErrorResult()));



template <class StringType>
class RichEditStringStreamer
   :
   public RichEditStreamer
{
   public:

   RichEditStringStreamer(HWND richEdit, const StringType& str)
      :
      RichEditStreamer(richEdit),
      textBuffer(str)
   {
   }



   virtual
   ~RichEditStringStreamer()
   {
   }



   protected:
   


   // RichEditStreamer overrides
   
   virtual
   HRESULT
   StreamCallback(
      PBYTE     buffer,
      LONG      bytesToTransfer,
      LONG*     bytesTransferred)
   {
      HRESULT hr = S_OK;
      
      if (direction == StreamDirection::TO_CONTROL)
      {
         // we're stuffing textBuffer into the control

         LONG bytesRemaining =
               (textBuffer.length() * sizeof(StringType::value_type))
            -  bytesCopiedSoFar;

         *bytesTransferred = min(bytesToTransfer, bytesRemaining);

         if (bytesRemaining)
         {
            PBYTE source =
                  reinterpret_cast<BYTE*>(
                     const_cast<StringType::value_type*>(textBuffer.c_str()))
               +  bytesCopiedSoFar;
            memcpy(buffer, source, *bytesTransferred);
         }
      }
      else
      {
         ASSERT(direction == StreamDirection::FROM_CONTROL);

         *bytesTransferred = 0;
         hr = E_NOTIMPL;
      }

      return hr;
   }



   private:

   StringType textBuffer;
};



#endif   // RICHEDITSTRINGSTREAMER_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\service.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Service Control Manager wrapper class
// 
// 10-6-98 sburns



#ifndef SERVICE_HPP_INCLUDED
#define SERVICE_HPP_INCLUDED



// Simple NTService Control Manager wrapper

class NTService
{
   public:

   // Constructs a new instance that corresponds to the given service name on
   // the given computer.
   // 
   // machine - name of the computer.  Empty string corresponds to the local
   // computer.
   // 
   // serviveName - name of the service.

   NTService(const String& machine, const String& serviceName);

   // Constructs a new instance that corresponds to the given service name on
   // the local computer (the machine on which this call is invoked).
   // 
   // serviveName - name of the service.

   explicit
   NTService(const String& serviceName);

   ~NTService();

   bool
   IsInstalled();

   // Queries the SCM for the last reported state of the service.

   HRESULT
   GetCurrentState(DWORD& state);

   // Uses GetCurrentState in a loop with sleeps until the service
   // enters the specified state or until the timeout period has passed

   HRESULT
   WaitForServiceState(
      DWORD state,
      DWORD sleepInterval = DEFAULT_SLEEP_INTERVAL, 
      DWORD timeout = DEFAULT_TIMEOUT);

   // These defaults were taken from the filemgmt snapin which
   // provides the start/stop services UI

   static const DWORD DEFAULT_SLEEP_INTERVAL = 500;
   static const DWORD DEFAULT_TIMEOUT = DEFAULT_SLEEP_INTERVAL * 250;

   private:

   // not implemented: no copying allowed
   NTService(const NTService&);
   const NTService& operator=(const NTService&);

   String machine;
   String name;
};



#endif   // SERVICE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\smartptr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Smart (Interface) pointer class
// 
// 9-25-97 sburns



#ifndef SMARTPTR_HPP_INCLUDED
#define SMARTPTR_HPP_INCLUDED



namespace Burnslib
{
   
// Requires that T derive from IUnknown

template <class T>
class SmartInterface
{
   public:

   // need default ctor if we are to use STL containers to hold SmartInterfaces

   SmartInterface()
      :

#ifdef DBG      
      ptrGuard(0xDDDDDDDD),
#endif
      
      ptr(0)
   {
   }



   explicit
   SmartInterface(T* p)

#ifdef DBG      
      :
      ptrGuard(0xDDDDDDDD)
#endif 
      
   {
      // don't assert(p), since construction w/ 0 is legal.

      ptr = p;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   SmartInterface(const SmartInterface<T>& s)

#ifdef DBG      
      :
      ptrGuard(0xDDDDDDDD)
#endif 

   {
      // makes no sense to pass null pointers

      ASSERT(s.ptr);
      ptr = s.ptr;
      if (ptr)
      {
         ptr->AddRef();
      }
   }



   ~SmartInterface()
   {
      Relinquish();
   }



   // Aquire means "take over from a dumb pointer, but don't AddRef it."
   //
   // This is used to take over ownership from a dumb pointer so that you
   // don't have to remember to call Release on the dumb pointer.
   //
   // Example:
   // 
   // SmartInterface<IFoo> smart(0);
   // IFoo* dumb = 0;
   //    
   // HRESULT hr =
   //    ::YourGetDumbPointerCall(
   //       __uuidof(IFoo),
   //       reinterpret_cast<void**>(&dumb));
   // BREAK_ON_FAILED_HRESULT(hr);
   //    
   // smart.Acquire(dumb);
   //
   // Don't call dumb->Release(), when smart dies it will release the
   // pointer.

   void
   Acquire(T* p)
   {
      ASSERT(!ptr);
      ptr = p;
   }



   HRESULT
   AcquireViaQueryInterface(IUnknown& i)
   {
      return AcquireViaQueryInterface(i, __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaQueryInterface(IUnknown& i, const IID& interfaceDesired)
   {
      ASSERT(!ptr);
      HRESULT hr = 
         i.QueryInterface(interfaceDesired, reinterpret_cast<void**>(&ptr));

      // don't assert success, since we might just be testing to see
      // if an interface is available.

      return hr;
   }



   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext)
   {
      return
         AcquireViaCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            __uuidof(T));
   }



   // fallback for those interfaces that are not
   // declared w/ __declspec(uuid())

   HRESULT
   AcquireViaCreateInstance(
      const CLSID&   classID,
      IUnknown*      unknownOuter,
      DWORD          classExecutionContext,
      const IID&     interfaceDesired)
   {
      ASSERT(!ptr);

      HRESULT hr =

      // REVIEWED-2002/02/18-sburns
      // Callers of this function should make sure the flags do not allow for
      // an out-of-proc create if the class only supports in-proc.
      
         ::CoCreateInstance(
            classID,
            unknownOuter,
            classExecutionContext,
            interfaceDesired,
            reinterpret_cast<void**>(&ptr));
      return hr;
   }



   void
   Relinquish()
   {
      if (ptr)
      {
         ptr->Release();
         ptr = 0;
      }
   }
      


   operator T*() const
   {
      return ptr;
   }



   // this allows SmartInterface instances to be passed as the first
   // parameter to AquireViaQueryInterface.  Note that this is a conversion
   // to IUnknown&, not IUnknown*.  An operator IUnknown* would be ambiguous
   // with respect to operator T*.
   //
   // (does not return a const IUnknown&, as COM interfaces are not const
   // aware.)

   operator IUnknown&() const
   {
      ASSERT(ptr);
      return *(static_cast<IUnknown*>(ptr));
   }



// don't appear to need this: less is better.
//    T&
//    operator*()
//    {
//       ASSERT(ptr);
//       return *ptr;
//    }



   T*
   operator->() const
   {
      ASSERT(ptr);
      return ptr;
   }



   T*
   operator=(T* rhs)
   {
      ASSERT(rhs);

      if (ptr != rhs)
      {
         Relinquish();
         ptr = rhs;
         if (ptr)
         {
            ptr->AddRef();
         }
      }

      return ptr;
   }



   // This is required by some STL container classes.

   const SmartInterface<T>&
   operator=(const SmartInterface<T>& rhs)
   {
      this->operator=(rhs.ptr);
      return *this;   
   }



//    // This might be a good idea, but std::list.erase chokes on it.
// ISSUE-2002/03/26-sburns maybe that's fixed w/ VS 7?
//    
//    T**
//    operator& ()
//    {
//       ASSERT(!ptr);
// 
//       if (ptr)
//       {
//          return &ptr;
//       }
//       else
//       {
//          return 0;
//       }
//    }
      


   private:

   
#ifdef DBG

//    Some code that takes the address of an instance of this class is working
//    by happy coincidence: that taking the address of an instance yields the
//    same address as the ptr member.  For chk builds, I am deliberately
//    breaking that code by inserting a dummy guard value, so that &i != i.ptr
// 
//    You should not try to take the address of a SmartInterface in order to
//    access the internal pointer.  You should instead use one of the Acquire
//    methods, or use a dumb pointer and then acquire it. Under no
//    circumstances will we allow access to our internal state!
   
   int ptrGuard;
#endif
         
   T* ptr;
};


}  // namespace Burnslib



#endif   // SMARTPTR_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\syscore.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//                          
// includes sdk and other headers external to this project necessary to
// build the burnslib core library
//
// 30 Nov 1999 sburns



#ifndef SYSCORE_HPP_INCLUDED
#define SYSCORE_HPP_INCLUDED


// the sources file should specify warning level 4.  But with warning level
// 4, most of the SDK and CRT headers fail to compile (isn't that nice?).
// So, here we set the warning level to 3 while we compile the headers

#pragma warning(push, 3)

// ISSUE-2002/03/25-sburns
// // Don't use the macro versions of min/max, they are prone to subtle bugs
// // since they re-evaluate their parameters more than once.
// 
// #define NOMINMAX

   #include <nt.h>
   #include <ntrtl.h>
   #include <nturtl.h>
   #include <windows.h>
   #include <ole2.h>

   // Standard C++ headers, including STL

   #include <string>
   #include <functional>
   #include <iterator>
   #include <crtdbg.h>
   #include <iso646.h>

#pragma warning (pop)



#endif   // SYSCORE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\stacktr.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// stack backtracing stuff
//
// 22-Nov-1999 sburns (refactored)



namespace Burnslib
{
   
namespace StackTrace
{
   const size_t MODULE_NAME_MAX = 32;
   const size_t SYMBOL_NAME_MAX = 256;



   // This should be called when stack tracing facilities are no longer
   // needed.

   void
   Cleanup();



   // Fill the provided array with a stack backtrace, starting with the
   // code address indicated by the context structure supplied.
   // 
   // This version is suited for use in an SEH exception handler to determine
   // the call stack at the point at which an exception was raised.
   //
   // Example:
   //
   // DWORD64 stackTrace[TRACE_MAX];
   // size_t traceMax = TRACE_MAX;
   // 
   // __try
   // {
   //    // call some code that might raise an SEH exception
   // }
   // __except(
   //    Burnslib::StackTrace::TraceFilter(
   //       stackTrace,
   //       traceMax,
   //       (GetExceptionInformation())->ContextRecord))
   // {
   //    // for each element in stackTrace, call
   //    // Burnslib::StackTrace::LookupAddress
   // }      
   //
   // Each element is an address that can be used to obtain a corresponding
   // module, function name, line number and source file name (or a subset of
   // that information, depending on the debugging symbol information
   // available), from the LookupAddress function.
   // Returns EXCEPTION_EXECUTE_HANDLER
   //
   // stackTrace - the array to receive the addresses.
   // 
   // traceMax - the maximum number of stack frames to traverse.  The
   // stackTrace array must be able to hold at least this many elements.
   // If the depth of the call stack is less than traceMax, then the
   // remaining elements are 0.

   DWORD
   TraceFilter(
      DWORD64  stackTrace[],
      size_t   traceMax,    
      CONTEXT* context);    



   // Fill the provided array with a stack backtrace, starting with the
   // invoker of this function.
   //
   // Each element is an address that can be used to obtain a corresponding
   // module, function name, line number and source file name (or a subset of
   // that information, depending on the debugging symbol information
   // available), from the LookupAddress function.
   // 
   // stackTrace - the array to receive the addresses.
   // 
   // traceMax - the maximum number of stack frames to traverse.  The
   // stackTrace array must be able to hold at least this many elements.
   // If the depth of the call stack is less than traceMax, then the
   // remaining elements are 0.

   void
   Trace(DWORD64 stackTrace[], size_t traceMax);



   // Resolves an address obtained by Trace.  ::SymSetOptions and
   // ::SymInitialize must have been called at some point before this
   // function is called.
   // 
   // traceAddress - the address to resolve.
   // 
   // moduleName - address of an array of char to receieve the name of the
   // module to which the address originates, or 0.  The array must be able
   // to hold MODULE_NAME_MAX bytes.
   // 
   // fullImageName - address of an array of char to receive the full path
   // name of the binary file from which the module was loaded, or 0.  The
   // array must be able to hold MAX_PATH bytes.
   // 
   // symbolName - address of an array of char to receive the undecorated
   // name of the function corresponding to the address, or 0.  The array
   // must be able to hold SYMBOL_NAME_MAX bytes.
   // 
   // displacement - address of a DWORD to receive the byte offset from the
   // beginning of the function that corresponds to the address, or 0.
   // 
   // line - address of a DWORD to receive the line number in the source of
   // the code that corresponds to the instruction at the displacement
   // offset of the function, or 0.
   // 
   // fullpath - address of an array of char to receive the full name of
   // the source code file that defines the function corresponding to the
   // address, or 0.  The array must be able to hold MAX_PATH bytes.

   void
   LookupAddress(
      DWORD64  traceAddress,   
      char     moduleName[],   
      char     fullImageName[],
      char     symbolName[],    // must be SYMBOL_NAME_MAX bytes
      DWORD64* displacement,   
      DWORD*   line,           
      char     fullpath[]);     // must be MAX_PATH bytes



   // Calls LookupAddress and fills in the blanks
   //
   // %1 - module name
   // %2 - symbol name
   // %3 - source full path
   // %4 - line number

   String
   LookupAddress(
      DWORD64 traceAddress,
      const wchar_t* format = L"%1%!%2 %3(%4!d!)");

}  // namespace StackTrace



}  // namespace Burnslib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\sysfull.hpp ===
// Copyright (c) 1999-2002 Microsoft Corporation
//
// System headers used in burnslib



#ifndef SYSHDRS_HPP_INCLUDED
#define SYSHDRS_HPP_INCLUDED



// the sources file should specify warning level 4.  But with warning level
// 4, most of the SDK and CRT headers fail to compile (isn't that nice?).
// So, here we set the warning level to 3 while we compile the headers

#pragma warning(push,3)

   #include "syscore.hpp"

   #include <list>
   #include <vector>
   #include <map>
   #include <algorithm>
   #include <stack>

   #include <comutil.h>
   #include <commctrl.h>
   #include <shlobj.h>
   #include <shellapi.h>
   #include <htmlhelp.h>
   #include <tchar.h>

   #include <lmerr.h>
   #include <lmcons.h>
   #include <lmjoin.h>
   #include <lmapibuf.h>
   #include <lmserver.h>
   #include <lmwksta.h>
   #include <icanon.h>
   #include <dsrole.h>
   #include <dnsapi.h>
   #include <dsgetdc.h>
   #include <safeboot.h>
   #include <regstr.h>
   #include <richedit.h>

   extern "C"
   {
      #include <dsgetdcp.h>
   }

   #include <ntdsapi.h>
   #include <sddl.h>
   #include <wincrypt.h>
   #include <aclapi.h>   
   #include <accctrl.h>
   
#pragma warning(pop)



#endif   // SYSHDRS_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\tempfact.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Class Factory template
// 
// 8-20-97 sburns



#ifndef TEMPFACT_HPP_INCLUDED
#define TEMPFACT_HPP_INCLUDED



// COM class factory implementation

template <class C>
class ClassFactory : public IClassFactory
{
   public:

   ClassFactory()
      :
      refcount(1)    // implicit AddRef
   {
      LOG_CTOR(ClassFactory);
   }

   // IUnknown overrides

   virtual
   ULONG __stdcall
   AddRef()
   {
      LOG_ADDREF(ClassFactory::AddRef);   
      return Win::InterlockedIncrement(refcount);
   }

   virtual
   ULONG __stdcall
   Release()
   {
      LOG_RELEASE(ClassFactory);   
      if (Win::InterlockedDecrement(refcount) == 0)
      {
         delete this;
         return 0;
      }

      return refcount;
   }

   virtual 
   HRESULT __stdcall
   QueryInterface(const IID& interfaceID, void** interfaceDesired)
   {
      LOG_FUNCTION(ClassFactory::QueryInterface);
      ASSERT(interfaceDesired);

      HRESULT hr = 0;

      if (!interfaceDesired)
      {
         hr = E_INVALIDARG;
         LOG_HRESULT(hr);
         return hr;
      }

      if (interfaceID == IID_IUnknown)
      {
//         LOG(L"Supplying IUnknown interface");         
         *interfaceDesired =
            static_cast<IUnknown*>(static_cast<IClassFactory*>(this));
      }
      else if (interfaceID == IID_IClassFactory)
      {
//         LOG(L"Supplying IClassFactory interface");
         *interfaceDesired = static_cast<IClassFactory*>(this);
      }
      else
      {
         *interfaceDesired = 0;
         hr = E_NOINTERFACE;
         LOG(
               L"interface not supported: "
            +  Win::StringFromGUID2(interfaceID));
         LOG_HRESULT(hr);
         return hr;
      }

      AddRef();
      return S_OK;
   }

   // IClassFactory overrides
  
   virtual
   HRESULT __stdcall
   CreateInstance(
      IUnknown*   outerUnknown,
      const IID&  interfaceID,
      void**      interfaceDesired)
   {
      LOG_FUNCTION(ClassFactory::CreateInstance);  

      HRESULT hr = 0;

      if (outerUnknown)
      {
         hr = CLASS_E_NOAGGREGATION;
         LOG_HRESULT(hr);
         return hr;
      }

      // the instance starts with a ref count of 1.  If the QI fails, then it
      // will self-destruct upon release.
      C* c = new C;
      hr = c->QueryInterface(interfaceID, interfaceDesired);
      c->Release();

      return hr;
   }

   virtual
   HRESULT __stdcall
   LockServer(BOOL lock)
   {
      LOG_FUNCTION(ClassFactory::LockServer);   
      ComServerLockState::LockServer(lock ? true : false);
      return S_OK;
   }
 
   private:


   
   // only Release can cause us to be deleted

   virtual
   ~ClassFactory()
   {
      LOG_DTOR(ClassFactory);   
      ASSERT(refcount == 0);
   }

   // not implemented; no instance copying allowed.
   ClassFactory(const ClassFactory&);
   const ClassFactory& operator=(const ClassFactory&);

   ComServerReference   dllref;
   long                 refcount;
};
   


#endif   // TEMPFACT_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\validatedomainname.h ===
// Copyright (C) 2001 Microsoft Corporation
//
// resources to be included in programs that use any of the following
//    UnmappableCharactersMessage
//    ForestValidateDomainDoesNotExist (the version that takes a resource ID)
//
// 3 December 2001 JeffJon


#define IDS_UNMAPPABLE_CHARS_IN_NAME         50000
#define IDS_NON_RFC_NAME                     50001
#define IDS_MS_DNS_NAME                      50002
#define IDS_ROOT_DOMAIN_IS_RESERVED          50003
#define IDS_DNS_NAME_TOO_LONG                50004
#define IDS_BAD_DNS_SYNTAX                   50005
#define IDS_MUST_ENTER_DOMAIN                50006
#define IDS_DOMAIN_NAME_IN_USE               50007
#define IDS_NET_NOT_REACHABLE                50008
#define IDS_CONFIRM_NETBIOS_LOOKING_NAME     50009
#define IDS_NO_DOTS_IN_NETBIOS_NAME          50010
#define IDS_NUMERIC_NETBIOS_NAME             50011
#define IDS_BAD_NETBIOS_NAME                 50012
#define IDS_NETBIOS_NAME_TOO_LONG            50013
#define IDS_BAD_NETBIOS_CHARACTERS           50014
#define IDS_FLATNAME_IN_USE                  50015
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\utility.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// global utility functions
// 
// 8-14-97 sburns

                           

#ifndef UTILITY_HPP_INCLUDED
#define UTILITY_HPP_INCLUDED



// Returns true if current process token contains administrators membership.

bool
IsCurrentUserAdministrator();



// Reboots the machine.  Returns S_OK on success.

HRESULT
Reboot();



enum NetbiosValidationResult
{
   VALID_NAME,
   INVALID_NAME,  // contains illegal characters
   NAME_TOO_LONG
};

NetbiosValidationResult
ValidateNetbiosComputerName(const String& s);



NetbiosValidationResult
ValidateNetbiosDomainName(const String& s);



// Inserts a value into the end of the container (by calling push_back on the
// container) iff the value is not already present in the container.  Returns
// true if the value was inserted, or false if it was not.
// 
// Container - class that supports methods begin() and end(), which return
// forward iterators positioned in the usual STL fashion, and push_back.  Also
// must support a nested typedef named value_type indicating the type of
// values that the container contains.
// 
// c - the container
// 
// value - the value to conditionally insert

template <class Container>
bool
push_back_unique(Container& c, const typename Container::value_type& value)
{
   bool result = false;
   if (std::find(c.begin(), c.end(), value) == c.end())
   {
      // value is not already present, so push it onto the end

      c.push_back(value);
      result = true;
   }

   return result;
}



#endif   // UTILITY_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\string.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Enhancement of std::basic_string; Windows-aware version
// 
// 8-14-97 sburns



// Users of this class should assume that none of the member functions here
// are threadsafe: that is, that concurrent calls to member functions on the
// same instance are not guaranteed to produce correct results.  The static
// class functions are, however, threadsafe.



// AnsiStrings are strings of char, and are intended to hold strings from the
// ANSI character set. While you can actually put multibyte characters into an
// ansi string, you must be very careful about character boundaries and use of
// string indexing methods (like op[], find, etc.) because they will not work
// on most multibyte characters.
// 
// Generally, you should use Unicode characters and the String class, and
// convert to an AnsiString only on "data translation" interfaces.
// String::convert supports conversion to AnsiString using a variety of
// codepages.

typedef
   std::basic_string<
      char,
      std::char_traits<char>,
      Burnslib::Heap::Allocator<char> >
   AnsiString;



typedef
   std::basic_string<
      wchar_t,
      std::char_traits<wchar_t>,
      Burnslib::Heap::Allocator<wchar_t> >
   StringBase;



class String : public StringBase
{
   public:

   typedef StringBase base;

   // contructor pass-thrus: we support all of the constructors of the
   // base class.

   explicit String()
      :
      base()
   {
   }

   //lint -e(1931) allow implicit type conversion with this ctor

   String(const base& x)
      :
      base(x)
   {
   }

   String(const String& x, base::size_type p, base::size_type m)
      :
      base(x, p, m)
   {
   }

   String(base::const_pointer s, base::size_type n)
      :
      base(s, n)
   {
   }

   //lint -e(1931) allow implicit type conversion with this ctor

   String(base::const_pointer s)
      :
      base(s)
   {
   }

   String(base::size_type n, base::value_type c)
      :
      base(n, c)
   {
   }

   String(base::const_iterator f, base::const_iterator l)
      :
      base(f, l)
   {
   }


   //
   // Enhancements to the base class std::base
   //



   // conversion from ANSI to Unicode

   String(PCSTR lpsz);
   String(const AnsiString& s);



   // Same as compare, except case is ignored.

   int
   icompare(const String& str) const;



   // returns true if the string consists entirely of digits, false
   // otherwise.

   bool
   is_numeric() const;
      


   // Overload of the replace() family of methods.  Replaces all occurrances
   // of the substring 'from' with the string 'to'.  Returns *this.  All
   // characters of the string are examined exactly once.  If the replacement
   // results in the creation of new occurrances of the 'from' substring,
   // these are not reconsidered.
   //   
   // from - The substring to be replaced.  If 'from' is the empty string,
   // then no change is made.
   //   
   // to - The string to replace 'from'.  If 'to' is the empty string, then
   // all occurrances of 'from' are removed from the string.

   //lint -e(1511) we are properly overloading base::replace

   String&
   replace(const String& from, const String& to);

   // Replaces all occurrances of the characters in the string
   // 'from' with the string 'to'.  Returns *this.  All
   // characters of the string are examined exactly once.  If the replacement
   // results in the creation of new occurrances of the 'from' substring,
   // these are not reconsidered.
   //   
   // from - The character set to be replaced.  If 'from' is the empty string,
   // then no change is made.
   //   
   // to - The string to replace 'from'.  If 'to' is the empty string, then
   // all occurrances of 'from' are removed from the string.

   String&
   replace_each_of(const String& from, const String& to);


   enum StripType
   {
      LEADING = 0x01,
      TRAILING = 0x02,
      BOTH = LEADING | TRAILING
   };

   // Removes all consecutive occurrances of a given character from one or
   // more ends of the string.  Returns *this.

   String&
   strip(
      StripType type = TRAILING,
      wchar_t charToStrip = L' ');



   // Converts all lower case characters of the string to upper case.  Returns
   // *this.

   String&
   to_upper();



   // Converts all upper case characters of the string to lower case.  Returns
   // *this.

   String&
   to_lower();



   // Copy the string into an OLESTR that has been allocated with
   // CoTaskMemAlloc, which the caller is responsible for deleting with
   // CoTaskMemFree.  Returns S_OK on success, E_OUTOFMEMORY if CoTaskMemAlloc
   // fails.
   //       
   // oleString - where to place the allocated copy.

   HRESULT
   as_OLESTR(LPOLESTR& oleString) const;



   enum ConvertResult
   {
      CONVERT_SUCCESSFUL,
      CONVERT_FAILED,
      CONVERT_OVERFLOW,
      CONVERT_UNDERFLOW,
      CONVERT_OUT_OF_MEMORY,
      CONVERT_BAD_INPUT,
      CONVERT_BAD_RADIX
   };

   // Converts the string from Unicode to the ANSI character set, for as many
   // characters as this can be done.  See the restrictions for
   // WideCharToMultiByte.
   //   
   // ansi - the string (i.e. basic_string<char>) in which the result is
   // placed.  If the conversion fails, this is set to the empty string.
   //
   // codePage - the CP_XXX value for the codepage used to perform the
   // conversion.  See WideCharToMultiByte

   // CODEWORK: AnsiString is really a misnomer, if we support multiple
   // codepages. MultiByteString or MbString would be more accurate.

   ConvertResult
   convert(AnsiString& ansi, UINT codePage = CP_ACP) const;



   // For all numeric converions, the string is expected in the following
   // form:
   // 
   // [whitespace] [{+ | }] [0 [{ x | X }]] [digits]
   // 
   // whitespace may consist of space and tab characters, which are ignored;
   // 
   // digits are one or more decimal digits. The first character that does not
   // fit this form stops the scan.
   // 
   // The default radix for the conversion is 10 (decimal).  If radix is 0,
   // then the the initial characters of the string are used to determine the
   // radix for which the digits are to be interpreted. If the first character
   // is 0 and the second character is not 'x' or 'X', the string is
   // interpreted as an octal integer; otherwise, it is interpreted as a
   // decimal number. If the first character is '0' and the second character
   // is 'x' or 'X', the string is interpreted as a hexadecimal integer. If
   // the first character is '1' through '9', the string is interpreted as a
   // decimal integer. The letters 'a' through 'z' (or 'A' through 'Z') are
   // assigned the values 10 through 35; only letters whose assigned values
   // are less than the radix are permitted.  The radix must be within the
   // range from 2 to 36, or the conversion will fail with an error
   // CONVERT_BAD_RADIX, and the result parameter is set to 0.
   //
   // If any additional, unrecognized characters appear in the string, the
   // conversion will fail with an error CONVERT_BAD_INPUT, and the result
   // parameter is set to 0.
   // 
   // If the conversion would produce a result too large or too small for the
   // target type, then the conversion fails with error CONVERT_OVERFLOW or
   // CONVERT_UNDERFLOW, and the result parameter is set to 0.
   // 
   // Conversions for unsigned types allow a plus (+) or minus (-) sign
   // prefix; a leading minus sign indicates that the result value is to be
   // negated.

   ConvertResult
   convert(short& s, int radix = 10) const;

   ConvertResult
   convert(unsigned short& us, int radix = 10) const;

   ConvertResult
   convert(int& i, int radix = 10) const;

   ConvertResult
   convert(long& l, int radix = 10) const;

   ConvertResult
   convert(unsigned& ui, int radix = 10) const;

   ConvertResult
   convert(unsigned long& ul, int radix = 10) const;

   ConvertResult
   convert(double& d) const;

   ConvertResult
   convert(LARGE_INTEGER& li) const;


   // Separates the tokens in the string and pushes them in left-to-right
   // order into the supplied container as a individual String instances. A
   // token is a sequence of characters separated by one or characters in the
   // set of delimiters.  Similar to the strtok function.  Returns the
   // number of tokens placed in the container.
   //
   // usage:
   // String s(L"a list of tokens");
   // StringList tokens;
   // size_t token_count = s.tokenize(back_inserter(tokens));
   // ASSERT(token_count == tokens.size())

   template <class BackInsertableContainer>
   size_t
   tokenize(
      std::back_insert_iterator<BackInsertableContainer>& bii,
      const String& delimiters = String(L" \t") ) const
   {
      size_t tokenCount = 0;
      size_type p1 = 0;

      while (1)
      {
         p1 = find_first_not_of(delimiters, p1);
         if (p1 == npos)
         {
            // no more tokens

            break;
         }
         size_type p2 = find_first_of(delimiters, p1 + 1);
         if (p2 == npos)
         {
            // this is the last token

            *bii++ = substr(p1);  // CODEWORK: substr appears to leak
            ++tokenCount;
            break;
         }

         // the region [p1..(p2 - 1)] is a token

         *bii++ = substr(p1, p2 - p1);  // CODEWORK: substr appears to leak
         ++tokenCount;
         p1 = p2 + 1;
      }

      return tokenCount;
   }



   //
   // static functions 
   //



   // Returns the string resource as a new instance.
   // 
   // resID - resource ID of the string resource to load.

   static
   String
   load(unsigned resId, HINSTANCE hInstance = 0);

   inline 
   static
   String
   load(int resId, HINSTANCE hInstance = 0)
   {
      return String::load(static_cast<unsigned>(resId), hInstance);
   }



   // FormatMessage-style formatted output.

#if defined(ALPHA) || defined(IA64)
//lint -e(1916)   it's ok to use elipsis here
   static
   String __cdecl
   String::format(
      const String& fmt,
      ...);
#else

   // the x86 compiler won't allow the first parameter to be a reference
   // type.  This is a compiler bug.

//lint -e(1916)   it's ok to use elipsis here

   static
   String __cdecl
   String::format(
      const String fmt,
      ...);
#endif

   static
   String __cdecl
   format(const wchar_t* qqfmt, ...);

//lint -e(1916)   it's ok to use elipsis here
   static 
   String __cdecl
   format(unsigned formatResID, ...);

   static 
   String __cdecl
   format(int formatResID, ...);


   //
   // STL support 
   //



   // Function object class for performing case-insensive comparisons of
   // Strings.  Can be used with any STL template involving binary_function.
   //
   // Example:
   //
   // to search a container for a String L"foo" using case-insensitive
   // compare:
   //
   // std::list<String> l;
   // // insert Strings into l...
   // 
   // std::list<String>::iterator i =
   //    std::find_if(
   //       l.begin(),
   //       l.end(),
   //       std::bind1st(String::EqualIgnoreCase(), L"foo"));
   // if (i == l.end())
   // {
   //    // found
   // }

   class EqualIgnoreCase
      :
      public std::binary_function<String, String, bool>
   {
      public:

      // Returns true if f and s are equal, ignoring case in the comparison

      inline
      bool
      operator()(
         const first_argument_type&  f,
         const second_argument_type& s) const
      {
         return (f.icompare(s) == 0);
      }
   };

   class LessIgnoreCase
      :
      public std::binary_function<String, String, bool>
   {
      public:

      // Returns true if f is less than s, ignoring case in the comparison

      inline
      bool
      operator()(
         const first_argument_type&  f,
         const second_argument_type& s) const
      {
         return (f.icompare(s) < 0);
      }
   };



   private:

   // Causes this to control a distinct copy of the string, without any shared
   // references.

   void
   _copy();

   void
   assignFromAnsi(PCSTR lpsz, size_t len);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\wizard.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#ifndef WIZARD_HPP_INCLUDED
#define WIZARD_HPP_INCLUDED



// A Wizard manages the traversal of 1+ WizardPage instances.

class Wizard
{
   public:


   // These values allow evil hacks to access the buttons on the wizard
   // control with GetDlgItem. I discovered the control IDs by using spy++,
   // see also 
   // Don't lecture me about sleazy comctl32 hacks, ok?
   
   enum ButtonIds
   {
      BACK_BTN_ID   = 12323,
      NEXT_BTN_ID   = 12324,
      FINISH_BTN_ID = 12325,
      HELP_BTN_ID   = 9
   };


   
   Wizard(
      unsigned titleStringResID,
      unsigned banner16BitmapResID,
      unsigned banner256BitmapResID,
      unsigned watermark16BitmapResID,
      unsigned watermark1256BitmapResID);
   ~Wizard();



   // Adds the page to the wizard.  Takes ownership of the instance, and
   // will delete it when the Wizard is deleted.

   void
   AddPage(WizardPage* page);



   // Invokes Create on all of the pages that have been added.
   // Calls Win32 ::PropertySheet to display and (modally) execute the
   // wizard.  Returns same values as ::PropertySheet.
   //
   // parentWindow - in, optional, handle to parent window. Default is 0,
   // for which the current desktop window will be used.
   //
   // startPageIndex - in, optional, the index of the page to start the
   // wizard at.  Default is 0, which is the first page that is added
   // using the AddPage method.
   //
   // sheetCallback - in, optional, pointer to a property sheet callback
   // function that will be called by ComCtl32 when the property sheet
   // is being created and destroyed.

   INT_PTR
   ModalExecute(
      HWND parentWindow = 0,
      UINT startPageIndex = 0,
      PFNPROPSHEETCALLBACK sheetCallback = 0);



   // Pushes the current page id on the backtracking stack, and causes the
   // given page to be transitioned to. Should be called in the OnSetActive or
   // OnWizNext method of a WizardPage instance (which is the default behavior
   // of the WizardPage base class).
   //
   // wizardPage - window handle of the current page (the page that is
   // handling OnSetActive or OnWizNext)
   //
   // pageResId - the resource ID of the next page to be shown.   
   
   void
   SetNextPageID(HWND wizardPage, int pageResId);


   
   // Pops the last page id off the history stack, and sets that page to be
   // transitioned to.  Should be called in the OnSetActive or OnWizBack
   // method of a WizardPage instance (which is the default behavior of the
   // WizardPage base class).
   // 
   // wizardPage - window handle of the current page (the page that is
   // handling OnSetActive or OnWizBack)
   
   void
   Backtrack(HWND wizardPage);


   
   // Returns true if Backtrack was the last function called to cause a page
   // transition, false if not.  By checking IsBacktracking in OnSetActive, a
   // WizardPage can determine if it was transitioned to by the user backing
   // up (IsBacktracking = true) or moving forward (IsBacktracking = false).
   
   bool
   IsBacktracking();


   
   private:

   // not implemented: copy not allowed
   
   Wizard(const Wizard&);
   const Wizard& operator=(const Wizard&);

   typedef
      std::list<WizardPage*, Burnslib::Heap::Allocator<WizardPage*> >
      PageList;

   typedef
      std::vector<unsigned, Burnslib::Heap::Allocator<unsigned> >
      UIntVector;


      
   // we derive a new stack class from std::stack to get at the protected
   // container member of that base class. We need to do this for our
   // loop collapsing logic.
   
   class PageIdStack : public std::stack<unsigned, UIntVector>
   {
      public:

      typedef std::stack<unsigned, UIntVector> base;
      
      PageIdStack() : base()
      {
      }


      void
      pop_and_remove_loops();



      void
      push(const value_type& x)
      {
         LOG(String::format(L"push %1!d!", x));

         base::push(x);
         // dump();
      }
      


      private:

//       void
//       dump()
//       {
//          LOG(String::format(L"%1!d!", size()));
//          
//          for (int i = 0; i < size(); ++i)
//          {
//             LOG(String::format(L"%1!d!", c[i]));
//          }
// 
//          // for(
//          //    UIntVector::iterator i = c.begin();
//          //    i != c.end();
//          //    ++i)
//          // {
//          //    LOG(String::format(L"%1!d!", *i));
//          // }
//       }
   };


   
   unsigned    banner16ResId;    
   unsigned    banner256ResId;   
   bool        isBacktracking;   
   PageIdStack pageIdHistory;    
   PageList    pages;            
   unsigned    titleResId;       
   unsigned    watermark16ResId; 
   unsigned    watermark256ResId;
};



#endif   // WIZARD_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\validatedomainname.hpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// functions to validate a new domain name
// The functions are split into validation routines
// and UI retrieving error messages based on the
// error codes returned from the validation routines.
//
// 3 December 2001 JeffJon



#ifndef VALIDATEDOMAINNAME_HPP_INCLUDED
#define VALIDATEDOMAINNAME_HPP_INCLUDED

// Error codes for the ValidateDomainDnsNameSyntax routine

typedef enum
{
   DNS_NAME_VALID,
   DNS_NAME_RESERVED,
   DNS_NAME_NON_RFC,
   DNS_NAME_NON_RFC_OEM_UNMAPPABLE,
   DNS_NAME_NON_RFC_WITH_UNDERSCORE,
   DNS_NAME_TOO_LONG,
   DNS_NAME_BAD_SYNTAX
} DNSNameSyntaxError; 

// Does a syntax validation of the DNS name of the domain
// returning an error code from the DNSNameSyntaxError enum

DNSNameSyntaxError
ValidateDomainDnsNameSyntax(
   const String&  domainName);

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   int    editResID,
   const Popup& popup);

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   int    editResID,
   const Popup& popup,
   bool   warnOnNonRFC,
   bool*  isNonRFC = 0);

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   const String& domainName,
   int    editResID,
   const Popup& popup,
   bool   warnOnNonRFC,
   bool*  isNonRFC = 0);

typedef enum
{
   FOREST_DOMAIN_NAME_EXISTS,
   FOREST_DOMAIN_NAME_EMPTY,
   FOREST_DOMAIN_NAME_DUPLICATE,
   FOREST_NETWORK_UNREACHABLE,
   FOREST_DOMAIN_NAME_DOES_NOT_EXIST
} ForestNameExistsError;

// Checks to see if the name already exists as a domain

ForestNameExistsError
ForestValidateDomainDoesNotExist(
   const String& name);

// Checks to see if the name already exists as a domain by
// retrieving the name from the specified UI control and then
// calling the overloaded ForestValidateDomainDoesNotExist

bool
ForestValidateDomainDoesNotExist(
   HWND   parentDialog,   
   int    editResID,
   const Popup& popup);

// If the new domain name is a single DNS label, then ask the user to confirm
// that name.  If the user rejects the name, set focus to the domain name edit
// box, return false.  Otherwise, return true.
// 
// parentDialog - HWND of the dialog with the edit box control.
// 
// editResID - resource ID of the domain name edit box containing the name to
// be confirmed.
//
// 309670

bool
ConfirmNetbiosLookingNameIsReallyDnsName(
   HWND parentDialog, 
   int editResID,
   const Popup& popup);


typedef enum
{
   NETBIOS_NAME_VALID,
   NETBIOS_NAME_DOT,
   NETBIOS_NAME_EMPTY,
   NETBIOS_NAME_NUMERIC,
   NETBIOS_NAME_BAD,
   NETBIOS_NAME_TOO_LONG,
   NETBIOS_NAME_INVALID,
   NETBIOS_NAME_DUPLICATE,
   NETBIOS_NETWORK_UNREACHABLE
} NetbiosNameError;

NetbiosNameError
ValidateDomainNetbiosName(
   const String& name);

bool
ValidateDomainNetbiosName(
   HWND dialog, 
   int editResID,
   const Popup& popup);


#endif   // VALIDATEDOMAINNAME_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\win.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Wrappers of Win APIs
// 
// 8-14-97 sburns



#ifndef WIN_HPP_INCLUDED
#define WIN_HPP_INCLUDED



// Wrappers of Win32 APIs, doing such nice things as taking Strings
// as parameters, asserting parameters and return values, assuming
// certain parameters such as resource instance handles, and other
// stuff.
// 
// Each function name is identical to the API function it wraps.

namespace Burnslib
{
   
namespace Win
{
   // Win::Error is a subclass of ::Error that automatically maps
   // error codes to message strings, pulling the strings string from
   // various windows system resources.

   class Error : public ::Error
   {
      public:

      // Constructs a new instance.
      // 
      // hr - The HRESULT to keep track of.
      // 
      // summaryResID - ID of the string resource that corresponds to
      // the summary text to be returned by GetSummary().

      Error(HRESULT hr, int summaryResID);



      virtual
      ~Error()
      {
      }


      
      // Overrides the default windows message text.
      //
      // hr - The HRESULT to keep track of.
      //
      // message - The error message that will be returned by calls to
      // GetMessage.
      //
      // summary - the string that will be returned by calls to GetSummary

      Error(HRESULT hr, const String& message, const String& summary);

      HRESULT
      GetHresult() const;

      // Returns the HelpContext that will point the user to
      // assistance in deciphering the error message and details.  For
      // this implementation, this is just the HRESULT parameter
      // passed to the ctor.

      virtual 
      HelpContext
      GetHelpContext() const;

      // Returns the human readable error message from the system
      // error message string table(s).

      virtual 
      String
      GetMessage() const;

      // returns a 1-line summary: The essence of the error, suitable
      // for use as the title of a reporting dialog, for instance.

      virtual 
      String
      GetSummary() const;

      const Error& operator=(const Error& rhs);

      private:

      HRESULT        hr;            
      mutable String message;
      mutable String summary;
      int            summaryResId;
   };



   // A CursorSetting is a convenient trick to change the cursor only
   // for the lifetime of a single code block.  When an instance is
   // constructed, the cursor is changed.  When it is destroyed, the
   // old cursor is restored.
   //
   // Example:
   //
   // {  // open block scope
   //   Win::CursorSetting scope(IDC_WAIT);
   //   // the cursor is now IDC_WAIT
   //
   //   // do something time consuming
   // }  // close block scope
   // // scope destroyed; the cursor is restored to what it was before

   // NOTE: not threadsafe: do not use the same CursorSetting object from
   // multiple threads.
      
   class CursorSetting
   {
      public:

      // Construct a new instance with the named cursor resource.

      explicit
      CursorSetting(const String& newCursorName);

      // MAKEINTRESOURCE version

      explicit
      CursorSetting(
         const TCHAR* newCursorName,
         bool         isSystemCursor = true);

      // Construct a new instance from a valid HCURSOR.
      explicit
      CursorSetting(HCURSOR newCursor);

      ~CursorSetting();

      private:

      HCURSOR oldCursor;

      void init(
         const TCHAR* cursorName,
         bool         isSystemCursor = true);

      // these are not defined

      CursorSetting(const CursorSetting&);
      const CursorSetting& operator=(const CursorSetting&);
   };



   class WaitCursor : public CursorSetting
   {
      public:

      WaitCursor()
         :
         CursorSetting(IDC_WAIT)
      {
      }

      private:

      // these are not defined

      WaitCursor(const WaitCursor&);
      const WaitCursor& operator=(const WaitCursor&);
   };



   HRESULT
   AdjustTokenPrivileges(
      HANDLE             tokenHandle,
      bool               disableAllPrivileges,
      TOKEN_PRIVILEGES   newState[]);



   // Previous state must be freed with BYTE::delete[], which should be done
   // whether or not the function returns a success code.  See
   // AutoTokenPrivileges for a friendly wrapper.
   //
   // tokenHandle - a token opened with TOKEN_ADJUST_PRIVILEGES and
   // TOKEN_QUERY permissions.
   //
   // see the win32 API docs for the meaning of the other params.
   //
   // Ex.
   //
   // TOKEN_PRIVILEGES* oldPrivs = 0;
   // HRESULT hr = AdjustTokenPrivileges(,,,oldPrivs);
   // // do stuff...
   // hr = AdjustTokenPrivileges(,,oldPrivs);   // i.e. the other overload
   // delete[] (BYTE*) oldPrivs;
   // oldPrivs = 0;
         
   HRESULT
   AdjustTokenPrivileges(
      HANDLE             tokenHandle,
      bool               disableAllPrivileges,
      TOKEN_PRIVILEGES   newState[],
      TOKEN_PRIVILEGES*& previousState);
      
      

   HRESULT
   AllocateAndInitializeSid(
      SID_IDENTIFIER_AUTHORITY&  authority,
      BYTE                       subAuthorityCount,
      DWORD                      subAuthority0,
      DWORD                      subAuthority1,
      DWORD                      subAuthority2,
      DWORD                      subAuthority3,
      DWORD                      subAuthority4,
      DWORD                      subAuthority5,
      DWORD                      subAuthority6,
      DWORD                      subAuthority7,
      PSID&                      sid);

#undef Animate_Close

   void
   Animate_Close(HWND animation);
         
#undef Animate_Open

   void
   Animate_Open(HWND animation, const TCHAR* animationNameOrRes);

#undef Animate_Stop

   void
   Animate_Stop(HWND animation);

   HRESULT
   AppendMenu(
      HMENU    menu,     
      UINT     flags,    
      UINT_PTR idNewItem,
      PCTSTR   newItem);

#undef Button_SetCheck

   void
   Button_SetCheck(HWND button, int checkState);

#undef Button_GetCheck

   bool
   Button_GetCheck(HWND button);

#undef Button_SetStyle

   void
   Button_SetStyle(HWND button, int style, bool redraw);

   void
   CheckDlgButton(HWND parentDialog, int buttonID, UINT buttonState);

   void
   CheckRadioButton(
      HWND  parentDialog,
      int   firstButtonInGroupID,
      int   lastButtonInGroupID,
      int   buttonInGroupToCheckID);



   // sets the handle to INVALID_HANDLE_VALUE

   void
   CloseHandle(HANDLE& handle);



   void
   CloseServiceHandle(SC_HANDLE handle);

#undef ComboBox_AddString

   int
   ComboBox_AddString(HWND combo, const String& s);



   // Adds all of the strings in the range defined by the provided iterators
   // to the combo box control, and returns the 0-based index of the last
   // string added.  Returns CB_ERR if an error occurred, or CB_ERRSPACE if
   // insufficient space is available to add the string.
   // 
   // Each element is added in the sequence provided by the iterators.  If an
   // error is encountered, the iteration stops, and the error value is
   // returned.  In other words, remaining elements in the iteration are
   // skipped.
   // 
   // Each element must be a String, or a type convertible to String (PWSTR,
   // etc.)
   // 
   // combo - a HWND for a combo box.
   //    
   // first - a forward iterator set to the first element in the sequence to
   // be added to the combo box.
   // 
   // last - a forward iterator set to just beyond the last element of the
   // sequence.
   // 
   // Example:
   // 
   // StringList fooStrings;
   // fooStrings.push_back(L"hello");
   // fooStrings.push_back(L"world");
   // 
   // int err =
   //    Win::ComboBox_AddStrings(
   //       combo,
   //       fooStrings.begin(),
   //       fooStrings.end());

   template<class ForwardIterator>
   int
   ComboBox_AddStrings(
      HWND              combo,
      ForwardIterator   first,
      ForwardIterator   last)
   {
      ASSERT(Win::IsWindow(combo));

      int err = CB_ERR;
      for (

         // copy the iterators so as not to modify the actual parameters

         ForwardIterator f = first, l = last;
         f != l;
         ++f)
      {
         err = Win::ComboBox_AddString(combo, *f);
         if (err == CB_ERR || err == CB_ERRSPACE)
         {
            break;
         }
      }

      return err;
   }



#undef ComboBox_GetCurSel

   int
   ComboBox_GetCurSel(HWND combo);

   // Retrieves the text of the selected item in the list box of the combo
   // or empty if no item is selected.

   String
   ComboBox_GetCurText(HWND combo);

#undef ComboBox_GetLBText

   String
   ComboBox_GetLBText(HWND combo, int index);

#undef ComboBox_GetLBTextLen

   int
   ComboBox_GetLBTextLen(HWND combo, int index);

#undef ComboBox_SelectString

   int
   ComboBox_SelectString(HWND combo, const String& str);

#undef ComboBox_SetCurSel

   void
   ComboBox_SetCurSel(HWND combo, int index);

#undef ComboBox_SetItemData

   void
   ComboBox_SetItemData(HWND combo, int index, LPARAM data);

#undef ComboBox_GetItemData

   LRESULT
   ComboBox_GetItemData(HWND combo, int index);

   int
   CompareString(
      LCID  locale,
      DWORD flags,
      const String& string1,
      const String& string2);

   HRESULT
   ConnectNamedPipe(
      HANDLE      pipe,
      OVERLAPPED* overlapped);

   HRESULT
   ConvertSidToStringSid(PSID sid, String& result);


   
   // sid must be freed with LocalFree
   
   HRESULT
   ConvertStringSidToSid(const String& sidString, PSID& sid);


   

   HRESULT
   CopyFileEx(
      const String&        existingFileName,
      const String&        newFileName,
      LPPROGRESS_ROUTINE   progressRoutine,
      void*                progressParam,
      BOOL*                cancelFlag,
      DWORD                flags);

   HRESULT
   CopySid(DWORD destLengthInBytes, PSID dest, PSID source);
      
   HRESULT
   CreateDialogParam(
      HINSTANCE      hInstance,	
      const TCHAR*   templateName,
      HWND           owner,
      DLGPROC        dialogProc,
      LPARAM         param,
      HWND&          result);

   HRESULT
   CreateDirectory(const String& path);

   

   HRESULT
   CreateDirectory(const String& path, const SECURITY_ATTRIBUTES& sa);
   


   HRESULT
   CreateEvent(
      SECURITY_ATTRIBUTES* securityAttributes,
      bool                 manualReset,
      bool                 initiallySignaled,
      HANDLE&              result);

   HRESULT
   CreateEvent(
      SECURITY_ATTRIBUTES* securityAttributes,
      bool                 manualReset,
      bool                 initiallySignaled,
      const String&        name,
      HANDLE&              result);

   HRESULT
   CreateFile(
      const String&        fileName,
      DWORD                desiredAccess,	
      DWORD                shareMode, 
      SECURITY_ATTRIBUTES* securityAttributes,	
      DWORD                creationDistribution,
      DWORD                flagsAndAttributes,
      HANDLE               hTemplateFile,
      HANDLE&              result);

   HRESULT
   DeleteFile(const String& fileName);

   HRESULT
   CreateFontIndirect(
      const LOGFONT& logFont,
      HFONT&         result);

   HRESULT
   CreateMailslot(
      const String&        name,
      DWORD                maxMessageSize,
      DWORD                readTimeout,
      SECURITY_ATTRIBUTES* attributes,
      HANDLE&              result);

   HRESULT
   CreateMutex(
      SECURITY_ATTRIBUTES* attributes,
      bool                 isInitialOwner,
      const String&        name,
      HANDLE&              result);

   HRESULT
   CreateNamedPipe(
      const String&        name,
      DWORD                openMode,
      DWORD                pipeMode,
      DWORD                maxInstances,
      DWORD                outBufferSizeInBytes,
      DWORD                inBufferSizeInBytes,
      DWORD                defaultTimeout,
      SECURITY_ATTRIBUTES* sa,
      HANDLE&              result);

   HRESULT
   CreatePopupMenu(HMENU& result);

#undef CreateProcess

   // ISSUE-2002/03/07-sburns depricate this version:
         
   HRESULT
   CreateProcess(
      String&              commandLine,
      SECURITY_ATTRIBUTES* processAttributes,
      SECURITY_ATTRIBUTES* threadAttributes,
      bool                 inheritHandles,
      DWORD                creationFlags,
      void*                environment,
      const String&        currentDirectory,
      STARTUPINFO&         startupInformation,
      PROCESS_INFORMATION& processInformation);

      
   // applicationFullPath - REQUIRED. The win32 CreateProcess API allows the
   // application name to be unspecified. In that case, the command line param
   // needs to ensure that the executable is properly quoted. Also, the Win32
   // API allows a relative path to the application.
   // 
   // Those characteristics are security vulnerabilities, so our version
   // requires the applicationFullPath, and requires it to be a full-qualified
   // absolute path name. Otherwise, E_INVALIDARG is returned
   //
   // commandLine - optional. The command line to be passed to the process
   // started. May be modified by the call, to what end I can't fathom. The
   // applicationFullPath will be prepended to this value to form the
   // customary first command line parameter.
   //
   // creationFlags - same as Win32 API.
   //
   // currentDirectory - optional, but if a non-empty string is passed, it
   // must be an absolute path to refer to an existing folder. Otherwise,
   // E_INVALIDARG is returned.
   //
   // startupInformation - same as Win32 API.
   //
   // processInformation - same as Win32 API.
      
   HRESULT
   CreateProcess(
      const String&        applicationFullPath,
      String&              commandLine,
      DWORD                creationFlags,
      const String&        currentDirectory,
      STARTUPINFO&         startupInformation,
      PROCESS_INFORMATION& processInformation);



   HRESULT
   CreatePropertySheetPage(
      const PROPSHEETPAGE& pageInfo,
      HPROPSHEETPAGE&      result);

   HRESULT
   CreateSolidBrush(
      COLORREF color,
      HBRUSH&  result);
      
   HRESULT
   CreateStreamOnHGlobal(
      HGLOBAL     hglobal,
      bool        deleteOnRelease,
      IStream*&   result);
      
   HRESULT
   CreateWindowEx(
      DWORD          exStyle,      
      const String&  className,
      const String&  windowName,
      DWORD          style,
      int            x,
      int            y,
      int            width,
      int            height,
      HWND           parent,
      HMENU          menuOrChildID,
      void*          param,
      HWND&          result);


      
   // Caller must free the cypherText.pbData member with ::LocalFree
   
   HRESULT
   CryptProtectData(const DATA_BLOB& clearText, DATA_BLOB& cypherText);


   
   // Caller must free the clearText.pbData member with ::LocalFree

   HRESULT
   CryptUnprotectData(const DATA_BLOB& cypherText, DATA_BLOB& clearText);


   
   // for protecting in-memory buffers. On success, buffer is overwritten
   // with the cyphertext.  On failure, the buffer is untouched.

   HRESULT
   CryptProtectMemory(
      void*  buffer,           
      size_t bufferSizeInBytes,
      DWORD  flags = CRYPTPROTECTMEMORY_SAME_PROCESS);



   // must be called with the same flags as CryptProtectMemory. On success,
   // buffer is overwritten with the cleartext. On failure, the buffer is
   // untouched.
   
   HRESULT
   CryptUnprotectMemory(
      void*  buffer,           
      size_t bufferSizeInBytes,
      DWORD  flags = CRYPTPROTECTMEMORY_SAME_PROCESS);



   HRESULT
   DeleteFile(const String& path);

   // object is set to 0

   HRESULT
   DeleteObject(HGDIOBJ& object);

   HRESULT
   DeleteObject(HFONT& object);

   HRESULT
   DeleteObject(HBITMAP& object);
   
   HRESULT
   DeleteObject(HBRUSH& object);

   // icon is set to 0

   HRESULT
   DestroyIcon(HICON& icon);

   // menu is set to 0

   HRESULT
   DestroyMenu(HMENU& menu);
      
   // page is set to 0

   HRESULT
   DestroyPropertySheetPage(HPROPSHEETPAGE& page);
      
   // window is set to 0

   HRESULT
   DestroyWindow(HWND& window);
         
   INT_PTR
   DialogBoxParam(
      HINSTANCE      hInstance,	
      const TCHAR*   templateName,
      HWND           owner,
      DLGPROC        dialogProc,
      LPARAM         param);


      
   // Returns the resource ID of the default push button control on the
   // dialog.  If there is not, or on error, returns 0.
   
   int
   Dialog_GetDefaultButtonId(HWND dialog);

   

   // Sets the default push button on the dialog to the button with the
   // given resource ID.  Note that this will not necessarily remove the
   // default pushbutton style from the button that previously had that
   // state (use Button_SetStyle to do that).
   
   void
   Dialog_SetDefaultButtonId(HWND dialog, int buttonResId);   

   

   HRESULT
   DisconnectNamedPipe(HANDLE pipe);

   HRESULT
   DrawFocusRect(HDC dc, const RECT& rect);

   // appends text to the contents of an edit control.
   //
   // editbox - HWND of the edit control
   //
   // text - text to append.  Must not be empty.
   //
   // preserveSelection - true to keep any active selection, false to move
   // the care to the end of the appended text.
   //
   // canUndo - true to allow undo of the append, false if not.

   void
   Edit_AppendText(
      HWND           editbox,
      const String&  text,
      bool           preserveSelection = true,
      bool           canUndo = true);

#undef Edit_GetSel

   void
   Edit_GetSel(HWND editbox, int& start, int& end);
         
#undef Edit_LimitText

   void
   Edit_LimitText(HWND editbox, int limit);

#undef Edit_ReplaceSel

   void
   Edit_ReplaceSel(HWND editbox, const String& newText, bool canUndo);
      
#undef Edit_SetSel

   void
   Edit_SetSel(HWND editbox, int start, int end);

   bool
   EqualSid(PSID sid1, PSID sid2);
         
   void
   EnableWindow(HWND window, bool state);

   HRESULT
   EndDialog(HWND dialog, int result);

#undef EnumUILanguages

   HRESULT
   EnumUILanguages(
      UILANGUAGE_ENUMPROCW proc,
      DWORD                flags,
      LONG_PTR             lParam);

   HRESULT
   ExitWindowsEx(UINT options);

   // expands strings in s, returns s on failure, expanded version on
   // success.

   String
   ExpandEnvironmentStrings(const String& s);
      
   HRESULT
   FindFirstFile(
      const String&     fileName,
      WIN32_FIND_DATA&  data,
      HANDLE&           result);
      
   HRESULT
   FindClose(HANDLE& findHandle);

   HRESULT
   FindNextFile(HANDLE& findHandle, WIN32_FIND_DATA& data);


   
   // Searches the module indicated by GetResourceModuleHandle()
   
   HRESULT
   FindResource(PCWSTR name, PCWSTR type, HRSRC& result);


   
   HRESULT
   FlushFileBuffers(HANDLE handle);

   HRESULT
   FrameRect(HDC dc, const RECT& rect, HBRUSH brush);

   HRESULT
   FreeLibrary(HMODULE& module);

   void
   FreeSid(PSID sid);

   // used to free the result returned by Win::GetTokenInformation
                  
   void
   FreeTokenInformation(TOKEN_USER* userInfo);
   
   HWND
   GetActiveWindow();

   // for Windows pre-defined classes.
         
   HRESULT
   GetClassInfoEx(const String& className, WNDCLASSEX& info);

   HRESULT
   GetClassInfoEx(
      HINSTANCE      hInstance,
      const String&  className,
      WNDCLASSEX&    info);

   String
   GetClassName(HWND window);

   String
   GetClipboardFormatName(UINT format);

   HRESULT
   GetClientRect(HWND window, RECT& rect);

   HRESULT
   GetColorDepth(int& result);

   String
   GetCommandLine();

   // Inserts the command line arguments of the current process into the
   // provided list.  The list is not cleared beforehand.  The list is similar
   // to the traditional argv array.  Returns the number of args inserted.
   //
   // Use instead of ::GetCommandLine, ::ComandLineToArgVW.
   //
   // BackInsertionSequence - any type that supports the construction of
   // a back_insert_iterator on itself, and has a value type that can be
   // constructed from an PWSTR.
   //
   // bii - a reference to a back_insert_iterator of the
   // BackInsertionSequence template parameter.  The simplest way to make
   // one of these is to use the back_inserter helper function.
   //
   // Example:
   //
   // StringList container;
   // int argCount = Win::GetCommandLineArgs(std::back_inserter(container));
   //
   // StringVector container;
   // int argCount = Win::GetCommandLineArgs(std::back_inserter(container));

   template <class BackInsertableContainer>
   int
   GetCommandLineArgs(
      std::back_insert_iterator<BackInsertableContainer>& bii)
   {
      PWSTR* clArgs   = 0;
      int    argCount = 0;
      int    retval   = 0;

      clArgs =
         ::CommandLineToArgvW(Win::GetCommandLine().c_str(), &argCount);
      ASSERT(clArgs);
      if (clArgs)
      {
         for (retval = 0; retval < argCount; retval++)
         {
            // the container values can be any type that can be constructed
            // from PWSTR...

            //lint --e(*)  lint does not grok back_insert_iterator
            *bii++ = clArgs[retval];
         }

         Win::GlobalFree(clArgs);
      }

      ASSERT(argCount == retval);

      return retval;
   }

   // HRESULT
   // GetComputerNameEx(COMPUTER_NAME_FORMAT format, String& result);

   String
   GetComputerNameEx(COMPUTER_NAME_FORMAT format);

   HRESULT
   GetCurrentDirectory(String& result);

   HANDLE
   GetCurrentProcess();
   
   HRESULT
   GetCursorPos(POINT& result);

   HRESULT
   GetDC(HWND window, HDC& result);

   int
   GetDeviceCaps(HDC hdc, int index);

   HWND
   GetDesktopWindow();

   HRESULT
   GetDiskFreeSpaceEx(
      const String&     path,
      ULARGE_INTEGER&   available,
      ULARGE_INTEGER&   total,
      ULARGE_INTEGER*   free);
      
   HWND
   GetDlgItem(HWND parentDialog, int itemResID);

   String
   GetDlgItemText(HWND parentDialog, int itemResID);

   int
   GetDlgItemInt(HWND parentDialog, int itemResID, bool isSigned = false);

   UINT
   GetDriveType(const String& path);

   EncryptedString
   GetEncryptedDlgItemText(HWND parentDialog, int itemResID);

   String
   GetEnvironmentVariable(const String& name);

   HRESULT
   GetExitCodeProcess(HANDLE hProcess, DWORD& exitCode);

   HRESULT
   GetFileAttributes(const String& path, DWORD& result);

   HRESULT
   GetFileSizeEx(HANDLE handle, LARGE_INTEGER& result);

   DWORD
   GetFileType(HANDLE handle);
            
   // DWORD
   // GetLastError();

   HRESULT
   GetFullPathName(const String& path, String& result);

   HRESULT
   GetLastErrorAsHresult();

   void
   GetLocalTime(SYSTEMTIME& time);

   HRESULT
   GetDateFormat(
      const SYSTEMTIME& date,
      String& formattedDate,
      LCID locale = LOCALE_USER_DEFAULT,
      DWORD flags = 0);

   HRESULT
   GetTimeFormat(
      const SYSTEMTIME& time,
      String& formattedTime,
      LCID locale = LOCALE_USER_DEFAULT,
      DWORD flags = 0);

   HRESULT
   GetLogicalDriveStrings(size_t bufChars, TCHAR* buf, DWORD& result);

   HRESULT
   GetMailslotInfo(
      HANDLE   mailslot,
      DWORD*   maxMessageSize,
      DWORD*   nextMessageSize,
      DWORD*   messageCount,
      DWORD*   readTimeout);

   String
   GetModuleFileName(HMODULE hModule);

   // of this process exe

   HINSTANCE
   GetModuleHandle();

   HWND
   GetParent(HWND child);

   String
   GetPrivateProfileString(
      const String& section,
      const String& key,
      const String& defaultValue,
      const String& filename);

   HRESULT
   GetProcAddress(HMODULE module, const String& procName, FARPROC& result);

   HRESULT
   GetStringTypeEx(
      LCID           localeId,
      DWORD          infoTypeOptions,
      const String&  sourceString,
      WORD*          charTypeInfo);

   DWORD
   GetSysColor(int element);

   HBRUSH
   GetSysColorBrush(int element);

   // returns %systemroot%\system32

   String
   GetSystemDirectory();

   void
   GetSystemInfo(SYSTEM_INFO& info);

   // returns %systemroot%, always (even under terminal server).

   String
   GetSystemWindowsDirectory();

//    // returns %systemroot%, always
// 
//    String
//    GetSystemRootDirectory();

   int
   GetSystemMetrics(int index);

#undef GetTempPath
   
   HRESULT
   GetTempPath(String& result);
         
   HRESULT
   GetTextExtentPoint32(HDC hdc, const String& string, SIZE& size);

   HRESULT
   GetTextMetrics(HDC hdc, TEXTMETRIC& tm);

   // free the result with Win::FreeTokenInformation.
   //
   // allocates the result and returns it thru userInfo.
      
   HRESULT
   GetTokenInformation(HANDLE hToken, TOKEN_USER*& userInfo);

   // ... other varations of GetTokenInformation could be defined for
   // other infomation classes...
   
   // trims off leading and trailing whitespace

   String
   GetTrimmedDlgItemText(HWND parentDialog, int itemResID);

   // trims off leading and trailing whitespace

   String
   GetTrimmedWindowText(HWND window);

   HRESULT
   GetVersionEx(OSVERSIONINFO& info);

   HRESULT
   GetVersionEx(OSVERSIONINFOEX& info);

   HRESULT
   GetVolumeInformation(
      const String&  volume,
      String*        name,
      DWORD*         serialNumber,
      DWORD*         maxFilenameLength,
      DWORD*         flags,
      String*        fileSystemName);

   HRESULT
   GetWindowDC(HWND window, HDC& result);

#undef GetWindowFont

   HFONT
   GetWindowFont(HWND window);

   HRESULT
   GetWindowPlacement(HWND window, WINDOWPLACEMENT& placement);

   HRESULT
   GetWindowRect(HWND window, RECT& rect);

   // returns %windir%, which may vary for terminal server users.

   String
   GetWindowsDirectory();

#undef GetWindowLong

   HRESULT
   GetWindowLong(HWND window, int index, LONG& result);

#undef GetWindowLongPtr

   HRESULT
   GetWindowLongPtr(HWND window, int index, LONG_PTR& result);

   String
   GetWindowText(HWND window);

   HRESULT
   GlobalAlloc(UINT flags, size_t bytes, HGLOBAL& result);

   HRESULT
   GlobalFree(HGLOBAL mem);

   HRESULT
   GlobalLock(HGLOBAL mem, PVOID& result);

   HRESULT
   GlobalUnlock(HGLOBAL mem);

   void
   HtmlHelp(
      HWND           caller,
      const String&  file,
      UINT           command,
      DWORD_PTR      data);

#undef ImageList_Add

   int
   ImageList_Add(HIMAGELIST list, HBITMAP image, HBITMAP mask);

#undef ImageList_AddIcon

   int
   ImageList_AddIcon(HIMAGELIST list, HICON icon);

#undef ImageList_AddMasked

   int
   ImageList_AddMasked(HIMAGELIST list, HBITMAP bitmap, COLORREF mask);

   HIMAGELIST
   ImageList_Create(
      int      pixelsx, 	
      int      pixelsy, 	
      UINT     flags, 	
      int      initialSize, 	
      int      reserve);

   HRESULT
   InitializeSecurityDescriptor(SECURITY_DESCRIPTOR& sd);

   LONG
   InterlockedDecrement(LONG& addend);

   LONG
   InterlockedIncrement(LONG& addend);

   bool
   IsDlgButtonChecked(HWND parentDialog, int buttonResID);

   // returns true if the name matches one of the local computer's names
   // (case insensitive)

   bool
   IsLocalComputer(const String& computerName);    

   bool
   IsWindow(HWND candidate);

   bool
   IsWindowEnabled(HWND window);
   
#undef ListBox_AddString

   int
   ListBox_AddString(HWND box, const String& s);

#undef ListBox_SetItemData

   int
   ListBox_SetItemData(HWND box, int index, LPARAM value);

#undef ListBox_GetItemData

   LPARAM
   ListBox_GetItemData(HWND box, int index);

#undef ListBox_SetCurSel

   int
   ListBox_SetCurSel(HWND box, int index);

#undef ListBox_GetCurSel

   int
   ListBox_GetCurSel(HWND box);

#undef ListView_DeleteAllItems

   bool
   ListView_DeleteAllItems(HWND listview);
      
#undef ListView_DeleteItem

   bool
   ListView_DeleteItem(HWND listview, int item);

#undef ListView_GetItem

   bool
   ListView_GetItem(HWND listview, LVITEM& item);

#undef ListView_GetItemCount

   int
   ListView_GetItemCount(HWND listview);

#undef ListView_GetItemState

   UINT
   ListView_GetItemState(HWND listview, int index, UINT mask);

#undef ListView_GetSelectedCount

   int
   ListView_GetSelectedCount(HWND listview);

#undef ListView_GetSelectionMark

   int
   ListView_GetSelectionMark(HWND listview);

#undef ListView_InsertColumn

   int
   ListView_InsertColumn(HWND listview, int index, const LVCOLUMN& column);

#undef ListView_InsertItem

   int
   ListView_InsertItem(HWND listview, const LVITEM& item);


   
#undef ListView_SetColumnWidth

   bool
   ListView_SetColumnWidth(HWND listview, int col, int cx);


   
#undef ListView_SetExtendedListViewStyle

   // Our version returns the previous extended styles
   
   DWORD
   ListView_SetExtendedListViewStyle(HWND listview, DWORD exStyle);


   
#undef ListView_SetExtendedListViewStyleEx
   
   // Our version returns the previous extended styles
   
   DWORD
   ListView_SetExtendedListViewStyleEx(
      HWND  listview,
      DWORD mask,
      DWORD exStyle);

      

#undef ListView_SetImageList

   HIMAGELIST
   ListView_SetImageList(HWND listview, HIMAGELIST images, int type);

#undef ListView_SetItem

   void
   ListView_SetItem(HWND listview, const LVITEM& item);
      
#undef ListView_SetItemText

   void
   ListView_SetItemText(
      HWND listview, 
      int item, 
      int subItem, 
      const String& text);

#undef ListView_SetItemState

   void
   ListView_SetItemState(
      HWND listview, 
      int item, 
      UINT state, 
      UINT mask);

   HRESULT
   LoadBitmap(unsigned resId, HBITMAP& result);
      
   HRESULT   
   LoadCursor(const String& cursorName, HCURSOR& result);

   // provided for MAKEINTRESOURCE versions of cursorName

   HRESULT
   LoadCursor(
      const TCHAR* cursorName,
      HCURSOR&     result,
      bool         isSystemCursor = true);

   HRESULT
   LoadIcon(int resID, HICON& result);

   HRESULT
   LoadImage(unsigned resID, unsigned type, HANDLE& result);

   HRESULT
   LoadImage(unsigned resID, HICON& result);

   HRESULT
   LoadImage(unsigned resID, HBITMAP& result);


   
   HRESULT
   LoadLibrary(const String& libFileName, HINSTANCE& result);
         

         
   HRESULT
   LoadLibraryEx(const String& libFileName, DWORD flags, HINSTANCE& result);


  
   HRESULT
   LoadMenu(unsigned resID, HMENU& result);


   
   // Loads from the module indicated by GetResourceModuleHandle()

   HRESULT
   LoadResource(HRSRC handle, HGLOBAL& result);


   
   // Loads from the module indicated by GetResourceModuleHandle()

   String
   LoadString(unsigned resID);

   String
   LoadString(unsigned resID, HINSTANCE hInstance);

   HRESULT
   LocalFree(HLOCAL mem);

   HRESULT
   LookupAccountSid(
      const String&  machineName,
      PSID           sid,
      String&        accountName,
      String&        domainName);

#undef LookupPrivilegeValue

   HRESULT
   LookupPrivilegeValue(
      const TCHAR* systemName,
      const TCHAR* privName,
      LUID& luid);

      
      
   // if you pass 0 for from, then this will convert from screen coords
   
   HRESULT
   MapWindowPoints(
      HWND  from,
      HWND  to,
      RECT& rect,
      int*  dh = 0,      // number of pixels added to horizontal coord
      int*  dv = 0);     // number of pixels added to vertical coord

   int
   MessageBox(
      HWND           owner,
      const String&  text,
      const String&  title,
      UINT           flags);

   HRESULT
   MoveFileEx(
      const String& srcPath,
      const String& dstPath,
      DWORD         flags);

   HRESULT
   MoveWindow(
      HWND  window,
      int   x,
      int   y,
      int   width,
      int   height,
      bool  shouldRepaint);

   HRESULT
   OpenProcessToken(
      HANDLE   processHandle,
      DWORD    desiredAccess,
      HANDLE&  tokenHandle);

   HRESULT
   OpenSCManager(
      const String&  machine,
      DWORD          desiredAccess,
      SC_HANDLE&     result);

   HRESULT
   OpenService(
      SC_HANDLE      managerHandle,
      const String&  serviceName,
      DWORD          desiredAccess,
      SC_HANDLE&     result);

   HRESULT
   ChangeServiceConfig(
      SC_HANDLE      serviceHandle,
      DWORD          serviceType,
      DWORD          serviceStartType,
      DWORD          errorControl,
      const String&  binaryPath,
      const String&  loadOrderingGroup,
      DWORD*         tagID,
      const String&  dependencies,
      const String&  accountName,
      EncryptedString& password,
      const String&  displayName);

   void
   OutputDebugString(const String& string);

   HRESULT
   PeekNamedPipe(
      HANDLE pipe,                     
      void*  buffer,                   
      DWORD  bufferSize,               
      DWORD* bytesRead,                
      DWORD* bytesAvailable,           
      DWORD* bytesRemainingThisMessage);

   HRESULT
   PostMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam);

   HRESULT
   PropertySheet(PROPSHEETHEADER* header, INT_PTR& result);

#undef PropSheet_Changed

   void
   PropSheet_Changed(HWND propSheet, HWND page);

#undef PropSheet_Unchanged

   void
   PropSheet_Unchanged(HWND propSheet, HWND page);

#undef PropSheet_RebootSystem

   void
   PropSheet_RebootSystem(HWND propSheet);

#undef PropSheet_SetTitle

   void
   PropSheet_SetTitle(
      HWND propSheet,
      DWORD style,
      const String& title);
      
#undef PropSheet_SetHeaderSubTitle

   void
   PropSheet_SetHeaderSubTitle(
      HWND propSheet,
      int  pageIndex,
      const String& subTitle);

#undef PropSheet_SetWizButtons

   void
   PropSheet_SetWizButtons(HWND propSheet, DWORD buttonFlags);

#undef PropSheet_PressButton

   void
   PropSheet_PressButton(HWND propSheet, DWORD buttonID);

#undef PropSheet_HwndToIndex

   int
   PropSheet_HwndToIndex(
      HWND propSheet,
      HWND page);

#undef PropSheet_IdToIndex

   int
   PropSheet_IdToIndex(
      HWND propSheet,
      int  pageId);

   HRESULT
   QueryServiceStatus(
      SC_HANDLE       handle,
      SERVICE_STATUS& status);

   HRESULT
   ReadFile(
      HANDLE      file,
      void*       buffer,
      DWORD       bytesToRead,
      DWORD&      bytesRead,
      OVERLAPPED* overlapped);

   void
   ReleaseStgMedium(STGMEDIUM& medium);

   HRESULT
   RegCloseKey(HKEY hKey);

   HRESULT
   RegConnectRegistry(
      const String&  machine,
      HKEY           hKey,
      HKEY&          result);

   HRESULT
   RegCreateKeyEx(
      HKEY                 hKey,
      const String&        subkeyName,
      DWORD                options,
      REGSAM               access,
      SECURITY_ATTRIBUTES* securityAttrs,
      HKEY&                result,
      DWORD*               disposition);

   HRESULT
   RegDeleteValue(
      HKEY           hKey,
      const String&  valueName);

   HRESULT
   RegOpenKeyEx(
      HKEY           hKey,
      const String&  subKey,
      REGSAM         accessDesired,
      HKEY&          result);
      
   HRESULT
   RegQueryValueEx(
      HKEY           hKey,
      const String&  valueName,
      DWORD*         type,
      BYTE*          data,
      DWORD*         dataSize);


   
   // You should really use the Registry class -- it's typesafe.
   
   HRESULT
   RegSetValueEx(
      HKEY           hKey,
      const String&  valueName,
      DWORD          type,
      const BYTE*    data,
      size_t         dataSizeInBytes);

   HRESULT 
   RegisterClassEx(const WNDCLASSEX& wndclass, ATOM& result);

   CLIPFORMAT
   RegisterClipboardFormat(const String& name);

   void
   ReleaseDC(HWND window, HDC dc);

   HRESULT
   ReleaseMutex(HANDLE mutex);

   HRESULT
   RemoveDirectory(const String& path);

   inline
   HRESULT
   RemoveFolder(const String& path)
   {
      return Win::RemoveDirectory(path);
   }

   HRESULT
   ResetEvent(HANDLE event);



   // Returns the previous mask.
   
   DWORD
   RichEdit_SetEventMask(HWND richEdit, DWORD mask);

   void
   RichEdit_GetSel(
      HWND       richEdit,
      CHARRANGE& range);



   // returns the number of bytes streamed
   
   int
   RichEdit_StreamIn(
      HWND        richEdit,
      WPARAM      formatOptions,
      EDITSTREAM& editStream);

   int
   RichEdit_SetRtfText(HWND richEdit, DWORD flags, const String& rtfText);

   void
   RichEdit_SetSel(
      HWND              richEdit,
      const CHARRANGE&  range);
      
   int
   RichEdit_SetText(HWND richEdit, DWORD flags, const String& text);
   
   bool   
   RichEdit_SetCharacterFormat(
      HWND         richEdit,
      DWORD        options, 
      CHARFORMAT2& format);

   HRESULT
   ScreenToClient(HWND window, POINT& point);

   HRESULT
   ScreenToClient(HWND window, RECT& rect);

   HGDIOBJ
   SelectObject(HDC hdc, HGDIOBJ hobject);
      
   LRESULT
   SendMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam);
  
   HRESULT
   SetComputerNameEx(COMPUTER_NAME_FORMAT format, const String& newName);

   HRESULT
   SetCurrentDirectory(const String& path);
   
   HCURSOR
   SetCursor(HCURSOR newCursor);

   HRESULT   
   SetDlgItemText(
      HWND           parentDialog,
      int            itemResID,
      const String&  text);

   inline
   HRESULT   
   SetDlgItemText(
      HWND parentDialog,
      int  itemResID,   
      int  textResID)   
   {
      return
         Win::SetDlgItemText(
            parentDialog,
            itemResID,
            String::load(textResID));
   }

   HRESULT   
   SetDlgItemText(
      HWND                 parentDialog, 
      int                  itemResID,    
      const EncryptedString& cypherText);



   HRESULT
   SetEntriesInAcl(
      ULONG           countOfEntries,
      EXPLICIT_ACCESS eaArray[],
      PACL&           result);

      

   HRESULT
   SetEvent(HANDLE event);

   HRESULT
   SetFileAttributes(const String& path, DWORD newAttrs);
   
   HRESULT
   SetFilePointerEx(
      HANDLE               handle,
      const LARGE_INTEGER& distanceToMove,
      LARGE_INTEGER*       newPosition,
      DWORD                moveMethod);


      
   HRESULT
   SetFileSecurity(
      const String&              path,
      SECURITY_INFORMATION       si,
      const SECURITY_DESCRIPTOR& sd);

      

   HWND
   SetFocus(HWND window);

   bool
   SetForegroundWindow(HWND window);

   

   // ISSUE-2002/04/23-sburns This version is silly: daclPresent and
   // daclDefaulted are always the same.
    
   HRESULT
   SetSecurityDescriptorDacl(
      SECURITY_DESCRIPTOR& sd,
      bool                 daclPresent,
      ACL&                 dacl,             // ref to prevent null dacl
      bool                 daclDefaulted);


      
   HRESULT
   SetSecurityDescriptorDacl(
      SECURITY_DESCRIPTOR& sd,
      ACL&                 dacl);            // ref to prevent null dacl
      

      
   HRESULT
   SetSecurityDescriptorOwner(SECURITY_DESCRIPTOR& sd, SID* ownerSid);
   
   
      
#undef SetWindowFont

   void
   SetWindowFont(HWND window, HFONT font, bool redraw);
      
#undef SetWindowLong

   HRESULT
   SetWindowLong(
      HWND  window,  
      int   index,   
      LONG  value,   
      LONG* oldValue = 0);

#undef SetWindowLongPtr

   HRESULT
   SetWindowLongPtr(
      HWND      window,   
      int       index,    
      LONG_PTR  value,    
      LONG_PTR* oldValue = 0);

   HRESULT
   SetWindowPos(
      HWND  window,
      HWND  insertAfter,
      int   x,
      int   y,
      int   width,
      int   height,
      UINT  flags);

   HRESULT
   SetWindowText(HWND window, const String& text);

   LPITEMIDLIST
   SHBrowseForFolder(BROWSEINFO& bi);

   HRESULT
   SHGetMalloc(LPMALLOC& pMalloc);

   String
   SHGetPathFromIDList(LPCITEMIDLIST pidl);
      
   HRESULT
   SHGetSpecialFolderLocation(
      HWND          hwndOwner, 	
      int           nFolder, 	
      LPITEMIDLIST& pidl);

   void
   ShowWindow(HWND window, int swOption);

   HRESULT
   SizeofResource(HRSRC handle, DWORD& result);
    
   // 'Spin' is a synonym for 'Up-Down' control

   void
   Spin_GetRange(HWND spinControl, int* low, int* high);

   void
   Spin_SetRange(HWND spinControl, int low, int high);

   int
   Spin_GetPosition(HWND spinControl);

   void
   Spin_SetPosition(HWND spinControl, int position);


#undef Static_SetIcon

   void
   Static_SetIcon(HWND staticText, HICON icon);
  
   String
   StringFromCLSID(const CLSID& clsID);

   // inline synonym

   inline
   String
   CLSIDToString(const CLSID& clsID)
   {
      return StringFromCLSID(clsID);
   }

   String
   StringFromGUID2(const GUID& guid);

   // inline synonym

   inline
   String
   GUIDToString(const GUID& guid)
   {
      return StringFromGUID2(guid);
   }
      
   HRESULT
   SystemParametersInfo(
      UINT  action,
      UINT  param,
      void* vParam,
      UINT  WinIni);

   HRESULT 
   TlsAlloc(DWORD& result);

   HRESULT
   TlsFree(DWORD index);

   HRESULT
   TlsSetValue(DWORD index, PVOID value);

   HRESULT
   TlsGetValue(DWORD index, PVOID& result);

   HRESULT
   UpdateWindow(HWND winder);

   bool
   ToolTip_AddTool(HWND toolTip, TOOLINFO& info);

   bool
   ToolTip_GetToolInfo(HWND toolTip, TOOLINFO& info);

   bool
   ToolTip_SetTitle(HWND toolTip, int icon, const String& title);

   void
   ToolTip_TrackActivate(HWND toolTip, bool activate, TOOLINFO& info);
   
   void
   ToolTip_TrackPosition(HWND toolTip, int xPos, int yPos);
   
   HRESULT
   UnregisterClass(const String& classname, HINSTANCE module);

   HRESULT
   WaitForSingleObject(
      HANDLE   object,       
      unsigned timeoutMillis,
      DWORD&   result);

   HRESULT
   WideCharToMultiByte(
      DWORD          flags,
      const String&  string,
      char*          buffer,
      size_t         bufferSize,
      size_t&        result);

   HRESULT
   WinHelp(
      HWND           window,
      const String&  helpFileName,
      UINT           command,
      ULONG_PTR      data);
      
   HRESULT
   WriteFile(
      HANDLE      handle, 
      const void* buffer,
      DWORD       numberOfBytesToWrite,
      DWORD*      numberOfBytesWritten);

   HRESULT
   WritePrivateProfileString(
      const String& section,
      const String& key,
      const String& value,
      const String& filename);
}

}  // namespace Burnslib



#endif   // WIN_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\inc\wizpage.hpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard page base class
//
// 12-15-97 sburns



#ifndef WIZPAGE_HPP_INCLUDED
#define WIZPAGE_HPP_INCLUDED



// A version of PropertyPage for wizards, for use with the Burnslib::Wizard
// class, facilitates bookkeeping for page transistions and style settings.

class WizardPage : public PropertyPage
{
   friend class Wizard;

   public:

   // no publics. This is is intended to be used solely as a base class.

   

   protected:

   WizardPage(
      unsigned dialogResID,
      unsigned titleResID,
      unsigned subtitleResID,   
      bool     isInteriorPage = true,
      bool     enableHelp = false);

   virtual ~WizardPage();

   Wizard&
   GetWizard() const;


   
   // PropertyPage overrides


   
   // calls Wizard::Backtrack();

   virtual
   bool
   OnWizBack();

   

   private:


   
   // Create the page with wizard style flags, title & subtitle, etc.
   // Overridden from PropertyPage base class, and access adjusted to
   // private so that just the Wizard class can call it.

   virtual 
   HPROPSHEETPAGE
   Create();

   // not defined: no copying allowed
   WizardPage(const WizardPage&);
   const WizardPage& operator=(const WizardPage&);

   bool     hasHelp;
   bool     isInterior;
   unsigned titleResId;
   unsigned subtitleResId;
   Wizard*  wizard;
};



#endif   // WIZPAGE_HPP_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\args.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// argument parsing
// 
// 3-3-99 sburns



#include "headers.hxx"



void
MapCommandLineArgs(ArgMap& argmap)
{
   Burnslib::StringList args;

   //lint -e(1058)   lint does not grok back_inserter

   int argCount = Win::GetCommandLineArgs(std::back_inserter(args));

   // should have at least one argument

   ASSERT(argCount);

   // give special treatment to the first arg: the name of the program

   String arg = args.front();
   args.pop_front();
   argmap[L"_command"] = arg;

   MapArgs(args.begin(), args.end(), argmap);
}



void
MapArgsHelper(const String& arg, ArgMap& argmap)
{
   String key;
   String value;
      
   if (arg[0] == L'/' || arg[0] == L'-')
   {
      // possibly of the form "/argname:value"
      // look for ':' to make sure

      size_t x = arg.find(L":");
      if (x != String::npos)
      {
         // found an arg of the form "/argname:value"

         key = arg.substr(1, x - 1);

         // check for the case "/:value"

         if (key.length())
         {
            value = arg.substr(x + 1);
         }
      }
      else
      {
         // form is "/argname" or "-argname", so remove the leading
         // character.

         key = arg.substr(1);
      }
   }

   // arg is of the form "argspec" (i.e. *not* of the form
   // "/argname:value")

   argmap[key] = value;
}



void
MapArgs(const String& args, ArgMap& argmap)
{
   PWSTR*     clArgs   = 0;
   int        argCount = 0;
   StringList tokens; 

   clArgs = ::CommandLineToArgvW(args.c_str(), &argCount);
   ASSERT(clArgs);
   if (clArgs)
   {
      while (argCount)
      {
         tokens.push_back(clArgs[argCount - 1]);
         --argCount;
      }

      Win::GlobalFree(clArgs);
   }

   MapArgs(tokens.begin(), tokens.end(), argmap);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\autotokenprivileges.cpp ===
// Copyright (C) 2002 Microsoft Corporation
// 
// AutoTokenPrivileges class - for enabling and automatically restoring
// process token privileges
//
// 29 April 2002 sburns



#include "headers.hxx"



AutoTokenPrivileges::AutoTokenPrivileges(const String& privName)
   :
   processToken(INVALID_HANDLE_VALUE),
   newPrivs(0),
   oldPrivs(0)
{
   LOG_CTOR2(AutoTokenPrivileges, privName);
   ASSERT(!privName.empty());

   privNames.push_back(privName);
}



AutoTokenPrivileges::~AutoTokenPrivileges()
{
   LOG_DTOR(AutoTokenPrivileges);
   
   InternalRestore();

   ASSERT(!oldPrivs);
   
   if (processToken != INVALID_HANDLE_VALUE)
   {
      Win::CloseHandle(processToken);
   }
   delete[] (BYTE*) newPrivs;
}



HRESULT
AutoTokenPrivileges::Enable()
{
   LOG_FUNCTION(AutoTokenPrivileges::Enable);
   ASSERT(!oldPrivs);
   ASSERT(privNames.size());

   HRESULT hr = S_OK;
      
   do
   {
      // if you haven't done a Restore since your last Enable, you're
      // insane.

      if (oldPrivs)
      {
         hr = E_UNEXPECTED;
         break;
      }

      // demand-init the token handle

      if (processToken == INVALID_HANDLE_VALUE)
      {
         hr =
            Win::OpenProcessToken(
               Win::GetCurrentProcess(),
               TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
               processToken);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      // demand-init the new privs 

      if (!newPrivs)
      {
         // compute the size of TOKEN_PRIVILEGES struct. The struct includes 
         // space for ANYSIZE_ARRAY elements of type LUID_AND_ATTRIBUTES, so
         // we allocate only the extra amount needed/

         size_t structSizeInBytes =
               sizeof TOKEN_PRIVILEGES
            +  (privNames.size() - ANYSIZE_ARRAY) * sizeof LUID_AND_ATTRIBUTES;
         
         newPrivs = (TOKEN_PRIVILEGES*) new BYTE[structSizeInBytes];
         ::ZeroMemory(newPrivs, structSizeInBytes);

         newPrivs->PrivilegeCount = (DWORD) privNames.size();

         LUID_AND_ATTRIBUTES* la = newPrivs->Privileges;
         
         for (
            StringList::iterator i = privNames.begin();
            i != privNames.end();
            ++i)
         {
            hr = Win::LookupPrivilegeValue(
               0,
               i->c_str(),
               la->Luid);
            BREAK_ON_FAILED_HRESULT(hr);

            la->Attributes = SE_PRIVILEGE_ENABLED;
            ++la;
         }
         if (FAILED(hr))
         {
            delete[] (BYTE*) newPrivs;
            newPrivs = 0;
            break;
         }
      }

      hr =
         Win::AdjustTokenPrivileges(
            processToken,
            false,
            newPrivs,
            oldPrivs);
      BREAK_ON_FAILED_HRESULT(hr);

      ASSERT(oldPrivs);
   }
   while (0);

   // don't deallocate anything if we fail. Sometimes a failure is a legit
   // result

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
AutoTokenPrivileges::Restore()
{
   LOG_FUNCTION(AutoTokenPrivileges::Restore);

   // Doesn't make sense to restore privs if you haven't changed any

   ASSERT(oldPrivs);
   ASSERT(processToken != INVALID_HANDLE_VALUE);
   ASSERT(newPrivs);
   
   return InternalRestore();
}



HRESULT
AutoTokenPrivileges::InternalRestore()
{
   LOG_FUNCTION(AutoTokenPrivileges::InternalRestore);
   ASSERT(processToken != INVALID_HANDLE_VALUE);
   ASSERT(newPrivs);

   // don't assert oldPrivs here: this is called from the dtor after
   // Restore may have already been called, i.e. the sequence
   // ctor, Enable, Restore, dtor is acceptable.
   
   HRESULT hr = S_OK;
   if (oldPrivs && (processToken != INVALID_HANDLE_VALUE) )
   {
      hr = Win::AdjustTokenPrivileges(processToken, false, oldPrivs);
      delete[] (BYTE*) oldPrivs;
      oldPrivs = 0;
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\computer.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Computer naming tool
//
// 12-1-97 sburns
// 10-26-1999 sburns (redone)



#include "headers.hxx"



static const wchar_t* TCPIP_PARAMS_KEY = 
   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters";

static const wchar_t* TCPIP_POLICY_KEY =
   L"Software\\Policies\\Microsoft\\System\\DNSclient";

static const wchar_t* NEW_HOSTNAME_VALUE = L"NV Hostname";
static const wchar_t* NEW_SUFFIX_VALUE   = L"NV Domain";
   
   

// rather than make this a nested type inside the Computer class, I chose
// to hide it completely as a private struct in the implementation file.

struct ComputerState
{
   bool            isLocal;            
   bool            isDomainJoined;
   bool            searchedForDnsDomainNames;
   String          netbiosComputerName;
   String          dnsComputerName;    
   String          netbiosDomainName;  
   String          dnsDomainName;      
   String          dnsForestName;      
   NT_PRODUCT_TYPE realProductType;
   Computer::Role  role;
   DWORD           verMajor;           
   DWORD           verMinor;           
   DWORD           safebootOption;

   ComputerState()
      :
      isLocal(false),
      isDomainJoined(false),
      searchedForDnsDomainNames(false),
      netbiosComputerName(),
      dnsComputerName(),
      netbiosDomainName(),  
      dnsDomainName(),      
      dnsForestName(),      
      realProductType(NtProductWinNt),
      role(Computer::STANDALONE_WORKSTATION),
      verMajor(0),
      verMinor(0),           
      safebootOption(0)
   {
   }

   // implicit dtor used
};



String
Computer::RemoveLeadingBackslashes(const String& computerName)
{
   LOG_FUNCTION2(Computer::RemoveLeadingBackslashes, computerName);

   static const String BACKSLASH(L"\\");

   String s = computerName;
   if (s.length() >= 2)
   {
      if ((s[0] == BACKSLASH[0]) && (s[1] == BACKSLASH[0]))
      {
         // remove the backslashes
         s.erase(0, 2);
      }
   }

   return s;
}



// Removes leading backslashes and trailing whitespace, if present, and
// returns the result.
// 
// name - string from which leading backslashes and trailing whitespace is to
// be stripped.

static
String
MassageName(const String& name)
{
   String result = Computer::RemoveLeadingBackslashes(name);
   result = result.strip(String::TRAILING, 0);

   return result;
}



Computer::Computer(const String& name)
   :
   ctorName(MassageName(name)),
   isRefreshed(false),
   state(0)
{
   LOG_CTOR(Computer);
}



Computer::~Computer()
{
   LOG_DTOR(Computer);

   delete state;
   state = 0;
}



Computer::Role
Computer::GetRole() const
{
   LOG_FUNCTION2(Computer::GetRole, GetNetbiosName());
   ASSERT(isRefreshed);

   Role result = STANDALONE_WORKSTATION;

   if (state)
   {
      result = state->role;
   }

   LOG(String::format(L"role: %1!X!", result));

   return result;
}



bool
Computer::IsDomainController() const
{
   LOG_FUNCTION2(Computer::IsDomainController, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   switch (GetRole())
   {
      case PRIMARY_CONTROLLER:
      case BACKUP_CONTROLLER:
      {
         result = true;
         break;
      }
      case STANDALONE_WORKSTATION:
      case MEMBER_WORKSTATION:
      case STANDALONE_SERVER:
      case MEMBER_SERVER:
      default:
      {
         // do nothing

         break;
      }
   }
   
   LOG(
      String::format(
         L"%1 a domain controller",
         result ? L"is" : L"is not"));
         
   return result;
}



String
Computer::GetNetbiosName() const
{
   LOG_FUNCTION(Computer::GetNetbiosName);
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->netbiosComputerName;
   }

   LOG(result);

   return result;
}



String
Computer::GetFullDnsName() const
{
   LOG_FUNCTION2(Computer::GetFullDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->dnsComputerName;
   }

   LOG(result);

   return result;
}



// Updates the dnsDomainName and dnsForestName members of the supplied
// ComputerState instance, if either of members are empty, and we have reason
// to believe that it's appropriate to attempt to do so.
// 
// Called by methods that are looking for the dnsDomainName and / or
// dnsForestName to ensure that those values are present.  They might not be
// read when the Computer instance is refreshed (which is normally the case),
// because the domain may have been upgraded since the time that the machine
// was joined to that domain.
// 
// state - ComputerState instance to update.

void
GetDnsDomainNamesIfNeeded(ComputerState& state)
{
   LOG_FUNCTION(GetDnsDomainNamesIfNeeded);

   if (
         // only applies if joined to a domain

         state.isDomainJoined

         // either name might be missing.

      && (state.dnsDomainName.empty() || state.dnsForestName.empty())

         // should always be true, but just in case,

      && !state.netbiosDomainName.empty()

         // don't search again -- it's too expensive

      && !state.searchedForDnsDomainNames)
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      HRESULT hr =
         MyDsGetDcName(
            state.isLocal ? 0 : state.netbiosComputerName.c_str(),
            state.netbiosDomainName,
            DS_DIRECTORY_SERVICE_REQUIRED | DS_RETURN_DNS_NAME,
            info);
      if (SUCCEEDED(hr) && info)
      {
         if ((info->Flags & DS_DNS_DOMAIN_FLAG) && info->DomainName)
         {
            // we found a DS domain

            state.dnsDomainName = info->DomainName;

            ASSERT(info->DnsForestName);
            ASSERT(info->Flags & DS_DNS_FOREST_FLAG);

            if (info->DnsForestName)
            {
               state.dnsForestName = info->DnsForestName;
            }
         }
         ::NetApiBufferFree(info);
      }

      // flag the fact that we've looked, so we don't look again, as the
      // search is expensive.

      state.searchedForDnsDomainNames = true;
   }
}



String
Computer::GetDomainDnsName() const
{
   LOG_FUNCTION2(Computer::GetDomainDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      GetDnsDomainNamesIfNeeded(*state);
      result = state->dnsDomainName;
   }

   LOG(result);

   return result;
}



String
Computer::GetForestDnsName() const
{
   LOG_FUNCTION2(Computer::GetForestDnsName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      GetDnsDomainNamesIfNeeded(*state);
      result = state->dnsForestName;
   }

   LOG(result);

   return result;
}



String
Computer::GetDomainNetbiosName() const
{
   LOG_FUNCTION2(Computer::GetDomainNetbiosName, GetNetbiosName());
   ASSERT(isRefreshed);

   String result;

   if (state)
   {
      result = state->netbiosDomainName;
   }

   LOG(result);

   return result;
}



// I can't think why I would need to do this, so I'm not.
// 
// static
// String
// canonicalizeComputerName(const String& computerName)
// {
//    LOG_FUNCTION2(canonicalizeComputerName, computerName);
// 
//    if (ValidateNetbiosComputerName(computerName) == VALID_NAME)
//    {
//       String s(MAX_COMPUTERNAME_LENGTH, 0);
// 
//       NET_API_STATUS err =
//          I_NetNameCanonicalize(
//             0,
//             const_cast<wchar_t*>(computerName.c_str()),
//             const_cast<wchar_t*>(s.c_str()),
//             s.length() * sizeof(wchar_t),
//             NAMETYPE_COMPUTER,
//             0);
//       if (err == NERR_Success)
//       {
//          // build a new string without trailing null characters.
//          return String(s.c_str());
//       }
//    }
// 
//    return String();
// }



bool
Computer::IsJoinedToDomain() const
{
   LOG_FUNCTION2(Computer::IsJoinedToDomain, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   if (state)
   {
      result = state->isDomainJoined;
   }

   LOG(
      String::format(
         L"%1 domain joined",
         result ? L"is" : L"is not"));
         
   return result;
}



bool
Computer::IsJoinedToWorkgroup() const
{
   LOG_FUNCTION2(Computer::IsJoinedToWorkgroup, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = !IsJoinedToDomain();

   LOG(
      String::format(
         L"%1 domain joined",
         result ? L"is" : L"is not"));
         
   return result;
}



bool
Computer::IsJoinedToDomain(const String& domainDnsName) const
{
   LOG_FUNCTION2(Computer::IsJoinedToDomain, domainDnsName);
   ASSERT(!domainDnsName.empty());
   ASSERT(isRefreshed);

   bool result = false;

   if (!domainDnsName.empty())
   {
      if (state && IsJoinedToDomain())
      {
         String d1 =
            GetDomainDnsName().strip(String::TRAILING, L'.');
         String d2 =
            String(domainDnsName).strip(String::TRAILING, L'.');
         result = (d1.icompare(d2) == 0);
      }
   }

   LOG(
      String::format(
         L"%1 joined to %2",
         result ? L"is" : L"is NOT",
         domainDnsName.c_str()));

   return result;
}



bool
Computer::IsLocal() const
{
   LOG_FUNCTION2(Computer::IsLocal, GetNetbiosName());
   ASSERT(isRefreshed);

   bool result = false;

   if (state)
   {
      result = state->isLocal;
   }

   LOG(
      String::format(
         L"%1 local machine",
         result ? L"is" : L"is not"));

   return result;
}



// Updates the following members of the ComputerState parameter with values
// from the local machine:
// 
// netbiosComputerName
// dnsComputerName
// verMajor
// verMinor
// 
// Note that the dnsComputerName may not have a value if tcp/ip is not
// installed and properly configured.  This is not considered an error
// condition.
// 
// Returns S_OK on success, or a failure code otherwise.
// 
// state - the ComputerState instance to be updated.

HRESULT
RefreshLocalInformation(ComputerState& state)
{
   LOG_FUNCTION(RefreshLocalInformation);

   state.netbiosComputerName =
      Win::GetComputerNameEx(ComputerNameNetBIOS);

   state.dnsComputerName =
      Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

   HRESULT hr = S_OK;

   do
   {
      OSVERSIONINFO verInfo;
      hr = Win::GetVersionEx(verInfo);
      BREAK_ON_FAILED_HRESULT(hr);

      state.verMajor = verInfo.dwMajorVersion;
      state.verMinor = verInfo.dwMinorVersion;
   }
   while (0);

   return hr;
}



// Read the registry of a remote machine to determine the fully-qualified
// DNS computer name of that machine, taking into account any policy-imposed
// DNS suffix.
// 
// On success, stores the result in the dnsComputerName member of the supplied
// ComputerState instance, and returns S_OK;
// 
// On failure, clears the dnsComputerName member, and returns a failure code.
// Thre failure code (ERROR_FILE_NOT_FOUND) may indicate that the registry
// value(s) are not present, which means that TCP/IP is not installed or is
// not properly configured on the remote machine.
// 
// remoteRegHKLM - HKEY previously opened to the HKEY_LOCAL_MACHINE hive of
// the remote computer.
// 
// state - ComputerState instance to be updated with the resulting name.

HRESULT
DetermineRemoteDnsComputerName(
   HKEY           remoteRegHKLM,
   ComputerState& state)        
{
   state.dnsComputerName.erase();

   String hostname;
   String suffix;
   String policySuffix;
   bool   policyInEffect = false;

   HRESULT hr = S_OK;

   do
   {
      RegistryKey key;
      hr = key.Open(remoteRegHKLM, TCPIP_PARAMS_KEY);
      BREAK_ON_FAILED_HRESULT(hr);

      // Read these values without checking for failure, as empty string
      // is ok.

      hostname = key.GetString(L"Hostname");
      suffix   = key.GetString(L"Domain");  
      
      // We need to check to see if there is a policy-supplied dns suffix

      if (state.realProductType != NtProductLanManNt)
      {
         hr = key.Open(remoteRegHKLM, TCPIP_POLICY_KEY);
         if (SUCCEEDED(hr))
         {
            hr = key.GetValue(L"PrimaryDnsSuffix", policySuffix);
            if (SUCCEEDED(hr))
            {
               // a policy-supplied computer DNS domain name is in effect.

               policyInEffect = true;
            }
         }
      }
   }
   while (0);

   if (!hostname.empty())
   {
      state.dnsComputerName =
         Computer::ComposeFullDnsComputerName(
            hostname,
            policyInEffect ? policySuffix : suffix);
   }

   return hr;
}



// Returns true if the computer represented by the provided ComputerState is
// a domain controller booted in DS repair mode.  Returns false otherwise.
// 
// state - a "filled-in" ComputerState instance.

bool
IsDcInRepairMode(const ComputerState& state)
{
   LOG_FUNCTION(IsDcInRepairMode);

   if (
         state.safebootOption  == SAFEBOOT_DSREPAIR
      && state.realProductType == NtProductLanManNt)
   {
      return true;
   }

   return false;
}



// Sets the following members of the supplied ComputerState struct, based on
// the current values of the isLocal and netbiosComputerName members of the
// same struct.  Returns S_OK on success, or an error code on failure.
// 
// role
// isDomainJoined
// 
// optionally sets the following, if applicable:
// 
// dnsForestName
// dnsDomainName
// netbiosDomainName
// 
// state - instance with isLocal and netbiosComputerName members previously
// set.  The members mentioned above will be overwritten.

HRESULT
DetermineRoleAndMembership(ComputerState& state)
{
   LOG_FUNCTION(DetermineRoleAndMembership);

   HRESULT hr = S_OK;

   do
   {
      DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
      hr = 
         MyDsRoleGetPrimaryDomainInformation(
            state.isLocal ? 0 : state.netbiosComputerName.c_str(),
            info);
      BREAK_ON_FAILED_HRESULT(hr);

      if (info->DomainNameFlat)
      {
         state.netbiosDomainName = info->DomainNameFlat;
      }
      if (info->DomainNameDns)
      {
         // not always present, even if the domain is NT 5.  See note
         // for GetDnsDomainNamesIfNeeded.

         state.dnsDomainName = info->DomainNameDns;
      }
      if (info->DomainForestName)
      {
         // not always present, even if the domain is NT 5.  See note
         // for GetDnsDomainNamesIfNeeded.

         state.dnsForestName = info->DomainForestName;
      }

      switch (info->MachineRole)
      {
         case DsRole_RoleStandaloneWorkstation:
         {
            state.role = Computer::STANDALONE_WORKSTATION;
            state.isDomainJoined = false;

            break;
         }
         case DsRole_RoleMemberWorkstation:
         {
            state.role = Computer::MEMBER_WORKSTATION;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RoleStandaloneServer:
         {
            state.role = Computer::STANDALONE_SERVER;
            state.isDomainJoined = false;

            // I wonder if we're really a DC booted in ds repair mode?

            if (IsDcInRepairMode(state))
            {
               LOG(L"machine is in ds repair mode");

               state.role = Computer::BACKUP_CONTROLLER;
               state.isDomainJoined = true;

               // the domain name will be reported as "WORKGROUP", which
               // is wrong, but that's the way the ds guys wanted it.
            }

            break;
         }
         case DsRole_RoleMemberServer:
         {
            state.role = Computer::MEMBER_SERVER;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RolePrimaryDomainController:
         {
            state.role = Computer::PRIMARY_CONTROLLER;
            state.isDomainJoined = true;

            break;
         }
         case DsRole_RoleBackupDomainController:
         {
            state.role = Computer::BACKUP_CONTROLLER;
            state.isDomainJoined = true;

            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }

      ::DsRoleFreeMemory(info);
   }
   while (0);

   if (FAILED(hr))
   {
      // infer a best-guess on the role from the product type

      state.isDomainJoined = false;

      switch (state.realProductType)
      {
         case NtProductWinNt:
         {
            state.role = Computer::STANDALONE_WORKSTATION;
            break;
         }
         case NtProductServer:
         {
            state.role = Computer::STANDALONE_SERVER;
            break;
         }
         case NtProductLanManNt:
         {
            state.isDomainJoined = true;
            state.role = Computer::BACKUP_CONTROLLER;
            break;
         }
         default:
         {
            ASSERT(false);
            break;
         }
      }
   }

   return hr;
}



// Sets the isLocal member of the provided ComputerState instance to true if
// the given name refers to the local computer (the computer on which this
// code is executed).  Sets the isLocal member to false if not, or on error.
// Returns S_OK on success or an error code on failure. May also set the
// following:
// 
// netbiosComputerName
// verMajor
// verMinor
// 
// Essentially the same as Win::IsLocalComputer; we repeat most of the code
// here to avoid a possibly redundant call to NetWkstaGetInfo.
//
// state - instance of ComputerState to be modified.
// 
// ctorName - the computer name with which an instance of Computer was
// constructed.  This may be any computer name form (netbios, dns, ip
// address).
   
HRESULT
IsLocalComputer(ComputerState& state, const String& ctorName)
{
   LOG_FUNCTION(IsLocalComputer);

   HRESULT hr = S_OK;
   bool result = false;

   do
   {
      if (ctorName.empty())
      {
         // an unnamed computer always represent the local computer.

         result = true;
         break;
      }

      String localNetbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);

      if (ctorName.icompare(localNetbiosName) == 0)
      {
         result = true;
         break;
      }
   
      String localDnsName =
         Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      if (ctorName.icompare(localDnsName) == 0)
      {
         // the given name is the same as the fully-qualified dns name
         
         result = true;
         break;
      }

      // we don't know what kind of name it is.  Ask the workstation service
      // to resolve the name for us, and see if the result refers to the
      // local machine.

      // NetWkstaGetInfo returns the netbios name for a given machine, given
      // a DNS, netbios, or IP address.

      WKSTA_INFO_100* info = 0;
      hr = MyNetWkstaGetInfo(ctorName, info);
      BREAK_ON_FAILED_HRESULT(hr);

      state.netbiosComputerName = info->wki100_computername;
      state.verMajor            = info->wki100_ver_major;   
      state.verMinor            = info->wki100_ver_minor;   

      ::NetApiBufferFree(info);

      if (state.netbiosComputerName.icompare(localNetbiosName) == 0)
      {
         // the given name is the same as the netbios name
         
         result = true;
         break;
      }
   }
   while (0);

   state.isLocal = result;

   return hr;
}



HRESULT
Computer::Refresh()
{
   LOG_FUNCTION(Computer::Refresh);

   // erase all the state that we may have set before

   isRefreshed = false;

   delete state;
   state = new ComputerState;

   HRESULT hr = S_OK;
   HKEY registryHKLM = 0;
   do
   {
      // First, determine if the computer this instance represents is the
      // local computer.

      hr = IsLocalComputer(*state, ctorName);
      BREAK_ON_FAILED_HRESULT(hr);

      // Next, based on whether the machine is local or not, populate the
      // netbios and dns computer names, and version information.

      if (state->isLocal)
      {
         // netbiosComputerName
         // dnsComputerName
         // version

         hr = RefreshLocalInformation(*state);
         BREAK_ON_FAILED_HRESULT(hr);
      }
      else
      {
         // IsLocalComputer has already set:
         // netbiosComputerName
         // version

         ASSERT(!state->netbiosComputerName.empty());
         ASSERT(state->verMajor);
      }

      // We will need to examine the registry to determine the safeboot
      // option and real product type.

      hr =
         Win::RegConnectRegistry(
            state->isLocal ? String() : L"\\\\" + state->netbiosComputerName,
            HKEY_LOCAL_MACHINE,
            registryHKLM);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = GetProductTypeFromRegistry(registryHKLM, state->realProductType);
      BREAK_ON_FAILED_HRESULT(hr);

      if (!state->isLocal)
      {
         // still need to get dnsComputerName, which we can do now that
         // we know the real product type.

         // The DNS Computer name can be determined be reading the remote
         // registry.

         hr = DetermineRemoteDnsComputerName(registryHKLM, *state);
         if (FAILED(hr) && hr != Win32ToHresult(ERROR_FILE_NOT_FOUND))
         {
            // if the DNS registry settings are not present, that's ok.
            // but otherwise:

            BREAK_ON_FAILED_HRESULT(hr);
         }
      }

      // We'll need to know the safeboot option to determine the role
      // in the next step.

      hr = GetSafebootOption(registryHKLM, state->safebootOption);
      if (FAILED(hr) && hr != Win32ToHresult(ERROR_FILE_NOT_FOUND))
      {
         // if the safeboot registry settings are not present, that's ok.
         // but otherwise:

         BREAK_ON_FAILED_HRESULT(hr);
      }

      // Next, determine the machine role and domain membership

      hr = DetermineRoleAndMembership(*state);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (registryHKLM)
   {
      Win::RegCloseKey(registryHKLM);
   }

   if (SUCCEEDED(hr))
   {
      isRefreshed = true;
   }

   return hr;
}



String
Computer::ComposeFullDnsComputerName(
   const String& hostname,
   const String& domainSuffix)
{
   LOG_FUNCTION2(
      Computer::ComposeFullDnsComputerName,
      String::format(
         L"hostname: %1 suffix: %2",
         hostname.c_str(),
         domainSuffix.c_str()));
   ASSERT(!hostname.empty());

   // The domain name may be empty if the machine is unjoined...

   if (domainSuffix.empty() || domainSuffix == L".")
   {
      // "computername."

      return hostname + L".";
   }

   // "computername.domain"

   return hostname + L"." + domainSuffix;
}



HRESULT
Computer::GetSafebootOption(HKEY regHKLM, DWORD& result)
{
   LOG_FUNCTION(GetSafebootOption);
   ASSERT(regHKLM);

   result = 0;
   HRESULT hr = S_OK;

   RegistryKey key;

   do
   {
      hr =       
         key.Open(
            regHKLM,
            L"System\\CurrentControlSet\\Control\\SafeBoot\\Option");
      BREAK_ON_FAILED_HRESULT(hr);

      hr = key.GetValue(L"OptionValue", result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG(String::format(L"returning : 0x%1!X!", result));

   return hr;
}



HRESULT
Computer::GetProductTypeFromRegistry(HKEY regHKLM, NT_PRODUCT_TYPE& result)
{
   LOG_FUNCTION(GetProductTypeFromRegistry);
   ASSERT(regHKLM);

   result = NtProductWinNt;
   HRESULT hr = S_OK;

   RegistryKey key;

   do
   {
      hr =       
         key.Open(
            regHKLM,
            L"System\\CurrentControlSet\\Control\\ProductOptions");
      BREAK_ON_FAILED_HRESULT(hr);

      String prodType;
      hr = key.GetValue(L"ProductType", prodType);
      BREAK_ON_FAILED_HRESULT(hr);

      LOG(prodType);

      // see ntos\rtl\prodtype.c, which uses case-insensitive unicode string
      // compare.

      if (prodType.icompare(L"WinNt") == 0)
      {
         result = NtProductWinNt;
      }
      else if (prodType.icompare(L"LanmanNt") == 0)
      {
         result = NtProductLanManNt;
      }
      else if (prodType.icompare(L"ServerNt") == 0)
      {
         result = NtProductServer;
      }
      else
      {
         LOG(L"unknown product type, assuming workstation");
      }
   }
   while (0);

   LOG(String::format(L"prodtype : 0x%1!X!", result));

   return hr;
}



String
Computer::GetFuturePhysicalNetbiosName()
{
   LOG_FUNCTION(Computer::GetFuturePhysicalNetbiosName);

   // the default future name is the existing name.
      
   String name = Win::GetComputerNameEx(ComputerNamePhysicalNetBIOS);
   RegistryKey key;

   HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, REGSTR_PATH_COMPUTRNAME);

   if (SUCCEEDED(hr))
   {
      hr = key.GetValue(REGSTR_VAL_COMPUTRNAME, name);
   }

   LOG_HRESULT(hr);
   LOG(name);
   
   return name;
}



String
Computer::GetActivePhysicalNetbiosName()
{
   LOG_FUNCTION(Computer::GetActivePhysicalNetbiosName);

   String result = Win::GetComputerNameEx(ComputerNamePhysicalNetBIOS);

   LOG(result);

   return result;   
}



// see base\win32\client\compname.c
      
bool
Computer::IsDnsSuffixPolicyInEffect(String& policyDnsSuffix)
{
   LOG_FUNCTION(Computer::IsDnsSuffixPolicyInEffect);

   bool policyInEffect = false;
   policyDnsSuffix.erase();

   NT_PRODUCT_TYPE productType = NtProductWinNt;
   if (!::RtlGetNtProductType(&productType))
   {
      // on failure, do nothing; assume workstation         

      ASSERT(false);
   }
   
   // read the suffix policy setting from the registry. We used to skip
   // this for domain controllers in win2k, but .net server supports
   // dc rename and policy supplied dns suffixes for dcs.
   // NTRAID#NTBUG9-704838-2002/09/23-sburns
   
   RegistryKey key;
   
   HRESULT hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_POLICY_KEY);
   if (SUCCEEDED(hr))
   {
      hr = key.GetValue(L"PrimaryDnsSuffix", policyDnsSuffix);
      if (SUCCEEDED(hr))
      {
         // a policy-supplied computer DNS domain name is in effect.

         policyInEffect = true;
      }
   }

   LOG(policyInEffect ? L"true" : L"false");
   LOG(policyDnsSuffix);

   return policyInEffect;
}



String
Computer::GetActivePhysicalFullDnsName()
{
   LOG_FUNCTION(Computer::GetActivePhysicalFullDnsName);

   // As a workaround to NTRAID#NTBUG9-216349-2000/11/01-sburns, compose our
   // own full DNS name from the hostname and suffix.

   String hostname = Win::GetComputerNameEx(ComputerNamePhysicalDnsHostname);
   String suffix   = Win::GetComputerNameEx(ComputerNamePhysicalDnsDomain);  
   String result   = Computer::ComposeFullDnsComputerName(hostname, suffix);

   LOG(result);

   return result;
}



String
Computer::GetFuturePhysicalFullDnsName()
{
   LOG_FUNCTION(Computer::GetFuturePhysicalFullDnsName);

   String result = Computer::GetActivePhysicalFullDnsName();
   RegistryKey key;

   HRESULT hr = S_OK;
   
   do
   {
      hr = key.Open(HKEY_LOCAL_MACHINE, TCPIP_PARAMS_KEY);

      // may be that there are no dns name parameters at all, probably because
      // tcp/ip is not installed.  So the future name == active name
      
      BREAK_ON_FAILED_HRESULT(hr);

      String hostname;
      hr = key.GetValue(NEW_HOSTNAME_VALUE, hostname);

      if (FAILED(hr))
      {
         // no new hostname set (or we can't tell what it is).  So the future
         // hostname is the active hostname.
         
         hostname = Win::GetComputerNameEx(ComputerNamePhysicalDnsHostname);
      }
      
      String suffix;
      hr = key.GetValue(NEW_SUFFIX_VALUE, suffix);
      if (FAILED(hr))
      {
         // no new suffix set (or we can't tell what it is).  So the future
         // suffix is the active suffix.
         
         suffix = Win::GetComputerNameEx(ComputerNamePhysicalDnsDomain);
      }

      // Decide which suffix -- local or policy -- is in effect

      String policyDnsSuffix;
      bool policyInEffect =
         Computer::IsDnsSuffixPolicyInEffect(policyDnsSuffix);

      result =
         Computer::ComposeFullDnsComputerName(
            hostname,
            policyInEffect ? policyDnsSuffix : suffix);
   }
   while (0);
   
   LOG_HRESULT(hr);
   LOG(result);
   
   return result;
}








// Implementation notes: please don't delete:

// Init/Refresh
// 
//    if given name empty,
//       set is local = true
// 
//    if !given name empty,
//       Win::IsLocalComputer(given name), if same set is local = true
// 
//    connect to local/remote registry
// 
//    read safe boot mode
//    read real product type
// 
//    if local 
//       get local dns name (getcomputernameex)
//       get local netbios name (getcomputernameex)
//       get version (getversion)
// 
//    if not local
//       call netwkstagetinfo,
//          get netbios name
//          get version
//       get dns name (account for policy, which requires real prod type)
// 
//    call dsrolegpdi (with netbios name if !local)
//       if succeeded
//          set role
//          set netbios domain name
//          set dns domain name
//          set dns forest name
//          set is joined
// 
//       if failed
//          infer role from real product type
// 
//    set is dc in restore mode
//
//
// true role
//    is dc                                x
//    is dc in restore mode                x
// netbios name                         x
// dns name                             x
//    is local machine                     x
// dns domain name                      x
// netbios domain name                  x
//    is joined to domain X                x
//    is domain joined                     x
//    is workgroup joined                  x
// dns forest name                      x
// version                              x
// is booted safe mode                  x
// 
// 
// netwkstgetinfo(100)
//    version
//    if name is netbios or not
// 
// registry:
//    real product type
//    safe boot mode
//    netbios name
//    dns name (remember to account for policy)
//      
// dsrolegpdi
//    role (wrong if in safeboot)
//    netbios domain name
//    dns domain name
//    dns forest name (also available from dsgetdcname)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\controlsubclasser.cpp ===
// Copyright (c) 2000 Microsoft Corporation
//
// windows control subclassing wrapper
//
// 22 Nov 2000 sburns



#include "headers.hxx"
#include "ControlSubclasser.hpp"



ControlSubclasser::ControlSubclasser()
   :
   hwnd(0),
   originalWindowProc(0)
{
   LOG_CTOR(ControlSubclasser);
}



ControlSubclasser::~ControlSubclasser()
{
   LOG_DTOR(ControlSubclasser);

   UnhookWindowProc();
}



HRESULT
ControlSubclasser::Init(HWND control)
{
   LOG_FUNCTION(ControlSubclasser::Init);
   ASSERT(Win::IsWindow(control));

   // hwnd should not be set, nor originalWindowProc.  If they are, then
   // Init has been called already.
      
   ASSERT(!hwnd);
   ASSERT(!originalWindowProc);

   hwnd = control;

   HRESULT hr = S_OK;

   do
   {
      // save our this pointer so we can find ourselves again when messages
      // are sent to the window.

      hr = Win::SetWindowLongPtr(
         hwnd,
         GWLP_USERDATA,
         reinterpret_cast<LONG_PTR>(this));
      BREAK_ON_FAILED_HRESULT(hr);
            
      // hook the windows procedure.

      LONG_PTR ptr = 0;
      hr = Win::GetWindowLongPtr(hwnd, GWLP_WNDPROC, ptr);
      BREAK_ON_FAILED_HRESULT(hr);

      originalWindowProc = reinterpret_cast<WNDPROC>(ptr);
      
      if (!originalWindowProc)
      {
         LOG(L"unable to hook winproc");
         
         hr = E_FAIL;
         break;
      }

      hr = Win::SetWindowLongPtr(
         hwnd,
         GWLP_WNDPROC,
         reinterpret_cast<LONG_PTR>(ControlSubclasser::WindowProc));
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (FAILED(hr))
   {
      // if we failed to save the this pointer, then we will never get
      // called back, as we don't try to hook the window proc.

      // if we fail to hook the window proc, then we will never get called
      // back, and the saved this pointer is irrelevant.
      
      hwnd = 0;
      originalWindowProc = 0;
   }

   return hr;
}



void
ControlSubclasser::UnhookWindowProc()
{
   LOG_FUNCTION(ControlSubclasser::UnhookWindowProc);

   if (Win::IsWindow(hwnd) && originalWindowProc)
   {
      // unhook the window proc

      Win::SetWindowLongPtr(
         hwnd,
         GWLP_WNDPROC,
         reinterpret_cast<LONG_PTR>(originalWindowProc));
   }
}



LRESULT
ControlSubclasser::OnMessage(UINT message, WPARAM wparam, LPARAM lparam)
{
   // LOG_FUNCTION(ControlSubclasser::OnMessage);

   switch (message)
   {
      case WM_DESTROY:
      {
         UnhookWindowProc();
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return ::CallWindowProc(originalWindowProc, hwnd, message, wparam, lparam);
}




LRESULT
CALLBACK
ControlSubclasser::WindowProc(
    HWND   window, 
    UINT   message,
    WPARAM wparam, 
    LPARAM lparam)
{
   // LOG_FUNCTION(ControlSubclasser::WindowProc)

   LRESULT result = 0;
      
   LONG_PTR ptr = 0;
   HRESULT hr = Win::GetWindowLongPtr(window, GWLP_USERDATA, ptr);

   if (SUCCEEDED(hr))
   {
      ControlSubclasser* that =
         reinterpret_cast<ControlSubclasser*>(ptr);

      ASSERT(that);

      result = that->OnMessage(message, wparam, lparam);
   }
   else
   {
      ASSERT(false);
   }

   return result;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\dllref.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// DLL object instance and server lock utility class
// 
// 8-19-97 sburns



#include "headers.hxx"



long ComServerLockState::instanceCount = 0;
long ComServerLockState::lockCount = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\diagnosedcnotfound.cpp ===
// Copyright (C) 2000 Microsoft Corporation
//
// diagnose domain controller not found problems, offer a popup dialog to
// assail the user with the results.
//
// 9 October 2000 sburns



// In order for clients of these functions to get the proper resources, the
// clients need to include burnslib\inc\DiagnoseDcNotFound.rc in their
// resources.  For an example, see admin\dcpromo\exe\dcpromo.rc



#include "headers.hxx"
#include "DiagnoseDcNotFound.h"
#include "DiagnoseDcNotFound.hpp"



// Return a string of IP addresses, each separated by a CRLF, one address for
// each DNS server specified in this machines TCP/IP protocol configuration.
// On failure, the return value is a message that no address were found.

String
GetListOfClientDnsServerAddresses()
{
   LOG_FUNCTION(GetListOfClientDnsServerAddresses);

   String result = String::load(IDS_NO_ADDRESSES);

   PIP_ARRAY pipArray = 0;
   DWORD bufSize = sizeof(IP_ARRAY);

   do
   {   
      DNS_STATUS status =
         ::DnsQueryConfig(
            DnsConfigDnsServerList,
            DNS_CONFIG_FLAG_ALLOC,
            0,
            0,
            &pipArray,
            &bufSize);
      if (status != ERROR_SUCCESS || !pipArray || !pipArray->AddrArray)
      {
         LOG(String::format(L"DnsQueryConfig failed %1!d!", status));
         break;
      }

      result = L"";
      PIP_ADDRESS pIpAddrs = pipArray->AddrArray;
      while (pipArray->AddrCount--)
      {
         result +=
            String::format(
               L"%1!d!.%2!d!.%3!d!.%4!d!\r\n",
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 0 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 1 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 2 ),
               * ( (PUCHAR) &pIpAddrs[pipArray->AddrCount] + 3 ) );
      }
   }
   while (0);

   Win::LocalFree(pipArray);
      
   LOG(result);

   return result;
}



// Return a string of DNS zone names derived from the given DNS domain name.
// Each zone is separated by a CRLF.  The last zone is the root zone, even if
// the domain name is the empty string, or a fully-qualified domain name.
// 
// example: if "foo.bar.com" is passed as the domain name, then the result is
// "foo.bar.com
// bar.com
// com
// . (the root zone)"
// 
// domainDnsName - in, the DNS domain name.

String
GetListOfZones(const String domainDnsName)
{
   LOG_FUNCTION2(GetListOfZones, domainDnsName);
   ASSERT(!domainDnsName.empty());

   String result;
   String zone = domainDnsName;

   while (zone != L"." && !zone.empty())
   {
      result += zone + L"\r\n";
      zone = Dns::GetParentDomainName(zone);
   }

   result += String::load(IDS_ROOT_ZONE);

   LOG(result);

   return result;
}



// Return a formatted string describing the given error code, including the
// corresponding error message, the error code in hex, and the symbolic name
// of the error code (e.g. "DNS_RCODE_NAME_ERROR")
// 
// errorCode - in, the DNS error code

String
GetErrorText(DNS_STATUS errorCode)
{
   LOG_FUNCTION(GetErrorText);

   String result = 
      String::format(
         IDS_DC_NOT_FOUND_DIAG_ERROR_CODE,
         GetErrorMessage(Win32ToHresult(errorCode)).c_str(),
         errorCode,
         MyDnsStatusString(errorCode).c_str());

   LOG(result);

   return result;      
}



// For each SRV record in the given linked list of DnsQuery results, extract
// the name of the machine.  Compose a string of all the names, separated by
// CRLFs.  If no SRV records are found, then return a string saying (to the
// effect) "none found"
// 
// queryResults - in, the linked list of DNS_RECORDs -- the result of calling
// DnsQuery.  Should not be null.

String
GetListOfDomainControllers(DNS_RECORD* queryResults)
{
   LOG_FUNCTION(GetListOfDomainControllers);
   ASSERT(queryResults);

   String result;
   
   if (queryResults)
   {
      DNS_RECORD* record = queryResults;
      while (record)
      {
         if (record->wType == DNS_TYPE_SRV)
         {
            // Extract the domain controller name from the RDATA

            result += String(record->Data.SRV.pNameTarget) + L"\r\n";
         }

         record = record->pNext;
      }
   }

   if (result.empty())
   {
      result = String::load(IDS_DC_NOT_FOUND_NO_RESULTS);
   }
   
   LOG(result);

   return result;
}

   

// Returns a text string describing the likely causes of DsGetDcName failing.
// Performs DnsQuery(ies) and exmaines the results.
// 
// domainName - in, the name of the domain for which a domain controller can't
// be located.  This name may be a netbios or DNS name, but the DNS
// diagnostics portion of the result text will not be useful if the name is a
// netbios name.
// 
// nameIsNotNetbios - in, if the caller knows that the domain named in
// the domainName parameter can't possibly be a netbios domain name, then this
// value should be true.  If the caller is not sure, then false should be
// passed.
// 
// helpTopic - out, the help topic link corresponding to the diagnostic result
// (HtmlHelp is used to display the link)

String
DiagnoseDcNotFound(
   const String&  domainName,
   bool           nameIsNotNetbios,
   String&        helpTopic)
{
   LOG_FUNCTION2(DiagnoseDcNotFound, domainName);
   ASSERT(!domainName.empty());

   String result = String::load(IDS_DC_NOT_FOUND_DIAG_NO_RESULTS);
   String message; 
   helpTopic.erase();
      
   // first possibility is that the name is a netbios name.  Let's check.

   if (
         domainName.length() > DNLEN
      || domainName.find_first_of(L".") != String::npos)
   {
      // Name is too long to be netbios, or contains dots.
      // 
      // While it is technically possible for a netbios domain name to contain
      // dots, we've been prohibiting it since win2k, and an administrator
      // from before that would have to have been spectacularly unwise to have
      // chosen such a name.
      // 
      // If I don't check for dots here, then as sure as it rains in Redmond,
      // someone will complain that a name with dots in it sure doesn't look
      // like a netbios name, so this code had better not imply that it is.

      nameIsNotNetbios = true;
   }

   if (!nameIsNotNetbios)
   {
      // i.e. name might be a netbios name

      message += 
         String::format(
            IDS_DC_NOT_FOUND_NETBIOS_PREFACE,
            domainName.c_str());
   }

   // attempt to find domain controllers for the domain with DNS

   String serverName = L"_ldap._tcp.dc._msdcs." + domainName;
         
   DNS_RECORD* queryResults = 0;
   DNS_STATUS status =
      MyDnsQuery(
         serverName,
         DNS_TYPE_SRV,
         DNS_QUERY_BYPASS_CACHE,
         queryResults);
   switch (status)
   {
      case DNS_ERROR_RCODE_SERVER_FAILURE:
      {
         // message F (message letters correspond to those in the spec)

         String zones = GetListOfZones(domainName);
         String addresses = GetListOfClientDnsServerAddresses();

         message +=
            String::format(
               IDS_DC_NOT_FOUND_DIAG_SERVER_FAILURE,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),
               addresses.c_str(),
               zones.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageF.htm";
         
         break;
      }
      case DNS_ERROR_RCODE_NAME_ERROR:
      {
         // message E

         String zones = GetListOfZones(domainName);
         String addresses = GetListOfClientDnsServerAddresses();
                  
         message +=
            String::format(
               IDS_DC_NOT_FOUND_NAME_ERROR,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),               
               zones.c_str(),
               addresses.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageE.htm";
         
         break;
      }
      case ERROR_TIMEOUT:
      {
         // message B

         String addresses = GetListOfClientDnsServerAddresses();

         message +=
            String::format(
               IDS_DC_NOT_FOUND_TIMEOUT,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str(),               
               addresses.c_str());
         
         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageB.htm";
         
         break;
      }
      case NO_ERROR:
      {
         if (queryResults)
         {
            // non-empty query results -- message Hb

            String dcs = GetListOfDomainControllers(queryResults);

            message +=
               String::format(
                  IDS_DC_NOT_FOUND_NO_ERROR_1,
                  domainName.c_str(),
                  serverName.c_str(),
                  dcs.c_str());
                              
            helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageHa.htm";
            break;
         }

         // empty query results -- message A
         // fall thru to default case
      }
      default:
      {
         // message A

         message +=
            String::format(
               IDS_DC_NOT_FOUND_DEFAULT,
               domainName.c_str(),
               GetErrorText(status).c_str(),
               serverName.c_str());

         helpTopic = L"tcpip.chm::/sag_DNS_tro_dcLocator_messageA.htm";
         
         break;
      }
   }

   MyDnsRecordListFree(queryResults);

   if (!message.empty())
   {
      result = message;
   }
   
   LOG(result);

   return result;   
}



// Class for displaying the a "dc not found" error and offering to run a
// diagnostic test to determine why the dc was not found.

class DcNotFoundErrorDialog : public Dialog
{
   public:

   // domainName - in, the name of the domain for which a domain controller
   // can't be located.  This name may be a netbios or DNS name, but the DNS
   // diagnostics portion of the result text will not be useful if the name is
   // a netbios name.
   //          
   // dialogTitle - in, the title of the error dialog.
   //       
   // errorMessage - in, the error message to be displayed in the dialog
   //    
   // domainNameIsNotNetbios - in, if the caller knows that the domain named
   // in the domainName parameter can't possibly be a netbios domain name,
   // then this value should be true.  If the caller is not sure, then false
   // should be passed.
   // 
   // userIsDomainSavvy - in, true if the end user is expected to be an
   // administrator or somesuch that might have an inkling what DNS is and how
   // to configure it.  If false, then the function will preface the
   // diagnostic text with calming words that hopefully prevent the
   // non-administrator from weeping.
   
   DcNotFoundErrorDialog(
      const String&  domainName,
      const String&  dialogTitle,
      const String&  errorMessage,
      bool           domainNameIsNotNetbios,
      bool           userIsDomainSavvy);

   virtual ~DcNotFoundErrorDialog();

   protected:

   // Dialog overrides

   virtual
   bool
   OnCommand(
      HWND        windowFrom,
      unsigned    controlIDFrom,
      unsigned    code);

   virtual
   void
   OnInit();

   private:

   void
   HideDetails();

   void
   ShowDetails();
   
   void
   DiagnoseAndSetDetailsText();
   
   String dialogTitle;
   bool   diagnosticWasRun;
   String domainName;            
   String errorMessage;          
   bool   domainNameIsNotNetbios;
   String helpTopicLink;         
   bool   detailsShowing;
   bool   userIsDomainSavvy;
   LONG   originalHeight;        

   // not defined: no copying allowed

   DcNotFoundErrorDialog(const DcNotFoundErrorDialog&);
   const DcNotFoundErrorDialog& operator=(const DcNotFoundErrorDialog&);
};



static const DWORD HELP_MAP[] =
{
   0, 0
};



DcNotFoundErrorDialog::DcNotFoundErrorDialog(
   const String&  domainName_,
   const String&  dialogTitle_,
   const String&  errorMessage_,
   bool           domainNameIsNotNetbios_,
   bool           userIsDomainSavvy_)
   :
   Dialog(IDD_DC_NOT_FOUND, HELP_MAP),
   dialogTitle(dialogTitle_),
   diagnosticWasRun(false),
   domainName(domainName_),
   errorMessage(errorMessage_),
   userIsDomainSavvy(userIsDomainSavvy_),
   domainNameIsNotNetbios(domainNameIsNotNetbios_),
   detailsShowing(false)
{
   LOG_CTOR(DcNotFoundErrorDialog);
   ASSERT(!domainName.empty());
   ASSERT(!errorMessage.empty());
   ASSERT(!dialogTitle.empty());

   // fall back to a default title
      
   if (dialogTitle.empty())
   {
      dialogTitle = String::load(IDS_DC_NOT_FOUND_TITLE);
   }
}



DcNotFoundErrorDialog::~DcNotFoundErrorDialog()
{
   LOG_DTOR(DcNotFoundErrorDialog);
}



void
DcNotFoundErrorDialog::OnInit()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::OnInit);

   Win::SetWindowText(hwnd, dialogTitle);   
   Win::SetDlgItemText(hwnd, IDC_ERROR_MESSAGE, errorMessage);

   // save the full size of the dialog so we can restore it later.
   
   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);

   originalHeight = fullRect.bottom - fullRect.top;

   HideDetails();
}



// resize the window to hide the details portion

void
DcNotFoundErrorDialog::HideDetails()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::HideDetails);

   // find the location of the horizontal line

   HWND line = Win::GetDlgItem(hwnd, IDC_HORIZONTAL_LINE);
   RECT lineRect;
   Win::GetWindowRect(line, lineRect);

   // find the dimensions of the dialog

   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);
   
   LONG shortHeight = lineRect.bottom - fullRect.top;

   Win::MoveWindow(
      hwnd,
      fullRect.left,
      fullRect.top,
      fullRect.right - fullRect.left,
      shortHeight,
      true);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DETAILS_TEXT), false);      
}



// resize the window to show the diagnostic results

void
DcNotFoundErrorDialog::ShowDetails()
{
   LOG_FUNCTION(DcNoFoundErrorDialog::ShowDetails);

   RECT fullRect;
   Win::GetWindowRect(hwnd, fullRect);
   
   Win::MoveWindow(
      hwnd,
      fullRect.left,
      fullRect.top,
      fullRect.right - fullRect.left,
      originalHeight,
      true);

   Win::EnableWindow(Win::GetDlgItem(hwnd, IDC_DETAILS_TEXT), true);
}



// Write the diagnostic text to a well-known file
// (%systemroot%\debug\dcdiag.txt), and return the name of the file.  Replaces
// the file if it exists already.  Return S_OK on success, or an error code on
// failure.  (On failure, the existence and contents of the file are not
// guaranteed).  The file is written in Unicode, as it may contain Unicode
// text (like non-rfc domain names).
// 
// contents - in, the text to be written.  Should not be the empty string.
// 
// filename - out, the name of the file that was written (on success), or
// would have been written (on failure).

HRESULT
WriteLogFile(const String& contents, String& filename)
{
   LOG_FUNCTION(WriteLogFile);
   ASSERT(!contents.empty());

   filename.erase();
   HRESULT hr = S_OK;
   HANDLE handle = INVALID_HANDLE_VALUE;
   
   do
   {
      String path = Win::GetSystemWindowsDirectory();

      filename = path + L"\\debug\\dcdiag.txt";

      hr =
         FS::CreateFile(
            filename,
            handle,
            GENERIC_WRITE,
            0,
            CREATE_ALWAYS);
      BREAK_ON_FAILED_HRESULT(hr);            

      hr = FS::Write(handle, contents);
      BREAK_ON_FAILED_HRESULT(hr);            
   }
   while (0);

   Win::CloseHandle(handle);
   
   LOG_HRESULT(hr);

   return hr;
}



// Run the diagnostic, and populate the UI with the results.  Also writes
// the results to a file if the user is deemed easily spooked.

void
DcNotFoundErrorDialog::DiagnoseAndSetDetailsText()
{
   LOG_FUNCTION(DcNotFoundErrorDialog::DiagnoseAndSetDetailsText);

   if (!diagnosticWasRun)
   {
      Win::WaitCursor wait;
      
      String details =
         DiagnoseDcNotFound(
            domainName,
            domainNameIsNotNetbios,
            helpTopicLink);

      if (!userIsDomainSavvy)
      {
         // The diagnosis will probably just frighten the poor user.  So write
         // the diagnostic info to a file, and preface all the icky computer
         // lingo with a soothing message about just delivering the file to an
         // administrator.

         String logFilename;
         HRESULT hr = WriteLogFile(details, logFilename);

         if (SUCCEEDED(hr))
         {
            details =
                  String::format(
                     IDS_DC_NOT_FOUND_SOOTHING_PREFACE_PARAM,
                     logFilename.c_str())
               +  details;
         }
         else
         {
            details = String::load(IDS_DC_NOT_FOUND_SOOTHING_PREFACE) + details;
         }
      }
   
      Win::SetDlgItemText(hwnd, IDC_DETAILS_TEXT, details);

      diagnosticWasRun = true;
   }
}

   

bool
DcNotFoundErrorDialog::OnCommand(
   HWND     /* windowFrom */ ,   
   unsigned controlIDFrom,
   unsigned code)         
{
//   LOG_FUNCTION(DcNotFoundErrorDialog::OnCommand);

   switch (controlIDFrom)
   {
      case IDOK:
      case IDCANCEL:
      {
         if (code == BN_CLICKED)
         {
            HRESULT unused = Win::EndDialog(hwnd, controlIDFrom);

            ASSERT(SUCCEEDED(unused));

            return true;
         }

         break;
      }
      case IDHELP:
      {
         if (code == BN_CLICKED)
         {
            DiagnoseAndSetDetailsText();

            if (!helpTopicLink.empty())
            {
               Win::HtmlHelp(hwnd, helpTopicLink, HH_DISPLAY_TOPIC, 0);
            }

            return true;
         }

         break;
      }
      case IDC_DETAILS_BUTTON:
      {
         if (code == BN_CLICKED)
         {
            int buttonLabelResId = IDS_SHOW_DETAILS_LABEL;
            
            if (detailsShowing)
            {
               HideDetails();
               detailsShowing = false;
            }
            else
            {
               buttonLabelResId = IDS_HIDE_DETAILS_LABEL;
               
               DiagnoseAndSetDetailsText();
               ShowDetails();
               detailsShowing = true;
            }

            Win::SetDlgItemText(
               hwnd,
               IDC_DETAILS_BUTTON,
               String::load(buttonLabelResId));
         }
         break;
      }
      default:
      {
         // do nothing
         
         break;
      }
   }

   return false;
}
   


void
ShowDcNotFoundErrorDialog(
   HWND          parent,
   int           editResId,
   const String& domainName,
   const String& dialogTitle,
   const String& errorMessage,
   bool          domainNameIsNotNetbios,
   bool          userIsDomainSavvy)
{
   LOG_FUNCTION(ShowDcNotFoundErrorDialog);
   ASSERT(Win::IsWindow(parent));
   
   // show the error dialog with the given error message.

   DcNotFoundErrorDialog(
      domainName,
      dialogTitle,
      errorMessage,
      domainNameIsNotNetbios,
      userIsDomainSavvy).ModalExecute(parent);   

   if (editResId != -1)
   {      
      HWND edit = Win::GetDlgItem(parent, editResId);
      Win::SendMessage(edit, EM_SETSEL, 0, -1);
      Win::SetFocus(edit);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\dialog.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Dialog class
// 
// 10-15-97 sburns



#include "headers.hxx"



// The base map is copied into the map supplied to the ctor.  It includes
// elements to disable context help for a range of control IDs.

static const DWORD BASE_HELP_MAP[] =
{
   // The STATIC_HELPLESS family is used to identify static controls for which
   // the Windows context help algorithm for ID == -1 is inappropriate.  That
   // algorithm is: if the control ID is -1, look for the next control in the
   // dialog, and present the help for it.  For group boxes and static text
   // following a control, this produces confusing results.  Unfortunately, -1
   // is the only ID exempt from resource compiler checking of unique control
   // IDs, so we need a bunch of "reserved" IDs.  Each control for which we
   // wish to disable context help is assigned an ID from the reserved pool.

   IDC_STATIC_HELPLESS,    NO_HELP,   
   IDC_STATIC_HELPLESS2,   NO_HELP,
   IDC_STATIC_HELPLESS3,   NO_HELP,
   IDC_STATIC_HELPLESS4,   NO_HELP,
   IDC_STATIC_HELPLESS5,   NO_HELP,
   IDC_STATIC_HELPLESS6,   NO_HELP,
   IDC_STATIC_HELPLESS7,   NO_HELP,
   IDC_STATIC_HELPLESS8,   NO_HELP,
   IDC_STATIC_HELPLESS9,   NO_HELP,
};

static const size_t baseMapSize = sizeof(BASE_HELP_MAP) / sizeof(DWORD);



Dialog::Dialog(
   unsigned    resID_,
   const DWORD helpMap_[])
   :
   hwnd(0),
   changemap(),
   helpMap(0),
   isEnded(false),
   isModeless(false),
   resID(resID_)
{
// Don't emit ctor trace, as this class is always a base class, and the
// derived class should emit the trace.

//   LOG_CTOR(Dialog);
   ASSERT(resID > 0);
   ASSERT(helpMap_);
   
   if (helpMap_)
   {
      size_t ctorMapsize = 0;
      while (helpMap_[++ctorMapsize])
      {
      }

      // make an even size, and add space for IDC_STATIC_HELPLESSn IDs

      size_t mapsize = ctorMapsize + (ctorMapsize % 2) + baseMapSize;
      helpMap = new DWORD[mapsize];

      // REVIEWED-2002/03/05-sburns correct byte count passed.
      
      ::ZeroMemory(helpMap, mapsize * sizeof DWORD);

      // copy the base map

      std::copy(BASE_HELP_MAP, BASE_HELP_MAP + baseMapSize, helpMap);

      // then append the ctor map

      std::copy(helpMap_, helpMap_ + ctorMapsize, helpMap + baseMapSize);
   }

   ClearChanges();
}



Dialog::~Dialog()
{
   
// Don't emit dtor trace, as this class is always a base class, and the
// derived class should emit the trace.
//   LOG_DTOR(Dialog);

   if (isModeless && !isEnded)
   {
      // this will destroy the window

      EndModelessExecution();
   }

   delete[] helpMap;
   hwnd = 0;
}
   


Dialog*
Dialog::GetInstance(HWND pageDialog)
{
   LONG_PTR ptr = 0;
   HRESULT hr = Win::GetWindowLongPtr(pageDialog, DWLP_USER, ptr);

   ASSERT(SUCCEEDED(hr));

   // don't assert ptr, it may not have been set.  Some messages are
   // sent before WM_INITDIALOG, which is the earliest we can set the
   // pointer.

   return reinterpret_cast<Dialog*>(ptr);
}



INT_PTR
Dialog::ModalExecute(HWND parent)
{
   LOG_FUNCTION(Dialog::ModalExecute);
   ASSERT(parent == 0 || Win::IsWindow(parent));

   return
      Win::DialogBoxParam(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         parent,
         Dialog::dialogProc,
         reinterpret_cast<LPARAM>(this));
}



INT_PTR
Dialog::ModalExecute(const Dialog& parent)
{
   return ModalExecute(parent.GetHWND());
}



HWND
Dialog::GetHWND() const
{
//   LOG_FUNCTION(Dialog::GetHWND);
   ASSERT(hwnd);

   return hwnd;
}   



void
Dialog::OnInit()
{
//   LOG_FUNCTION(Dialog::OnInit);
}



void
Dialog::OnDestroy()
{
//   LOG_FUNCTION(Dialog::OnDestroy);
}



bool
Dialog::OnCommand(
   HWND        /* windowFrom */ ,
   unsigned    /* controlIDFrom */ ,
   unsigned    /* code */ )
{
//   LOG_FUNCTION(Dialog::OnCommand);

   return false;
}



bool
Dialog::OnNotify(
   HWND     /* windowFrom */ ,
   UINT_PTR /* controlIDFrom */ ,
   UINT     /* code */ ,
   LPARAM   /* lParam */ )
{
//   LOG_FUNCTION(Dialog::OnNotify);

   return false;
}



unsigned
Dialog::GetResID() const
{
   return resID;
}



void
Dialog::SetHWND(HWND window)
{
   if (hwnd == window)
   {
      // this should not be already set unless it's a modeless dialog
      ASSERT(isModeless);
   }
   else
   {
      ASSERT(!hwnd);
   }

   hwnd = window;
}



// CODEWORK: I assert that in all cases, the lifetime of the Dialog instance
// encompasses the lifetime of the Window handle.  Therefore, it is not
// possible to have a message sent to a window that will be dispatched to a
// Dialog instance that no longer exists.
// 
// However, the code could be made to verify this assertion by:
// 
// - allocating user space in the window for a flag (this means subclassing
// and adding bytes to the window with the cbWndExtra member of the WNDCLASSEX
// structure)
// 
// - setting that flag in the user area of the hwnd when the WM_INITDIALOG
// message sets the DWLP_USER to point to the Dialog instance.
// 
// - clearing the DWLP_USER value in the dtor
// 
// - in dialogProc, asserting that if the flag is set, the DWLP_USER value is
// set too.

INT_PTR CALLBACK
Dialog::dialogProc(
   HWND     dialog,
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
   switch (message)
   {
      case WM_INITDIALOG:
      {
         // a pointer to the Dialog is in lparam.  Save this in the window
         // structure so that it can later be retrieved by GetInstance.

         ASSERT(lparam);
         Win::SetWindowLongPtr(dialog, DWLP_USER, lparam);

         Dialog* dlg = GetInstance(dialog);
         if (dlg)
         {
            dlg->SetHWND(dialog);
            dlg->OnInit();

            // determine if we can set the control ID. A window without
            // the WS_CHILD style can't have the control ID set, because
            // that bit of window data is instead used for the window's
            // HMENU

            LONG l = 0;
            HRESULT hr = Win::GetWindowLong(dialog, GWL_STYLE, l);
            if (SUCCEEDED(hr))
            {
               if (l & WS_CHILD)
               {
                  Win::SetWindowLongPtr(
                     dialog,
                     GWLP_ID,
                     (LONG_PTR) dlg->GetResID());
               }
            }
         }
   
         return TRUE;
      }
      case WM_COMMAND:
      {
         Dialog* dlg = GetInstance(dialog);

         // Amazingly, buddy spin controls send EN_UPDATE and EN_CHANGE
         // before WM_INITDIALOG is called!
         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               dlg->OnCommand(
                  reinterpret_cast<HWND>(lparam),
                  LOWORD(wparam),
                  HIWORD(wparam));
         }
         break;   
      }
      case WM_NOTIFY:
      {
         NMHDR* nmhdr = reinterpret_cast<NMHDR*>(lparam);
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            return
               dlg->OnNotify(
                  nmhdr->hwndFrom,
                  nmhdr->idFrom,
                  nmhdr->code,
                  lparam);
         }
         break;
      }
      case WM_DESTROY:
      {
         // It's possible to get a WM_DESTROY message without having gotten
         // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
         // comctl32.dll) fails, so guard against this case.

         Dialog* dlg = GetInstance(dialog);
         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            dlg->OnDestroy();
         }

         return FALSE;
      }
      case WM_HELP:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            if (dlg->helpMap && HELPFILE_NAME && HELPFILE_NAME[0])
            {
               HELPINFO* helpinfo = reinterpret_cast<HELPINFO*>(lparam);
               ASSERT(helpinfo);

               if (helpinfo)
               {
                  if (helpinfo->iContextType == HELPINFO_WINDOW)
                  {
                     Win::WinHelp(
                        reinterpret_cast<HWND>(helpinfo->hItemHandle),
                        Win::GetSystemWindowsDirectory().append(HELPFILE_NAME),
                        HELP_WM_HELP,
                        reinterpret_cast<ULONG_PTR>(dlg->helpMap));
                  }
               }
            }
         }
         return TRUE;
      }
      case WM_CONTEXTMENU:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);            
            if (dlg->helpMap && HELPFILE_NAME && HELPFILE_NAME[0])
            {
               Win::WinHelp(
                  reinterpret_cast<HWND>(wparam),
                  Win::GetSystemWindowsDirectory().append(HELPFILE_NAME),
                  HELP_CONTEXTMENU,
                  reinterpret_cast<ULONG_PTR>(dlg->helpMap));
            }
         }
         return TRUE;
      }
      case WM_CTLCOLORDLG:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return 
               reinterpret_cast<INT_PTR>(
                  dlg->OnCtlColorDlg(
                     reinterpret_cast<HDC>(wparam),
                     reinterpret_cast<HWND>(lparam)));
         }
         break;
      }
      case WM_CTLCOLORSTATIC:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               reinterpret_cast<INT_PTR>(
                  dlg->OnCtlColorStatic(
                     reinterpret_cast<HDC>(wparam),
                     reinterpret_cast<HWND>(lparam)));
         }
         break;
      }
      case WM_CTLCOLOREDIT:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               reinterpret_cast<INT_PTR>(
                  dlg->OnCtlColorEdit(
                     reinterpret_cast<HDC>(wparam),
                     reinterpret_cast<HWND>(lparam)));
         }
         break;
      }
      case WM_CTLCOLORLISTBOX:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               reinterpret_cast<INT_PTR>(
                  dlg->OnCtlColorListbox(
                     reinterpret_cast<HDC>(wparam),
                     reinterpret_cast<HWND>(lparam)));
         }
         break;
      }
      case WM_CTLCOLORSCROLLBAR:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return
               reinterpret_cast<INT_PTR>(
                  dlg->OnCtlColorScrollbar(
                     reinterpret_cast<HDC>(wparam),
                     reinterpret_cast<HWND>(lparam)));
         }
         break;
      }
      default:
      {
         Dialog* dlg = GetInstance(dialog);

         if (dlg)
         {
            ASSERT(dlg->hwnd == dialog);
            return dlg->OnMessage(message, wparam, lparam);
         }
         break;
      }
   }

   return FALSE;
}



void
Dialog::ClearChanges()
{
//   LOG_FUNCTION(Dialog::ClearChanges);

   changemap.clear();
}



void
Dialog::SetChanged(UINT_PTR controlResID)
{
//   LOG_FUNCTION(Dialog::SetChanged);

   if (Win::GetDlgItem(hwnd, static_cast<int>(controlResID)))
   {
      changemap[controlResID] = true;
   }
}



bool
Dialog::WasChanged(UINT_PTR controlResId) const
{
//   LOG_FUNCTION(Dialog::WasChanged);

   bool result = false;
   do
   {
      ChangeMap::iterator iter = changemap.find(controlResId);
      if (iter != changemap.end())
      {
         // the res id was in the map, so check the mapped value.

         result = iter->second;
         break;
      }

      // the res id was not in the map, so it can't have been changed.

      ASSERT(result == false);
   }
   while (0);

   return result;
}



bool
Dialog::WasChanged() const
{
//   LOG_FUNCTION(Dialog::WasChanged);

   bool result = false;

   do
   {   
      if (changemap.size() == 0)
      {
         // no entries in the map == no changes.

         break;
      }

      for (
         Dialog::ChangeMap::iterator i = changemap.begin();
         i != changemap.end();
         ++i)
      {
         if (i->second)
         {
            // found an entry marked "changed"

            result = true;
            break;
         }
      }
   }
   while (0);

   return result;
}

   

void
Dialog::DumpChangeMap() const
{

#ifdef DBG
   Win::OutputDebugString(L"start\n");
   for (
      Dialog::ChangeMap::iterator i = changemap.begin();
      i != changemap.end();
      ++i)
   {
      Win::OutputDebugString(
         String::format(
            L"%1!d! %2 \n",
            (*i).first,
            (*i).second ? L"true" : L"false"));
   }
   Win::OutputDebugString(L"end\n");
#endif

}

HBRUSH
Dialog::OnCtlColorDlg(
   HDC   /*deviceContext*/, 
   HWND  /*dialog*/)
{
//   LOG_FUNCTION(Dialog::OnCtlColorDlg);

   return 0;
}

HBRUSH
Dialog::OnCtlColorStatic(
   HDC   /*deviceContext*/, 
   HWND  /*dialog*/)
{
//   LOG_FUNCTION(Dialog::OnCtlColorStatic);

   return 0;
}

HBRUSH
Dialog::OnCtlColorEdit(
   HDC   /*deviceContext*/, 
   HWND  /*dialog*/)
{
//   LOG_FUNCTION(Dialog::OnCtlColorEdit);

   return 0;
}

HBRUSH
Dialog::OnCtlColorListbox(
   HDC   /*deviceContext*/, 
   HWND  /*dialog*/)
{
//   LOG_FUNCTION(Dialog::OnCtlColorListbox);

   return 0;
}

HBRUSH
Dialog::OnCtlColorScrollbar(
   HDC   /*deviceContext*/, 
   HWND  /*dialog*/)
{
//   LOG_FUNCTION(Dialog::OnCtlColorScrollbar);

   return 0;
}

bool
Dialog::OnMessage(
   UINT     /* message */,
   WPARAM   /* wparam */,
   LPARAM   /* lparam */)
{
//   LOG_FUNCTION(Dialog::OnMessage);

   return false;
}



void
Dialog::ModelessExecute(HWND parent)
{
   LOG_FUNCTION(Dialog::ModelessExecute);
   ASSERT(parent == 0 || Win::IsWindow(parent));

   isModeless = true;

   HRESULT hr = 
      Win::CreateDialogParam(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         parent,
         Dialog::dialogProc,
         reinterpret_cast<LPARAM>(this),
         hwnd);

   ASSERT(SUCCEEDED(hr));
}



void
Dialog::ModelessExecute(const Dialog& parent)
{
   ModelessExecute(parent.GetHWND());
}



void
Dialog::EndModelessExecution()
{
   LOG_FUNCTION(Dialog::EndModelessExecution);
   ASSERT(isModeless);
   ASSERT(Win::IsWindow(hwnd));

   if (isModeless)
   {
      Win::DestroyWindow(hwnd);
      isEnded = true;
      hwnd = 0;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\dns.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DNS API wrappers
//
// 12-16-97 sburns



#include "headers.hxx"



// not a String instance to avoid order of static initialization problems

static const wchar_t* DNS_SERVICE_NAME = L"dns";



bool
Dns::IsClientConfigured()
{
   LOG_FUNCTION(Dns::IsClientConfigured);

   bool result = true;

   PDNS_RECORD unused = 0;
   LOG(L"Calling DnsQuery");
   LOG(               L"lpstrName         : \"\" (empty)");
   LOG(               L"wType             : DNS_TYPE_A");
   LOG(               L"fOPtions          : DNS_QUERY_BYPASS_CACHE");
   LOG(               L"aipServers        : 0");
   LOG(String::format(L"ppQueryResultsSet : 0x%1!X!", &unused));
   LOG(               L"pReserved         : 0");

   DNS_STATUS testresult =
      ::DnsQuery(
         L"",
         DNS_TYPE_A,
         DNS_QUERY_BYPASS_CACHE,    
         0,   // use the default server list
         &unused,   
         0);  // as above

   LOG(String::format(L"Result 0x%1!X!", testresult));
   LOG(MyDnsStatusString(testresult));

   if (testresult == DNS_ERROR_NO_DNS_SERVERS)
   {
      result = false;
   }

   LOG(
      String::format(
         L"DNS client %1 configured",
         result ? L"is" : L"is NOT"));

   return result;
}



String
MyDnsStatusString(DNS_STATUS status)
{
   // this converts the ansi result to unicode with a String ctor, and strips whitespace

   return String(::DnsStatusString(status)).strip(String::BOTH);
}



DNS_STATUS
MyDnsValidateName(const String& name, DNS_NAME_FORMAT format)
{
   LOG_FUNCTION2(MyDnsValidateName, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsValidateName");
   LOG(String::format(L"pszName : %1", name.c_str()));
   LOG(String::format(L"Format  : %1!d!", format));

   DNS_STATUS status = ::DnsValidateName(name.c_str(), format);

   LOG(String::format(L"status 0x%1!X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}
   


// maxUnicodeCharacters - in, max number of unicode characters allowed in
// the name.
   
// maxUTF8Bytes - in, maximum number of bytes allowed to represent s in the
// UTF-8 character set.

Dns::ValidateResult
DoDnsValidation(
   const String&     s,
   size_t            maxUnicodeCharacters,
   size_t            maxUTF8Bytes,
   DNS_NAME_FORMAT   format)
{
   LOG_FUNCTION2(
      DoDnsValidation,
      String::format(
         L"s: %1, max len unicode: %2!d!, max len utf8: %3!d!",
         s.c_str(),
         maxUnicodeCharacters,
         maxUTF8Bytes));
   ASSERT(!s.empty());
   ASSERT(maxUnicodeCharacters);
   ASSERT(maxUTF8Bytes);

   // a unicode character requires at least 1 byte in utf8, so sanity check
   // the limits.
   
   ASSERT(maxUTF8Bytes >= maxUnicodeCharacters);

   Dns::ValidateResult result = Dns::INVALID;
   do
   {
      if (s.empty())
      {
         // obviously bad

         break;
      }

      //
      // we do our own length checking, as the DnsValidateName API does not
      // return a distinct error code for length problems.
      //

      // first- cheap length test.  Since a character will never be smaller
      // than 1 byte, if the number of characters exceeds the number of
      // bytes, we know it will never fit.

      if (s.length() > maxUTF8Bytes || s.length() > maxUnicodeCharacters)
      {
         result = Dns::TOO_LONG;
         break;
      }

      // second- check length of against corresponding UTF8 string
      // utf8bytes is the number of bytes (not characters) required to hold
      // the string in the UTF-8 character set.

      size_t utf8bytes = 
         static_cast<size_t>(

            // ISSUE-2002/03/05-sburns why isn't this wrapped with a Win function?
            
            ::WideCharToMultiByte(
               CP_UTF8,
               0,
               s.c_str(),
               static_cast<int>(s.length()),
               0,
               0,
               0,
               0));

      LOG(String::format(L"name is %1!d! utf-8 bytes", utf8bytes));

      if (utf8bytes > maxUTF8Bytes)
      {
         LOG(L"UTF-8 length too long");
         result = Dns::TOO_LONG;
         break;
      }

      // last- check the name for valid characters

      DNS_STATUS status = MyDnsValidateName(s, format);
      switch (status)
      {
         case ERROR_SUCCESS:
         {
            result = Dns::VALID;
            break;
         }
         case DNS_ERROR_NON_RFC_NAME:
         {
            result = Dns::NON_RFC;
            break;
         }
         case DNS_ERROR_NUMERIC_NAME:
         {
            result = Dns::NUMERIC;
            break;
         }
         case DNS_ERROR_INVALID_NAME_CHAR:
         {
            result = Dns::BAD_CHARS;
            break;
         }
         case ERROR_INVALID_NAME:
         default:
         {
            // do nothing

            break;
         }
      }
   }
   while (0);

   return result;
}



Dns::ValidateResult
Dns::ValidateDnsLabelSyntax(const String& candidateDNSLabel)
{
   LOG_FUNCTION2(Dns::ValidateDnsLabelSyntax, candidateDNSLabel);
   ASSERT(!candidateDNSLabel.empty());

   return 
      DoDnsValidation(
         candidateDNSLabel,
         Dns::MAX_LABEL_LENGTH,
         Dns::MAX_LABEL_LENGTH,

         // always use the Hostname formats, as they check for all-numeric
         // labels.

         DnsNameHostnameLabel);
}

  

Dns::ValidateResult
Dns::ValidateDnsNameSyntax(
   const String&  candidateDNSName,
   size_t         maxLenUnicodeCharacters,
   size_t         maxLenUTF8Bytes)
{
   LOG_FUNCTION2(Dns::ValidateDnsNameSyntax, candidateDNSName);
   ASSERT(!candidateDNSName.empty());

   return
      DoDnsValidation(
         candidateDNSName,
         maxLenUnicodeCharacters,
         maxLenUTF8Bytes,     // for policy bug workaround
         DnsNameDomain);      // allow numeric first labels
}



bool
Dns::IsServiceInstalled()
{
   LOG_FUNCTION(Dns::IsServiceInstalled);
  
   NTService s(DNS_SERVICE_NAME);

   bool result = s.IsInstalled();

   LOG(
      String::format(
         L"service %1 installed.",
         result ? L"is" : L"is not"));

   return result;
}



bool
Dns::IsServiceRunning()
{
   LOG_FUNCTION(Dns::IsServiceRunning);

   bool result = false;
   NTService s(DNS_SERVICE_NAME);
   DWORD state = 0;
   if (SUCCEEDED(s.GetCurrentState(state)))
   {
      result = (state == SERVICE_RUNNING);
   }

   LOG(
      String::format(
         L"service %1 running.",
         result ? L"is" : L"is not"));

   return result;
}



String
Dns::HostnameToNetbiosName(const String& hostname, HRESULT* err)
{
   LOG_FUNCTION2(Dns::HostnameToNetbiosName, hostname);

   ASSERT(!hostname.empty());

   if (err)
   {
      *err = S_OK;
   }

   static const int NAME_SIZE = MAX_COMPUTERNAME_LENGTH + 1;
   DWORD size = NAME_SIZE;
   TCHAR buf[NAME_SIZE];

   // REVIEWED-2002/03/05-sburns correct byte count passed.

   ::ZeroMemory(buf, sizeof buf);

   BOOL result =
      ::DnsHostnameToComputerName(
         const_cast<wchar_t*>(hostname.c_str()),
         buf,
         &size);
   ASSERT(result);

   if (result)
   {
      LOG(buf);
      return buf;
   }

   HRESULT hr = Win::GetLastErrorAsHresult();
   LOG_HRESULT(hr);

   if (err)
   {
      *err = hr;
   }

   return String();
}



DNS_NAME_COMPARE_STATUS
Dns::CompareNames(const String& dnsNameA, const String& dnsNameB)
{
   LOG_FUNCTION2(
      Dns::CompareNames,
      dnsNameA + L" vs " + dnsNameB);
   ASSERT(!dnsNameA.empty());
   ASSERT(!dnsNameB.empty());

   PCWSTR a = dnsNameA.c_str();
   PCWSTR b = dnsNameB.c_str();
    
   LOG(L"Calling DnsNameCompareEx_W");
   LOG(String::format(L"pszLeftName  : %1", a));
   LOG(String::format(L"pszRightName : %1", b));
   LOG(               L"dwReserved   : 0");

   DNS_NAME_COMPARE_STATUS status = ::DnsNameCompareEx_W(a, b, 0);

#ifdef LOGGING_BUILD
   LOG(String::format(L"Result 0x%1!X!", status));

   String rel;
   switch (status)
   {
      case DnsNameCompareNotEqual:
      {
         rel = L"DnsNameCompareNotEqual";
         break;
      }
      case DnsNameCompareEqual:
      {
         rel = L"DnsNameCompareEqual";
         break;
      }
      case DnsNameCompareLeftParent:
      {
         rel = L"DnsNameCompareLeftParent";
         break;
      }
      case DnsNameCompareRightParent:
      {
         rel = L"DnsNameCompareRightParent";
         break;
      }
      case DnsNameCompareInvalid:
      {
         rel = L"DnsNameCompareInvalid";
         break;
      }
      default:
      {
         ASSERT(false);
         rel = L"error";
         break;
      }
   }

   LOG(String::format(L"relation: %1", rel.c_str()));
#endif

   return status;
}



void
MyDnsRecordListFree(DNS_RECORD* rl)
{
   if (rl)
   {
      ::DnsRecordListFree(rl, DnsFreeRecordListDeep);
   }
}



// caller must free the result with MyDnsRecordListFree

DNS_STATUS
MyDnsQuery(
   const String& name,
   WORD          type,
   DWORD         options,
   DNS_RECORD*&  result)
{
   LOG_FUNCTION2(MyDnsQuery, name);
   ASSERT(!name.empty());

   LOG(L"Calling DnsQuery_W");
   LOG(String::format(L"lpstrName : %1", name.c_str()));
   LOG(String::format(L"wType     : %1!X!", type));
   LOG(String::format(L"fOptions  : %1!X!", options));

   DNS_STATUS status =
      ::DnsQuery_W(
         name.c_str(),
         type,
         options,
         0,
         &result,
         0);

   LOG(String::format(L"status = %1!08X!", status));
   LOG(MyDnsStatusString(status));

   return status;
}



String
Dns::GetParentDomainName(const String& domainName)
{
   LOG_FUNCTION2(Dns::GetParentDomainName, domainName);
   ASSERT(!domainName.empty());

   String result(domainName);

   do
   {
      if (domainName.empty())
      {
         break;
      }

      size_t pos = domainName.find_first_of(L".");

      if (pos == String::npos)
      {
         // no dot found, so we've found the last label of a name that is
         // not fully qualified. So the parent zone is the root zone.

         result = L".";
         break;
      }

      // REVIEW: this is the same as pos == domainName.rbegin(). Which is
      // cheaper?

      if (pos == domainName.length() - 1)
      {
         // we found the last dot.  Don't back up any further -- we define
         // the parent zone of the root zone to be the root zone itself.

         result = domainName.substr(pos);
         break;
      }

      result = domainName.substr(pos + 1);
   }
   while (0);

   LOG(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\dsutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// DS utility functions
//
// 3-11-99 sburns



#include "headers.hxx"



// Caller must free info with ::NetApiBufferFree

HRESULT
MyDsGetDcName(
   const TCHAR*               machine,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info)
{
   LOG_FUNCTION(MyDsGetDcName);

   info = 0;

   LOG(L"Calling DsGetDcName");
   LOG(String::format(L"ComputerName : %1", machine ? machine : L"(null)"));
   LOG(String::format(L"DomainName   : %1", domainName.c_str()));
   LOG(               L"DomainGuid   : (null)");
   LOG(               L"SiteGuid     : (null)");
   LOG(String::format(L"Flags        : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDcName(
            machine,
            domainName.c_str(),
            0,
            0,
            flags,
            &info));

   LOG_HRESULT(hr);

   // do second attempt masking in DS_FORCE_REDISCOVERY, if not already
   // specified.

   if (FAILED(hr) && !(flags & DS_FORCE_REDISCOVERY))
   {
      // try again w/ rediscovery on

      LOG(L"Trying again w/ rediscovery");

      flags |= DS_FORCE_REDISCOVERY;
      hr =
         Win32ToHresult(
            ::DsGetDcName(
               machine,
               domainName.c_str(),
               0,
               0,
               flags,
               &info));

      LOG_HRESULT(hr);
   }


#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"DomainControllerName    : %1",       info->DomainControllerName));
      LOG(String::format(L"DomainControllerAddress : %1",       info->DomainControllerAddress));
      LOG(String::format(L"DomainGuid              : %1",       Win::StringFromGUID2(info->DomainGuid).c_str()));
      LOG(String::format(L"DomainName              : %1",       info->DomainName));
      LOG(String::format(L"DnsForestName           : %1",       info->DnsForestName));
      LOG(String::format(L"Flags                   : 0x%1!X!:", info->Flags));
      LOG(String::format(L"DcSiteName              : %1",       info->DcSiteName));
      LOG(String::format(L"ClientSiteName          : %1",       info->ClientSiteName));
   }
#endif

   return hr;
}



bool
IsDomainReachable(const String& domainName)
{
   LOG_FUNCTION(IsDomainReachable);
   ASSERT(!domainName.empty());

   bool result = false;
   if (!domainName.empty())
   {
      DOMAIN_CONTROLLER_INFO* info = 0;
      HRESULT hr =
         MyDsGetDcName(
            0, // this server
            domainName,

            // force discovery to ensure that we don't pick up a cached
            // entry for a domain that may no longer exist

            DS_FORCE_REDISCOVERY,
            info);
      if (SUCCEEDED(hr))
      {
         ::NetApiBufferFree(info);
         result = true;
      }
   }

   LOG(
      String::format(
         L"The domain %1 %2 be reached.",
         domainName.c_str(),
         result ? L"can" : L"can NOT"));

   return result;
}



bool
IsDSRunning()
{
   LOG_FUNCTION(IsDSRunning);

   bool result = false;
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC* info = 0;
   HRESULT hr = MyDsRoleGetPrimaryDomainInformation(0, info);
   if (SUCCEEDED(hr) && info)
   {
      result = info->Flags & DSROLE_PRIMARY_DS_RUNNING ? true : false;
      ::DsRoleFreeMemory(info);
   }

   LOG(
      String::format(
         L"DS %1 running",
         result ? L"is" : L"is NOT"));

   return result;
}



HRESULT
MyDsBind(const String& dcName, const String& dnsDomain, HANDLE& hds)
{
   LOG_FUNCTION(MyDsBind);

   // either parameter may be empty
      
   LOG(L"Calling DsBind");
   LOG(String::format(L"DomainControllerName : %1",
      dcName.empty() ? L"(null)" : dcName.c_str()));
   LOG(String::format(L"DnsDomainName        : %1",
      dnsDomain.empty() ? L"(null)" : dnsDomain.c_str()));

   hds = 0;
   HRESULT hr =
      Win32ToHresult(
         ::DsBind(
            dcName.empty() ? 0 : dcName.c_str(),
            dnsDomain.empty() ? 0 : dnsDomain.c_str(),
            &hds));

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
MyDsBindWithCred(
   const String&          dcName,    
   const String&          dnsDomain, 
   const String&          username,  
   const String&          userDomain,
   const EncryptedString& password,  
   HANDLE&                hds)
{
   LOG_FUNCTION(MyDsBindWithCred);

#ifdef DBG   
   if (username.empty())
   {
      ASSERT(userDomain.empty());
      ASSERT(password.IsEmpty());
   }
#endif

   hds = 0;
   HRESULT hr = S_OK;
   do
   {
      // create an identity handle
      HANDLE authIdentity = INVALID_HANDLE_VALUE;
      PWSTR u =
         username.empty() ? 0 : const_cast<wchar_t*>(username.c_str());
      PWSTR d = const_cast<wchar_t*>(userDomain.c_str());

      LOG(L"Calling DsMakePasswordCredentials");
      LOG(String::format(L"User   : %1", u ? u : L"(null)"));
      LOG(String::format(L"Domain : %1", d ? d : L"(null)"));

      PWSTR p = password.GetClearTextCopy();
      hr = Win32ToHresult(::DsMakePasswordCredentials(u, d, p, &authIdentity));
      password.DestroyClearTextCopy(p);
      
      BREAK_ON_FAILED_HRESULT(hr);

      LOG_HRESULT(hr);

      PCWSTR dc = dcName.empty() ? 0 : dcName.c_str();
      PCWSTR dom = dnsDomain.empty() ? 0 : dnsDomain.c_str();

      LOG(L"Calling DsBindWithCred");
      LOG(String::format(L"DomainControllerName : %1", dc ? dc : L"(null)"));
      LOG(String::format(L"DnsDomainName        : %1", dom ? dom : L"(null)"));

      hr = Win32ToHresult(::DsBindWithCred(dc, dom, authIdentity, &hds));
      // don't break here, continue on to free the identity handle

      LOG_HRESULT(hr);

      ::DsFreePasswordCredentials(authIdentity);
   }
   while (0);

   return hr;
}



HRESULT
MyDsGetDomainControllerInfoHelper(
   HANDLE         hDs,
   const String&  domainName,
   DWORD          infoLevel,
   DWORD&         cOut,
   void**         info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfoHelper);
   ASSERT(hDs);
   ASSERT(!domainName.empty());
   ASSERT(infoLevel);
   ASSERT(info);

   cOut = 0;

   LOG(L"Calling DsGetDomainControllerInfo");
   LOG(String::format(L"DomainName : %1", domainName.c_str()));
   LOG(String::format(L"InfoLevel  : %1!d!", infoLevel));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDomainControllerInfo(
            hDs,
            domainName.c_str(),
            infoLevel,
            &cOut,
            info));

   LOG_HRESULT(hr);

#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"*pcOut : %1!d!", cOut));
   }
#endif

   return hr;
}



HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W*&   info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfo);

   return
      MyDsGetDomainControllerInfoHelper(
         hDs,
         domainName,
         1,
         cOut,
         reinterpret_cast<void**>(&info));
}



HRESULT
MyDsGetDomainControllerInfo(
   HANDLE                           hDs,
   const String&                    domainName,
   DWORD&                           cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W*&   info)
{
   LOG_FUNCTION(MyDsGetDomainControllerInfo);

   return
      MyDsGetDomainControllerInfoHelper(
         hDs,
         domainName,
         2,
         cOut,
         reinterpret_cast<void**>(&info));
}



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_1W* info)
{
   LOG_FUNCTION(MyDsFreeDomainControllerInfo);
   ASSERT(info);

   ::DsFreeDomainControllerInfo(1, cOut, info);
}



void
MyDsFreeDomainControllerInfo(
   DWORD                         cOut,
   DS_DOMAIN_CONTROLLER_INFO_2W* info)
{
   LOG_FUNCTION(MyDsFreeDomainControllerInfo);
   ASSERT(info);

   ::DsFreeDomainControllerInfo(2, cOut, info);
}

                                 

#ifdef LOGGING_BUILD

String
LevelName(DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level)
{
   switch (level)
   {
      case ::DsRoleOperationState:
      {
         return L"DsRoleOperationState";
      }
      case ::DsRolePrimaryDomainInfoBasic:
      {
         return L"DsRolePrimaryDomainInfoBasic";
      }
      case ::DsRoleUpgradeStatus:
      {
         return L"DsRoleUpgradeStatus";
      }
      default:
      {
         ASSERT(false);

         // fall thru;
      }
   }

   return L"** unknown **";
}

#endif



// Caller needs to buffer info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformationHelper(
   const TCHAR*                     machine,
   DSROLE_PRIMARY_DOMAIN_INFO_LEVEL level,
   BYTE*&                           buffer)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformationHelper);

   buffer = 0;

   LOG(L"Calling DsRoleGetPrimaryDomainInformation");
   LOG(
      String::format(
         L"lpServer  : %1",
         machine ? machine : L"(null)" ));
   LOG(
      String::format(
         L"InfoLevel : 0x%1!X! (%2)",
         level,
         LevelName(level).c_str()));

   HRESULT hr =
      Win32ToHresult(
         ::DsRoleGetPrimaryDomainInformation(machine, level, &buffer));

   LOG_HRESULT(hr);

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_OPERATION_STATE_INFO*&       info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRoleOperationState,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_OPERATION_STATE_INFO*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(
            String::format(
               L"OperationState : 0x%1!X!",
               info->OperationState));
      }
#endif

   }

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                        machine,
   DSROLE_PRIMARY_DOMAIN_INFO_BASIC*&  info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRolePrimaryDomainInfoBasic,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_PRIMARY_DOMAIN_INFO_BASIC*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(String::format(L"MachineRole      : 0x%1!X!", info->MachineRole));
         LOG(String::format(L"Flags            : 0x%1!X!", info->Flags));
         LOG(String::format(L"DomainNameFlat   : %1", info->DomainNameFlat   ? info->DomainNameFlat   : L"(null)"));
         LOG(String::format(L"DomainNameDns    : %1", info->DomainNameDns    ? info->DomainNameDns    : L"(null)"));
         LOG(String::format(L"DomainForestName : %1", info->DomainForestName ? info->DomainForestName : L"(null)"));
      }
#endif

   }

   return hr;
}



// Caller needs to delete info with ::DsRoleFreeMemory.

HRESULT
MyDsRoleGetPrimaryDomainInformation(
   const TCHAR*                  machine,
   DSROLE_UPGRADE_STATUS_INFO*&  info)
{
   LOG_FUNCTION(MyDsRoleGetPrimaryDomainInformation);

   info = 0;

   BYTE* buffer = 0;
   HRESULT hr =
      Win32ToHresult(
         MyDsRoleGetPrimaryDomainInformationHelper(
            machine,
            ::DsRoleUpgradeStatus,
            buffer));
   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<DSROLE_UPGRADE_STATUS_INFO*>(buffer);

      ASSERT(info);

#ifdef LOGGING_BUILD
      if (info)
      {
         LOG(String::format(L"OperationState      : %1!d!", info->OperationState));
         LOG(String::format(L"PreviousServerState : %1!d!", info->PreviousServerState));
      }
#endif

   }

   return hr;
}



HRESULT
MyDsGetDcNameWithAccount(
   const TCHAR*               machine,
   const String&              accountName,
   ULONG                      allowedAccountFlags,
   const String&              domainName,
   ULONG                      flags,
   DOMAIN_CONTROLLER_INFO*&   info)
{
   LOG_FUNCTION(MyDsGetDcNameWithAccount);
   ASSERT(!domainName.empty());
   ASSERT(!accountName.empty());

   info = 0;

   LOG(L"Calling DsGetDcNameWithAccount");
   LOG(String::format(L"ComputerName          : %1",      machine ? machine : L"(null)"));
   LOG(String::format(L"AccountName           : %1",      accountName.c_str()));
   LOG(String::format(L"AllowableAccountFlags : 0x%1!X!", allowedAccountFlags));
   LOG(String::format(L"DomainName            : %1",      domainName.c_str()));
   LOG(               L"DomainGuid            : (null)");
   LOG(               L"SiteGuid              : (null)");
   LOG(String::format(L"Flags                 : 0x%1!X!", flags));

   HRESULT hr =
      Win32ToHresult(
         ::DsGetDcNameWithAccountW(
            machine,
            accountName.c_str(),
            allowedAccountFlags,
            domainName.c_str(),
            0,
            0,
            flags,
            &info));

   LOG_HRESULT(hr);

   // on error, do second attempt masking in DS_FORCE_REDISCOVERY, if not
   // already specified.

   if (FAILED(hr) && !(flags & DS_FORCE_REDISCOVERY))
   {
      LOG(L"Trying again w/ rediscovery");

      flags |= DS_FORCE_REDISCOVERY;
      hr =
         Win32ToHresult(
            ::DsGetDcNameWithAccountW(
               machine,
               accountName.c_str(),
               allowedAccountFlags,
               domainName.c_str(),
               0,
               0,
               flags,
               &info));

      LOG_HRESULT(hr);
   }

#ifdef LOGGING_BUILD
   if (SUCCEEDED(hr))
   {
      LOG(String::format(L"DomainControllerName    : %1",       info->DomainControllerName    ? info->DomainControllerName    : L"(null)"));
      LOG(String::format(L"DomainControllerAddress : %1",       info->DomainControllerAddress ? info->DomainControllerAddress : L"(null)"));
      LOG(String::format(L"DomainGuid              : %1",       Win::StringFromGUID2(info->DomainGuid).c_str()));
      LOG(String::format(L"DomainName              : %1",       info->DomainName              ? info->DomainName              : L"(null)"));
      LOG(String::format(L"DnsForestName           : %1",       info->DnsForestName           ? info->DnsForestName           : L"(null)"));
      LOG(String::format(L"Flags                   : 0x%1!X!:", info->Flags));
      LOG(String::format(L"DcSiteName              : %1",       info->DcSiteName              ? info->DcSiteName              : L"(null)"));
      LOG(String::format(L"ClientSiteName          : %1",       info->ClientSiteName          ? info->ClientSiteName          : L"(null)"));
   }
#endif

   return hr;
}



bool
IsDcpromoRunning()
{
   LOG_FUNCTION(IsDcpromoRunning);

   bool result = false;

   // If we can open the mutex created by dcpromo, then dcpromo is running,
   // as it created that mutex.
   // see admin\dcpromo\exe\dcpromo.cpp

   HANDLE mutex = ::OpenMutex(SYNCHRONIZE, FALSE, L"Global\\dcpromoui");
   if (mutex)
   {
      result = true;
      Win::CloseHandle(mutex);
   }

   LOG(String::format(L"Dcpromo %1 running", result ? L"is" : L"is not"));

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\error.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// abstract base class to encapsulate error information
//
// 8-14-97 sburns



#include "headers.hxx"



// Error::Details::Details(
//    const String&  body,
//    const String&  fileName,
//    unsigned       lineNumber)
//    :
//    body_(body),
//    file(fileName),
//    line(lineNumber)
// {
// }
// 


// due to an oddity of C++, this must be defined although it is
// pure virtual.  What a langauge!

Error::~Error()
{
}



// String
// Error::Details::GetBody() const
// {
//    return body_;
// }
// 
// 
// 
// String
// Error::Details::GetFileName() const
// {
//    return file;
// }
// 
// 
// 
// unsigned
// Error::Details::GetLineNumber() const
// {
//    return line;
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\encryptedstring.cpp ===
// Copyright (c) 2002 Microsoft Corporation
// 
// Encrypted string class
// 
// 18 March 2002 



#include <headers.hxx>
#include <strsafe.h>



static const size_t CRYPTPROTECTMEMORY_BLOCK_SIZE_IN_CHARS =
   CRYPTPROTECTMEMORY_BLOCK_SIZE / sizeof WCHAR;
   
static WCHAR EMPTY_STRING[CRYPTPROTECTMEMORY_BLOCK_SIZE_IN_CHARS] = {0};


   
EncryptedString::EncryptedString()
   :
   clearTextLength(0),
   cleartextCopyCount(0),
   cypherText(EMPTY_STRING),
   isEncrypted(false)
{
   ASSERT(cypherText);

   // make sure that our assumption about the block size being a multiple
   // of of sizeof WCHAR still holds.  I wonder how I could formulate this
   // as a compile-time check?
   
   ASSERT(CRYPTPROTECTMEMORY_BLOCK_SIZE % sizeof WCHAR == 0);
}



// rounds x up to the next multiple of factor.

size_t
roundup(size_t x, size_t factor)
{
   ASSERT(x);
   
   return ((x + factor - 1) / factor) * factor;
}



// Allocates and zero-inits a buffer.  The length is the next multiple of
// the crypto block size larger than charLength characters.
//
// caller must free the result with delete[]
//
// charLength - the length, in characters of the buffer that will be copied
// into the buffer to be allocated.
// 
// resultCharCount - the count of the characters actually allocated.

WCHAR*
CreateRoundedBuffer(size_t charLength, size_t& resultCharCount)
{
   resultCharCount =
      roundup(
         charLength + 1,
         CRYPTPROTECTMEMORY_BLOCK_SIZE_IN_CHARS);
         
   ASSERT(
         ((resultCharCount * sizeof WCHAR)
      %  CRYPTPROTECTMEMORY_BLOCK_SIZE) == 0);
         
   WCHAR* result = new WCHAR[resultCharCount];
   ::ZeroMemory(result, resultCharCount * sizeof WCHAR);
   
   return result;
}



// causes this to become a copy of the given instance.

void
EncryptedString::Clone(const EncryptedString& rhs)
{
   do
   {
      if (rhs.cypherText == EMPTY_STRING)
      {
         cypherText      = EMPTY_STRING;
         clearTextLength = 0;           
         isEncrypted     = false;
         break;
      }

      if (!rhs.isEncrypted)
      {
         Init(rhs.cypherText);
         break;
      }

      size_t bufSizeInChars = 0;
      cypherText = CreateRoundedBuffer(rhs.clearTextLength, bufSizeInChars);
      ::CopyMemory(
         cypherText,
         rhs.cypherText,
         bufSizeInChars * sizeof WCHAR);   

      clearTextLength = rhs.clearTextLength;
      
      isEncrypted = rhs.isEncrypted;
      ASSERT(isEncrypted);
   }
   while (0);

   ASSERT(cypherText);
}

   

EncryptedString::EncryptedString(const EncryptedString& rhs)
   :
   // although the rhs instance may have outstanding copies, we don't.
   
   cleartextCopyCount(0)
{
   Clone(rhs);
}


   
const EncryptedString&
EncryptedString::operator= (const EncryptedString& rhs)
{
   // don't reset the instance unless you have destroyed all the cleartext
   // copies. We assert this before checking for a=a, because the caller
   // still has a logic error even if the result is "harmless"
   
   ASSERT(cleartextCopyCount == 0);

   // handle the a = a case.
   
   if (this == &rhs)
   {
      return *this;
   }

   Reset();
   Clone(rhs);
   
   return *this;
}



// cause this to assume the empty state.

void
EncryptedString::Reset()
{
   // don't reset the instance unless you have destroyed all the cleartext
   // copies.
   
   ASSERT(cleartextCopyCount == 0);

   if (cypherText != EMPTY_STRING)
   {
      delete[] cypherText;
   }

   cypherText      = EMPTY_STRING;
   clearTextLength = 0;           
   isEncrypted     = false;       
}



// builds the internal encrypted representation from the cleartext.
//
// clearText - in, un-encoded text to be encoded.  May be empty string, but
// not a null pointer.

void
EncryptedString::Init(const WCHAR* clearText)
{
   ASSERT(clearText);

   // don't reset the instance unless you have destroyed all the cleartext
   // copies.

   ASSERT(cleartextCopyCount == 0);

   Reset();

   do
   {
      if (clearText == EMPTY_STRING)
      {
         // nothing to do

         ASSERT(cypherText == EMPTY_STRING);

         break;
      }

      if (!clearText)
      {
         // nothing to do

         ASSERT(cypherText == EMPTY_STRING);

         break;
      }
      
      // make a copy of the clear text, and then encrypt it.
      
      cypherText      = 0;
      clearTextLength = 0;

      HRESULT hr =
         StringCchLength(
            clearText,

            // max allowed, including null terminator (so +1)
            
            MAX_CHARACTER_COUNT + 1,
            &clearTextLength);
      if (FAILED(hr))
      {
         // caller needs to know he's exceeded the max string size.
            
         ASSERT(false);
         
         // the string is too long. Make a truncated copy, and encrypt that
         // instead.

         clearTextLength = MAX_CHARACTER_COUNT;
      }

      if (clearTextLength == 0)
      {
         cypherText      = EMPTY_STRING;
         isEncrypted     = false;
         break;
      }
         
      size_t bufSizeInChars = 0;
      cypherText = CreateRoundedBuffer(clearTextLength, bufSizeInChars);
      ::CopyMemory(
         cypherText,
         clearText,
         clearTextLength * sizeof WCHAR);
 
      hr = Win::CryptProtectMemory(cypherText, bufSizeInChars * sizeof WCHAR);
      if (FAILED(hr))
      {
         // I can't think of any reason this would fail in the normal
         // course of things, so I'd like to know about it.
         
         ASSERT(false);

         isEncrypted = false;
      }
      else
      {
         isEncrypted = true;
      }
   }
   while (0);

   ASSERT(cypherText);
   ASSERT(cleartextCopyCount == 0);
}



// decrypts the blob and returns a copy of the cleartext, but does not
// bump up the outstanding copy counter.  Result must be freed with
// delete[].
//
// May return 0.
//
// Used internally to prevent infinite mutual recursion 

WCHAR*
EncryptedString::InternalDecrypt() const
{
   size_t bufSizeInChars = 0;
   WCHAR* result = CreateRoundedBuffer(clearTextLength, bufSizeInChars);
   ::CopyMemory(result, cypherText, bufSizeInChars * sizeof WCHAR);   

   if (isEncrypted)
   {   
      HRESULT hr = Win::CryptUnprotectMemory(result, bufSizeInChars * sizeof WCHAR);
      if (FAILED(hr))
      {
         ASSERT(false);

         // this situation is very bad. We can't just return an empty string
         // to the caller, since that might represent a password to be
         // set -- which would result in a null password. The only correct
         // thing to do is bail out.

         delete[] result;
         result = 0;
         
         throw DecryptionFailureException();
      }
   }

   return result;
}



WCHAR* 
EncryptedString::GetClearTextCopy() const
{
   // Even if we fail the decryption, we bump the count so that it's easy for
   // the caller to always balance GetClearTextCopy with DestroyClearTextCopy

   WCHAR* result = InternalDecrypt();   
   ++cleartextCopyCount;
   
   return result;
}



void
EncryptedString::Encrypt(const WCHAR* clearText)
{
   ASSERT(clearText);
   
   // don't reset the instance unless you have destroyed all the cleartext
   // copies.

   ASSERT(cleartextCopyCount == 0);
   
   Init(clearText);
}



bool
EncryptedString::operator==(const EncryptedString& rhs) const
{
   // handle the a == a case
   
   if (this == &rhs)
   {
      return true;
   }

   if (GetLength() != rhs.GetLength())
   {
      // can't be the same if lengths differ...
      
      return false;
   }
   
   // Two strings are the same if their decoded contents are the same.
   
   WCHAR* clearTextThis = GetClearTextCopy();
   WCHAR* clearTextThat = rhs.GetClearTextCopy();

   bool result = false;
   if (clearTextThis && clearTextThat)
   {
      result = (wcscmp(clearTextThis, clearTextThat) == 0);
   }

   DestroyClearTextCopy(clearTextThis);
   rhs.DestroyClearTextCopy(clearTextThat);
   
   return result;
}



size_t
EncryptedString::GetLength() const
{

#ifdef DBG    
   // we don't use GetClearTextCopy, that may result in infinite recursion
   // since this function is called internally.
   
   WCHAR* clearTextThis = InternalDecrypt(); 

   size_t len = 0;
   if (clearTextThis)
   {
      HRESULT hr =
         StringCchLength(
            clearTextThis,
            MAX_CHARACTER_COUNT * sizeof WCHAR,
            &len);
      if (FAILED(hr))
      {
         // we should be guaranteeing that the result of GetClearTextCopy
         // is always null-terminated, so a failure here represents a bug
         // in our implementation.
         
         ASSERT(false);
         len = 0;
      }
   }
   InternalDestroy(clearTextThis);

   ASSERT(len == clearTextLength);
#endif    

   return clearTextLength;
}



// destroys a clear text copy without changing the outstanding copies count.

void
EncryptedString::InternalDestroy(WCHAR* cleartext) const
{   
   if (cleartext)
   {
      ::SecureZeroMemory(cleartext, clearTextLength * sizeof WCHAR);
      delete[] cleartext;
   }
}



void
EncryptedString::DestroyClearTextCopy(WCHAR* cleartext) const
{
   // we expect that cleartext is usually non-null.  It may not be, if
   // GetClearTextCopy failed, however.
   // ASSERT(cleartext);
   
   // we should have some outstanding copies. If not, then the caller has
   // called DestroyClearTextCopy more times than he called GetClearTextCopy,
   // and therefore has a bug.
   
   ASSERT(cleartextCopyCount);

   InternalDestroy(cleartext);

   --cleartextCopyCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\extract.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// class Extractor
// 
// 11-12-97 sburns



#include "headers.hxx"



Extractor::Extractor(CLIPFORMAT clipFormatID, size_t bufSize_)
   :
   formatetc(),
   stgmedium(),
   bufSize(bufSize_)
{
   ASSERT(clipFormatID);
   ASSERT(bufSize);

   formatetc.cfFormat = clipFormatID;
   formatetc.ptd = 0;
   formatetc.dwAspect = DVASPECT_CONTENT;
   formatetc.lindex = -1;
   formatetc.tymed = TYMED_HGLOBAL;

   stgmedium.tymed = TYMED_HGLOBAL;
   HRESULT hr = Win::GlobalAlloc(GPTR, bufSize, stgmedium.hGlobal);

   ASSERT(SUCCEEDED(hr));
}



Extractor::~Extractor()
{
   if (stgmedium.hGlobal)
   {
      Win::GlobalFree(stgmedium.hGlobal);
   }
}



HGLOBAL
Extractor::ExtractData(IDataObject& dataObject)
{
   HGLOBAL result = 0;
   do
   {
      if (!stgmedium.hGlobal)
      {
         break;
      }

      // clear out any prior contents of the memory.  We don't need to call
      // GlobalLock because the memory was allocated as fixed.

      // REVIEWED-2002/03/05-sburns correct byte count passed (see ctor)
      
      ::ZeroMemory(reinterpret_cast<void*>(stgmedium.hGlobal), bufSize);
      
      HRESULT hr = dataObject.GetDataHere(&formatetc, &stgmedium);
      BREAK_ON_FAILED_HRESULT(hr);
      result = stgmedium.hGlobal;
   }
   while (0);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\richeditstreamer.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Rich Edit streaming helper 
//
// 28 Sep 2001 sburns



#include "RichEditStreamer.hpp"



HRESULT
RichEditStreamer::ErrorResult()
{
   // we use the dwError field to hold HRESULTs
   
   return editStream.dwError;
}



int
RichEditStreamer::StreamIn(DWORD formatOptions) // TEXT | SF_UNICODE)
{
   ASSERT(formatOptions);

   editStream.dwError = 0;         
   bytesCopiedSoFar   = 0;         
   direction          = TO_CONTROL;
   int result = Win::RichEdit_StreamIn(richEdit, formatOptions, editStream);
   ASSERT(SUCCEEDED(ErrorResult()));
   
   return result;
}



//    int
//    StreamOut(DWORD formatOptions = SF_RTF | SF_UNICODE)
//    {
//       ASSERT(formatOptions);
// 
//       editStream.dwError = 0;           
//       bytesCopiedSoFar   = 0;           
//       direction          = FROM_CONTROL;
//       int result = Win::RichEdit_StreamOut(richEdit, formatOptions, editStream);
//       ASSERT(SUCCEEDED(ErrorResult()));
// 
//       return result;
//    }



RichEditStreamer::RichEditStreamer(HWND richEdit_)
   :
   richEdit(richEdit_)
{
   ASSERT(Win::IsWindow(richEdit));
   
   ::#_#_ZeroMemory(&editStream, sizeof(editStream));
   editStream.dwCookie    = reinterpret_cast<DWORD_PTR>(this);     
   editStream.pfnCallback = RichEditStreamer::StaticStreamCallback;
}



~RichEditStreamer()
{
}



HRESULT
RichEditStreamer::StreamCallbackHelper(
   PBYTE     buffer,
   LONG      bytesToTransfer,
   LONG*     bytesTransferred)
{
   HRESULT hr = StreamCallback(buffer, bytesToTransfer, bytesTransferred);
   bytesCopiedSoFar += *bytesTransferred;
   return hr;
}



DWORD CALLBACK
RichEditStreamer::StaticStreamCallback(
   DWORD_PTR cookie,
   PBYTE     buffer,
   LONG      bytesToTransfer,
   LONG*     bytesTransferred)
{
   // the cookie is a this pointer to an instance of RichEditStreamer

   HRESULT hr = E_INVALIDARG;
   ASSERT(cookie);
   ASSERT(buffer);
   ASSERT(bytesToTransfer);
   ASSERT(bytesTransferred);
   
   if (cookie && buffer && bytesToTransfer && bytesTransferred)
   {
      RichEditStreamer* that = reinterpret_cast<RichEditStreamer*>(cookie);
      hr = that->StreamCallbackHelper(buffer, bytesToTransfer, bytesTransferred);
   }

   // HRESULT and DWORD differ by sign 
   return static_cast<DWORD>(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\proppage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Property Page base class class
// 
// 9-9-97 sburns



#include "headers.hxx"



PropertyPage::PropertyPage(
   unsigned    dialogResID,
   const DWORD helpMap_[],
   bool        deleteOnRelease_)
   :
   Dialog(dialogResID, helpMap_),
   deleteOnRelease(deleteOnRelease_)
{
//   LOG_CTOR(PropertyPage);
}



PropertyPage::~PropertyPage()
{
//   LOG_DTOR(PropertyPage);
}



UINT CALLBACK 
PropertyPage::PropSheetPageCallback(
   HWND           /* hwnd */ ,
   UINT           uMsg,
   PROPSHEETPAGE* page)
{
   if (uMsg == PSPCB_RELEASE)
   {
      // deletes the PropertyPage instance if it was created with the
      // appropriate flag
      PropertyPage* p = reinterpret_cast<PropertyPage*>(page->lParam);
      if (p)
      {
         if (p->deleteOnRelease)
         {
            delete p;
         }
      }
   }

   return TRUE;
}



HPROPSHEETPAGE
PropertyPage::Create()
{
   LOG_FUNCTION(PropertyPage::Create);

   PROPSHEETPAGE page;
   
   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&page, sizeof page);
      
   page.dwSize       = sizeof(page);
   page.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK;
   page.hInstance    = GetResourceModuleHandle();
   page.pszTemplate  = reinterpret_cast<PCTSTR>(MAKEINTRESOURCEW(GetResID()));
   page.pfnDlgProc   = PropertyPage::propPageDialogProc;
   page.pfnCallback  = PropertyPage::PropSheetPageCallback;

   // this pointer is retrieved by the dialog proc 
   page.lParam       = reinterpret_cast<LPARAM>(this);

   HPROPSHEETPAGE result = 0;
   HRESULT hr = Win::CreatePropertySheetPage(page, result);
   ASSERT(SUCCEEDED(hr));

   return result;
}



bool
PropertyPage::OnApply(bool /* isClosing */ )
{
   // LOG_FUNCTION2(
   //    PropertyPage::OnApply,
   //    isClosing ? L"closing" : L"not closing");

   return false;
}



bool
PropertyPage::OnHelp()
{
   LOG_FUNCTION(PropertyPage::OnHelp);

   return false;
}



bool
PropertyPage::OnKillActive()
{
//   LOG_FUNCTION(PropertyPage::OnKillActive);

   return false;
}



bool
PropertyPage::OnSetActive()
{
//   LOG_FUNCTION(PropertyPage::OnSetActive);

   return false;
}



bool
PropertyPage::OnQueryCancel()
{
//   LOG_FUNCTION(PropertyPage::OnQueryCancel);

   return false;
}



bool
PropertyPage::OnReset()
{
//   LOG_FUNCTION(PropertyPage::OnReset);

   return false;
}



bool
PropertyPage::OnWizBack()
{
//   LOG_FUNCTION(PropertyPage::OnWizBack);

   return false;
}



bool
PropertyPage::OnWizNext()
{
//   LOG_FUNCTION(PropertyPage::OnWizNext);

   return false;
}



bool
PropertyPage::OnWizFinish()
{
//   LOG_FUNCTION(PropertyPage::OnWizFinish);

   return false;
}



// bool
// PropertyPage::OnHelp(const HELPINFO& helpinfo)
// {
//    LOG_FUNCTION(PropertyPage::OnHelp);
// 
//    return false;
// }



PropertyPage*
PropertyPage::getPage(HWND pageDialog)
{
//    LOG_FUNCTION(getPage);
   ASSERT(Win::IsWindow(pageDialog));

   Dialog* result = Dialog::GetInstance(pageDialog);

   // don't assert ptr, it may not have been set.  Some messages are
   // sent before WM_INITDIALOG, which is the earliest we can set the
   // pointer.
   //
   // for example, the LinkWindow control sends NM_CUSTOMDRAW before
   // WM_INITDIALOG

   return dynamic_cast<PropertyPage*>(result);
}


      
INT_PTR APIENTRY
PropertyPage::propPageDialogProc(
   HWND     dialog,
   UINT     message,
   WPARAM   wparam,
   LPARAM   lparam)
{
   switch (message)
   {
      case WM_INITDIALOG:
      {
         // a pointer to the PropertyPage is in the lparam of the page struct,
         // which is in the lparam to this function.  Save this in the window
         // structure so that it can later be retrieved by getPage.

         ASSERT(lparam);
         PROPSHEETPAGE* psp = reinterpret_cast<PROPSHEETPAGE*>(lparam);
         ASSERT(psp);

         if (psp)
         {
            Win::SetWindowLongPtr(dialog, DWLP_USER, psp->lParam);
            Win::SetWindowLongPtr(dialog, GWLP_ID, (LONG_PTR) psp->pszTemplate);

            PropertyPage* page = getPage(dialog);
            if (page)      // 447770 prefix warning
            {
               page->SetHWND(dialog);
               page->OnInit();
            }
         }
   
         return TRUE;
      }
      case WM_NOTIFY:
      {
         NMHDR* nmhdr = reinterpret_cast<NMHDR*>(lparam);
         PropertyPage* page = getPage(dialog);

         if (page)
         {
            ASSERT(page->hwnd == dialog);
            bool result = false;

            // LOG(String::format(L"%1!x!", nmhdr->code));
            
            switch (nmhdr->code)
            {
               case PSN_APPLY:
               {
                  PSHNOTIFY* pshn = reinterpret_cast<PSHNOTIFY*>(nmhdr);
                  result = page->OnApply(pshn->lParam ? true : false);
                  break;
               }
               case PSN_KILLACTIVE:
               {
                  result = page->OnKillActive();
                  break;
               }
               case PSN_QUERYCANCEL:
               {
                  result= page->OnQueryCancel();
                  break;
               }
               case PSN_RESET:
               {
                  result = page->OnReset();
                  break;
               }
               case PSN_SETACTIVE:
               {
                  result = page->OnSetActive();
                  break;
               }
               case PSN_WIZBACK:
               {
                  result = page->OnWizBack();
                  break;
               }
               case PSN_WIZNEXT:
               {
                  result = page->OnWizNext();
                  break;
               }
               case PSN_WIZFINISH:
               {
                  result = page->OnWizFinish();

                  // DONT DO THIS!!! - the result is just there to mean that we have
                  //                   handled the message.  It does reveal whether or
                  //                   not the OnWizFinish was successful.  The
                  //                   the handler of OnWizFinish should call
                  //                   SetWindowLongPtr to set its result value

                  //Win::SetWindowLongPtr(dialog, DWLP_MSGRESULT, result ? TRUE : FALSE);
                  break;
               }
               case PSN_HELP:
               {
                  result = page->OnHelp();
                  break;
               }
               case PSN_QUERYINITIALFOCUS:
               case PSN_TRANSLATEACCELERATOR:
               default:
               {
                  result = 
                     page->OnNotify(
                        nmhdr->hwndFrom,
                        nmhdr->idFrom,
                        nmhdr->code,
                        lparam);
                  break;
               }
            }

            return result ? TRUE : FALSE;
         }

         return FALSE;
      }
      default:
      {
         return dialogProc(dialog, message, wparam, lparam);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\netutil.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Net utility functions
//
// 11-4-1999 sburns



#include "headers.hxx"



HRESULT
MyNetWkstaGetInfo(const String& serverName, WKSTA_INFO_100*& info)
{
   LOG_FUNCTION2(MyNetWkstaGetInfo, serverName);

   info = 0;   

   LOG(L"Calling NetWkstaGetInfo");

   PWSTR server =
         serverName.empty()
      ?  0
      :  const_cast<PWSTR>(serverName.c_str());

   BYTE* buf = 0;
   HRESULT hr =
      Win32ToHresult(       
         ::NetWkstaGetInfo(
            server,
            100,
            &buf));

   LOG_HRESULT(hr);

   if (SUCCEEDED(hr))
   {
      info = reinterpret_cast<WKSTA_INFO_100*>(buf);
   }

   return hr;
}



HRESULT
MyNetValidateName(
   const String&        name,
   NETSETUP_NAME_TYPE   nameType)
{
   LOG_FUNCTION(MyNetValidateName);
   ASSERT(!name.empty());

   if (!name.empty())
   {

#ifdef LOGGING_BUILD

      String typedesc;
      switch (nameType)
      {
         case NetSetupDomain:
         {
            typedesc = L"NetSetupDomain";
            break;
         }
         case NetSetupWorkgroup:
         {
            typedesc = L"NetSetupWorkgroup";
            break;
         }
         case NetSetupMachine:
         {
            typedesc = L"NetSetupMachine";
            break;
         }
         case NetSetupNonExistentDomain:
         {
            typedesc = L"NetSetupNonExistentDomain";
            break;
         }
         case NetSetupDnsMachine:
         {
            typedesc = L"NetSetupDnsMachine";
            break;
         }
         case NetSetupUnknown:
         {
            typedesc = L"NetSetupUnknown";
            break;
         }
         default:
         {
            typedesc = L"** unknown **";
            break;
         }
      }

      LOG(L"Calling NetValidateName");
      LOG(               L"lpServer   : (null)");
      LOG(String::format(L"lpName     : %1", name.c_str()));
      LOG(               L"lpAccount  : (null)");
      LOG(               L"lpPassword : (null)");
      LOG(String::format(L"NameType   : %1", typedesc.c_str()));
#endif

      HRESULT hr =
         Win32ToHresult(
            ::NetValidateName(
               0,
               name.c_str(),
               0,
               0,
               nameType));

      LOG_HRESULT(hr);

      // remap the error code to more meaningful ones depending on the
      // context in which the call was made

      if (FAILED(hr))
      {
         // 382695

         if (
               nameType == NetSetupDomain
            && hr == Win32ToHresult(ERROR_INVALID_NAME) )
         {
            LOG(L"mapping ERROR_INVALID_NAME to ERROR_INVALID_DOMAINNAME");

            hr = Win32ToHresult(ERROR_INVALID_DOMAINNAME);
         }
      }
         
      return hr;
   }

   return Win32ToHresult(ERROR_INVALID_PARAMETER);
}



HRESULT
MyNetJoinDomain(
   const String&          domain,  
   const String&          username,
   const EncryptedString& password,
   ULONG                  flags)
{
   LOG_FUNCTION2(MyNetJoinDomain, domain);
   ASSERT(!domain.empty());

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0 : server.c_str();  
   PCWSTR u = username.empty() ? 0 : username.c_str();

   LOG(L"Calling NetJoinDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpDomain         : %1", domain.c_str()));
   LOG(               L"lpAccountOU      : (null)");
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fJoinOptions : 0x%1!X!", flags));

   PWSTR p = 0;
   if (u)
   {
      p = password.GetClearTextCopy();
   }
   
   HRESULT hr =
      Win32ToHresult(
         ::NetJoinDomain(
            s,
            domain.c_str(),
            0, // default OU
            u,
            p,
            flags));

   if (u)
   {
      password.DestroyClearTextCopy(p);
   }
   
   LOG_HRESULT(hr);

   return hr;
}



bool
IsNetworkingInstalled()
{
   LOG_FUNCTION(IsNetworkingInstalled);

   // We test to see if the workstation service is running.  An alternative is
   // to check
   // HLKM\System\CurrentControlSet\Control\NetworkProvider\Order\ProviderOrder
   // registry value to see that it is not empty.
   // see net\config\common\ncbase\ncmisc.cpp

   NTService wks(L"LanmanWorkstation");
   DWORD state = 0;
   HRESULT hr = wks.GetCurrentState(state);

   bool result = false;
   if (SUCCEEDED(hr))
   {
      result = (state == SERVICE_RUNNING);
   }

   LOG(
      String::format(
         L"workstation service %1 running",
         result ? L"is" : L"is NOT"));

   return result;
}



bool
IsTcpIpInstalled()
{
   LOG_FUNCTION(IsTcpIpInstalled);

   HKEY    key    = 0;    
   HRESULT hr     = S_OK; 
   bool    result = false;

   do
   {
      hr = 
         Win::RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Services\\Tcpip\\Linkage",
            KEY_QUERY_VALUE,
            key);
      BREAK_ON_FAILED_HRESULT(hr);

      DWORD dataSize = 0;
      hr =

         // REVIEWED-2002/03/05-sburns no null termination issue here
         
         Win::RegQueryValueEx(
            key,
            L"Export",
            0,
            0,
            &dataSize);
      BREAK_ON_FAILED_HRESULT(hr);

      if (dataSize > 2)
      {
         // the value is non-null

         result = true;
      }
   }
   while (0);

   if (key)
   {
      hr = Win::RegCloseKey(key);
   }

   LOG(String::format(L"TCP/IP %1 detected", result ? L"is" : L"is not"));

   return result;
}



HRESULT
MyNetRenameMachineInDomain(
   const String&          newNetbiosName,
   const String&          username,      
   const EncryptedString& password,      
   DWORD                  flags)
{
   LOG_FUNCTION(MyNetRenameMachineInDomain);
   ASSERT(!newNetbiosName.empty());

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0                : server.c_str();  
   PCWSTR u = username.empty() ? 0                : username.c_str();

   LOG(L"Calling NetRenameMachineInDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpNewMachineName : %1", newNetbiosName.c_str()));
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fRenameOptions   : 0x%1!X!", flags));

   PWSTR p = 0;
   if (u)
   {
      p = password.GetClearTextCopy();
   }

   HRESULT hr =
      Win32ToHresult(
         ::NetRenameMachineInDomain(
            s,
            newNetbiosName.c_str(),
            u,
            p,
            flags));

   if (u)
   {
      password.DestroyClearTextCopy(p);
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
MyNetUnjoinDomain(
   const String&          username,
   const EncryptedString& password,
   DWORD                  flags)
{
   LOG_FUNCTION(MyNetUnjoinDomain);

   // currently no need to support remote operation, but if that becomes
   // the case in the future, just make this local a parameter instead.

   String server;

   PCWSTR s = server.empty()   ? 0 : server.c_str();  
   PCWSTR u = username.empty() ? 0 : username.c_str();

   LOG(L"Calling NetUnjoinDomain");
   LOG(String::format(L"lpServer         : %1", s ? s : L"(null)"));
   LOG(String::format(L"lpAccount        : %1", u ? u : L"(null)"));
   LOG(String::format(L"fUnjoinOptions   : 0x%1!X!", flags));

   PWSTR p = 0;
   if (u)
   {
      p = password.GetClearTextCopy();
   }

   HRESULT hr = Win32ToHresult(::NetUnjoinDomain(s, u, p, flags));

   if (u)
   {
      password.DestroyClearTextCopy(p);
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\popup.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Popup message box class
// 
// 8-31-98 sburns



#include "headers.hxx"



Popup::Popup(UINT titleStringResID, bool systemModal_)
   :
   initialized(false),
   systemModal(systemModal_),
   title(),
   titleResId(titleStringResID)
{
   LOG_CTOR(Popup);

   ASSERT(titleResId);
}



Popup::Popup(const String& title_, bool systemModal_)
   :
   initialized(true),
   systemModal(systemModal_),
   title(title_),
   titleResId(0)
{
   LOG_CTOR(Popup);   
}



void
Popup::Gripe(HWND parentDialog, int editResID, UINT errStringResID) const
{
   Gripe(parentDialog, editResID, String::load(errStringResID));
}



void
Popup::checkInit() const
{
   if (!initialized)
   {
      ASSERT(titleResId);

      title = Win::LoadString(titleResId);
      if (!title.empty())
      {
         initialized = true;
      }
   }
}



void
Popup::Info(
   HWND parentDialog,      
   UINT messageStringResID) const
{
   ASSERT(messageStringResID);

   Info(parentDialog, String::load(messageStringResID));
}


   
void
Popup::Info(
   HWND           parentDialog,
   const String&  message) const
{
   LOG_FUNCTION(Popup::Info);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
         MB_OK
      |  MB_ICONINFORMATION
      |  getStyleMask());
}



void
Popup::Gripe(
   HWND           parentDialog,
   int            editResID,
   const String&  message) const
{
   LOG_FUNCTION(Popup::Gripe);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());
   ASSERT(editResID);

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
      MB_OK | MB_ICONERROR | getStyleMask());

   HWND edit = Win::GetDlgItem(parentDialog, editResID);
   Win::SendMessage(edit, EM_SETSEL, 0, -1);

   // @@ should this really be a WM_NEXTDLGCTL?
   
   Win::SetFocus(edit);
}



void
Popup::Gripe(
   HWND           parentDialog,
   const String&  message) const
{
   LOG_FUNCTION(Popup::Gripe);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
      MB_OK | MB_ICONERROR | getStyleMask());
}



void
Popup::Gripe(
   HWND           parentDialog,
   int            editResID,
   HRESULT        hr,
   const String&  message) const
{
   Error(parentDialog, hr, message);

   HWND edit = Win::GetDlgItem(parentDialog, editResID);
   Win::SendMessage(edit, EM_SETSEL, 0, -1);
   Win::SetFocus(edit);
}



void
Popup::Error(
   HWND           parent,
   HRESULT        hr,
   const String&  message) const
{
   LOG_FUNCTION(Popup::Error);
   ASSERT(Win::IsWindow(parent));
   ASSERT(!message.empty());

   checkInit();

   String newMessage = message + L"\n\n";
   if (FAILED(hr))
   {
      String errorMessage = GetErrorMessage(hr);
      if (errorMessage.empty())
      {
         // these are error codes for which there are no descriptions

         newMessage += String::format(IDS_HRESULT_SANS_MESSAGE, hr);
      }
      else
      {
         newMessage += errorMessage;
      }
   }

   Win::MessageBox(
      parent,
      newMessage,
      title,
      MB_ICONERROR | MB_OK | getStyleMask());
}



void
Popup::Error(
   HWND    parent,      
   HRESULT hr,          
   UINT    messageResID) const
{
   Error(parent, hr, String::load(messageResID));
}



void
Popup::Error(
   HWND parentDialog,      
   UINT messageStringResID) const
{
   Error(parentDialog, String::load(messageStringResID));
}



void
Popup::Error(
   HWND           parentDialog,
   const String&  message) const
{
   LOG_FUNCTION(Popup::Error);
   ASSERT(Win::IsWindow(parentDialog));   
   ASSERT(!message.empty());

   checkInit();

   Win::MessageBox(
      parentDialog,
      message,
      title,
         MB_OK
      |  MB_ICONERROR
      |  getStyleMask());
}



int
Popup::MessageBox(
   HWND           parentDialog,
   const String&  message,
   UINT           flags) const
{
   LOG_FUNCTION(Popup::MessageBox);
   ASSERT(!message.empty());

   // can't assert flags 'cause MB_OK is 0

   checkInit();

   return
      Win::MessageBox(
         parentDialog,
         message,
         title,
         flags | getStyleMask());
}



int
Popup::MessageBox(
   HWND parentDialog,      
   UINT messageStringResID,
   UINT flags) const
{
   return MessageBox(parentDialog, String::load(messageStringResID), flags);
}
   


UINT
Popup::getStyleMask() const
{
   UINT mask = 0;
   if (systemModal)
   {
      mask |= MB_SETFOREGROUND | MB_SYSTEMMODAL;
   }
   else
   {
      mask |= MB_APPLMODAL;
   }

   return mask;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\registry.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// System Registry Class
//
// 7-9-98 sburns



#include "headers.hxx"



RegistryKey::RegistryKey()
   :
   key(0)
{
   LOG_CTOR(RegistryKey);
}



RegistryKey::~RegistryKey()
{
   LOG_DTOR(RegistryKey);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
      key = 0;
   }
}



HRESULT
RegistryKey::Close()
{
   HRESULT hr = Win::RegCloseKey(key);
   key = 0;

   return hr;
}



HRESULT
RegistryKey::Create(
   HKEY                 parentKey,
   const String&        subkeyName,
   DWORD                options,
   REGSAM               desiredAccess,
   SECURITY_ATTRIBUTES* securityAttrs,
   DWORD*               disposition)
{
   LOG_FUNCTION2(RegistryKey::Create, subkeyName);
   ASSERT(parentKey);
   ASSERT(!subkeyName.empty());
   ASSERT(desiredAccess);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
   }

   return
      Win::RegCreateKeyEx(
         parentKey,
         subkeyName,
         options,
         desiredAccess,
         securityAttrs,
         key,
         disposition);
}



HRESULT
RegistryKey::Open(
   HKEY           parentKey,
   const String&  subkeyName,
   REGSAM         desiredAccess)
{
   LOG_FUNCTION2(RegistryKey::Open, subkeyName);
   ASSERT(parentKey);
   ASSERT(!subkeyName.empty());
   ASSERT(desiredAccess);

   if (key)
   {
      HRESULT hr = Close();
      ASSERT(SUCCEEDED(hr));
   }

   return Win::RegOpenKeyEx(parentKey, subkeyName, desiredAccess, key);
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   DWORD&         value)
{
   LOG_FUNCTION2(RegistryKey::GetValue-DWORD, valueName);

   // Do not assert that the valueName is not empty because
   // an empty value means the default value for that key
   // ASSERT(!valueName.empty());

   ASSERT(key);

   value = 0;
   DWORD dataSize = sizeof(DWORD);
   DWORD type = 0;

   HRESULT hr =

      // REVIEWED-2002/03/05-sburns no null termination issue here
      
      Win::RegQueryValueEx(
         key,
         valueName,
         &type,
         reinterpret_cast<BYTE*>(&value),
         &dataSize);

   if (SUCCEEDED(hr))
   {
      if (
            type != REG_DWORD
         && type != REG_DWORD_LITTLE_ENDIAN
         && type != REG_DWORD_BIG_ENDIAN)
      {
         // wrong type
         hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
      }
   }

   return hr;
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   String&        value,
   bool&          isExpandSz)
{
   LOG_FUNCTION2(RegistryKey::GetValue-String, valueName);
   ASSERT(!valueName.empty());
   ASSERT(key);

   value.erase();
   isExpandSz = false;

   DWORD type = 0;
   DWORD size = 0;

   // REVIEWED-2002/03/05-sburns no null termination issue here
   
   HRESULT hr = Win::RegQueryValueEx(key, valueName, &type, 0, &size);
   if (SUCCEEDED(hr))
   {
      if (type == REG_SZ || type == REG_EXPAND_SZ)
      {
         // now that we know the size, read the contents
         // +2 to guarantee null termination
         
         BYTE* buf = new BYTE[size + 2];   // a bitesized buffer!  Ha Ha!

         // REVIEWED-2002/03/05-sburns correct byte count passed
         
         ::ZeroMemory(buf, size + 2);

         type = 0;

         // REVIEWED-2002/03/05-sburns null termination guaranteed by our
         // oversized buffer
         
         hr = Win::RegQueryValueEx(key, valueName, &type, buf, &size);
         if (SUCCEEDED(hr))
         {
            value = reinterpret_cast<wchar_t*>(buf);
            isExpandSz = (type == REG_EXPAND_SZ);
         }
         delete[] buf;
      }
      else
      {
         // caller requested a string from a non-string key

         hr = Win32ToHresult(ERROR_INVALID_FUNCTION);
      }
   }

   return hr;
}



HRESULT
RegistryKey::GetValue(
   const String&  valueName,
   String&        value)
{
   bool unused = false;
   return GetValue(valueName, value, unused);
}



HRESULT
RegistryKey::SetValue(
   const String&  valueName,
   DWORD          value)
{
   LOG_FUNCTION2(RegistryKey::SetValue-DWORD, valueName);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   return

      // REVIEWED-2002/03/05-sburns no null termination issue here
      
      Win::RegSetValueEx(
         key,
         valueName,
         REG_DWORD,
         reinterpret_cast<BYTE*>(&value),
         sizeof(DWORD));
}



HRESULT
RegistryKey::SetValue(
   const String&  valueName,
   const String&  value,
   bool           expand)
{
   LOG_FUNCTION2(
      RegistryKey::SetValue-String,
      valueName + L"=" + value);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   BYTE* dataPtr =
      reinterpret_cast<BYTE*>(const_cast<wchar_t*>(value.c_str()));

   // add 1 to include null terminator
      
   DWORD bytes = static_cast<DWORD>((value.length() + 1) * sizeof(wchar_t));

   // verify null termination
   
   ASSERT(!dataPtr[bytes - 2] && !dataPtr[bytes - 1]);
   
   return
      Win::RegSetValueEx(
         key,
         valueName,
         expand ? REG_EXPAND_SZ : REG_SZ,
         dataPtr,
         bytes);
}



String
RegistryKey::GetString(const String& valueName)
{
   LOG_FUNCTION2(RegistryKey::GetString, valueName);

   // Do not assert this value because it needs to be empty to set
   // the default value for the key
   // ASSERT(!valueName.empty());

   String s;
   LONG result = GetValue(valueName, s);
   if (result != ERROR_SUCCESS)
   {
      s.erase();
   }

   return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\filesys.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// file system services
//
// 8-14-97 sburns



#include "headers.hxx"



static const int ROOTDIR_SIZE = 3;



// Returns true if the find handle is valid, false if not.

bool
IsValidHandle(HANDLE findHandle)
{
   if (findHandle != 0 && findHandle != INVALID_HANDLE_VALUE)
   {
      return true;
   }

   return false;
}



FS::Iterator::Iterator(
   const String&  startingPathSpec,
   unsigned       optionMask)
   :
   findData(0),
   findHandle(INVALID_HANDLE_VALUE),
   finished(false),
   options(optionMask),
   parentFolder(),
   startSearchSpec(startingPathSpec)
{
   LOG_CTOR(FS::Iterator);
   
#ifdef DBG

   // NTRAID#NTBUG9-569132-2002/03/19-sburns
   
   FS::PathSyntax syn = FS::GetPathSyntax(startSearchSpec);
   ASSERT(
         syn == FS::SYNTAX_ABSOLUTE_DRIVE_WILDCARD
      || syn == SYNTAX_UNC_WILDCARD);
#endif      

   parentFolder = GetParentFolder(startSearchSpec);

   if (parentFolder.length() > ROOTDIR_SIZE)
   {
      // the parent folder is not a root folder, and so will not have
      // a trailing whack

      parentFolder += L"\\";
   }
}



FS::Iterator::~Iterator()
{
   LOG_DTOR(FS::Iterator);

   if (!finished)
   {
      Finish();
   }

   delete findData;
   findData = 0;
}



// Forces the iterator to the finished state.

void
FS::Iterator::Finish()
{
   LOG_FUNCTION(FS::Iterator::Finish);

   if (IsValidHandle(findHandle))
   {
      HRESULT unused = Win::FindClose(findHandle);

      ASSERT(SUCCEEDED(unused));   
      ASSERT(findData);

      findHandle = INVALID_HANDLE_VALUE;
   }

   delete findData;
   findData = 0;

   finished = true;
}



// Forces the iterator to the not started state.

void
FS::Iterator::Reset()
{
   LOG_FUNCTION(FS::Iterator::Reset);

   Finish();

   finished = false;
}



HRESULT
FS::Iterator::Start()
{
   LOG_FUNCTION(FS::Iterator::Start);

   // we should be in the "not started" state

   ASSERT(IsNotStarted());

   HRESULT hr = S_OK;

   do
   {
      // findData is deleted by Iterator::Finish

      findData = new WIN32_FIND_DATA;

      hr = Win::FindFirstFile(startSearchSpec, *findData, findHandle);
      if (FAILED(hr))
      {
         Finish();

         if (
               hr == Win32ToHresult(ERROR_NO_MORE_FILES)
            || hr == Win32ToHresult(ERROR_FILE_NOT_FOUND) )
         {
            // the iteration set is empty

            hr = S_FALSE;
         }

         break;   
      }

      // Here, we're positioned at the first match, which may not meet
      // our filter criteria.  Skip those matches that don't.

      hr = SkipFilteredPaths();
      BREAK_ON_FAILED_HRESULT(hr);
      if (hr == S_FALSE)
      {
         break;
      }
   }
   while (0);

   return hr;
}



bool
FS::Iterator::IsNotStarted()
{
   return !finished && !findData && (findHandle == INVALID_HANDLE_VALUE);
}



HRESULT
FS::Iterator::GetCurrent(String& result)
{
//   LOG_FUNCTION(FS::Iterator::GetCurrent);

   HRESULT hr = S_OK;
   result.erase();

   do
   {
      if (finished)
      {
         hr = S_FALSE;
         break;
      }

      if (IsNotStarted())
      {
         hr = Start();
         BREAK_ON_FAILED_HRESULT(hr);
         if (hr == S_FALSE)
         {
            break;
         }
      }

      // At this point, we're positioned at the first match that meets
      // our filter.

      result = ReturnPath();
   }
   while (0);

   return hr;
}



HRESULT
FS::Iterator::Increment()
{
//   LOG_FUNCTION(FS::Iterator::Increment);

   HRESULT hr = S_OK;
   
   do
   {
      // Start the iterator if it is not started already.

      String unused;
      hr = GetCurrent(unused);
      BREAK_ON_FAILED_HRESULT(hr);
      if (hr == S_FALSE)
      {
         break;
      }

      // now step to the next match.

      do
      {
         ASSERT(findData);

         if (findData)
         {
            hr = Win::FindNextFile(findHandle, *findData);
         }
         else
         {
            hr = E_POINTER;
         }
         if (FAILED(hr))
         {
            Finish();

            if (hr == Win32ToHresult(ERROR_NO_MORE_FILES))
            {
               // this is a "good" error.  It means we are done.

               hr = S_FALSE;
            }

            break;
         }

         ASSERT(IsValidHandle(findHandle));
      }
      while (ShouldSkipCurrent());
   }
   while (0);

   return hr;
}



String
FS::Iterator::ReturnPath()
{
//   LOG_FUNCTION(FS::Iterator::ReturnPath);
   ASSERT(findData);
   ASSERT(IsValidHandle(findHandle));

   if ((options & RETURN_FULL_PATHS) && findData)
   {
      return parentFolder + findData->cFileName;
   }

   if (findData)
   {
      return findData->cFileName;
   }

   return String();
}



// Determines if the Current path should be skipped according to the
// filtering options set upon contruction of the iterator.

bool
FS::Iterator::ShouldSkipCurrent()
{
//   LOG_FUNCTION(FS::Iterator::ShouldSkipCurrent);
   ASSERT(findData);

   bool result = false;

   do
   {
      if (!findData)
      {
         LOG(L"findData is null");
         break;
      }

      String file = findData->cFileName;

      if (!(options & INCLUDE_DOT_PATHS))
      {
         if (file == L"." || file == L"..")
         {
            LOG(L"skipping dot path " + file);
            result = true;
            break;
         }
      }

      bool isFolder =
            findData->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY
         ?  true
         :  false;

      if (!(options & INCLUDE_FOLDERS))
      {
         if (isFolder)
         {
            LOG(L"skipping folder " + file);
            result = true;
            break;
         }
      }

      if (!(options & INCLUDE_FILES))
      {
         if (!isFolder)
         {
            LOG(L"skipping file " + file);
            result = true;
            break;
         }
      }
   }
   while (0);

   return result;
}



HRESULT
FS::Iterator::SkipFilteredPaths()
{
//   LOG_FUNCTION(FS::Iterator::SkipFilteredPaths);

   ASSERT(IsValidHandle(findHandle));

   HRESULT hr = S_OK;
   while (
         hr != S_FALSE
      && IsValidHandle(findHandle)
      && ShouldSkipCurrent())
   {
      hr = Increment();
      BREAK_ON_FAILED_HRESULT(hr);
   }

   return hr;
}



struct CopyFileExProgressData
{
   FS::CopyCallbackParam*  param;
   BOOL                    cancelFlag;
   Callback*               callback;
};



// Return the next highest whole number greater than n if the
// fractional portion of n >= 0.5, otherwise return n.

int
Round(double n)
{
   // truncate n to the integer portion
   //lint -e(922)  
   int n1 = static_cast<int>(n);
   if (n - n1 >= 0.5)
   {
      return n1 + 1;
   }

   return n1;
}



DWORD
WINAPI
copyFileProgress(

   //lint -e1746 These parameters can't be made const refs

   LARGE_INTEGER  TotalFileSize,
   LARGE_INTEGER  TotalBytesTransferred,
   LARGE_INTEGER  /* StreamSize */ ,
   LARGE_INTEGER  /* StreamBytesTransferred */ ,	
   DWORD          /* dwStreamNumber */ ,	
   DWORD          /* dwCallbackReason */ ,	
   HANDLE         /* hSourceFile */ ,	
   HANDLE         /* hDestinationFile */ ,
   void*          dp)
{
   ASSERT(dp);

   CopyFileExProgressData* data =
      reinterpret_cast<CopyFileExProgressData*>(dp);

   if (data)
   {
      LONGLONG totalCopied = TotalBytesTransferred.QuadPart;
      LONGLONG totalSize = TotalFileSize.QuadPart;

      if (totalSize != 0)
      {
         data->param->percentCopied =
            Round(totalCopied / totalSize * 100.0);
      }
      else
      {
         data->param->percentCopied = 100;
      }

      // invoke the callback
      if (data->callback)
      {
         data->cancelFlag = !data->callback->Execute(data->param);
      }

      if (!data->cancelFlag)
      {
         return PROGRESS_CONTINUE;
      }
   }

   return PROGRESS_CANCEL;
}



HRESULT
FS::CopyFile(
   const String& sourceFile,
   const String& destinationFile,
   Callback*     progressCallback)
{
   LOG_FUNCTION(FS::CopyFile);
   ASSERT(!sourceFile.empty());
   ASSERT(!destinationFile.empty());
   ASSERT(PathExists(sourceFile));

   HRESULT hr = S_OK;

   do
   {
      if (!PathExists(sourceFile))
      {
         hr = Win32ToHresult(ERROR_FILE_NOT_FOUND);
         break;
      }

      if (PathExists(destinationFile))
      {
         hr = Win32ToHresult(ERROR_ALREADY_EXISTS);
         break;
      }

      // do the copy

      // pull off the destination path

      String destPath = GetParentFolder(destinationFile);
      if (!PathExists(destPath))
      {
         hr = CreateFolder(destPath);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      CopyCallbackParam param;

      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(&param, sizeof param);
      
      param.sourceFile      = sourceFile;     
      param.destinationFile = destinationFile;
      param.percentCopied   = 0;              

      CopyFileExProgressData data;

      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(&data, sizeof data);
      
      data.param      = &param;          
      data.cancelFlag = FALSE;           
      data.callback   = progressCallback;

      hr =
         Win::CopyFileEx(
            sourceFile,
            destinationFile,
            copyFileProgress,
            &data,
            &data.cancelFlag,
            0);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   return hr;
}



HRESULT
FS::CreateFolder(const String& path)
{
   LOG_FUNCTION2(FS::CreateFolder, path);
   ASSERT(IsValidPath(path));

   HRESULT hr = S_OK;

   do
   {
      if (PathExists(path))
      {
         // already exists is considered a successful create.

         hr = S_FALSE;
         break;
      }

      // Create all the folders required, up to and including the leaf folder.
      // The SDK api MakeSureDirectoryPathExists from dbghelp.lib also does
      // this, but the documented failure semantics are a bit vague, and it
      // doesn't seem necessary to require another link lib for this
      // operation.
      
      // copy the path into an array that we can mark up as we walk thru the
      // nested subdirectories.

      size_t len = path.length() + 1;
      wchar_t* c = new wchar_t[len];
      
      // REVIEWED-2002/03/05-sburns correct byte count passed

      ::ZeroMemory(c, sizeof wchar_t * len);

      path.copy(c, len - 1);

      // Search for the first backslash after the first folder name.  Skip the
      // volume designation, and one character more, as we know that a folder
      // name must consist of at least one character that is not '\'
                                                                 
      wchar_t* current = wcschr(c + GetRootFolder(path).length() + 1, L'\\');

      while (SUCCEEDED(hr))
      {
         if (current)
         {
            // mark the trailing backslash as the end of the string.  This
            // makes c point to a truncated path (containing only the folder
            // names we have walk thru so far).

            *current = 0;
         }

         hr = Win::CreateDirectory(c);
         if (FAILED(hr))
         {
            if (hr == Win32ToHresult(ERROR_ALREADY_EXISTS))
            {
               // folder already exists, so treat that as a successful
               // create.  We don't set hr = S_FALSE, because the existing
               // folder is an intermediate folder, not the one indicated
               // by the path parameter (that case is handled above).

               hr = S_OK;
            }
            else
            {
               break;
            }
         }

         if (current)
         {
            // replace the original trailing backslash, and move on to the
            // next backslash after that.

            *current = L'\\';
            current = wcschr(current + 1, L'\\');
         }
         else
         {
            // no more folders are on the path.  We're done.

            break;
         }
      }

      delete[] c;
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
FS::GetAvailableSpace(const String& path, ULONGLONG& result)
{
   LOG_FUNCTION2(FS::GetAvailableSpace, path);
   ASSERT(FS::PathExists(path));

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&result, sizeof result);

   ULARGE_INTEGER available;

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&available, sizeof available);

   ULARGE_INTEGER total;

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&total, sizeof total);

   HRESULT hr = Win::GetDiskFreeSpaceEx(path, available, total, 0);

   if (SUCCEEDED(hr))
   {
      result = available.QuadPart;
   }

   return hr;   
}



String
FS::GetRootFolder(const String& fullpath)
{
   LOG_FUNCTION2(FS::GetRootFolder, fullpath);
   ASSERT(FS::IsValidPath(fullpath));

   String result;

   do
   {
      FS::PathSyntax syn = FS::GetPathSyntax(fullpath);
      if (syn == SYNTAX_UNC_WILDCARD || syn == SYNTAX_UNC)
      {
         // we define the root folder of a UNC path to be the
         // share name with trailing backslash: \\server\share\

         // start looking for backslashes after the first two characters.

         size_t pos = fullpath.find(L"\\", 2);

         // this assertion had better hold if it's a valid unc path

         ASSERT(pos != String::npos);
         if (pos == String::npos)
         {
            break;
         }

         // look for the next backslash after that

         pos = fullpath.find(L"\\", pos + 1);

         if (pos != String::npos)
         {
            // include the trailing \

            result = fullpath.substr(0, pos + 1);
         }
         else
         {
            // it's just a share name, \\foo\bar, add trailing \

            result = fullpath + L"\\";
         }
      }
   }
   while (0);

   if (result.empty())
   {
      result = fullpath.substr(0, ROOTDIR_SIZE);
   }

   return result;
}



bool
FS::IsFolderEmpty(const String& path)
{
   LOG_FUNCTION(FS::IsFolderEmpty);
   ASSERT(IsValidPath(path));

   bool result = true;

   do
   {
      if (!PathExists(path))
      {
         // non-existent folders are empty by definition

         break;
      }

      String wild = path;

      // REVIEW: wild[wild.length() - 1] is the same as *(wild.rbegin())
      // which is cheaper?
      
      if (wild[wild.length() - 1] != L'\\')
      {
         wild += L"\\";
      }

      wild += L"*.*";

      FS::Iterator iter(wild, FS::Iterator::INCLUDE_FILES);

// when recursive iteration is done, this can be added back in.
//          |  FS::Iterator::INCLUDE_FOLDERS);

      String unused;
      if (iter.GetCurrent(unused) != S_FALSE)
      {
         // there is at least one file/folder in the iteration set

         result = false;
      }
   }
   while (0);

   return result;
}



FS::PathSyntax
FS::GetPathSyntax(const String& str)
{
   LOG_FUNCTION2(FS::GetPathSyntax, str);
   ASSERT(!str.empty());

   if (!str.empty())
   {
      wchar_t* p = const_cast<wchar_t*>(str.c_str());
      DWORD pathType = 0;

      NET_API_STATUS err = I_NetPathType(0, p, &pathType, 0);
      if (err == NERR_Success)
      {
         switch (pathType)
         {
            case ITYPE_PATH_ABSND:
            {
               return SYNTAX_ABSOLUTE_NO_DRIVE;
            }
            case ITYPE_PATH_ABSD:
            {
               return SYNTAX_ABSOLUTE_DRIVE;
            }
            case ITYPE_PATH_RELND:
            {
               return SYNTAX_RELATIVE_NO_DRIVE;
            }
            case ITYPE_PATH_RELD:
            {
               return SYNTAX_RELATIVE_DRIVE;
            }
            case ITYPE_PATH_ABSND_WC:
            {
               return SYNTAX_ABSOLUTE_NO_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_ABSD_WC:
            {
               return SYNTAX_ABSOLUTE_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_RELND_WC:
            {
               return SYNTAX_RELATIVE_NO_DRIVE_WILDCARD;
            }
            case ITYPE_PATH_RELD_WC:
            {
               return SYNTAX_RELATIVE_DRIVE_WILDCARD;
            }
            case ITYPE_UNC:
            {
               return SYNTAX_UNC;
            }
            case ITYPE_UNC_WC:
            {
               return SYNTAX_UNC_WILDCARD;
            }
            default:
            {
               // fall thru
            }
         }
      }
   }

   return SYNTAX_UNRECOGNIZED;
}



bool
FS::IsValidPath(const String& path)
{
   ASSERT(!path.empty());

   bool result = false;

   do
   {
      if (path.empty())
      {
         break;
      }
      
      FS::PathSyntax syn = GetPathSyntax(path);
      if (syn != SYNTAX_ABSOLUTE_DRIVE && syn != SYNTAX_UNC)
      {
         // we only support absolute and UNC paths.

         break;
      }
      
      // The following reserved words cannot be used as the name of a file:
      // CON, PRN, AUX, CLOCK$, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7,
      // COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
      // Also, reserved words followed by an extension for example,
      // NUL.tx7 is and invalid file name. 

      // Try to determine if the path refers to a file or device

      // ISSUE-2002/04/15-sburns This code does not catch X:\foo.ext or X:\foo
      // when foo is one of {CON, CLOCK$, COM[3..9], LPT[2..9]}, but does
      // catch those cases when foo is one of {PRN, AUX, NUL, COM1, COM2,
      // LPT1}

      // Since the candidate path may not exist, prevent the system from
      // popping up any "insert disk" prompts

      UINT oldMode = ::SetErrorMode(SEM_FAILCRITICALERRORS);
      
      HANDLE h =
         ::CreateFile(
            path.c_str(),

            // 0 is "query device access" without actually opening it.
      
            0,
            0,
            0,

            // OPEN_EXISTING is required when opening a device.
      
            OPEN_EXISTING,
            0,
            0);

      (void) ::SetErrorMode(oldMode);
            
      if (h == INVALID_HANDLE_VALUE)
      {
         // not a valid device, or the file does not exist. Either way,
         // we know that the path does not refer to a device, and is
         // a syntactically valid path.

         result = true;
         break;
      }

      // At this point, we have a valid handle to the file or device. Let's
      // check to make sure it is not a device.

      DWORD fileType = ::GetFileType(h);
      ::CloseHandle(h);
      
      if (fileType != FILE_TYPE_DISK)
      {
         // not a disk file
         
         break;
      }
            
      // At this point, the path refers to an existing disk file

      result = true;
   }
   while (0);

   return result;
}



HRESULT
FS::CreateFile(
   const String&  path,
   HANDLE&        handle,
   DWORD          desiredAccess,
   DWORD          shareMode,
   DWORD          creationDisposition,
   DWORD          flagsAndAttributes)
{
   LOG_FUNCTION(FS::CreateFile);

   HRESULT hr = S_OK;
   handle = INVALID_HANDLE_VALUE;

   do
   {
      if (!IsValidPath(path))
      {
         // if you're passing junk, you've got a problem.
         
         ASSERT(false);
         hr = E_INVALIDARG;
         break;
      }
      
      // remove the last element of the path to form the parent directory

      String parentFolder = GetParentFolder(path);
      if (!PathExists(parentFolder))
      {
         hr = FS::CreateFolder(parentFolder);
         BREAK_ON_FAILED_HRESULT(hr);
      }

      hr = 
         Win::CreateFile(
            path,
            desiredAccess,
            shareMode,
            0,
            creationDisposition,
            flagsAndAttributes,
            0,
            handle);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}

HRESULT
FS::DeleteFile(const String&  path)
{
   ASSERT(IsValidPath(path));

   HRESULT hr = S_OK;

   hr = Win::DeleteFile(path);

   LOG_HRESULT(hr);

   return hr;
}

bool
FS::PathExists(const String& path)
{
   ASSERT(IsValidPath(path));

   bool result = false;

   if (IsValidPath(path))
   {
      DWORD attrs = 0;
      HRESULT hr = Win::GetFileAttributes(path, attrs);
      if (SUCCEEDED(hr))
      {
         result = true;
      }
   }

   LOG(result ? L"true" : L"false");

   return result;
}



bool
FS::FileExists(const String& filepath)
{
   ASSERT(IsValidPath(filepath));

   bool result = false;

   if (IsValidPath(filepath))
   {
      DWORD attrs = 0;
      HRESULT hr = Win::GetFileAttributes(filepath, attrs);
      if (SUCCEEDED(hr))
      {
         result = !(attrs & FILE_ATTRIBUTE_DIRECTORY);
      }
   }

   LOG_BOOL(result);

   return result;
}



HRESULT
mySeek(
   HANDLE    handle,     
   LONGLONG  position,   
   DWORD     whence,     
   LONGLONG* newPosition)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   if (newPosition)
   {
      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(newPosition, sizeof(LONGLONG));
   }

   LARGE_INTEGER li;
   li.QuadPart = position;

   LARGE_INTEGER newPos;

   HRESULT hr = Win::SetFilePointerEx(handle, li, &newPos, whence);

   if (newPosition)
   {
      *newPosition = newPos.QuadPart;
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::GetFilePosition(HANDLE handle, LONGLONG& result)
{
   LOG_FUNCTION(FS::GetFilePosition);
   ASSERT(handle != INVALID_HANDLE_VALUE);

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&result, sizeof result);

   LONGLONG position;

   // REVIEWED-2002/03/05-sburns correct byte count passed
  
   ::ZeroMemory(&position, sizeof position);

   return mySeek(handle, position, FILE_CURRENT, &result);
}



HRESULT
FS::GetFileSize(HANDLE handle, LONGLONG& result)
{
   LOG_FUNCTION(FS::GetFileSize);
   ASSERT(handle != INVALID_HANDLE_VALUE);

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&result, sizeof result);

   LARGE_INTEGER li;
   HRESULT hr = Win::GetFileSizeEx(handle, li);
   if (SUCCEEDED(hr))
   {
      result = li.QuadPart;
   }

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Read(HANDLE handle, int bytesToRead, AnsiString& text)
{
   LOG_FUNCTION(FS::Read);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(bytesToRead);

   text.erase();

   HRESULT hr = S_OK;
   do
   {
      // figure out how much to read

      LONGLONG size;

      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(&size, sizeof size);

      hr = FS::GetFileSize(handle, size);
      BREAK_ON_FAILED_HRESULT(hr);

      LONGLONG pos;

      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(&pos, sizeof pos);

      hr = FS::GetFilePosition(handle, pos);
      BREAK_ON_FAILED_HRESULT(hr);

      if (bytesToRead == -1)
      {
         bytesToRead = INT_MAX;
      }

      // the most you can read is all that's left...

      LONGLONG btr = min(bytesToRead, size - pos);

      if (btr > INT_MAX)
      {
         // too much!  You'll never have enough memory

         hr = E_OUTOFMEMORY;
         break;
      }

      if (btr == 0)
      {
         // nothing to read

         break;
      }

      // altering the string should ensure that we are not sharing any
      // copies of the string data.

      // +1 to guarantee null termination
      //lint -e(922) for x86 LONGLONG is a double

      text.resize(static_cast<size_t>(btr + 1));

      BYTE* buffer = reinterpret_cast<BYTE*>(const_cast<char*>(text.data()));

      DWORD bytesRead = 0;

      hr =
         Win::ReadFile(
            handle,
            buffer,

            //lint -e(922) for x86 LONGLONG is a double

            static_cast<DWORD>(btr),
            bytesRead,
            0);
      BREAK_ON_FAILED_HRESULT(hr);

      // the buffer contains all the bytes read.  now look for the first
      // null in the buffer, and truncate the string if necessary. The
      // strlen call is safe because we've ensured a null at the end when
      // we sized the buffer.

      size_t len = strlen(text.data());
      if (len != text.length())
      {
         text.resize(len);
      }
   }
   while (0);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Seek(HANDLE handle, LONGLONG position)
{
   LOG_FUNCTION(FS::Seek);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   LONGLONG newpos;

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&newpos, sizeof newpos);

   HRESULT hr = mySeek(handle, position, FILE_BEGIN, &newpos);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::SeekToEnd(HANDLE handle)
{
   LOG_FUNCTION(FS::SeekToEnd);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   LARGE_INTEGER li;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&li, sizeof li);

   return Win::SetFilePointerEx(handle, li, 0, FILE_END);
}



HRESULT
WriteHelper(HANDLE handle, void* buf, size_t bytesToWrite)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(buf);
   ASSERT(bytesToWrite);

   // on win64, size_t is 64 bits.
      
   ASSERT(bytesToWrite < ULONG_MAX);

   DWORD bytesWritten = 0;
   HRESULT hr =
      Win::WriteFile(
         handle,
         buf,
         static_cast<DWORD>(bytesToWrite),
         &bytesWritten);

   ASSERT(bytesWritten == bytesToWrite);

   LOG_HRESULT(hr);

   return hr;
}



HRESULT
FS::Write(HANDLE handle, const String& text)
{
   LOG_FUNCTION(FS::Write);
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(!text.empty());

   size_t bytesToWrite = text.length() * sizeof(wchar_t);
   return
      WriteHelper(
         handle,
         reinterpret_cast<void*>(
            const_cast<wchar_t*>(text.data())),

         // REVIEWED-2002/03/06-sburns correct byte count passed
            
         bytesToWrite);
}



HRESULT
FS::WriteLine(HANDLE handle, const String& text)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   return FS::Write(handle, text + L"\r\n");
}



HRESULT
FS::Write(HANDLE handle, const AnsiString& buf)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(!buf.empty());

   return
      WriteHelper(
         handle,
         reinterpret_cast<void*>(const_cast<char*>(buf.data())),

         // REVIEWED-2002/03/06-sburns correct byte count passed
         
         buf.length());
}



FS::FSType
FS::GetFileSystemType(const String& path)
{
   LOG_FUNCTION(FS::GetFileSystemType);
   ASSERT(IsValidPath(path));

   String vol = FS::GetRootFolder(path);
   String filesysName;
   DWORD flags = 0;

   HRESULT hr =
      Win::GetVolumeInformation(vol, 0, 0, 0, &flags, &filesysName);

   LOG_HRESULT(hr);

   if (FAILED(hr))
   {
      return FAT;
   }

   if (filesysName.icompare(L"CDFS") == 0)
   {
      return CDFS;
   }
   else if (filesysName.icompare(L"FAT") == 0)
   {
      return FAT;
   }
   else if (filesysName.icompare(L"NTFS") == 0)
   {
      // Keith Kaplan supplied code for win2k to do this same determination,
      // using NtQueryVolumeInformationFile, but this seems to do the same
      // thing, and is much simpler. If this proves not to work, then pull
      // back in the old code which is logged in this file in source depot.
      // NTRAID#NTBUG9-543420-2002/03/05-sburns     
      
      if (flags & FILE_SUPPORTS_SPARSE_FILES)
      {
         // NTFS 5.0 supports this

         return NTFS5;
      }

      return NTFS4;
   }

   return FAT;
}



bool
FS::IsParentFolder(const String& parent, const String& child)
{
   LOG_FUNCTION(FS::IsParentFolder);
   ASSERT(FS::IsValidPath(parent));
   ASSERT(FS::IsValidPath(child));

   if (child.length() <= parent.length())
   {
      // if child is shorter than parent, then no way parent is parent
      // folder
      return false;
   }

   // tokenize both paths, then compare the tokens one-by-one.  parent
   // is really a parent directory if all it's tokens are at the beginning
   // of child

   static const String DELIMS(L":\\");

   StringVector parentTokens;
   StringVector childTokens;
   parent.tokenize(std::back_inserter(parentTokens), DELIMS.c_str());
   child.tokenize(std::back_inserter(childTokens),   DELIMS.c_str());

   if (parentTokens.size() >= childTokens.size())
   {
      // if child has same or fewer tokens than parent, then no way is
      // parent the parent folder.
      return false;
   }

   for (
      size_t i = 0;
      i < parentTokens.size();
      ++i)
   {
      if (parentTokens[i].icompare(childTokens[i]))
      {
         // not equal tokens
         return false;
      }
   }

   return true;
}



// ISSUE-2002/02/26-sburns Seems like this belongs in Win:: since it's just a
// simple wrapper.

HRESULT
FS::GetVolumePathName(const String& path, String& result)
{
   result.erase();
   HRESULT hr = S_OK;

   WCHAR* buf = new WCHAR[MAX_PATH];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, MAX_PATH * sizeof WCHAR);
            
   if (::GetVolumePathName(path.c_str(), buf, MAX_PATH - 1))
   {
      result = buf;
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   delete[] buf;

   return hr;
}



String
FS::NormalizePath(const String& abnormalPath)
{
   LOG_FUNCTION2(FS::NormalizePath, abnormalPath);
   ASSERT(!abnormalPath.empty());

   // GetFullPathName will resolve current working directory, relative path
   // elements (e.g. .. and .).  It does not verify that the result is 
   // syntactically correct, or exists. For that, use IsValidPath() and
   // PathExists()
   
   String result;
   HRESULT hr = Win::GetFullPathName(abnormalPath, result);

   // ISSUE-2002/02/28-sburns Call ::GetLongPathName too, to weed out short
   // file names?  That only works if the file exists.
   
   // ISSUE-2002/02/28-sburns what happens for paths like
   // mysecretfile.txt::$DATA
   
   if (SUCCEEDED(hr))
   {
      // if it's normal, it should be a fully-qualified path.
      
      ASSERT(IsValidPath(result));
      
      return result;
   }

   LOG_HRESULT(hr);

   return abnormalPath;
}


   
HRESULT
FS::MoveFile(
   const String&  srcPath,
   const String&  dstPath)
{
   LOG_FUNCTION(FS::MoveFile);
   ASSERT(FS::PathExists(srcPath));
   ASSERT(FS::IsValidPath(dstPath));

   DWORD flags = 0;

   if (FS::GetRootFolder(srcPath).icompare(FS::GetRootFolder(dstPath)))
   {
      // paths are on different volumes, so include the copy option
      flags |= MOVEFILE_COPY_ALLOWED | MOVEFILE_WRITE_THROUGH;
   }

   return Win::MoveFileEx(srcPath, dstPath, flags);
}



void
FS::SplitPath(
   const String&  fullpath,
   String&        drive,
   String&        folderPath,
   String&        fileName,
   String&        extension)
{
   LOG_FUNCTION2(FS::SplitPath, fullpath);
   ASSERT(!fullpath.empty());

   wchar_t driveBuf[_MAX_DRIVE];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(driveBuf, sizeof driveBuf);

   wchar_t folderBuf[_MAX_DIR];

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(folderBuf, sizeof folderBuf);

   wchar_t fileBuf[_MAX_FNAME];

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(fileBuf, sizeof fileBuf);

   wchar_t extBuf[_MAX_EXT];

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(extBuf, sizeof extBuf);

   // REVIEWED-2002/03/06-sburns component buffers are all max size, so
   // there should not be a truncation problem
   
   _wsplitpath(fullpath.c_str(), driveBuf, folderBuf, fileBuf, extBuf);

   drive      = driveBuf; 
   folderPath = folderBuf;
   fileName   = fileBuf;  
   extension  = extBuf;   
}



String
FS::AppendPath(
   const String& base, 
   const String& additional)
{
   LOG_FUNCTION2(FS::AppendPath, base);
   ASSERT(!base.empty());
   ASSERT(!additional.empty());


   String path = base;
   
   if (*(path.rbegin()) != L'\\' &&
       *(additional.begin()) != L'\\')
   {
      path += L'\\';
   }

   path += additional;

   return path;
}



String
FS::GetParentFolder(const String& fullpath)
{
   LOG_FUNCTION2(FS::GetFolder, fullpath);
   ASSERT(!fullpath.empty());

   String drive;
   String folder;
   String filename;
   String extension;

   SplitPath(fullpath, drive, folder, filename, extension);

   String result = drive + folder;

   if (folder.length() > 1)
   {
      // the folder is not the root folder, which means it also has a
      // trailing \ which we want to remove

      ASSERT(folder[folder.length() - 1] == L'\\');

      result.resize(result.length() - 1);
   }

   return result;
}



String
FS::GetPathLeafElement(const String& fullpath)
{
   LOG_FUNCTION(FS::GetPathLeafElement);

   ASSERT(!fullpath.empty());

   String drive;
   String folder;
   String filename;
   String extension;

   SplitPath(fullpath, drive, folder, filename, extension);

   String result = filename + extension;

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\safedll.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Self-freeing DLL class
// 
// 10-9-98 sburns



#include "headers.hxx"



SafeDLL::SafeDLL(const String& dllName)
   :
   module(0),
   name(dllName)
{
   LOG_CTOR(SafeDLL);
   ASSERT(!name.empty());
}



SafeDLL::~SafeDLL()
{
   LOG_DTOR(SafeDLL);

   if (module)
   {
      HRESULT unused = Win::FreeLibrary(module);

      ASSERT(SUCCEEDED(unused));
   }
}



HRESULT
SafeDLL::GetProcAddress(const String& functionName, FARPROC& result) const
{
   LOG_FUNCTION2(SafeDLL::GetProcAddress, functionName);
   ASSERT(!functionName.empty());

   result = 0;
   HRESULT hr = S_OK;

   do
   {
      // load the dll if not already loaded.
      
      if (!module)
      {
         hr = Win::LoadLibrary(name, module);
      }
      BREAK_ON_FAILED_HRESULT2(hr, L"failed to load " + name);

      hr = Win::GetProcAddress(module, functionName, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   LOG_HRESULT(hr);
   
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\service.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// Service Control Manager wrapper class
// 
// 10-6-98 sburns




#include "headers.hxx"



NTService::NTService(const String& machine_, const String& serviceName)
   :
   machine(machine_),
   name(serviceName)
{
   LOG_CTOR(NTService);
   ASSERT(!serviceName.empty());

   // machine name may be empty
}



NTService::NTService(const String& serviceName)
   :
   machine(),
   name(serviceName)
{
   LOG_CTOR(NTService);
   ASSERT(!serviceName.empty());

   // machine name may be empty
}



NTService::~NTService()
{
   LOG_DTOR(NTService);
}



HRESULT
MyOpenService(
   const String&  machine,
   const String&  name,
   DWORD          access,
   SC_HANDLE&     result)
{
   LOG_FUNCTION(MyOpenService);
   ASSERT(!name.empty());
   ASSERT(access);

   result = 0;

   HRESULT hr = S_OK;

   SC_HANDLE handle = 0;

   do
   {
      hr = Win::OpenSCManager(machine, GENERIC_READ, handle);
      BREAK_ON_FAILED_HRESULT(hr);

      hr = Win::OpenService(handle, name, access, result);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (handle)
   {
      Win::CloseServiceHandle(handle);
   }

   return hr;
}   



bool
NTService::IsInstalled()
{
   LOG_FUNCTION2(NTService::IsInstalled, name);

   SC_HANDLE handle = 0;
   HRESULT hr = MyOpenService(machine, name, SERVICE_QUERY_STATUS, handle);

   if (SUCCEEDED(hr))
   {
      Win::CloseServiceHandle(handle);
      return true;
   }

   return false;
}



HRESULT
NTService::GetCurrentState(DWORD& state)
{
   LOG_FUNCTION2(NTService::GetCurrentState, name);

   state = 0;
   SC_HANDLE handle = 0;
   HRESULT hr = S_OK;
   do
   {
      hr = MyOpenService(machine, name, SERVICE_QUERY_STATUS, handle);
      BREAK_ON_FAILED_HRESULT(hr);

      SERVICE_STATUS status;

      // REVIEWED-2002/03/05-sburns correct byte count passed
      
      ::ZeroMemory(&status, sizeof status);

      hr = Win::QueryServiceStatus(handle, status); 
      BREAK_ON_FAILED_HRESULT(hr);

      state = status.dwCurrentState;
   }
   while (0);

   if (handle)
   {
      Win::CloseServiceHandle(handle);
   }
      
   return hr;
}

HRESULT
NTService::WaitForServiceState(
   DWORD state,
   DWORD sleepInterval, 
   DWORD timeout)
{
   LOG_FUNCTION2(NTService::WaitForServiceState, name);

   HRESULT hr = S_OK;
   DWORD time = 0;

   while (true)
   {
      DWORD currentState = 0;
      hr = GetCurrentState(currentState);
      BREAK_ON_FAILED_HRESULT(hr);

      if (currentState == state)
      {
         break;
      }

      Sleep(sleepInterval);

      time += sleepInterval;

      if (time > timeout)
      {
         hr = Win32ToHresult(ERROR_SERVICE_REQUEST_TIMEOUT);
         
         break;
      }
   }

   LOG_HRESULT(hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\sources.inc ===
# BURNSLIB project support code 
#
# Copyright (c) 1997-2001 Microsoft Corporation
#
# 06 Jan 2000 sburns

# common definitions to be included in the sources file(s) of subfolders


MAJORCOMP=admin
MINORCOMP=burnslib

BURNSLIB_BASE_NAME=burnslib
TARGETPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETLIBPATH=$(PROJECT_ROOT)\burnslib\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

UMTYPE=windows

# ISOLATION_AWARE_ENABLED ==> use ui themes. The sources for your binary
# that links to burnslib will also need to define this flag.

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE -DISOLATION_AWARE_ENABLED

# USE_MSVCRT or USE_LIBCMT is set in the subordinate sources files

USE_NATIVE_EH=1
USE_RTTI=1
USE_STD=1
USE_STL=1

PRECOMPILED_INCLUDE=..\headers.hxx
PRECOMPILED_CXX=1

MSC_WARNING_LEVEL=/W4

INCLUDES=..\;$(PROJECT_ROOT)\burnslib\inc;$(DS_INC_PATH);$(NET_INC_PATH);

SOURCES= \
    ..\args.cpp                \
    ..\AutoTokenPrivileges.cpp \
    ..\computer.cpp            \
    ..\ControlSubclasser.cpp   \
    ..\dialog.cpp              \
    ..\DiagnoseDcNotFound.cpp  \
    ..\dllref.cpp              \
    ..\dns.cpp                 \
    ..\dsutil.cpp              \
    ..\EncryptedString.cpp     \
    ..\error.cpp               \
    ..\extract.cpp             \
    ..\filesys.cpp             \
    ..\netutil.cpp             \
    ..\proppage.cpp            \
    ..\popup.cpp               \
    ..\registry.cpp            \
    ..\safedll.cpp             \
    ..\service.cpp             \
    ..\utility.cpp             \
    ..\ValidateDomainName.cpp  \
    ..\win.cpp                 \
    ..\winerror.cpp            \
    ..\wizard.cpp              \
    ..\wizpage.cpp             \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\winerror.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
// 
// subclass of Error that understands Win32 error codes.  See
// winerror.h, lmerr.h in the Win32 SDK.
// 
// 8-14-97 sburns



#include "headers.hxx"



Win::Error::Error(HRESULT hr_, const String& message_, const String& summary_)
   :
   ::Error(),
   hr(hr_),
   message(message_),
   summary(summary_),
   summaryResId(0)
{
   ASSERT(!message.empty());
   ASSERT(!summary.empty());
}
   


Win::Error::Error(HRESULT hr_, int summaryResID)
   :
   ::Error(),
   hr(hr_),
   message(),
   summary(),
   summaryResId(summaryResID)
{
}



HRESULT
Win::Error::GetHresult() const
{
   return hr;
}



HelpContext
Win::Error::GetHelpContext() const
{
   return static_cast<HelpContext>(hr);
}

   

String
Win::Error::GetMessage() const
{
   if (message.empty() && hr)
   {
      message = GetErrorMessage(hr);
   }

   return message;
}



String
Win::Error::GetSummary() const
{
   if (summary.empty() && summaryResId)
   {
      summary = String::load(summaryResId);
   }

   return summary;
}



const Win::Error&
Win::Error::operator=(const Win::Error& rhs)
{
   if (&rhs != this)
   {
      message      = rhs.message;     
      summary      = rhs.summary;     
      hr           = rhs.hr;          
      summaryResId = rhs.summaryResId;
   }

   return *this;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\utility.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// global utility functions
//
// 8-14-97 sburns



#include "headers.hxx"



HRESULT
Reboot()
{
   LOG_FUNCTION(Reboot);

   HRESULT hr = S_OK;
   HANDLE htoken = INVALID_HANDLE_VALUE;

   do
   {
      AutoTokenPrivileges privs(SE_SHUTDOWN_NAME);
      hr = privs.Enable();

      LOG(L"Calling ExitWindowsEx");

      hr = Win::ExitWindowsEx(EWX_REBOOT);
      BREAK_ON_FAILED_HRESULT(hr);
   }
   while (0);

   if (htoken != INVALID_HANDLE_VALUE)
   {
      Win::CloseHandle(htoken);
   }

   return S_OK;
}



bool
IsCurrentUserAdministrator()
{
   LOG_FUNCTION(IsCurrentUserAdministrator);

   HRESULT hr = S_OK;

   bool result = false;
   do
   {
      // Create a SID for the local Administrators group
      SID_IDENTIFIER_AUTHORITY authority = {SECURITY_NT_AUTHORITY};
      PSID adminGroupSid = 0;
      hr =
         Win::AllocateAndInitializeSid(
            authority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0,
            0,
            0,
            0,
            0,
            0,
            adminGroupSid);
      BREAK_ON_FAILED_HRESULT(hr);

      BOOL isMember = FALSE;
      if (::CheckTokenMembership(0, adminGroupSid, &isMember))
      {
         result = isMember ? true : false;
      }

      Win::FreeSid(adminGroupSid);
   }
   while (0);

   LOG(
      String::format(
         L"Current user %1 an admin",
         result ? L"is" : L"is NOT"));

   return result;
}



NetbiosValidationResult
NetbiosValidationHelper(const String& name, DWORD nameType, int maxLength)
{
   LOG_FUNCTION(NetbiosValidationHelper);

   if (name.empty())
   {
      LOG(L"empty name");
      return INVALID_NAME;
   }

   // check that the name is not longer than the max bytes in the oem
   // character set.
   wchar_t* ps = const_cast<wchar_t*>(name.c_str());

   // ISSUE-2002/03/26-sburns should use Win:: wrapper.
     
   int oembytes =
      ::WideCharToMultiByte(
         CP_OEMCP,
         0,
         ps,

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         static_cast<int>(name.length()),
         0,
         0,
         0,
         0);
   if (oembytes > maxLength)
   {
      LOG(L"name too long");
      return NAME_TOO_LONG;
   }

   // this checks length in oem bytes, and illegal characters.  Unfortunately,
   // it does not distinguish between those two.  That's why we checked the
   // length ourselves (above).

   LOG(L"Calling I_NetNameValidate");

   NET_API_STATUS err =
      I_NetNameValidate(
         0,
         ps,
         nameType,
         LM2X_COMPATIBLE);
   if (err != NERR_Success)
   {
      LOG(L"invalid name");
      return INVALID_NAME;
   }

   LOG(L"valid name");
   return VALID_NAME;
}



NetbiosValidationResult
ValidateNetbiosDomainName(const String& s)
{
   LOG_FUNCTION2(ValidateNetbiosDomainName, s);
   ASSERT(!s.empty());

   return
      NetbiosValidationHelper(
         s,
         NAMETYPE_DOMAIN,
         DNLEN);
}



NetbiosValidationResult
ValidateNetbiosComputerName(const String& s)
{
   LOG_FUNCTION2(ValidateNetbiosComputerName, s);
   ASSERT(!s.empty());

   return
      NetbiosValidationHelper(
         s,
         NAMETYPE_COMPUTER,
         MAX_COMPUTERNAME_LENGTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\validatedomainname.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// functions to validate a new domain name
// The functions are split into validation routines
// and UI retrieving error messages based on the
// error codes returned from the validation routines.
//
// 3 December 2001 JeffJon



// In order for clients of these functions to get the proper resources, the 
// clients need to include burnslib\inc\ValidateDomainName.rc in their 
// resources.  For an example, see admin\dcpromo\exe\dcpromo.rc



#include "headers.hxx"
#include "ValidateDomainName.h"
#include "ValidateDomainName.hpp"

// return true if the name is a reserved name, false otherwise.  If true, also
// set message to an error message describing the problem.

bool
IsReservedDnsName(const String& dnsName)
{
   LOG_FUNCTION2(IsReservedDnsName, dnsName);
   ASSERT(!dnsName.empty());

   bool result = false;

   if (dnsName == L".")
   {
      // root domain is not a valid domain name
      // NTRAID#NTBUG9-424293-2001/07/06-sburns

      result = true;
   }
      
// We're still trying to decide if we should restrict these names
//
//    // names with these as the last labels are illegal.
// 
//    static const String RESERVED[] =
//    {
//       L"in-addr.arpa",
//       L"ipv6.int",
// 
//       // RFC 2606 documents these:
// 
//       L"test",
//       L"example",
//       L"invalid",
//       L"localhost",
//       L"example.com",
//       L"example.org",
//       L"example.net"
//    };
// 
//    String name(dnsName);
//    name.to_upper();
//    if (*(name.rbegin()) == L'.')
//    {
//       // remove the trailing dot
// 
//       name.resize(name.length() - 1);
//    }
// 
//    for (int i = 0; i < sizeof(RESERVED) / sizeof(String); ++i)
//    {
//       String res = RESERVED[i];
//       res.to_upper();
// 
//       size_t pos = name.rfind(res);
// 
//       if (pos == String::npos)
//       {
//          continue;
//       }
// 
//       if (pos == 0 && name.length() == res.length())
//       {
//          ASSERT(name == res);
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME,
//                dnsName.c_str());
//          break;
//       }
// 
//       if ((pos == name.length() - res.length()) && (name[pos - 1] == L'.'))
//       {
//          // the name has reserved as a suffix.
// 
//          result = true;
//          message =
//             String::format(
//                IDS_RESERVED_NAME_SUFFIX,
//                dnsName.c_str(),
//                RESERVED[i].c_str());
//          break;
//       }
//    }

   LOG_BOOL(result);
   
   return result;
}


bool
IsStringMappableToOem(const String& str)
{
   if (str.empty())
   {
      return true;
   }

   OEM_STRING dest;

   UNICODE_STRING source;

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&source, sizeof source);

   // ISSUE-2002/03/05-sburns use RtlInitUnicodeStringEx
   
   ::RtlInitUnicodeString(&source, str.c_str());

   NTSTATUS status = 
      ::RtlUpcaseUnicodeStringToOemString(
         &dest,
         &source,
         TRUE);

   ::RtlFreeOemString(&dest);

   return (status == STATUS_UNMAPPABLE_CHARACTER) ? false : true;
}



String
UnmappableCharactersMessage(const String& dnsName)
{
   LOG_FUNCTION2(UnmappableCharactersMessage, dnsName);
   ASSERT(!dnsName.empty());

   // for each character in the name, determine if it is unmappable, and
   // if so, add it to a list.

   String unmappables;
   
   for (size_t i = 0; i < dnsName.length(); ++i)
   {
      String s(1, dnsName[i]);
      if (
            !IsStringMappableToOem(s) 

            // not already in our list
            
         && unmappables.find_first_of(s) == String::npos)
      {
         unmappables += s + L" ";
      }
   }

   String message =
      String::format(
         IDS_UNMAPPABLE_CHARS_IN_NAME,
         unmappables.c_str(),
         dnsName.c_str());
         
   // CODEWORK: spec is to have a help link to some topic here....

   LOG(message);

   return message;
}

// Some constants used in ValidateDomainDnsNameSyntax

const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY      = 64;  // 106840
const int DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8 = 155; // 54054


String
GetMessageForDomainDnsNameSyntaxError(
   DNSNameSyntaxError dnsNameError, 
   String             domainName)
{
   LOG_FUNCTION2(GetMessageForDomainDnsNameSyntaxError, domainName);

   String result;

   switch (dnsNameError)
   {
      case DNS_NAME_NON_RFC_OEM_UNMAPPABLE:
         result = UnmappableCharactersMessage(domainName);
         break;

      case DNS_NAME_NON_RFC:
         result = String::format(IDS_NON_RFC_NAME, domainName.c_str());
         break;

      case DNS_NAME_NON_RFC_WITH_UNDERSCORE:
         result = String::format(IDS_MS_DNS_NAME, domainName.c_str());
         break;

      case DNS_NAME_RESERVED:
         result = String::load(IDS_ROOT_DOMAIN_IS_RESERVED);
         break;

      case DNS_NAME_TOO_LONG:
         result = 
            String::format(
               IDS_DNS_NAME_TOO_LONG,
               domainName.c_str(),
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
               DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8);
         break;
               
      case DNS_NAME_BAD_SYNTAX:
         result =
            String::format(
               IDS_BAD_DNS_SYNTAX,
               domainName.c_str(),
               Dns::MAX_LABEL_LENGTH);
         break;

      case DNS_NAME_VALID:
      default:
         // No error, so no message
         break;
   }
   LOG(result);
   return result;
}

   
DNSNameSyntaxError
ValidateDomainDnsNameSyntax(
   const String&  domainName)
{
   LOG_FUNCTION(ValidateDomainDnsNameSyntax);
   ASSERT(!domainName.empty());

   DNSNameSyntaxError result = DNS_NAME_VALID;

   LOG(L"validating " + domainName);

   switch (
      Dns::ValidateDnsNameSyntax(
         domainName,
         DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY,
         DNS_DOMAIN_NAME_MAX_LIMIT_DUE_TO_POLICY_UTF8) )
   {
      case Dns::NON_RFC:
      {
         // check for characters that cannot be mapped to the OEM character
         // set. These are not allowed.  Also check for variations on non
         // RFC-ness
         // NTRAID#NTBUG9-395298-2001/08/28-sburns

         static const String MS_DNS_CHARS =
            L"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.";
            
         if (!IsStringMappableToOem(domainName))
         {
            result = DNS_NAME_NON_RFC_OEM_UNMAPPABLE;
            break;
         }
         else if (domainName.find_first_not_of(MS_DNS_CHARS) == String::npos)
         {
            // there are no characters other than those in MS_DNS_CHARS.
            // Since we know that the name is non-RFC, then what is making
            // it such must be the presence of an underscore.

            ASSERT(domainName.find_first_of(L"_") != String::npos);
            
            result = DNS_NAME_NON_RFC_WITH_UNDERSCORE;
         }
         else
         {
            result = DNS_NAME_NON_RFC;
         }

         // fall through
         // We should never get a domain name that is non RFC and is reserved
         // so go ahead and overwrite the non RFC error (since its really just
         // a warning) with the reserved error is the name is reserved.
      }
      case Dns::VALID:
      {
         if (IsReservedDnsName(domainName))
         {
            result = DNS_NAME_RESERVED;
         }
         break;
      }
      case Dns::TOO_LONG:
      {
         result = DNS_NAME_TOO_LONG;
         break;
      }
      case Dns::NUMERIC:
      case Dns::BAD_CHARS:
      case Dns::INVALID:
      default:
      {
         result = DNS_NAME_BAD_SYNTAX;
         break;
      }
   }

   return result;
}

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   int    editResID,
   const Popup& popup)
{
   bool isNonRFC = false;
   return ValidateDomainDnsNameSyntax(
             parentDialog,
             String(),
             editResID,
             popup,
             true,
             &isNonRFC);
}

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   int    editResID,
   const Popup& popup,
   bool   warnOnNonRFC,
   bool*  isNonRFC)
{
   return ValidateDomainDnsNameSyntax(
             parentDialog,
             String(),
             editResID,
             popup,
             warnOnNonRFC,
             isNonRFC);
}

bool
ValidateDomainDnsNameSyntax(
   HWND   parentDialog,
   const String& domainName,
   int    editResID,
   const Popup& popup,
   bool   warnOnNonRFC,
   bool*  isNonRFC)
{
   LOG_FUNCTION(ValidateDomainDnsNameSyntax);

   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(editResID > 0);

   bool result = true;

   if (isNonRFC)
   {
      *isNonRFC = false;
   }

   do
   {
      String domain = 
         !domainName.empty() ? domainName :
                      Win::GetTrimmedDlgItemText(parentDialog, editResID);
      if (domain.empty())
      {
         popup.Gripe(parentDialog, editResID, IDS_MUST_ENTER_DOMAIN);
         result = false;
         break;
      }

      DNSNameSyntaxError dnsNameError = ValidateDomainDnsNameSyntax(domain);

      if (dnsNameError != DNS_NAME_VALID)
      {
         String errorMessage =
            GetMessageForDomainDnsNameSyntaxError(dnsNameError, domain);

         if (dnsNameError == DNS_NAME_NON_RFC ||
             dnsNameError == DNS_NAME_NON_RFC_WITH_UNDERSCORE)
         {
            if (isNonRFC)
            {
               *isNonRFC = true;
            }

            // This is just a warning so continue processing 

            if (warnOnNonRFC)
            {
               popup.Info(parentDialog, errorMessage);
            }
         }
         else
         {
            popup.Gripe(parentDialog, editResID, errorMessage);
            result = false;
            break;
         }
      }
   } while (false);

   LOG_BOOL(result);

   return result;
}



ForestNameExistsError
ForestValidateDomainDoesNotExist(
   const String& name)
{
   LOG_FUNCTION2(ForestValidateDomainDoesNotExist, name);

   // The invoking code should verify this condition, but we will handle
   // it just in case.

   ASSERT(!name.empty());

   ForestNameExistsError result = FOREST_DOMAIN_NAME_DOES_NOT_EXIST;
   String message;
   do
   {
      if (name.empty())
      {
         result = FOREST_DOMAIN_NAME_EMPTY;
         break;
      }
      if (IsDomainReachable(name))
      {
         result = FOREST_DOMAIN_NAME_EXISTS;
         break;
      }

      HRESULT hr = MyNetValidateName(name, ::NetSetupNonExistentDomain);

      if (hr == Win32ToHresult(ERROR_DUP_NAME))
      {
         result = FOREST_DOMAIN_NAME_DUPLICATE;
         break;
      }

      if (hr == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
      {
         result = FOREST_NETWORK_UNREACHABLE;
         break;
      }

      // otherwise the domain does not exist
   }
   while (0);

   return result;
}


bool
ForestValidateDomainDoesNotExist(
   HWND parentDialog,   
   int  editResID,
   const Popup& popup)
{
   LOG_FUNCTION(ForestValidateDomainDoesNotExist);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(editResID > 0);

   bool valid = true;
   String message;

   // this can take awhile.

   Win::WaitCursor cursor;

   String name = Win::GetTrimmedDlgItemText(parentDialog, editResID);

   ForestNameExistsError error = ForestValidateDomainDoesNotExist(name);

   do
   {
      switch (error)
      {
         case FOREST_DOMAIN_NAME_EMPTY:
            message = String::load(IDS_MUST_ENTER_DOMAIN);
            valid = false;
            break;

         case FOREST_DOMAIN_NAME_EXISTS:
            message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
            valid = false;
            break;

         case FOREST_DOMAIN_NAME_DUPLICATE:
            message = String::format(IDS_DOMAIN_NAME_IN_USE, name.c_str());
            valid = false;
            break;

         case FOREST_NETWORK_UNREACHABLE:
            {
               if (
                  popup.MessageBox(
                     parentDialog,
                     String::format(
                        IDS_NET_NOT_REACHABLE,
                        name.c_str()),
                     MB_YESNO | MB_ICONWARNING) != IDYES)
               {
                  message.erase();
                  valid = false;

                  HWND edit = Win::GetDlgItem(parentDialog, editResID);
                  Win::SendMessage(edit, EM_SETSEL, 0, -1);
                  Win::SetFocus(edit);
               }
            }
            break;

         case FOREST_DOMAIN_NAME_DOES_NOT_EXIST:
         default:
            valid = true;
            break;
      }
   }
   while (0);

   if (!valid && !message.empty())
   {
      popup.Gripe(parentDialog, editResID, message);
   }

   return valid;
}



bool
ConfirmNetbiosLookingNameIsReallyDnsName(
   HWND parentDialog, 
   int editResID,
   const Popup& popup)
{
   LOG_FUNCTION(ConfirmNetbiosLookingNameIsReallyDnsName);
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(editResID > 0);

   // check if the name is a single DNS label (a single label with a trailing
   // dot does not count.  If the user is DNS-saavy enough to use an absolute
   // DNS name, then we will pester him no further.)

   String domain = Win::GetTrimmedDlgItemText(parentDialog, editResID);
   if (domain.find(L'.') == String::npos)
   {
      // no dot found: must be a single label

      if (
         popup.MessageBox(
            parentDialog,
            String::format(
               IDS_CONFIRM_NETBIOS_LOOKING_NAME,
               domain.c_str(),
               domain.c_str()),
            MB_YESNO) == IDNO)
      {
         // user goofed.  or we frightened them.

         HWND edit = Win::GetDlgItem(parentDialog, editResID);
         Win::SendMessage(edit, EM_SETSEL, 0, -1);
         Win::SetFocus(edit);
         return false;
      }
   }

   return true;
}

NetbiosNameError
ValidateDomainNetbiosName(
   const String& name,
   String& hostName,
   HRESULT* hr = 0)
{
   LOG_FUNCTION2(ValidateDomainNetbiosName, name);

   NetbiosNameError result = NETBIOS_NAME_VALID;

   do
   {
      if (name.empty())
      {
         result = NETBIOS_NAME_EMPTY;
         break;
      }

      if (name.find(L".") != String::npos)
      {
         result = NETBIOS_NAME_DOT;
         break;
      }

      // Check that the name is not a number.  368777
      if (name.is_numeric())
      {
         result = NETBIOS_NAME_NUMERIC;
         break;
      }

      // we pretend that the candidate name is a hostname, and attempt to
      // generate a netbios name from it.  If that can't be done, then the
      // candidate name can't be a legal netbios name.

      HRESULT hresult = S_OK;
      hostName = Dns::HostnameToNetbiosName(name, &hresult);
      if (hr)
      {
         *hr = hresult;
      }

      if (FAILED(hresult))
      {
         result = NETBIOS_NAME_BAD;
         break;
      }

      if (hostName.length() < name.length())
      {
         result = NETBIOS_NAME_TOO_LONG;
         break;
      }

      if (ValidateNetbiosDomainName(hostName) != VALID_NAME)
      {
         result = NETBIOS_NAME_INVALID;
         break;
      }

      hresult = MyNetValidateName(name, ::NetSetupNonExistentDomain);

      if (hr)
      {
         *hr = hresult;
      }

      if (hresult == Win32ToHresult(ERROR_DUP_NAME))
      {
         result = NETBIOS_NAME_DUPLICATE;
         break;
      }

      if (hresult == Win32ToHresult(ERROR_NETWORK_UNREACHABLE))
      {
         result = NETBIOS_NETWORK_UNREACHABLE;
         break;
      }

   } while (false);

   return result;
}

const int MAX_NETBIOS_NAME_LENGTH = DNLEN;

bool
ValidateDomainNetbiosName(
   HWND dialog, 
   int editResID,
   const Popup& popup)
{
   LOG_FUNCTION(ValidateDomainNetbiosName);
   ASSERT(Win::IsWindow(dialog));
   ASSERT(editResID > 0);

   Win::CursorSetting cursor(IDC_WAIT);

   bool result = true;

   String name = Win::GetTrimmedDlgItemText(dialog, editResID);

   String hostName;
   HRESULT hr = S_OK;
   NetbiosNameError error = ValidateDomainNetbiosName(name, hostName, &hr);

   switch(error)
   {
      case NETBIOS_NAME_EMPTY:
         result = false;
         break;

      case NETBIOS_NAME_DOT:
         popup.Gripe(
            dialog,
            editResID,
            IDS_NO_DOTS_IN_NETBIOS_NAME);
         result = false;
         break;

      case NETBIOS_NAME_NUMERIC:
         popup.Gripe(
            dialog,
            editResID,
            String::format(IDS_NUMERIC_NETBIOS_NAME, name.c_str()));
         result = false;
         break;

      case NETBIOS_NAME_BAD:
         popup.Gripe(
            dialog,
            editResID,
            hr,
            String::format(IDS_BAD_NETBIOS_NAME, name.c_str()));
         result = false;
         break;

      case NETBIOS_NAME_TOO_LONG:
         popup.Gripe(
            dialog,
            editResID,
            String::format(
               IDS_NETBIOS_NAME_TOO_LONG,
               name.c_str(),
               MAX_NETBIOS_NAME_LENGTH));
         result = false;
         break;

      case NETBIOS_NAME_INVALID:
         popup.Gripe(
            dialog,
            editResID,
            String::format(
               IDS_BAD_NETBIOS_CHARACTERS,
               hostName.c_str()));
         result = false;
         break;

      case NETBIOS_NAME_DUPLICATE:
         popup.Gripe(
            dialog,
            editResID,
            String::format(IDS_FLATNAME_IN_USE, name.c_str()));
         result = false;
         break;

      case NETBIOS_NETWORK_UNREACHABLE:
         if (
            popup.MessageBox(
               dialog,
               String::format(
                  IDS_NET_NOT_REACHABLE,
                  name.c_str()),
               MB_YESNO | MB_ICONWARNING) != IDYES)
         {
            HWND edit = Win::GetDlgItem(dialog, editResID);
            Win::SendMessage(edit, EM_SETSEL, 0, -1);
            Win::SetFocus(edit);
            
            result = false;
         }
         break;

      default:
         break;
   }

   LOG_BOOL(result);

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\win.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// Wrappers of Win APIs
//
// 8-14-97 sburns



#include "headers.hxx"



static const int ROOTDIR_SIZE = 3;



Win::CursorSetting::CursorSetting(const String& newCursorName)
   :
   oldCursor(0)
{
   init(newCursorName.c_str(), false);
}



Win::CursorSetting::CursorSetting(
   const TCHAR* newCursorName,
   bool         isSystemCursor)
   :
   oldCursor(0)
{
   init(newCursorName, isSystemCursor);
}



Win::CursorSetting::CursorSetting(HCURSOR newCursor)
   :
   oldCursor(0)
{
   oldCursor = Win::SetCursor(newCursor);
}



void
Win::CursorSetting::init(
   const TCHAR* newCursorName,
   bool         isSystemCursor)
{
   ASSERT(newCursorName);

   HCURSOR newCursor = 0;
   HRESULT hr = Win::LoadCursor(newCursorName, newCursor, isSystemCursor);

   // NTRAID#NTBUG9-556278-2002/03/28-sburns
   
   if (SUCCEEDED(hr))
   {
      // oldCursor may be null if no cursor was in effect

      oldCursor = Win::SetCursor(newCursor);
   }
}



Win::CursorSetting::~CursorSetting()
{
   // restore the old cursor, if we replaced it

   if (oldCursor)
   {
      Win::SetCursor(oldCursor);
   }
}



HRESULT
Win::AdjustTokenPrivileges(
   HANDLE             tokenHandle,
   bool               disableAllPrivileges,
   TOKEN_PRIVILEGES   newState[])
{
   ASSERT(tokenHandle);

   HRESULT hr = S_OK;

   ::AdjustTokenPrivileges(
      tokenHandle,
      disableAllPrivileges ? TRUE : FALSE,
      newState,
      0,
      0,
      0);

   // We always check GLE because the function may still succeed even if not
   // all of the privs are adjusted.
   // NTRAID#NTBUG9-572324-2002/03/19-sburns
   
   hr = Win::GetLastErrorAsHresult();

   // don't assert, as ERROR_NOT_ALL_ASSIGNED is a possibility
   // 
   // ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::AdjustTokenPrivileges(
   HANDLE             tokenHandle,
   bool               disableAllPrivileges,
   TOKEN_PRIVILEGES   newState[],
   TOKEN_PRIVILEGES*& previousState)
{
   ASSERT(tokenHandle);
   ASSERT(!previousState);

   // this little bit of idiocy is required to convince AdjustTokenPrivs
   // that we don't know how much buffer to allocate, and to please tell
   // us. Passing a valid ptr for the required len is apparently not clue
   // enough.
   
   previousState = (TOKEN_PRIVILEGES*) new BYTE[1];

   HRESULT hr = S_OK;
   do
   {
      // first call to determine result buffer size.

      DWORD retLenInBytes = 0;
      BOOL succeeded =
         ::AdjustTokenPrivileges(
            tokenHandle,

            // since we are forcing a failure with a too-small buffer, this
            // should cause no change to any privs.
            
            disableAllPrivileges ? TRUE : FALSE,
            newState,
            1,

            // have to pass something here in order to get the desired
            // buffer length.
            
            previousState,
            &retLenInBytes);
         
      ASSERT(!succeeded);
      ASSERT(retLenInBytes);

      if (!retLenInBytes)
      {
         // The API is insane, and we're screwed.

         hr = E_UNEXPECTED;
         break;
      }

      delete[] (BYTE*) previousState;
      
      previousState = (TOKEN_PRIVILEGES*) new BYTE[retLenInBytes];
      ::ZeroMemory(previousState, retLenInBytes);
      
      DWORD retLenInBytes2 = 0;

      succeeded =
         ::AdjustTokenPrivileges(
            tokenHandle,
            disableAllPrivileges,
            newState,
            retLenInBytes,
            previousState,
            &retLenInBytes2);

      // We always check GLE because the function may still succeed even if not
      // all of the privs are adjusted.
      // NTRAID#NTBUG9-572324-2002/03/19-sburns
      
      hr = Win::GetLastErrorAsHresult();

      ASSERT(retLenInBytes == retLenInBytes2);
         
   }
   while (0);

   // don't assert success, as ERROR_NOT_ALL_ASSIGNED is a possibility
   // 
   // ASSERT(SUCCEEDED(hr));
   
   return hr;
}
      


HRESULT
Win::AllocateAndInitializeSid(
   SID_IDENTIFIER_AUTHORITY&  authority,
   BYTE                       subAuthorityCount,
   DWORD                      subAuthority0,
   DWORD                      subAuthority1,
   DWORD                      subAuthority2,
   DWORD                      subAuthority3,
   DWORD                      subAuthority4,
   DWORD                      subAuthority5,
   DWORD                      subAuthority6,
   DWORD                      subAuthority7,
   PSID&                      sid)
{
   ASSERT(subAuthorityCount && subAuthorityCount <= UCHAR_MAX);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::AllocateAndInitializeSid(
         &authority,
         subAuthorityCount,
         subAuthority0,
         subAuthority1,
         subAuthority2,
         subAuthority3,
         subAuthority4,
         subAuthority5,
         subAuthority6,
         subAuthority7,
         &sid);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Animate_Close(HWND animation)
{
   ASSERT(Win::IsWindow(animation));
   
   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            animation,
            ACM_OPEN,
            0,
            0));

   // should always return FALSE
            
   ASSERT(!result);
}



void
Win::Animate_Open(HWND animation, const TCHAR* animationNameOrRes)
{
   ASSERT(Win::IsWindow(animation));
   ASSERT(animationNameOrRes);

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            animation,
            ACM_OPEN,
            0,
            reinterpret_cast<LPARAM>(animationNameOrRes)));

   ASSERT(result);
}



void
Win::Animate_Stop(HWND animation)
{
   ASSERT(Win::IsWindow(animation));

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            animation,
            ACM_STOP,
            0,
            0));
   ASSERT(result);
}



HRESULT
Win::AppendMenu(
   HMENU    menu,     
   UINT     flags,    
   UINT_PTR idNewItem,
   PCTSTR   newItem)
{
   ASSERT(menu);
   ASSERT(idNewItem);
   ASSERT(newItem);

   HRESULT hr = S_OK;

   BOOL err = ::AppendMenu(menu, flags, idNewItem, newItem);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Button_SetCheck(HWND button, int checkState)
{
   ASSERT(Win::IsWindow(button));

   Win::SendMessage(button, BM_SETCHECK, static_cast<WPARAM>(checkState), 0);
}

bool
Win::Button_GetCheck(HWND button)
{
   ASSERT(Win::IsWindow(button));

   bool result = BST_CHECKED ==
      Win::SendMessage(
         button,
         BM_GETCHECK,
         0,
         0);

   return result;
}

void
Win::Button_SetStyle(HWND button, int style, bool redraw)
{
   ASSERT(Win::IsWindow(button));

   Win::SendMessage(
      button,
      BM_SETSTYLE,
      static_cast<WPARAM>(LOWORD(style)),
      MAKELPARAM((redraw ? TRUE : FALSE), 0));
}



void
Win::CheckDlgButton(
   HWND     parentDialog,
   int      buttonID,
   UINT     buttonState)
{
   // ensure that our type substitution is valid
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(buttonID);
   ASSERT(
         buttonState == BST_CHECKED
      || buttonState == BST_UNCHECKED
      || buttonState == BST_INDETERMINATE);

   BOOL result =
      ::CheckDlgButton(parentDialog, buttonID, buttonState);
   ASSERT(result);
}



void
Win::CheckRadioButton(
   HWND  parentDialog,
   int   firstButtonInGroupID,
   int   lastButtonInGroupID,
   int   buttonInGroupToCheckID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(firstButtonInGroupID);
   ASSERT(lastButtonInGroupID);
   ASSERT(buttonInGroupToCheckID);

   BOOL result =
      ::CheckRadioButton(
         parentDialog,
         firstButtonInGroupID,
         lastButtonInGroupID,
         buttonInGroupToCheckID);

   ASSERT(result);
}



void
Win::CloseHandle(HANDLE& handle)
{

// don't assert.  Closing an invalid handle is a no-op.
//    ASSERT(handle != INVALID_HANDLE_VALUE);

   if (handle != INVALID_HANDLE_VALUE)
   {
      BOOL result = ::CloseHandle(handle);
      ASSERT(result);
   }

   handle = INVALID_HANDLE_VALUE;
}



void
Win::CloseServiceHandle(SC_HANDLE handle)
{
   ASSERT(handle);

   BOOL result = ::CloseServiceHandle(handle);
   ASSERT(result);
}



int
Win::ComboBox_AddString(HWND combo, const String& s)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(!s.empty());

   int result =
      static_cast<int>(
         Win::SendMessage(
            combo,
            CB_ADDSTRING,
            0,
            reinterpret_cast<LPARAM>(s.c_str())));
   ASSERT(result != CB_ERR);
   ASSERT(result != CB_ERRSPACE);

   return result;
}



int
Win::ComboBox_GetCurSel(HWND combo)
{
   ASSERT(Win::IsWindow(combo));

   int result = (int) (DWORD) Win::SendMessage(combo, CB_GETCURSEL, 0, 0);

   // don't assert: it's legal that the listbox not have any selection

   return result;
}



String
Win::ComboBox_GetCurText(HWND combo)
{
   ASSERT(Win::IsWindow(combo));

   int sel = Win::ComboBox_GetCurSel(combo);
   if (sel != CB_ERR)
   {
      return Win::ComboBox_GetLBText(combo, sel);
   }

   return String();
}



String
Win::ComboBox_GetLBText(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   String s;
   do
   {
      int maxlen = Win::ComboBox_GetLBTextLen(combo, index);
      if (maxlen == CB_ERR)
      {
         break;
      }

      // +1 for null-terminator paranoia
      
      s.resize(maxlen + 1);
      int len =
         (int) Win::SendMessage(
            combo,

            // REVIEWED-2002/03/05-sburns text length accounts for null
            // terminator
            
            CB_GETLBTEXT,
            index,
            reinterpret_cast<LPARAM>(const_cast<wchar_t*>(s.c_str())));
      if (len == CB_ERR)
      {
         break;
      }

      s.resize(len);
   }
   while (0);

   return s;
}
   

      
int
Win::ComboBox_GetLBTextLen(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   return (int) Win::SendMessage(combo, CB_GETLBTEXTLEN, index, 0);
}



int
Win::ComboBox_SelectString(HWND combo, const String& str)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(!str.empty());

   int result =
      (int) Win::SendMessage(
         combo,
         CB_SELECTSTRING,
         static_cast<WPARAM>(-1),   // search entire list
         reinterpret_cast<LPARAM>(const_cast<wchar_t*>(str.c_str())));

   // don't assert the result: if the item is not in the list, that's
   // not necessarily a logic failure

   return result;
}



void
Win::ComboBox_SetCurSel(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   int result =
      (int) (DWORD) Win::SendMessage(
         combo,
         CB_SETCURSEL,
         static_cast<WPARAM>(index),
         0);
   ASSERT(result != CB_ERR);
}

void
Win::ComboBox_SetItemData(HWND combo, int index, LPARAM data)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   LRESULT result =
      Win::SendMessage(
         combo,
         CB_SETITEMDATA,
         static_cast<WPARAM>(index),
         data);

   ASSERT(result != CB_ERR);
}

LRESULT
Win::ComboBox_GetItemData(HWND combo, int index)
{
   ASSERT(Win::IsWindow(combo));
   ASSERT(index >= 0);

   LRESULT result =
      Win::SendMessage(
         combo,
         CB_GETITEMDATA,
         static_cast<WPARAM>(index),
         0);

   ASSERT(result != CB_ERR);

   return result;
}


int
Win::CompareString(
   LCID  locale,
   DWORD flags,
   const String& string1,
   const String& string2)
{
   int len1 = static_cast<int>(string1.length());
   int len2 = static_cast<int>(string2.length());

   int result =
      ::CompareString(
         locale,
         flags,
         string1.c_str(),
         len1,
         string2.c_str(),
         len2);
   ASSERT(result);

   return result;
}



HRESULT
Win::ConvertSidToStringSid(PSID sid, String& result)
{
   ASSERT(sid);

   result.erase();

   HRESULT hr = S_OK;

   PTSTR sidstr = 0;
   BOOL b = ::ConvertSidToStringSid(sid, &sidstr);
   if (b)
   {
      result = sidstr;
      ::LocalFree(sidstr);
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::ConvertStringSidToSid(const String& sidString, PSID& sid)
{
   ASSERT(!sidString.empty());

   sid = 0;

   HRESULT hr = S_OK;

   BOOL b = ::ConvertStringSidToSid(sidString.c_str(), &sid);
   if (!b)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else
   {
      ASSERT(::IsValidSid(sid));
   }

   return hr;
}



HRESULT
Win::CopyFileEx(
   const String&        existingFileName,
   const String&        newFileName,
   LPPROGRESS_ROUTINE   progressRoutine,
   void*                progressParam,
   BOOL*                cancelFlag,
   DWORD                flags)
{
   ASSERT(!existingFileName.empty());
   ASSERT(!newFileName.empty());

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::CopyFileEx(
         existingFileName.c_str(),
         newFileName.c_str(),
         progressRoutine,
         progressParam,
         cancelFlag,
         flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as there are any number of reasons this may
   // fail that are not unexpected and should be explicitly checked for
   // by the caller.

   return hr;
}



HRESULT
Win::CopySid(DWORD destLengthInBytes, PSID dest, PSID source)
{
   ASSERT(destLengthInBytes);
   ASSERT(dest);
   ASSERT(source);
   ::ZeroMemory(dest, destLengthInBytes);

   HRESULT hr = S_OK;
   
   BOOL succeeded = ::CopySid(destLengthInBytes, dest, source);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));
   
   return hr;
}



HRESULT
Win::CreateDialogParam(
   HINSTANCE      hInstance,	
   const TCHAR*   templateName,
   HWND           owner,
   DLGPROC        dialogProc,
   LPARAM         param,
   HWND&          result)
{
   ASSERT(hInstance);
   ASSERT(templateName);
   ASSERT(dialogProc);
   ASSERT(owner == 0 || Win::IsWindow(owner));

   HRESULT hr = S_OK;

   result =
      ::CreateDialogParam(
         hInstance,
         templateName,
         owner,
         dialogProc,
         param);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));
   ASSERT(Win::IsWindow(result));

   return hr;
}



HRESULT
Win::CreateDirectory(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   // ISSUE-2002/03/06-sburns we're encouraging default SDs. Is that a
   // problem?
   
   BOOL succeeded = ::CreateDirectory(path.c_str(), 0);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as there are any number of reasons this may
   // fail that are not unexpected and should be explicitly checked for
   // by the caller.

   return hr;
}



HRESULT
Win::CreateDirectory(const String& path, const SECURITY_ATTRIBUTES& sa)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::CreateDirectory(
         path.c_str(),
         const_cast<SECURITY_ATTRIBUTES*>(&sa));
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as there are any number of reasons this may
   // fail that are not unexpected and should be explicitly checked for
   // by the caller.

   return hr;
}



HRESULT
Win::CreateEvent(
   SECURITY_ATTRIBUTES* securityAttributes,
   bool                 manualReset,
   bool                 initiallySignaled,
   HANDLE&              result)
{
   // securityAttributes may be null

   HRESULT hr = S_OK;

   result =
      ::CreateEvent(
         securityAttributes,
         manualReset ? TRUE : FALSE,
         initiallySignaled ? TRUE : FALSE,
         0);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateEvent(
   SECURITY_ATTRIBUTES* securityAttributes,
   bool                 manualReset,
   bool                 initiallySignaled,
   const String&        name,
   HANDLE&              result)
{
   // securityAttributes may be null

   ASSERT(!name.empty());

   HRESULT hr = S_OK;

   result =
      ::CreateEvent(
         securityAttributes,
         manualReset ? TRUE : FALSE,
         initiallySignaled ? TRUE : FALSE,
         name.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateFile(
   const String&        fileName,
   DWORD                desiredAccess,	
   DWORD                shareMode,
   SECURITY_ATTRIBUTES* securityAttributes,	
   DWORD                creationDistribution,
   DWORD                flagsAndAttributes,
   HANDLE               hTemplateFile,
   HANDLE&              result)
{
   // securityAttributes may be null

   ASSERT(!fileName.empty());

   HRESULT hr = S_OK;

   result =
      ::CreateFile(
         fileName.c_str(),
         desiredAccess,	
         shareMode,
         securityAttributes,	
         creationDistribution,
         flagsAndAttributes,
         hTemplateFile);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateFontIndirect(
   const LOGFONT& logFont,
   HFONT&         result)
{
   HRESULT hr = S_OK;

   result = ::CreateFontIndirect(&logFont);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateMailslot(
   const String&        name,
   DWORD                maxMessageSize,
   DWORD                readTimeout,
   SECURITY_ATTRIBUTES* attributes,
   HANDLE&              result)
{
   ASSERT(!name.empty());
   ASSERT(readTimeout == 0 || readTimeout == MAILSLOT_WAIT_FOREVER);

   // attributes may be null

   HRESULT hr = S_OK;
   result =
      ::CreateMailslot(
         name.c_str(),
         maxMessageSize,
         readTimeout,
         attributes);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }
      
   // don't assert, as the caller may be explicitly testing for an error.      

   return hr;
}



HRESULT
Win::CreateMutex(
   SECURITY_ATTRIBUTES* attributes,
   bool                 isInitialOwner,
   const String&        name,
   HANDLE&              result)
{
   // securityAttributes may be null

   HRESULT hr = S_OK;
      
   ::SetLastError(0);

   result =
      ::CreateMutex(
         attributes,
         isInitialOwner ? TRUE : FALSE,
         name.empty() ? 0 : name.c_str());

   // If the create fails, then the last error is why it failed.  If it
   // succeeded, then the mutex may have already existed, in which case the
   // last error is ERROR_ALREADY_EXISTS.  If it succeeds, and the mutex
   // didn't already exist, then the last error is 0.

   hr = Win::GetLastErrorAsHresult();

   // don't assert, as the caller may be explicitly testing for an error.      

   return hr;
}



HRESULT
Win::CreatePopupMenu(HMENU& result)
{
   HRESULT hr = S_OK;

   result = ::CreatePopupMenu();
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



// ISSUE-2002/03/07-sburns depricate this

HRESULT
Win::CreateProcess(
   String&              commandLine,
   SECURITY_ATTRIBUTES* processAttributes,
   SECURITY_ATTRIBUTES* threadAttributes,
   bool                 inheritHandles,
   DWORD                creationFlags,
   void*                environment,
   const String&        currentDirectory,
   STARTUPINFO&         startupInformation,
   PROCESS_INFORMATION& processInformation)
{
   ASSERT(!commandLine.empty());
     
   HRESULT hr = S_OK;

   startupInformation.cb = sizeof(STARTUPINFO);
   startupInformation.lpReserved = 0;
   startupInformation.cbReserved2 = 0;
   startupInformation.lpReserved2 = 0;

   memset(&processInformation, 0, sizeof(processInformation));

   size_t len = commandLine.length();
   WCHAR* tempCommandLine = new WCHAR[len + 1];
   
   memset(tempCommandLine, 0, sizeof(WCHAR) * (len + 1));
   commandLine.copy(tempCommandLine, len);
   
   BOOL result =
      ::CreateProcessW(
         0,
         tempCommandLine,
         processAttributes,
         threadAttributes,
         inheritHandles ? TRUE : FALSE,
         creationFlags,
         environment,
         currentDirectory.empty() ? 0 : currentDirectory.c_str(),
         &startupInformation,
         &processInformation);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // The api may have modified the command line

   commandLine = tempCommandLine;
   delete[] tempCommandLine;

   return hr;
}



HRESULT
Win::CreateProcess(
   const String&        applicationFullPathName,
   String&              commandLine,
   DWORD                creationFlags,
   const String&        currentDirectory,
   STARTUPINFO&         startupInformation,
   PROCESS_INFORMATION& processInformation)
{
   // we require full path names, anything else is a security hole.
   
   if (!FS::IsValidPath(applicationFullPathName))
   {
      // your call is bad if you're passing junk
      
      ASSERT(false);
      
      return E_INVALIDARG;
   }

   // if a current directory is specified, make sure it's real


   if (!currentDirectory.empty())
   {
      DWORD attrs = 0;
      FS::PathSyntax syn = FS::GetPathSyntax(currentDirectory);
      
      if (
            // the path isn't full
            
            (syn != FS::SYNTAX_ABSOLUTE_DRIVE && syn != FS::SYNTAX_UNC)

            // or the path does not exist
            
         || FAILED(Win::GetFileAttributes(currentDirectory, attrs))

            // or it does, but it's not a folder
            
         || !(attrs & FILE_ATTRIBUTE_DIRECTORY))
      {
         // if you failed to do these, your call is wrong.
         
         ASSERT(false);
         
         return E_INVALIDARG;
      }
   }
     
   HRESULT hr = S_OK;

   startupInformation.cb = sizeof(STARTUPINFO);
   startupInformation.lpReserved = 0;
   startupInformation.cbReserved2 = 0;
   startupInformation.lpReserved2 = 0;

   // REVIEWED-2002/02/26-sburns correct byte count passed.
   
   ::ZeroMemory(&processInformation, sizeof processInformation);

   // compose the command line parameter, making a temporary copy and
   // pre-pending the application path (per customary usage)
   // NTRAID#NTBUG9-584126-2002/03/25-sburns
   
   // +1 for space separator
   size_t len = commandLine.length() + applicationFullPathName.length() + 1;
   
   WCHAR* tempCommandLine = new WCHAR[len + 1];
   
   // REVIEWED-2002/02/26-sburns correct byte count passed.
   
   ::ZeroMemory(tempCommandLine, sizeof WCHAR * (len + 1));

   // REVIEWED-2002/02/26-sburns correct character count passed.

   size_t appPathLen = applicationFullPathName.length();
   applicationFullPathName.copy(tempCommandLine, appPathLen);
   tempCommandLine[appPathLen] = L' ';
   commandLine.copy(tempCommandLine + appPathLen + 1, commandLine.length());
   
   BOOL result =
      ::CreateProcessW(
         applicationFullPathName.c_str(),
         tempCommandLine,
         0,
         0,
         FALSE,
         creationFlags,
         0,
         currentDirectory.empty() ? 0 : currentDirectory.c_str(),
         &startupInformation,
         &processInformation);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // The api may have modified the command line

   commandLine = tempCommandLine;
   delete[] tempCommandLine;

   return hr;
}



HRESULT
Win::CreatePropertySheetPage(
   const PROPSHEETPAGE& pageInfo,
   HPROPSHEETPAGE&      result)
{
   HRESULT hr = S_OK;

   result = ::CreatePropertySheetPage(&pageInfo);
   if (!result)
   {
      // then what?  The SDK docs don't mention any error code, and an
      // inspection of the code indicates that SetLastError is not called.

      hr = E_FAIL;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateSolidBrush(
   COLORREF color,
   HBRUSH&  result)
{
   HRESULT hr = S_OK;

	result = ::CreateSolidBrush(color);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateStreamOnHGlobal(
   HGLOBAL     hglobal,
   bool        deleteOnRelease,
   IStream*&   result)
{
   ASSERT(hglobal);

   HRESULT hr =
      ::CreateStreamOnHGlobal(
         hglobal,
         deleteOnRelease ? TRUE : FALSE,
         &result);

   ASSERT(SUCCEEDED(hr));
   ASSERT(result);

   return hr;
}



HRESULT
Win::CreateWindowEx(
   DWORD          exStyle,
   const String&  className,
   const String&  windowName,
   DWORD          style,
   int            x,
   int            y,
   int            width,
   int            height,
   HWND           parent,
   HMENU          menuOrChildID,
   void*          param,
   HWND&          result)
{
   // parent may be null

   HRESULT hr = S_OK;

   result =
      ::CreateWindowEx(
         exStyle,
         className.c_str(),
         windowName.c_str(),
         style,
         x,
         y,
         width,
         height,
         parent,
         menuOrChildID,
         GetResourceModuleHandle(),
         param);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::DeleteFile(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL result = ::DeleteFile(path.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure to delete a file is not necessarily a program
   // logic problem.

   return hr;
}



HRESULT
Win::DeleteObject(HGDIOBJ& object)
{
	ASSERT(object);

   HRESULT hr = S_OK;

	BOOL result = ::DeleteObject(object);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // why would you care if the delete failed?  because it might fail if
   // the object was selected into a DC, and that would indicate a bug.

	ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   object = 0;

   return hr;
}



HRESULT
Win::DeleteObject(HFONT& object)
{
   HGDIOBJ o = reinterpret_cast<HGDIOBJ>(object);

   HRESULT hr = Win::DeleteObject(o);

   object = 0;

   return hr;
}



HRESULT
Win::DeleteObject(HBITMAP& object)
{
   HGDIOBJ o = reinterpret_cast<HGDIOBJ>(object);

   HRESULT hr = Win::DeleteObject(o);

   object = 0;

   return hr;
}

HRESULT
Win::DeleteObject(HBRUSH& object)
{
   HGDIOBJ o = reinterpret_cast<HGDIOBJ>(object);

   HRESULT hr = Win::DeleteObject(o);

   object = 0;

   return hr;
}


HRESULT
Win::DestroyIcon(HICON& icon)
{
   ASSERT(icon);

   HRESULT hr = S_OK;

   BOOL result = ::DestroyIcon(icon);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   icon = 0;

   return hr;
}



HRESULT
Win::DestroyMenu(HMENU& menu)
{
   ASSERT(menu);

   HRESULT hr = S_OK;

   BOOL err = ::DestroyMenu(menu);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   menu = 0;

   return hr;
}



HRESULT
Win::DestroyPropertySheetPage(HPROPSHEETPAGE& page)
{
   ASSERT(page);

   HRESULT hr = S_OK;

   BOOL result = ::DestroyPropertySheetPage(page);
   if (!result)
   {
      // There is no documentation indicating that there is an error code,
      // and looking at the source, it appears that the delete will always
      // return true.  So this is probably dead code.

      hr = E_FAIL;
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   page = 0;

   return hr;
}



HRESULT
Win::DestroyWindow(HWND& window)
{
   ASSERT(window == 0 || Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL result = ::DestroyWindow(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the object so we don't use it again.

   window = 0;

   return hr;
}



// templateName must be TCHAR* to support MAKEINTRESOURCE usage

// threadsafe

INT_PTR
Win::DialogBoxParam(
   HINSTANCE      hInstance,	
   const TCHAR*   templateName,
   HWND           owner,
   DLGPROC        dialogProc,
   LPARAM         param)
{
   ASSERT(hInstance);
   ASSERT(templateName);
   ASSERT(dialogProc);
   ASSERT(owner == 0 || Win::IsWindow(owner));

   INT_PTR result =
      ::DialogBoxParam(
         hInstance,
         templateName,
         owner,
         dialogProc,
         param);
   ASSERT(result != -1);

   return result;
}



HRESULT
Win::DrawFocusRect(HDC dc, const RECT& rect)
{
	ASSERT(dc);

   HRESULT hr = S_OK;

	BOOL result = ::DrawFocusRect(dc, &rect);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::Edit_AppendText(
   HWND           editbox,
   const String&  text,
   bool           preserveSelection,
   bool           canUndo)
{
   ASSERT(Win::IsWindow(editbox));
   ASSERT(!text.empty());

   // save the current selection
   int start = 0;
   int end = 0;
   if (preserveSelection)
   {
      Win::Edit_GetSel(editbox, start, end);
   }

   // move the selection to the end
   Win::Edit_SetSel(editbox, INT_MAX, INT_MAX);

   // insert the text
   Win::Edit_ReplaceSel(editbox, text, canUndo);

   // restore the selection
   if (preserveSelection)
   {
      Win::Edit_SetSel(editbox, start, end);
   }
}



void
Win::Edit_GetSel(HWND editbox, int& start, int& end)
{
   ASSERT(Win::IsWindow(editbox));

   LRESULT result =
         Win::SendMessage(
            editbox,
            EM_GETSEL,
            0,
            0);

   ASSERT(result != -1);

   start = LOWORD(result);
   end = HIWORD(result);
}



void
Win::Edit_LimitText(HWND editbox, int limit)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(editbox, EM_LIMITTEXT, static_cast<WPARAM>(limit), 0);
}



void
Win::Edit_ReplaceSel(HWND editbox, const String& newText, bool canUndo)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(
      editbox,
      EM_REPLACESEL,
      canUndo ? TRUE : FALSE,
      reinterpret_cast<LPARAM>(newText.c_str()));
}



void
Win::Edit_SetSel(HWND editbox, int start, int end)
{
   ASSERT(Win::IsWindow(editbox));

   Win::SendMessage(editbox, EM_SETSEL, start, end);
}



bool
Win::EqualSid(PSID sid1, PSID sid2)
{
   ASSERT(IsValidSid(sid1));
   ASSERT(IsValidSid(sid2));

   return ::EqualSid(sid1, sid2) ? true : false;
}



// @@ hresult?  What possible value would it be?

void
Win::EnableWindow(HWND window, bool state)
{
   ASSERT(Win::IsWindow(window));

   // the return value here is of no use.
   ::EnableWindow(window, state ? TRUE : FALSE);
}



HRESULT
Win::EndDialog(HWND dialog, int result)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(result != -1);

   HRESULT hr = S_OK;

   BOOL r = ::EndDialog(dialog, result);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::EnumUILanguages(
   UILANGUAGE_ENUMPROCW proc,
   DWORD                flags,
   LONG_PTR             lParam)
{
   ASSERT(proc);

   HRESULT hr = S_OK;

   BOOL result = ::EnumUILanguagesW(proc, flags, lParam);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ExitWindowsEx(UINT options)
{
   HRESULT hr = S_OK;

   BOOL result = ::ExitWindowsEx(options, 0);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::ExpandEnvironmentStrings(const String& s)
{
   if (s.empty())
   {
      return s;
   }

   // determine the length of the expanded string
   
   DWORD len = ::ExpandEnvironmentStrings(s.c_str(), 0, 0);
   ASSERT(len);

   if (!len)
   {
      return s;
   }

   // +1 for paranoid null terminator
   
   String result(len + 1, 0);
   DWORD len1 =
      ::ExpandEnvironmentStrings(
         s.c_str(),
         const_cast<wchar_t*>(result.data()),

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         len);
   ASSERT(len1 == len);

   if (!len1)
   {
      return s;
   }

   return result;
}



HRESULT
Win::FindFirstFile(
   const String&     fileName,
   WIN32_FIND_DATA&  data,
   HANDLE&           result)
{
   ASSERT(!fileName.empty());

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&data, sizeof WIN32_FIND_DATA);
   result = INVALID_HANDLE_VALUE;

   HRESULT hr = S_OK;

   result = ::FindFirstFile(fileName.c_str(), &data);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert:  not necessarily a program logic error

   return hr;
}



HRESULT
Win::FindClose(HANDLE& findHandle)
{
   ASSERT(findHandle);

   HRESULT hr = S_OK;

   BOOL result = ::FindClose(findHandle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   findHandle = 0;

   return hr;      
}



HRESULT
Win::FindNextFile(HANDLE& findHandle, WIN32_FIND_DATA& data)
{
   ASSERT(findHandle != 0 && findHandle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result = ::FindNextFile(findHandle, &data);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, as caller may be looking for ERROR_NO_MORE_FILES

   return hr;
}



HRESULT
Win::FlushFileBuffers(HANDLE handle)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result = ::FlushFileBuffers(handle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::FrameRect(HDC dc, const RECT& rect, HBRUSH brush)
{
	ASSERT(dc);
	ASSERT(brush);

   HRESULT hr = S_OK;

	int result = ::FrameRect(dc, &rect, brush);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::FreeLibrary(HMODULE& module)
{
   // don't assert; it's legal to free a null module (makes cleanup code
   // cleaner)
   // ASSERT(module);

   HRESULT hr = S_OK;

   if (module)
   {
      BOOL result = ::FreeLibrary(module);
      if (!result)
      {
         hr = Win::GetLastErrorAsHresult();
      }
   }

   ASSERT(SUCCEEDED(hr));

   // rub out the module so we don't reuse it

   module = 0;

   return hr;
}



void
Win::FreeSid(PSID sid)
{
   // Don't assert: it's OK to free a null pointer
   // ASSERT(sid);

   if (sid)
   {
      ::FreeSid(sid);
   }
}



HWND
Win::GetActiveWindow()
{
   return ::GetActiveWindow();
}



HRESULT
Win::GetClassInfoEx(const String& className, WNDCLASSEX& info)
{
   return Win::GetClassInfoEx(0, className, info);
}



HRESULT
Win::GetClassInfoEx(
   HINSTANCE      hInstance,
   const String&  className,
   WNDCLASSEX&    info)
{
   ASSERT(!className.empty());

   // REVIEWED-2002/03/05-sburns correct byte count passed.
      
   ::ZeroMemory(&info, sizeof info);
   
   info.cbSize = sizeof(WNDCLASSEX);

   HRESULT hr = S_OK;

   BOOL result = ::GetClassInfoEx(hInstance, className.c_str(), &info);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetClassName(HWND window)
{
   ASSERT(Win::IsWindow(window));

   // ISSUE-2002/03/04-sburns this implementation is completely bogus. Where
   // did the magic 256 come from?  Should have an implementation where the
   // buffer is grown until the entire result is read.

   WCHAR name[256 + 1];
   
   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(name, sizeof name);
   int result =
      ::GetClassName(
         window,
         name,

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         256);
   ASSERT(result);

   return String(name);
}



String
Win::GetClipboardFormatName(UINT format)
{
   ASSERT(format);

   // ISSUE-2002/03/04-sburns this implementation is completely bogus. Where
   // did the magic 256 come from?  Should have an implementation where the
   // buffer is grown until the entire result is read.
   
   String s(256 + 1, 0);
   int result =
      ::GetClipboardFormatName(
         format,
         const_cast<wchar_t*>(s.c_str()),

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         256);
   ASSERT(result);
   s.resize(result);

   return s;
}



HRESULT
Win::GetClientRect(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL result = ::GetClientRect(window, &rect);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetColorDepth(int& result)
{
   result = 0;

   HRESULT hr = S_OK;

   do
   {
      HDC hdc = 0;
      hr = Win::GetDC(NULL, hdc);
      BREAK_ON_FAILED_HRESULT(hr);

      result = Win::GetDeviceCaps(hdc, BITSPIXEL);
      Win::ReleaseDC(NULL, hdc);
   }
   while (0);

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetCommandLine()
{
   PTSTR line = ::GetCommandLine();
   ASSERT(line);

   return String(line);
}



// ISSUE-2000/10/31-sburns CODEWORK: this usage should be preferred, as in the case of DNS names,
// if tcp/ip is not installed, GetComputerNameEx will fail.

HRESULT
Win__GetComputerNameEx(COMPUTER_NAME_FORMAT format, String& result)
{
   result.erase();

   HRESULT hr = S_OK;
   TCHAR* buf = 0;

   do
   {   
      // first call to determine buffer size

      DWORD bufSize = 0;
      BOOL succeeded = ::GetComputerNameEx(format, 0, &bufSize);

      // we expect it to fail with ERROR_MORE_DATA. If it has failed for
      // some other cause, we will allocate a tiny buffer, and try again.
      // The second attempt will also fail, and we will error out of the
      // function.

      ASSERT(!succeeded);
      ASSERT(::GetLastError() == ERROR_MORE_DATA);

      // second call to retrieve the name

      DWORD bufSize2 = bufSize + 1;   
      buf = new WCHAR[bufSize2];

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(buf, bufSize2 * sizeof WCHAR);

      succeeded = ::GetComputerNameEx(format, buf, &bufSize);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      ASSERT(bufSize <= bufSize2);

      result = buf;
   }
   while (0);

   if (buf)
   {
      delete[] buf;
   }

   return hr;
}



String
Win::GetComputerNameEx(COMPUTER_NAME_FORMAT format)
{
   String result;

   Win__GetComputerNameEx(format, result);

   // don't assert success: the given name type may not be present (e.g.
   // if tcp/ip is not installed, no DNS names are available)

   return result;
}



HRESULT
Win::GetCurrentDirectory(String& result)
{
   wchar_t buf[MAX_PATH + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, (MAX_PATH + 1) * sizeof(wchar_t));

   result.erase();
   HRESULT hr = S_OK;

   // REVIEWED-2002/03/06-sburns correct character count passed

   // ISSUE-2002/03/06-sburns probably would be a good idea to make two
   // calls, one to get the buffer size needed, another to fill it.
   
   DWORD r = ::GetCurrentDirectory(MAX_PATH, buf);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else
   {
      result = buf;
   }

   return hr;
}



HANDLE
Win::GetCurrentProcess()
{
   HANDLE result = ::GetCurrentProcess();
   ASSERT(result);

   return result;
}



HRESULT
Win::GetCursorPos(POINT& result)
{
   HRESULT hr = S_OK;
   result.x = 0;
   result.y = 0;
   BOOL err = ::GetCursorPos(&result);
   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetDC(HWND window, HDC& result)
{
   ASSERT(window == 0 || Win::IsWindow(window));

   HRESULT hr = S_OK;

   result = ::GetDC(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::GetDesktopWindow()
{
   return ::GetDesktopWindow();
}



int
Win::GetDeviceCaps(HDC hdc, int index)
{
   ASSERT(hdc);
   ASSERT(index > 0);

   return ::GetDeviceCaps(hdc, index);
}



HRESULT
Win::GetDiskFreeSpaceEx(
   const String&     path,
   ULARGE_INTEGER&   available,
   ULARGE_INTEGER&   total,
   ULARGE_INTEGER*   freespace)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL result =
      ::GetDiskFreeSpaceEx(path.c_str(), &available, &total, freespace);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::GetDlgItem(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HWND item = ::GetDlgItem(parentDialog, itemResID);
   ASSERT(item);

   return item;
}



String
Win::GetDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID);

   HWND h = Win::GetDlgItem(parentDialog, itemResID);
   ASSERT(Win::IsWindow(h));

   return Win::GetWindowText(h);
}


int
Win::GetDlgItemInt(HWND parentDialog, int itemResID, bool isSigned)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID);

   BOOL success = TRUE;
   int result = ::GetDlgItemInt(
                   parentDialog, 
                   itemResID,
                   &success,
                   isSigned);

   ASSERT(success);
   return result;
}


UINT
Win::GetDriveType(const String& path)
{
   ASSERT(path[1] == L':');

   // The Win32 function requires a path containing just the root directory,
   // so determine what that is

   String rootDir;
   if (path.length() > ROOTDIR_SIZE)
   {
      rootDir = path.substr(0, ROOTDIR_SIZE);
   }
   else
   {
      rootDir = path;
   }
      
   return ::GetDriveType(rootDir.c_str());
}



EncryptedString
Win::GetEncryptedDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   EncryptedString retval;
   WCHAR* cleartext = 0;
   int length = 0;
   
   do
   {
      HWND item = Win::GetDlgItem(parentDialog, itemResID);
      if (!item)
      {
         break;
      }

      length = ::GetWindowTextLengthW(item);
      if (!length)
      {
         break;
      }

      // add 1 to length for null-terminator
   
      ++length;
      cleartext = new WCHAR[length];

      // REVIEWED-2002/03/01-sburns correct byte count passed.
      
      ::ZeroMemory(cleartext, length * sizeof WCHAR);

      // REVIEWED-2002/03/01-sburns length includes space for null terminator
      // which is correct for this call.
           
      int result = ::GetWindowText(item, cleartext, length);

      ASSERT(result == length - 1);

      if (!result)
      {
         break;
      }

      retval.Encrypt(cleartext);
   }
   while (0);
   
   // make sure we scribble out the cleartext.

   if (cleartext)
   {
      // REVIEWED-2002/03/01-sburns correct byte count passed.
      
      ::SecureZeroMemory(cleartext, length * sizeof WCHAR);
      delete[] cleartext;
   }

   return retval;
}

   
   
String
Win::GetEnvironmentVariable(const String& name)
{
   ASSERT(!name.empty());

   // determine the size of the result, in characters
   
   DWORD chars = ::GetEnvironmentVariable(name.c_str(), 0, 0);

   if (chars)
   {
      String retval(chars + 1, 0);

      DWORD result =
         ::GetEnvironmentVariable(
            name.c_str(),
            const_cast<WCHAR*>(retval.c_str()),

            // REVIEWED-2002/03/06-sburns correct character count passed
            
            chars);

      // -1 because the first call includes the null terminator, the
      // second does not
      
      ASSERT(result == (chars - 1));

      return retval;
   }

   return String();
}



HRESULT
Win::GetExitCodeProcess(HANDLE hProcess, DWORD& exitCode)
{
   ASSERT(hProcess);

   HRESULT hr = S_OK;

   exitCode = 0;
   BOOL result = ::GetExitCodeProcess(hProcess, &exitCode);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetFileAttributes(const String& path, DWORD& result)
{
   ASSERT(!path.empty());

   result = 0;

   HRESULT hr = S_OK;

   result = ::GetFileAttributes(path.c_str());
   if (result == INVALID_FILE_ATTRIBUTES)
   {
      result = 0;
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: caller may be testing for the presence of a file.

   return hr;
}



HRESULT
Win::GetFileSizeEx(HANDLE handle, LARGE_INTEGER& result)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&result, sizeof result);

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetFileSizeEx(handle, &result);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



DWORD
Win::GetFileType(HANDLE handle)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);

   return ::GetFileType(handle);
}



HRESULT
Win::GetFullPathName(const String& path, String& result)
{
   ASSERT(!path.empty());
   ASSERT(path.length() <= MAX_PATH);

   result.erase();

   HRESULT hr = S_OK;

// ISSUE-2002/02/22-sburns do something like this here   
// #ifdef DBG
// 
//    // on chk builds, use a small buffer size so that our growth algorithm
//    // gets exercised
//    
//    unsigned      bufSizeInCharacters = 3;
// 
// #else
//    unsigned      bufSizeInCharacters = 1023;
// #endif

   unsigned bufchars = MAX_PATH;
   wchar_t* buf = 0;

   // don't retry more than 3 times...

   while (bufchars < MAX_PATH * 4)
   {
      buf = new wchar_t[bufchars];

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(buf, bufchars * sizeof wchar_t);

      wchar_t* unused = 0;
      DWORD x =
         ::GetFullPathName(
            path.c_str(),

            // REVIEWED-2002/03/06-sburns correct character count passed
            
            bufchars,
            buf,
            &unused);
      if (x == 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }
      if (x > MAX_PATH)
      {
         // buffer too small.  Not likely, as we passed in MAX_PATH characters.

         ASSERT(false);

         delete[] buf;
         buf = 0;
         bufchars *= 2;
         continue;
      }

      result = buf;
      break;
   }

   delete[] buf;

   return hr;
}



HRESULT
Win::GetLastErrorAsHresult()
{
   DWORD err = ::GetLastError();
   return HRESULT_FROM_WIN32(err);
}



void
Win::GetLocalTime(SYSTEMTIME& time)
{
   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&time, sizeof time);

   ::GetLocalTime(&time);
}

HRESULT
Win::GetDateFormat(
   const SYSTEMTIME& date,
   String& formattedDate,
   LCID locale,
   DWORD flags)
{
   HRESULT hr = S_OK;

   wchar_t* buffer = 0;

   do
   {
      int charsNeeded = ::GetDateFormat(
                           locale,
                           flags,
                           &date,
                           0,
                           buffer,
                           0);

      if (charsNeeded <= 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      buffer = new wchar_t[charsNeeded];

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(buffer, charsNeeded * sizeof wchar_t);

      int charsUsed = ::GetDateFormat(
                         locale,
                         flags,
                         &date,
                         0,
                         buffer,
                         charsNeeded);

      if (charsUsed <= 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      formattedDate = buffer;

   } while (false);

   delete[] buffer;
   
   return hr;
}



HRESULT
Win::GetTimeFormat(
   const SYSTEMTIME& time,
   String& formattedTime,
   LCID locale,
   DWORD flags)
{
   HRESULT hr = S_OK;

   do
   {
      wchar_t* buffer = 0;
      int charsNeeded = ::GetTimeFormat(
                           locale,
                           flags,
                           &time,
                           0,
                           buffer,
                           0);

      if (charsNeeded <= 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      buffer = new wchar_t[charsNeeded];

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(buffer, charsNeeded * sizeof wchar_t);

      int charsUsed = ::GetTimeFormat(
                         locale,
                         flags,
                         &time,
                         0,
                         buffer,
                         charsNeeded);

      if (charsUsed <= 0)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      formattedTime = buffer;

      delete[] buffer;

   } while (false);

   return hr;
}



HRESULT
Win::GetLogicalDriveStrings(size_t bufChars, WCHAR* buf, DWORD& result)
{

#ifdef DBG
   // if buf == 0, then bufChars must also (this would be the case where
   // the caller is attempting to determine the size of the buffer needed.
   // (if C++ supported a logical xor, denoted by ^^, then this expression
   // would be: ASSERT(!(bufChars ^^ buf)

   if (!buf)
   {
      ASSERT(!bufChars);
   }
   
   if (bufChars)
   {
      ASSERT(buf);

      // Make sure that the buffer is at least bufChars + 1 characters long
      // If it ain't this will AV under pageheap (which is what we want)
      
      ::ZeroMemory(buf, (bufChars + 1) * sizeof WCHAR);
   }

   ASSERT(bufChars < ULONG_MAX);

#endif

   HRESULT hr = S_OK;

   DWORD buflen = static_cast<DWORD>(bufChars);
   result = ::GetLogicalDriveStrings(buflen, buf);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

#ifdef DBG

   if (bufChars)
   {
      // check that the buffer supplied was large enough to hold the result

      ASSERT(bufChars >= result);

      // and that the result was double null-terminated

      ASSERT(!buf[result] && !buf[result - 1]);
   }
   
   ASSERT(SUCCEEDED(hr));
#endif   

   return hr;
}



HRESULT
Win::GetMailslotInfo(
   HANDLE   mailslot,
   DWORD*   maxMessageSize,
   DWORD*   nextMessageSize,
   DWORD*   messageCount,
   DWORD*   readTimeout)
{
   ASSERT(mailslot != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL result =
      ::GetMailslotInfo(
         mailslot,
         maxMessageSize,
         nextMessageSize,
         messageCount,
         readTimeout);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetModuleFileName(HMODULE hModule)
{
   // Don't assert hModule: null means "current module"

   String retval;

#ifdef DBG

   // on chk builds, use a small buffer size so that our growth algorithm
   // gets exercised
   
   unsigned      bufSizeInCharacters = 1;

#else
   unsigned      bufSizeInCharacters = MAX_PATH;
#endif

   PWSTR buffer = 0;

   do
   {
      // +1 for extra null-termination paranoia
      
      buffer = new WCHAR[bufSizeInCharacters + 1];

      // REVIEWED-2002/02/22-sburns byte count correctly passed in
            
      ::ZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);

      // REVIEWED-2002/02/22-sburns call correctly passes size in characters.
      
      DWORD result =
         ::GetModuleFileName(hModule, buffer, bufSizeInCharacters);

      if (!result)
      {
         break;
      }

      if (result == bufSizeInCharacters)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         delete[] buffer;

         bufSizeInCharacters *= 2;
         if (bufSizeInCharacters > USHRT_MAX)   // effectively ~32K max
         {
            // too big. way too big. We'll make do with the truncated value.

            ASSERT(false);
            break;
         }
         continue;
      }

      // copy the result, which should be null-terminated.

      ASSERT(buffer[result] == 0);
      
      retval = buffer;
      break;
   }
   while (true);

   delete[] buffer;

   // it's pretty unlikely that this would fail.
   
   ASSERT(!retval.empty());
   
   return retval;
}



HINSTANCE
Win::GetModuleHandle()
{
   HINSTANCE result = ::GetModuleHandle(0);
   ASSERT(result);

   return result;
}



HWND
Win::GetParent(HWND child)
{
   ASSERT(Win::IsWindow(child));

   HWND retval = ::GetParent(child);

   // you probably are doing something wrong if you ask for the
   // parent of an orphan.
   ASSERT(retval);

   return retval;
}



String
Win::GetPrivateProfileString(
   const String& section,
   const String& key,
   const String& defaultValue,
   const String& filename)
{
   ASSERT(!section.empty());
   ASSERT(!key.empty());
   ASSERT(!filename.empty());

   // our first call is with a large buffer, hoping that it will suffice...

   String retval;

#ifdef DBG

   // on chk builds, use a small buffer size so that our growth algorithm
   // gets exercised
   
   unsigned      bufSizeInCharacters = 3;

#else
   unsigned      bufSizeInCharacters = 1023;
#endif

   PWSTR buffer = 0;

   do
   {
      // +1 for extra null-termination paranoia
      
      buffer = new WCHAR[bufSizeInCharacters + 1];

      // REVIEWED-2002/02/22-sburns byte count correctly passed in
            
      ::ZeroMemory(buffer, (bufSizeInCharacters + 1) * sizeof WCHAR);

      DWORD result =

      // REVIEWED-2002/02/22-sburns call correctly passes size in characters.
      
         ::GetPrivateProfileString(
            section.c_str(),
            key.c_str(),
            defaultValue.c_str(),
            buffer,
            bufSizeInCharacters,
            filename.c_str());

      if (!result)
      {
         break;
      }

      // A value was found.  check to see if it was truncated. neither
      // lpAppName nor lpKeyName were null, so check result against character
      // count - 1

      if (result == bufSizeInCharacters - 1)
      {
         // buffer was too small, so the value was truncated.  Resize the
         // buffer and try again.

         delete[] buffer;

         bufSizeInCharacters *= 2;
         if (bufSizeInCharacters > USHRT_MAX)   // effectively ~32K max
         {
            // too big. way too big. We'll make do with the truncated value.

            ASSERT(false);
            break;
         }
         continue;
      }

      // copy the result, which should be null-terminated.

      ASSERT(buffer[result] == 0);

      retval = buffer;
      break;
   }

   //lint -e506   ok that this looks like "loop forever"
      
   while (true);

   delete[] buffer;
   return retval;
}



HRESULT
Win::GetProcAddress(
   HMODULE        module,
   const String&  procName,
   FARPROC&       result)
{
   ASSERT(module);
   ASSERT(!procName.empty());

   HRESULT hr = S_OK;

   result = 0;

   // convert the name from unicode to ansi

   AnsiString pn;
   String::ConvertResult r = procName.convert(pn);
   ASSERT(r == String::CONVERT_SUCCESSFUL);

   result = ::GetProcAddress(module, pn.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetStringTypeEx(
   LCID           localeId,
   DWORD          infoTypeOptions,
   const String&  sourceString,
   WORD*          charTypeInfo)
{
   ASSERT(localeId);
   ASSERT(infoTypeOptions);
   ASSERT(!sourceString.empty());
   ASSERT(charTypeInfo);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::GetStringTypeEx(
         localeId,
         infoTypeOptions,
         sourceString.c_str(),
         static_cast<int>(sourceString.length()),
         charTypeInfo);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



DWORD
Win::GetSysColor(int element)
{
	ASSERT(element);

	DWORD result = ::GetSysColor(element);
   ASSERT(result);

   return result;
}

HBRUSH
Win::GetSysColorBrush(int element)
{
   ASSERT(element);

   HBRUSH result = ::GetSysColorBrush(element);
   ASSERT(result);

   return result;
}


int
Win::GetSystemMetrics(int index)
{
   // should assert that index is an SM_ value

   int result = ::GetSystemMetrics(index);

   // Do not assert the result because some of the
   // metrics return 0 as a valid result. For instance
   // SM_REMOTESESSION will return 0 if the process
   // is running on the console
   // ASSERT(result);

   return result;
}



String
Win::GetSystemDirectory()
{
   // ISSUE-2002/03/06-sburns too small: see docs
   
   wchar_t buf[MAX_PATH + 1];

   // REVIEWED-2002/03/07-sburns correct byte count passed
   
   ::ZeroMemory(buf, sizeof buf);

   // ISSUE-2002/03/06-sburns get rid of the fallback path, and make an
   // earlier call to determine the size of the buffer needed.
   
   UINT result = ::GetSystemDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);
   if (result == 0 || result > MAX_PATH)
   {
      // fall back to a reasonable default
      return
            Win::GetSystemWindowsDirectory()
         +  L"\\"
         +  String::load(IDS_SYSTEM32);
   }

   return String(buf);
}


// should use GetSystemWindowsDirectory instead

// String
// Win::GetSystemRootDirectory()
// {
//    static const wchar_t* SYSTEMROOT = L"%systemroot%";
// 
//    wchar_t buf[MAX_PATH + 1];
// 
//    DWORD result =
//       ::ExpandEnvironmentStrings(
//          SYSTEMROOT,
//          buf,
//          MAX_PATH + 1);
//    ASSERT(result != 0 && result <= MAX_PATH);
//    if (result == 0 || result > MAX_PATH)
//    {
//       return String();
//    }
// 
//    return String(buf);
// }



// CODEWORK: should replace this with a version that returns an HRESULT
// like GetTempPath

String
Win::GetSystemWindowsDirectory()
{
   wchar_t buf[MAX_PATH + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, sizeof buf);

   // ISSUE-2002/03/06-sburns should probably make an earlier call to
   // determine the length of the buffer
   
   UINT result = ::GetSystemWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   return String(buf);
}



HRESULT
Win::GetTempPath(String& result)
{
   wchar_t buf[MAX_PATH + 1];
   
   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, sizeof buf);

   HRESULT hr = S_OK;
   result.erase();
   
   // ISSUE-2002/03/06-sburns should make an earlier call to determine
   // the size of the buffer and get rid of the silly error path
   
   DWORD err = ::GetTempPathW(MAX_PATH, buf);
   ASSERT(err != 0 && err <= MAX_PATH);

   if (!err)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else if (err > MAX_PATH)
   {
      // buffer too small: unlikely!

      hr = Win32ToHresult(ERROR_INSUFFICIENT_BUFFER);
   }
   else
   {
      result = buf;
   }

   return hr;
}
      
   
   
HRESULT
Win::GetTextExtentPoint32(
   HDC            hdc,
   const String&  str,
   SIZE&          size)
{
   ASSERT(hdc);
   ASSERT(hdc != INVALID_HANDLE_VALUE);

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&size, sizeof SIZE);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::GetTextExtentPoint32(
         hdc,
         str.c_str(),
         static_cast<int>(str.length()),
         &size);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetTextMetrics(HDC hdc, TEXTMETRIC& tmet)
{
   ASSERT(hdc);
   ASSERT(hdc != INVALID_HANDLE_VALUE);

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&tmet, sizeof TEXTMETRIC);

   HRESULT hr = S_OK;

   BOOL succeeded =::GetTextMetrics(hdc, &tmet);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::FreeTokenInformation(TOKEN_USER* userInfo)
{
   delete[] reinterpret_cast<BYTE*>(userInfo);
}



// caller should free the result with Win::FreeTokenInformation

HRESULT
GetTokenInformationHelper(
   HANDLE                  hToken,   
   TOKEN_INFORMATION_CLASS infoClass,
   BYTE*&                  result)   
{
   ASSERT(hToken != INVALID_HANDLE_VALUE);
   ASSERT(!result);

   HRESULT hr = S_OK;
   result = 0;

   do
   {
      // first, determine the size of the buffer we'll need

      DWORD bufSize = 0;
      BOOL succeeded =
         ::GetTokenInformation(hToken, infoClass, 0, 0, &bufSize);

      if (succeeded)
      {
         // we expect failure...

         ASSERT(false);
         hr = E_UNEXPECTED;
         break;
      }

      hr = Win::GetLastErrorAsHresult();
      if (hr != Win32ToHresult(ERROR_INSUFFICIENT_BUFFER))
      {
         // we failed for some other reason than buffer too small.

         break;
      }

      ASSERT(bufSize);

      // erase the last error (the insuff. buffer error)
      
      hr = S_OK;
      
      result = new BYTE[bufSize];

      // REVIEWED-2002/03/06-sburns correct byte count passed

      ::ZeroMemory(result, bufSize);

      succeeded =
      
         // REVIEWED-2002/03/06-sburns correct byte count passed
         
         ::GetTokenInformation(hToken, infoClass, result, bufSize, &bufSize);
      if (!succeeded)
      {
         delete[] result;
         result = 0;
         hr = Win::GetLastErrorAsHresult();
         break;
      }
   }
   while (0);

   return hr;
}



HRESULT
Win::GetTokenInformation(HANDLE hToken, TOKEN_USER*& userInfo)
{
   ASSERT(hToken != INVALID_HANDLE_VALUE);
   ASSERT(!userInfo);

   userInfo = 0;

   BYTE* result = 0;
   HRESULT hr = GetTokenInformationHelper(hToken, TokenUser, result);
   if (SUCCEEDED(hr))
   {
      userInfo = reinterpret_cast<TOKEN_USER*>(result);
   }
   else
   {
      ASSERT(false);
   }

   return hr;
}



String
Win::GetTrimmedDlgItemText(HWND parentDialog, int itemResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HWND item = Win::GetDlgItem(parentDialog, itemResID);
   if (!item)
   {
      // The empty string
      return String();
   }

   return Win::GetWindowText(item).strip(String::BOTH);
}



String
Win::GetTrimmedWindowText(HWND window)
{
   // Win::GetWindowText does validation of the window
   
   return Win::GetWindowText(window).strip(String::BOTH);
}



HRESULT
Win::GetVersionEx(OSVERSIONINFO& info)
{
   // REVIEWED-2002/03/01-sburns correct byte count passed.
   
   ::ZeroMemory(&info, sizeof OSVERSIONINFO);
   info.dwOSVersionInfoSize = sizeof OSVERSIONINFO;

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetVersionEx(&info);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetVersionEx(OSVERSIONINFOEX& info)
{
   // REVIEWED-2002/02/25-sburns byte count correctly passed
   
   ::ZeroMemory(&info, sizeof OSVERSIONINFOEX);
   
   info.dwOSVersionInfoSize = sizeof OSVERSIONINFOEX;

   HRESULT hr = S_OK;

   BOOL succeeded = ::GetVersionEx(reinterpret_cast<OSVERSIONINFO*>(&info));
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}

void
Win::GetSystemInfo(SYSTEM_INFO& info)
{
   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&info, sizeof SYSTEM_INFO);

   ::GetSystemInfo(reinterpret_cast<SYSTEM_INFO*>(&info));
}



HRESULT
Win::GetVolumeInformation(
   const String&  volume,
   String*        name,
   DWORD*         serialNumber,
   DWORD*         maxFilenameLength,
   DWORD*         flags,
   String*        fileSystemName)
{
   ASSERT(volume.length() >= ROOTDIR_SIZE);

   HRESULT hr = S_OK;

   if (name)
   {
      name->erase();
   }
   if (serialNumber)
   {
      *serialNumber = 0;
   }
   if (maxFilenameLength)
   {
      *maxFilenameLength = 0;
   }
   if (flags)
   {
      *flags = 0;
   }
   if (fileSystemName)
   {
      fileSystemName->erase();
   }

   WCHAR volNameBuf[MAX_PATH + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(volNameBuf, sizeof volNameBuf);

   WCHAR filesysName[MAX_PATH + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(filesysName, sizeof filesysName);

   BOOL succeeded =
      ::GetVolumeInformation(
         volume.c_str(),
         volNameBuf,

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         MAX_PATH,
         serialNumber,
         maxFilenameLength,
         flags,
         filesysName,

         // REVIEWED-2002/03/06-sburns correct character count passed

         MAX_PATH);
   if (succeeded)
   {
      if (name)
      {
         name->assign(volNameBuf);
      }
      if (fileSystemName)
      {
         fileSystemName->assign(filesysName);
      }
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: some devices (like floppy drives) may respond with
   // not ready, and that's not necessarily a logic error.

   return hr;
}



HRESULT
Win::GetWindowDC(HWND window, HDC& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;

   result = ::GetWindowDC(window);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HFONT
Win::GetWindowFont(HWND window)
{
   ASSERT(Win::IsWindow(window));

   return
      reinterpret_cast<HFONT>(
         Win::SendMessage(window, WM_GETFONT, 0, 0));
}



HRESULT
Win::GetWindowPlacement(HWND window, WINDOWPLACEMENT& placement)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&placement, sizeof WINDOWPLACEMENT);
   
   placement.length = sizeof(WINDOWPLACEMENT);

   BOOL succeeded = ::GetWindowPlacement(window, &placement);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetWindowRect(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&rect, sizeof RECT);

   BOOL succeeded = ::GetWindowRect(window, &rect);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetWindowsDirectory()
{
   wchar_t buf[MAX_PATH + 1];

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(buf, sizeof wchar_t * (MAX_PATH + 1));

   // ISSUE-2002/03/06-sburns might be a good idea to make an earlier call to
   // determine the necessary buffer size.
   
   UINT result = ::GetWindowsDirectory(buf, MAX_PATH);
   ASSERT(result != 0 && result <= MAX_PATH);

   return String(buf);
}



HRESULT
Win::GetWindowLong(HWND window, int index, LONG& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;

   ::SetLastError(NO_ERROR);

   result = ::GetWindowLongW(window, index);
   if (!result)
   {
      // in the event that the value extracted really is 0, this will
      // return NO_ERROR, which equals S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GetWindowLongPtr(HWND window, int index, LONG_PTR& result)
{
   ASSERT(Win::IsWindow(window));

   result = 0;

   HRESULT hr = S_OK;
      
   ::SetLastError(NO_ERROR);

   result = ::GetWindowLongPtrW(window, index);
   if (!result)
   {
      // in the event that the value extracted really is 0, this will
      // return NO_ERROR, which equals S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



String
Win::GetWindowText(HWND window)
{
   ASSERT(Win::IsWindow(window));

   size_t length = ::GetWindowTextLengthW(window);
   if (length == 0)
   {
      return String();
   }

   // +1 for null terminator
   
   String s(length + 1, 0);
   size_t result =
      ::GetWindowTextW(
         window,
         const_cast<wchar_t*>(s.c_str()),

         // REVIEWED-2002/03/01-sburns +1 here is ok: the call handles null
         // termination.
         
         static_cast<int>(length + 1));
         
   ASSERT(result == length);
   if (!result)
   {
      return String();
   }
   s.resize(result);
   return s;
}



HRESULT
Win::GlobalAlloc(UINT flags, size_t bytes, HGLOBAL& result)
{
   ASSERT(flags);
   ASSERT(bytes);

   result = 0;

   HRESULT hr = S_OK;

   result = ::GlobalAlloc(flags, bytes);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalFree(HGLOBAL mem)
{
   ASSERT(mem);

   HRESULT hr = S_OK;

   HGLOBAL result = ::GlobalFree(mem);

   // note that success == null

   if (result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalLock(HGLOBAL mem, PVOID& result)
{
   ASSERT(mem);

   result = 0;

   HRESULT hr = S_OK;

   result = ::GlobalLock(mem);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::GlobalUnlock(HGLOBAL mem)
{
   ASSERT(mem);

   HRESULT hr = S_OK;

   BOOL succeeded = ::GlobalUnlock(mem);
   if (!succeeded)
   {
      // if there was no error, then this will be S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



void
Win::HtmlHelp(
   HWND           caller,
   const String&  file,
   UINT           command,
   DWORD_PTR      data)
{
   // Do not assert that caller is a window
   // The caller can be null if we don't want
   // an owner for the help window. By not having
   // an owner the caller's window can be moved
   // to the foreground over the help window

   ASSERT(!file.empty());

   (void) ::HtmlHelpW(caller, file.c_str(), command, data);

   // This return value is not a reliable indicator of success or failure,
   // as according to the docs, what's returned depends on the command.
   // 
}


int
Win::ImageList_Add(HIMAGELIST list, HBITMAP image, HBITMAP mask)
{
   ASSERT(list);
   ASSERT(image);

   int result = ::ImageList_Add(list, image, mask);
   ASSERT(result != -1);

   return result;
}

int
Win::ImageList_AddIcon(HIMAGELIST hlist, HICON hicon)
{
   ASSERT(hlist);
   ASSERT(hicon);

   int result = ::ImageList_ReplaceIcon(hlist, -1, hicon);
   ASSERT(result != -1);

   return result;
}

int
Win::ImageList_AddMasked(HIMAGELIST list, HBITMAP bitmap, COLORREF mask)
{
   ASSERT(list);
   ASSERT(bitmap);

   int result = ::ImageList_AddMasked(list, bitmap, mask);

   ASSERT(result != -1);

   return result;
}


HIMAGELIST
Win::ImageList_Create(
   int      pixelsx, 	
   int      pixelsy, 	
   UINT     flags, 	
   int      initialSize, 	
   int      reserve)
{
   ASSERT(pixelsy == pixelsx);
   ASSERT(initialSize);

   HIMAGELIST result =
      ::ImageList_Create(pixelsx, pixelsy, flags, initialSize, reserve);
   ASSERT(result);

   return result;
}



LONG
Win::InterlockedDecrement(LONG& addend)
{
   return ::InterlockedDecrement(&addend);
}



LONG
Win::InterlockedIncrement(LONG& addend)
{
   return ::InterlockedIncrement(&addend);
}



bool
Win::IsDlgButtonChecked(HWND parentDialog, int buttonResID)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(buttonResID > 0);

   if (
      ::IsDlgButtonChecked(
         parentDialog,
         buttonResID) == BST_CHECKED)
   {
      return true;
   }

   return false;
}



bool
Win::IsWindow(HWND candidate)
{
   return ::IsWindow(candidate) ? true : false;
}



bool
Win::IsWindowEnabled(HWND window)
{
   ASSERT(Win::IsWindow(window));

   return ::IsWindowEnabled(window) ? true : false;
}



int
Win::ListBox_AddString(HWND box, const String& s)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(!s.empty());

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_ADDSTRING,
               0,
               reinterpret_cast<LPARAM>(s.c_str()))));

   ASSERT(result != LB_ERR);
   ASSERT(result != LB_ERRSPACE);

   return result;
}


int 
Win::ListBox_SetItemData(HWND box, int index, LPARAM value)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_SETITEMDATA,
               index,
               value)));
   
   ASSERT(result != LB_ERR);

   return result;
}

int 
Win::ListBox_SetCurSel(HWND box, int index)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_SETCURSEL,
               index,
               0)));
   
   ASSERT(result != LB_ERR);

   return result;
}

int 
Win::ListBox_GetCurSel(HWND box)
{
   ASSERT(Win::IsWindow(box));

   int result =
      static_cast<int>(
         static_cast<DWORD>(
            Win::SendMessage(
               box,
               LB_GETCURSEL,
               0,
               0)));
   
   // Don't assert that result != LB_ERR because
   // it is LB_ERR if nothing is selected which
   // may be correct for some uses

   return result;
}



LPARAM 
Win::ListBox_GetItemData(HWND box, int index)
{
   ASSERT(Win::IsWindow(box));
   ASSERT(index >= 0);

   LPARAM result =
      static_cast<LPARAM>(
         Win::SendMessage(
            box,
            LB_GETITEMDATA,
            index,
            0));
   
   ASSERT(result != LB_ERR);

   return result;
}



bool
Win::ListView_DeleteAllItems(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            listview,
            LVM_DELETEALLITEMS,
            0,
            0));

   ASSERT(result);

   return result ? true : false;
}



bool
Win::ListView_DeleteItem(HWND listview, int item)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(item >= 0);

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            listview,
            LVM_DELETEITEM,
            static_cast<WPARAM>(item),
            0));

   ASSERT(result);

   return result ? true : false;
}



bool
Win::ListView_GetItem(HWND listview, LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      static_cast<BOOL>(
            Win::SendMessage(
            listview,
            LVM_GETITEM,
            0,
            reinterpret_cast<LPARAM>(&item)));

   // You shouldn't ask for items that don't exist!

   ASSERT(result);

   return result ? true : false;
}



int
Win::ListView_GetItemCount(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(Win::SendMessage(listview, LVM_GETITEMCOUNT, 0, 0));

   ASSERT(result >= 0);

   return result;
}



UINT
Win::ListView_GetItemState(HWND listview, int index, UINT mask)
{
   ASSERT(Win::IsWindow(listview));

   return (UINT) Win::SendMessage(listview, LVM_GETITEMSTATE, index, mask);
}



int
Win::ListView_GetSelectedCount(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result = (int) Win::SendMessage(listview, LVM_GETSELECTEDCOUNT, 0, 0);

   return result;
}



int
Win::ListView_GetSelectionMark(HWND listview)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(listview, LVM_GETSELECTIONMARK, 0, 0));

   return result;
}



int
Win::ListView_InsertColumn(HWND listview, int index, const LVCOLUMN& column)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(
            listview,
            LVM_INSERTCOLUMN,
            static_cast<WPARAM>(index),
            reinterpret_cast<LPARAM>(&column)));
   ASSERT(result != -1);

   return result;
}



int
Win::ListView_InsertItem(HWND listview, const LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   int result =
      static_cast<int>(
         Win::SendMessage(
            listview,
            LVM_INSERTITEM,
            0,
            reinterpret_cast<LPARAM>(&item)));
   ASSERT(result != -1);

   return result;
}



bool
Win::ListView_SetColumnWidth(HWND listview, int col, int cx)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            listview,
            LVM_SETCOLUMNWIDTH,
            col,
            cx));

   ASSERT(result);

   return result ? true : false;
}


    
DWORD
Win::ListView_SetExtendedListViewStyle(HWND listview, DWORD exStyle)
{
   return Win::ListView_SetExtendedListViewStyleEx(listview, 0, exStyle);
}



DWORD
Win::ListView_SetExtendedListViewStyleEx(
   HWND  listview,
   DWORD mask,
   DWORD exStyle)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(exStyle);

   // mask may be 0

   DWORD result =
      static_cast<DWORD>(
         Win::SendMessage(
            listview,
            LVM_SETEXTENDEDLISTVIEWSTYLE,
            static_cast<WPARAM>(mask),
            static_cast<LPARAM>(exStyle)));

   return result;
}



HIMAGELIST
Win::ListView_SetImageList(HWND listview, HIMAGELIST images, int type)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(images);
   ASSERT(
         type == LVSIL_NORMAL
      || type == LVSIL_SMALL
      || type == LVSIL_STATE);

   HIMAGELIST result =
      (HIMAGELIST) Win::SendMessage(
         listview,
         LVM_SETIMAGELIST,
         static_cast<WPARAM>(type),
         (LPARAM) images);

   // can't assert result: if this is the first time the image list has been
   // set, the return value is the same as the error value!

   return result;
}



void
Win::ListView_SetItem(HWND listview, const LVITEM& item)
{
   ASSERT(Win::IsWindow(listview));

   BOOL result =
      (BOOL) Win::SendMessage(
         listview,
         LVM_SETITEM,
         0,
         (LPARAM) &item);
   ASSERT(result);
}

void
Win::ListView_SetItemText(HWND listview, int item, int subItem, const String& text)
{
   ASSERT(Win::IsWindow(listview));

   LVITEM lvitem;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&lvitem, sizeof LVITEM);

   lvitem.iSubItem = subItem;
   lvitem.mask = LVIF_TEXT;
   lvitem.pszText = const_cast<wchar_t*>(text.c_str());

   BOOL result =
      (BOOL) Win::SendMessage(
         listview,
         LVM_SETITEMTEXT,
         item,
         (LPARAM) &lvitem);
   ASSERT(result);
}

void
Win::ListView_SetItemState(HWND listview, int item, UINT state, UINT mask)
{
   ASSERT(Win::IsWindow(listview));
   ASSERT(mask);

   LVITEM lvitem;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&lvitem, sizeof LVITEM);

   lvitem.mask = LVIF_STATE;
   lvitem.state = state;
   lvitem.stateMask = mask;

   BOOL result =
      (BOOL) Win::SendMessage(
         listview,
         LVM_SETITEMSTATE,
         item,
         (LPARAM) &lvitem);
   ASSERT(result);
}

// needs to support TCHAR* because of that MAKEINTRESOURCE junk.

HRESULT
Win::LoadBitmap(unsigned resId, HBITMAP& result)
{
   ASSERT(resId);

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadBitmap(GetResourceModuleHandle(), MAKEINTRESOURCE(resId));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadCursor(const String& cursorName, HCURSOR& result)
{
   return Win::LoadCursor(cursorName.c_str(), result, false);
}



// provided for MAKEINTRESOURCE versions of cursorName
// CODEWORK: result should be the final parameter

HRESULT
Win::LoadCursor(
   const TCHAR*   cursorName,
   HCURSOR&       result,
   bool           isSystemCursor)
{
   result = 0;

   HRESULT hr = S_OK;

   result =
      ::LoadCursor(
         isSystemCursor ? 0 : GetResourceModuleHandle(),
         cursorName);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadIcon(int resID, HICON& result)
{
   ASSERT(resID);

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadIcon(GetResourceModuleHandle(), MAKEINTRESOURCE(resID));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, unsigned type, HANDLE& result)
{
   ASSERT(resID);
   ASSERT(type == IMAGE_BITMAP || type == IMAGE_CURSOR || type == IMAGE_ICON);

   result = 0;

   HRESULT hr = S_OK;

   result =
      ::LoadImage(
         GetResourceModuleHandle(),
         MAKEINTRESOURCEW(resID),
         type,
         0,
         0,

         // do NOT pass LR_DEFAULTSIZE here, so we get the actual size of
         // the resource.
         LR_DEFAULTCOLOR);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, HICON& result)
{
   result = 0;
   HANDLE h = 0;
   HRESULT hr = Win::LoadImage(resID, IMAGE_ICON, h);
   if (SUCCEEDED(hr))
   {
      result = reinterpret_cast<HICON>(h);
   }

   return hr;
}



HRESULT
Win::LoadImage(unsigned resID, HBITMAP& result)
{
   result = 0;
   HANDLE h = 0;
   HRESULT hr = Win::LoadImage(resID, IMAGE_BITMAP, h);
   if (SUCCEEDED(hr))
   {
      result = reinterpret_cast<HBITMAP>(h);
   }

   return hr;
}



HRESULT
Win::LoadLibrary(const String& libFileName, HINSTANCE& result)
{
   ASSERT(!libFileName.empty());

   // ISSUE-2002/03/05-sburns might want to assert that we're not passing a
   // full pathname, as that might break fusion.

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadLibrary(libFileName.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

#ifdef DBG

   // if your load failed, it's probably because you specified the wrong
   // dll name, which is a logic bug.
      
   ASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
   {
      // we should get a good handle if we're claiming to have succeeded
      
      ASSERT(result);
      ASSERT(result != INVALID_HANDLE_VALUE);
   }
#endif   

   return hr;
}



HRESULT
Win::LoadLibraryEx(
   const String&  libFileName,
   DWORD          flags,
   HINSTANCE&     result)
{
   ASSERT(!libFileName.empty());

   // ISSUE-2002/03/05-sburns might want to assert that we're not passing a
   // full pathname, as that might break fusion.

   result = 0;

   HRESULT hr = S_OK;

   result = ::LoadLibraryEx(libFileName.c_str(), 0, flags);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

#ifdef DBG

   // if your load failed, it's probably because you specified the wrong
   // dll name, which is a logic bug.
      
   ASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
   {
      // we should get a good handle if we're claiming to have succeeded
      
      ASSERT(result);
      ASSERT(result != INVALID_HANDLE_VALUE);
   }
#endif   

   return hr;
}



HRESULT
Win::LoadMenu(unsigned resID, HMENU& result)
{
   ASSERT(resID);

   HRESULT hr = S_OK;
   result = ::LoadMenu(GetResourceModuleHandle(), MAKEINTRESOURCEW(resID));
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}
      


String
Win::LoadString(unsigned resID)
{
   return String::load(resID);
}



String
Win::LoadString(unsigned resID, HINSTANCE hInstance)
{
   return String::load(resID, hInstance);
}



HRESULT
Win::LocalFree(HLOCAL mem)
{
   HRESULT hr = S_OK;

   // Don't assert mem, LocalFree will just return null and it's a nop.
   // This is consistent with most other mem mgmt functions: it's legal
   // to delete the null pointer.
   
   HLOCAL result = ::LocalFree(mem);
   if (result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



// moved to Win namespace, as it is used in that namespace

bool
Win::IsLocalComputer(const String& computerName)
{
   ASSERT(!computerName.empty());

   bool result = false;
   WKSTA_INFO_100* info = 0;
   
   do
   {
      String netbiosName = Win::GetComputerNameEx(ComputerNameNetBIOS);

      if (computerName.icompare(netbiosName) == 0)
      {
         result = true;
         break;
      }
   
      String dnsName = Win::GetComputerNameEx(ComputerNameDnsFullyQualified);

      if (computerName.icompare(dnsName) == 0)
      {
         result = true;
         break;
      }

      // we don't know what kind of name it is.  Ask the workstation service
      // to resolve the name for us, and see if the result refers to the
      // local machine.

      // NetWkstaGetInfo returns the netbios name for a given machine, given
      // a DNS, netbios, or IP address.

      HRESULT hr = MyNetWkstaGetInfo(computerName, info);
      BREAK_ON_FAILED_HRESULT(hr);

      if (info && netbiosName.icompare(info->wki100_computername) == 0)
      {
         // the given name is the same as the netbios name
      
         result = true;
         break;
      }
   } while (0);

   if (info)
   {
      ::NetApiBufferFree(info);
   }
   
   return result;
}



HRESULT
Win::LookupAccountSid(
   const String&  machineName,
   PSID           sid,
   String&        accountName,
   String&        domainName)
{
   ASSERT(sid);

   accountName.erase();
   domainName.erase();

   WCHAR* boxName = const_cast<WCHAR*>(machineName.c_str());
   if (machineName.empty() || Win::IsLocalComputer(machineName))
   {
      // local machine
      boxName = 0;
   }

   // Make the first call to determine the sizes of required buffers

   DWORD nameSize = 0;
   DWORD domainSize = 0;
   SID_NAME_USE use = SidTypeUnknown;

   if (
      !::LookupAccountSid(
         boxName,
         sid,
         0,
         &nameSize,
         0,
         &domainSize,
         &use))
   {
      // failed, but this is ok if the error is insufficient buffer; we're
      // deliberately calling it to get the buffer size.

      // ISSUE-2002/11/06-sburns  This is brain-dead: LSA lookups are
      // expensive so we should try a buffer big-enough to likely
      // succeed and resize up from there if necessary.
      
      DWORD err = ::GetLastError();

      if (err != ERROR_INSUFFICIENT_BUFFER)
      {
         return Win32ToHresult(err);
      }
   }

   ASSERT(nameSize);
   ASSERT(domainSize);

   HRESULT hr = S_OK;
   WCHAR* an = new WCHAR[nameSize + 1];
   WCHAR* dn = new WCHAR[domainSize + 1];

   // REVIEWED-2002/03/05-sburns correct byte counts passed.
   
   ::ZeroMemory(an, sizeof WCHAR * (nameSize + 1));
   ::ZeroMemory(dn, sizeof WCHAR * (domainSize + 1));

   if (
      ::LookupAccountSid(
         boxName,
         sid,
         an,

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         &nameSize,
         dn,

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         &domainSize,
         &use))
   {
      // ISSUE-2002/03/04-sburns if for some reason LookupAccountSid is
      // failing to null terminate, this is a buffer overread and overrun
      
      accountName = an;
      domainName = dn;
   }
   else
   {
      hr = Win::GetLastErrorAsHresult();
   }

   delete[] an;
   delete[] dn;

   LOG_HRESULT(hr);
   
   return hr;
}



HRESULT
Win::LookupPrivilegeValue(
   const TCHAR* systemName,
   const TCHAR* privName,
   LUID& luid)
{
   // systemName may be 0
   ASSERT(privName && privName[0]);

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&luid, sizeof LUID);

   HRESULT hr = S_OK;

   BOOL succeeded = ::LookupPrivilegeValueW(systemName, privName, &luid);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



int
Win::MessageBox(
   HWND           owner,
   const String&  text,
   const String&  title,
   UINT           flags)
{
   ASSERT(owner == 0 || Win::IsWindow(owner));
   ASSERT(!text.empty());

   // don't assert flags, MB_OK == 0

   const TCHAR* t = title.empty() ? 0 : title.c_str();

   LOG(String::format(L"MessageBox: %1 : %2", t, text.c_str()));

   int result = ::MessageBox(owner, text.c_str(), t, flags);
   ASSERT(result);

   return result;
}



HRESULT
Win::MoveFileEx(
   const String& srcPath,
   const String& dstPath,
   DWORD         flags)
{
   ASSERT(!srcPath.empty());
   ASSERT(!dstPath.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::MoveFileEx(srcPath.c_str(), dstPath.c_str(), flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::MoveWindow(
   HWND  window,
   int   x,
   int   y,
   int   width,
   int   height,
   bool  shouldRepaint)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::MoveWindow(window, x, y, width, height, shouldRepaint ? TRUE : FALSE);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::OpenProcessToken(
   HANDLE   processHandle,
   DWORD    desiredAccess,
   HANDLE&  tokenHandle)
{
   ASSERT(processHandle);

   tokenHandle = 0;

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::OpenProcessToken(processHandle, desiredAccess, &tokenHandle);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::OpenSCManager(
   const String&  machine,
   DWORD          desiredAccess,
   SC_HANDLE&     result)
{
   LOG_FUNCTION2(Win::OpenSCManager, machine);

   HRESULT hr = S_OK;
   PCWSTR m = machine.empty() ? 0 : machine.c_str();   

   result = ::OpenSCManager(m, 0, desiredAccess);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure could be due to access denied, etc.

   return hr;
}



HRESULT
Win::OpenService(
   SC_HANDLE      managerHandle,
   const String&  serviceName,
   DWORD          desiredAccess,
   SC_HANDLE&     result)
{
   LOG_FUNCTION2(Win::OpenService, serviceName);
   ASSERT(managerHandle);
   ASSERT(!serviceName.empty());

   HRESULT hr = S_OK;

   result = ::OpenService(managerHandle, serviceName.c_str(), desiredAccess);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: failure could be due to access denied, etc.

   return hr;
}

HRESULT
Win::ChangeServiceConfig(
   SC_HANDLE      serviceHandle,
   DWORD          serviceType,
   DWORD          serviceStartType,
   DWORD          errorControl,
   const String&  binaryPath,
   const String&  loadOrderingGroup,
   DWORD*         tagID,
   const String&  dependencies,
   const String&  accountName,
   EncryptedString& password,
   const String&  displayName)
{
   LOG_FUNCTION(Win::ChangeServiceConfig);

   ASSERT(serviceHandle);

   HRESULT hr = S_OK;

   PWSTR clearTextPassword = 0;
   if (!password.IsEmpty())
   {
      clearTextPassword = password.GetClearTextCopy();
   }

   BOOL result = 
      ::ChangeServiceConfig(
         serviceHandle,
         serviceType,
         serviceStartType,
         errorControl,
         (binaryPath.empty()) ? 0 : binaryPath.c_str(),
         (loadOrderingGroup.empty()) ? 0 : loadOrderingGroup.c_str(),
         tagID,
         (dependencies.empty()) ? 0 : dependencies.c_str(),
         (accountName.empty()) ? 0 : accountName.c_str(),
         clearTextPassword,
         (displayName.empty()) ? 0 : displayName.c_str());


   if (clearTextPassword)
   {
      password.DestroyClearTextCopy(clearTextPassword);
   }

   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}

void
Win::OutputDebugString(const String& str)
{
   ASSERT(!str.empty());

   ::OutputDebugString(str.c_str());
}



HRESULT
Win::PostMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = ::PostMessage(window, msg, wParam, lParam);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::PropertySheet(PROPSHEETHEADER* header, INT_PTR& result)
{
   ASSERT(header);

   result = 0;

   HRESULT hr = S_OK;

   result = ::PropertySheetW(header);
   if (result == -1)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::PropSheet_Changed(HWND propSheet, HWND page)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(Win::IsWindow(page));

   Win::SendMessage(propSheet, PSM_CHANGED, reinterpret_cast<WPARAM>(page), 0);
}



void
Win::PropSheet_Unchanged(HWND propSheet, HWND page)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(Win::IsWindow(page));

   Win::SendMessage(propSheet, PSM_UNCHANGED, reinterpret_cast<WPARAM>(page), 0);
}



void
Win::PropSheet_RebootSystem(HWND propSheet)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::SendMessage(propSheet, PSM_REBOOTSYSTEM, 0, 0);
}



void
Win::PropSheet_SetTitle(
   HWND propSheet,
   DWORD style,
   const String& title)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::SendMessage(
      propSheet,
      PSM_SETTITLE,
      style,
      reinterpret_cast<LPARAM>(title.c_str()));
}

void
Win::PropSheet_SetHeaderSubTitle(
   HWND propSheet,
   int  pageIndex,
   const String& subTitle)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(pageIndex >= 0);

   Win::SendMessage(
      propSheet,
      PSM_SETHEADERSUBTITLE,
      pageIndex,
      reinterpret_cast<LPARAM>(subTitle.c_str()));
}


void
Win::PropSheet_SetWizButtons(HWND propSheet, DWORD buttonFlags)
{
   ASSERT(Win::IsWindow(propSheet));

   Win::PostMessage(
      propSheet,
      PSM_SETWIZBUTTONS,
      0,
      buttonFlags);
}

void
Win::PropSheet_PressButton(HWND propSheet, DWORD buttonID)
{
   ASSERT(Win::IsWindow(propSheet));

   ASSERT(buttonID == PSBTN_APPLYNOW ||
          buttonID == PSBTN_BACK     ||
          buttonID == PSBTN_CANCEL   ||
          buttonID == PSBTN_FINISH   ||
          buttonID == PSBTN_HELP     ||
          buttonID == PSBTN_NEXT     ||
          buttonID == PSBTN_OK);

   Win::PostMessage(
      propSheet,
      PSM_PRESSBUTTON,
      buttonID,
      0);
}

int
Win::PropSheet_HwndToIndex(
   HWND propSheet,
   HWND page)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(Win::IsWindow(page));

   int result = 
      static_cast<int>(
         Win::SendMessage(
            propSheet,
            PSM_HWNDTOINDEX,
            reinterpret_cast<WPARAM>(page),
            0));

   ASSERT(result >= 0);

   return result;
}

int
Win::PropSheet_IdToIndex(
   HWND propSheet,
   int  pageId)
{
   ASSERT(Win::IsWindow(propSheet));
   ASSERT(pageId);

   int result =
      static_cast<int>(
         Win::SendMessage(
            propSheet,
            PSM_IDTOINDEX,
            0,
            pageId));

   ASSERT(result >= 0);

   return result;
}

HRESULT
Win::QueryServiceStatus(
   SC_HANDLE       handle,
   SERVICE_STATUS& status)
{
   ASSERT(handle);

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&status, sizeof SERVICE_STATUS);

   HRESULT hr = S_OK;

   BOOL succeeded = ::QueryServiceStatus(handle, &status);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ReadFile(
   HANDLE      handle,
   void*       buffer,
   DWORD       bytesToRead,
   DWORD&      bytesRead,
   OVERLAPPED* overlapped)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(bytesToRead);
   ASSERT(buffer);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::ReadFile(handle, buffer, bytesToRead, &bytesRead, overlapped);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success -- there may be any number of normal reasons
   // why this might legitimately fail.

   return hr;
}



HRESULT
Win::RegCloseKey(HKEY hKey)
{
   // don't assert hKey: we support closing a null key.

   HRESULT hr = S_OK;

   if (hKey)
   {
      hr = Win32ToHresult(::RegCloseKey(hKey));
      ASSERT(SUCCEEDED(hr));
   }
   else
   {
      hr = S_FALSE;
   }

   return hr;
}



HRESULT
Win::RegConnectRegistry(
   const String&  machine,
   HKEY           hKey,
   HKEY&          result)
{
   // machine may be empty

   ASSERT(hKey);

   HRESULT hr =
      Win32ToHresult(
         ::RegConnectRegistry(
            machine.empty() ? 0 : machine.c_str(),
            hKey,
            &result));

   // don't assert: it may be normal not to be able to access the remote
   // machine's registry.

   return hr;
}



HRESULT
Win::RegCreateKeyEx(
   HKEY                 hKey,
   const String&        subkeyName,
   DWORD                options,
   REGSAM               access,
   SECURITY_ATTRIBUTES* securityAttrs,
   HKEY&                result,
   DWORD*               disposition)
{
   ASSERT(hKey);
   ASSERT(!subkeyName.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegCreateKeyEx(
            hKey,
            subkeyName.c_str(),
            0,
            0,
            options,
            access,
            securityAttrs,
            &result,
            disposition));

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::RegDeleteValue(
   HKEY          hKey,
   const String& valueName)
{
   ASSERT(hKey);
   ASSERT(!valueName.empty());

   HRESULT hr = Win32ToHresult(::RegDeleteValue(hKey, valueName.c_str()));

   // don't assert the result, the value might not be present

   return hr;
}



HRESULT
Win::RegOpenKeyEx(
   HKEY           hKey,
   const String&  subKey,
   REGSAM         accessDesired,
   HKEY&          result)
{
   ASSERT(hKey);
   ASSERT(!subKey.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegOpenKeyEx(hKey, subKey.c_str(), 0, accessDesired, &result));

   // don't assert the result, the key may not be present...caller may be
   // testing for this state

   return hr;
}



// ptrs are used to allow nulls

HRESULT
Win::RegQueryValueEx(
   HKEY           hKey,
   const String&  valueName,
   DWORD*         type,
   BYTE*          data,
   DWORD*         dataSize)
{
   ASSERT(hKey);

   // Don't assert the value name: empty string means the default value
   // NTRAID#NTBUG9-578029-2002/03/20-sburns
   // 
   // ASSERT(!valueName.empty());

   HRESULT hr =
      Win32ToHresult(
         ::RegQueryValueEx(
            hKey,
            valueName.c_str(),
            0,
            type,
            data,
            dataSize));

   // don't assert the result, the key may not be present...caller may be
   // testing for this state

   return hr;
}



HRESULT
Win::RegSetValueEx(
   HKEY           hKey,
   const String&  valueName,
   DWORD          type,
   const BYTE*    data,
   size_t         dataSize)
{
   ASSERT(hKey);
   ASSERT(dataSize < ULONG_MAX);

   // value may be null.

   HRESULT hr =
      Win32ToHresult(
         ::RegSetValueEx(
            hKey,
            valueName.c_str(),
            0,
            type,
            data,
            static_cast<DWORD>(dataSize)));

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::RegisterClassEx(const WNDCLASSEX& wndclass, ATOM& result)
{
   HRESULT hr = S_OK;

   result = ::RegisterClassEx(&wndclass);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
      
   ASSERT(SUCCEEDED(hr));

   return hr;
}



CLIPFORMAT
Win::RegisterClipboardFormat(const String& name)
{
   ASSERT(!name.empty());

   CLIPFORMAT result = (CLIPFORMAT) ::RegisterClipboardFormat(name.c_str());
   ASSERT(result);

   return result;
}



void
Win::ReleaseDC(HWND window, HDC dc)
{
   ASSERT(window == 0 || Win::IsWindow(window));
   ASSERT(dc && dc != INVALID_HANDLE_VALUE);

   int result = 1;

   if (dc)
   {
      result = ::ReleaseDC(window, dc);
   }

   ASSERT(result);
}



HRESULT
Win::ReleaseMutex(HANDLE mutex)
{
   ASSERT(mutex && mutex != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::ReleaseMutex(mutex);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // releasing a mutex you don't hold is probably a program logic bug.

   ASSERT(SUCCEEDED(hr));

   return hr;
}



void
Win::ReleaseStgMedium(STGMEDIUM& medium)
{
   ::ReleaseStgMedium(&medium);
}



HRESULT
Win::RemoveDirectory(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::RemoveDirectory(path.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // Don't assert: failure does not necessarily indicate a program logic
   // error.

   return hr;
}

   
   
HRESULT
Win::ResetEvent(HANDLE event)
{
   ASSERT(event && event != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::ResetEvent(event);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ScreenToClient(HWND window, POINT& point)
{
	ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

	BOOL succeeded = ::ScreenToClient(window, &point);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::ScreenToClient(HWND window, RECT& rect)
{
   ASSERT(Win::IsWindow(window));

   // this evil hack takes advantage of the fact that a RECT is the
   // catentation of two points.

   POINT* pt = reinterpret_cast<POINT*>(&rect);

   HRESULT hr = S_OK;

   do
   {
      BOOL succeeded = ::ScreenToClient(window, pt);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }

      succeeded = ::ScreenToClient(window, pt + 1);
      if (!succeeded)
      {
         hr = Win::GetLastErrorAsHresult();
         break;
      }
   }
   while (0);

   ASSERT(SUCCEEDED(hr));

   return hr;
}

	

HGDIOBJ
Win::SelectObject(HDC hdc, HGDIOBJ hobject)
{
   ASSERT(hdc);
   ASSERT(hobject);
   ASSERT(hdc != INVALID_HANDLE_VALUE);
   ASSERT(hobject != INVALID_HANDLE_VALUE);

   HGDIOBJ result = ::SelectObject(hdc, hobject);

#pragma warning(push)
#pragma warning(disable: 4312)
   
   ASSERT(result != 0 && result != HGDI_ERROR);

#pragma warning(pop)

   return result;
}



LRESULT
Win::SendMessage(HWND window, UINT msg, WPARAM wParam, LPARAM lParam)
{
   ASSERT(Win::IsWindow(window));

   return ::SendMessage(window, msg, wParam, lParam);
}



HRESULT
Win::SetComputerNameEx(COMPUTER_NAME_FORMAT format, const String& newName)
{
   HRESULT hr = S_OK;

   BOOL result =
      ::SetComputerNameEx(
         format,
         newName.c_str());
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HCURSOR
Win::SetCursor(HCURSOR newCursor)
{
   return ::SetCursor(newCursor);
}



HRESULT
Win::SetDlgItemText(
   HWND           parentDialog,
   int            itemResID,
   const String&  text)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetDlgItemText(parentDialog, itemResID, text.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetDlgItemText(
   HWND                  parentDialog,
   int                   itemResID,
   const EncryptedString&  cypherText)
{
   ASSERT(Win::IsWindow(parentDialog));
   ASSERT(itemResID > 0);

   HRESULT hr = S_OK;

   WCHAR* cleartext = cypherText.GetClearTextCopy();
   
   BOOL succeeded = ::SetDlgItemText(parentDialog, itemResID, cleartext);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   cypherText.DestroyClearTextCopy(cleartext);
   
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetEvent(HANDLE event)
{
   ASSERT(event && event != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetEvent(event);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetFilePointerEx(
   HANDLE               handle,
   const LARGE_INTEGER& distanceToMove,
   LARGE_INTEGER*       newPosition,
   DWORD                moveMethod)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(Win::GetFileType(handle) == FILE_TYPE_DISK);

   if (newPosition)
   {
      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(newPosition, sizeof LARGE_INTEGER);
   }

   HRESULT hr = S_OK;

   BOOL succeeded = 
      ::SetFilePointerEx(handle, distanceToMove, newPosition, moveMethod);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HWND
Win::SetFocus(HWND window)
{
   ASSERT(Win::IsWindow(window));

   ::SetLastError(0);

   HWND result = ::SetFocus(window);
   if (result == NULL)
   {
      // do MT SetFocus
      HWND focus = ::GetFocus();
      if (focus == NULL)
      {
         // window with focus is in another thread.
         HWND current = ::GetForegroundWindow();
         DWORD thread1 = ::GetWindowThreadProcessId(current, 0);
         DWORD thread2 = ::GetWindowThreadProcessId(window, 0);
         ASSERT(thread1 != thread2);
         BOOL b = ::AttachThreadInput(thread2, thread1, TRUE);
         ASSERT(b);
         result = ::SetFocus(window);
         ASSERT(result);
         b = ::AttachThreadInput(thread2, thread1, FALSE);
         ASSERT(b);
         return result;
      }
   }

//   ASSERT(result);
   return result;
}



bool
Win::SetForegroundWindow(HWND window)
{
   ASSERT(Win::IsWindow(window));

   BOOL result = ::SetForegroundWindow(window);

   // don't assert the result, as the window may not be set to the forground
   // under "normal" circumstances.

   return result ? true : false;
}
      


void
Win::SetWindowFont(HWND window, HFONT font, bool redraw)
{
   ASSERT(Win::IsWindow(window));
   ASSERT(font);

   BOOL r = redraw ? 1 : 0;
   Win::SendMessage(
      window,
      WM_SETFONT,
      reinterpret_cast<WPARAM>(font),
      static_cast<LPARAM>(r) );
}



HRESULT
Win::SetWindowLong(
   HWND  window,  
   int   index,   
   LONG  value,   
   LONG* oldValue)
{
   ASSERT(Win::IsWindow(window));

   if (oldValue)
   {
      *oldValue = 0;
   }

   HRESULT hr = S_OK;

   // need to clear this as the prior value may have been 0.

   ::SetLastError(0);

   LONG result = ::SetWindowLongW(window, index, value);

   if (!result)
   {
      // maybe the previous value was zero, or maybe an error occurred.  If
      // the prior value really was zero, then this will leave hr == S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   if (oldValue)
   {
      *oldValue = result;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowLongPtr(
   HWND      window,   
   int       index,    
   LONG_PTR  value,    
   LONG_PTR* oldValue)
{
   ASSERT(Win::IsWindow(window));

   if (oldValue)
   {
      *oldValue = 0;
   }

   HRESULT hr = S_OK;

   // need to clear this as the prior value may have been 0.

   ::SetLastError(0);

   LONG_PTR result = ::SetWindowLongPtrW(window, index, value);
   if (!result)
   {
      // maybe the previous value was zero, or maybe an error occurred.  If
      // the prior value really was zero, then this will leave hr == S_OK

      hr = Win::GetLastErrorAsHresult();
   }

   if (oldValue)
   {
      *oldValue = result;
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowText(HWND window, const String& text)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetWindowText(window, text.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



LPITEMIDLIST
Win::SHBrowseForFolder(BROWSEINFO& bi)
{
   return ::SHBrowseForFolder(&bi);
}



HRESULT
Win::SHGetMalloc(LPMALLOC& pMalloc)
{
   pMalloc = 0;
   HRESULT hr = ::SHGetMalloc(&pMalloc);

   ASSERT(SUCCEEDED(hr));

   if (FAILED(hr))
   {
      pMalloc = 0;
   }

   return hr;
}



String
Win::SHGetPathFromIDList(LPCITEMIDLIST pidl)
{
   ASSERT(pidl);
   
   wchar_t buf[MAX_PATH];

   BOOL result = ::SHGetPathFromIDList(pidl, buf);

   // don't assert, list could be empty

   if (!result)
   {
      *buf = 0;
   }

   return String(buf);
}



HRESULT
Win::SHGetSpecialFolderLocation(
    HWND          hwndOwner, 	
    int           nFolder, 	
    LPITEMIDLIST& pidl)
{
   ASSERT(Win::IsWindow(hwndOwner));

   pidl = 0;
   HRESULT hr =
      ::SHGetSpecialFolderLocation(
         hwndOwner,
         nFolder,
         &pidl);

   ASSERT(SUCCEEDED(hr));

   if (FAILED(hr))
   {
      pidl = 0;
   }

   return hr;
}



void
Win::ShowWindow(HWND window, int swOption)
{
   ASSERT(Win::IsWindow(window));

   // the return value is of no use.
   ::ShowWindow(window, swOption);
}



void
Win::Spin_GetRange(HWND spinControl, int* low, int* high)
{
   ASSERT(Win::IsWindow(spinControl));

   Win::SendMessage(
      spinControl,
      UDM_GETRANGE32,
      reinterpret_cast<WPARAM>(low),
      reinterpret_cast<LPARAM>(high));

   return;
}



void
Win::Spin_SetRange(HWND spinControl, int low, int high)
{
   ASSERT(Win::IsWindow(spinControl));

   Win::SendMessage(
      spinControl,
      UDM_SETRANGE32,
      static_cast<WPARAM>(low),
      static_cast<LPARAM>(high));

   return;
}



int
Win::Spin_GetPosition(HWND spinControl)
{
   ASSERT(Win::IsWindow(spinControl));

   LRESULT result = Win::SendMessage(spinControl, UDM_GETPOS, 0, 0);

   // according to the docs, the high order word is non-zero on error.  But
   // how can this be if the range is 32 bits?

   ASSERT(!HIWORD(result));

   // we are truncating the 32 bit value.

   return LOWORD(result);
}



void
Win::Spin_SetPosition(HWND spinControl, int position)
{
   ASSERT(Win::IsWindow(spinControl));

#ifdef DBG
   // first, get the range and test that it encompasses the new range

   int low = 0;
   int high = 0;
   Win::Spin_GetRange(spinControl, &low, &high);
   ASSERT(low <= position && position <= high);
#endif

   Win::SendMessage(
      spinControl,
      UDM_SETPOS,
      0,
      static_cast<LPARAM>(position));
}



void
Win::Static_SetIcon(HWND staticText, HICON icon)
{
   ASSERT(Win::IsWindow(staticText));
   ASSERT(icon);
   ASSERT(icon != INVALID_HANDLE_VALUE);

   Win::SendMessage(
      staticText,
      STM_SETICON,
      reinterpret_cast<WPARAM>(icon),
      0);
}



String
Win::StringFromCLSID(const CLSID& clsID)
{
	LPOLESTR ole = 0;
   String retval;

	HRESULT hr = ::StringFromCLSID(clsID, &ole);

	ASSERT(SUCCEEDED(hr));

   if (SUCCEEDED(hr))
   {
      retval = ole;
   	::CoTaskMemFree(ole);
   }

   return retval;
}



String
Win::StringFromGUID2(const GUID& guid)
{
   static const size_t GUID_LEN = 39;   // includes null
	String retval(GUID_LEN, 0);
   int result =
      ::StringFromGUID2(
         guid,
         const_cast<wchar_t*>(retval.c_str()),
         GUID_LEN);
   ASSERT(result);
   retval.resize(GUID_LEN - 1);

   return retval;
}



HRESULT
Win::SystemParametersInfo(
   UINT  action,
   UINT  param,
   void* vParam,
   UINT  winIni)
{
   // this API is so ambiguous that no parameters can be
   // reasonably asserted.

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::SystemParametersInfo(action, param, vParam, winIni);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::TlsAlloc(DWORD& result)
{
   HRESULT hr = S_OK;
   result = ::TlsAlloc();
   if (result == static_cast<DWORD>(-1))
   {
      hr = Win::GetLastErrorAsHresult();
      ASSERT(false);
   }

   return hr;
}



HRESULT
Win::TlsFree(DWORD index)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   HRESULT hr = S_OK;
   BOOL result = ::TlsFree(index);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(result);

   return hr;
}



HRESULT
Win::TlsGetValue(DWORD index, PVOID& result)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   result = ::TlsGetValue(index);

   return Win::GetLastErrorAsHresult();
}



HRESULT
Win::TlsSetValue(DWORD index, PVOID value)
{
   ASSERT(index && index != static_cast<DWORD>(-1));

   HRESULT hr = S_OK;

   BOOL result = ::TlsSetValue(index, value);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(result);

   return hr;
}



HRESULT
Win::UnregisterClass(const String& classname, HINSTANCE module)
{
   ASSERT(!classname.empty());
   ASSERT(module);

   HRESULT hr = S_OK;

   BOOL succeeded = ::UnregisterClass(classname.c_str(), module);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::UpdateWindow(HWND winder)
{
   ASSERT(Win::IsWindow(winder));

   HRESULT hr = S_OK;

   BOOL succeeded = ::UpdateWindow(winder);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WaitForSingleObject(
   HANDLE   object,       
   unsigned timeoutMillis,
   DWORD&   result)       
{
   ASSERT(object && object != INVALID_HANDLE_VALUE);

   result = WAIT_FAILED;

   HRESULT hr = S_OK;

   result = ::WaitForSingleObject(object, timeoutMillis);
   if (result == WAIT_FAILED)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WideCharToMultiByte(
   DWORD          flags,
   const String&  str,
   char*          buffer,
   size_t         bufferSize,
   size_t&        result)
{
   ASSERT(!str.empty());

   result = 0;

   HRESULT hr = S_OK;

   int r =
      ::WideCharToMultiByte(
         CP_ACP,
         flags,
         str.c_str(),

         // REVIEWED-2002/03/06-sburns correct character count passed
         
         static_cast<int>(str.length()),
         buffer,
         static_cast<int>(bufferSize),
         0,
         0);
   if (!r)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   result = static_cast<size_t>(r);

   return hr;
}



HRESULT
Win::WinHelp(
   HWND           window,
   const String&  helpFileName,
   UINT           command,
   ULONG_PTR      data)
{
   ASSERT(Win::IsWindow(window));
   ASSERT(!helpFileName.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::WinHelp(window, helpFileName.c_str(), command, data);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WriteFile(
   HANDLE      handle,
   const void* buffer,
   DWORD       numberOfBytesToWrite,
   DWORD*      numberOfBytesWritten)
{
   ASSERT(handle != INVALID_HANDLE_VALUE);
   ASSERT(buffer);
   ASSERT(numberOfBytesToWrite);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::WriteFile(
         handle,
         buffer,
         numberOfBytesToWrite,
         numberOfBytesWritten,
         0);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::WritePrivateProfileString(
   const String& section,
   const String& key,
   const String& value,
   const String& filename)
{
   ASSERT(!section.empty());
   ASSERT(!key.empty());
   ASSERT(!filename.empty());

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::WritePrivateProfileString(
         section.c_str(),
         key.c_str(),
         value.c_str(),
         filename.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert success, that doesn't necessarily imply a logic error.
   // ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::InitializeSecurityDescriptor(SECURITY_DESCRIPTOR& sd)
{
   HRESULT hr = S_OK;

   // REVIEWED-2002/03/06-sburns correct byte count passed

   ::ZeroMemory(&sd, sizeof SECURITY_DESCRIPTOR);

   if (!::InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::SetSecurityDescriptorDacl(
   SECURITY_DESCRIPTOR& sd,
   bool                 daclPresent,
   ACL&                 dacl,             // ref to prevent null dacl
   bool                 daclDefaulted)
{
   HRESULT hr = S_OK;

   if (
      !::SetSecurityDescriptorDacl(
         &sd,
         daclPresent ? TRUE : FALSE,
         &dacl,
         daclDefaulted ? TRUE : FALSE) )
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CreateNamedPipe(
   const String&        name,
   DWORD                openMode,
   DWORD                pipeMode,
   DWORD                maxInstances,
   DWORD                outBufferSizeInBytes,
   DWORD                inBufferSizeInBytes,
   DWORD                defaultTimeout,
   SECURITY_ATTRIBUTES* sa,
   HANDLE&              result)
{
   ASSERT(!name.empty());
   ASSERT(maxInstances && maxInstances < PIPE_UNLIMITED_INSTANCES);

   HRESULT hr = S_OK;

   result =
      ::CreateNamedPipe(
         name.c_str(),
         openMode,
         pipeMode,
         maxInstances,
         outBufferSizeInBytes,
         inBufferSizeInBytes,
         defaultTimeout,
         sa);
   if (result == INVALID_HANDLE_VALUE)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::ConnectNamedPipe(
   HANDLE      pipe,
   OVERLAPPED* overlapped)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   // overlapped may be null

   HRESULT hr = S_OK;

   if (!::ConnectNamedPipe(pipe, overlapped))
   {
      // client may already connected, in which case the call might fail
      // with ERROR_PIPE_CONNECTED.  We consider that a successful connect.

      hr = Win::GetLastErrorAsHresult();
      if (hr == Win32ToHresult(ERROR_PIPE_CONNECTED))
      {
         hr = S_OK;
      }
   }

   return hr;
}



HRESULT
Win::PeekNamedPipe(
   HANDLE pipe,                     
   void*  buffer,                   
   DWORD  bufferSize,               
   DWORD* bytesRead,                
   DWORD* bytesAvailable,           
   DWORD* bytesRemainingThisMessage)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   // all other params may be null

   HRESULT hr = S_OK;

   if (
      !::PeekNamedPipe(
         pipe,
         buffer,
         bufferSize,
         bytesRead,
         bytesAvailable,
         bytesRemainingThisMessage) )
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



HRESULT
Win::DisconnectNamedPipe(HANDLE pipe)
{
   ASSERT(pipe != INVALID_HANDLE_VALUE);

   HRESULT hr = S_OK;

   if (!::DisconnectNamedPipe(pipe))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetWindowPos(
   HWND  window,
   HWND  insertAfter,
   int   x,
   int   y,
   int   width,
   int   height,
   UINT  flags)
{
   ASSERT(Win::IsWindow(window));

   HRESULT hr = S_OK;

   if (!::SetWindowPos(window, insertAfter, x, y, width, height, flags))
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::MapWindowPoints(
   HWND  from,
   HWND  to,
   RECT& rect,
   int*  dh,      // number of pixels added to horizontal coord
   int*  dv)      // number of pixels added to vertical coord
{
   // either from or to may be null

   HRESULT hr = S_OK;

   if (dh)
   {
      *dh = 0;
   }
   if (dv)
   {
      *dv = 0;
   }

   int result =
      ::MapWindowPoints(
         from,
         to,
         reinterpret_cast<PPOINT>(&rect),
         2);

   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }
   else
   {
      if (dh)
      {
         *dh = LOWORD(result);
      }
      if (dv)
      {
         *dv = HIWORD(result);
      }
   }

   return hr;
}



bool
Win::ToolTip_AddTool(HWND toolTip, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_ADDTOOL,
            0,
            reinterpret_cast<LPARAM>(&info)));

   ASSERT(result);
            
   return result ? true : false;
}
   


bool
Win::ToolTip_GetToolInfo(HWND toolTip, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_GETTOOLINFO,
            0,
            reinterpret_cast<LPARAM>(&info)));

   ASSERT(result);
            
   return result ? true : false;
}


   
bool
Win::ToolTip_SetTitle(HWND toolTip, int icon, const String& title)
{
   ASSERT(Win::IsWindow(toolTip));
   ASSERT(!title.empty());

   BOOL result =
      static_cast<BOOL>(
         Win::SendMessage(
            toolTip,
            TTM_SETTITLE,
            icon,
            reinterpret_cast<LPARAM>(title.c_str())));

   ASSERT(result);

   return result ? true : false;
}



void
Win::ToolTip_TrackActivate(HWND toolTip, bool activate, TOOLINFO& info)
{
   ASSERT(Win::IsWindow(toolTip));

   info.cbSize = sizeof(info);
   
   Win::SendMessage(
      toolTip,
      TTM_TRACKACTIVATE,
      activate ? TRUE : FALSE,
      reinterpret_cast<LPARAM>(&info));
}



void
Win::ToolTip_TrackPosition(HWND toolTip, int xPos, int yPos)
{
   ASSERT(Win::IsWindow(toolTip));

   Win::SendMessage(
      toolTip,
      TTM_TRACKPOSITION,
      0,
      static_cast<LPARAM>(MAKELONG(xPos, yPos)));
}



int
Win::Dialog_GetDefaultButtonId(HWND dialog)
{
   ASSERT(Win::IsWindow(dialog));

   int retval = 0;
   
   DWORD result = (DWORD) Win::SendMessage(dialog, DM_GETDEFID, 0, 0);
   if (result)
   {
      ASSERT(HIWORD(result) == DC_HASDEFID);
      retval = LOWORD(result);
   }

   return retval;
}



void
Win::Dialog_SetDefaultButtonId(HWND dialog, int buttonResId)
{
   ASSERT(Win::IsWindow(dialog));
   ASSERT(buttonResId);

   Win::SendMessage(dialog, DM_SETDEFID, buttonResId, 0);
}



HRESULT
Win::SetCurrentDirectory(const String& path)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;
      
   BOOL succeeded = ::SetCurrentDirectory(path.c_str());
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}



DWORD
Win::RichEdit_SetEventMask(HWND richEdit, DWORD mask)
{
   ASSERT(Win::IsWindow(richEdit));

   // mask may be 0

   DWORD result =
      static_cast<DWORD>(
         Win::SendMessage(
            richEdit,
            EM_SETEVENTMASK,
            0,
            static_cast<LPARAM>(mask)));
         
   return result;
}



int
Win::RichEdit_StreamIn(
   HWND        richEdit,
   WPARAM      formatOptions,
   EDITSTREAM& editStream)
{
   ASSERT(Win::IsWindow(richEdit));
   ASSERT(formatOptions);

   editStream.dwError = 0;

   int result =
      static_cast<int>(
         Win::SendMessage(
            richEdit,
            EM_STREAMIN,
            formatOptions,
            reinterpret_cast<LPARAM>(&editStream)));
   ASSERT(!editStream.dwError);

   return result;
}
   


int
Win::RichEdit_SetText(HWND richEdit, DWORD flags, const String& text)
{
   ASSERT(Win::IsWindow(richEdit));
   
   SETTEXTEX textEx;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&textEx, sizeof textEx);

   textEx.flags = flags;

   // Since text is a unicode string, we set the codepage to 1200
   
   textEx.codepage = 1200;  

   LRESULT result =
      Win::SendMessage(
         richEdit,
         EM_SETTEXTEX,
         (WPARAM) &textEx,
         (LPARAM) text.c_str());
   ASSERT(result);

   return (int) result;
}



int
Win::RichEdit_SetRtfText(HWND richEdit, DWORD flags, const String& rtfText)
{
   ASSERT(Win::IsWindow(richEdit));
   
   SETTEXTEX textEx;

   // REVIEWED-2002/03/06-sburns correct byte count passed
   
   ::ZeroMemory(&textEx, sizeof textEx);

   textEx.flags = flags;
   textEx.codepage = CP_UTF8; 
   
   // rtf is only read if it is first converted to a multi-byte format.
   // utf-8 is what works for unicode source text
   // NTRAID#NTBUG9-489329-2001/11/05-sburns

   AnsiString ansi;
   String::ConvertResult cr = rtfText.convert(ansi, CP_UTF8);
   ASSERT(cr == String::CONVERT_SUCCESSFUL);

   LRESULT result =
      Win::SendMessage(
         richEdit,
         EM_SETTEXTEX,
         (WPARAM) &textEx,
         (LPARAM) ansi.c_str());
   ASSERT(result);

   return (int) result;
}
   
   

bool   
Win::RichEdit_SetCharacterFormat(
   HWND         richEdit,
   DWORD        options, 
   CHARFORMAT2& format)
{
   ASSERT(Win::IsWindow(richEdit));

   format.cbSize = sizeof(format);

   LRESULT result =
      Win::SendMessage(
         richEdit,
         EM_SETCHARFORMAT,
         (WPARAM) options,
         (LPARAM) &format);
   ASSERT(result);

   return result ? true : false;
}



void
Win::RichEdit_GetSel(
   HWND       richEdit,
   CHARRANGE& range)
{
   ASSERT(Win::IsWindow(richEdit));

   Win::SendMessage(
      richEdit,
      EM_EXGETSEL,
      0,
      (LPARAM) &range);
}



void
Win::RichEdit_SetSel(
   HWND              richEdit,
   const CHARRANGE&  range)
{
   ASSERT(Win::IsWindow(richEdit));

   Win::SendMessage(
      richEdit,
      EM_EXSETSEL,
      0,
      (LPARAM) &range);
}



HRESULT
Win::FindResource(PCWSTR name, PCWSTR type, HRSRC& result)
{
   ASSERT(name);
   ASSERT(type);

   HRESULT hr = S_OK;
   
   result = ::FindResourceW(GetResourceModuleHandle(), name, type);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::LoadResource(HRSRC handle, HGLOBAL& result)
{
   ASSERT(handle);

   HRESULT hr = S_OK;
   result = ::LoadResource(GetResourceModuleHandle(), handle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SizeofResource(HRSRC handle, DWORD& result)
{
   ASSERT(handle);

   HRESULT hr = S_OK;
   result = ::SizeofResource(GetResourceModuleHandle(), handle);
   if (!result)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::CryptProtectData(const DATA_BLOB& clearText, DATA_BLOB& cypherText)
{
   ASSERT(clearText.cbData);
   ASSERT(clearText.pbData);

   // REVIEWED-2002/03/19-sburns correct byte count passed

   ::ZeroMemory(&cypherText, sizeof cypherText);

   HRESULT hr = S_OK;
      
   BOOL succeeded =
      ::CryptProtectData(
         const_cast<DATA_BLOB*>(&clearText),
         0,
         0,
         0,
         0,
         CRYPTPROTECT_UI_FORBIDDEN,
         &cypherText);
         
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();

      // should have a null result on failure, but just in case...

      ASSERT(!cypherText.cbData && !cypherText.pbData);

      // REVIEWED-2002/03/19-sburns correct byte count passed

      ::ZeroMemory(&cypherText, sizeof cypherText);
   }

   // we don't assert success, as the API may have run out of memory.

   return hr;
}



HRESULT
Win::CryptUnprotectData(const DATA_BLOB& cypherText, DATA_BLOB& clearText)
{
   ASSERT(cypherText.cbData);
   ASSERT(cypherText.pbData);

   // REVIEWED-2002/03/19-sburns correct byte count passed

   ::ZeroMemory(&clearText, sizeof clearText);

   HRESULT hr = S_OK;
   
   BOOL succeeded =
      ::CryptUnprotectData(
         const_cast<DATA_BLOB*>(&cypherText),
         0,
         0,
         0,
         0,
         CRYPTPROTECT_UI_FORBIDDEN,
         &clearText);
         
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();

      // should have a null result on failure, but just in case...

      ASSERT(!clearText.cbData && !clearText.pbData);

      // REVIEWED-2002/03/19-sburns correct byte count passed

      ::ZeroMemory(&clearText, sizeof clearText);
   }

   // we don't assert success, as the API may have run out of memory.

   return hr;
}



HRESULT
Win::SetFileAttributes(const String& path, DWORD newAttrs)
{
   ASSERT(!path.empty());

   HRESULT hr = S_OK;

   BOOL succeeded = ::SetFileAttributes(path.c_str(), newAttrs);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   return hr;
}
   


HRESULT
Win::SetEntriesInAcl(
   ULONG           countOfEntries,
   EXPLICIT_ACCESS eaArray[],
   PACL&           result)
{
   ASSERT(countOfEntries);
   ASSERT(eaArray);

   HRESULT hr =
      Win32ToHresult(
         ::SetEntriesInAcl(countOfEntries, eaArray, 0, &result));

   // can't think of a legit reason this would fail

   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetSecurityDescriptorDacl(SECURITY_DESCRIPTOR& sd, ACL& acl)
{
   HRESULT hr = S_OK;
   
   BOOL succeeded = ::SetSecurityDescriptorDacl(&sd, TRUE, &acl, FALSE);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // can't think of a legit reason this can fail
   
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetSecurityDescriptorOwner(SECURITY_DESCRIPTOR& sd, SID* ownerSid)
{
   ASSERT(ownerSid);
   ASSERT(::IsValidSid(ownerSid));

   HRESULT hr = S_OK;
      
   BOOL succeeded = ::SetSecurityDescriptorOwner(&sd, ownerSid, FALSE);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // can't think of a legit reason this can fail
   
   ASSERT(SUCCEEDED(hr));

   return hr;
}



HRESULT
Win::SetFileSecurity(
   const String&              path,
   SECURITY_INFORMATION       si,
   const SECURITY_DESCRIPTOR& sd)
{
   ASSERT(!path.empty());
   ASSERT(si);

   HRESULT hr = S_OK;
      
   BOOL succeeded =
      ::SetFileSecurity(path.c_str(), si, (PSECURITY_DESCRIPTOR) &sd);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   // don't assert: the file might not exist, be read-only, etc

   return hr;
}
      
   
   
HRESULT
Win::CryptProtectMemory(
   void*  buffer,           
   size_t bufferSizeInBytes,
   DWORD  flags)
{
   ASSERT(buffer);
   ASSERT(bufferSizeInBytes);
   ASSERT(bufferSizeInBytes % CRYPTPROTECTMEMORY_BLOCK_SIZE == 0);
   ASSERT(bufferSizeInBytes <= ULONG_MAX);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::CryptProtectMemory(buffer, (DWORD) bufferSizeInBytes, flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}


   
HRESULT
Win::CryptUnprotectMemory(
   void*  buffer,           
   size_t bufferSizeInBytes,
   DWORD  flags)
{
   ASSERT(buffer);
   ASSERT(bufferSizeInBytes);
   ASSERT(bufferSizeInBytes % CRYPTPROTECTMEMORY_BLOCK_SIZE == 0);
   ASSERT(bufferSizeInBytes <= ULONG_MAX);

   HRESULT hr = S_OK;

   BOOL succeeded =
      ::CryptUnprotectMemory(buffer, (DWORD) bufferSizeInBytes, flags);
   if (!succeeded)
   {
      hr = Win::GetLastErrorAsHresult();
   }

   ASSERT(SUCCEEDED(hr));

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\wizpage.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#include "headers.hxx"



static const DWORD HELP_MAP[] =
{
   0, 0
};



WizardPage::WizardPage(
   unsigned dialogResID,
   unsigned titleResID,
   unsigned subtitleResID,   
   bool     isInteriorPage,
   bool     enableHelp)
   :
   PropertyPage(dialogResID, HELP_MAP, false),
   hasHelp(enableHelp),
   isInterior(isInteriorPage),
   titleResId(titleResID),
   subtitleResId(subtitleResID),
   wizard(0)
{
//   LOG_CTOR(WizardPage);
}



WizardPage::~WizardPage()
{
//   LOG_DTOR(WizardPage);

   wizard = 0;
}



Wizard&
WizardPage::GetWizard() const
{
   ASSERT(wizard);

   return *wizard;
}



HPROPSHEETPAGE
WizardPage::Create()
{
//   LOG_FUNCTION(WizardPage::Create);
   ASSERT(wizard);

   String title = String::load(titleResId);
   String subtitle = String::load(subtitleResId);

   PROPSHEETPAGE page;

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(&page, sizeof page);
      
   page.dwSize       = sizeof(page);
   page.dwFlags      = PSP_DEFAULT | PSP_USECALLBACK | PSP_USETITLE;
   if (isInterior)
   {
      page.dwFlags |= PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
   }
   else
   {
      page.dwFlags |= PSP_HIDEHEADER;
   }

   if (hasHelp)
   {
      page.dwFlags |= PSP_HASHELP;
   }

   page.hInstance          = GetResourceModuleHandle();
   page.pszTemplate        = MAKEINTRESOURCE(GetResID());
   page.pfnDlgProc         = PropertyPage::propPageDialogProc;
   page.pfnCallback        = PropertyPage::PropSheetPageCallback;
   page.pszHeaderTitle     = title.c_str();
   page.pszHeaderSubTitle  = subtitle.c_str();

   // this pointer is retrieved by the dialog proc 
   page.lParam             = reinterpret_cast<LPARAM>(this);

   HPROPSHEETPAGE result = 0;
   HRESULT hr = Win::CreatePropertySheetPage(page, result);
   ASSERT(SUCCEEDED(hr));

   return result;
}



bool
WizardPage::OnWizBack()
{
//   LOG_FUNCTION(WizardPage::OnWizBack);

   GetWizard().Backtrack(hwnd);
   return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\wizard.cpp ===
// Copyright (c) 1997-1999 Microsoft Corporation
//
// wizard base class
//
// 12-15-97 sburns



#include "headers.hxx"



Wizard::Wizard(
   unsigned titleStringResID,
   unsigned banner16BitmapResID,
   unsigned banner256BitmapResID,
   unsigned watermark16BitmapResID,
   unsigned watermark1256BitmapResID)
   :
   banner16ResId(banner16BitmapResID),
   banner256ResId(banner256BitmapResID),
   isBacktracking(false),
   pageIdHistory(),
   pages(),
   titleResId(titleStringResID),
   watermark16ResId(watermark16BitmapResID),
   watermark256ResId(watermark1256BitmapResID)
{
   LOG_CTOR(Wizard);
   ASSERT(titleResId);
   ASSERT(banner16ResId);
   ASSERT(banner256ResId);
   ASSERT(watermark16ResId);
   ASSERT(watermark256ResId);
}



Wizard::~Wizard()
{
   LOG_DTOR(Wizard);

   for (
      PageList::iterator i = pages.begin();
      i != pages.end();
      ++i)
   {
      // we can delete the pages because they were created with the
      // deleteOnRelease flag = false;
      delete *i;
   }
}



void
Wizard::AddPage(WizardPage* page)
{
   LOG_FUNCTION(Wizard::AddPage);
   ASSERT(page);

   if (page)
   {
      LOG(
         String::format(
            L"id = %1!d! title = %2",
            page->GetResID(),
            String::load(page->titleResId).c_str()));
            
      pages.push_back(page);
      page->wizard = this;
   }
}



INT_PTR
Wizard::ModalExecute(
   HWND parentWindow,
   UINT startPageIndex,
   PFNPROPSHEETCALLBACK sheetCallback)
{
   LOG_FUNCTION(Wizard::ModalExecute);

   if (!parentWindow)
   {
      parentWindow = Win::GetDesktopWindow();
   }

   // build the array of prop sheet pages.

   size_t pageCount = pages.size();
   HPROPSHEETPAGE* propSheetPages = new HPROPSHEETPAGE[pageCount];

   // REVIEWED-2002/03/05-sburns correct byte count passed
   
   ::ZeroMemory(propSheetPages, sizeof HPROPSHEETPAGE * pageCount);

   int j = 0;
   for (
      PageList::iterator i = pages.begin();
      i != pages.end();
      ++i, ++j)
   {
      propSheetPages[j] = (*i)->Create();
   }

   bool deletePages = false;
   INT_PTR result = -1;

   // ensure that the pages were created

   for (size_t k = 0; k < pageCount; ++k)
   {
      if (propSheetPages[k] == 0)
      {
         deletePages = true;
         break;
      }
   }

   if (!deletePages)
   {
      ASSERT(startPageIndex < pageCount);

      PROPSHEETHEADER header;

      // REVIEWED-2002/03/06-sburns correct byte count passed
      
      ::ZeroMemory(&header, sizeof header);

      String title = String::load(titleResId);

      header.dwSize           = sizeof(header);                                  
      header.dwFlags          =
            PSH_WIZARD | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;

      if (sheetCallback)
      {
         header.dwFlags |= PSH_USECALLBACK;
      }

      header.hwndParent       = parentWindow;
      header.hInstance        = GetResourceModuleHandle();
      header.hIcon            = 0;
      header.pszCaption       = title.c_str();
      header.nPages           = static_cast<UINT>(pageCount);
      header.nStartPage       = startPageIndex;               
      header.phpage           = propSheetPages;
      header.pfnCallback      = sheetCallback;

      int colorDepth = 0;
      HRESULT hr = Win::GetColorDepth(colorDepth);

      ASSERT(SUCCEEDED(hr));

      bool use256ColorBitmaps = colorDepth >= 8;

      header.pszbmWatermark   =
         use256ColorBitmaps
         ? MAKEINTRESOURCEW(watermark256ResId)
         : MAKEINTRESOURCEW(watermark16ResId);
      header.pszbmHeader      =
         use256ColorBitmaps
         ? MAKEINTRESOURCEW(banner256ResId)
         : MAKEINTRESOURCEW(banner16ResId);      

      hr = Win::PropertySheet(&header, result);
      ASSERT(SUCCEEDED(hr));

      if (result == -1)
      {
         deletePages = true;
      }
   }

   if (deletePages)
   {
      // Manually destroy the pages if something failed.  (otherwise,
      // ::PropertySheet will have destroyed them)

      for (size_t i = 0; i < pageCount; i++)
      {
         if (propSheetPages[i])
         {
            HRESULT hr = Win::DestroyPropertySheetPage(propSheetPages[i]);

            ASSERT(SUCCEEDED(hr));
         }
      }
   }

   delete[] propSheetPages;

   return result;
}



void
Wizard::SetNextPageID(HWND wizardPage, int pageResID)
{
   LOG_FUNCTION2(
      Wizard::SetNextPageID,
      String::format(L"id = %1!d!", pageResID));
   ASSERT(Win::IsWindow(wizardPage));

   if (pageResID != -1)
   {
      Dialog* dlg = Dialog::GetInstance(wizardPage);
      ASSERT(dlg);

      if (dlg)
      {
         pageIdHistory.push(dlg->GetResID());
      }
   }

   isBacktracking = false;
   Win::SetWindowLongPtr(wizardPage, DWLP_MSGRESULT, pageResID);
}



void
Wizard::Backtrack(HWND wizardPage)
{
   LOG_FUNCTION(Wizard::Backtrack);
   ASSERT(Win::IsWindow(wizardPage));

   // If this fails, then you haven't pushed any pages on the stack by
   // calling SetNextPageID (which is typically done in your page's
   // OnSetActive and/or OnWizNext)
   
   ASSERT(pageIdHistory.size());
   
   isBacktracking = true;
   unsigned topPage = 0;

   if (pageIdHistory.size())
   {
      topPage = pageIdHistory.top();
      ASSERT(topPage > 0);

      LOG(String::format(L" id = %1!u!", topPage));

      pageIdHistory.pop_and_remove_loops();
   }

   Win::SetWindowLongPtr(
      wizardPage,
      DWLP_MSGRESULT,
      static_cast<LONG_PTR>(topPage));
}



bool
Wizard::IsBacktracking()
{
   return isBacktracking;
}



// It is possible for the page history stack to contain loops. When we pop the
// top element of the stack, we see if the element is still in the stack. If
// so, then we pop until element no longer appears in the stack. This will
// remove any loops.
// NTRAID#NTBUG9-490197-2001/11/19-sburns
       
void
Wizard::PageIdStack::pop_and_remove_loops()
{
   // if you're popping from an empty stack, then you've made a mistake
   
   ASSERT(size());

   unsigned topPage = top();

   // CODEWORK: this could be done more efficiently by finding the first
   // occurrance of topPage, and erasing the rest -- a "batch" pop.
   
   while (std::count(c.begin(), c.end(), topPage))
   {
      pop();
      // dump();
   }

   // like this, maybe:
   // UIntVector::iterator i = std::find(c.begin(), c.end(), topPage);
   // if (i != c.end())
   // {
   //    c.erase(i, c.end());
   // }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-computer.cpp ===
// Test Burnslib::Computer



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



const String ARG_COMPUTER(L"c");



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



AnsiString
GetRoleDescription(const Computer& c)
{
   AnsiString role;
   switch (c.GetRole())
   {
      case Computer::STANDALONE_WORKSTATION:
      {
         role = "StandaloneWorkstation";
         break;
      }
      case Computer::MEMBER_WORKSTATION:
      {
         role = "MemberWorkstation";
         break;
      }
      case Computer::STANDALONE_SERVER:
      {
         role = "StandaloneServer";
         break;
      }
      case Computer::MEMBER_SERVER:
      {
         role = "MemberServer";
         break;
      }
      case Computer::PRIMARY_CONTROLLER:
      {
         role = "PrimaryDomainController";
         break;
      }
      case Computer::BACKUP_CONTROLLER:
      {
         role = "BackupDomainController";
         break;
      }
      default:
      {
         role = "unknown";
         break;
      }
   }

   return role;
}



void
DumpComputer(const Computer& c)
{
   std::cout << "NetBIOS Name       : ";    AnsiOutLn(c.GetNetbiosName());
   std::cout << "DNS Name           : ";    AnsiOutLn(c.GetFullDnsName());
   std::cout << "Domain NetBIOS Name: ";    AnsiOutLn(c.GetDomainNetbiosName());
   std::cout << "Domain DNS Name    : ";    AnsiOutLn(c.GetDomainDnsName());
   std::cout << "Domain Forest Name : ";    AnsiOutLn(c.GetForestDnsName());
   std::cout << "Role               : " << GetRoleDescription(c) << std::endl;
   std::cout << (c.IsLocal()             ? "Is" : "Is NOT") << " local computer" << std::endl;
   std::cout << (c.IsJoinedToDomain()    ? "Is" : "Is NOT") << " domain joined" << std::endl;
   std::cout << (c.IsDomainController()  ? "Is" : "Is NOT") << " domain controller" << std::endl;
   std::cout << (c.IsJoinedToWorkgroup() ? "Is" : "Is NOT") << " workgroup joined" << std::endl;
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   // unit test of the Computer object

   //                                   local             remote
   // worksta svc not running          X ok               X err
   // net connection disabled          X ok               X err
   // not joined to domain             X ok               X ok
   // joined to downlevel domain         ok                 ok
   // no networking                    X ok                 err
   // non-tcp/ip networking            X ok                 ok
   // access denied                      possible?        X err
   // named by netbios name            X ok               X ok
   // named by dns name                X ok               X ok
   // named by ip address              X ok               X ok

   ArgMap clmap;
   MapCommandLineArgs(clmap);

   Computer comp(clmap[ARG_COMPUTER]);

   HRESULT hr = comp.Refresh();

   if (SUCCEEDED(hr))
   {
      DumpComputer(comp);
   }
   else
   {
      AnsiOutLn(String::format(L"error 0x%1!08X!", hr));
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-fs-1.cpp ===
// Test miscellaneous FS:: stuff



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-1";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
testGetParentFolder()
{
   LOG_FUNCTION(testGetParentFolder);

   HRESULT hr = S_OK;

   String root = L"e:\\";

   // parent of root folder is the root folder

   AnsiOutLn(FS::GetParentFolder(root));
   ASSERT(FS::GetParentFolder(root) == root);

   // parent of files in root folder is root folder

   String file = root + L"rootfile.ext";

   HANDLE h = INVALID_HANDLE_VALUE;
   hr = FS::CreateFile(file, h, GENERIC_WRITE);
   Win::CloseHandle(h);

   AnsiOutLn(FS::GetParentFolder(file));
   ASSERT(FS::GetParentFolder(file) == root);

   hr = Win::DeleteFile(file);

   // parent of a folder is a folder

   String folder = root + L"rootdir";

   hr = FS::CreateFolder(folder);

   AnsiOutLn(FS::GetParentFolder(folder));
   ASSERT(FS::GetParentFolder(folder) == root);

   hr = Win::RemoveFolder(folder);

   // parent of a sub folder

   String subfolder = folder + L"\\subfolder";

   AnsiOutLn(FS::GetParentFolder(subfolder));
   ASSERT(FS::GetParentFolder(subfolder) == folder);

   // parent folder of a wildcard spec can be found

   String wild = root + L"*.???";

   AnsiOutLn(FS::GetParentFolder(wild));
   ASSERT(FS::GetParentFolder(wild) == root);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

//    StringVector args;
//    int argc = Win::GetCommandLineArgs(std::back_inserter(args));
// 
//    if (argc < 2)
//    {
//       AnsiOutLn(L"missing filespec - path w/ wildcards to iterate over (non-destructive)");
//       exit(0);
//    }
// 
//    String sourceDir = args[1];
//    AnsiOutLn(sourceDir);

   testGetParentFolder();


   // test that IsParentFolder is not fooled by "c:\a\b\c", "c:\a\b\cde"

   // test that CopyFile, when cancelled, returns an HRESULT that indicates
   // cancellation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-fs-createfolder.cpp ===
// Test miscellaneous (possibly destuctive) FS:: stuff 



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-3";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_MUTE;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
doCannedTests()
{
   LOG_FUNCTION(doCannedTests);

   StringVector paths;

   paths.push_back(L"c:\\temp");
   paths.push_back(L"c:\\temp\\a");
   paths.push_back(L"c:\\temp\\a\\b\\c\\d");
   paths.push_back(L"c:\\temp\\a\\b\\c\\d");

   String server = Win::GetComputerNameEx(ComputerNameNetBIOS);
   String share = L"\\\\" + server + L"\\c$\\temp\\unc\\";

   paths.push_back(share + L"a");
   paths.push_back(share + L"a\\b\\c\\d");
   paths.push_back(share + L"a\\b\\c\\d");

   HRESULT hr = S_OK;
   for (
      StringVector::iterator i = paths.begin();
      i != paths.end();
      ++i)
   {
      AnsiOut(String::format(L"creating %1", i->c_str()));

      hr = FS::CreateFolder(*i);

      AnsiOut(
         String::format(
            L" \t\t%1",
            SUCCEEDED(hr) ? L"succeeded" : L"failed"));

      AnsiOutLn(
         String::format(
            L" \t\t%1",
            FS::PathExists(*i) ? L"exists" : L"absent"));
   }
}


         
void
testCreateFolder(const String& path)
{
   LOG_FUNCTION(testCreateFolder);

   HRESULT hr = FS::CreateFolder(path);
   AnsiOutLn(
      String::format(
         L"CreateFolder(%1) %2.",
         path.c_str(),
         SUCCEEDED(hr) ? L"succeeded" : L"failed"));
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      doCannedTests();
   }
   else
   {
      String sourceDir = args[1];
      AnsiOutLn(sourceDir);
      AnsiOutLn(L"=================");

      testCreateFolder(sourceDir);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-encryptedstring.cpp ===
// test the Burnslib::EncryptedString class



#include "headers.hxx"
#include <time.h>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
TestEmptyness(const EncryptedString& empty)
{
   LOG_FUNCTION(TestEmptyness);

   ASSERT(empty.IsEmpty());
   ASSERT(empty.GetLength() == 0);
   
   // the cleartext of an empty instance should also be empty

   WCHAR* emptyClear = empty.GetClearTextCopy();

   ASSERT(emptyClear);
   ASSERT(*emptyClear == 0);

   empty.DestroyClearTextCopy(emptyClear);
}



void
TestEmptyStrings()
{
   LOG_FUNCTION(TestEmptyStrings);
   
   EncryptedString empty1;

   TestEmptyness(empty1);
   
   // copies of empty strings are themselves empty
   
   EncryptedString empty2(empty1);

   // source should still be empty
   
   TestEmptyness(empty1);
   TestEmptyness(empty2);

   EncryptedString empty3;
   
   TestEmptyness(empty3);

   empty3 = empty2;
   
   // source should still be empty
   
   TestEmptyness(empty2);
   TestEmptyness(empty3);

   empty3 = empty1;

   TestEmptyness(empty1);
   TestEmptyness(empty2);
   TestEmptyness(empty3);
   
   // strings built from empty strings should be empty

   EncryptedString empty4;

   TestEmptyness(empty4);

   empty4.Encrypt(L"");
   
   TestEmptyness(empty4);

   // a string made from an empty string is still empty when the source
   // is made non-empty

   EncryptedString empty5;
   EncryptedString empty6(empty5);

   TestEmptyness(empty5);
   TestEmptyness(empty6);

   empty5.Encrypt(L"not empty any more");

   ASSERT(!empty5.IsEmpty());
   ASSERT(empty5.GetLength() != 0);
   TestEmptyness(empty6);

   // A cleared string is empty

   EncryptedString empty7;
   empty7.Encrypt(L"some text");
   empty7.Clear();
   TestEmptyness(empty7);
   
   // empty strings are equal

   ASSERT(empty1 == empty1);
   ASSERT(empty1 == empty2);
   ASSERT(empty1 == empty3);
   ASSERT(empty1 == empty4);
   ASSERT(empty1 == empty6);      
   ASSERT(empty1 == empty7);      
   ASSERT(empty2 == empty1);
   ASSERT(empty2 == empty2);     
   ASSERT(empty2 == empty3);
   ASSERT(empty2 == empty4);
   ASSERT(empty2 == empty6);
   ASSERT(empty2 == empty7);
   ASSERT(empty3 == empty1);
   ASSERT(empty3 == empty2);
   ASSERT(empty3 == empty3);
   ASSERT(empty3 == empty4);
   ASSERT(empty3 == empty6);
   ASSERT(empty3 == empty7);
   ASSERT(empty4 == empty1);   
   ASSERT(empty4 == empty2);   
   ASSERT(empty4 == empty3);   
   ASSERT(empty4 == empty4);
   ASSERT(empty4 == empty6);
   ASSERT(empty4 == empty7);
   ASSERT(empty6 == empty1);
   ASSERT(empty6 == empty2);
   ASSERT(empty6 == empty3);
   ASSERT(empty6 == empty4);
   ASSERT(empty6 == empty6);
   ASSERT(empty6 == empty7);
   ASSERT(empty7 == empty1);
   ASSERT(empty7 == empty2);
   ASSERT(empty7 == empty3);
   ASSERT(empty7 == empty4);
   ASSERT(empty7 == empty6);
   ASSERT(empty7 == empty7);
}



WCHAR*
MakeRandomString(size_t length)
{
   LOG_FUNCTION2(MakeRandomString, String::format(L"%1!d!", length));

   WCHAR* result = new WCHAR[length + 1];

   for (size_t i = 0; i < length; ++i)
   {
      // 32 = space, the lowest printable character
      
      int r1 = rand() % 0xFFEE;

      // careful not to use an expression as a parameter to max...
      
      int r2 = max(32, r1);

      ASSERT(r2);
      ASSERT(r2 >= 32);
      ASSERT(r2 < 0xFFEE);
      
      result[i] = (WCHAR) r2;
      ASSERT(result[i]);
   }

   result[length] = 0;

   return result;
}



void
TestEncryption(const EncryptedString& s, const WCHAR* sourceClearText)
{
   LOG_FUNCTION(TestEncryption);

   // decrypt s, compare it to sourceClearText

   WCHAR* clearText = s.GetClearTextCopy();

   // the decryption shouldn't fail (barring out-of-memory);
   
   ASSERT(clearText);
   ASSERT(wcscmp(clearText, sourceClearText) == 0);

   s.DestroyClearTextCopy(clearText);
}



void
TestEncryptionForStringOfLengthN(size_t length)
{
   LOG_FUNCTION2(TestEncryptionForStringOfLengthN, String::format(L"%1!d!", length));
   ASSERT(length <= EncryptedString::MAX_CHARACTER_COUNT);
   
   WCHAR* source = MakeRandomString(length);

   EncryptedString s;
   s.Encrypt(source);
   
   TestEncryption(s, source);

   EncryptedString s1(s);
   TestEncryption(s1, source);
   
   EncryptedString s2;
   s2 = s;

   TestEncryption(s2, source);

   delete[] source;
}



void
TestEncryptionFidelity()
{
   LOG_FUNCTION(TestEncryptionFidelity);

   // do we get out what we put in?

   srand(time(0));
   
   // test increasing lengths of random strings
   
   for (
      size_t length = 0;
      length <= EncryptedString::MAX_CHARACTER_COUNT;
      ++length)
   {
      TestEncryptionForStringOfLengthN(length);
   }

   // test decreasing lengths of random strings
   
   for (
      size_t length = EncryptedString::MAX_CHARACTER_COUNT;
      length != 0;
      --length)
   {
      TestEncryptionForStringOfLengthN(length);
   }

   // test strings of random length, with lots of outstanding encrypted
   // strings

   typedef std::list<EncryptedString*> ESPList;
   ESPList strings;
   
   for (
      int count = 0;
      count < 1000;
      ++count)
   {
      size_t length = rand() % EncryptedString::MAX_CHARACTER_COUNT;

      WCHAR* source = MakeRandomString(length);

      EncryptedString* ps = new EncryptedString;
      strings.push_back(ps);
      
      ps->Encrypt(source);
         
      TestEncryption(*ps, source);

      // make a copy via copy ctor
      
      EncryptedString* ps1 = new EncryptedString(*ps);
      strings.push_back(ps1);
      
      TestEncryption(*ps1, source);

      // make a copy via operator =
         
      EncryptedString* ps2 = new EncryptedString;
      strings.push_back(ps2);

      *ps2 = *ps;
   
      TestEncryption(*ps2, source);
   
      delete[] source;
   }
   
   for (
      ESPList::iterator i = strings.begin();
      i != strings.end();
      ++i)
   {
      (*i)->Clear();
      TestEmptyness(**i);
      delete *i;
   }
}



void
TestClearTextCopying()
{
   LOG_FUNCTION(TestClearTextCopying);

   // make a bunch of copies, make sure the count balances

   typedef char foo[2];


   // An encrypted string and the source string used to build it.
   
   typedef
      std::pair<EncryptedString*, WCHAR*>
      EncryptedAndSourcePair;

   // A list of results from EncryptedString::GetClearTextCopy
      
   typedef std::list<WCHAR*> ClearTextList;

   // A tuple of the encrypted string, its source string, and a list
   // of clear-text copies made from the encrypted string
   
   typedef
      std::pair<EncryptedAndSourcePair*, ClearTextList*>
      MasterAndClearTextCopiesPair;

   // A list of the above tuples.
      
   typedef
      std::list<MasterAndClearTextCopiesPair*>
      MasterAndCopiesList;

   MasterAndCopiesList mcList;
   
   for (int count = 0; count < 1000; ++count)
   {
      // Make a random source string
      
      size_t length = rand() % EncryptedString::MAX_CHARACTER_COUNT;
      WCHAR* source = MakeRandomString(length);

      // Make an encrypted string from it
      
      EncryptedString* ps = new EncryptedString;
      ps->Encrypt(source);

      // Make a pair of the encrypted string and its source string

      EncryptedAndSourcePair* esp = new EncryptedAndSourcePair(ps, source);
      
      // Make a list of clear-text copies of the encrypted string

      ClearTextList* ctList = new ClearTextList;

      // Make a master and copies pair

      MasterAndClearTextCopiesPair* mcPair = new MasterAndClearTextCopiesPair(esp, ctList);

      // add the master and copies pair to the master and copies list

      mcList.push_back(mcPair);

      int copyMax = max(1, rand() % 50);
      for (int copyCount = 0; copyCount < copyMax; ++copyCount)
      {
         // make some copies

         ctList->push_back(ps->GetClearTextCopy());
      }
   }

   for (
      MasterAndCopiesList::iterator i = mcList.begin();
      i != mcList.end();
      ++i)
   {
      EncryptedAndSourcePair* esp = (*i)->first;
      ClearTextList* ctList = (*i)->second;

      // delete each element of the ClearTextList

      for (
         ClearTextList::iterator j = ctList->begin();
         j != ctList->end();
         ++j)
      {
         // all copies should be identical

         ASSERT(wcscmp(esp->second, *j) == 0);

         esp->first->DestroyClearTextCopy(*j);
      }
      
      // delete the ClearTextList

      delete ctList;
      
      // delete the encrypted string

      delete esp->first;

      // delete the source string;

      delete[] esp->second;

      // delete the encrypted string/source string pair

      delete esp;

      // delete the master and copies pair

      delete *i;
   }
}



void
TestAssignment()
{
   LOG_FUNCTION(TestAssignment);
}



void
TestEquality(const EncryptedString& s, const EncryptedString& s1, size_t length)
{
   LOG_FUNCTION(TestEquality);

   // a string is equal to itself

   ASSERT(s == s);
   ASSERT(s1 == s1);

   // a string is equal to a copy of itself

   ASSERT(s1 == s);

   // a copy is equal to its source
   
   ASSERT(s == s1);

   // a copy is equal to itself

   ASSERT(s1 == s1);
   
   // a copy is the same length as its source

   ASSERT(s1.GetLength() == length);
   ASSERT(s.GetLength() == length);
   
   // a string is the same length as its copy

   ASSERT(s1.GetLength() == s.GetLength());
}



void
TestEqualityForStringOfLengthN(size_t length)
{
   LOG_FUNCTION2(TestEncryptionForStringOfLengthN, String::format(L"%1!d!", length));
   ASSERT(length <= EncryptedString::MAX_CHARACTER_COUNT);
   
   WCHAR* source = MakeRandomString(length);

   EncryptedString s;
   s.Encrypt(source);
   ASSERT(s.GetLength() == length);
   
   EncryptedString s1(s);
   ASSERT(s1.GetLength() == length);

   TestEquality(s, s1, length);
   
   EncryptedString s2;
   s2 = s;

   TestEquality(s, s2, length);
   TestEquality(s1, s2, length);
      
   // a copy is not equal to its source when the source is changed

   s.Encrypt(L"Something else...");
   ASSERT(s != s1);
   ASSERT(s != s2);
   ASSERT(s2 != s);
   ASSERT(s1 != s);
   
   TestEquality(s1, s2, length);
   
   delete[] source;
}
   


void
DoEqualityTests()
{
   LOG_FUNCTION(DoEqualityTests);

   for (
      size_t length = 0;
      length <= EncryptedString::MAX_CHARACTER_COUNT;
      ++length)
   {
      TestEqualityForStringOfLengthN(length);
   }
   
}



void
TestInequality()
{
   LOG_FUNCTION(TestInequality);
}



void
TestBoundaries()
{
   LOG_FUNCTION(TestBoundaries);
}

      

void
TestLigitimateUse()
{
   LOG_FUNCTION(TestLigitimateUse);

   TestEmptyStrings();
   TestClearTextCopying();
   TestEncryptionFidelity();
   TestAssignment();
   DoEqualityTests();
   TestInequality();
   TestBoundaries();
}



void
TestIlllegitimateUse()
{
   LOG_FUNCTION(TestIlllegitimateUse);
   
   // make strings that are too long,
   // make unbalanced cleartext copyies (call Destroy too many times, not enough times)   
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   TestLigitimateUse();
   TestIlllegitimateUse();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-fs-2.cpp ===
// Test miscellaneous FS:: stuff



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-2";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
testVerifyDevicePathIsNotValidHelper(const String& root)
{
   LOG_FUNCTION2(testVerifyDevicePathIsNotValidHelper, root);

   ASSERT(!FS::IsValidPath(L"C:\\temp\\" + root));
   ASSERT(!FS::IsValidPath(L"C:\\" + root));
   ASSERT(!FS::IsValidPath(L"C:" + root));
   ASSERT(!FS::IsValidPath(root));
   ASSERT(!FS::IsValidPath(L"C:\\temp\\" + root + L":"));
}


   
void   
testVerifyDevicePathIsNotValid(const String& root)
{
   LOG_FUNCTION2(testVerifyDevicePathIsNotValid, root);
   
   testVerifyDevicePathIsNotValidHelper(root);
   testVerifyDevicePathIsNotValidHelper(root + L".txt");
}



void
testDevicePaths()
{
   // The following reserved words cannot be used as the name of a file:
   // CON, PRN, AUX, CLOCK$, NUL, COM1, COM2, COM3, COM4, COM5, COM6, COM7,
   // COM8, COM9, LPT1, LPT2, LPT3, LPT4, LPT5, LPT6, LPT7, LPT8, and LPT9.
   // Also, reserved words followed by an extension for example,
   // NUL.tx7 is invalid.
   
   testVerifyDevicePathIsNotValid(L"PRN");
   testVerifyDevicePathIsNotValid(L"AUX");
   testVerifyDevicePathIsNotValid(L"NUL");
   testVerifyDevicePathIsNotValid(L"COM1");
   testVerifyDevicePathIsNotValid(L"COM2");
   testVerifyDevicePathIsNotValid(L"LPT1");

   LOG(L"stage 2");

   // ISSUE-2002/04/15-sburns
   // these currently fail the test:
   
   testVerifyDevicePathIsNotValid(L"CON");
   testVerifyDevicePathIsNotValid(L"CLOCK$");
   testVerifyDevicePathIsNotValid(L"COM3");
   testVerifyDevicePathIsNotValid(L"COM4");
   testVerifyDevicePathIsNotValid(L"COM5");
   testVerifyDevicePathIsNotValid(L"COM6");
   testVerifyDevicePathIsNotValid(L"COM7");
   testVerifyDevicePathIsNotValid(L"COM8");
   testVerifyDevicePathIsNotValid(L"COM9");
   testVerifyDevicePathIsNotValid(L"LPT2");
   testVerifyDevicePathIsNotValid(L"LPT3");
   testVerifyDevicePathIsNotValid(L"LPT4");
   testVerifyDevicePathIsNotValid(L"LPT5");
   testVerifyDevicePathIsNotValid(L"LPT6");
   testVerifyDevicePathIsNotValid(L"LPT7");
   testVerifyDevicePathIsNotValid(L"LPT8");
   testVerifyDevicePathIsNotValid(L"LPT9");
}
   
      

void
testIsValidPath(const String& sourceDir)
{
   LOG_FUNCTION2(testIsValidPath, sourceDir);

   AnsiOutLn(
      String::format(
         L"%1 %2 a valid path.",
         sourceDir.c_str(),
         FS::IsValidPath(sourceDir) ? L"is" : L"is NOT"));
}



void
testPathExists(const String& sourceDir)
{
   LOG_FUNCTION(testPathExists);

   AnsiOutLn(
      String::format(
         L"%1 %2 exist.",
         sourceDir.c_str(),
         FS::PathExists(sourceDir) ? L"does" : L"does NOT"));
}



void
testGetFileSystemType(const String& sourceDir)
{
   LOG_FUNCTION(testGetFileSystemType);

   typedef
      std::map<
         FS::FSType,
         String,
         std::less<FS::FSType>,
         Burnslib::Heap::Allocator<String> >
      TypeDescMap;

   TypeDescMap tdMap;

   tdMap[FS::FAT]   = L"FAT";  
   tdMap[FS::CDFS]  = L"CDFS"; 
   tdMap[FS::NTFS4] = L"NTFS4";
   tdMap[FS::NTFS5] = L"NTFS5";

   AnsiOutLn(
      String::format(
         L"%1 is on a volume formatted for %2.",
         sourceDir.c_str(),
         tdMap[FS::GetFileSystemType(sourceDir)].c_str()));
}



void
testGetRootFolder(const String& sourceDir)
{
   LOG_FUNCTION(testGetRootFolder);

   AnsiOutLn(
      String::format(
         L"root folder = %1",
         FS::GetRootFolder(sourceDir).c_str()));
}



void
testSplitPath(const String& sourceDir)
{
   LOG_FUNCTION(testSplitPath);

   String drive;
   String folderPath;
   String fileName;
   String extension;

   FS::SplitPath(sourceDir, drive, folderPath, fileName, extension);

   AnsiOutLn(L"SplitPath:");
   AnsiOutLn(L"drive     : " + drive);
   AnsiOutLn(L"folderPath: " + folderPath);
   AnsiOutLn(L"fileName  : " + fileName);
   AnsiOutLn(L"extension : " + extension);
}



void
testNormalizePath(const String& sourcePath)
{
   String normal = FS::NormalizePath(sourcePath);

   AnsiOutLn(L"normalized: " + normal);
}
   


VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      AnsiOutLn(L"missing filespec - path to validate.  may be UNC or absolute");
      exit(0);
   }

   String sourceDir = args[1];
   AnsiOutLn(sourceDir);
   AnsiOutLn(L"=================");

   testDevicePaths();
   testIsValidPath(sourceDir);
   testPathExists(sourceDir);
   testSplitPath(sourceDir);
   testGetRootFolder(sourceDir);
   testGetFileSystemType(sourceDir);
   testNormalizePath(sourceDir);


   // test that IsParentFolder is not fooled by "c:\a\b\c", "c:\a\b\cde"

   // test that CopyFile, when cancelled, returns an HRESULT that indicates
   // cancellation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-fs-getvaliddrives.cpp ===
// Test FS::GetValidDrives
//
// 3 April 2002 sburns




#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-fs-GetValidDrives";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



template <class BackInsertableContainer>
void
GetValidDrivesTest(BackInsertableContainer& bic)
{
   LOG_FUNCTION(GetValidDrivesTest);
   
   HRESULT hr = FS::GetValidDrives(std::back_inserter(bic));

   AnsiOutLn(String::format(L"HRESULT = %1!8X!", hr));
   
   for (
      BackInsertableContainer::iterator i = bic.begin();
      i != bic.end();
      ++i)
   {
      AnsiOutLn(*i);
   }

   AnsiOutLn(L"");
}
   


VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector sv;
   GetValidDrivesTest(sv);

   StringList sl;
   GetValidDrivesTest(sl);

   // the containers should hold the same results
   
   ASSERT(sv.size() == sl.size());

   StringVector::iterator svi;
   StringList::iterator sli;
   
   for(
      svi = sv.begin(), sli = sl.begin();
      svi != sv.end();
      ++svi, ++sli)
   {
      ASSERT(*svi == *sli);
   }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-paranoia-exenvstr.cpp ===
// Copyright (C) 2002 Microsoft Corporation
// Test updated pseudoparanoid behavior of Win::ExpandEnvironmentStrings
// and Win::GetEnvironmentVariable
// t-mhock

// Win::ExpandEnvironmentStrings (and Win::GetEnvironmentVariable) would
// create Strings with too many nul terminators (3 instead of 1), which
// didn't usually matter unless two Strings are concatenated.

#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-paranoia-exenvstr";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;

void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}

VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);
   
   // This demonstrates that my fix does something
   std::wcout << Win::ExpandEnvironmentStrings(L"%ProgramFiles%") << L"\\myprogram" << std::endl;
   std::wcout << (Win::ExpandEnvironmentStrings(L"%ProgramFiles%") + L"\\myprogram") << std::endl;
   std::wcout << Win::GetEnvironmentVariable(L"ProgramFiles") << L"\\myprogram" << std::endl;
   std::wcout << (Win::GetEnvironmentVariable(L"ProgramFiles") + L"\\myprogram") << std::endl;
   std::wcout << L"The four lines above should be the same" << std::endl;

   // This demonstrates that my fix doesn't break anything
   // The only nontrivial usage of the result of ExpandEnvironmentStrings that I found was in
   // dcpromo's State::SetupAnswerFile() which performs the following operations:

   String f = Win::ExpandEnvironmentStrings(L"%ProgramFiles%");
   if (FS::NormalizePath(f) != f) {
      std::wcout << L"Normalized " << f << " != original: existing usage affected";
      return;
   }
   if (!FS::PathExists(f))
   {
      std::wcout << f << L" does not exist though it should: existing usage affected";
   } else {
      std::wcout << f << L" exists: existing usage should be unaffected";
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-fs-iterator.cpp ===
// Test FS::Iterator



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
iterate(FS::Iterator& iter)
{
   LOG_FUNCTION(iterate);

   HRESULT hr = S_OK;

   int count = 0;

   String current;

   while ((hr = iter.GetCurrent(current)) == S_OK)
   {
      AnsiOutLn(current);
      count++;

      hr = iter.Increment();
      BREAK_ON_FAILED_HRESULT(hr);
   }

   AnsiOutLn(String::format(L"%1!d!", count));
}
   


void
testIterator1(const String& sourceDir)
{
   LOG_FUNCTION(testIterator1);

   AnsiOutLn(L"test 1: files and directories, no dot paths, relative paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::INCLUDE_FOLDERS);

   iterate(iter);
}



void
testIterator2(const String& sourceDir)
{
   LOG_FUNCTION(testIterator2);

   AnsiOutLn(L"test 1: files and directories, dot paths, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::INCLUDE_FOLDERS
      |  FS::Iterator::INCLUDE_DOT_PATHS
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



void
testIterator3(const String& sourceDir)
{
   LOG_FUNCTION(testIterator3);

   AnsiOutLn(L"test 1: files only, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FILES
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



void
testIterator4(const String& sourceDir)
{
   LOG_FUNCTION(testIterator4);

   AnsiOutLn(L"test 4: folders only, full paths");

   FS::Iterator iter(
      sourceDir,
         FS::Iterator::INCLUDE_FOLDERS
      |  FS::Iterator::RETURN_FULL_PATHS);

   iterate(iter);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   StringVector args;
   int argc = Win::GetCommandLineArgs(std::back_inserter(args));

   if (argc < 2)
   {
      AnsiOutLn(L"missing filespec - path w/ wildcards to iterate over (non-destructive)");
      exit(0);
   }

   String sourceDir = args[1];
   AnsiOutLn(sourceDir);

   testIterator1(sourceDir);
   testIterator2(sourceDir);
   testIterator3(sourceDir);
   testIterator4(sourceDir);


   // test that iterator without wildcard includes just the one file or folder,
   // and that if the filter options so indicate, that one is not returned.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-reboot.cpp ===
// test Reboot()



#include "headers.hxx"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME = L"test";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   Reboot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-substr.cpp ===
// Copyright (C) 2002 Microsoft Corporation
// Test whether substr leaks
// t-mhock

#include "headers.hxx"
#include <iostream>


HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-paranoia-exenvstr";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;

void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}

VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

   String teststr(L"a");

   // Create a Morse-Thue sequence
   // The sequence does not have three in a row of any subsequence
   // (e.g. it is highly nonrepetitive)

   for (int i = 0; i < 20; i++)
   {
      String tmp(teststr);
      for (int j = 0; j < (int)tmp.size(); j++)
      {
         if (tmp[j] == L'a')
         {
            tmp[j] = L'b';
         }
         else
         {
            tmp[j] = L'a';
         }
      }
      teststr += tmp;
   }

   // Spin forever while doing all n(n+1)/2 possible substrings
   // as well as n+1 zero length ones for kicks
   // Watch that memory usage grow!
   while (1)
   {
      for (int i = 0; i < (int)teststr.size(); i++)
      {
         for (int j = i; j < (int)teststr.size(); j++)
         {
            String *subbed;
            subbed = new String(teststr.substr(i, j-i));
            delete subbed;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\burnslib\src\test\test-win-1.cpp ===
// Test miscellaneous Win:: stuff



#include "headers.hxx"
#include <iostream>



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;
const wchar_t* RUNTIME_NAME  = L"test-win-1";

DWORD DEFAULT_LOGGING_OPTIONS = Burnslib::Log::OUTPUT_TYPICAL;



void
AnsiOut(const String& wide)
{
   AnsiString ansi;

   wide.convert(ansi);

   std::cout << ansi;
}



void
AnsiOutLn(const String& wide)
{
   AnsiOut(wide);
   std::cout << std::endl;
}



void
testGetModuleFileName()
{
   LOG_FUNCTION(testGetModuleFileName);

   AnsiOutLn(Win::GetModuleFileName(0));

   static const String KNOWN_DLL(L"shell32.dll");
   
   HMODULE module = 0;
   HRESULT hr =
      Win::LoadLibrary(KNOWN_DLL, module);
   ASSERT(SUCCEEDED(hr));

   String s = Win::GetModuleFileName(module);
   ASSERT(!s.empty());
   ASSERT(FS::IsValidPath(s));
   ASSERT(FS::GetPathLeafElement(s).icompare(KNOWN_DLL) == 0);

   AnsiOutLn(s);
}



VOID
_cdecl
main(int, char **)
{
   LOG_FUNCTION(main);

//    StringVector args;
//    int argc = Win::GetCommandLineArgs(std::back_inserter(args));
// 
//    if (argc < 2)
//    {
//       AnsiOutLn(L"missing filespec - path w/ wildcards to iterate over (non-destructive)");
//       exit(0);
//    }
// 
//    String sourceDir = args[1];
//    AnsiOutLn(sourceDir);

   testGetModuleFileName();


   // test that IsParentFolder is not fooled by "c:\a\b\c", "c:\a\b\cde"

   // test that CopyFile, when cancelled, returns an HRESULT that indicates
   // cancellation
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\bootcfg64.h ===
#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#define ALIGN_DOWN(length, type) \
    ((ULONG)(length) & ~(sizeof(type) - 1))

#define ALIGN_UP(length, type) \
    (ALIGN_DOWN(((ULONG)(length) + sizeof(type) - 1), type))


#define MBE_STATUS_IS_NT        0x00000001

#define MBE_IS_NT(_be) (((_be)->Status & MBE_STATUS_IS_NT) != 0)
#define MBE_SET_IS_NT(_be) ((_be)->Status |= MBE_STATUS_IS_NT)

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PLIST_ENTRY ListHead;
    PUCHAR AllocationEnd;
    ULONG Ordered;
    ULONG Status;
    ULONG myId;
    ULONG Id;
    ULONG Attributes;
    PWSTR FriendlyName;
    ULONG FriendlyNameLength;
    PWSTR OsLoadOptions;
    ULONG OsLoadOptionsLength;
    PFILE_PATH BootFilePath;
    PFILE_PATH OsFilePath;
    PUCHAR ForeignOsOptions;
    ULONG ForeignOsOptionsLength;
    BOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;



DWORD InitializeEFI(void);
BOOL  QueryBootIniSettings_IA64(DWORD argc, LPCTSTR argv[]);
DWORD DeleteBootIniSettings_IA64(DWORD argc, LPCTSTR argv[]);
DWORD CopyBootIniSettings_IA64(DWORD argc, LPCTSTR argv[]);
DWORD ChangeTimeOut_IA64(DWORD argc, LPCTSTR argv[]);
DWORD RawStringOsOptions_IA64(DWORD argc, LPCTSTR argv[]);
DWORD ChangeDefaultBootEntry_IA64(DWORD argc, LPCTSTR argv[]);

NTSTATUS BootCfg_EnumerateBootEntries(PBOOT_ENTRY_LIST *ntBootEntries);
NTSTATUS BootCfg_QueryBootOptions(PBOOT_OPTIONS *ppBootOptions);

PWSTR GetNtNameForFilePath (IN PFILE_PATH FilePath);
DWORD ChangeBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName, LPTSTR lpOSLoadOptions);
//DWORD CopyBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName);
DWORD ModifyBootOptions(ULONG Timeout, LPTSTR pHeadlessRedirection, ULONG NextBootEntryID, ULONG Flag);

PMY_BOOT_ENTRY CreateBootEntryFromBootEntry (IN PMY_BOOT_ENTRY OldBootEntry);

BOOL IsBootEntryWindows(PBOOT_ENTRY bootEntry);

PWSTR
GetNtNameForFilePath (IN PFILE_PATH FilePath);

DWORD ConvertBootEntries (PBOOT_ENTRY_LIST BootEntries);
VOID DisplayBootEntry();
DWORD DisplayBootOptions();
DWORD GetCurrentBootEntryID(DWORD Id);

DWORD ProcessDebugSwitch_IA64(  DWORD argc, LPCTSTR argv[] );

VOID  GetComPortType_IA64( LPTSTR  szString,LPTSTR szTemp );
DWORD ProcessEmsSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessAddSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessRmSwSwitch_IA64(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessDbg1394Switch_IA64(DWORD argc,LPCTSTR argv[]);

VOID displayListUsage_IA64();
VOID displayUpdateUsage_IA64();
DWORD ProcessUpdateSwitch_IA64(  DWORD argc, LPCTSTR argv[] );

#define PORT_COM1A  _T("/debugport=COM1")
#define PORT_COM2A  _T("/debugport=COM2")
#define PORT_COM3A  _T("/debugport=COM3")
#define PORT_COM4A  _T("/debugport=COM4")
#define PORT_1394A  _T("/debugport=1394")


//#ifdef _WIN64

#define PARTITION_TABLE_OFFSET 446
#define PART_NAME_LEN 36
#define GPT_PART_SIGNATURE 0x5452415020494645

#define TOKEN_BACKSLASH4 _T("\\\\")
#define SUBKEY1 _T("SYSTEM\\SETUP")

#define IDENTIFIER_VALUE2 _T("SystemPartition")
#define IDENTIFIER_VALUE3 _T("OsLoaderPath")
#define ARC_SIGNATURE     _T("signature({%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}-%08x-%016I64x-%016I64x)")



 typedef struct _GPT_ENTRY
{
    GUID    PartitionTypeGUID;  // declartion of this partition's type
    GUID    UniquePartitionGUID;    // Unique ID for this particular partition
                                // (unique to this instance)
    UINT64  StartingLBA;    // 0 based block (sector) address of the
                                // first block included in the partition.
    UINT64  EndingLBA;      // 0 based block (sector) address of the
                                // last block included in the partition.
                                // If StartingLBA == EndingLBA then the
                                // partition is 1 block long.  this is legal.
    UINT64  Attributes;     // Always ZERO for now
    WCHAR   PartitionName[PART_NAME_LEN];  // 36 unicode characters of name
    struct _GPT_ENTRY *NextGPTEntry;
} GPT_ENTRY, *PGPT_ENTRY;

typedef struct _GPT_HEADER
{
    UINT64  Signature;      // GPT PART
    UINT32  Revision;
    UINT32  HeaderSize;
    UINT32  HeaderCRC32;    // computed using 0 for own init value
    UINT32  Reserved0;
    UINT64  MyLBA;          // 0 based sector number of the first
                                // sector of this structure
    UINT64  AlternateLBA;   // 0 based sector (block) number of the
                                // first sector of the secondary
                                // GPT_HEADER, or 0 if this is the
                                // secondary.
    UINT64  FirstUsableLBA; // 0 based sector number of the first
                                // sector that may be included in a partition.
    UINT64  LastUsableLBA;  // last legal LBA, inclusive.
    GUID    DiskGUID;       // The unique ID of this LUN/spindle/disk
    UINT64  PartitionEntryLBA;       // The start of the table of entries...
    UINT32  NumberOfPartitionEntries; // Number of entries in the table, this is
                                  // how many allocated, NOT how many used.
    UINT32  SizeOfPartitionEntry;    // sizeof(GPT_ENTRY) always mult. of 8
    UINT32  PartitionEntryArrayCRC32;      // CRC32 of the table.
    // Reserved and zeros to the end of the block
    // Don't declare an array or sizeof() gives a nonsense answer..

    // Computed data
    UINT32  ComputedHeaderCRC32;
    UINT32  ComputedPartitionEntryArrayCRC32;
    UINT32  UsedPartitionEntries;
    PGPT_ENTRY FirstGPTEntry;
    BOOLEAN Healthy;
} GPT_HEADER, *PGPT_HEADER;

UINT32  ScanGPT(DWORD nPhysicalDisk);
DWORD ProcessMirrorSwitch_IA64(DWORD argc,LPCTSTR argv[]) ;
DWORD GetBootFilePath(LPTSTR szComputerName,LPTSTR szBootPath);
BOOL GetARCSignaturePath(LPTSTR szString,LPTSTR szFinalPath);


DWORD ProcessMirrorBootEntry(PBOOT_ENTRY bootEntry, PWSTR lpBootFilePath,LPTSTR OsFilePath);
DWORD GetDeviceInfo(LPTSTR szGUID,LPTSTR szFinalStr,DWORD dwDriveNum,DWORD dwActuals);

PBOOT_ENTRY FillBootEntry(PBOOT_ENTRY bootEntry,LPTSTR szBootPath,LPTSTR szArcPath);

LPVOID MEMALLOC( ULONG size );

VOID MEMFREE ( LPVOID block );

LONG LowNtAddBootEntry(
    IN WCHAR *pwszLoaderPath,
    IN WCHAR *pwszArcString
    );


DWORD FormARCPath(LPTSTR szGUID,LPTSTR szFinalStr);

LONG LowNtAddBootEntry( IN WCHAR *pwszLoaderPath,IN WCHAR *pwszArcString) ;

DWORD GetBootPath(LPTSTR szValue,LPTSTR szResult);
LONG AddBootEntry( IN WCHAR *pwszLoaderPath,IN WCHAR *pwszArcString  );

NTSTATUS LowGetPartitionInfo(     IN HANDLE handle,OUT PARTITION_INFORMATION_EX   *partitionData    );

LONG DmCommonNtOpenFile(IN PWSTR     Name,    IN ULONG   access,    IN PHANDLE Handle  );

DWORD AddMirrorPlex(LPTSTR szOsLoadPath , LPTSTR szLoaderPath , LPTSTR szValue ,BOOL bFlag,LPTSTR szFriendlyName);

BOOL FormatAccToLocale( NUMBERFMT  *pNumberFmt,LPTSTR* pszGroupSep,LPTSTR* pszDecimalSep,LPTSTR* pszGroupThousSep);

BOOL GetInfo( LCTYPE lctype, LPTSTR* pszData );

DWORD
 ConvertintoLocale( IN LPWSTR  szTempBuf,
                    OUT LPWSTR szOutputStr );

DWORD CopyBootEntry(PBOOT_ENTRY bootEntry, LPTSTR lpNewFriendlyName,BOOL bFlag);


#define SAFEMEMFREE(pVal) \
if ( pVal ) { \
        MEMFREE(pVal);\
        pVal = NULL ; \
    }

    
DWORD IsAdminGroup( BOOL *bAdmin );
BOOL GetTokenHandle(OUT PHANDLE hTokenHandle);
BOOL CheckAdminAccess( LPCTSTR pszMachine );
VOID Freelist();
PWSTR GetDefaultBootEntry();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\bootcfg64.c ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        BootCfg64.cpp

    Abstract:


        This file is intended to have the functionality for
        configuring, displaying, changing and deleting boot.ini
        settings for the local host for a 64 bit system.

    Author:

        J.S.Vasu           17/1/2001 .

    Revision History:


        J.S.Vasu            17/1/2001        Created it.

        SanthoshM.B         10/2/2001        Modified it.

        J.S.Vasu            15/2/2001        Modified it.

******************************************************************************/

#include "pch.h"
#include "resource.h"
#include "BootCfg.h"
#include "BootCfg64.h"
#include <strsafe.h>

#define BOOTFILE_PATH1      L"signature({%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x})%s"
#define BOOTFILE_PATH       L"signature({%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x})%s\\ia64ldr.efi"

NTSTATUS ModifyBootEntry(    IN WCHAR *pwszInstallPath,    IN PBOOT_ENTRY pSourceEntry);
NTSTATUS FindBootEntry(IN PVOID pEntryListHead,IN WCHAR *pwszTarget, OUT PBOOT_ENTRY *ppTargetEntry);
LPVOID MEMALLOC( ULONG size ) ;
VOID MEMFREE ( LPVOID block ) ;
NTSTATUS EnumerateBootEntries( IN PVOID *ppEntryListHead);
NTSTATUS AcquirePrivilege(IN CONST ULONG ulPrivilege,IN CONST BOOLEAN bEnable);
DWORD ListDeviceInfo(DWORD dwVal);

//Global Linked lists for storing the boot entries
LIST_ENTRY BootEntries;
LIST_ENTRY ActiveUnorderedBootEntries;
LIST_ENTRY InactiveUnorderedBootEntries;

DWORD InitializeEFI(void)
/*++

  Routine Description :
                    This routine initializes the EFI environment required.
                    Initializes the function pointers for the
                    NT Boot Entry Management API's

  Arguments           : None

  Return Type         : DWORD
                        Returns EXIT_SUCCESS if successful,
                        returns EXIT_FAILURE otherwise.
--*/
{
    DWORD error;
    NTSTATUS status;
    BOOLEAN wasEnabled;
    HMODULE hModule;
    PBOOT_ENTRY_LIST ntBootEntries = NULL;
    PMY_BOOT_ENTRY bootEntry;
    PLIST_ENTRY listEntry;
    PULONG BootEntryOrder;
    ULONG BootEntryOrderCount;
    ULONG length, i, myId;
    TCHAR dllName[MAX_PATH];

     if( FALSE == IsUserAdmin() )
     {
        ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_64 ));
        ReleaseGlobals();
        return EXIT_FAILURE;
     }


    // Enable the privilege that is necessary to query/set NVRAM.
    status = RtlAdjustPrivilege(SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                                TRUE,
                                FALSE,
                                &wasEnabled
                                );
    if (!NT_SUCCESS(status))
    {
        error = RtlNtStatusToDosError( status );
        ShowMessage( stderr, GetResString(IDS_INSUFF_PRIV));
        return EXIT_FAILURE ;
    }

    // Load ntdll.dll from the system directory. This is used to get the
    // function addresses for the various NT Boot Entry Management API's used by
    // this tool.

    if(!GetSystemDirectory( dllName, MAX_PATH ))
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return EXIT_FAILURE ;
    }

    StringConcat(dllName, _T("\\ntdll.dll"), SIZE_OF_ARRAY(dllName));

    hModule = LoadLibrary( dllName );
    if ( hModule == NULL )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return EXIT_FAILURE ;
    }

    // Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        if ( status == STATUS_SUCCESS )
        {
            length = 0;
        }
        else
        {
            error = RtlNtStatusToDosError( status );
            ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );
            return EXIT_FAILURE ;
        }
    }
    if ( length != 0 )
    {
        BootEntryOrder = (PULONG)AllocateMemory( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return EXIT_FAILURE ;
        }
        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
        {
            error = RtlNtStatusToDosError( status );
            ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );
            if(BootEntryOrder)
            {
                FreeMemory((LPVOID *)&BootEntryOrder);
            }
            return EXIT_FAILURE ;
        }
    }

    BootEntryOrderCount = length;

    //Enumerate all the boot entries
    status = BootCfg_EnumerateBootEntries(&ntBootEntries);
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        //free the ntBootEntries list
        if(ntBootEntries)
        {
            FreeMemory((LPVOID *)&ntBootEntries);
        }
        if(BootEntryOrder)
        {
            FreeMemory((LPVOID *)&BootEntryOrder);
        }
        return EXIT_FAILURE ;
    }

    //Initialize the various head pointers
    InitializeListHead( &BootEntries );
    InitializeListHead( &ActiveUnorderedBootEntries );
    InitializeListHead( &InactiveUnorderedBootEntries );

    //Convert the bootentries into our know format -- MY_BOOT_ENTRIES.
    if(ConvertBootEntries( ntBootEntries ) == EXIT_FAILURE)
    {
        if(ntBootEntries)
        {
            FreeMemory((LPVOID *)&ntBootEntries);
        }
        if(BootEntryOrder)
        {
            FreeMemory((LPVOID *)&BootEntryOrder);
        }
        return EXIT_FAILURE ;
    }

    //free the memory allocated for the enumeration
    if(ntBootEntries)
    {
        FreeMemory((LPVOID *)&ntBootEntries);
    }

    // Build the ordered boot entry list.

    myId = 1;

    for ( i = 0; i < BootEntryOrderCount; i++ )
    {
        ULONG id = BootEntryOrder[i];
        for ( listEntry = ActiveUnorderedBootEntries.Flink;
              listEntry != &ActiveUnorderedBootEntries;
               listEntry = listEntry->Flink )
        {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id )
            {
                //Mark this entry as "Ordered" as the ordered id is found
                bootEntry->Ordered = 1;
                //Assign the internal ID
                bootEntry->myId = myId++;
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
        for ( listEntry = InactiveUnorderedBootEntries.Flink;
        listEntry != &InactiveUnorderedBootEntries;
        listEntry = listEntry->Flink )
        {
            bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
            if ( bootEntry->Id == id )
            {
                //Mark this entry as ordered as the ordered id is found
                bootEntry->Ordered = 1;
                //Assign the internal ID
                bootEntry->myId = myId++;
                listEntry = listEntry->Blink;
                RemoveEntryList( &bootEntry->ListEntry );
                InsertTailList( &BootEntries, &bootEntry->ListEntry );
                bootEntry->ListHead = &BootEntries;
            }
        }
    }

    //Now add the boot entries that are not a part of the ordered list
    for (listEntry = ActiveUnorderedBootEntries.Flink;
    listEntry != &ActiveUnorderedBootEntries;
    listEntry = listEntry->Flink )
    {
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        if ( bootEntry->Ordered != 1 )
        {
            //Assign the internal ID
            bootEntry->myId = myId++;
            listEntry = listEntry->Blink;
            RemoveEntryList( &bootEntry->ListEntry );
            InsertTailList( &BootEntries, &bootEntry->ListEntry );
            bootEntry->ListHead = &BootEntries;
        }
    }
    for (listEntry = InactiveUnorderedBootEntries.Flink;listEntry != &InactiveUnorderedBootEntries;listEntry = listEntry->Flink)
    {
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        if ( bootEntry->Id != 1 )
        {
            //Assign the internal ID
            bootEntry->myId = myId++;
            listEntry = listEntry->Blink;
            RemoveEntryList( &bootEntry->ListEntry );
            InsertTailList( &BootEntries, &bootEntry->ListEntry );
            bootEntry->ListHead = &BootEntries;
        }
    }

    if(BootEntryOrder)
    {
        FreeMemory((LPVOID *)&BootEntryOrder);
    }

    return EXIT_SUCCESS ;
}

BOOL QueryBootIniSettings_IA64( DWORD argc, LPCTSTR argv[])
/*++
  Name            : QueryBootIniSettings_IA64

  Synopsis        : This routine is displays the boot entries and their settings
                    for an EFI based machine

  Parameters      : None

  Return Type     : VOID

  Global Variables: Global Linked lists for storing the boot entries
                      LIST_ENTRY BootEntries;
--*/
{

// Builiding the TCMDPARSER structure

    BOOL bQuery = FALSE ;
    BOOL bUsage = FALSE ;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[2];
    PTCMDPARSER2 pcmdOption; 

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_QUERY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bQuery;

    //usage option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_QUERY_USAGE));
        return ( EXIT_FAILURE );
    }

    if( bUsage )
    {
        displayQueryUsage();
        return EXIT_SUCCESS ;
    }
     
    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    if(DisplayBootOptions() == EXIT_FAILURE)
    {
        return EXIT_FAILURE;
    }

    DisplayBootEntry();

    //Remember to free the memory for the linked lists here
    Freelist();

    return EXIT_SUCCESS;
}

NTSTATUS
BootCfg_EnumerateBootEntries(
                             PBOOT_ENTRY_LIST *ntBootEntries
                            )
/*++
    Routine Description :
                    This routine enumerates the boot entries and fills the
                    BootEntryList
                    This routine will fill in the Boot entry list. The caller
                    of this function needs to free the memory for ntBootEntries.

  Arguments
        ntBootEntries  : Pointer to the BOOT_ENTRY_LIST structure

  Return Type     : NTSTATUS
--*/
{
    DWORD error;
    NTSTATUS status;
    ULONG length = 0;

    // Query all existing boot entries.
    status = NtEnumerateBootEntries( NULL, &length );
    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        if ( status == STATUS_SUCCESS )
        {
            length = 0;
        }
        else
        {
            error = RtlNtStatusToDosError( status );
            ShowMessage(stderr,GetResString(IDS_ERROR_ENUM_BOOTENTRY) );
        }
    }

    if ( length != 0 )
    {
        *ntBootEntries = (PBOOT_ENTRY_LIST)AllocateMemory( length );
        if(*ntBootEntries == NULL)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return STATUS_UNSUCCESSFUL;
        }

        status = NtEnumerateBootEntries( *ntBootEntries, &length );
        if ( status != STATUS_SUCCESS )
        {
            error = RtlNtStatusToDosError( status );
            FreeMemory((LPVOID *)&(*ntBootEntries) );
            ShowMessage(stderr,GetResString(IDS_ERROR_ENUM_BOOTENTRY) );
        }
    }
    return status;
}


NTSTATUS
BootCfg_QueryBootOptions( IN PBOOT_OPTIONS *ppBootOptions)
/*++
  Routine Description :
                    This routine enumerates the boot options and fills the
                    BOOT_OPTIONS
                    The caller of this function needs to free the memory for
                    BOOT_OPTIONS.

  Arguments
          ppBootOptions  : Pointer to the BOOT_ENTRY_LIST structure

  Return Type     : NTSTATUS
--*/
{
    DWORD error;
    NTSTATUS status;
    ULONG length = 0;

    //Querying the Boot options

    status = NtQueryBootOptions( NULL, &length );
    if ( status == STATUS_NOT_IMPLEMENTED )
    {
        ShowMessage( stderr,GetResString(IDS_NO_EFINVRAM) );
        return STATUS_UNSUCCESSFUL;
    }

    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        error = RtlNtStatusToDosError( status );
        ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTOPTIONS) );
        return STATUS_UNSUCCESSFUL;
    }

    *ppBootOptions = (PBOOT_OPTIONS)AllocateMemory(length);
    if(*ppBootOptions == NULL)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return STATUS_UNSUCCESSFUL;
    }

    status = NtQueryBootOptions( *ppBootOptions, &length );
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTOPTIONS) );
        FreeMemory( (LPVOID *) &*ppBootOptions );
        return STATUS_UNSUCCESSFUL;
    }
    return status;
}

DWORD
RawStringOsOptions_IA64( IN DWORD argc,
                         IN LPCTSTR argv[]
                        )
/*++
  Routine Description :
                   Allows the user to add the OS load options specifed
                   as a raw string at the cmdline to the boot

  Arguments
         [ in ] argc - Number of command line arguments
         [ in ] argv - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if function is successful,
                       returns EXIT_FAILURE otherwise.
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bRaw = FALSE ;
    DWORD dwBootID = 0;
    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;

    STRING256 szRawString     = NULL_STRING ;
    BOOL bAppendFlag = FALSE ;

    STRING256 szAppendString = NULL_STRING ;
    PWINDOWS_OS_OPTIONS pWindowsOptions;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[5];
    PTCMDPARSER2 pcmdOption;

    // Building the TCMDPARSER structure
    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RAW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bRaw;

    //usage option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //id option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

    //default option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szRawString;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //append option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_APPEND;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bAppendFlag;

    // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_RAW_USAGE));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayRawUsage_IA64();
        return (EXIT_SUCCESS);
    }


    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //Trim any leading or trailing spaces
    if(StringLengthW(szRawString,0) != 0)
    {
        TrimString(szRawString, TRIM_ALL);
    }

    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;

            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }
            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

            if(bAppendFlag == TRUE )
            {
                StringCopy(szAppendString,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szAppendString));
                StringConcat(szAppendString,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szAppendString) );
                StringConcat(szAppendString,szRawString, SIZE_OF_ARRAY(szAppendString));
            }
            else
            {
                StringCopy(szAppendString,szRawString, SIZE_OF_ARRAY(szAppendString));
            }

            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szAppendString, 0) > MAX_RES_STRING)
            {
               ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }
            //
            //Change the OS load options.
            //Pass NULL to friendly name as we are not changing the same
            //szAppendString is the Os load options specified by the user
            //to be appended or to be overwritten over the existing options
            //
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szAppendString);
            if(dwExitCode == ERROR_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_OSOPTIONS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }


    //Remember to free memory allocated for the linked lists
    Freelist();
    return (dwExitCode);

}

DWORD
ChangeBootEntry( IN PBOOT_ENTRY bootEntry,
                 IN LPTSTR lpNewFriendlyName,
                 IN LPTSTR lpOSLoadOptions)
/*++
  Routine Description:
                      This routine is used to change the FriendlyName and the
                      OS Options for a boot entry.

  Arguments
  [ in ]   bootEntry          -Pointer to a BootEntry structure
                               for which the changes needs to be made
  [ in ]   lpNewFriendlyName  -String specifying the new friendly name.
  [ in ]   lpOSLoadOptions    - String specifying the OS load options.

  Return Type        : DWORD -- ERROR_SUCCESS on success
                             -- ERROR_FAILURE on failure
--*/
{

    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length;
    PMY_BOOT_ENTRY myChBootEntry;
    NTSTATUS status;
    DWORD error, dwErrorCode = ERROR_SUCCESS;

    // Calculate the length of our internal structure. This includes
    // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
    //
    length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
    myBootEntry = (PMY_BOOT_ENTRY)AllocateMemory(length);
    if( NULL == myBootEntry )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    RtlZeroMemory(myBootEntry, length);

    //
    // Copy the NT BOOT_ENTRY into the allocated buffer.
    //
    bootEntryCopy = &myBootEntry->NtBootEntry;
    memcpy(bootEntryCopy, bootEntry, bootEntry->Length);


    myBootEntry->Id = bootEntry->Id;
    myBootEntry->Attributes = bootEntry->Attributes;

    //Change the friendly name if lpNewFriendlyName is not NULL
    if(lpNewFriendlyName)
    {
        myBootEntry->FriendlyName = lpNewFriendlyName;
        myBootEntry->FriendlyNameLength = ((ULONG)StringLengthW(lpNewFriendlyName, 0) + 1) * sizeof(WCHAR);
    }
    else
    {
        myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength = ((ULONG)StringLengthW(myBootEntry->FriendlyName, 0) + 1) * sizeof(WCHAR);
    }

    myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

    // If this is an NT boot entry, capture the NT-specific information in
    // the OsOptions.

    osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

    if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
        (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
    {

        MBE_SET_IS_NT( myBootEntry );
        //To change the OS Load options

        if(lpOSLoadOptions)
        {
            myBootEntry->OsLoadOptions = lpOSLoadOptions;
            myBootEntry->OsLoadOptionsLength = ((ULONG)StringLengthW(lpOSLoadOptions, 0) + 1) * sizeof(WCHAR);
        }
        else
        {
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength = ((ULONG)StringLengthW(myBootEntry->OsLoadOptions, 0) + 1) * sizeof(WCHAR);
        }
        myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);
    }
    else
    {
        // Foreign boot entry. Just capture whatever OS options exist.
        //
        myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
        myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
    }

    myChBootEntry = CreateBootEntryFromBootEntry(myBootEntry);
    if(myChBootEntry == NULL)
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        if(myBootEntry)
        {
            FreeMemory((LPVOID *)&myBootEntry);
        }
        return EXIT_FAILURE;
    }
    //Call the modify API
    status = NtModifyBootEntry(&myChBootEntry->NtBootEntry);
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        dwErrorCode = error;
        ShowMessage(stderr,GetResString(IDS_ERROR_MODIFY_BOOTENTRY) );
    }

    //free the memory
    if(myChBootEntry)
    {
        FreeMemory((LPVOID *)&myChBootEntry);
    }
    if(myBootEntry)
    {
        FreeMemory((LPVOID *)&myBootEntry);
    }
    return dwErrorCode;
}

PMY_BOOT_ENTRY
CreateBootEntryFromBootEntry (IN PMY_BOOT_ENTRY OldBootEntry)
/*++

  Routine Description :
                  This routine is used to create a new MY_BOOT_ENTRY struct.
                  The caller of this function needs to free the memory allocated
                    for the MY_BOOT_ENTRY struct.

  Arguments          :
     [ in ] bootEntry         - Pointer to a BootEntry structure
                                for which the changes needs to be made
     [ in ] lpNewFriendlyName - String specifying the new friendly name.
     [ in ] lpOSLoadOptions   - String specifying the OS load options.

  Return Type        : PMY_BOOT_ENTRY - Pointer to the new MY_BOOT_ENTRY strucure.
                       NULL on failure
--*/
{
    ULONG requiredLength;
    ULONG osOptionsOffset;
    ULONG osLoadOptionsLength;
    ULONG osLoadPathOffset;
    ULONG osLoadPathLength;
    ULONG osOptionsLength;
    ULONG friendlyNameOffset;
    ULONG friendlyNameLength;
    ULONG bootPathOffset;
    ULONG bootPathLength;
    PMY_BOOT_ENTRY newBootEntry;
    PBOOT_ENTRY ntBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    PFILE_PATH osLoadPath;
    PWSTR friendlyName;
    PFILE_PATH bootPath;

    // Calculate how long the internal boot entry needs to be. This includes
    // our internal structure, plus the BOOT_ENTRY structure that the NT APIs
    // use.
    //
    // Our structure:
    //
    requiredLength = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);

    // Base part of NT structure:
    //
    requiredLength += FIELD_OFFSET(BOOT_ENTRY, OsOptions);

    // Save offset to BOOT_ENTRY.OsOptions. Add in base part of
    // WINDOWS_OS_OPTIONS. Calculate length in bytes of OsLoadOptions
    // and add that in.
    //
    osOptionsOffset = requiredLength;

    if ( MBE_IS_NT( OldBootEntry ) )
    {

        // Add in base part of WINDOWS_OS_OPTIONS. Calculate length in
        // bytes of OsLoadOptions and add that in.
        //
        requiredLength += FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions);
        osLoadOptionsLength = OldBootEntry->OsLoadOptionsLength;
        requiredLength += osLoadOptionsLength;

        // Round up to a ULONG boundary for the OS FILE_PATH in the
        // WINDOWS_OS_OPTIONS. Save offset to OS FILE_PATH. Calculate length
        // in bytes of FILE_PATH and add that in. Calculate total length of
        // WINDOWS_OS_OPTIONS.
        //
        requiredLength = ALIGN_UP(requiredLength, ULONG);
        osLoadPathOffset = requiredLength;
        requiredLength += OldBootEntry->OsFilePath->Length;
        osLoadPathLength = requiredLength - osLoadPathOffset;
    }
    else
    {
        // Add in length of foreign OS options.
        //
        requiredLength += OldBootEntry->ForeignOsOptionsLength;
        osLoadOptionsLength = 0;
        osLoadPathOffset = 0;
        osLoadPathLength = 0;
    }

    osOptionsLength = requiredLength - osOptionsOffset;

    // Round up to a ULONG boundary for the friendly name in the BOOT_ENTRY.
    // Save offset to friendly name. Calculate length in bytes of friendly name
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    friendlyNameOffset = requiredLength;
    friendlyNameLength = OldBootEntry->FriendlyNameLength;
    requiredLength += friendlyNameLength;

    // Round up to a ULONG boundary for the boot FILE_PATH in the BOOT_ENTRY.
    // Save offset to boot FILE_PATH. Calculate length in bytes of FILE_PATH
    // and add that in.
    //
    requiredLength = ALIGN_UP(requiredLength, ULONG);
    bootPathOffset = requiredLength;
    requiredLength += OldBootEntry->BootFilePath->Length;
    bootPathLength = requiredLength - bootPathOffset;

    // Allocate memory for the boot entry.
    //
    newBootEntry = (PMY_BOOT_ENTRY)AllocateMemory(requiredLength);
    if(newBootEntry == NULL)
    {
        return NULL;
    }

    RtlZeroMemory(newBootEntry, requiredLength);

    // Calculate addresses of various substructures using the saved offsets.
    //
    ntBootEntry = &newBootEntry->NtBootEntry;
    osOptions = (PWINDOWS_OS_OPTIONS)ntBootEntry->OsOptions;
    osLoadPath = (PFILE_PATH)((PUCHAR)newBootEntry + osLoadPathOffset);
    friendlyName = (PWSTR)((PUCHAR)newBootEntry + friendlyNameOffset);
    bootPath = (PFILE_PATH)((PUCHAR)newBootEntry + bootPathOffset);

    // Fill in the internal-format structure.
    //
    //    newBootEntry->AllocationEnd = (PUCHAR)newBootEntry + requiredLength;
    newBootEntry->Status = OldBootEntry->Status & MBE_STATUS_IS_NT;
    newBootEntry->Attributes = OldBootEntry->Attributes;
    newBootEntry->Id = OldBootEntry->Id;
    newBootEntry->FriendlyName = friendlyName;
    newBootEntry->FriendlyNameLength = friendlyNameLength;
    newBootEntry->BootFilePath = bootPath;
    if ( MBE_IS_NT( OldBootEntry ) )
    {
        newBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        newBootEntry->OsLoadOptionsLength = osLoadOptionsLength;
        newBootEntry->OsFilePath = osLoadPath;
    }

    // Fill in the base part of the NT boot entry.
    //
    ntBootEntry->Version = BOOT_ENTRY_VERSION;
    ntBootEntry->Length = requiredLength - FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry);
    ntBootEntry->Attributes = OldBootEntry->Attributes;
    ntBootEntry->Id = OldBootEntry->Id;
    ntBootEntry->FriendlyNameOffset = (ULONG)((PUCHAR)friendlyName - (PUCHAR)ntBootEntry);
    ntBootEntry->BootFilePathOffset = (ULONG)((PUCHAR)bootPath - (PUCHAR)ntBootEntry);
    ntBootEntry->OsOptionsLength = osOptionsLength;

    if ( MBE_IS_NT( OldBootEntry ) )
    {
        // Fill in the base part of the WINDOWS_OS_OPTIONS, including the
        // OsLoadOptions.
        //
        StringCopyA((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE, sizeof(WINDOWS_OS_OPTIONS_SIGNATURE));
        osOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
        osOptions->Length = osOptionsLength;
        osOptions->OsLoadPathOffset = (ULONG)((PUCHAR)osLoadPath - (PUCHAR)osOptions);
        StringCopy(osOptions->OsLoadOptions, OldBootEntry->OsLoadOptions, osOptions->Length );

        // Copy the OS FILE_PATH.
        //
        memcpy( osLoadPath, OldBootEntry->OsFilePath, osLoadPathLength );
    }
    else
    {
        // Copy the foreign OS options.
        memcpy( osOptions, OldBootEntry->ForeignOsOptions, osOptionsLength );
    }

    // Copy the friendly name.
    StringCopy(friendlyName, OldBootEntry->FriendlyName, friendlyNameLength );

    // Copy the boot FILE_PATH.
    memcpy( bootPath, OldBootEntry->BootFilePath, bootPathLength );

    return newBootEntry;

} // CreateBootEntryFromBootEntry


DWORD
DeleteBootIniSettings_IA64(  IN DWORD argc,
                             IN LPCTSTR argv[]
                          )
/*++
//
//   Routine Description  : This routine deletes an existing boot entry from an EFI
//                          based machine
//
//   Arguments            :
//      [ in ]  argc       - Number of command line arguments
//      [ in ]  argv       - Array containing command line arguments
//
//  Return Type     : DWORD
//                    Returns EXIT_SUCCESS if successful,
//                    returns EXIT_FAILURE otherwise.
//
//
--*/
{

    BOOL bDelete = FALSE ;
    BOOL bUsage = FALSE;
    DWORD dwBootID = 0;

    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;
    NTSTATUS status;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;

    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[3];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    // Building the TCMDPARSER structure
    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DELETE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDelete;

    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

    // Parsing the delete option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

        
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_DELETE_USAGE));
        return ( EXIT_FAILURE );
    }

    // Displaying delete usage if user specified -? with -delete option
    if( bUsage )
    {
        displayDeleteUsage_IA64();
        return EXIT_SUCCESS;
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //
        //display an error message if there is only 1 boot entry saying
        //that it cannot be deleted.
        //
        if (listEntry->Flink == NULL)
        {
            ShowMessage(stderr,GetResString(IDS_ONLY_ONE_OS));
            dwExitCode = EXIT_FAILURE;
            break ;
        }


        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;

            //Delete the boot entry specified by the user.
            status = NtDeleteBootEntry(mybootEntry->Id);
            if(status == STATUS_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_DELETE_SUCCESS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_DELETE_FAILURE),dwBootID);
            }
            break;
        }
    }


    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }

    //Remember to free the memory allocated to the linked lists
    Freelist();
    return (dwExitCode);
}


BOOL
IsBootEntryWindows(PBOOT_ENTRY bootEntry)
/*++
//
//
//  Routine Description :
//                      Checks whether the boot entry is a Windows or a foreign one
//
//  Arguments           :
//   [ in ] bootEntry    - Boot entry structure describing the
//                         boot entry.
//
//  Return Type     : BOOL
//                    TRUE if bootEntry is an windows entry,
//                    FALSE otherwise
//
--*/
{
    PWINDOWS_OS_OPTIONS osOptions;

    osOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

    if ((bootEntry->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
        (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
    {
        return TRUE;
    }

    return FALSE;
}

PWSTR GetNtNameForFilePath(IN PFILE_PATH FilePath)
/*++

  Routine Description :
                    Converts the FilePath into a NT file path.

  Arguments           :
    [ in ]  FilePath  - The File path.

  Return Type     : PWSTR
                    The NT file path.
--*/
{
    NTSTATUS status;
    ULONG length;
    PFILE_PATH ntPath;
    PWSTR osDeviceNtName;
    PWSTR osDirectoryNtName;
    PWSTR fullNtName;

    length = 0;
    status = NtTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                NULL,
                &length
                );
    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        return NULL;
    }

    ntPath = (PFILE_PATH)AllocateMemory( length );
    if(ntPath == NULL)
    {
        return NULL;
    }
    status = NtTranslateFilePath(
                FilePath,
                FILE_PATH_TYPE_NT,
                ntPath,
                &length
                );
    if ( !NT_SUCCESS(status) )
    {
        if(ntPath)
        {
            FreeMemory((LPVOID *)&ntPath);
        }
        return NULL;
    }

    osDeviceNtName = (PWSTR)ntPath->FilePath;
    osDirectoryNtName = osDeviceNtName + StringLengthW(osDeviceNtName,0) + 1;

    length = (ULONG)(StringLengthW(osDeviceNtName,0) + StringLengthW(osDirectoryNtName, 0) + 1) * sizeof(WCHAR);

    fullNtName = (PWSTR)AllocateMemory( length );
    if(fullNtName == NULL)
    {
        if(ntPath)
        {
            FreeMemory((LPVOID *)&ntPath);
        }
        return NULL;
    }

    StringCopy( fullNtName, osDeviceNtName, GetBufferSize(fullNtName)/sizeof(WCHAR) );
    StringConcat( fullNtName, osDirectoryNtName, GetBufferSize(fullNtName)/sizeof(WCHAR) );

    if(ntPath)
    {
        FreeMemory((LPVOID *) &ntPath );
    }

    return fullNtName;
} // GetNtNameForFilePath


DWORD 
CopyBootIniSettings_IA64( IN DWORD argc, 
                          IN LPCTSTR argv[] 
                        )
/*++

  Routine Description :
                       This routine copies and existing boot entry for an EFI
                       based machine. The user can then add the various OS load
                       options.

  Arguments           : 
     [ in ]     argc     - Number of command line arguments
     [ in ]     argv     - Array containing command line arguments

  Return Type     : DWORD
                    Returns EXIT_SUCCESS if successful,
                    returns EXIT_FAILURE otherwise
--*/
{

    BOOL bCopy                          = FALSE ;
    BOOL bUsage                         = FALSE;
    DWORD dwExitCode                    = EXIT_SUCCESS;
    DWORD dwBootID                      = 0;
    BOOL bBootIdFound                   = FALSE;
    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;
    DWORD dwExitcode                    = 0 ;
    STRING256 szDescription             = NULL_STRING;
    BOOL bFlag                          = FALSE ;
    TCMDPARSER2 cmdOptions[4];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_COPY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bCopy;
    
    //description option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_DESCRIPTION;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDescription;
    pcmdOption->dwLength= FRIENDLY_NAME_LENGTH;

    // usage
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;
    
    //id  option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

        
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_COPY_USAGE));
        return ( EXIT_FAILURE );
    }

    // Displaying copy usage if user specified -? with -copy option
    if( bUsage )
    {
        displayCopyUsage_IA64();
        dwExitCode = EXIT_SUCCESS;
        return dwExitCode;
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    if(cmdOptions[1].dwActuals  != 0)
    {
        bFlag = TRUE ;
    }

    //Query the boot entries till u get the BootID specified by the user

    for (listEntry = BootEntries.Flink;listEntry != &BootEntries; listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;

            //Copy the boot entry specified by the user.
            dwExitCode = CopyBootEntry(bootEntry, szDescription,bFlag);
            if(dwExitCode == EXIT_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_COPY_SUCCESS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_COPY_ERROR),dwBootID);
                return EXIT_FAILURE ;
            }
            break;
        }

    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        return (EXIT_FAILURE) ;
    }

    //Remember to free the memory allocated for the linked lists
    Freelist();

    return EXIT_SUCCESS;
}

DWORD 
CopyBootEntry( IN PBOOT_ENTRY bootEntry, 
               IN LPTSTR lpNewFriendlyName,
               IN BOOL bFlag)
/*++
    Routine Description : 
               This routine is used to add / copy a boot entry.

   Arguments            : 
     [ in ]  bootEntry          - Pointer to a BootEntry structure for which the changes needs to be made
     [ in ]  lpNewFriendlyName  - String specifying the new friendly name.

   Return Type        : DWORD -- ERROR_SUCCESS on success
                             -- EXIT_FAILURE on failure
--*/
{

    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length, Id;
    PMY_BOOT_ENTRY myChBootEntry;
    NTSTATUS status;
    DWORD error, dwErrorCode = ERROR_SUCCESS;
    WCHAR szString[500] ;

    PULONG BootEntryOrder, NewBootEntryOrder, NewTempBootEntryOrder;

    // Calculate the length of our internal structure. This includes
    // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
    //
    length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
    myBootEntry = (PMY_BOOT_ENTRY)AllocateMemory(length);
    if(myBootEntry == NULL)
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    RtlZeroMemory(myBootEntry, length);

    //
    // Copy the NT BOOT_ENTRY into the allocated buffer.
    //
    bootEntryCopy = &myBootEntry->NtBootEntry;
    memcpy(bootEntryCopy, bootEntry, bootEntry->Length);


    myBootEntry->Id = bootEntry->Id;
    myBootEntry->Attributes = bootEntry->Attributes;


    //Change the friendly name if lpNewFriendlyName is not NULL
    //if(lpNewFriendlyName && (lstrlen(lpNewFriendlyName) != 0))

    //if(( cmdOptions[4].dwActuals  == 0) )
    if(TRUE == bFlag)
    //if(lstrlen(lpNewFriendlyName) != 0)
    {
        myBootEntry->FriendlyName = lpNewFriendlyName;
        myBootEntry->FriendlyNameLength = ((ULONG)StringLengthW(lpNewFriendlyName,0) + 1) * sizeof(WCHAR);
    }
    else
    {
        StringCopy(szString,GetResString(IDS_COPY_OF), SIZE_OF_ARRAY(szString));
        StringConcat(szString,(PWSTR)ADD_OFFSET(bootEntryCopy, FriendlyNameOffset), SIZE_OF_ARRAY(szString));

        if(StringLengthW(szString, 0) >= 67)
        {
            StringCopy(szString,szString,67);
        }

        myBootEntry->FriendlyName  = szString ;
        myBootEntry->FriendlyNameLength = ((ULONG)StringLengthW(szString,0) + 1) * sizeof(WCHAR);
    }

    myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

    // If this is an NT boot entry, capture the NT-specific information in
    // the OsOptions.

    osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

    if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
        (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
    {

        MBE_SET_IS_NT( myBootEntry );
        //To change the OS Load options

        myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
        myBootEntry->OsLoadOptionsLength = ((ULONG)StringLengthW(myBootEntry->OsLoadOptions, 0) + 1) * sizeof(WCHAR);
        myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);
    }
    else
    {
        // Foreign boot entry. Just capture whatever OS options exist.
        //

        myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
        myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
    }

    myChBootEntry = CreateBootEntryFromBootEntry(myBootEntry);
    if(myChBootEntry == NULL)
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        if(myBootEntry)
        {
            FreeMemory((LPVOID *)&myBootEntry);
        }
        ShowLastError(stderr);
        return (EXIT_FAILURE);
    }

    //Call the NtAddBootEntry API
    status = NtAddBootEntry(&myChBootEntry->NtBootEntry, &Id);
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        dwErrorCode = error;
        ShowMessage(stderr,GetResString(IDS_ERROR_UNEXPECTED) );
    }

    // Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );

    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        if ( status == STATUS_SUCCESS )
        {
            length = 0;
        }
        else
        {
            error = RtlNtStatusToDosError( status );
            ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY) );
            if(myBootEntry)
            {
                FreeMemory((LPVOID *)&myBootEntry);
            }
            if(myChBootEntry)
            {
                FreeMemory((LPVOID *)&myChBootEntry);
            }
            return FALSE;
        }
    }

    if ( length != 0 )
    {
        BootEntryOrder = (PULONG)AllocateMemory( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            if(myBootEntry)
            {
              FreeMemory((LPVOID *)&myBootEntry);
            }
            if(myChBootEntry)
            {
                FreeMemory((LPVOID *)&myChBootEntry);
            }
            return (EXIT_FAILURE);
        }

        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
        {
            error = RtlNtStatusToDosError( status );
            ShowMessage(stderr,GetResString(IDS_ERROR_QUERY_BOOTENTRY));
            dwErrorCode = error;
            FreeMemory((LPVOID *)&myBootEntry);
            FreeMemory((LPVOID *)&BootEntryOrder);
            FreeMemory((LPVOID *)&myChBootEntry);
            return dwErrorCode;
        }
    }

    //Allocate memory for the new boot entry order.
    NewBootEntryOrder = (PULONG)AllocateMemory((length+1) * sizeof(ULONG));
    if(NULL == NewBootEntryOrder )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory((LPVOID *)&myBootEntry);
        FreeMemory((LPVOID *)&BootEntryOrder);
        FreeMemory((LPVOID *)&myChBootEntry);
        return (EXIT_FAILURE);
    }

    NewTempBootEntryOrder = NewBootEntryOrder;
    memcpy(NewTempBootEntryOrder,BootEntryOrder,length*sizeof(ULONG));
    NewTempBootEntryOrder = NewTempBootEntryOrder + length;
    *NewTempBootEntryOrder =  Id;

    status = NtSetBootEntryOrder(NewBootEntryOrder, length+1);
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        dwErrorCode = error;
        ShowMessage(stderr,GetResString(IDS_ERROR_SET_BOOTENTRY));
    }

    //free the memory
    FreeMemory((LPVOID *)&NewBootEntryOrder);
    FreeMemory((LPVOID *)&myBootEntry);
    FreeMemory((LPVOID *)&BootEntryOrder);
    FreeMemory((LPVOID *)&myChBootEntry);

    return dwErrorCode;

}

DWORD 
ChangeTimeOut_IA64( IN DWORD argc, 
                    IN LPCTSTR argv[]
                  )
/*++
  Routine Description : 
                      This routine chnages the Timeout value in the system
                      global boot options.

  Arguments           :
    [ in ] argc        - Number of command line arguments
    [ in ] argv        - Array containing command line arguments

  Return Type     : DOWRD
                    Returns EXIT_SUCCESS if it successfull,
                    returns EXIT_FAILURE otherwise.
--*/
{

    DWORD dwTimeOut         = 0;
    DWORD dwExitCode        = EXIT_SUCCESS;
    ULONG Flag              = 0;
    DWORD dwExitcode        = 0;
    BOOL bTimeout           = FALSE;
    BOOL bUsage             = FALSE;

   TCMDPARSER2 cmdOptions[3];
   PTCMDPARSER2 pcmdOption;
   
    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );
    
    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_TIMEOUT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bTimeout;

   
    //default timeout value
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags =  CP2_DEFAULT | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwTimeOut;

     //usage option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    if( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_TIMEOUT_USAGE));
        return ( EXIT_FAILURE );
    }
    
    if(bUsage)
    {

      displayTimeOutUsage_IA64();
      return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //Check for the limit of Timeout value entered by the user.
    if(dwTimeOut > TIMEOUT_MAX )
    {
        ShowMessage(stderr,GetResString(IDS_TIMEOUT_RANGE));
        return (EXIT_FAILURE );
    }

    //Call the ModifyBootOptions function with the BOOT_OPTIONS_FIELD_COUNTDOWN
    Flag |= BOOT_OPTIONS_FIELD_COUNTDOWN;

    dwExitCode = ModifyBootOptions(dwTimeOut, NULL, 0, Flag);

    return dwExitCode;
}

DWORD 
ModifyBootOptions( IN ULONG Timeout, 
                   IN LPTSTR pHeadlessRedirection, 
                   IN ULONG NextBootEntryID, 
                   IN ULONG Flag
                  )
/*++
  Routine Description : 
                   This routine Modifies the Boot options
                   -Timeout
                   -NextBootEntryID
                   -HeadlessRedirection

  Arguments        : 
   [ in ] Timeout                   - The new Timeout value
   [ in ] pHeadlessRedirection      - The Headless redirection string
   [ in ] NextBootEntryID           - The NextBootEntryID
   [ in ] Flag                      - The Flags indicating what fields that needs to be changed
                                      BOOT_OPTIONS_FIELD_COUNTDOWN
                                      BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID
                                      BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION
  Return Type     : DOWRD
                    Returns EXIT_SUCCESS if successful,
                    returns EXIT_FAILURE otherwise.
--*/
{
    PBOOT_OPTIONS pBootOptions;
    PBOOT_OPTIONS pModifiedBootOptions;
    DWORD error;
    NTSTATUS status;
    ULONG newlength=0;
    DWORD dwExitCode = EXIT_SUCCESS;

    NextBootEntryID = 0;
    
    //Query the existing Boot options and modify based on the Flag value

    status =  BootCfg_QueryBootOptions(&pBootOptions);
    if(status != STATUS_SUCCESS)
    {
        error = RtlNtStatusToDosError( status );
        FreeMemory((LPVOID *)&pBootOptions);
        return (error);
    }

    //Calculate the new length of the BOOT_OPTIONS struct based on the fields that needs to be changed.
    newlength = FIELD_OFFSET(BOOT_OPTIONS, HeadlessRedirection);

    if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
    {
        newlength = FIELD_OFFSET(BOOT_OPTIONS, HeadlessRedirection);
        newlength += StringLengthW(pHeadlessRedirection,0);
        newlength = ALIGN_UP(newlength, ULONG);
    }
    else
    {
        newlength = pBootOptions->Length;
    }

    //Also allocate the memory for a new Boot option struct
    pModifiedBootOptions = (PBOOT_OPTIONS)AllocateMemory(newlength);
    if(pModifiedBootOptions == NULL)
    {
        FreeMemory((LPVOID *)&pBootOptions);
        return (EXIT_FAILURE);
    }

    //Fill in the new boot options struct
    pModifiedBootOptions->Version = BOOT_OPTIONS_VERSION;
    pModifiedBootOptions->Length = newlength;

    if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
    {
        pModifiedBootOptions->Timeout = Timeout;
    }
    else
    {
        pModifiedBootOptions->Timeout = pBootOptions->Timeout;
    }

    //Cannot change the CurrentBootEntryId.So just pass what u got.
    pModifiedBootOptions->CurrentBootEntryId = pBootOptions->CurrentBootEntryId;

    if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
    {
        pModifiedBootOptions->NextBootEntryId = pBootOptions->NextBootEntryId;
    }
    else
    {
        pModifiedBootOptions->NextBootEntryId = pBootOptions->NextBootEntryId;
    }

    if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
    {
        StringCopy(pModifiedBootOptions->HeadlessRedirection, pBootOptions->HeadlessRedirection, StringLengthW(pBootOptions->HeadlessRedirection,0));
    }
    else
    {
        StringCopy(pModifiedBootOptions->HeadlessRedirection, pBootOptions->HeadlessRedirection, StringLengthW(pBootOptions->HeadlessRedirection,0));
    }

    //Set the boot options in the NVRAM
    status = NtSetBootOptions(pModifiedBootOptions, Flag);

    if(status != STATUS_SUCCESS)
    {
        dwExitCode = EXIT_SUCCESS;
        if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_TIMEOUT));
        }
        if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_NEXTBOOTID));
        }
        if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_MODIFY_HEADLESS));
        }
    }
    else
    {
        dwExitCode = EXIT_SUCCESS;
        if((Flag & BOOT_OPTIONS_FIELD_COUNTDOWN))
        {
            ShowMessage(stdout,GetResString(IDS_SUCCESS_MODIFY_TIMEOUT));
        }
        if((Flag & BOOT_OPTIONS_FIELD_NEXT_BOOT_ENTRY_ID))
        {
            ShowMessage(stdout,GetResString(IDS_SUCCESS_MODIFY_NEXTBOOTID));
        }
        if((Flag & BOOT_OPTIONS_FIELD_HEADLESS_REDIRECTION))
        {
            ShowMessage(stdout,GetResString(IDS_SUCCESS_MODIFY_HEADLESS));
        }
    }

    //free the memory
    FreeMemory((LPVOID *) &pModifiedBootOptions);
     FreeMemory((LPVOID *) &pBootOptions);
    return dwExitCode;
}

DWORD 
ConvertBootEntries(PBOOT_ENTRY_LIST NtBootEntries)
/*++
  Routine Description : 
                    Convert boot entries read from EFI NVRAM into our internal format.

  Arguments           : 
     [ in ] NtBootEntries - The boot entry list given by the enumeration

  Return Type     : DWORD
--*/
{
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PBOOT_ENTRY bootEntryCopy;
    PMY_BOOT_ENTRY myBootEntry;
    PWINDOWS_OS_OPTIONS osOptions;
    ULONG length = 0;
    DWORD dwErrorCode = EXIT_SUCCESS;
    BOOL  bNoBreak = TRUE;

    bootEntryList = NtBootEntries;

    do
    {
        bootEntry = &bootEntryList->BootEntry;

        //
        // Calculate the length of our internal structure. This includes
        // the base part of MY_BOOT_ENTRY plus the NT BOOT_ENTRY.
        //
        length = FIELD_OFFSET(MY_BOOT_ENTRY, NtBootEntry) + bootEntry->Length;
        //Remember to check for the NULL pointer
        myBootEntry = (PMY_BOOT_ENTRY)AllocateMemory(length);
        if(myBootEntry == NULL)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }

        RtlZeroMemory(myBootEntry, length);

        //
        // Link the new entry into the list.
        //
        if ( (bootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_ACTIVE) )
        {
            InsertTailList( &ActiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &ActiveUnorderedBootEntries;
        }
        else
        {
            InsertTailList( &InactiveUnorderedBootEntries, &myBootEntry->ListEntry );
            myBootEntry->ListHead = &InactiveUnorderedBootEntries;
        }

        //
        // Copy the NT BOOT_ENTRY into the allocated buffer.
        //
        bootEntryCopy = &myBootEntry->NtBootEntry;
        memcpy(bootEntryCopy, bootEntry, bootEntry->Length);

        //
        // Fill in the base part of the structure.
        //
        myBootEntry->AllocationEnd = (PUCHAR)myBootEntry + length - 1;
        myBootEntry->Id = bootEntry->Id;
        //Assign 0 to the Ordered field currently so that
        //once the boot order is known, we can assign 1 if this entry is a part of the ordered list.
        myBootEntry->Ordered = 0;
        myBootEntry->Attributes = bootEntry->Attributes;
        myBootEntry->FriendlyName = (PWSTR)ADD_OFFSET(bootEntryCopy, FriendlyNameOffset);
        myBootEntry->FriendlyNameLength =((ULONG)StringLengthW(myBootEntry->FriendlyName,0) + 1) * sizeof(WCHAR);
        myBootEntry->BootFilePath = (PFILE_PATH)ADD_OFFSET(bootEntryCopy, BootFilePathOffset);

        //
        // If this is an NT boot entry, capture the NT-specific information in
        // the OsOptions.
        //
        osOptions = (PWINDOWS_OS_OPTIONS)bootEntryCopy->OsOptions;

        if ((bootEntryCopy->OsOptionsLength >= FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)) &&
            (strcmp((char *)osOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE) == 0))
        {
            MBE_SET_IS_NT( myBootEntry );
            myBootEntry->OsLoadOptions = osOptions->OsLoadOptions;
            myBootEntry->OsLoadOptionsLength =((ULONG)StringLengthW(myBootEntry->OsLoadOptions,0) + 1) * sizeof(WCHAR);
            myBootEntry->OsFilePath = (PFILE_PATH)ADD_OFFSET(osOptions, OsLoadPathOffset);
        }
        else
        {
            //
            // Foreign boot entry. Just capture whatever OS options exist.
            //
            myBootEntry->ForeignOsOptions = bootEntryCopy->OsOptions;
            myBootEntry->ForeignOsOptionsLength = bootEntryCopy->OsOptionsLength;
        }

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0)
        {
            bNoBreak = FALSE;
            break;
        }

        bootEntryList = (PBOOT_ENTRY_LIST)ADD_OFFSET(bootEntryList, NextEntryOffset);
    } while ( TRUE == bNoBreak );

    return dwErrorCode;

} // ConvertBootEntries


DWORD DisplayBootOptions()
/*++
  Name            : DisplayBootOptions

  Synopsis        : Display the boot options

  Parameters      : NONE

  Return Type     : DWORD

  Global Variables: Global Linked lists for storing the boot entries
                      LIST_ENTRY BootEntries;
--*/
{
    DWORD error;
    NTSTATUS status;
    PBOOT_OPTIONS pBootOptions;
    TCHAR szDisplay[MAX_RES_STRING+1] = NULL_STRING;

    //Query the boot options
    status =  BootCfg_QueryBootOptions(&pBootOptions);
    if(status != STATUS_SUCCESS)
    {
        error = RtlNtStatusToDosError( status );
        if(pBootOptions)
        {
            FreeMemory((LPVOID *)&pBootOptions);
        }
        return EXIT_FAILURE;
    }

    //Printout the boot options
    ShowMessage(stdout,_T("\n"));
    ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64A));
    ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64B));

    ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_OUTPUT_IA64C), pBootOptions->Timeout);

    //display default boot entry id
    ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64P), GetDefaultBootEntry());

    //Get the CurrentBootEntryId from the actual Id present in the boot options
    SecureZeroMemory( szDisplay, SIZE_OF_ARRAY(szDisplay) );
    ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64D), GetCurrentBootEntryID(pBootOptions->CurrentBootEntryId));

    ShowMessage(stdout,L"\n");


#if 0
    if(StringLengthW(pBootOptions->HeadlessRedirection) == 0)
    {
        ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64E));
    }
    else
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64F), pBootOptions->HeadlessRedirection);
    }
#endif //Commenting out the display of the Headless redirection
       //as we cannot query the same through API (its Firmware controlled)

    if(pBootOptions)
    {
            FreeMemory((LPVOID *)&pBootOptions);
    }

    return EXIT_SUCCESS;
}

VOID DisplayBootEntry()
/*++

  Routine Description : Display the boot entries (in an order)

  Parameters      : NONE

  Return Type     : DWORD

--*/
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;
    PWSTR NtFilePath;

    //Printout the boot entires
    ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64G));
    ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64H));

    for (listEntry = BootEntries.Flink;listEntry != &BootEntries; listEntry = listEntry->Flink)
    {
        //Get the boot entry
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64I), bootEntry->myId);

        //friendly name
        if(StringLengthW(bootEntry->FriendlyName,0)!=0)
        {
            ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64J), bootEntry->FriendlyName);
        }
        else
        {
             ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64K));
        }

        if(MBE_IS_NT(bootEntry))
        {
            //the OS load options
            if(StringLengthW(bootEntry->OsLoadOptions, 0)!=0)
            {
               ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64L), bootEntry->OsLoadOptions);
            }
            else
            {
                ShowMessage(stdout,GetResString(IDS_OUTPUT_IA64M));
            }
            
            //Get the BootFilePath
            NtFilePath = GetNtNameForFilePath(bootEntry->BootFilePath);
            ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64N), NtFilePath);

            //free the memory
            if(NtFilePath)
            {
               FreeMemory((LPVOID *)&NtFilePath);
            }

            //Get the OS load path
            NtFilePath = GetNtNameForFilePath(bootEntry->OsFilePath);
            ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_OUTPUT_IA64O), NtFilePath);

            //free the memory
            if(NtFilePath)
            {
              FreeMemory((LPVOID *)&NtFilePath);
            }
        }
        else
        {
            ShowMessage(stdout,_T("\n"));
        }
    }
}


DWORD GetCurrentBootEntryID(DWORD Id)
/*++
  Routine Description : 
                   Gets the Boot entry ID generated by us from the BootId given by the NVRAM

  Arguments           : 
    [ in ]         Id - The current boot id (BootId given by the NVRAM)

  Return Type     : DWORD
                    Returns EXIT_SUCCESS if successful,
                    returns EXIT_FAILURE otherwise
--*/
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;

    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        if(bootEntry->Id == Id)
        {
            return bootEntry->myId;
        }
    }
    return 0;
}

DWORD 
ChangeDefaultBootEntry_IA64( IN DWORD argc,
                             IN LPCTSTR argv[]
                           )
/*++

  Routine Description : 
                   This routine is to change the Default boot entry in the NVRAM

  Arguments           : 
     [ in ] argc       - Number of command line arguments
     [ in ] argv       - Array containing command line arguments

  Return Type        : DWORD
--*/
{

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    NTSTATUS status;
    PULONG BootEntryOrder, NewBootEntryOrder;
    DWORD       dwBootID                = 0;
    BOOL        bDefaultOs              = FALSE ;
    DWORD       dwExitCode              = ERROR_SUCCESS;
    BOOL        bBootIdFound            = FALSE;
    BOOL        bIdFoundInBootOrderList = FALSE;
    ULONG       length, i, j, defaultId = 0;
    DWORD       error                   = 0;
    DWORD       dwExitcode              = 0;
    BOOL        bUsage                  = FALSE;

    TCMDPARSER2 cmdOptions[3];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULTOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDefaultOs;

    //id option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

    //usage option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    if( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE );
    }

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_DEFAULTOS_USAGE));
        return ( EXIT_FAILURE );
    }

    if(bUsage)
    {
        displayDefaultEntryUsage_IA64();
        return EXIT_SUCCESS;
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }
    //Check whether the boot entry entered bu the user is a valid boot entry id or not.

    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            //store the default ID
            defaultId = mybootEntry->Id;
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        return (EXIT_FAILURE);
    }

    // Get the system boot order list.
    length = 0;
    status = NtQueryBootEntryOrder( NULL, &length );

    if ( status != STATUS_BUFFER_TOO_SMALL )
    {
        if ( status == STATUS_SUCCESS )
        {
            length = 0;
        }
        else
        {
            error = RtlNtStatusToDosError( status );
            ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
            return (EXIT_FAILURE);
        }
    }

    if ( length != 0 )
    {
        BootEntryOrder = (PULONG)AllocateMemory( length * sizeof(ULONG) );
        if(BootEntryOrder == NULL)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }

        status = NtQueryBootEntryOrder( BootEntryOrder, &length );
        if ( status != STATUS_SUCCESS )
        {
            error = RtlNtStatusToDosError( status );
            ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
            FreeMemory((LPVOID *)&BootEntryOrder);
            return EXIT_FAILURE;
        }
    }

    //Check if the boot id entered by the user is a part of the Boot entry order.
    //If not for the time being do not make it the default.
    for(i=0;i<length;i++)
    {
        if(*(BootEntryOrder+i) == defaultId)
        {
            bIdFoundInBootOrderList = TRUE;
            break;
        }
    }

    if(bIdFoundInBootOrderList == FALSE)
    {
        FreeMemory((LPVOID *)&BootEntryOrder);
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
        return (EXIT_FAILURE);
    }

    //Allocate memory for storing the new boot entry order.
    NewBootEntryOrder = (PULONG)AllocateMemory((length) * sizeof(ULONG));
    if(NewBootEntryOrder == NULL)
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory((LPVOID *)&BootEntryOrder);
        return (EXIT_FAILURE);
    }

    *NewBootEntryOrder =  defaultId;
    j=0;
    for(i=0;i<length;i++)
    {
        if(*(BootEntryOrder+i) == defaultId)
        {
            continue;
        }
        *(NewBootEntryOrder+(j+1)) = *(BootEntryOrder+i);
        j++;
    }


    status = NtSetBootEntryOrder(NewBootEntryOrder, length);
    if ( status != STATUS_SUCCESS )
    {
        error = RtlNtStatusToDosError( status );
        dwExitCode = error;
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_DEFAULT_ENTRY),dwBootID);
    }
    else
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_DEFAULT_ENTRY),dwBootID);
    }

    //free the memory
    FreeMemory((LPVOID *)&NewBootEntryOrder);
    FreeMemory((LPVOID *)&BootEntryOrder);
    return dwExitCode;
}

DWORD 
ProcessDebugSwitch_IA64( IN DWORD argc, 
                         IN LPCTSTR argv[] 
                       )
/*++

  Routine Description : 
                   Allows the user to add the OS load options specifed
                   as a debug string at the cmdline to the boot

  Arguments          :
    [ in ] argc           - Number of command line arguments
    [ in ] argv           - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if successful,
                       returns EXIT_FAILURE otherwise.

--*/
{

    BOOL    bUsage                                  = FALSE ;
    DWORD   dwBootID                                = 0;
    BOOL    bBootIdFound                            = FALSE;
    DWORD   dwExitCode                              = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;

    TCHAR   szPort[MAX_RES_STRING+1]                  = NULL_STRING ;
    TCHAR   szBaudRate[MAX_RES_STRING+1]              = NULL_STRING ;
    TCHAR   szDebug[MAX_RES_STRING+1]                 = NULL_STRING ;
    BOOL    bDebug                                  = FALSE ;
    PWINDOWS_OS_OPTIONS pWindowsOptions             = NULL ;
    TCHAR   szOsLoadOptions[MAX_RES_STRING+1]         = NULL_STRING ;
    TCHAR   szTemp[MAX_RES_STRING+1]                  = NULL_STRING ;
    TCHAR   szTmpBuffer[MAX_RES_STRING+1]             = NULL_STRING ;
    DWORD   dwExitcode                              = 0 ;
    

    TCMDPARSER2 cmdOptions[6];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEBUG;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDebug;
    
   //usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;
    
    //id option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

    //port option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PORT;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPort;
    pcmdOption->pwszValues = COM_PORT_RANGE;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //baud option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BAUD;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szBaudRate;
    pcmdOption->pwszValues = BAUD_RATE_VALUES_DEBUG;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //default on/off option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDebug;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayDebugUsage_IA64();
        return (ERROR_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //Trim any leading or trailing spaces
    if(StringLengthW(szDebug, 0)!=0)
    {
        TrimString(szDebug, TRIM_ALL);
    }

    if( !( ( StringCompare(szDebug,VALUE_ON,TRUE,0)== 0) || (StringCompare(szDebug,VALUE_OFF,TRUE,0)== 0 ) ||(StringCompare(szDebug,EDIT_STRING,TRUE,0)== 0) ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
        return EXIT_FAILURE;
    }
    
    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries; listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;
            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }

            //Change the OS load options. Pass NULL to friendly name as we are not changing the same
            //szRawString is the Os load options specified by the user

            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

            if(StringLengthW(pWindowsOptions->OsLoadOptions, 0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            // copy the existing OS Loadoptions into a string.
            StringCopy(szOsLoadOptions,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szOsLoadOptions));

            //check if the user has entered On option
            if( StringCompare(szDebug,VALUE_ON,TRUE,0)== 0)
            {
                //display an error message
                if ( (FindString(szOsLoadOptions,DEBUG_SWITCH, 0) != 0 )&& (StringLengthW(szPort, 0)==0) &&(StringLengthW(szBaudRate, 0)==0) )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_DEBUG));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                //display a error message and exit if the 1394 port is already present.
                if(FindString(szOsLoadOptions,DEBUGPORT_1394, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_1394_ALREADY_PRESENT));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                //
                //display an duplicate entry error message if substring is already present.
                //
                if(StringLengthW(szBaudRate, 0)==0)
                {
                    if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_SUCCESS )
                    {
                        ShowMessage(stderr,GetResString(IDS_DUPLICATE_ENTRY));
                        return EXIT_FAILURE ;
                    }
                }


                if(StringLengthW(szTemp, 0)!=0)
                {
                    ShowMessage(stderr,GetResString(IDS_DUPLICATE_ENTRY));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }


                //check if the Os load options already contains
                // debug switch
                if(FindString(szOsLoadOptions,DEBUG_SWITCH, 0) == 0 )
                {
                    if(StringLengthW(szOsLoadOptions, 0)!=0)
                    {
                        StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szOsLoadOptions) );
                    }
                    else
                    {
                        StringCopy(szTmpBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szOsLoadOptions) );
                    }
                }


                if(StringLengthW(szPort, 0)!= 0)
                {
                    if(StringLengthW(szTmpBuffer, 0)==0)
                    {
                        StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    StringConcat(szTmpBuffer,TOKEN_DEBUGPORT, SIZE_OF_ARRAY(szTmpBuffer)) ;
                    StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer)) ;
                    CharUpper(szPort);
                    StringConcat(szTmpBuffer,szPort, SIZE_OF_ARRAY(szTmpBuffer));
                }

                //Check if the OS Load Options contains the baud rate already specified.
                if(StringLengthW(szBaudRate, 0)!=0)
                {
                    StringCopy(szTemp,NULL_STRING, SIZE_OF_ARRAY(szTemp) );
                    GetBaudRateVal(szOsLoadOptions,szTemp)  ;
                    if(StringLengthW(szTemp, 0)!=0)
                    {
                        ShowMessage(stderr,GetResString(IDS_DUPLICATE_BAUD_RATE));
                        dwExitCode = EXIT_FAILURE;
                        break;
                    }
                    else
                    {
                        if(StringLengthW(szTmpBuffer, 0)==0)
                        {
                            StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        }
                        else
                        {
                            StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        }
                        StringConcat(szTmpBuffer,BAUD_RATE, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,szBaudRate, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                }
 
            }

            //check if the user has entered OFF  option
            if( StringCompare(szDebug,VALUE_OFF,TRUE,0)== 0)
            {

                // If the user enters either com port or  baud rate then display error message and exit.
                if ((StringLengthW(szPort, 0)!=0) ||(StringLengthW(szBaudRate, 0)!=0))
                {
                    ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                // if debug port is absent print message and exit.
                if (FindString(szOsLoadOptions,DEBUG_SWITCH, 0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DEBUG_ABSENT));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                //remove the debug switch from the OSLoad Options
                removeSubString(szOsLoadOptions,DEBUG_SWITCH);

                if(FindString(szOsLoadOptions,DEBUGPORT_1394, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_ERROR_1394_REMOVE));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                
                GetSubString(szOsLoadOptions, TOKEN_DEBUGPORT,szTemp);

                if(StringLengthW(szTemp, 0)!=0)
                {
                    // remove the /debugport=comport switch if it is present from the Boot Entry
                    removeSubString(szOsLoadOptions,szTemp);
                }

                StringCopy(szTemp , NULL_STRING, SIZE_OF_ARRAY(szTemp) );
                //remove the baud rate switch if it is present.
                GetBaudRateVal(szOsLoadOptions,szTemp)  ;

                // if the OSLoadOptions contains baudrate then delete it.
                if (StringLengthW(szTemp, 0 )!= 0)
                {
                    removeSubString(szOsLoadOptions,szTemp);
                }

            }

            //if the user selected the edit option .
            if( StringCompare(szDebug,EDIT_STRING,TRUE,0)== 0)
            {
                //check if the debug switch is present in the Osload options else display error message.
                if (FindString(szOsLoadOptions,DEBUG_SWITCH, 0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DEBUG_ABSENT));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                if( FindString(szOsLoadOptions,DEBUGPORT_1394, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_ERROR_EDIT_1394_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                //check if the user enters COM port or baud rate else display error message.
                if((StringLengthW(szPort, 0)==0)&&(StringLengthW(szBaudRate, 0)==0))
                {
                    ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                if( StringLengthW(szPort, 0)!=0 )
                {
                    if ( GetSubString(szOsLoadOptions,TOKEN_DEBUGPORT,szTemp) == EXIT_FAILURE)
                    {
                        ShowMessage(stderr,GetResString(IDS_NO_DEBUGPORT));
                        return EXIT_FAILURE ;
                    }
                    if(StringLengthW(szTemp, 0)!=0)
                    {
                        //remove the existing entry from the OsLoadOptions String.
                        removeSubString(szOsLoadOptions,szTemp);
                    }

                    //Add the port entry specified by user into the OsLoadOptions String.
                    if(StringLengthW(szTmpBuffer, 0)==0)
                    {
                        StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    StringConcat(szTmpBuffer,TOKEN_DEBUGPORT, SIZE_OF_ARRAY(szTmpBuffer)) ;
                    StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer)) ;
                    CharUpper(szPort);
                    StringConcat(szTmpBuffer,szPort, SIZE_OF_ARRAY(szTmpBuffer));
                }

                //Check if the OS Load Options contains the baud rate already specified.
                if(StringLengthW(szBaudRate, 0)!=0)
                {
                    StringCopy(szTemp,NULL_STRING, SIZE_OF_ARRAY(szTemp));
                    GetBaudRateVal(szOsLoadOptions,szTemp)  ;
                    if(StringLengthW(szTemp, 0)!=0)
                    {
                        removeSubString(szOsLoadOptions,szTemp);
                    }

                    //add the baud rate value to boot entry
                    if(StringLengthW(szTmpBuffer, 0) == 0)
                    {
                        StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    StringConcat(szTmpBuffer,BAUD_RATE, SIZE_OF_ARRAY(szTmpBuffer));
                    StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
                    StringConcat(szTmpBuffer,szBaudRate, SIZE_OF_ARRAY(szTmpBuffer));
                }
            }

            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szOsLoadOptions, 0) + StringLengthW(szTmpBuffer,0)> MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }
            else
            {
               StringConcat(szOsLoadOptions,szTmpBuffer, SIZE_OF_ARRAY(szOsLoadOptions));
            }


            // modify the Boot Entry with the modified OsLoad Options.
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
            if(dwExitCode == ERROR_SUCCESS)
            {
                ShowMessageEx(stdout,1,TRUE,  GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr,1,TRUE, GetResString(IDS_ERROR_CHANGE_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(FALSE == bBootIdFound )
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }


    //Remember to free memory allocated for the linked lists
    Freelist();
    return (dwExitCode);
}

VOID  
GetComPortType_IA64( IN LPTSTR  szString,
                     IN LPTSTR szTemp 
                    )
/*++

  Routine Description:  
             Get the Type of  Com Port present in Boot Entry

  Arguments          :
    [ in ]  szString    : The String  which is to be searched.
    [ in ]  szTemp      : String which will get the com port type

  Return Type        : VOID
--*/
{

    if(FindString(szString,PORT_COM1A, 0)!=0)
    {
        StringCopy(szTemp,PORT_COM1A, MAX_RES_STRING);
    }
    else if(FindString(szString,PORT_COM2A,0)!=0)
    {
        StringCopy(szTemp,PORT_COM2A, MAX_RES_STRING);
    }
    else if(FindString(szString,PORT_COM3A,0)!=0)
    {
        StringCopy(szTemp,PORT_COM3A, MAX_RES_STRING);
    }
    else if(FindString(szString,PORT_COM4A,0)!=0)
    {
        StringCopy(szTemp,PORT_COM4A, MAX_RES_STRING);
    }
    else if(FindString(szString,PORT_1394A,0)!=0)
    {
        StringCopy(szTemp,PORT_1394A, MAX_RES_STRING);
    }
}

DWORD
ProcessEmsSwitch_IA64( IN DWORD argc, 
                       IN LPCTSTR argv[] 
                      )
/*++

  Routine Description : 
                  Which process the ems switch.

  Arguments           :
     [ in ] argc           - Number of command line arguments
     [ in ] argv           - Array containing command line arguments

  Return Type        : DWORD
--*/
{
    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;
    PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;

    BOOL        bUsage                              = FALSE ;
    DWORD       dwBootID                            = 0;
    BOOL        bBootIdFound                        = FALSE;
    DWORD       dwExitCode                          = ERROR_SUCCESS;

    TCHAR       szEms[MAX_STRING_LENGTH+1]               = NULL_STRING ;
    BOOL        bEms                                = FALSE ;
    TCHAR       szOsLoadOptions[MAX_RES_STRING+1]     = NULL_STRING ;
    TCHAR       szTmpBuffer[MAX_RES_STRING+1]     = NULL_STRING ;
    DWORD       dwExitcode                          = 0 ;

    TCMDPARSER2 cmdOptions[4];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_EMS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bEms;
    
    
    //usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //id option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

     //default on/off option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szEms;
    pcmdOption->dwLength= MAX_STRING_LENGTH;


     // Parsing the ems option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

        //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayEmsUsage_IA64();
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //display error message if the user enters any other string other that on/off.
    if( !((StringCompare(szEms,VALUE_ON,TRUE,0)== 0) || (StringCompare(szEms,VALUE_OFF,TRUE,0)== 0)))
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
        return EXIT_FAILURE ;
    }

    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;


            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }

            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

            if(StringLengthW(pWindowsOptions->OsLoadOptions, 0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            // copy the existing OS Loadoptions into a string.
            StringCopy(szOsLoadOptions,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szOsLoadOptions));

            //check if the user has entered On option
            if( StringCompare(szEms,VALUE_ON,TRUE,0)== 0)
            {
                if (FindString(szOsLoadOptions,REDIRECT_SWITCH, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_REDIRECT));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                // add the redirect switch to the OS Load Options string.
                if( StringLength(szOsLoadOptions,0) != 0 )
                {
                     StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                     StringConcat(szTmpBuffer,REDIRECT_SWITCH, SIZE_OF_ARRAY(szTmpBuffer) );
                }
                else
                {
                    StringCopy(szTmpBuffer,REDIRECT_SWITCH, SIZE_OF_ARRAY(szTmpBuffer) );
                }
            }

            //check if the user has entered OFF  option
            if( StringCompare(szEms,VALUE_OFF,TRUE,0)== 0)
            {
                // If the user enters either com port or  baud rate then display error message and exit.
                if (FindString(szOsLoadOptions,REDIRECT_SWITCH, 0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_REDIRECT_ABSENT));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                //remove the debug switch from the OSLoad Options
                removeSubString(szOsLoadOptions,REDIRECT_SWITCH);
            }


            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szOsLoadOptions, 0)+StringLength(szTmpBuffer,0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }
            else
            {
                StringConcat( szOsLoadOptions, szTmpBuffer, SIZE_OF_ARRAY(szOsLoadOptions) );
            }

            // modify the Boot Entry with the modified OsLoad Options.
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
            if(dwExitCode == ERROR_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
            }
            else
            {
               ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_CHANGE_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }

    //free the global linked lists
    Freelist();
    return (dwExitCode);
}


DWORD
ProcessAddSwSwitch_IA64( IN DWORD argc, 
                         IN LPCTSTR argv[] 
                        )
/*++

  Routine Description : 
                 Which implements the Addsw switch.

  Arguments           :
    [ in ] argc             - Number of command line arguments
    [ in ] argv             - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if it is successful,
                       return EXIT_FAILURE otherwise.
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bAddSw = FALSE ;
    DWORD dwBootID = 0;
    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;

    BOOL bBaseVideo = FALSE ;
    BOOL bNoGui = FALSE ;
    BOOL bSos = FALSE ;
    DWORD dwMaxmem = 0 ;

    PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
    TCHAR szOsLoadOptions[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szTmpBuffer[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szMaxmem[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwExitcode = 0 ;

    TCMDPARSER2 cmdOptions[7];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_ADDSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bAddSw;
    
     // usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //id option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

   //maxmem  option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_MAXMEM;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwMaxmem;

   //basvideo option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BASEVIDEO;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bBaseVideo;

   //nogui option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_NOGUIBOOT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bNoGui;

   //nogui option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bSos;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayAddSwUsage_IA64();
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    if((0==dwMaxmem)&&(cmdOptions[3].dwActuals!=0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
        return EXIT_FAILURE ;
    }

    //display an error mesage if none of the options are specified.
    if((!bSos)&&(!bBaseVideo)&&(!bNoGui)&&(dwMaxmem==0))
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
        return EXIT_FAILURE ;
    }


    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries; listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;


            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }

            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;
            if(StringLengthW(pWindowsOptions->OsLoadOptions,0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            // copy the existing OS Loadoptions into a string.
            StringCopy(szOsLoadOptions,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szOsLoadOptions));

            //check if the user has entered -basevideo option
            if(bBaseVideo)
            {
                if (FindString(szOsLoadOptions,BASEVIDEO_VALUE, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_BASEVIDEO_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                   StringCopy(szTmpBuffer,BASEVIDEO_VALUE, SIZE_OF_ARRAY(szTmpBuffer) );
                   
                }
            }

            if(bSos)
            {
                if (FindString(szOsLoadOptions,SOS_VALUE, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_SOS_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {

                    // add the sos switch to the OS Load Options string.
                    if(StringLengthW(szTmpBuffer, 0) != 0)
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,SOS_VALUE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringCopy(szTmpBuffer,SOS_VALUE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    
                }
            }

            if(bNoGui)
            {
                if (FindString(szOsLoadOptions,NOGUI_VALUE, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_NOGUI_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // add the no gui switch to the OS Load Options string.
                    if(StringLengthW(szTmpBuffer, 0) != 0)
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,NOGUI_VALUE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringCopy(szTmpBuffer,NOGUI_VALUE, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    
                }

            }

            if(dwMaxmem!=0)
            {
                // check if the maxmem value is in the valid range.
                if( (dwMaxmem < 32) )
                {
                    ShowMessage(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
                    dwExitCode = EXIT_FAILURE;
                    break;

                }

                if (FindString(szOsLoadOptions,MAXMEM_VALUE1, 0) != 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_DUPL_MAXMEM_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // add the maxmem switch to the OS Load Options string.
                    if(StringLengthW(szTmpBuffer, 0) != 0)
                    {
                        StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,MAXMEM_VALUE1, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
                        _ltow(dwMaxmem,szMaxmem,10);
                        StringConcat(szTmpBuffer,szMaxmem, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                    else
                    {
                        StringCopy(szTmpBuffer,MAXMEM_VALUE1, SIZE_OF_ARRAY(szTmpBuffer));
                        StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
                        _ltow(dwMaxmem,szMaxmem,10);
                        StringConcat(szTmpBuffer,szMaxmem, SIZE_OF_ARRAY(szTmpBuffer));
                    }
                }
            }


            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szOsLoadOptions, 0)+StringLength(szTmpBuffer,0) + StringLength(TOKEN_EMPTYSPACE,0)> MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }
            else
            {
                if( StringLength(szOsLoadOptions,0) != 0 )
                {
                    StringConcat(szOsLoadOptions,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szOsLoadOptions));
                    StringConcat(szOsLoadOptions,szTmpBuffer,SIZE_OF_ARRAY(szOsLoadOptions));
                }
                else
                {
                    StringCopy(szOsLoadOptions,szTmpBuffer,SIZE_OF_ARRAY(szOsLoadOptions));
                }
            }

            //Change the OS load options. Pass NULL to friendly name as we are not changing the same
            //szRawString is the Os load options specified by the user
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
            if(dwExitCode == ERROR_SUCCESS)
            {
               ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_OSOPTIONS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }

    //Remember to free memory allocated for the linked lists
    Freelist();
   return (dwExitCode);
}

DWORD 
ProcessRmSwSwitch_IA64( IN DWORD argc, 
                        IN LPCTSTR argv[] 
                      )
/*++

  Routine Description : 
                   Process the rmsw switch

  Arguments           : 
     [ in ] argc           - Number of command line arguments
     [ in ] argv           - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if it is successful,
                       returns EXIT_FAILURE otherwise.
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bRmSw = FALSE ;
    DWORD dwBootID = 0;
    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;

    BOOL bBaseVideo = FALSE ;
    BOOL bNoGui = FALSE ;
    BOOL bSos = FALSE ;

    BOOL bMaxmem = FALSE ;

    PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
    TCHAR szOsLoadOptions[MAX_RES_STRING+1] = NULL_STRING ;

    TCHAR szTemp[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[7];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RMSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bRmSw;
    
     // usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //id option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

   //maxmem  option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_MAXMEM;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bMaxmem;

   //basvideo option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BASEVIDEO;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bBaseVideo;

   //nogui option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_NOGUIBOOT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bNoGui;

   //sos option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bSos;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_RMSW));
        return ( EXIT_FAILURE );
    }


    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayRmSwUsage_IA64();
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //display an error mesage if none of the options are specified.
    if((!bSos)&&(!bBaseVideo)&&(!bNoGui)&&(!bMaxmem))
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_RMSW));
        return EXIT_FAILURE;
    }


    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;
            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }

            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

            if(StringLengthW(pWindowsOptions->OsLoadOptions, 0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            // copy the existing OS Loadoptions into a string.
            StringCopy(szOsLoadOptions,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szOsLoadOptions));

            //check if the user has entered -basevideo option
            if(bBaseVideo)
            {
                if (FindString(szOsLoadOptions,BASEVIDEO_VALUE, 0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_NO_BV_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // remove the basevideo switch from the OS Load Options string.
                    removeSubString(szOsLoadOptions,BASEVIDEO_VALUE);
                }
            }

            if(bSos)
            {
                if (FindString(szOsLoadOptions,SOS_VALUE, 0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_NO_SOS_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // remove the /sos switch from the  Load Options string.
                    removeSubString(szOsLoadOptions,SOS_VALUE);
                }
            }

            if(bNoGui)
            {
                if (FindString(szOsLoadOptions,NOGUI_VALUE,0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_NO_NOGUI_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // remove the noguiboot switch to the OS Load Options string.
                    removeSubString(szOsLoadOptions,NOGUI_VALUE);
                }

            }

            if(bMaxmem)
            {
                if (FindString(szOsLoadOptions,MAXMEM_VALUE1,0) == 0 )
                {
                    ShowMessage(stderr,GetResString(IDS_NO_MAXMEM_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }
                else
                {
                    // add the redirect switch to the OS Load Options string.
                    //for, a temporary string of form /maxmem=xx so that it
                    //can be checked in the Os load options,
                    if ( GetSubString(szOsLoadOptions,MAXMEM_VALUE1,szTemp) == EXIT_FAILURE)
                    {
                        return EXIT_FAILURE ;
                    }
                    removeSubString(szOsLoadOptions,szTemp);
                    if(FindString(szOsLoadOptions,MAXMEM_VALUE1,0)!=0)
                    {
                        ShowMessage(stderr,GetResString(IDS_NO_MAXMEM) );
                        return EXIT_FAILURE ;
                    }
                }
            }

            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szOsLoadOptions,0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            //Change the OS load options. Pass NULL to friendly name as we are not changing the same
            //szRawString is the Os load options specified by the user
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
            if(dwExitCode == ERROR_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }

    Freelist();
    return (dwExitCode);

}

DWORD 
ProcessDbg1394Switch_IA64( IN DWORD argc, 
                           IN LPCTSTR argv[] 
                         )
/*++
  Routine Description :
       Which process the dbg1394 switch

  Arguments           :
    [ in ] argc           - Number of command line arguments
    [ in ] argv           - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if it is successful,
                       returns EXIT_FAILURE otherwise.
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bDbg1394 = FALSE ;

    DWORD dwBootID = 0;
    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    PLIST_ENTRY listEntry;
    PBOOT_ENTRY bootEntry;

    PWINDOWS_OS_OPTIONS pWindowsOptions = NULL ;
    TCHAR szOsLoadOptions[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szTemp[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szTmpBuffer[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szChannel[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szDefault[MAX_RES_STRING+1] = NULL_STRING ;

    DWORD dwChannel = 0 ;
    DWORD dwCode = 0 ;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[5];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DBG1394;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDbg1394;
    
     //id usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //default option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

   //id option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_CHANNEL;
    pcmdOption->dwFlags =  CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwChannel;

    //default option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDefault;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayDbg1394Usage_IA64() ;
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    if((cmdOptions[2].dwActuals == 0) &&(dwBootID == 0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_ID_MISSING));
        ShowMessage(stderr,GetResString(IDS_1394_HELP));
        return (EXIT_FAILURE);
    }

    //
    //display error message if user enters a value
    // other than on or off
    //
    if( ( StringCompare(szDefault,OFF_STRING,TRUE,0)!=0 ) && (StringCompare(szDefault,ON_STRING,TRUE,0)!=0 ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_DEFAULT_MISSING));
        ShowMessage(stderr,GetResString(IDS_1394_HELP));
        return (EXIT_FAILURE);
    }


    if(( StringCompare(szDefault,OFF_STRING,TRUE,0)==0 ) && (cmdOptions[3].dwActuals != 0) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
        return (EXIT_FAILURE);
    }

    if(( StringCompare(szDefault,ON_STRING,TRUE,0)==0 ) && (cmdOptions[3].dwActuals == 0) )
    {
        ShowMessage(stderr,GetResString(IDS_MISSING_CHANNEL));
        return (EXIT_FAILURE);
    }

    if(( StringCompare(szDefault,ON_STRING,TRUE,0)==0 ) && (cmdOptions[3].dwActuals != 0) &&( (dwChannel < 1) || (dwChannel > 64 ) ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_CH_RANGE));
        return (EXIT_FAILURE);
    }


    //Query the boot entries till u get the BootID specified by the user
    for (listEntry = BootEntries.Flink;listEntry != &BootEntries;listEntry = listEntry->Flink)
    {
        //Get the boot entry
        mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

        if(mybootEntry->myId == dwBootID)
        {
            bBootIdFound = TRUE;
            bootEntry = &mybootEntry->NtBootEntry;


            //Check whether the bootEntry is a Windows one or not.
            //The OS load options can be added only to a Windows boot entry.
            if(!IsBootEntryWindows(bootEntry))
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                dwExitCode = EXIT_FAILURE;
                break;
            }


            pWindowsOptions = (PWINDOWS_OS_OPTIONS)bootEntry->OsOptions;

            if(StringLengthW(pWindowsOptions->OsLoadOptions,0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }

            // copy the existing OS Loadoptions into a string.
            StringCopy(szOsLoadOptions,pWindowsOptions->OsLoadOptions, SIZE_OF_ARRAY(szOsLoadOptions));

            //check if the user has entered on option
            if(StringCompare(szDefault,ON_STRING,TRUE,0)==0 )
            {

                if(FindString(szOsLoadOptions,DEBUGPORT,0) != 0)
                {
                    ShowMessage(stderr,GetResString(IDS_DUPLICATE_ENTRY));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                if(FindString(szOsLoadOptions,BAUD_TOKEN,0) != 0)
                {
                    ShowMessage(stderr,GetResString(IDS_ERROR_BAUD_RATE));
                    dwExitCode = EXIT_FAILURE ;
                    break;
                }

                if( FindString(szOsLoadOptions,DEBUG_SWITCH,0)== 0)
                {
                    if( StringLength(szOsLoadOptions,0) != 0 )
                    {
                       StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                       StringConcat(szTmpBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szOsLoadOptions));
                    }
                    else
                    {
                        StringCopy(szTmpBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szOsLoadOptions));
                    }
                }

                if(StringLength(szTmpBuffer,0) == 0)
                {
                    StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                }
                else
                {
                    StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                }
                StringConcat(szTmpBuffer,DEBUGPORT_1394, SIZE_OF_ARRAY(szTmpBuffer)) ;

                if(dwChannel!=0)
                {
                    //frame the string and concatenate to the Os Load options.
                    StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE,SIZE_OF_ARRAY(szTmpBuffer));
                    StringConcat(szTmpBuffer,TOKEN_CHANNEL,SIZE_OF_ARRAY(szTmpBuffer));
                    StringConcat(szTmpBuffer,TOKEN_EQUAL,SIZE_OF_ARRAY(szTmpBuffer));
                    _ltow(dwChannel,szChannel,10);
                    StringConcat(szTmpBuffer,szChannel,SIZE_OF_ARRAY(szTmpBuffer));
                }


            }

            if(StringCompare(szDefault,OFF_STRING,TRUE,0)==0 )
            {
                if(FindString(szOsLoadOptions,DEBUGPORT_1394,0) == 0)
                {
                    ShowMessage(stderr,GetResString(IDS_NO_1394_SWITCH));
                    dwExitCode = EXIT_FAILURE;
                    break;
                }

                //
                //remove the port from the Os Load options string.
                //
                removeSubString(szOsLoadOptions,DEBUGPORT_1394);

                // check if the string contains the channel token
                // and if present remove that also.
                //
                if(FindString(szOsLoadOptions,TOKEN_CHANNEL,0)!=0)
                 {
                    StringCopy(szTemp,NULL_STRING, MAX_RES_STRING);
                    dwCode = GetSubString(szOsLoadOptions,TOKEN_CHANNEL,szTemp);
                    if(dwCode == EXIT_SUCCESS)
                    {
                        //
                        //Remove the channel token if present.
                        //
                        if(StringLengthW(szTemp,0)!= 0)
                        {
                            removeSubString(szOsLoadOptions,szTemp);
                            removeSubString(szOsLoadOptions,DEBUG_SWITCH);
                        }
                    }
                }
                removeSubString(szOsLoadOptions,DEBUG_SWITCH);
            }

            //display error message if Os Load options is more than 254
            // characters.
            if(StringLengthW(szOsLoadOptions,0)+StringLength(szTmpBuffer,0) > MAX_RES_STRING)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH1),MAX_RES_STRING);
                return EXIT_FAILURE ;
            }
            else
            {
                StringConcat(szOsLoadOptions, szTmpBuffer, SIZE_OF_ARRAY(szOsLoadOptions) );
            }



            //Change the OS load options. Pass NULL to friendly name as we are not changing the same
            //szRawString is the Os load options specified by the user
            dwExitCode = ChangeBootEntry(bootEntry, NULL, szOsLoadOptions);
            if(dwExitCode == ERROR_SUCCESS)
            {
                ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS),dwBootID);
            }
            else
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
            }
            break;
        }
    }

    if(bBootIdFound == FALSE)
    {
        //Could not find the BootID specified by the user so output the message and return failure
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        dwExitCode = EXIT_FAILURE;
    }
    
    Freelist();
    return (dwExitCode);
}

 DWORD 
 ProcessMirrorSwitch_IA64( IN DWORD argc, 
                           IN LPCTSTR argv[] 
                          )
/*++

  Routine Description  :
                process the mirror switch

  Arguments          :
     [ in ] argc           - Number of command line arguments
     [ in ] argv           - Array containing command line arguments

  Return Type        : DWORD
                       Returns EXIT_SUCCESS if it is successful,
                       returns EXIT_FAILURE otherwise.

--*/
{

    BOOL bUsage = FALSE ;
    DWORD dwBootID = 0;
    BOOL bBootIdFound = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    PMY_BOOT_ENTRY mybootEntry;
    TCHAR szAdd[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szLoaderPath[MAX_RES_STRING+1] = NULL_STRING ;
    BOOL bMirror = FALSE ;
    NTSTATUS status ;
    DWORD error = 0 ;
    TCHAR szFinalStr[256] = NULL_STRING ;
    TCHAR szResult[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwActuals = 0 ;
    PBOOT_ENTRY_LIST ntBootEntries = NULL;
    PBOOT_ENTRY pBootEntry = NULL ;
    PFILE_PATH pFilePath = NULL ;
    PWSTR NtFilePath ;
    PTCHAR szPartition = NULL ;
    TCHAR szOsLoaderPath[MAX_RES_STRING+1] = NULL_STRING ;

    TCHAR szSystemPartition[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szBrackets[] = _T("{}");
    PLIST_ENTRY listEntry;
    BOOL bFlag = TRUE ;
    TCHAR szFriendlyName[MAX_STRING_LENGTH] = NULL_STRING ;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[5];
    PTCMDPARSER2 pcmdOption;
    BOOL bNobreak = TRUE;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_MIRROR;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bMirror;

     //id usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    // add option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_ADD;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szAdd;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //id option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY;  
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwBootID;

    // friendly option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_DESCRIPTION;
    pcmdOption->dwFlags =  CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szFriendlyName;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    // Parsing the copy option switches
     if ( !(DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_MIRROR_SYNTAX));
        return ( EXIT_FAILURE );
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayMirrorUsage_IA64() ;
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

   // If the user enters empty string after add option then display an error
    // message.

    TrimString(szAdd,TRIM_ALL);
    TrimString(szFriendlyName,TRIM_ALL);

    //
    //copy the default friendly name from resource file if no
    //friendly name is specified.
    //
    if(cmdOptions[4].dwActuals == 0)
    {
        StringCopy(szFriendlyName,GetResString(IDS_MIRROR_NAME), SIZE_OF_ARRAY(szFriendlyName));
    }

    if(StringLengthW(szAdd,0) !=0)
    {
        //Trim of the Brackets which may be specified
        //along with the GUID.
        TrimString2(szAdd, szBrackets, TRIM_ALL);
        dwActuals = 0 ;

         //get the ARC signature path corresponding to the GUID specified.
        if (GetDeviceInfo(szAdd,szFinalStr,0,dwActuals) == EXIT_FAILURE )
        {
            return EXIT_FAILURE ;
        }

        StringConcat(szFinalStr,_T("\\WINDOWS"), SIZE_OF_ARRAY(szFinalStr));

        //
        //if the user does specifies /id option
        // then retreive the OS Load Path from the
        // registry
        //
        if(cmdOptions[3].dwActuals == 0 )
        {
            //retreive the Os Loader Path from the registry.
            if(GetBootPath(IDENTIFIER_VALUE2,szResult) != ERROR_SUCCESS )
            {
                ShowMessage(stderr,GetResString(IDS_ERROR_UNEXPECTED));
                return EXIT_FAILURE ;
            }

            //retreive the Os Loader Path from the registry.
            if( GetBootPath(IDENTIFIER_VALUE3,szLoaderPath)!= ERROR_SUCCESS )
            {
                ShowMessage(stderr,GetResString(IDS_ERROR_UNEXPECTED));
                return EXIT_FAILURE ;
            }

            bFlag = TRUE ;
            //call the function which adds the mirror plex.
            if (AddMirrorPlex(szFinalStr,szLoaderPath,szResult,bFlag,szFriendlyName) == EXIT_FAILURE )
            {
                return EXIT_FAILURE ;
            }
        }
        else
        {
            // query the information from the NVRAM .
            status = BootCfg_EnumerateBootEntries(&ntBootEntries);
            if( !NT_SUCCESS(status) )
            {
                error = RtlNtStatusToDosError( status );
                return EXIT_FAILURE ;
            }


            for (listEntry = BootEntries.Flink; listEntry != &BootEntries;  listEntry = listEntry->Flink)
            {
                //Get the boot entry
                mybootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );

                //check for the id specified by the user matches the
                // id
                if(mybootEntry->myId == dwBootID)
                {
                    bBootIdFound = TRUE;
                    pBootEntry = &mybootEntry->NtBootEntry;

                    //Check whether the bootEntry is a Windows one or not.
                    //The OS load options can be added only to a Windows boot entry.
                    if(!IsBootEntryWindows(pBootEntry))
                    {
                        ShowMessageEx(stderr, 1, TRUE,  GetResString(IDS_ERROR_OSOPTIONS),dwBootID);
                        dwExitCode = EXIT_FAILURE;
                        break;
                    }
                }
            }
            // display an error
            if (pBootEntry == NULL)
            {
                ShowMessage(stderr,GetResString(IDS_PARTITION_ERROR));
                SAFEFREE(ntBootEntries);
                return EXIT_FAILURE ;
            }

            //Get a pointer to the FILE_PATH structure.
            pFilePath = (PFILE_PATH)ADD_OFFSET(pBootEntry, BootFilePathOffset);

            //get the  name of the .
            NtFilePath = GetNtNameForFilePath(pFilePath );
           if(NtFilePath == NULL)
           {
               ShowMessage(stderr,GetResString(IDS_ERROR_MIRROR));
               SAFEFREE(ntBootEntries);
               return EXIT_FAILURE ;
           }

           // split the path to get the SystemPartition path and the
           // OsLoader Path .
           szPartition = _tcstok(NtFilePath,_T("\\"));

           //display error message and exit if szPartition is null.
           if(szPartition == NULL)
           {
                ShowMessage(stderr,GetResString(IDS_TOKEN_ABSENT));
                SAFEFREE(ntBootEntries);
                return EXIT_FAILURE ;
           }

           //concatenate the "\" to frame the path .
            StringConcat(szOsLoaderPath,_T("\\"), SIZE_OF_ARRAY(szOsLoaderPath));
            StringConcat(szOsLoaderPath,szPartition, SIZE_OF_ARRAY(szOsLoaderPath) );
            StringConcat(szOsLoaderPath,_T("\\"), SIZE_OF_ARRAY(szOsLoaderPath));


            szPartition = _tcstok(NULL,_T("\\"));

            //display error message and exit if szPartition is null.
            if(NULL == szPartition )
            {
                ShowMessage(stderr,GetResString(IDS_TOKEN_ABSENT));
                SAFEFREE(ntBootEntries);
                return EXIT_FAILURE ;
            }


            StringConcat(szOsLoaderPath,szPartition, SIZE_OF_ARRAY(szOsLoaderPath));

        //Framing the OsLoader Path
        do
        {
            szPartition = _tcstok(NULL,_T("\\"));
            if(szPartition == NULL)
            {
                break ;
                bNobreak = FALSE;
            }
            StringConcat(szSystemPartition,_T("\\"), SIZE_OF_ARRAY(szSystemPartition));
            StringConcat(szSystemPartition,szPartition, SIZE_OF_ARRAY(szSystemPartition));
        }while(TRUE == bNobreak );

        //This flag is for determining if the boot path should be BOOTFILE_PATH1
        //or BOOTFILE_PATH

        bFlag = FALSE ;

        //call the function which adds the mirror plex.
        if ( AddMirrorPlex(szFinalStr,szSystemPartition,szOsLoaderPath,bFlag,szFriendlyName) == EXIT_FAILURE )
        {
            return EXIT_FAILURE ;
        }
     }
  }

    SAFEFREE(ntBootEntries);
    Freelist();
    return EXIT_SUCCESS ;
}

NTSTATUS 
FindBootEntry(IN PVOID pEntryListHead,
              IN WCHAR *pwszTarget, 
              OUT PBOOT_ENTRY *ppTargetEntry
             )
/*++

    Routine description :     Routine finds a boot entry in the list of all boot
                            entries and returns a pointer into the list for the found entry.



  Arguments:
      pEntryListHead  - The address of a pointer to a BOOT_ENTRY_LIST struct.

      pwszTarget      - The OsLoadPath (install path) string.
                          "signature(<part GUID>-<part#>-<part_start>-<part_len>)"
                        OR
                        "signature(<part GUID>-<part#>-<part_start>-<part_len>)\\WINDOWS"
                       on input. If we find the entry in NVRAM, we copy the
                        full install path back to the input string so that it includes
                        the directory name.

      ppTargetEntry   - The address of a BOOT_ENTRY pointer, points to the
                         found entry at return.

    Return Value        : NT status
 
                          STATUS_INSUFFICIENT_RESOURCES
                          STATUS_ACCESS_VIOLATION
                          STATUS_UNSUPPORTED
                          STATUS_OBJECT_NAME_NOT_FOUND
                          STATUS_SUCCESS and *ppTargetEntry should be non-NULL for success.
--*/
{
    LONG                status          = STATUS_SUCCESS;
    PBOOT_ENTRY_LIST    pEntryList      = NULL;
    PBOOT_ENTRY         pEntry          = NULL;
    PWINDOWS_OS_OPTIONS pOsOptions      = NULL;
    PFILE_PATH          pTransEntry     = NULL;
    DWORD               dwTransSize     = 0L;
    DWORD               i               = 0L;
    BOOL                bFlag           = FALSE ;
    BOOL                bNobreak        = FALSE ;
    DWORD               dwCount         = 0L ;
    TCHAR               szFinalStr[256] = NULL_STRING ;
    DWORD               dwFailCount     = 0L;
    DWORD               dwSuccessCount  = 0L;

    if ( !pEntryListHead || !pwszTarget || !ppTargetEntry )
    {
        ShowMessage(stderr,GetResString(IDS_FIND_BOOT_ENTRY) );
        return STATUS_INVALID_PARAMETER;
    }

    *ppTargetEntry = NULL;
    pEntryList = (PBOOT_ENTRY_LIST) pEntryListHead;

    //
    // Iterate over all the entries returned looking for the target
    // boot partition's entry. Convert the install path for each
    // entry to the signature format, then compare to the
    // input partition signature formatted path.
    //
    bNobreak = TRUE;
    do 
    {
        //
        // Translate the entry's install path to signature format.
        //
        if ( pEntryList )
        {
            pEntry = &pEntryList->BootEntry;
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_FIND_BOOT_ENTRY_NULL));
            status = STATUS_OBJECT_NAME_NOT_FOUND;
            bNobreak = FALSE;
            break;
        }

        //
        // If this entry does not have the BOOT_ENTRY_ATTRIBUTE_WINDOWS
        // attribute set, or, the attribute is set and this entry has
        // an invalid OsOptions structure length, move to the next entry
        // and continue searching and check the next boot entry
        //

        if ( !(pEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) || ( (pEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_WINDOWS) && pEntry->OsOptionsLength < sizeof(WINDOWS_OS_OPTIONS) ) )
        {
	        //exit from the loop if we have reached the last Boot Entry.
            if ( !pEntryList->NextEntryOffset )
            {
                bNobreak = FALSE;
                break;
            }
            //
            // Continue with the next iteration
            // after obtaining the pointer to the next entry.
            //
            pEntryList = (PBOOT_ENTRY_LIST)(((PBYTE)pEntryList) + pEntryList->NextEntryOffset);
            continue;
        }
	     
        //
        // Use the entry's current length to start and resize
        // if necessary.
        //
        dwTransSize = pEntry->Length;
        for ( i = 1; i <= 2; i++ )
        {

            if ( pTransEntry )
            {
                MEMFREE(pTransEntry);
                pTransEntry = NULL;
            }

            pTransEntry = (PFILE_PATH) MEMALLOC(dwTransSize);
            if ( !pTransEntry )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                status = STATUS_NO_MEMORY;
                SAFEMEMFREE(pTransEntry);
                return status ;
            }

            pOsOptions = (WINDOWS_OS_OPTIONS *)&pEntry->OsOptions;
            status = NtTranslateFilePath
                     (
                        (PFILE_PATH)( ((PBYTE) pOsOptions) + pOsOptions->OsLoadPathOffset ),
                        FILE_PATH_TYPE_ARC_SIGNATURE,
                        pTransEntry,
                        &dwTransSize
                     );

            if ( STATUS_INSUFFICIENT_RESOURCES == status )
            {
                continue;
            }
            else
            {
                break;
            }
        }
	     
        //
        // Ignore STATUS_OBJECT_NAME_NOT_FOUND
        // We shouldn't get that error anyway, since we are using
        // the long signature format.
        //
        if ( !NT_SUCCESS(status)&& STATUS_OBJECT_NAME_NOT_FOUND != status )
        {
            DISPLAY_MESSAGE( stderr,GetResString(IDS_TRANSLATE_FAIL));
            SAFEMEMFREE(pTransEntry);
            return status ;
        }

        //
        // Compare this entry's install path to the current boot
        // partition's signature formatted install path.
        // If the input install path may not include the install
        // directory name.
        //
        //
        // Check if the GUID specified by the User matches with the set of GUID's
        // already present
        //
		
        if ( NT_SUCCESS(status) && !(wcsncmp( (WCHAR*)&pTransEntry->FilePath, pwszTarget, 48 ) ) )
        {
			
			// Set the flag to true indicating that the
            // specified GUID matches
            //
            bFlag = TRUE ;

            //
            // Check if the ARC Path specified by the User matches with the ARC Path
            // of the entry already present and if so display an error message and exit.
            //
            
            if( !(StringCompare( (WCHAR*)&pTransEntry->FilePath, pwszTarget, TRUE, StringLengthW(pwszTarget,0) ) ) )
            {
				
                ShowMessage(stderr,GetResString(IDS_ALREADY_UPDATED));
                SAFEMEMFREE(pTransEntry) ;
                return STATUS_OBJECT_NAME_NOT_FOUND;

            }
            else
            {
                *ppTargetEntry = pEntry;
                
				
                //concatenate the string "\WINDOWS" to the path formed.
                StringCopy ( szFinalStr, NULL_STRING, SIZE_OF_ARRAY(szFinalStr));
                StringConcat(szFinalStr,pwszTarget,SIZE_OF_ARRAY(szFinalStr));
                StringConcat(szFinalStr,_T("\\WINDOWS"), SIZE_OF_ARRAY(szFinalStr));

                //
                //modify the Boot Entry with the Arc Signature path specified.
                //
                status = ModifyBootEntry(szFinalStr,*ppTargetEntry);
                if ( !NT_SUCCESS(status) )
                {	
                    //If unsuccessful to update the Boot_Entry then increment the Failure
                    //count.
                    dwFailCount++ ;
                }
                else
                {
                    //If successfully updated the Boot_Entry then increment the Success
                    //count.
                    dwSuccessCount++;
                }

                if ( !pEntryList->NextEntryOffset )
                {
                    bNobreak = FALSE;
                    break;
                }
                else
                {
                    pEntryList = (PBOOT_ENTRY_LIST)( ((PBYTE)pEntryList) + pEntryList->NextEntryOffset );
                    continue ;
                } 
            }

        }
        else
        {
            if ( !pEntryList->NextEntryOffset )
            {
                bNobreak = FALSE;
                break;
            }

            pEntryList = (PBOOT_ENTRY_LIST)( ((PBYTE)pEntryList) + pEntryList->NextEntryOffset );
        }
    }while(TRUE == bNobreak );

	// Depending upon the number of entries successfully updated 
	// display appropriate messages.
	if((0 != dwFailCount)&&(0 == dwSuccessCount))
	{
		ShowMessage(stdout,GetResString(IDS_MODIFY_FAIL));
	}
	if(( 0 != dwSuccessCount )&&(0 == dwFailCount))
	{
		ShowMessage(stdout,GetResString(IDS_GUID_MODIFIED));
	}
	else if( ( 0 != dwSuccessCount )&&(0 != dwFailCount))
	{
		
		ShowMessage(stdout,GetResString(IDS_PARTIAL_UPDATE));
	}

	
    //display an error message if the GUID specified does not match with the GUID's present.
    if(FALSE == bFlag )
    {
        //ShowMessage(stderr,GetResString(IDS_FIND_FAIL));
        SAFEMEMFREE(pTransEntry) ;
        return STATUS_INVALID_PARAMETER;
    }

    SAFEMEMFREE(pTransEntry)
    return status;
}


LPVOID 
MEMALLOC( ULONG size ) 
/*++

   Routine Description            : Allocates the memory Block.

   Arguments                      :
      [ in ] block                : Size of the block to be allocated.

   Return Type                    : LPVOID
--*/
{
    HANDLE hProcessHeap;
    hProcessHeap = GetProcessHeap();
    if (hProcessHeap == NULL ||
        size > 0x7FFF8) {
        return NULL;
    }
    else {
        return HeapAlloc (hProcessHeap, HEAP_ZERO_MEMORY, size);
    }
}

VOID MEMFREE ( LPVOID block ) {
/*++

   Routine Description            : Frees the memory Allocated.
   Arguments                      :
      [ in ] block                : Block to be freed.


   Return Type                    : VOID
--*/

    HANDLE hProcessHeap;
    hProcessHeap = GetProcessHeap();
    if (hProcessHeap != NULL) {
        HeapFree(hProcessHeap, 0, block);
    }
}


NTSTATUS 
ModifyBootEntry( IN WCHAR *pwszInstallPath, 
                 IN PBOOT_ENTRY pSourceEntry
               )
/*++
  Routine description : This routine is used to modify a boot entry in the  NVRAM.


  Arguments:
         pwszInstallPath - The new install path
         pSourceEntry    - Entry that we will modify

  Return Value        : NT status
--*/
{
    LONG        status              = STATUS_SUCCESS;
    PFILE_PATH  pLoaderFile         = NULL;
    ULONG       dwLoaderFileSize    = 0L;
    PFILE_PATH  pInstallPath        = NULL;     // new install path
    ULONG       dwInstallPathSize   = 0L;       // new install path size
    PWINDOWS_OS_OPTIONS pWinOpt     = NULL;
    ULONG       dwWinOptSize        = 0L;
    PBOOT_ENTRY pSetEntry           = 0L;       // new, modified entry
    ULONG       dwSetEntrySize      = 0L;
    DWORD       dwFriendlyNameSize  = 0L;
    DWORD       dwAlign             = 0L;

    PWINDOWS_OS_OPTIONS pSourceWinOpt = NULL;   // old, source entry options to be modified
    PFILE_PATH  pSourceInstallPath  = NULL;     // old, source entry install path to be modified

    //
    // Validate params.
    //

    if ( !pwszInstallPath
        || !(StringLengthW(pwszInstallPath,0))
        || !pSourceEntry ) 
   {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Setup the BootFilePath member of the BOOT_ENTRY.
    //

    dwLoaderFileSize = ( (PFILE_PATH) (((PBYTE)pSourceEntry) + pSourceEntry->BootFilePathOffset) )->Length;
    pLoaderFile = (PFILE_PATH)MEMALLOC(dwLoaderFileSize);

    if ( NULL == pLoaderFile )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return STATUS_NO_MEMORY ;
    }

    RtlCopyMemory(pLoaderFile,((PBYTE)pSourceEntry) + pSourceEntry->BootFilePathOffset,
                dwLoaderFileSize
                );

    //
    // Setup the OsLoadPath member of the WINDOWS_OS_OPTIONS struct.
    //

    dwInstallPathSize = FIELD_OFFSET(FILE_PATH, FilePath) + ( (StringLengthW(pwszInstallPath,0)+1) * sizeof(WCHAR) );
    pInstallPath = (PFILE_PATH)MEMALLOC(dwInstallPathSize);

    if ( NULL == pInstallPath )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFEMEMFREE(pLoaderFile);
        return STATUS_NO_MEMORY ;
    }

    pSourceWinOpt = (PWINDOWS_OS_OPTIONS) &pSourceEntry->OsOptions;
    pSourceInstallPath = (PFILE_PATH)( ((PBYTE)pSourceWinOpt)+ pSourceWinOpt->OsLoadPathOffset );

    pInstallPath->Version = pSourceInstallPath->Version;
    pInstallPath->Length = dwInstallPathSize;                           // new install path size
    pInstallPath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;
    RtlCopyMemory(pInstallPath->FilePath,                               // new path to the OS on the boot partition, "signature(partition_guid)\WINDOWS"
                pwszInstallPath,
                (StringLengthW(pwszInstallPath,0) + 1) * sizeof(WCHAR)
                );

    //
    // Setup the OsOptions member of the BOOT_ENTRY
    //

    dwWinOptSize = FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)
                    + ( (StringLengthW(pSourceWinOpt->OsLoadOptions,0) + 1) * sizeof(WCHAR) ) // old OsLoadOptions
                    + dwInstallPathSize             // new OsLoadPath
                    + sizeof(DWORD);                // Need to align the FILE_PATH struct
    pWinOpt = (PWINDOWS_OS_OPTIONS) MEMALLOC(dwWinOptSize);

    if ( NULL == pWinOpt )
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFEMEMFREE(pLoaderFile);
        SAFEMEMFREE(pInstallPath);
        return STATUS_NO_MEMORY ;
    }


    RtlCopyMemory( pWinOpt->Signature, pSourceWinOpt->Signature, sizeof(WINDOWS_OS_OPTIONS_SIGNATURE) );

    pWinOpt->Version = pSourceWinOpt->Version;
    pWinOpt->Length = dwWinOptSize;
    pWinOpt->OsLoadPathOffset = FIELD_OFFSET(WINDOWS_OS_OPTIONS, OsLoadOptions)
                    + ((StringLengthW(pSourceWinOpt->OsLoadOptions,0) + 1) * sizeof(WCHAR));
    //
    // Need to align the OsLoadPathOffset on a 4 byte boundary.
    //
    dwAlign = ( pWinOpt->OsLoadPathOffset & (sizeof(DWORD) - 1) );
    if ( dwAlign != 0 ) 
    {
        pWinOpt->OsLoadPathOffset += sizeof(DWORD) - dwAlign;
    }

    StringCopy(pWinOpt->OsLoadOptions, pSourceWinOpt->OsLoadOptions, (StringLengthW(pSourceWinOpt->OsLoadOptions,0)));
    RtlCopyMemory( ((PBYTE)pWinOpt) + pWinOpt->OsLoadPathOffset, pInstallPath, dwInstallPathSize );

    //
    // Setup the BOOT_ENTRY struct.
    //
    dwFriendlyNameSize = ( StringLengthW( (WCHAR *)(((PBYTE)pSourceEntry) + pSourceEntry->FriendlyNameOffset), 0 ) + 1)*sizeof(WCHAR);

    dwSetEntrySize = FIELD_OFFSET(BOOT_ENTRY, OsOptions)
                    + dwWinOptSize          // OsOptions
                    + dwFriendlyNameSize    // FriendlyName including the NULL terminator
                    + dwLoaderFileSize      // BootFilePath
                    + sizeof(WCHAR)         // Need to align the FriendlyName on WCHAR
                    + sizeof(DWORD);        // Need to align the BootFilePath on DWORD


    pSetEntry = (PBOOT_ENTRY) MEMALLOC(dwSetEntrySize);

    if ( NULL == pSetEntry )
    {
        SAFEMEMFREE(pLoaderFile);
        SAFEMEMFREE(pInstallPath);
        SAFEMEMFREE(pWinOpt);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return STATUS_NO_MEMORY;
    }

    pSetEntry->Version = pSourceEntry->Version;
    pSetEntry->Length = dwSetEntrySize;
    pSetEntry->Id = pSourceEntry->Id;                   // not used, output param
    pSetEntry->Attributes = pSourceEntry->Attributes;
    pSetEntry->FriendlyNameOffset = FIELD_OFFSET(BOOT_ENTRY, OsOptions)
                                            + dwWinOptSize;
    //
    // Need to align the unicode string on a 2 byte boundary.
    //
    dwAlign = ( pSetEntry->FriendlyNameOffset & (sizeof(WCHAR) - 1) );
    if ( dwAlign != 0 ) 
    {
        pSetEntry->FriendlyNameOffset += sizeof(WCHAR) - dwAlign;
    }

    pSetEntry->BootFilePathOffset = pSetEntry->FriendlyNameOffset + dwFriendlyNameSize;
    //
    // Need to align the FILE_PATH struct on a 4 byte boundary.
    //
    dwAlign = ( pSetEntry->BootFilePathOffset & (sizeof(DWORD) - 1) );
    if ( dwAlign != 0 )
    {
        pSetEntry->BootFilePathOffset += sizeof(DWORD) - dwAlign;
    }

    pSetEntry->OsOptionsLength = dwWinOptSize;

    RtlCopyMemory( pSetEntry->OsOptions, pWinOpt, dwWinOptSize );

    RtlCopyMemory( ((PBYTE)pSetEntry) + pSetEntry->FriendlyNameOffset,
            ((PBYTE)pSourceEntry) + pSourceEntry->FriendlyNameOffset,
            dwFriendlyNameSize
            );

    RtlCopyMemory( ((PBYTE)pSetEntry) + pSetEntry->BootFilePathOffset,
            pLoaderFile,
            dwLoaderFileSize
            );

    status = NtModifyBootEntry( pSetEntry );
    if(!NT_SUCCESS(status))
    {
        ShowMessage(stderr,GetResString(IDS_MODIFY_FAIL));
    }

    SAFEMEMFREE(pLoaderFile);
    SAFEMEMFREE(pInstallPath);
    SAFEMEMFREE(pWinOpt);
    SAFEMEMFREE(pSetEntry);
    return status;
}

DWORD 
ListDeviceInfo(DWORD dwDriveNum)
/*++

  Routine description : This routine is used to  retrieve the list of device partitions.


  Arguments:
    szGUID            : The address of a pointer to a BOOT_ENTRY_LIST struct.
    szFinalStr        : The String containing the final ARG signature path.

  Return Value        : DWORD
                          EXIT_SUCCESS if it is successful,
                          EXIT_FAILURE otherwise.
--*/
{
    HRESULT hr = S_OK;
    HANDLE hDevice  ;

    BOOL bResult = FALSE ;
    PPARTITION_INFORMATION_EX pInfo=NULL ;
    PDRIVE_LAYOUT_INFORMATION_EX Drive=NULL;
    DWORD dwBytesCount = 0 ;

    TCHAR szDriveName[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwStructSize = 0 ;

    TCHAR szInstallPath[MAX_RES_STRING+1] = NULL_STRING;
    TCHAR szWindowsDirectory[MAX_PATH*2] = NULL_STRING;

    PTCHAR pszTok = NULL ;
    PPARTITION_INFORMATION_GPT pGptPartition=NULL;

    DWORD dwPartitionId = 0 ;

    CHAR szTempBuffer[ 33 ] = "\0";
    WCHAR wszOffsetStr[ 33 ] = L"\0";
    CHAR szTempBuffer1[ 33 ] = "\0";
    WCHAR wszPartitionStr[ 33 ] = L"\0";
    WCHAR szOutputStr[MAX_RES_STRING+1] = NULL_STRING ;

    NTSTATUS ntstatus;

    SecureZeroMemory(szDriveName, SIZE_OF_ARRAY(szDriveName));

    hr = StringCchPrintf(szDriveName, SIZE_OF_ARRAY(szDriveName), _T("\\\\.\\physicaldrive%d"),dwDriveNum);

    //get a handle after opening the File.
    hDevice = CreateFile(szDriveName,
               GENERIC_READ|GENERIC_WRITE,
               FILE_SHARE_READ|FILE_SHARE_WRITE,
               NULL,
               OPEN_EXISTING,
               0,
               NULL);

     if(hDevice == INVALID_HANDLE_VALUE)
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_DISK));
        return EXIT_FAILURE ;

    }


     Drive = (PDRIVE_LAYOUT_INFORMATION_EX)AllocateMemory(sizeof(DRIVE_LAYOUT_INFORMATION_EX) +5000) ;
     if(NULL == Drive)
     {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        CloseHandle(hDevice);
        return EXIT_FAILURE ;
     }

    dwStructSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) ;

    bResult = DeviceIoControl(
                            hDevice,
                            IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                            NULL,
                            0,
                            Drive,
                            sizeof(DRIVE_LAYOUT_INFORMATION_EX)+5000,
                            &dwBytesCount,
                                NULL);

        if(bResult ==0)
        {
            SAFEFREE(Drive);
            DISPLAY_MESSAGE( stderr, ERROR_TAG);
            ShowLastError(stderr);
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_LIST0),dwDriveNum);
        ShowMessage(stdout,GetResString(IDS_LIST1));

        for(dwPartitionId = 0 ;dwPartitionId < Drive->PartitionCount ; dwPartitionId++)
        {
            //get a pointer to the corresponding partition.

            pInfo = (PPARTITION_INFORMATION_EX)(&Drive->PartitionEntry[dwPartitionId] ) ;

           ShowMessageEx(stdout,1, TRUE, GetResString(IDS_LIST2),dwPartitionId+1);

            switch(Drive->PartitionStyle )
            {
                case PARTITION_STYLE_MBR :
                                            ShowMessage(stdout,GetResString(IDS_LIST3));
                                            break;
                case PARTITION_STYLE_GPT :
                                            ShowMessage(stdout,GetResString(IDS_LIST4));
                                            break;
                case PARTITION_STYLE_RAW :
                                            ShowMessage(stdout,GetResString(IDS_LIST5));
                                            break;
            }


        ntstatus = RtlLargeIntegerToChar( &pInfo->StartingOffset, 10, SIZE_OF_ARRAY( szTempBuffer ), szTempBuffer );
        if ( ! NT_SUCCESS( ntstatus ) )
        {
            SAFEFREE(Drive);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }


        ntstatus = RtlLargeIntegerToChar( &pInfo->PartitionLength, 10, SIZE_OF_ARRAY( szTempBuffer1 ), szTempBuffer1 );
        if ( ! NT_SUCCESS( ntstatus ) )
        {
            SAFEFREE(Drive);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        MultiByteToWideChar( _DEFAULT_CODEPAGE, 0, szTempBuffer, -1, wszOffsetStr, SIZE_OF_ARRAY(wszOffsetStr) );

        if( ConvertintoLocale( wszOffsetStr,szOutputStr )== EXIT_FAILURE )
        {
            SAFEFREE(Drive);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }


        ShowMessage(stdout,GetResString(IDS_LIST6));
        ShowMessage(stdout,_X3(szOutputStr));
        ShowMessage(stdout,L"\n");

        MultiByteToWideChar( _DEFAULT_CODEPAGE, 0, szTempBuffer1, -1, wszPartitionStr, SIZE_OF_ARRAY(wszOffsetStr) );

        if( ConvertintoLocale( wszPartitionStr,szOutputStr )== EXIT_FAILURE )
        {
            SAFEFREE(Drive);
            DISPLAY_MESSAGE( stderr, ERROR_TAG);
            ShowLastError(stderr);
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        ShowMessage(stdout,GetResString(IDS_LIST7));
        ShowMessage(stdout,_X3(szOutputStr));
        ShowMessage(stdout,L"\n");


        //get a pointer to the PARTITION_INFORMATION_GPT structure.
        pGptPartition = AllocateMemory( sizeof( PARTITION_INFORMATION_GPT));
        if(NULL == pGptPartition )
        {
            SAFEFREE(Drive);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        CopyMemory(pGptPartition,&pInfo->Gpt,sizeof(PARTITION_INFORMATION_GPT) );

        ShowMessage(stdout, GetResString(IDS_LIST8));
        ShowMessageEx(stdout, 11, TRUE, _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                pGptPartition->PartitionId.Data1,
                pGptPartition->PartitionId.Data2,
                pGptPartition->PartitionId.Data3,
                pGptPartition->PartitionId.Data4[0],
                pGptPartition->PartitionId.Data4[1],
                pGptPartition->PartitionId.Data4[2],
                pGptPartition->PartitionId.Data4[3],
                pGptPartition->PartitionId.Data4[4],
                pGptPartition->PartitionId.Data4[5],
                pGptPartition->PartitionId.Data4[6],
                pGptPartition->PartitionId.Data4[7] );

         ShowMessage(stdout, GetResString(IDS_LIST9));
         ShowMessageEx(stdout, 11, TRUE,
                _T("{%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}"),
                pGptPartition->PartitionType.Data1,
                pGptPartition->PartitionType.Data2,
                pGptPartition->PartitionType.Data3,
                pGptPartition->PartitionType.Data4[0],
                pGptPartition->PartitionType.Data4[1],
                pGptPartition->PartitionType.Data4[2],
                pGptPartition->PartitionType.Data4[3],
                pGptPartition->PartitionType.Data4[4],
                pGptPartition->PartitionType.Data4[5],
                pGptPartition->PartitionType.Data4[6],
                pGptPartition->PartitionType.Data4[7]   );

            //partition name.
           if(StringLengthW(pGptPartition->Name,0) != 0)
           {
                ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_LIST10),pGptPartition->Name);
           }
           else
           {
                ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_LIST10),_T("N/A"));
           }
        }

        if( 0 == GetWindowsDirectory(szWindowsDirectory,MAX_PATH) )
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            ShowMessage(stderr,GetResString(IDS_ERROR_DRIVE));
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }


        StringConcat(szWindowsDirectory,_T("*"), SIZE_OF_ARRAY(szWindowsDirectory));

        pszTok = _tcstok(szWindowsDirectory,_T("\\"));
        if(pszTok == NULL)
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_TOKEN_ABSENT));
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        pszTok = _tcstok(NULL,_T("*"));
        if(pszTok == NULL)
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            DISPLAY_MESSAGE(stderr,GetResString(IDS_TOKEN_ABSENT));
            CloseHandle(hDevice);
            return EXIT_FAILURE ;
        }

        SecureZeroMemory(szInstallPath, SIZE_OF_ARRAY(szInstallPath));
        hr = StringCchPrintf( szInstallPath, SIZE_OF_ARRAY(szInstallPath),
            _T("signature({%08x-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x}-%08x-%016I64x-%016I64x)"),
          pGptPartition->PartitionId.Data1,
          pGptPartition->PartitionId.Data2,
          pGptPartition->PartitionId.Data3,
          pGptPartition->PartitionId.Data4[0],
          pGptPartition->PartitionId.Data4[1],
          pGptPartition->PartitionId.Data4[2],
          pGptPartition->PartitionId.Data4[3],
          pGptPartition->PartitionId.Data4[4],
          pGptPartition->PartitionId.Data4[5],
          pGptPartition->PartitionId.Data4[6],
          pGptPartition->PartitionId.Data4[7],
          pInfo->PartitionNumber,
          pInfo->StartingOffset,
          pInfo->PartitionLength
          );

    SAFEFREE(Drive);
    SAFEFREE(pGptPartition);
    CloseHandle(hDevice);
    return EXIT_SUCCESS ;
}


NTSTATUS 
AcquirePrivilege( IN CONST ULONG ulPrivilege,
                  IN CONST BOOLEAN bEnable  
                )
/*++
  Routine description : This routine is used to set or reset a privilege
    on a process token.

  Arguments:
    ulPrivilege    - The privilege t enable or disable.
    bEnable        - TRUE to enable the priviliege, FALSE to disable.

  Return Value        : NTSTATUS
--*/
{
    NTSTATUS status;
    BOOLEAN  bPrevState;

    if ( bEnable ) {
        status = RtlAdjustPrivilege( ulPrivilege,
                                    TRUE,          // enable
                                    FALSE,         // adjust the process token
                                    &bPrevState
                                    );
    }
    else {
        status = RtlAdjustPrivilege( ulPrivilege,
                                    FALSE,          // disable
                                    FALSE,          // adjust the process token
                                    &bPrevState
                                    );
    }
    return status;
}

NTSTATUS 
EnumerateBootEntries( IN PVOID *ppEntryListHead)
/*++
  Routine description : This routine is used to  retrieve the list of boot entries.

  Arguments:
    ppEntryListHead    - The address of a pointer to a BOOT_ENTRY_LIST struct.


  Return Value        : NTSTATUS
--*/
{
    LONG    status          = STATUS_SUCCESS;
    DWORD   dwEntryListSize = 0x0001000;        // 4k
    BOOL    bNobreak        = TRUE;

    if ( !ppEntryListHead )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_ENUMERATE));
        return STATUS_INVALID_PARAMETER;
    }

    do  
    {

        *ppEntryListHead = (PBOOT_ENTRY_LIST) MEMALLOC(dwEntryListSize);

        if ( !*ppEntryListHead )
        {

            ShowMessage(stderr,GetResString(IDS_ERROR_ENUMERATE));
            status = STATUS_NO_MEMORY;
            bNobreak = FALSE;
            break;
        }

        status = NtEnumerateBootEntries(
                            (PVOID) *ppEntryListHead,
                            &dwEntryListSize
                            );

        if ( !NT_SUCCESS(status) )
        {

            if ( *ppEntryListHead ) {
                MEMFREE(*ppEntryListHead);
                *ppEntryListHead = NULL;
            }

            if ( STATUS_INSUFFICIENT_RESOURCES == status ) {
                dwEntryListSize += 0x0001000;
                continue;
            }
            else
            {

                ShowMessage(stderr,GetResString(IDS_ERROR_ENUMERATE));
                bNobreak = FALSE;
                break;
            }
        }
        else {
            break;
        }
    }while (TRUE==bNobreak);

    return status;
}


DWORD
GetDeviceInfo( IN LPTSTR szGUID,
               OUT LPTSTR szFinalStr,
               IN DWORD dwDriveNum,
               IN DWORD dwActuals)
/*++

  Routine description : This routine is used to  retrieve the list of boot entries.


  Arguments:
    [ in  ]      szGUID            : The address of a pointer to a BOOT_ENTRY_LIST struct.
    [ out ]      szFinalStr        : The String containing the final ARG signature path.
    [ in  ]      dwDriveNum        : Specifies the drive number
    [ in  ]      dwActuals         : Specifies

  Return Value        : DWORD
                        Returns EXIT_SUCCESS if it is successful,
                        returnS EXIT_FAILURE otherwise.
--*/
{
    HRESULT hr = S_OK;
    HANDLE hDevice  ;
    BOOL bResult = FALSE ;
    PPARTITION_INFORMATION_EX pInfo ;
    PDRIVE_LAYOUT_INFORMATION_EX Drive ;
    DWORD dwBytesCount = 0 ;

    TCHAR szDriveName[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwErrCode = 0 ;
    DWORD dwStructSize = 0 ;

    TCHAR szInstallPath[MAX_RES_STRING+1] = NULL_STRING;
    TCHAR szInstallPath1[MAX_RES_STRING*2] = NULL_STRING;
    TCHAR szWindowsDirectory[MAX_PATH*2] = NULL_STRING;
    TCHAR szMessage[MAX_RES_STRING+1] = NULL_STRING;
    PTCHAR pszTok = NULL ;
    PPARTITION_INFORMATION_GPT pGptPartition ;
    UUID MyGuid ;
    DWORD dwPartitionId = 0 ;
    BOOL bGuidFlag = FALSE ;
    BOOL bFoundFlag = TRUE ;
    DWORD dwReqdSize = 0 ;

    if ( UuidFromString(szGUID,&MyGuid) != RPC_S_OK )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_GUID));
        return EXIT_FAILURE ;
    }

    while(bFoundFlag == TRUE)
    {
        SecureZeroMemory(szDriveName, SIZE_OF_ARRAY(szDriveName));
        hr = StringCchPrintf(szDriveName, SIZE_OF_ARRAY(szDriveName), _T("\\\\.\\physicaldrive%d"), dwDriveNum );
        hDevice = CreateFile(szDriveName,
                   GENERIC_READ|GENERIC_WRITE,
                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                   NULL,
                   OPEN_EXISTING,
                   0,
                   NULL);

         if(hDevice == INVALID_HANDLE_VALUE)
        {
            dwErrCode = GetLastError();

            bFoundFlag =FALSE ;

            // Display ann error message and exit if the user has mentioned
            // any disk number.
            if ( dwActuals == 1)
            {
                ShowMessage(stderr,GetResString(IDS_INVALID_DISK) );
                return EXIT_FAILURE ;
            }
            else
            {
                break ;
            }
        }

         //increase the drive number.

        dwDriveNum++ ;
        //Drive = (PDRIVE_LAYOUT_INFORMATION_EX)malloc(sizeof(DRIVE_LAYOUT_INFORMATION_EX) +5000) ;

        dwReqdSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX)+ sizeof(PARTITION_INFORMATION)*50 ;

        Drive = (PDRIVE_LAYOUT_INFORMATION_EX)AllocateMemory(sizeof(DRIVE_LAYOUT_INFORMATION_EX) + sizeof(PARTITION_INFORMATION)*50) ;
        if(Drive == NULL)
        {
           ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
           CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

        dwStructSize = sizeof(DRIVE_LAYOUT_INFORMATION_EX) ;


        bResult = DeviceIoControl(
                                hDevice,
                                IOCTL_DISK_GET_DRIVE_LAYOUT_EX,
                                NULL,
                                0,
                                Drive,
                                dwReqdSize,
                                &dwBytesCount,
                                    NULL);

            //Drive = realloc(Drive,malloc(sizeof(DRIVE_LAYOUT_INFORMATION_EX) )+500 ) ;

        if(bResult ==0)
        {
            SAFEFREE(Drive);
            dwErrCode = GetLastError();
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

            //get a pointer to the PARTITION_INFORMATION_EX structure
            for(dwPartitionId = 0 ;dwPartitionId < Drive->PartitionCount ; dwPartitionId++)
            {

                //get a pointer to the corresponding partition.

                pInfo = (PPARTITION_INFORMATION_EX)(&Drive->PartitionEntry[dwPartitionId] ) ;


                //get a pointer to the PARTITION_INFORMATION_GPT structure.
                pGptPartition = AllocateMemory( sizeof( PARTITION_INFORMATION_GPT));

                if(pGptPartition == NULL)
                {
                     SAFEFREE(Drive);
                     ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                     CloseHandle(hDevice );
                     return EXIT_FAILURE ;
                }

                CopyMemory(pGptPartition,&pInfo->Gpt,sizeof(PARTITION_INFORMATION_GPT) );


                if( ( MyGuid.Data1 == pGptPartition->PartitionId.Data1 ) &&
                ( MyGuid.Data2 == pGptPartition->PartitionId.Data2 )
                && (MyGuid.Data3 == pGptPartition->PartitionId.Data3)
                && (MyGuid.Data4[0] == pGptPartition->PartitionId.Data4[0])
                && (MyGuid.Data4[1] == pGptPartition->PartitionId.Data4[1])
                && (MyGuid.Data4[2] == pGptPartition->PartitionId.Data4[2])
                &&(MyGuid.Data4[3] == pGptPartition->PartitionId.Data4[3])
                && (MyGuid.Data4[4]== pGptPartition->PartitionId.Data4[4] )
                && (MyGuid.Data4[5]== pGptPartition->PartitionId.Data4[5] )
                && (MyGuid.Data4[6]== pGptPartition->PartitionId.Data4[6] )
                && (MyGuid.Data4[7]== pGptPartition->PartitionId.Data4[7] ) )
                    {
                        SecureZeroMemory(szMessage, SIZE_OF_ARRAY(szMessage));
                        hr = StringCchPrintf(szMessage, SIZE_OF_ARRAY(szMessage),GetResString(IDS_GUID_FOUND),dwPartitionId+1);
                        bGuidFlag = TRUE ;
                        bFoundFlag =FALSE ;
                        goto out ;
                    }
            }
            CloseHandle(hDevice );
    }

        if(bGuidFlag == FALSE )
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            ShowMessage(stdout,GetResString(IDS_GUID_ABSENT));
            CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

out:   if( 0 == GetWindowsDirectory(szWindowsDirectory,MAX_PATH) )
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            ShowMessage(stderr,GetResString(IDS_ERROR_DRIVE));
            CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

        StringConcat(szWindowsDirectory,_T("*"), SIZE_OF_ARRAY(szWindowsDirectory));

        pszTok = _tcstok(szWindowsDirectory,_T("\\"));
        if(pszTok == NULL)
        {   SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            ShowMessage(stderr,GetResString(IDS_TOKEN_ABSENT));
            CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

        pszTok = _tcstok(NULL,_T("*"));
        if(pszTok == NULL)
        {
            SAFEFREE(Drive);
            SAFEFREE(pGptPartition);
            ShowMessage(stderr,GetResString(IDS_TOKEN_ABSENT));
            CloseHandle(hDevice );
            return EXIT_FAILURE ;
        }

        //prints the path into the string.
        hr = StringCchPrintf( szInstallPath, SIZE_OF_ARRAY(szInstallPath),
              ARC_SIGNATURE,
              pGptPartition->PartitionId.Data1,
              pGptPartition->PartitionId.Data2,
              pGptPartition->PartitionId.Data3,
              pGptPartition->PartitionId.Data4[0],
              pGptPartition->PartitionId.Data4[1],
              pGptPartition->PartitionId.Data4[2],
              pGptPartition->PartitionId.Data4[3],
              pGptPartition->PartitionId.Data4[4],
              pGptPartition->PartitionId.Data4[5],
              pGptPartition->PartitionId.Data4[6],
              pGptPartition->PartitionId.Data4[7],
              dwPartitionId + 1  ,
              pInfo->StartingOffset,
              pInfo->PartitionLength
              );
        
        SecureZeroMemory(szInstallPath1, SIZE_OF_ARRAY(szInstallPath1) );
        hr = StringCchPrintf( szInstallPath1, SIZE_OF_ARRAY(szInstallPath1), _T("%s\\%s"), szInstallPath, pszTok);
        StringCopy(szFinalStr,szInstallPath, MAX_RES_STRING+1 );

        SAFEFREE(Drive);
        SAFEFREE(pGptPartition);
        CloseHandle(hDevice );
        return EXIT_SUCCESS ;
}

 DWORD 
 ProcessListSwitch_IA64( IN DWORD argc, 
                         IN LPCTSTR argv[] 
                        )
/*++

  Routine description : This routine is used to  retrieve and display the list of boot entries.

  Arguments:
    argc              : command line arguments count.
    argv              :

  Return Value        : DWORD
                        Returns EXIT_SUCCESS if it is successful,
                        returns EXIT_FAILURE otherwise.
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bList  = FALSE;
    DWORD dwExitCode = ERROR_SUCCESS;

    DWORD dwList = 0 ;
    TCHAR szList[MAX_STRING_LENGTH] = NULL_STRING ;
    LPTSTR pszStopStr = NULL;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[3];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_LIST;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->pValue = &bList;

    //main option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwFlags = CP2_DEFAULT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szList;
    pcmdOption->dwLength = MAX_STRING_LENGTH;

     //id usage
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    // Parsing the copy option switches
    if ( !(DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_LIST_SYNTAX));
        return ( EXIT_FAILURE );
    }

     // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayListUsage_IA64() ;
        return (EXIT_SUCCESS);
    }

    TrimString(szList,TRIM_ALL);

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    //if empty value is specified
    if( cmdOptions[1].dwActuals != 0 && StringLength(szList,0) == 0 )
    {
        ShowMessage(stderr,GetResString(IDS_LIST_SYNTAX));
        return ( EXIT_FAILURE );
    }

    dwList = _tcstoul(szList,&pszStopStr, 10);
    if ( StringLengthW(pszStopStr,0) != 0 )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_LISTVALUE));
        return EXIT_FAILURE;
    }

    if(dwList > 0)
    {
        dwExitCode= ListDeviceInfo(dwList );
        return (dwExitCode);
    }
    else
    {
        dwList = 0 ;
        dwExitCode = ListDeviceInfo(dwList);
        return (dwExitCode);
    }
    return EXIT_SUCCESS ;
}

VOID
displayListUsage_IA64()
/*++
   Routine Description            : Display the help for the list option (IA64).
   Arguments                      :
                                  : NONE

   Return Type                    : VOID
--*/
{
    DWORD dwIndex = IDS_LIST_BEGIN_IA64 ;
    for(;dwIndex <=IDS_LIST_END_IA64 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID 
displayUpdateUsage_IA64()
/*++
   Routine Description            : Display the help for the update option (IA64).

   Arguments                      :
                                  : NONE

   Return Type                    : VOID
--*/
{
    DWORD dwIndex = IDS_UPDATE_BEGIN_IA64 ;
    for(;dwIndex <=IDS_UPDATE_END_IA64 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

 DWORD 
 ProcessUpdateSwitch_IA64( IN  DWORD argc, 
                           IN LPCTSTR argv[] 
                          )
/*++

  Routine Description : Allows the user to update the OS load options specifed
                       based on the  plex

  Arguments           :
    [ in ] argc             - Number of command line arguments
    [ in ] argv             - Array containing command line arguments

  Return Type        : DWORD
--*/
{

    BOOL bUsage = FALSE ;
    TCHAR szUpdate[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwList = 0 ;
    NTSTATUS status ;

    TCHAR szFinalStr[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szBrackets[] = _T("{}");

    PBOOT_ENTRY_LIST    pEntryListHead  = NULL;
    PBOOT_ENTRY         pTargetEntry    = NULL;
    DWORD dwActuals = 0 ;
    DWORD dwExitcode = 0 ;
    TCMDPARSER2 cmdOptions[2];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_UPDATE;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwFlags= CP2_VALUE_OPTIONAL;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szUpdate;
    pcmdOption->dwLength = MAX_STRING_LENGTH;
    
     //id usage
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    // Parsing the copy option switches
    if ( !(DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

         
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_UPDATE_SYNTAX));
        return ( EXIT_FAILURE );
    }


    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        displayUpdateUsage_IA64() ;
        return (EXIT_SUCCESS);
    }

    dwExitcode = InitializeEFI();
    if(EXIT_FAILURE == dwExitcode )
    {
        return EXIT_FAILURE ;
    }

    if(!bUsage && (StringLengthW(szUpdate,0) ==0) )
    {
        ShowMessage(stderr,GetResString(IDS_UPDATE_SYNTAX));
        return EXIT_FAILURE ;
    }


    if(StringLengthW(szUpdate,0) !=0)
    {

        //
        // Pass the GUID specified by the User
        // and convert that into the ARC signature Path.
        //

        //Trim the Leading and trailing brackets specified
        // by the user.
        StrTrim(szUpdate, szBrackets);
        
        //dwActuals = cmdOptions[2].dwActuals ;
        dwActuals  = 0 ;
        if (GetDeviceInfo(szUpdate,szFinalStr,dwList,dwActuals) == EXIT_FAILURE )
        {
            return EXIT_FAILURE ;

        }

        //acquire the necessary privilages for querying and manipulating the NV RAM.
        status = AcquirePrivilege( SE_SYSTEM_ENVIRONMENT_PRIVILEGE, TRUE );
        if ( !NT_SUCCESS(status) )
        {
            ShowMessage(stderr,GetResString(IDS_INSUFF_PRIV));
            return HRESULT_FROM_NT(status);
        }


        //Enumerate the list of Boot Entries in the NV Ram.
        status = EnumerateBootEntries( (PVOID *) &pEntryListHead );
        if ( !NT_SUCCESS(status) || !pEntryListHead )
        {
            if ( !pEntryListHead )
            {
                return EXIT_FAILURE ;
            }
        }

        //
        // Find The BootEntry corresponding to the ARC Signature path specified by the user.
        //
        //

        status = FindBootEntry( pEntryListHead,szFinalStr,&pTargetEntry);

        if ( !NT_SUCCESS(status) && STATUS_OBJECT_NAME_NOT_FOUND != status)
        {
            DISPLAY_MESSAGE(stderr,GetResString(IDS_FIND_FAIL) );
            return EXIT_FAILURE ;
        }

        
    }

    return EXIT_SUCCESS ;
}

DWORD 
GetBootPath(IN LPTSTR szValue,
            IN LPTSTR szResult
           )
/*++

   Routine Description            : retreive the information from registry

   Arguments                      :
      [ in ] Keyname : System name

   Return Type                    : DWORD
      ERROR_SUCCESS           :   if successful in retreiving information.
      ERROR_RETREIVE_REGISTRY :   if error occurs while retreving information.

--*/
{
  HKEY     hKey1 = 0;

  HKEY     hRemoteKey = 0;
  TCHAR    szPath[MAX_STRING_LENGTH + 1] = SUBKEY1 ;
  DWORD    dwValueSize = MAX_STRING_LENGTH + 1;
  DWORD    dwRetCode = ERROR_SUCCESS;
  DWORD    dwError = 0;
  TCHAR szTmpCompName[MAX_STRING_LENGTH+1] = NULL_STRING;

   DWORD dwLength = MAX_STRING_LENGTH ;
   LPTSTR szReturnValue = NULL ;
   DWORD dwCode =  0 ;

   szReturnValue = ( LPTSTR ) AllocateMemory( dwLength*sizeof( TCHAR ) );

   if(szReturnValue == NULL)
   {
        return ERROR_RETREIVE_REGISTRY ;
   }



  // Get Remote computer local machine key
  dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
  if (dwError == ERROR_SUCCESS)
  {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if (dwError == ERROR_SUCCESS)
     {
        dwRetCode = RegQueryValueEx(hKey1, szValue, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);

        if (dwRetCode == ERROR_MORE_DATA)
        {
            if ( szReturnValue != NULL )
            {
                FreeMemory((LPVOID *) &szReturnValue );
                szReturnValue = NULL;
            }

            szReturnValue    = ( LPTSTR ) AllocateMemory( dwValueSize*sizeof( TCHAR ) );
            if(szReturnValue == NULL)
            {
                RegCloseKey(hKey1);
                RegCloseKey(hRemoteKey);
                SAFEFREE(szReturnValue);
                return ERROR_RETREIVE_REGISTRY ;
            }
            dwRetCode = RegQueryValueEx(hKey1, szValue, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
        }
        if(dwRetCode != ERROR_SUCCESS)
        {
            RegCloseKey(hKey1);
            RegCloseKey(hRemoteKey);
            SAFEFREE(szReturnValue);
            return ERROR_RETREIVE_REGISTRY ;
        }
     }
     else
     {
        RegCloseKey(hRemoteKey);
        SAFEFREE(szReturnValue);
        return ERROR_RETREIVE_REGISTRY ;

     }

    RegCloseKey(hKey1);
  }
  else
  {
      RegCloseKey(hRemoteKey);
      SAFEFREE(szReturnValue);
      return ERROR_RETREIVE_REGISTRY ;
  }

  RegCloseKey(hRemoteKey);

 StringCopy(szResult,szReturnValue, MAX_RES_STRING+1);

  SAFEFREE(szReturnValue);
  return dwCode ;

}




NTSTATUS
LowGetPartitionInfo(
    IN HANDLE                       handle,
    OUT PARTITION_INFORMATION_EX    *partitionData
    )
/*++

Routine Description:

    This routine gets the partition information given a handle to a partition.

Arguments:

    handle          - A handle to the partition.
    partitionData   - Returns a partition information structure.

Return Value:

    Returns STATUS_SUCESS if successful, otherwise it returns the error code.


--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    IO_STATUS_BLOCK statusBlock;
    RtlZeroMemory( &statusBlock, sizeof(IO_STATUS_BLOCK) );

    if ( (NULL == partitionData)
        || (sizeof(*partitionData) < sizeof(PARTITION_INFORMATION_EX))
        || (NULL == handle)
        || (INVALID_HANDLE_VALUE == handle) ) 
    {                 
        return STATUS_INVALID_PARAMETER;
    }

    RtlZeroMemory( partitionData, sizeof(PARTITION_INFORMATION_EX) );

    status = NtDeviceIoControlFile(handle,
                                   0,
                                   NULL,
                                   NULL,
                                   &statusBlock,
                                   IOCTL_DISK_GET_PARTITION_INFO_EX,
                                   NULL,
                                   0,
                                   partitionData,
                                   sizeof(PARTITION_INFORMATION_EX)
                                   );
    return status;
}

LONG
DmCommonNtOpenFile(
    IN PWSTR     Name,
    IN ULONG   access,
    IN PHANDLE Handle

    )
/*++

Routine Description:

    This is a routine to handle open requests.

Arguments:

    Name - pointer to the NT name for the open.
    Handle - pointer for the handle returned.

Return Value:

    NT status

--*/
{
    OBJECT_ATTRIBUTES oa;
    NTSTATUS          status;
    IO_STATUS_BLOCK   statusBlock;
    UNICODE_STRING    unicodeName;
    int i = 0 ;

    status = RtlCreateUnicodeString(&unicodeName, Name);

    if (!NT_SUCCESS(status))
    {
        return status;
    }

    RtlZeroMemory(&statusBlock, sizeof(IO_STATUS_BLOCK));
    RtlZeroMemory(&oa, sizeof(OBJECT_ATTRIBUTES));
    oa.Length = sizeof(OBJECT_ATTRIBUTES);
    oa.ObjectName = &unicodeName;
    oa.Attributes = OBJ_CASE_INSENSITIVE;


    // If a sharing violation occurs,retry it for
    // max. 10 seconds
    for (i = 0; i < 5; i++)
    {
        status = NtOpenFile(Handle,
                        SYNCHRONIZE | access,
                        &oa,
                        &statusBlock,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        FILE_SYNCHRONOUS_IO_ALERT
                        );

        if (status == STATUS_SHARING_VIOLATION) {

            Sleep(2000);
        }
        else {
            break;
        }
    }

    RtlFreeUnicodeString(&unicodeName);
    return status;
}


DWORD 
AddMirrorPlex( IN LPTSTR szOsLoadPath , 
               IN LPTSTR szLoaderPath , 
               IN LPTSTR szValue ,
               IN BOOL bFlag,
               IN LPTSTR szFriendlyName
              )
/*++

Routine Description:

    This is a routine to Add a new mirror Entry

Arguments:


Return Value:

    DWORD.

--*/

{
   // local variables
    HRESULT hr = S_OK;
    BOOLEAN wasEnabled = TRUE;
    DWORD dwAlign = 0;
    DWORD dwError = 0;
    DWORD dwLength = 0;
    DWORD dwBootEntrySize = 0;
    DWORD dwBootFilePathSize = 0;
    DWORD dwOsLoadPathSize = 0;
    DWORD dwWindowsOptionsSize = 0;
    PBOOT_ENTRY pBootEntry = NULL;
    PWINDOWS_OS_OPTIONS pWindowsOptions = NULL;
    PFILE_PATH pBootFilePath = NULL;
    PFILE_PATH pOsLoadPath = NULL;
    ULONG* pdwIdsArray = NULL;
    ULONG ulId = 0;
    ULONG ulIdCount = 0;
    NTSTATUS status;
    TCHAR pwszBootFilePath[MAX_RES_STRING+1] = NULL_STRING;
    PFILE_PATH pFilePath = NULL;
    HANDLE hPart = INVALID_HANDLE_VALUE;
    GUID     guid;
    PARTITION_INFORMATION_EX PartitionInfo;
    TCHAR szBootPath[MAX_RES_STRING+1] = NULL_STRING;

    // enable the privilege that is necessary to query/set NVRAM.
    status = RtlAdjustPrivilege( SE_SYSTEM_ENVIRONMENT_PRIVILEGE, TRUE, FALSE, &wasEnabled );
    if ( !NT_SUCCESS( status ) )
    {
        dwError = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE( stderr, GetResString(IDS_INSUFF_PRIV));
        return EXIT_FAILURE;
    }



    //
    // open the system device
    //
    status = DmCommonNtOpenFile( szValue, GENERIC_READ, &hPart );

    if ( status || !hPart || INVALID_HANDLE_VALUE == hPart )
    {
        dwError = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ADD));
        return EXIT_FAILURE;
    }

    //
    // The structure is zero'ed in this call before retrieving the data.
    //
    status = LowGetPartitionInfo( hPart, &PartitionInfo );
    if ( status )
    {
        dwError = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_PARTITION_ERROR));
        return EXIT_FAILURE;
    }

    if ( PARTITION_STYLE_GPT != PartitionInfo.PartitionStyle )
    {
        dwError = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_PARTITION_STYLE));
        return EXIT_FAILURE;
    }

    //
    // Setup the OSLoader file path.
    //
    guid = PartitionInfo.Gpt.PartitionId;

    if (bFlag)
    {
        StringCopy(szBootPath,BOOTFILE_PATH, SIZE_OF_ARRAY(szBootPath));
    }
    else
    {
        StringCopy(szBootPath,BOOTFILE_PATH1, SIZE_OF_ARRAY(szBootPath) );
    }

    SecureZeroMemory(pwszBootFilePath, sizeof(pwszBootFilePath) );

    hr = StringCchPrintf( pwszBootFilePath, SIZE_OF_ARRAY(pwszBootFilePath)-1,
            szBootPath,
            guid.Data1,
            guid.Data2,
            guid.Data3,
            guid.Data4[0],  guid.Data4[1],  guid.Data4[2],  guid.Data4[3],
            guid.Data4[4],  guid.Data4[5],  guid.Data4[6],  guid.Data4[7],
            szLoaderPath);


    //
    // prepare the boot file path
    //
    //

    // determine the length of the BOOTFILE_PATH
    dwLength = StringLengthW( pwszBootFilePath,0) + 1;

    // now determine the memory size that needs to be allocated for FILE_PATH structure
    // and align up to the even memory bounday
    dwBootFilePathSize = FIELD_OFFSET( FILE_PATH, FilePath ) + (dwLength * sizeof( WCHAR ));

    // allocate the memory
    pBootFilePath = (PFILE_PATH) AllocateMemory( sizeof( BYTE )*dwBootFilePathSize );
    if ( NULL == pBootFilePath )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FAILURE;
    }

    // set the values now
    SecureZeroMemory( pBootFilePath, dwBootFilePathSize );            // double init
    pBootFilePath->Length = dwBootFilePathSize;
    pBootFilePath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;
    pBootFilePath->Version = FILE_PATH_VERSION;
    CopyMemory( pBootFilePath->FilePath, pwszBootFilePath, dwLength * sizeof( WCHAR ) );

    //
    // testing translating
    //
    pFilePath = (PFILE_PATH) AllocateMemory( sizeof( BYTE )* 1024 );

    if(NULL == pFilePath )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    ulId = 1024;
    status = NtTranslateFilePath( pBootFilePath, FILE_PATH_TYPE_NT, pFilePath, &ulId );
    if ( ! NT_SUCCESS( status ) )
    {
        dwError = RtlNtStatusToDosError( status );
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ADD));
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath );
        return EXIT_FAILURE;
    }

    //
    // determine the length of the OSLOAD PATH
    //

    dwLength = StringLengthW( szOsLoadPath,0 ) + 1;

    // now determine the memory size that needs to be allocated for FILE_PATH structure
    // and align up to the even memory bounday
    dwOsLoadPathSize = FIELD_OFFSET( FILE_PATH, FilePath ) + (dwLength * sizeof( WCHAR ));

    // allocate the memory
    pOsLoadPath = (PFILE_PATH) AllocateMemory( sizeof( BYTE )*dwOsLoadPathSize );
    if(pOsLoadPath == NULL)
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        DISPLAY_MESSAGE( stderr, ERROR_TAG);
        ShowLastError(stderr);
        return EXIT_FAILURE;
    }

    // set the values now
    SecureZeroMemory( pOsLoadPath, dwOsLoadPathSize );            // double init
    pOsLoadPath->Length = dwOsLoadPathSize;
    pOsLoadPath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;
    pOsLoadPath->Version = FILE_PATH_VERSION;


    CopyMemory( pOsLoadPath->FilePath, szOsLoadPath, dwLength * sizeof( WCHAR ) );

    //
    // windows os options
    //

    // determine the size needed
    dwLength = 1;                   // os load options is empty string
    dwWindowsOptionsSize = sizeof(WINDOWS_OS_OPTIONS) +
                           dwOsLoadPathSize + sizeof(DWORD);  // Need to align the FILE_PATH struct

    // allocate the memory
    pWindowsOptions = (PWINDOWS_OS_OPTIONS) AllocateMemory( dwWindowsOptionsSize*sizeof( BYTE ) );
    if(pWindowsOptions == NULL)
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FAILURE;
    }

    // set the values now
    SecureZeroMemory( pWindowsOptions, dwWindowsOptionsSize );                // double init
    CopyMemory( (BYTE*) pWindowsOptions->Signature, WINDOWS_OS_OPTIONS_SIGNATURE, sizeof(WINDOWS_OS_OPTIONS_SIGNATURE) );
    pWindowsOptions->Length = dwWindowsOptionsSize;
    pWindowsOptions->Version = WINDOWS_OS_OPTIONS_VERSION;
    pWindowsOptions->OsLoadPathOffset = sizeof( WINDOWS_OS_OPTIONS );

    //
    // Need to align the OsLoadPathOffset on a 4 byte boundary.
    //
    dwAlign = ( pWindowsOptions->OsLoadPathOffset & (sizeof(DWORD) - 1) );
    if ( dwAlign != 0 )
    {
        pWindowsOptions->OsLoadPathOffset += sizeof(DWORD) - dwAlign;
    }

    StringCopy(pWindowsOptions->OsLoadOptions, L"", StringLengthW(L"",0) );
    CopyMemory( ((BYTE*) pWindowsOptions) + pWindowsOptions->OsLoadPathOffset, pOsLoadPath, dwOsLoadPathSize );

    //
    // prepare the boot entry
    //

    // find the length of the friendly name
    dwLength = StringLengthW( szFriendlyName, 0  ) + 1;

    // determine the size of the structure
    dwBootEntrySize = FIELD_OFFSET( BOOT_ENTRY, OsOptions ) +
                      dwWindowsOptionsSize +
                      ( dwLength * sizeof( WCHAR ) ) +
                      dwBootFilePathSize +
                      + sizeof(WCHAR)         // Need to align the FriendlyName on WCHAR
                      + sizeof(DWORD);        // Need to align the BootFilePath on DWORD


    // allocate memory
    pBootEntry = (PBOOT_ENTRY) AllocateMemory( sizeof( BYTE )*dwBootEntrySize );
    if(pBootEntry == NULL)
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR|SLE_INTERNAL );
        return EXIT_FAILURE;
    }

    // set the values now
    SecureZeroMemory( pBootEntry, dwBootEntrySize );
    pBootEntry->Version = BOOT_ENTRY_VERSION;
    pBootEntry->Length = dwBootEntrySize;
    pBootEntry->Id = 0L;
    pBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_ACTIVE;

    pBootEntry->FriendlyNameOffset = FIELD_OFFSET(BOOT_ENTRY, OsOptions) + dwWindowsOptionsSize;

    //
    // Need to align the unicode string on a 2 byte boundary.
    //
    dwAlign = ( pBootEntry->FriendlyNameOffset & (sizeof(WCHAR) - 1) );
    if ( dwAlign != 0 )
    {
        pBootEntry->FriendlyNameOffset += sizeof(WCHAR) - dwAlign;
    }

    pBootEntry->BootFilePathOffset = pBootEntry->FriendlyNameOffset + ( dwLength * sizeof(WCHAR) );

    //
    // Need to align the FILE_PATH struct on a 4 byte boundary.
    //
    dwAlign = ( pBootEntry->BootFilePathOffset & (sizeof(DWORD) - 1) );
    if ( dwAlign != 0 )
    {
        pBootEntry->BootFilePathOffset += sizeof(DWORD) - dwAlign;
    }

    pBootEntry->OsOptionsLength = dwWindowsOptionsSize;

    CopyMemory( pBootEntry->OsOptions, pWindowsOptions, dwWindowsOptionsSize );
    CopyMemory( ((PBYTE) pBootEntry) + pBootEntry->FriendlyNameOffset, szFriendlyName, ( dwLength * sizeof(WCHAR) ) );
    CopyMemory( ((PBYTE) pBootEntry) + pBootEntry->BootFilePathOffset, pBootFilePath, dwBootFilePathSize );

    //
    // add the prepared boot entry
    //

    status = NtAddBootEntry( pBootEntry, &ulId );
    if ( ! NT_SUCCESS( status ) )
    {
        dwError = RtlNtStatusToDosError( status );
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        DISPLAY_MESSAGE(stderr,GetResString(IDS_ERROR_ADD));
        return EXIT_FAILURE;
    }
    else
    {
        DISPLAY_MESSAGE(stdout,GetResString(IDS_MIRROR_ADDED));
    }

    //
    // Add the entry to the boot order.
    //
    ulIdCount = 32L;
    pdwIdsArray = (PULONG) AllocateMemory(ulIdCount * sizeof(ULONG));
    if(!pdwIdsArray)
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        SAFEFREE( pBootEntry);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }
    status = NtQueryBootEntryOrder( pdwIdsArray, &ulIdCount );
    if (! NT_SUCCESS( status ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SET_BOOTENTRY));
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        SAFEFREE( pBootEntry);
        SAFEFREE( pdwIdsArray);
        return EXIT_SUCCESS ;
    }

    //
    // Need room in the buffer for the new entry.
    //
    if ( 31L < ulIdCount )
    {
        pdwIdsArray = (PULONG) AllocateMemory( (ulIdCount+1) * sizeof(ULONG));

        if(!pdwIdsArray)
        {
            SAFEFREE( pBootFilePath );
            SAFEFREE( pFilePath);
            SAFEFREE( pOsLoadPath);
            SAFEFREE( pWindowsOptions);
            SAFEFREE( pBootEntry);
            SAFEFREE( pdwIdsArray);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return EXIT_FAILURE;
        }

        status = NtQueryBootEntryOrder( pdwIdsArray, &ulIdCount );
    }

    if ( !NT_SUCCESS(status) )
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        SAFEFREE( pBootEntry);
        SAFEFREE( pdwIdsArray);
        dwError = RtlNtStatusToDosError( status );
        ShowMessage(stderr,GetResString(IDS_ERROR_ADD));
        return EXIT_FAILURE;
    }

    ulIdCount++;
    *(pdwIdsArray + (ulIdCount - 1)) = ulId;

    status = NtSetBootEntryOrder( pdwIdsArray, ulIdCount );

    if ( !NT_SUCCESS(status) )
    {
        SAFEFREE( pBootFilePath );
        SAFEFREE( pFilePath);
        SAFEFREE( pOsLoadPath);
        SAFEFREE( pWindowsOptions);
        SAFEFREE( pBootEntry);
        SAFEFREE( pdwIdsArray);
        dwError = RtlNtStatusToDosError( status );
        ShowMessage(stderr,GetResString(IDS_ERROR_ADD));
        return EXIT_FAILURE;
    }

    //
    // release the allocated memory
    //
    SAFEFREE( pBootFilePath );
    SAFEFREE( pFilePath);
    SAFEFREE( pOsLoadPath);
    SAFEFREE( pWindowsOptions);
    SAFEFREE( pBootEntry);
    SAFEFREE( pdwIdsArray);

    return EXIT_SUCCESS;
}


DWORD
 ConvertintoLocale( IN LPWSTR  szTempBuf,
                    OUT LPWSTR szOutputStr )
/*++

  Routine Description:

  Converts into Locale and Gets the Locale information

  Arguments:

    LPWSTR szTempBuf [in] -- Locale Information to get
    LPWSTR szOutputStr [out] -- Locale value corresponding to the given
          information

  Return Value:
      DWORD
--*/

{
    NUMBERFMT numberfmt;
    WCHAR   szGrouping[MAX_RES_STRING+1]      =   NULL_STRING;
    WCHAR   szDecimalSep[MAX_RES_STRING+1]    =   NULL_STRING;
    WCHAR   szThousandSep[MAX_RES_STRING+1]   =   NULL_STRING;
    WCHAR   szTemp[MAX_RES_STRING+1]          =   NULL_STRING;
    LPWSTR  szTemp1                         =   NULL;
    LPWSTR  pszStoppedString                =   NULL;
    DWORD   dwStatus                        =   0;
    DWORD   dwGrouping                      =   0;

    //make the fractional digits and leading zeros to nothing
    numberfmt.NumDigits = 0;
    numberfmt.LeadingZero = 0;


    //get the decimal seperate character
    if(GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SDECIMAL, szDecimalSep, SIZE_OF_ARRAY(szDecimalSep) ) == 0)
    {
        return EXIT_FAILURE;
    }
    numberfmt.lpDecimalSep = szDecimalSep;

    if(GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, szThousandSep, SIZE_OF_ARRAY(szThousandSep) ) == 0)
    {
        return EXIT_FAILURE;
    }

    numberfmt.lpThousandSep = szThousandSep;

    if(GetLocaleInfo( LOCALE_USER_DEFAULT, LOCALE_SGROUPING, szGrouping, SIZE_OF_ARRAY(szGrouping) ) == 0)
    {
        return EXIT_FAILURE;
    }

    szTemp1 = wcstok( szGrouping, L";");
    do
    {
        StringConcat( szTemp, szTemp1, SIZE_OF_ARRAY(szTemp));
        szTemp1 = wcstok( NULL, L";" );
    }while( szTemp1 != NULL && StringCompare( szTemp1, L"0", TRUE, 0) != 0);

    dwGrouping = wcstol( szTemp, &pszStoppedString, 10);
    numberfmt.Grouping = (UINT)dwGrouping ;

    numberfmt.NegativeOrder = 2;

    dwStatus = GetNumberFormat( LOCALE_USER_DEFAULT, 0, szTempBuf, &numberfmt, szOutputStr, MAX_RES_STRING+1);

    return(EXIT_SUCCESS);
}



void Freelist()
/*++
  Routine Description : Function used to free the global linked list

  Arguments:

  Return Type    :
--*/
{
    PLIST_ENTRY listEntry;
    PLIST_ENTRY listEntry1;
    PMY_BOOT_ENTRY bootEntry;

    listEntry = BootEntries.Flink;
    while(  listEntry != &BootEntries)
    {
        listEntry1 = listEntry;
        bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
        RemoveEntryList( &bootEntry->ListEntry );
        listEntry = listEntry->Flink;
        if( listEntry1 != NULL )
        {
           FreeMemory((LPVOID *) &listEntry1 );
        }
    }
}

PWSTR GetDefaultBootEntry()
/*++
  Routine Description : 
                   Gets the default Boot entry.

  Arguments           : 

  Return Type     : PWSTR
                    Returns the first entry in the list.
--*/
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY bootEntry;
    PWSTR NtFilePath=NULL;

    listEntry = BootEntries.Flink;
    bootEntry = CONTAINING_RECORD( listEntry, MY_BOOT_ENTRY, ListEntry );
    NtFilePath = GetNtNameForFilePath(bootEntry->OsFilePath);
    return (NtFilePath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\bootcfg.c ===
/******************************************************************************

    Copyright(c) Microsoft Corporation

    Module Name:

        BootCfg.cpp

    Abstract:

        This file is intended to have the functionality for
        configuring, displaying, changing and deleting boot.ini
        settings for the local host or a remote system.

    Author:

        J.S.Vasu  17/1/2001

    Revision History:

        J.S.Vasu            17/1/2001            Localisation,function headers

        SanthoshM.B         10/2/2001           Added 64 bit functionality Code.

        J.S.Vasu            15/2/2001           Added the functionality of 32 bit and 64 bit acc to the DCR's.

        J.S.Vasu            5/10/2001           Fixed some RAID bugs.

        J.S.Vasu            26/11/2001          Fixed some Raid Bugs.
******************************************************************************/



// Include files

#include "pch.h"
#include "resource.h"
#include "BootCfg.h"
#include "BootCfg64.h"
#include <strsafe.h>

DWORD ProcessCloneSwitch_IA64(DWORD argc, LPCWSTR argv[] );

DWORD _cdecl _tmain( DWORD argc, LPCTSTR argv[] )
/*++
  Routine description : Main function which calls all the other main functions depending on
                        the option specified by the user.

  Arguments:
        [in] argc     : argument count specified at the command prompt.
        [in] argv     : arguments specified at the command prompt.

  Return Value        : DWORD
         0            : If the utility successfully performs the specified operation.
         1            : If the utility is unsuccessful in performing the specified operation.
--*/
{
    // Declaring the main option switches as boolean values
    BOOL bUsage  =  FALSE ;
    BOOL bCopy   =  FALSE ;
    BOOL bQuery  =  FALSE ;
    BOOL bDelete =  FALSE ;
    BOOL bRawString = FALSE ;
    DWORD dwExitcode = ERROR_SUCCESS;
    BOOL bTimeOut = FALSE ;
    BOOL bDefault = FALSE ;
    BOOL bDebug = FALSE ;
    BOOL bEms = FALSE ;
    BOOL bAddSw = FALSE ;
    BOOL bRmSw = FALSE ;
    BOOL bDbg1394 = FALSE ;
    BOOL bMirror = FALSE ;
    BOOL bList = FALSE ;
    BOOL bUpdate = FALSE ;
	BOOL bClone = FALSE ;
	DWORD result =0;
    TCHAR szServer[MAX_RES_STRING+1] = NULL_STRING ;

    if( 1 == argc )
    {
		
        #ifndef _WIN64
                if( FALSE == IsUserAdmin() )
                 {
                    ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
                    ReleaseGlobals();
                    return EXIT_FAILURE;
                 }
				
				dwExitcode  = QueryBootIniSettings( argc, argv );
        #else
            if( FALSE == IsUserAdmin() )
             {
                ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_64 ));
                ReleaseGlobals();
                return EXIT_FAILURE;
             }
            dwExitcode  = QueryBootIniSettings_IA64( argc, argv );
        #endif
        ReleaseGlobals();
        return dwExitcode;
    }

	

    // Call the preProcessOptions function to find out the option selected by the user
    dwExitcode = preProcessOptions( argc, argv, &bUsage, &bCopy, &bQuery, &bDelete,&bRawString,&bDefault,&bTimeOut,&bDebug,&bEms,&bAddSw,&bRmSw,&bDbg1394,&bMirror,&bList,&bUpdate,&bClone);
    if(dwExitcode == EXIT_FAILURE)
    {
        ReleaseGlobals();
        return dwExitcode;
    }

//check out for non administrative user
#ifndef _WIN64
/*
     if( FALSE == IsUserAdmin() )
     {
        ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
        ReleaseGlobals();
        return EXIT_FAILURE;
     }
*/
#else
/*     if( FALSE == IsUserAdmin() )
     {
        ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_64 ));
        ReleaseGlobals();
        return EXIT_FAILURE;
     }
*/
#endif

    // If BootIni.exe /?
if( ( bUsage ==TRUE)&& ( bCopy==FALSE )&& (bQuery==FALSE)&&(bDelete==FALSE)&&(bRawString ==FALSE)
     &&(bDefault==FALSE)&&(bTimeOut==FALSE) && (bDebug==FALSE)&& (bEms==FALSE)&&(bAddSw==FALSE)
     &&(bRmSw==FALSE)&&( bDbg1394==FALSE )&&(bMirror== FALSE) && (bList==FALSE)&&(bUpdate == FALSE)&&(bClone==FALSE) )
{
#ifndef _WIN64
/*    
    //check whether he is administrator or not
    if( !IsUserAdmin() )
    {
        ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
        ReleaseGlobals();
        return EXIT_FAILURE;
    }
*/
       dwExitcode = displayMainUsage_X86();
#else
        displayMainUsage_IA64();
        ReleaseGlobals();
        return EXIT_SUCCESS ;
#endif
}

    if(bRawString)
    {
#ifndef _WIN64
        dwExitcode = AppendRawString(argc,argv);
#else
        dwExitcode = RawStringOsOptions_IA64(argc,argv);
#endif
    ReleaseGlobals();
    return dwExitcode;
    }

    // If BootIni.exe -copy option is selected
    if( bCopy )
    {
#ifndef _WIN64

        dwExitcode = CopyBootIniSettings( argc, argv );
#else
        dwExitcode = CopyBootIniSettings_IA64( argc, argv);
#endif
    }

    // If BootIni.exe -delete option is selected
    if( bDelete )
    {
#ifndef _WIN64
        dwExitcode  = DeleteBootIniSettings( argc, argv );
#else
        dwExitcode  = DeleteBootIniSettings_IA64( argc, argv );
#endif
    }

    // If BootIni.exe -query option is selected
    if( bQuery )
    {
#ifndef _WIN64
        dwExitcode  = QueryBootIniSettings( argc, argv );
#else
        dwExitcode  = QueryBootIniSettings_IA64( argc, argv );
#endif
    }

    if(bTimeOut)
    {
#ifndef _WIN64
            dwExitcode = ChangeTimeOut(argc,argv);
#else
            dwExitcode = ChangeTimeOut_IA64(argc,argv);
#endif
    }

    if(bDefault)
    {
#ifndef _WIN64
        dwExitcode = ChangeDefaultOs(argc,argv);
#else
        dwExitcode = ChangeDefaultBootEntry_IA64(argc,argv);
#endif
    }


    if(bDebug )
    {
#ifndef _WIN64
            dwExitcode = ProcessDebugSwitch(  argc, argv );
#else
            dwExitcode = ProcessDebugSwitch_IA64(argc,argv);
#endif
    }

    if(bEms )
    {
#ifndef _WIN64
            dwExitcode = ProcessEmsSwitch(  argc, argv );
#else
            dwExitcode = ProcessEmsSwitch_IA64(argc,argv);
#endif
    }

    if(bAddSw )
    {
#ifndef _WIN64
            dwExitcode = ProcessAddSwSwitch(  argc, argv );
#else
           dwExitcode = ProcessAddSwSwitch_IA64(argc,argv);
#endif
    }

    if(bRmSw )
    {
#ifndef _WIN64
            dwExitcode = ProcessRmSwSwitch(  argc,  argv );
#else
            dwExitcode = ProcessRmSwSwitch_IA64(  argc,  argv );
#endif
    }

    if (bDbg1394 )
    {
#ifndef _WIN64
            dwExitcode = ProcessDbg1394Switch(argc,argv);
#else
            dwExitcode = ProcessDbg1394Switch_IA64(argc,argv);
#endif
    }

    if(bMirror)
    {
#ifdef _WIN64
        dwExitcode = ProcessMirrorSwitch_IA64(argc,argv);
#else
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        dwExitcode = EXIT_FAILURE;
#endif
    }

    if(bList)
    {
#ifdef _WIN64
        dwExitcode = ProcessListSwitch_IA64(argc,argv);
#else
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        dwExitcode = EXIT_FAILURE;
#endif
    }

    if(bUpdate)
    {
#ifdef _WIN64
        dwExitcode = ProcessUpdateSwitch_IA64(argc,argv);
#else
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        dwExitcode = EXIT_FAILURE;
#endif
    }

    if(bClone == TRUE )
    {
#ifdef _WIN64
        dwExitcode = ProcessCloneSwitch_IA64(argc,argv);
#else
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        dwExitcode = EXIT_FAILURE;
#endif
    }
	

    // exit with the appropriate return value if there is no problem
    ReleaseGlobals();
    return dwExitcode;
}


DWORD 
preProcessOptions( IN  DWORD argc, 
                   IN  LPCTSTR argv[],
                   OUT PBOOL pbUsage,
                   OUT PBOOL pbCopy,
                   OUT PBOOL pbQuery,
                   OUT PBOOL pbDelete,
                   OUT  PBOOL pbRawString,
                   OUT PBOOL pbDefault,
                   OUT PBOOL pbTimeOut,
                   OUT PBOOL pbDebug,
                   OUT PBOOL pbEms,
                   OUT PBOOL pbAddSw,
                   OUT PBOOL pbRmSw,
                   OUT PBOOL pbDbg1394 ,
                   OUT PBOOL pbMirror  ,
                   OUT PBOOL pbList ,
                   OUT PBOOL pbUpdate,
                   OUT PBOOL pbClone
                  )
/*++
  Routine Description : This function process the command line arguments passed
                        to the utility.

  Arguments:
       [ in  ]  argc         : Number of command line arguments
       [ in  ]  argv         : Array containing command line arguments
       [ out ]  pbUsage      : Pointer to boolean variable which will indicate
                               whether usage option is specified by the user.
       [ out ]  pbCopy       : Pointer to boolean variable which will indicate
                               whether copy option is specified by the user.
       [ out ]  pbQuery      : Pointer to boolean variable which will indicate
                               whether query option is specified by the user.
       [ out ]  pbChange     : Pointer to boolean variable which will indicate
                               whether change option is specified by the user.
       [ out ]  pbDelete     : Pointer to boolean variable which will indicate
                               whether delete option is specified by the user.
       [ out ]  pbRawString  : Pointer to the boolean indicating whether raw option
                               is specified by the user.
       [ out ]  pbDefault    : Pointer to the boolean indicating whether default option
                               is specified by the user.
       [ out ]  pbTimeOut    : Pointer to the boolean indicating whether timeout option
                               is specified by the user.
       [ out ]  pbDebug      : Pointer to the boolean indicating whether debug option
                               is specified by the user.
       [ out ]  pbEms        : Pointer to the boolean indicating whether ems option
                               is specified by the user.
       [ out ]  pbAddSw      : Pointer to the boolean indicating whether Addsw option
                               is specified by the user.
       [ out ]  pbRmSw       : Pointer to the boolean indicating whether rmsw option
                               is specified by the user.
       [ out ]  pbDbg1394    : Pointer to the boolean indicating whether dbg1394 option
                               is specified by the user.
       [ out ]  pbMirror     : Pointer to the boolean indicating whether mirror option
                               is specified by the user.

  Return Type    : Bool
      A Bool value indicating EXIT_SUCCESS on success else
      EXIT_FAILURE on failure

-*/
{
    // Initialise a boolean variable bOthers to find out whether switches other
    // than the main swithces are selected by the user
    DWORD dwCount                   = 0;
    DWORD dwi                       = 0;
    TARRAY arrTemp                  = NULL;
    TCMDPARSER2 cmdOptions[17];
    PTCMDPARSER2 pcmdOption;
    BOOL bStatus = FALSE;
//    BOOL bOthers = FALSE;

       
    arrTemp = CreateDynamicArray();
    if( NULL == arrTemp )
    {
        SetLastError(E_OUTOFMEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return EXIT_FAILURE;
    }

    // Populate the TCMDPARSER structure and pass the structure to the DoParseParam
    // function. DoParseParam function populates the corresponding variables depending
    // upon the command line input.
    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_COPY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbCopy;

    //query option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_QUERY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbQuery;

    //delete option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DELETE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbDelete;

    //usage option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbUsage;

    //raw option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RAW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbRawString;

    //default os option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULTOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbDefault;

    // timeout option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_TIMEOUT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbTimeOut;

    //debug option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEBUG;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbDebug;

    //ems option
    pcmdOption = &cmdOptions[8];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_EMS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbEms;

    //addsw option
    pcmdOption = &cmdOptions[9];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_ADDSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbAddSw;

    //rmsw option
    pcmdOption = &cmdOptions[10];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RMSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbRmSw;

    //dbg1394 option
    pcmdOption = &cmdOptions[11];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DBG1394;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbDbg1394;

    //mirror option
    pcmdOption = &cmdOptions[12];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_MIRROR;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbMirror;

    //list option
    pcmdOption = &cmdOptions[13];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_LIST;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbList;

    //update option
    pcmdOption = &cmdOptions[14];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_UPDATE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbUpdate;

	pcmdOption = &cmdOptions[14];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_UPDATE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbUpdate;

    //clone
    pcmdOption = &cmdOptions[15];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_CLONE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = pbClone ;

   //other options
    pcmdOption = &cmdOptions[16];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MODE_ARRAY;
    pcmdOption->pValue = &arrTemp;

    
	// If there is an error while parsing, display "Invalid Syntax"
    // If more than one main option is selected, then display error message
    // If usage is specified for sub-options
    // If none of the options are specified
    bStatus = DoParseParam2( argc, argv, -1, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 );
    if ( !bStatus  )
    {
        //ignore this error because a user might have specified main option and sub option
        //which gets FALSE by this function, do the validation here to determine
        //whether user has entered correct option or not
        //if bUsage is specified but error occurs means user entered some junk 
        DestroyDynamicArray( &arrTemp);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL);
        return EXIT_FAILURE ;
    }
    
    DestroyDynamicArray( &arrTemp);

    //checking if the user has entered more than 1 option.
     if (*pbCopy)
     {
        dwCount++ ;
     }

     if (*pbQuery)
     {
        dwCount++ ;
     }

     if (*pbDelete)
     {
        dwCount++ ;
     }

     if (*pbRawString)
     {
        dwCount++ ;

        // Check if any of the other valid switches have been
        // given as an input to the raw string
           if( *pbTimeOut  || *pbDebug   || *pbAddSw
            ||*pbRmSw   || *pbDbg1394 || *pbEms
            ||*pbDelete || *pbCopy  || *pbQuery
            ||*pbDefault || *pbMirror || *pbList || *pbUpdate || *pbClone)
        {
            // Check wether the usage switch has been entered
            if( *pbUsage )
            {
                ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
                return ( EXIT_FAILURE );
            }

            // Check if the other option is specified after the
            // 'raw' option
            for( dwi = 0; dwi < argc; dwi++ )
            {
                if( StringCompare( argv[ dwi ], OPTION_RAW, TRUE, 0 ) == 0 )
                {
                    if( (dwi+1) == argc )
                    {
                        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
                        return ( EXIT_FAILURE );
                    }
                    else if( argv[dwi + 1][0] != _T( '\"' ) )
                    {
                        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
                        return ( EXIT_FAILURE );
                    }
                }
            }
            dwCount--;
        }
    }

     if (*pbDefault)
     {
        dwCount++ ;
     }

     if (*pbTimeOut)
     {
       dwCount++ ;
     }

     if (*pbDebug)
     {
        dwCount++ ;
     }

     if(*pbAddSw)
     {
        dwCount++ ;
     }

     if(*pbRmSw)
     {
        dwCount++ ;
     }

     if(*pbDbg1394)
     {
        dwCount++ ;
     }

     if(*pbEms)
     {
        dwCount++ ;
     }

     if(*pbMirror)
     {
        dwCount++ ;
     }

      if(*pbList)
     {
        dwCount++ ;
     }

     if(*pbUpdate)
     {
        dwCount++ ;
     }

     if(*pbClone)
     {
        dwCount++ ;
     }


    //display an  error message if the user enters more than 1 main option
    //display an  error message if the user enters  1 main option along with other junk
    //display an  error message if the user does not enter any main option
    if( (  ( dwCount > 1 ) ) ||
        ( (*pbUsage) && !bStatus ) ||
        ( !(*pbCopy) && !(*pbQuery) && !(*pbDelete) && !(*pbUsage) && !(*pbRawString)&& !(*pbDefault)&&!(*pbTimeOut)&&!(*pbDebug)&& !( *pbEms)&& !(*pbAddSw)&& !(*pbRmSw)&& !(*pbDbg1394)&& !(*pbMirror) &&!(*pbUpdate) && !(*pbList)&& !(*pbClone) ) )
    {
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        return ( EXIT_FAILURE );
    }

    //if usage is specified with some junk
    if( *pbUsage && dwCount <=0 && argc >= 3 )
    {
        ShowMessage(stderr,GetResString(IDS_MAIN_USAGE));
        return ( EXIT_FAILURE );
    }

    return ( EXIT_SUCCESS );
}

DWORD
CopyBootIniSettings( 
                    IN DWORD argc, 
                    IN LPCTSTR argv[] 
                    )
/*++
    Routine Description:
         This routine is to make another OS instance copy for which you
         can add switches.

    Arguments:
    [in] argc               : Number of command line arguments
    [in] argv               : Array containing command line arguments

    Return Value :
        DWORD
--*/
{
    HRESULT hr = S_OK;
    BOOL bCopy                                  = FALSE ;
    BOOL bUsage                                 = FALSE;
    FILE *stream                                = NULL;
    TARRAY arr                                  = NULL;
    BOOL bRes                                   = FALSE ;
    WCHAR szPath[MAX_STRING_LENGTH]             = NULL_STRING;
    TCHAR szTmpPath[MAX_RES_STRING+1]             = NULL_STRING ;
    DWORD dwNumKeys                             = 0;
    BOOL bNeedPwd                               = FALSE;
    BOOL bFlag                                  = FALSE;
    WCHAR *szServer                             = NULL;
    WCHAR *szUser                               = NULL;
    WCHAR szPassword[MAX_RES_STRING+1]            = NULL_STRING;
    WCHAR szDescription[FRIENDLY_NAME_LENGTH]   = NULL_STRING;
    DWORD dwDefault                             = 0;
    DWORD dwLength                              = MAX_STRING_LENGTH1 ;
    LPCTSTR szToken                             = NULL ;
    DWORD dwRetVal                              = 0 ;
    BOOL bConnFlag                              = FALSE ;
    TCHAR szFriendlyName[255]                   = NULL_STRING ;
    LPCWSTR pwsz                                = NULL ;
    TCHAR newInstance[255]                      = NULL_STRING ;
    LPTSTR pszKey1                              = NULL ;
    LPWSTR szPathOld                            = NULL;
    LPWSTR szFriendlyNameOld                    = NULL;
    LPWSTR szOsOptionsOld                       = NULL;
    TCHAR szTempBuf[MAX_RES_STRING+1]             = NULL_STRING ;
    LPWSTR  szFinalstr                          = NULL;
    TCMDPARSER2 cmdOptions[7];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions,  SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_COPY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bCopy;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;
    
    //description option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_DESCRIPTION ;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_VALUE_TRIMINPUT;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDescription;
    pcmdOption->dwLength= FRIENDLY_NAME_LENGTH;

    //id usage
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;
    
    //default option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY ;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

    SecureZeroMemory(szFriendlyName, sizeof( szFriendlyName) );

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_COPY_USAGE));
        return ( EXIT_FAILURE );
    }

  
    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        return EXIT_FAILURE ;
    }

    //display error message if the user enters password without entering username
    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        return EXIT_FAILURE ;
    }


   //if usage is specified
    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
        displayCopyUsage_X86();
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_SUCCESS) ;
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }
    

    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }


    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, SIZE_OF_ARRAY_IN_CHARS(szServer));
        }
    }

    //display warning message if local credentils are supplied
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }
    
    //open the file pointer
    // of the boot.ini file if there is no error while establishing connection
    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Getting the keys of the Operating system section in the boot.ini file
    arr = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arr == NULL)
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    StringCopy(szTmpPath,szPath, SIZE_OF_ARRAY(szTmpPath));

    // Getting the total number of keys in the operating systems section
    dwNumKeys = DynArrayGetCount(arr);

    if((dwNumKeys >= MAX_BOOTID_VAL) )
    {
        ShowMessage(stderr,GetResString(IDS_MAX_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Displaying error message if the number of keys is less than the OS entry
    // line number specified by the user
    if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Getting the key of the OS entry specified by the user
    if(arr != NULL)
    {
        pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
        pszKey1 = (LPWSTR)AllocateMemory((StringLength(pwsz, 0)+2)*sizeof(WCHAR) );
        if(pszKey1 == NULL)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        StringCopy( pszKey1, pwsz, SIZE_OF_ARRAY_IN_CHARS(pszKey1) );

        //divide this for friendly name and boot options
        szPathOld = (LPWSTR)pszKey1;

        szFriendlyNameOld = wcschr( pszKey1, L'=');
        szFriendlyNameOld[0]=L'\0';
        szFriendlyNameOld++;

        szOsOptionsOld = wcsrchr( szFriendlyNameOld, L'"');
        szOsOptionsOld++;
        if(StringLengthW(szOsOptionsOld, 0) != 0)
        {
            //szOsOptionsOld++;
            szOsOptionsOld[0]=L'\0';
            szOsOptionsOld++;
        }

        dwLength = StringLength(pszKey1, 0)+StringLength(szFriendlyNameOld,0)+StringLength(szOsOptionsOld,0)+1;
    }
    else
    {
        resetFileAttrib(szPath);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage( stderr, ERROR_TAG);
        ShowLastError(stderr);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arr);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
     }

    // Copying the description specified by the user as the value of the new key.
    if(( cmdOptions[4].dwActuals  == 0) )
    {
        
		TrimString2(szFriendlyNameOld, L"\"", TRIM_ALL);
        if( StringLengthW(szFriendlyNameOld,0) > 59 )
        {
            StringCopy( szTempBuf, szFriendlyNameOld,59 ); //67
            hr = StringCchPrintf(szFriendlyName,SIZE_OF_ARRAY(szFriendlyName),L"\"%s%s\"", GetResString(IDS_COPY_OF), szTempBuf);
        }
        else
        {
            hr = StringCchPrintf(szFriendlyName, SIZE_OF_ARRAY(szFriendlyName),L"\"%s%s\"", GetResString(IDS_COPY_OF), szFriendlyNameOld);
        }

        dwLength = StringLengthW(szPathOld, 0)+StringLengthW(szFriendlyName,0)+StringLengthW(szOsOptionsOld,0)+1;
        //End of Changes

        //check if total length is exceeded max length of entry
        if( dwLength > MAX_RES_STRING ) 
        {
            ShowMessage( stderr,GetResString(IDS_STRING_TOO_LONG));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SAFEFREE(pszKey1);
            DestroyDynamicArray(&arr);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
    }
    else
    {
        //check if total length is exceeded max length of entry
        if( dwLength-StringLengthW(szFriendlyNameOld, 0)+StringLengthW(szDescription, 0) > MAX_RES_STRING )
        {
            ShowMessage( stderr,GetResString(IDS_STRING_TOO_LONG));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SAFEFREE(pszKey1);
            DestroyDynamicArray(&arr);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        StringCopy( szFriendlyName, TOKEN_SINGLEQUOTE, SIZE_OF_ARRAY(szFriendlyName) );
        
        TrimString( szDescription, TRIM_ALL );
        if( (StringLength(szDescription, 0) != 0)  ) //||lstrcmp(szDescription,L" "))
        {   
            StringConcat( szFriendlyName, szDescription, SIZE_OF_ARRAY(szFriendlyName) ); 
        }
        StringConcat( szFriendlyName, TOKEN_SINGLEQUOTE, SIZE_OF_ARRAY(szFriendlyName) );
    }

    StringCopy( newInstance, szPathOld, SIZE_OF_ARRAY(newInstance) );
    StringConcat( newInstance, TOKEN_EQUAL, SIZE_OF_ARRAY(newInstance));
    StringConcat( newInstance, szFriendlyName, SIZE_OF_ARRAY(newInstance));
    StringConcat( newInstance, L" ", SIZE_OF_ARRAY(newInstance));
    StringConcat( newInstance, szOsOptionsOld, SIZE_OF_ARRAY(newInstance) );

    //not needed any more
    SAFEFREE(pszKey1);

    DynArrayAppendString( arr, newInstance, StringLengthW(newInstance, 0) );
    if( EXIT_FAILURE == stringFromDynamicArray2(arr, &szFinalstr ) )
    {
        bRes = resetFileAttrib(szPath);
        SAFEFREE(szFinalstr);
        DestroyDynamicArray(&arr);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return(EXIT_FAILURE);
    }

    // Writing to the profile section with new key-value pair
    if( WritePrivateProfileSection(OS_FIELD, szFinalstr, szTmpPath) != 0 )
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_COPY_SUCCESS),dwDefault);
        bRes = resetFileAttrib(szPath);
        SAFEFREE(szFinalstr);
        DestroyDynamicArray(&arr);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return(bRes);
    }
    else
    {
        ShowMessage(stderr,GetResString(IDS_COPY_OS));
        resetFileAttrib(szPath);
        SAFEFREE(szFinalstr);
        DestroyDynamicArray(&arr);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return (EXIT_FAILURE);
    }

    // Closing the opened boot.ini file handl
    SAFECLOSE(stream);
    bRes = resetFileAttrib(szPath);
    SAFEFREE(szFinalstr);
    DestroyDynamicArray(&arr);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes);
}

DWORD 
DeleteBootIniSettings(  IN DWORD argc, 
                        IN LPCTSTR argv[] 
                     )
/*++
    Routine Description:
      This routine is to delete an OS entry from the Operating systems
      section of Boot.ini file in the specified machine.

    Arguments:
    [in] argc                : Number of command line arguments
    [in] argv                : Array containing command line arguments

    Return Value :
        DWORD
--*/
{
    TARRAY arrKeyValue                          = NULL;
    TARRAY arrBootIni                           = NULL;
    BOOL bDelete                                = FALSE ;
    BOOL bUsage                                 = FALSE;
    BOOL bRes                                   = FALSE ;
    DWORD dwInitialCount                        = 0;
    LPTSTR szFinalStr                           = NULL_STRING;
    WCHAR szPath[MAX_RES_STRING]               = NULL_STRING ;
    FILE *stream                                = NULL;
    BOOL bNeedPwd                               = FALSE ;
    BOOL bFlag                                  = FALSE ;
    LPWSTR  szTemp                              = NULL;
    WCHAR *szServer                             = NULL;
    WCHAR *szUser                               = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]         = NULL_STRING;
    DWORD dwDefault                             = 0;
    LPCTSTR szToken                             = NULL ;
    DWORD dwRetVal                              = 0 ;
    BOOL bConnFlag                              = FALSE ;
    DWORD dwI                                   = 0 ;
    TCHAR szRedirectBaudrate[MAX_RES_STRING+1]    = NULL_STRING ;
    TCHAR  szBoot[MAX_RES_STRING+1]               = NULL_STRING ;
    DWORD dwSectionFlag                         = 0 ;
    LPWSTR  pToken                              = NULL;
    BOOL bRedirect                              = FALSE;
    LPWSTR  szARCPath                           = NULL;

    // Builiding the TCMDPARSER structure
    TCMDPARSER2 cmdOptions[6];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DELETE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDelete;

    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

    // Parsing the delete option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );
    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_DELETE_USAGE));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLength(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }


   //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        SetReason(GetResString(IDS_USER_BUT_NOMACHINE));
        ShowMessage(stderr,GetReason());

        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        SetReason(GetResString(IDS_PASSWD_BUT_NOUSER));
        ShowMessage(stderr,GetReason());
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //if usage is specified
    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
        displayDeleteUsage_X86();
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_SUCCESS) ;
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    //
    //for setting the bNeedPwd
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }
    
    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                return (EXIT_FAILURE);
            }
            else
            {
                StringCopy(szServer,szToken, MAX_RES_STRING);
            }
        }
    }

    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser,0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection
    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag );
    if(bFlag == EXIT_FAILURE)
    {
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Getting all the key-value pairs of the operating system into a dynamic
    // array for manipulation.
    arrKeyValue = getKeyValueOfINISection( szPath, OS_FIELD);
    if(arrKeyValue == NULL)
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Getting the total no: of key-value pairs in the operating system section.
    dwInitialCount = DynArrayGetCount(arrKeyValue);

    // Checking whether the given OS entry is valid or not. If the OS entry given
    // is greater than the number of keys present, then display an error message
    if( ( dwDefault <= 0 ) || ( dwDefault > dwInitialCount ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrKeyValue);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // If only one OS entry is present and if the user tries to delete the OS entry, then
    // display an error message
    if( 1 == dwInitialCount )
    {
        ShowMessage(stderr,GetResString(IDS_ONLY_ONE_OS));
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrKeyValue);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    if( (DWORD) StringLengthW(DynArrayItemAsString(arrKeyValue,dwDefault - 1), 0 ) > MAX_RES_STRING )
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH), MAX_RES_STRING);
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrKeyValue);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //check before deleting this entry check if it contains /redirect switch or not
    //this is because if it contains /redirect switch and any other other doesn't contains
    //then we have to remove redirect port and baud rate from boot loader section
    szTemp = (LPWSTR)DynArrayItemAsString(arrKeyValue,dwDefault - 1);
    pToken = _tcsrchr(szTemp , L'"') ;
    if(NULL== pToken)
    {
        ShowMessage(stderr,GetResString(IDS_NO_TOKENS));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrBootIni);
        DestroyDynamicArray(&arrKeyValue);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }
    pToken++;
    StringCopy(szRedirectBaudrate,REDIRECT_SWITCH, SIZE_OF_ARRAY(szRedirectBaudrate));
    CharLower(szRedirectBaudrate);
    if( FindString(pToken,szRedirectBaudrate, 0) != 0)
    {
        bRedirect = TRUE ;
    }

    // Remove the OS entry specified by the user from the dynamic array
    DynArrayRemove(arrKeyValue, dwDefault - 1);
    
    //reform the ini section
    if (stringFromDynamicArray2( arrKeyValue,&szFinalStr) == EXIT_FAILURE)
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrKeyValue);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //check if it is default entry, if so retrieve the ARC path of first entry
    if( 1 == dwDefault )
    {
        szTemp = (LPWSTR)DynArrayItemAsString( arrKeyValue, 0 );
        szARCPath = (LPWSTR)AllocateMemory((StringLength(szTemp,0)+10)*sizeof(WCHAR));
        if( NULL == szARCPath )
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            DestroyDynamicArray(&arrKeyValue);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
        }
        StringCopy(szARCPath, szTemp, GetBufferSize(szARCPath)/sizeof(szARCPath) );
        szTemp = wcstok(szARCPath, L"=");
    }

    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {
        ShowMessageEx(stdout,1, TRUE, GetResString(IDS_DEL_SUCCESS),dwDefault);
    }
    else
    {
        ShowMessage(stderr,GetResString(IDS_DELETE_OS));
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        SAFEFREE(szFinalStr);
        DestroyDynamicArray(&arrKeyValue);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        FreeMemory((LPVOID *)&szARCPath );
        return (EXIT_FAILURE);
    }

    //now change the default entry in the  bootloader section if deleted entry is default entry
    if( 1 == dwDefault )
    {
        if( WritePrivateProfileString( BOOTLOADERSECTION, KEY_DEFAULT, szARCPath,
                                  szPath ) == 0 )
        {
            ShowMessage(stderr,GetResString(IDS_ERR_CHANGE));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            DestroyDynamicArray(&arrKeyValue);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            FreeMemory((LPVOID *)&szARCPath );
            return (EXIT_FAILURE);
        }
        FreeMemory((LPVOID *)&szARCPath );
    }
    //this is to ensure that redirect switch is not there in any entry other than deleted one
    dwInitialCount = DynArrayGetCount(arrKeyValue);
    bFlag = FALSE ;
    for(dwI = 0 ;dwI < dwInitialCount ; dwI++ )
    {
        szTemp = (LPWSTR)DynArrayItemAsString(arrKeyValue,dwI);
        pToken = _tcsrchr(szTemp , L'"') ;
        if(NULL== pToken)
        {
            ShowMessage(stderr,GetResString(IDS_NO_TOKENS));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrKeyValue);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        pToken++;
        CharLower(szRedirectBaudrate);
        if( FindString(pToken,szRedirectBaudrate, 0)!= 0 && (dwI != dwDefault -1) )
        {
            bFlag = TRUE ;
        }
     }

    if(FALSE == bFlag && bRedirect)
    {
        // First check if the Redirect section is present and if so delete
        // the section.
        dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
        if (dwSectionFlag == EXIT_FAILURE)
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            DestroyDynamicArray(&arrBootIni);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        //If the Redirect section is present then delete it.
        if( StringLengthW(szBoot,0) != 0)
        {
            if(TRUE== deleteKeyFromINISection(KEY_REDIRECT,szPath,BOOTLOADERSECTION))
            {
                ShowMessage(stdout,GetResString(IDS_REDIRECT_REMOVED));
            }
            else
            {
                ShowMessage(stdout,GetResString(IDS_ERROR_REDIRECT_REMOVED));
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arrKeyValue);
                DestroyDynamicArray(&arrBootIni);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
           }
        }

            // First check if the Redirect section is present and if so delete
            // the section.
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,KEY_BAUDRATE,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arrKeyValue);
                DestroyDynamicArray(&arrBootIni);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            // First check if the Redirection baudrate section is present and if so delete
            // the section.
            if(StringLengthW(szBoot, 0)!=0)
            {
                if(TRUE == deleteKeyFromINISection(KEY_BAUDRATE,szPath,BOOTLOADERSECTION))
                {
                    ShowMessage(stdout,GetResString(IDS_BAUDRATE_REMOVED));
                }
                else
                {
                    ShowMessage(stdout,GetResString(IDS_ERROR_BAUDRATE_REMOVED));
                }
            }
        }

    // Closing the boot.ini stream
    SAFECLOSE(stream);
    bRes = resetFileAttrib(szPath);
    SAFEFREE(szFinalStr);
    DestroyDynamicArray(&arrKeyValue);
    DestroyDynamicArray(&arrBootIni);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes);
}

DWORD QueryBootIniSettings(  DWORD argc, LPCTSTR argv[] )
/*++
    Routine Description:
      This routine is to display the current boot.ini file settings for
      the specified system.

    Arguments:
    [in]  argc                : Number of command line arguments
    [in]  argv                : Array containing command line arguments

    Return Value :
        DWORD
--*/
{
    // File pointer pointing to the boot.ini file
    TCOLUMNS ResultHeader[ MAX_COLUMNS ];
    FILE *stream                            = NULL;
    BOOL bQuery                             = FALSE ;
    BOOL bUsage                             = FALSE;
    BOOL bNeedPwd                           = FALSE ;
    BOOL bVerbose                           = TRUE ;
    TARRAY arrResults                       = NULL ;
    TARRAY arrKeyValuePairs                 = NULL;
    TARRAY arrBootLoader                    = NULL;
    DWORD dwFormatType                      = 0;
    BOOL bHeader                            = TRUE ;
    DWORD dwLength                          = 0 ;
    DWORD dwCnt                             = 0;
    TCHAR szValue[255]                      = NULL_STRING ;
    TCHAR szFriendlyName[MAX_STRING_LENGTH] = NULL_STRING;
    TCHAR szValue1[255]                     = NULL_STRING ;
    TCHAR szBootOptions[255]                = TOKEN_NA ;
    TCHAR szBootEntry[255]                  = TOKEN_NA ;
    TCHAR szArcPath[255]                    = TOKEN_NA ;
    TCHAR szTmpString[255]                  = TOKEN_NA ;
    PTCHAR psztok                           = NULL ;
    DWORD dwRow                             = 0;
    DWORD dwCount                           = 0;
    BOOL bRes                               = FALSE ;
    BOOL bFlag                              = FALSE ;
    DWORD dwIndex                           = 0 ;
    DWORD dwLength1                         = 0 ;
    DWORD dwFinalLength                     = 0 ;
    WCHAR *szServer                         = NULL;
    WCHAR *szUser                           = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]     = NULL_STRING;
    WCHAR szPath[MAX_RES_STRING+1]            = NULL_STRING;

    LPWSTR szResults[MAX_RES_STRING+1];
    LPCWSTR szKeyName;
    TCHAR szDisplay[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwSectionFlag = 0 ;
    LPCTSTR szToken = NULL ;
    DWORD dwRetVal= 0 ;
    BOOL bConnFlag = FALSE ;
    PTCHAR pszString = NULL ;
    PTCHAR pszFriendlyName = NULL ;
    TCHAR szFinalString[MAX_RES_STRING+1] = NULL_STRING ;

    // Builiding the TCMDPARSER structure
    TCMDPARSER2 cmdOptions[5];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_QUERY;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bQuery;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //usage option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;


    // Parsing all the switches specified with -query option
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }

    szServer = cmdOptions[1].pValue;
    szUser  = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (LPWSTR) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_QUERY_USAGE));
        return ( EXIT_FAILURE );
    }

    //check for empty values of server 
    if((cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //check for empty values of user 
    if( (cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered without a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
      displayQueryUsage();
      FreeMemory((LPVOID *)&szServer );
      FreeMemory((LPVOID *)&szUser );
      return (EXIT_SUCCESS);
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, MAX_STRING_LENGTH+1);
        }
    }
    

    //
    //for setting the bNeedPwd
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    //set the default format as list
    dwFormatType = SR_FORMAT_LIST;

    //forms the header for the OS options
    FormHeader(bHeader,ResultHeader,bVerbose);


    //create dynamic array to hold the results for the BootOptions
    arrResults = CreateDynamicArray();

    //create dynamic array to hold the results for the BootLoader section
    arrBootLoader = CreateDynamicArray();

    if(arrResults == NULL || arrBootLoader == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        DestroyDynamicArray(&arrBootLoader);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //to store entries corresponding to Operating Systems sections
    arrKeyValuePairs = getKeyValueOfINISection( szPath, OS_FIELD );

    //to store entries corresponding to BootLoader section
    arrBootLoader = getKeysOfINISection(szPath,BOOTLOADERSECTION);

    if( (arrBootLoader == NULL)||(arrKeyValuePairs == NULL))
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        DestroyDynamicArray(&arrBootLoader);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    
    //getting the count of the number of boot entries
    dwLength = DynArrayGetCount(arrKeyValuePairs);

    for(dwCnt=0;dwCnt < dwLength;dwCnt++ )
    {
        dwRow = DynArrayAppendRow(arrResults,MAX_COLUMNS) ;
        StringCopy(szFriendlyName,NULL_STRING, SIZE_OF_ARRAY(szFriendlyName));
        StringCopy(szBootOptions,NULL_STRING, SIZE_OF_ARRAY(szBootOptions));
        StringCopy(szTmpString,NULL_STRING, SIZE_OF_ARRAY(szTmpString));
        if(arrKeyValuePairs != NULL)
        {
            LPCWSTR pwsz = NULL;
            pwsz = DynArrayItemAsString( arrKeyValuePairs,dwCnt );

            if(StringLengthW(pwsz, 0) > 254)
            {
                ShowMessage( stderr,GetResString(IDS_STRING_TOO_LONG));
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                DestroyDynamicArray(&arrBootLoader);
                DestroyDynamicArray(&arrKeyValuePairs);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
            if(pwsz != NULL)
            {
                StringCopy(szValue,pwsz, SIZE_OF_ARRAY(szValue));
                StringCopy(szValue1,pwsz, SIZE_OF_ARRAY(szValue1));
            }
            else
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ShowMessage( stderr, ERROR_TAG);
                ShowLastError(stderr);
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                DestroyDynamicArray(&arrBootLoader);
                DestroyDynamicArray(&arrKeyValuePairs);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ShowMessage( stderr, ERROR_TAG);
            ShowLastError(stderr);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrBootLoader);
            DestroyDynamicArray(&arrResults);
            if(NULL !=arrKeyValuePairs)
            DestroyDynamicArray(&arrKeyValuePairs);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        //Parse the string to obtain the Boot Path
        psztok = wcschr(szValue,L'=');
        if( NULL == psztok  )
        {
            ShowMessage( stderr, GetResString(IDS_NO_TOKENS));
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrBootLoader);
            DestroyDynamicArray(&arrResults);
            DestroyDynamicArray(&arrKeyValuePairs);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
        psztok[0]=0;
        if(StringLength(szValue,0) != 0 )
        {
            StringCopy(szArcPath,szValue, SIZE_OF_ARRAY(szArcPath));
        }
        else
        {
            ShowMessage( stderr, GetResString(IDS_NO_TOKENS));
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrBootLoader);
            DestroyDynamicArray(&arrResults);
            DestroyDynamicArray(&arrKeyValuePairs);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        
        //get the friendly name
        pszFriendlyName = DivideToken(szValue1,szFinalString);
        if(pszFriendlyName == NULL)
        {
            ShowMessage( stderr, GetResString(IDS_NO_TOKENS));
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrBootLoader);
            DestroyDynamicArray(&arrResults);
            DestroyDynamicArray(&arrKeyValuePairs);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        pszString = _tcsrchr(szValue1,L'\"');
        pszString++ ;

        StringCopy(szTmpString,pszString, SIZE_OF_ARRAY(szTmpString));
        TrimString(szTmpString,TRIM_ALL);

        _ltow(dwCnt+1,szBootEntry,10);
        DynArraySetString2( arrResults,dwRow ,COL0,szBootEntry,0 );
        if(StringLengthW(pszFriendlyName, 0)==0)
        {
            pszFriendlyName=TOKEN_NA;
        }
        DynArraySetString2( arrResults,dwRow ,COL1,pszFriendlyName,0 );
        DynArraySetString2(arrResults,dwRow,COL2,szArcPath,0);

        if(StringLengthW(szTmpString, 0) != 0)
        {
         //lstrcat(szBootOptions,TOKEN_FWDSLASH1);
         StringConcat(szBootOptions,szTmpString, SIZE_OF_ARRAY(szBootOptions));
        }
        else
        {
            StringCopy(szBootOptions,TOKEN_NA, SIZE_OF_ARRAY(szBootOptions));
        }
        DynArraySetString2( arrResults,dwRow ,COL3,szBootOptions,0 );
    }


    dwCount = DynArrayGetCount(arrBootLoader);
    bFlag = TRUE;

    // this loop is for getting key values of boot loader section and 
    // calculating the maximum width of the the keys which will be displayed.
    for(dwIndex=0;dwIndex < dwCount;dwIndex++)
    {
        szKeyName   = DynArrayItemAsString(arrBootLoader,dwIndex);
        szResults[dwIndex] = (LPWSTR)AllocateMemory(MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szResults[dwIndex] )
        {
            bFlag = FALSE;
            break;
        }

        //the value correspondin to the key is obtained.
        dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,szKeyName,szResults[dwIndex]);
        
        if (dwSectionFlag == EXIT_FAILURE)
        {
            bFlag = FALSE;
            break;
        }
            
        dwLength1 = StringLengthW(szKeyName,0);

        if (dwLength1 > dwFinalLength)
        {
            dwFinalLength = dwLength1;
        }
    }

    if( FALSE == bFlag )
    {
        //free the memory allocated for values
        for(dwIndex=0;dwIndex < dwCount;dwIndex++)
        {
            FreeMemory((LPVOID *) &szResults[dwIndex] );
        }
        
         ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
         resetFileAttrib(szPath);
         SAFECLOSE(stream);
         DestroyDynamicArray(&arrResults);
         DestroyDynamicArray(&arrBootLoader);
         DestroyDynamicArray(&arrKeyValuePairs);
         SafeCloseConnection(szServer,bConnFlag);
         FreeMemory((LPVOID *)&szServer );
         FreeMemory((LPVOID *)&szUser );
         return EXIT_FAILURE;
    }


    ShowMessage(stdout,TOKEN_NEXTLINE);
    ShowMessage(stdout,BOOT_HEADER);
    ShowMessage(stdout,DASHES_BOOTOS);


    // display the results of the bootloader section.
    for(dwIndex=0;dwIndex < dwCount;dwIndex++)
    {
        szKeyName   = DynArrayItemAsString(arrBootLoader,dwIndex);
        dwLength1 = dwFinalLength - StringLengthW(szKeyName, 0) + 1;
        ShowMessage(stdout,szKeyName);
        StringCopy(szDisplay,TOKEN_COLONSYMBOL, SIZE_OF_ARRAY(szDisplay));
        StringConcat(szDisplay,TOKEN_50SPACES,dwLength1+1);
        ShowMessage(stdout,szDisplay);
        ShowMessage(stdout,szResults[dwIndex]);
        ShowMessage(stdout,TOKEN_NEXTLINE);
    }

    ShowMessage(stdout,TOKEN_NEXTLINE);
    ShowMessage(stdout,OS_HEADER);
    ShowMessage(stdout,DASHES_OS);



    ShowResults(MAX_COLUMNS, ResultHeader, dwFormatType,arrResults ) ;

    
    //free the memory allocated for values
     for(dwIndex=0;dwIndex < dwCount;dwIndex++)
     {
        FreeMemory((LPVOID *) &szResults[dwIndex] );
     }

    // Closing the boot.ini stream and destroying the dynamic arrays.
    DestroyDynamicArray(&arrResults);
    DestroyDynamicArray(&arrBootLoader);
    DestroyDynamicArray(&arrKeyValuePairs);
    SAFECLOSE(stream);
    bRes = resetFileAttrib(szPath);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes);
}

TARRAY 
getKeysOfINISection(  
                     IN LPTSTR sziniFile, 
                     IN LPTSTR sziniSection 
                     )
/*++

    Routine Description:
      This function gets all the keys present in the specified section of
      an .ini file and then returns the dynamic array containing all the
      keys

    Arguments:
    [in] sziniFile     :  Name of the ini file.
    [in] szinisection  :  Name of the section in the boot.ini.


    Return Value :
        TARRAY ( pointer to the dynamic array )
--*/
{

    TARRAY  arrKeys         = NULL;
    DWORD   len             = 0 ;
    DWORD   i               = 0 ;
    DWORD   j               = 0 ;
    LPTSTR  inBuf           = NULL ;
    DWORD   dwLength        = MAX_STRING_LENGTH1;
    BOOL    bNobreak        = TRUE;
    LPTSTR  szTemp          = NULL ;

    inBuf = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
    if(inBuf==NULL)
    {
        return NULL ;
    }

    szTemp = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
    if((szTemp == NULL))
    {
        SAFEFREE(inBuf);
        return NULL ;
    }

    SecureZeroMemory(inBuf,GetBufferSize(inBuf));
    SecureZeroMemory(szTemp,GetBufferSize(szTemp));

    do
    {
        // Getting all the keys from the boot.ini file
        len = GetPrivateProfileString (sziniSection,
                                       NULL,
                                       ERROR_PROFILE_STRING,
                                       inBuf,
                                       dwLength,
                                        sziniFile);


        //if the size of the string is not sufficient then increment the size.
        if(len == dwLength-2)
        {
            dwLength +=100 ;
            if ( inBuf != NULL )
            {
                FreeMemory( (LPVOID *) &inBuf );
                inBuf = NULL;
            }
            inBuf = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
            if(inBuf == NULL)
            {
                SAFEFREE(inBuf);
                SAFEFREE(szTemp);
                return NULL ;
            }

            if ( szTemp != NULL )
            {
                FreeMemory( (LPVOID *) &szTemp );
                szTemp = NULL;
            }
            szTemp = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
            if(szTemp == NULL)
            {
                SAFEFREE(inBuf);
                SAFEFREE(szTemp);
                return NULL ;
            }
        }
        else
        {
            bNobreak = FALSE;
            break ;
        }
    }while(TRUE == bNobreak);

    // Creating a dynamic array by using the function in the DynArray.c module.
    // This dynamic array will contain all the keys.
    arrKeys = CreateDynamicArray();
    if(arrKeys == NULL)
    {
        SAFEFREE(inBuf);
        SAFEFREE(szTemp);
        return NULL ;
    }

    // Looping through the characters returned by the above function
    while(i<len)
    {

      // Each individual key will be got in arrTest array
      szTemp[ j++ ] = inBuf[ i ];
      if( inBuf[ i ] == TOKEN_DELIM )
      {
            // Setting j to 0 to start the next key.
            j = 0;

            // Appending each key to the dynamic array
            DynArrayAppendString( arrKeys, szTemp, 0 );
            if(StringLength(szTemp, 0)==0)
            {
                SAFEFREE(inBuf);
                SAFEFREE(szTemp);
                DestroyDynamicArray(&arrKeys);
                return  NULL ;
            }
      }

      // Incrementing loop variable
      i++;
    }

    SAFEFREE(inBuf);
    SAFEFREE(szTemp);
    // returning the dynamic array containing all the keys
    return arrKeys;
}


TARRAY 
getKeyValueOfINISection( 
                        IN LPTSTR iniFile, 
                        IN LPTSTR sziniSection 
                       )
/*++
    Routine Description:
        This function gets all the key-value pairs of the [operating systems]
        section and returns a dynamic array containing all the key-value pairs

    Arguments:
    [in] sziniFile     :  Name of the ini file.
    [in] szinisection  :  Name of the section in the boot.ini.


    Return Value :
        TARRAY ( pointer to the dynamic array )
--*/
{
    HANDLE hFile;
    TARRAY arrKeyValue = NULL;
    DWORD len = 0;
    DWORD i = 0 ;
    DWORD j = 0 ;
    LPTSTR inbuf = NULL;
    LPTSTR szTemp = NULL ;
    DWORD dwLength = MAX_STRING_LENGTH1 ;
    BOOL  bNobreak  = TRUE;

    hFile = CreateFile( iniFile, 0, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_READONLY, NULL );
    if ( hFile != INVALID_HANDLE_VALUE )
    {
        //get length of the file
        dwLength = GetFileSize(hFile, NULL );
        CloseHandle(hFile);
        if( dwLength >= 2*1024*1024 ) //if file size is greater than 2MB
        {
            ShowMessage( stdout, GetResString(IDS_FILE_TOO_LONG) );
            return NULL;
        }
    }

    // Initialising loop variables
    i = 0;
    j = 0;

    //return NULL if failed to allocate memory.
    inbuf = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
    if(inbuf==NULL)
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return NULL ;
    }
    
    //return NULL if failed to allocate memory
    szTemp = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
    if(szTemp == NULL)
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFEFREE(inbuf);
        return NULL ;
    }

   SecureZeroMemory(inbuf,GetBufferSize(inbuf));

    do
    {

        // Getting all the key-value pairs from the boot.ini file
        len = GetPrivateProfileSection (sziniSection, inbuf,dwLength, iniFile);

        if(len == dwLength -2)
        {
            dwLength +=1024 ;

            if ( inbuf != NULL )
            {
                FreeMemory( (LPVOID *)&inbuf );
                inbuf = NULL;
            }

            if ( szTemp != NULL )
            {
                 FreeMemory( (LPVOID *)&szTemp );
                szTemp = NULL;
            }

            inbuf = (LPTSTR)AllocateMemory(dwLength* sizeof(TCHAR));
            szTemp = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
            if((inbuf== NULL)||(szTemp==NULL) || dwLength == 65535)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                SAFEFREE(inbuf);
                SAFEFREE(szTemp);
                return NULL ;
            }
        }
        else
        {
            bNobreak = FALSE;
            break ;
        }
    }while(TRUE == bNobreak);


    inbuf[StringLengthW(inbuf, 0)] = '\0';

    // Creating a dynamic array by using the function in the DynArray.c module.
    // This dynamic array will contain all the key-value pairs.
    arrKeyValue = CreateDynamicArray();
    if(arrKeyValue == NULL)
    {
       ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        SAFEFREE(inbuf);
        SAFEFREE(szTemp);
        return NULL ;
    }

    // Looping through the characters returned by the above function
    while(i<len)
    {
      // Each individual key will be got in arrTest array
      szTemp[ j++ ] = inbuf[ i ];
      if( inbuf[ i ] == TOKEN_DELIM)
      {
            szTemp[j+1] = '\0';
            // Setting j to 0 to start the next key.
            j = 0;
            // Appending each key-value to the dynamic array
            DynArrayAppendString( arrKeyValue, szTemp, 0 );
            if(StringLengthW(szTemp, 0)==0)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                ShowMessage( stderr, ERROR_TAG);
                ShowLastError(stderr);
                SAFEFREE(inbuf);
                SAFEFREE(szTemp);
                return NULL ;
            }
      }
      // Incrementing loop variable
      i++;
    }

    // returning the dynamic array containing all the key-value pairs
    SAFEFREE(inbuf);
    SAFEFREE(szTemp);
    return arrKeyValue;
}


BOOL 
deleteKeyFromINISection( IN LPTSTR szKey, 
                         IN LPTSTR sziniFile, 
                         IN LPTSTR sziniSection 
                        )
/*++
    Routine Description:
        This function deletes a key from an ini section of an ini file

      Arguments:
    [in] szKey           :  Name of the key which has to be deleted
                            from the given section present in the
                            given ini file
    [in] sziniFile       :  Name of the ini file.
    [in] szinisection    :  Name of the section in the boot.ini.

    Return Value :
        BOOL (TRUE if there is no error, else the value is FALSE)
--*/
{
    // If the third parameter (default value) is NULL, the key pointed to by
    // the key parameter is deleted from the specified section of the specified
    // INI file
    if( WritePrivateProfileString( sziniSection, szKey, NULL, sziniFile ) == 0 )
    {
        // If there is an error while writing then return false
        return FALSE;
    }

    // If there is no error, then return true
    return TRUE;
}

DWORD removeSubString( LPTSTR szString, LPCTSTR szSubString )
/*++
    Routine Description:
        This function removes a sub-string from a string

      Arguments:
         [in] szString           :  Main string
         [in] szSubString         : Sub-string

    Return Value :
        VOID
--*/
{

    LPWSTR szFinalStr=NULL;
    DWORD dwSize =0;
    TCHAR sep[] = TOKEN_EMPTYSPACE ;
    PTCHAR pszToken = NULL_STRING;
    DWORD dwCnt = 0 ;
    DWORD dw=0;
    
    szFinalStr = (LPWSTR) AllocateMemory( (StringLengthW(szString, 0)+10)*sizeof(WCHAR) );
    if( NULL == szFinalStr )
    {
      ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
      return EXIT_FAILURE;
    }

    SecureZeroMemory( szFinalStr, GetBufferSize(szFinalStr) );

    dw = StringLengthW(szString, 0)+10;

    // Character space is used for tokenising
    StringCopy( sep, _T(" "), SIZE_OF_ARRAY(sep) );

    // Getting the first token
    pszToken = _tcstok( szString, sep );
    while( pszToken != NULL )
    {
        // If the token is equal to the sub-string, then the token
        // is not added to the final string. The final string contains
        // all the tokens except the sub-string specified.
        if(StringCompare( pszToken, szSubString, TRUE, 0 ) != 0 )
        {
            if(dwCnt != 0)
            {
                StringCopy( szFinalStr + dwSize - 1, TOKEN_EMPTYSPACE, dw-dwSize );
            }
            dwCnt++ ;
            StringCopy( szFinalStr + dwSize, pszToken, dw-dwSize );
            dwSize = dwSize + StringLengthW(pszToken, 0) + 1;
        }

        // Getting the next token
        pszToken = _tcstok( NULL, sep );
    }

    //lstrcpyn(szString,szFinalStr,lstrlen(szFinalStr)-1);
    StringCopy(szString,szFinalStr, dw );
    return EXIT_SUCCESS;
}

BOOL 
openConnection( IN LPWSTR szServer, 
                IN LPWSTR szUser,
                IN LPWSTR szPassword,
                IN LPWSTR szPath,
                IN BOOL bNeedPwd,
                IN FILE *stream,
                IN PBOOL pbConnFlag
               )
/*++
    Routine Description:
        This function establishes a connection to the specified system with
        the given credentials.
    Arguments:
    [in] szServer     :  server name to coonect to
    [in] szUser       :  User Name
    [in] szPassword   :  password
    [in] bNeedPwd     :  Boolean for asking the password.
    [in] szPath       :  path of the ini file .

    Return Value :
      BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
--*/
{

    // Declaring the file path string which will hold the path of boot.ini file
    HRESULT hr = S_OK;
    TCHAR filePath[MAX_RES_STRING+1] = NULL_STRING ;

    DWORD dwRetVal = 0 ;

    BOOL bResult = FALSE;
    INT   nRetVal = 0;

    HKEY hKey;
    HKEY hBootpathKey;

    //WCHAR  szDrive[MAX_STRING_LENGTH]=NULL_STRING;
    LPTSTR  szDrive = NULL ;

    WCHAR  szDrive1[MAX_STRING_LENGTH]=NULL_STRING;
    DWORD  dwSize=MAX_RES_STRING;
    DWORD  dwType=0;

    *pbConnFlag = TRUE ;
    
    SecureZeroMemory( filePath, sizeof(filePath));

    if( StringCompare(szServer, NULL_STRING, TRUE, 0) != 0 )
    {

            bResult = EstablishConnection(szServer,
                                          szUser,
                                          (StringLengthW(szUser,0)!=0)? SIZE_OF_ARRAY_IN_CHARS(szUser):256,
                                          szPassword,
                                          MAX_STRING_LENGTH,
                                          bNeedPwd);
            if (bResult == FALSE)
            {
               ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
               SecureZeroMemory( szPassword, MAX_STRING_LENGTH );
               return EXIT_FAILURE ;
            }
            else
            {
                switch( GetLastError() )
                {
                case I_NO_CLOSE_CONNECTION:
                    *pbConnFlag = FALSE ;
                    break;

                case E_LOCAL_CREDENTIALS:
                    break;
                case ERROR_SESSION_CREDENTIAL_CONFLICT:
                    {
                        ShowLastErrorEx(stderr, SLE_TYPE_WARNING | SLE_INTERNAL );
                        *pbConnFlag = FALSE ;
                         break;
                    }
                }
            }

            SecureZeroMemory( szPassword, MAX_STRING_LENGTH );

            dwRetVal = CheckSystemType( szServer);
            if(dwRetVal==EXIT_FAILURE )
            {
                return EXIT_FAILURE ;
            }

            //connect to the registry to bring the boot volume name
            if( ERROR_SUCCESS != RegConnectRegistry( szServer, HKEY_LOCAL_MACHINE, &hKey ) )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return EXIT_FAILURE;
            }
    }
    else
    {
            dwRetVal = CheckSystemType( szServer);
            if(dwRetVal==EXIT_FAILURE )
            {
                return EXIT_FAILURE ;
            }

            //connect to the registry to bring the boot volume name
            if( ERROR_SUCCESS != RegConnectRegistry( NULL, HKEY_LOCAL_MACHINE, &hKey ) )
            {
                SaveLastError();
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                return EXIT_FAILURE;
            }

    }

    //now open the desired key
    if( ERROR_SUCCESS != RegOpenKeyEx( hKey, REGISTRY_PATH, 0, KEY_QUERY_VALUE, &hBootpathKey ) )
    {
        SetLastError(nRetVal);
        SaveLastError();
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }


    szDrive = ( LPTSTR )AllocateMemory( dwSize*sizeof( TCHAR ) );
   if(szDrive == NULL)
   {
        return ERROR_NOT_ENOUGH_MEMORY;
   }

    nRetVal = RegQueryValueEx( hBootpathKey, L"BootDir", 0, &dwType, (LPBYTE)szDrive, &dwSize ) ;
    if (nRetVal == ERROR_MORE_DATA)
        {
            if ( szDrive != NULL )
            {
                FreeMemory((LPVOID *) &szDrive );
                szDrive = NULL;
            }
            szDrive    = ( LPTSTR ) AllocateMemory( dwSize*sizeof( TCHAR ) );
            if( NULL == szDrive )
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

        }

    nRetVal = RegQueryValueEx( hBootpathKey, L"BootDir", 0, &dwType, (LPBYTE)szDrive, &dwSize ) ;
    if( ERROR_SUCCESS != nRetVal)
    {
        RegCloseKey(hKey);
        ShowMessage( stderr, GetResString(IDS_BOOTINI) );
        return EXIT_FAILURE;
    }

    //this for display purpose
    StringCopy( szDrive1, szDrive, SIZE_OF_ARRAY(szDrive1) );
    CharUpper(szDrive1);

    if( StringCompare(szServer, NULL_STRING, TRUE, 0) != 0 )
    {
        szDrive[1]=L'$';
        szDrive[2]=0;
        hr = StringCchPrintf(filePath, SIZE_OF_ARRAY(filePath), L"\\\\%s\\%s\\boot.ini", szServer, szDrive );
    }
    else
    {
        hr = StringCchPrintf(filePath, SIZE_OF_ARRAY(filePath), L"%sboot.ini", szDrive );
    }

    stream = _tfopen(filePath, READ_MODE);
    
    // If boot.ini is not found, then display error message
    if(stream == NULL )
    {
        RegCloseKey(hKey);
        RegCloseKey(hBootpathKey);
        ShowMessage( stderr, GetResString(IDS_BOOTINI) );
        return EXIT_FAILURE ;
    }
    //store the attribs of ini file
    g_dwAttributes = GetFileAttributes( filePath );
    if( (DWORD)-1 == g_dwAttributes )
    {
        SaveLastError();
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        RegCloseKey(hKey);
        RegCloseKey(hBootpathKey);
        return EXIT_FAILURE;
    }

    // Changing the file permissions of the boot.ini file
    nRetVal = _tchmod(filePath, _S_IREAD | _S_IWRITE);
    if (nRetVal == -1)
    {
        RegCloseKey(hKey);
        RegCloseKey(hBootpathKey);
        ShowMessageEx( stderr, 1, TRUE, GetResString(IDS_READWRITE_BOOTINI), szDrive1 );
        return EXIT_FAILURE ;
    }
    
    if( nRetVal != 0 )
    {
        RegCloseKey(hKey);
        RegCloseKey(hBootpathKey);
        ShowMessage(stderr,GetResString(IDS_READWRITE_BOOTINI));
        return EXIT_FAILURE ;
    }


    //close the registry, it's work is over
    RegCloseKey(hKey);
    RegCloseKey(hBootpathKey);

    //fill the return value
    StringCopy( szPath, filePath, MAX_STRING_LENGTH);

    return EXIT_SUCCESS ;
}

void displayDeleteUsage_IA64()
/*++
 Routine Description:
      This function fetches 64 bit Delete Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_DEL_HELP_IA64_BEGIN;
    for(;dwIndex <= ID_DEL_HELP_IA64_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

void displayDeleteUsage_X86()
/*++
 Routine Description:
      This function fetches 32 bit Delete Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_DEL_HELP_BEGIN;
    for(;dwIndex <= ID_DEL_HELP_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayCopyUsage_IA64()
/*++
 Routine Description:
      This function fetches 64 bit Copy Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_COPY_HELP_IA64_BEGIN;
    for(;dwIndex <=ID_COPY_HELP_IA64_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayCopyUsage_X86()
/*++
 Routine Description:
      This function fetches 32 bit Copy Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_COPY_HELP_BEGIN;
    for(;dwIndex <=ID_COPY_HELP_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}


VOID displayQueryUsage()
/*++
 Routine Description:
      This function fetches Query Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
#ifdef _WIN64
        displayQueryUsage_IA64();
#else
        displayQueryUsage_X86();
#endif
}

VOID displayQueryUsage_IA64()
/*++
 Routine Description:
      This function fetches Query Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_QUERY_HELP64_BEGIN ;

    for(;dwIndex <= ID_QUERY_HELP64_END ;dwIndex++ )
    {
            ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayQueryUsage_X86()
/*++
 Routine Description:
      This function fetches Query Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_QUERY_HELP_BEGIN ;
    for(;dwIndex <= ID_QUERY_HELP_END;dwIndex++ )
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

DWORD displayMainUsage_X86()
/*++
 Routine Description:
      This function fetches Main Usage information from resource file and displays it

 Arguments:
      None

 Return Value:
      void
--*/
{

    TCHAR szServer[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwRetVal = 0;

    DWORD dwIndex = ID_MAIN_HELP_BEGIN1 ;

    //display the error message if  the target system is a 64 bit system or if error occured in
    //retreiving the information
    dwRetVal = CheckSystemType( szServer);
    if(dwRetVal==EXIT_FAILURE )
    {
        return (EXIT_FAILURE);
    }

    for(;dwIndex <= ID_MAIN_HELP_END1 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }

    return EXIT_SUCCESS ;
}

VOID displayMainUsage_IA64()
/*++
 Routine Description:
      This function fetches Usage information for the 64 bit system

 Arguments:
      None

 Return Value:
      void
--*/
{
    DWORD dwIndex = ID_MAIN_HELP_IA64_BEGIN ;

    for(;dwIndex <= ID_MAIN_HELP_IA64_END ;dwIndex++)
    {
            ShowMessage(stdout,GetResString(dwIndex));
    }
}

BOOL resetFileAttrib( LPTSTR szFilePath )
/*++

    Routine Description:
        This function resets the permissions with the original set of
        permissions ( -readonly -hidden -system )
        and then exits with the given exit code.

    Arguments
    [in] szFilePath   :  File Path of the boot.ini file


    Return Value :
      BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
--*/
{
    if( NULL == szFilePath)
    {
        return FALSE ;
    }

    
    // Resetting the file permission of the boot.ini file to its original
    // permission list( -r, -h, -s )
    if( g_dwAttributes & FILE_ATTRIBUTE_READONLY )
    {
        g_dwAttributes |= FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_READONLY;
    }
    else
    {
        g_dwAttributes |= FILE_ATTRIBUTE_ARCHIVE;
    }


    if( FALSE == SetFileAttributes( szFilePath, g_dwAttributes) )
    {
        ShowMessage(stderr,GetResString(IDS_RESET_ERROR));
        return EXIT_FAILURE ;
    }

    return EXIT_SUCCESS ;
}


DWORD 
stringFromDynamicArray2( IN TARRAY arrKeyValuePairs,
                         IN LPTSTR* szFinalStr 
                       )
/*++

    Routine Description:
        This function forms a string of string by combining all strings in dynamic array .

    Arguments
        [in]  arrKeyValuePairs    :  Dynamic array which contains all the
                                     key-value pairs.
        [out] szFiinalStr             :  String which is formed from all the key-value pairs

    Return Value :
      BOOL (EXIT_SUCCESS if there is no error, else the value is EXIT_FAILURE)
--*/
{

    // Total number of elements in the array
    DWORD dwKeyValueCount = 0;

    // Variable used to keep track the current position while appending strings.
    DWORD dwStrSize = 0;

    // Loop variable
    DWORD i = 0;
    DWORD dw =0;

    // Initialsing size and loop variables to 0
    dwStrSize = 0;
    i = 0;

    if( (arrKeyValuePairs ==NULL) )
    {
        return EXIT_FAILURE ;
    }


    // Getting the total number of key-value pairs
    dwKeyValueCount = DynArrayGetCount(arrKeyValuePairs);

    for(i=0;i < dwKeyValueCount;i++)
    {
        LPCWSTR pwsz = NULL;
        pwsz = DynArrayItemAsString( arrKeyValuePairs, i ) ;
        if(pwsz != NULL)
        {
            dwStrSize += StringLengthW(pwsz,0) + 1;
        }
    }

    *szFinalStr = (LPWSTR) AllocateMemory( (dwStrSize+1)*sizeof(WCHAR));
    if( NULL == *szFinalStr )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE ;
    }

    SecureZeroMemory(*szFinalStr, GetBufferSize(*szFinalStr));

    i = 0 ;
    dw = dwStrSize;
    dwStrSize =  0 ;

    // Looping through all the key-value pairs and building the final string
    // containing all the key value pairs. This string has to be passed to
    // WriteProfileSection
    while( (i < dwKeyValueCount )&& (arrKeyValuePairs != NULL) )
    {
        // Building the final string, by getting each key-value pair present in the
        // dynamic array
        if(arrKeyValuePairs != NULL)
        {
            LPCWSTR pwsz = NULL;
            pwsz = DynArrayItemAsString( arrKeyValuePairs, i ) ;

            if(pwsz != NULL)
            {
                StringCopy(*szFinalStr + dwStrSize, pwsz, dw-dwStrSize );
                dwStrSize = dwStrSize + StringLengthW(pwsz, 0) + 1;
            }
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            SaveLastError();
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return EXIT_FAILURE ;
        }
        i++;
    }
    return EXIT_SUCCESS ;
}


VOID 
FormHeader( IN BOOL bHeader,
            IN TCOLUMNS *ResultHeader,
            IN BOOL bVerbose
          )
/*++
   Routine Description:
       This function is used to build the header and also display the
       result in the required format as specified by  the user.

   Arguments:
      [ in ] arrResults     : argument(s) count specified at the command prompt
      [ in ] dwFormatType   : format flags
      [ in ] bHeader        : Boolean for specifying if the header is required or not.

   Return Value:
      none
--*/
{
    bVerbose = TRUE;
    bHeader = TRUE;

    //OS Entry
    ResultHeader[COL0].dwWidth = COL_BOOTOPTION_WIDTH ;
    ResultHeader[COL0].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL0].pFunction = NULL;
    ResultHeader[COL0].pFunctionData = NULL;
    StringCopy( ResultHeader[COL0].szFormat, NULL_STRING, SIZE_OF_ARRAY(ResultHeader[COL0].szFormat) );
    StringCopy( ResultHeader[COL0].szColumn,COL_BOOTOPTION, SIZE_OF_ARRAY( ResultHeader[COL0].szColumn) );

    ResultHeader[COL1].dwWidth = COL_FRIENDLYNAME_WIDTH;
    ResultHeader[COL1].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL1].pFunction = NULL;
    ResultHeader[COL1].pFunctionData = NULL;
    StringCopy( ResultHeader[COL1].szFormat, NULL_STRING, SIZE_OF_ARRAY(ResultHeader[COL1].szFormat) );
    StringCopy( ResultHeader[COL1].szColumn,COL_FRIENDLYNAME, SIZE_OF_ARRAY(ResultHeader[COL1].szColumn) );


    ResultHeader[COL2].dwWidth =  COL_ARC_WIDTH;
    ResultHeader[COL2].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL2].pFunction = NULL;
    ResultHeader[COL2].pFunctionData = NULL;
    StringCopy( ResultHeader[COL2].szFormat, NULL_STRING, SIZE_OF_ARRAY(ResultHeader[COL2].szFormat) );
    StringCopy( ResultHeader[COL2].szColumn,COL_ARCPATH, SIZE_OF_ARRAY(ResultHeader[COL2].szColumn) );

    ResultHeader[COL3].dwWidth =  COL_BOOTID_WIDTH;
    ResultHeader[COL3].dwFlags = SR_TYPE_STRING;
    ResultHeader[COL3].pFunction = NULL;
    ResultHeader[COL3].pFunctionData = NULL;
    StringCopy( ResultHeader[COL3].szFormat, NULL_STRING, SIZE_OF_ARRAY(ResultHeader[COL3].szFormat) );
    StringCopy( ResultHeader[COL3].szColumn,COL_BOOTID, SIZE_OF_ARRAY(ResultHeader[COL3].szColumn) );

}

DWORD AppendRawString(  DWORD argc, LPCTSTR argv[] )
/*++
// Routine Description:
//      This routine will append or add a string to osloadoptions
//
// Arguments:
//      [ in ] argc     : Number of command line arguments
//      [ in ] argv     : Array containing command line arguments

// Return Value:
//      DWORD
//
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bNeedPwd = FALSE ;
    BOOL bRaw = FALSE ;

    DWORD dwDefault = 0;

    TARRAY arr ;

    LPWSTR pwszKey                            = NULL;
    FILE *stream                              = NULL;

    WCHAR *szServer                          = NULL;
    WCHAR *szUser                            = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]      = NULL_STRING;
    WCHAR szPath[MAX_RES_STRING+1]             = NULL_STRING;
    WCHAR szRawString[MAX_STRING_LENGTH]     = NULL_STRING ;

    DWORD dwNumKeys = 0;
    BOOL bRes = FALSE ;
    PTCHAR pToken = NULL ;
    LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ;
    LPCTSTR szToken = NULL ;
    DWORD dwRetVal = 0 ;
    BOOL bConnFlag = FALSE ;
    BOOL bAppendFlag = FALSE ;
    TCHAR szString[255] = NULL_STRING ;

    TCMDPARSER2 cmdOptions[8];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RAW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bRaw;

    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //usage option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //id option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

    //default option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szRawString;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //usage option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_APPEND;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bAppendFlag;

    // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);  
    }

    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser ) 
    {
        szUser = (WCHAR *) AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );
    TrimString( szRawString, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_RAW_USAGE));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if((cmdOptions[1].dwActuals!=0)&&(StringLength(szServer,0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }
    
    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
       ShowMessage(stderr,GetResString(IDS_PASSWD_BUT_NOUSER));
       FreeMemory((LPVOID *) &szServer );
       FreeMemory((LPVOID *) &szUser );
       return EXIT_FAILURE ;
    }

    //if usage is specified
    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
      displayRawUsage_X86();
      FreeMemory( (LPVOID *) &szServer );
      FreeMemory( (LPVOID *) &szUser );
      return EXIT_SUCCESS;
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }


    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection
    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE ,0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                FreeMemory((LPVOID *) &szServer );
                FreeMemory((LPVOID *) &szUser );
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, GetBufferSize(szServer)/sizeof(WCHAR));
        }
    }

    //determine whether to prompt for password or not
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath, bNeedPwd, stream, &bConnFlag );
    if(bFlag == EXIT_FAILURE)
    {
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    // Getting the keys of the Operating system section in the boot.ini file
    arr = getKeyValueOfINISection( szPath, OS_FIELD );

    if(arr == NULL)
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    // Getting the total number of keys in the operating systems section
    dwNumKeys = DynArrayGetCount(arr);


    // Displaying error message if the number of keys is less than the OS entry
    // line number specified by the user
    if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    // Getting the key of the OS entry specified by the user
    if (arr != NULL)
    {
        LPCWSTR pwsz = NULL;
        pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;

        //allocate memory to the new key
        pwszKey = (LPWSTR) AllocateMemory( (StringLength(szRawString,0)+StringLength(pwsz,0)+10)*sizeof(WCHAR ) );
        if( NULL == pwszKey )
        {
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        StringCopy( pwszKey, pwsz, GetBufferSize(pwszKey)/sizeof(WCHAR) );
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }
    
    //if append is not required truncate the existing osloadoptions from the boot entry
    if(bAppendFlag == FALSE)
    {
        pToken = _tcsrchr(pwszKey,L'"');
        if(NULL== pToken)
        {
            ShowMessage(stderr,GetResString(IDS_NO_TOKENS));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *) &szServer );
            FreeMemory((LPVOID *) &szUser );
            FreeMemory((LPVOID *) &pwszKey);
            return EXIT_FAILURE ;
        }
        pToken++;
        pToken[0]=L'\0';
    }

    //concatenate the raw string to the boot entry
    CharLower(szRawString);
    StringConcat(pwszKey , TOKEN_EMPTYSPACE, GetBufferSize(pwszKey)/sizeof(WCHAR) );
    StringConcat(pwszKey ,szRawString, GetBufferSize(pwszKey)/sizeof(WCHAR) );

    //check the length exceeds the max. length of boot entry
    if( StringLengthW(pwszKey, 0) > MAX_RES_STRING)
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        FreeMemory((LPVOID *) &pwszKey);
        return EXIT_FAILURE ;
    }

    DynArrayRemove(arr, dwDefault - 1 );
    DynArrayInsertString(arr, dwDefault - 1, pwszKey, MAX_RES_STRING+1);

    //free the memory, no need
    FreeMemory((LPVOID *) &pwszKey);

    //The memory is allocated in this function which should be freed before exitting
    if (stringFromDynamicArray2( arr,&szFinalStr) == EXIT_FAILURE)
    {
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return EXIT_FAILURE;
    }


    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SWITCH_ADD), dwDefault );
    }
    else
    {
        ShowMessage(stderr,GetResString(IDS_NO_ADD_SWITCHES));
        DestroyDynamicArray(&arr);
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *) &szServer );
        FreeMemory((LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    //reset the file attributes and free the memory and close the connection to the server.
    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arr);
    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *) &szServer );
    FreeMemory((LPVOID *) &szUser );
    return (EXIT_SUCCESS);

}

VOID displayRawUsage_X86()
/*++
  Routine Description:
       This routine is to display the current boot.ini file settings for
       the specified system.

 Arguments:
      none
 Return Value:
      VOID
--*/
{

    DWORD dwIndex = RAW_HELP_BEGIN;
    for(;dwIndex <= RAW_HELP_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayRawUsage_IA64()
/*++
  Routine Description:
    Display the help for the 64 bit raw option.

  Arguments:
       none
  Return Value:
       VOID
--*/
{
    DWORD dwIndex = RAW_HELP_IA64_BEGIN;
    for(;dwIndex <= RAW_HELP_IA64_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}


DWORD ChangeTimeOut(DWORD argc,LPCTSTR argv[])
/*++
 Routine Description:
      This routine is to change the timout of the boot.ini file settings for
      the specified system.
 Arguments:
   [in ]   argc  : Number of command line arguments
   [in ]   argv  : Array containing command line arguments

 Return Value:
      DWORD
--*/

{

    WCHAR *szServer                      = NULL;
    WCHAR *szUser                        = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]  = NULL_STRING;
    WCHAR szPath[MAX_STRING_LENGTH]      = NULL_STRING;
    DWORD dwTimeOut                      = 0 ;
    BOOL  bTimeout                       = FALSE;
    BOOL bNeedPwd                        = FALSE ;
    BOOL bRes                            = FALSE ;
    BOOL bFlag                           = 0 ;
    FILE *stream                         = NULL;
    TCHAR timeOutstr[STRING20]           = NULL_STRING;
    LPCTSTR szToken                      = NULL ;
    DWORD dwRetVal                       = 0 ;
    BOOL bConnFlag                       = FALSE ;
    BOOL bUsage                          = FALSE;

    TCMDPARSER2 cmdOptions[6];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_TIMEOUT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bTimeout;
   

    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags =  CP2_DEFAULT | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwTimeOut;

     //usage option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    if( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx(stderr,SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE ;
    }

    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_TIMEOUT_USAGE));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if(dwTimeOut > TIMEOUT_MAX )
    {
        ShowMessage(stderr,GetResString(IDS_TIMEOUT_RANGE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
      displayTimeOutUsage_X86();
      FreeMemory((LPVOID *)&szServer );
      FreeMemory((LPVOID *)&szUser );
      return (EXIT_SUCCESS);
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, GetBufferSize(szServer)/sizeof(WCHAR));
        }
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //display a warning message if it is a local system and set the server name to empty.
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    // Converting the numeric value to string because the WritePrivateProfileString
    // takes only string value as the value for a particular key
    _itot( dwTimeOut, timeOutstr, 10 );

    // Changing the timeout value
    if( WritePrivateProfileString( BOOTLOADERSECTION,TIMEOUT_SWITCH,
        timeOutstr, szPath ) != 0 )
    {
        ShowMessage(stdout,GetResString(IDS_TIMEOUT_CHANGE));
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        SAFECLOSE(stream);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_SUCCESS ;
    }

    // DISPLAY Error message and exit with Error code of 1.

    ShowMessage(stderr,GetResString(IDS_ERROR_TIMEOUT));
    bRes = resetFileAttrib(szPath);
    SafeCloseConnection(szServer,bConnFlag);
    SAFECLOSE(stream);
    return EXIT_FAILURE ;
}

VOID displayTimeOutUsage_X86()
/*++
   Routine Description:
        Display the help for the timeout option.
   Arguments:
        NONE.
   Return Value:
        VOID
--*/
{
    DWORD dwIndex = TIMEOUT_HELP_BEGIN;
    for(;dwIndex <= TIMEOUT_HELP_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID 
displayTimeOutUsage_IA64()
/*++
   Routine Description:
       Display the help for the 64 BIT timeout option.
   Arguments:
       NONE.
   Return Value:
       VOID
--*/
{
    DWORD dwIndex = TIMEOUT_HELP_IA64_BEGIN;

    for(;dwIndex <= TIMEOUT_HELP_IA64_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

DWORD 
ChangeDefaultOs( IN DWORD argc, 
                 IN LPCTSTR argv[]
               )
/*++
  Routine Description:
        This routine is to change the Default OS  boot.ini file settings for
                      the specified system.
  Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

  Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.
--*/
{
    WCHAR   *szServer                         = NULL;
    WCHAR   *szUser                           = NULL;
    WCHAR   szPassword[MAX_STRING_LENGTH]     = NULL_STRING ;
    DWORD   dwId                              = 0;
    BOOL    bDefaultOs                        = FALSE ;
    WCHAR   szPath[MAX_RES_STRING+1]            = NULL_STRING;
    FILE    *stream                           = NULL;
    BOOL    bNeedPwd                          = FALSE ;
    TARRAY  arrResults                        = NULL;
    DWORD   dwCount                           = 0;
    BOOL    bFlag                             = FALSE ;
    TCHAR   szDefaultId[MAX_RES_STRING+1]       = NULL_STRING ;
    long    dwValue                           = 0 ;
    LPCWSTR pwsz                              = NULL;
    LPCWSTR pwszBootId                        = NULL;
    LPTSTR  szFinalStr                        = NULL  ;
    LPTSTR  szTemp                            = NULL;
    LPCTSTR szToken                           = NULL ;
    BOOL    bConnFlag                         = FALSE ;
    BOOL    bRes                              = FALSE;
    BOOL    bUsage                            = FALSE;

    TCMDPARSER2 cmdOptions[6];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULTOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDefaultOs;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    
    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //id option
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwId;

    //usage option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_DEFAULTOS_USAGE));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

        //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if(bUsage )
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
       displayChangeOSUsage_X86();
       FreeMemory((LPVOID *)&szServer );
       FreeMemory((LPVOID *)&szUser );
       return(EXIT_SUCCESS);
    }

        //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    if(dwId <= 0)
    {
        ShowMessage(stderr, GetResString( IDS_INVALID_OSID));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection
    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, GetBufferSize(szServer)/sizeof(WCHAR));
        }
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //display warning message 
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    arrResults = CreateDynamicArray();
    //return failure if failed to allocate memory
    if(arrResults == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return (EXIT_FAILURE);
    }

    arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arrResults == NULL)
    {
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return EXIT_FAILURE ;
    }

    dwCount = DynArrayGetCount(arrResults);

    if(dwId<=0 || dwId > dwCount )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_OSID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        SAFECLOSE(stream);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if(arrResults !=NULL)
    {
        pwsz = DynArrayItemAsString(arrResults, dwId - 1);
        if(NULL == pwsz)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        //check whether it exceeds maximum limit or not
        if( (StringLengthW(pwsz, 0)>MAX_RES_STRING) || (StringLengthW(pwszBootId, 0)>MAX_RES_STRING ))
        {
            ShowMessage( stderr, GetResString(IDS_STRING_TOO_LONG));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        StringCopy(szDefaultId,pwsz, SIZE_OF_ARRAY(szDefaultId));
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        SAFECLOSE(stream);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //loop through all the  Boot entries and
    for(dwValue = dwId-2 ; dwValue>=0 ; dwValue-- )
    {
            szTemp = (LPWSTR)DynArrayItemAsString(arrResults,dwValue );
            DynArrayRemove(arrResults, dwValue+1 );
            DynArrayInsertString(arrResults, dwValue+1, szTemp, StringLengthW(szTemp, 0));
    }

    DynArrayRemove(arrResults, 0 );
    DynArrayInsertString(arrResults, 0, szDefaultId, StringLengthW(szDefaultId, 0));

    // Setting the buffer to 0, to avoid any junk value
    if (stringFromDynamicArray2( arrResults,&szFinalStr) == EXIT_FAILURE)
    {
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        SAFECLOSE(stream);
        SAFEFREE(szFinalStr);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( ( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) == 0 ) )
    {
            ShowMessage(stderr,GetResString(IDS_ERR_CHANGE));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
    }

        //to strip of the unwanted string from the string and save the required part in the Boot Loader section.
        szToken = _tcstok(szDefaultId,TOKEN_EQUAL);
        if(szToken == NULL)
        {
            ShowMessage( stderr,GetResString(IDS_NO_TOKENS));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        if( WritePrivateProfileString( BOOTLOADERSECTION, KEY_DEFAULT, szDefaultId,
                                  szPath ) != 0 )
        {
            ShowMessage(stdout,GetResString(IDS_OS_CHANGE));
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_ERR_CHANGE));
            DestroyDynamicArray(&arrResults);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arrResults);
    SafeCloseConnection(szServer,bConnFlag);
    SAFECLOSE(stream);
    SAFEFREE(szFinalStr);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return bRes ;
}

VOID displayChangeOSUsage_X86()
/*++
  Routine Description        :  Display the help for the default entry option (x86).

  Parameters         : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = DEFAULT_BEGIN;
    for(;dwIndex <=DEFAULT_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID 
displayDefaultEntryUsage_IA64()
/*++
  Routine Description        :  Display the help for the default entry option (IA64).

  Parameters                 : none

  Return Type                : VOID
--*/
{
    DWORD dwIndex = DEFAULT_IA64_BEGIN;

    for(;dwIndex <=DEFAULT_IA64_END;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

DWORD 
ProcessDebugSwitch( IN DWORD argc, 
                    IN LPCTSTR argv[] 
                   )
/*++
 Routine Description:
      Implement the Debug switch.

 Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

 Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
--*/
{

    BOOL    bUsage                                   = FALSE ;
    BOOL    bNeedPwd                                 = FALSE ;
    BOOL    bDebug                                   = FALSE ;
    DWORD   dwId                                     = 0;
    TARRAY  arrResults                               = NULL;
    FILE    *stream                                  = NULL;
    WCHAR   *szServer                                = NULL;
    WCHAR   *szUser                                  = NULL;
    WCHAR   szPassword[MAX_STRING_LENGTH]            = NULL_STRING;
    WCHAR   szPath[MAX_STRING_LENGTH]                = NULL_STRING;
    TCHAR   szDebug[MAX_RES_STRING+1]                  = NULL_STRING ;
    TCHAR   szPort[MAX_RES_STRING+1]                   = NULL_STRING ;
    TCHAR   szBoot[MAX_RES_STRING+1]                   = NULL_STRING ;
    BOOL    bRes                                     = FALSE ;
    LPTSTR  szFinalStr                               = NULL ;
    BOOL    bFlag                                    = FALSE ;
    DWORD   dwCount                                  = 0 ;
    DWORD   dwSectionFlag                            = 0 ;
    TCHAR   szTmpBuffer[MAX_RES_STRING+1]              = NULL_STRING ;
    TCHAR   szBaudRate[MAX_RES_STRING+1]               = NULL_STRING ;
    TCHAR   szString[255]                            = NULL_STRING ;
    TCHAR   szTemp[MAX_RES_STRING+1]                   = NULL_STRING ;
    TCHAR  *szValues[2]                              = {NULL};
    DWORD   dwCode                                   = 0 ;
    LPCTSTR szToken                                  = NULL ;
    DWORD   dwRetVal                                 = 0 ;
    BOOL    bConnFlag                                = FALSE ;

    TCMDPARSER2 cmdOptions[9];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEBUG;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDebug;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;
    
    
    //usage
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;
    
    //id option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwId;

    //port option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PORT;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPort;
    pcmdOption->pwszValues = COM_PORT_RANGE;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //baud option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BAUD;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szBaudRate;
    pcmdOption->pwszValues = BAUD_RATE_VALUES_DEBUG;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //default on/off option
    pcmdOption = &cmdOptions[8];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT  | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDebug;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );
    TrimString( szDebug, TRIM_ALL );
    TrimString( szBaudRate, TRIM_ALL );
    TrimString( szPort, TRIM_ALL );


    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the user enters password without entering username
    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage  )
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
      displayDebugUsage_X86();
      FreeMemory((LPVOID *)&szServer );
      FreeMemory((LPVOID *)&szUser );
      return (EXIT_SUCCESS);
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    //check if invald id is entered
    if(dwId <= 0)
    {
        ShowMessage(stderr, GetResString( IDS_INVALID_OSID));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    // Displaying copy usage if user specified -? with -copy option
 

    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    //display an error message if the user specifies any string other than on,off,edit.
    if( !( ( StringCompare(szDebug, VALUE_ON, TRUE, 0)== 0)|| (StringCompare(szDebug, VALUE_OFF, TRUE, 0)== 0) ||(StringCompare(szDebug,EDIT_STRING, TRUE, 0)== 0) ))
    {
        szValues[0]= (_TCHAR *)szDebug ;
        szValues[1]= (_TCHAR *)CMDOPTION_DEBUG ;
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }

    if( (StringCompare(szDebug, EDIT_STRING, TRUE, 0)== 0)&& (StringLength(szPort, 0)==0) && (StringLengthW(szBaudRate, 0)==0) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_EDIT_SYNTAX));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }


    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection

    arrResults = CreateDynamicArray();
    if(arrResults == NULL)
    {   
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, GetBufferSize(szServer)/sizeof(WCHAR));
        }
    }

    // display a warning message if it is a local system and set the
    // server name to empty.
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arrResults == NULL)
    {
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }


    //getting the number of boot entries
    dwCount = DynArrayGetCount(arrResults);
    if(dwId<=0 || dwId > dwCount )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_OSID));
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if( (DWORD) StringLengthW( DynArrayItemAsString(arrResults, dwId - 1 ),0 ) > MAX_RES_STRING )
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    StringCopy(szString ,DynArrayItemAsString(arrResults, dwId - 1 ), SIZE_OF_ARRAY(szString));
    if(StringLengthW(szString, 0) == 0)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }


    // check if the user entered the value of debug as on and do accordingly
    if( StringCompare(szDebug,VALUE_ON, TRUE, 0)== 0)
    {
        //check if the debug switch is already present and if so display a error message.
        if( (FindString(szString,DEBUG_SWITCH,0) != NULL ) && ( (StringLengthW(szPort,0)== 0)&&(StringLengthW(szBaudRate,0)== 0) ) )
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_DEBUG));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if(FindString(szString,DEBUG_SWITCH, 0) == NULL )
            {
                StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                StringConcat(szTmpBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szTmpBuffer));
            }
        }
        
        
        // check already com port present or not
        dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);

        if((EXIT_SUCCESS == dwCode) && (StringLengthW(szTemp, 0 )!= 0)&& (StringLengthW(szPort, 0)!= 0))
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_DUPLICATE_COM_PORT), dwId );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        // get the type of the Com port present
        dwCode = GetSubString(szString,PORT_1394,szTemp);

        if( StringLengthW(szTemp, 0)!= 0 && EXIT_SUCCESS == dwCode)
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_1394_COM_PORT), dwId );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        // if the debug port is specified by the user
        if(StringLengthW(szPort, 0)!= 0)
        {
            // compare that with the redirected port in boot loader section
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            if(StringLengthW(szBoot, 0)!= 0)
            {
                if (StringCompare(szBoot,szPort, TRUE, 0)==0)
                {
                    ShowMessage( stderr, GetResString(IDS_ERROR_REDIRECT_PORT));
                    resetFileAttrib(szPath);
                    SAFECLOSE(stream);
                    DestroyDynamicArray(&arrResults);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
            if( StringLength(szTmpBuffer,0)== 0 )
            {
                StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
            }
            else
            {
                StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
            }
            StringConcat(szTmpBuffer,TOKEN_DEBUGPORT, SIZE_OF_ARRAY(szTmpBuffer)) ;
            StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer)) ;
            CharLower(szPort);
            StringConcat(szTmpBuffer,szPort, SIZE_OF_ARRAY(szTmpBuffer));
        }


        StringCopy(szTemp,NULL_STRING, SIZE_OF_ARRAY(szTemp));
        GetBaudRateVal(szString,szTemp) ;

        //to add the Baud rate value specified by the user.
        if(StringLengthW(szBaudRate, 0)!=0)
        {
            if(StringLengthW(szTemp, 0)!= 0)
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_DUPLICATE_BAUD_VAL), dwId );
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }
            else
            {
                //forming the string to be concatenated to the BootEntry string
                if( StringLength(szTmpBuffer,0)== 0 )
                {
                    StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                }
                else
                {
                    StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
                }
                StringConcat(szTmpBuffer,BAUD_RATE, SIZE_OF_ARRAY(szTmpBuffer));
                StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
                StringConcat(szTmpBuffer,szBaudRate, SIZE_OF_ARRAY(szTmpBuffer));
            }
        }
    }
    else if( StringCompare(szDebug,VALUE_OFF, TRUE, 0)== 0)
    {
        if((StringLengthW(szPort, 0)!= 0) || (StringLengthW(szBaudRate, 0)!= 0))
        {
            DestroyDynamicArray(&arrResults);
            ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if (FindString(szString,DEBUG_SWITCH, 0) == 0 )
        {
            ShowMessage(stderr,GetResString(IDS_DEBUG_ABSENT));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            // remove the /debug switch.
            if( EXIT_FAILURE == removeSubString(szString,DEBUG_SWITCH) )
            {
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            StringCopy(szTemp,NULL_STRING, SIZE_OF_ARRAY(szTemp));

            // get the type of the Com port present
            dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);
            if(StringCompare(szTemp,PORT_1394, TRUE, 0)==0)
            {
                ShowMessage(stderr,GetResString(IDS_ERROR_1394_REMOVE));
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            // remove the /debugport=comport switch if it is present from the Boot Entry
            if (StringLengthW(szTemp, 0)!= 0)
            {
                if( EXIT_FAILURE == removeSubString(szString,szTemp) )
                {
                    resetFileAttrib(szPath);
                    SAFECLOSE(stream);
                    DestroyDynamicArray(&arrResults);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }

            StringCopy(szTemp , NULL_STRING, SIZE_OF_ARRAY(szTemp) );

            //remove the baud rate switch if it is present.
            GetBaudRateVal(szString,szTemp) ;
            if (StringLengthW(szTemp, 0)!= 0)
            {
                if( EXIT_FAILURE == removeSubString(szString,szTemp))
                {
                    resetFileAttrib(szPath);
                    SAFECLOSE(stream);
                    DestroyDynamicArray(&arrResults);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
        }
    }
    // if the user enters the EDIT  option
    else if(StringCompare(szDebug,SWITCH_EDIT, TRUE, 0)== 0)
    {

        //display error message if the /debugport=1394 switch is present already.
        if(FindString(szString,DEBUGPORT_1394, 0)!=0)
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_EDIT_1394_SWITCH));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        
        //display error message if debug switch is not present
        if (FindString(szString,DEBUG_SWITCH,0) == 0 )
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_NO_DBG_SWITCH), dwId );
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

            StringCopy(szTemp,NULL_STRING, SIZE_OF_ARRAY(szTemp));
            dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);

        //display an error message if user is trying to add baudrate value
        // when there is no COM port present in the boot options.
        // chk if the port has been spec by the user
        if((StringLengthW(szPort, 0)== 0)&&(StringLengthW(szBaudRate, 0)== 0))
        {
            DestroyDynamicArray(&arrResults);
            ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DEBUG));
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }


        if(StringLengthW(szPort, 0)!= 0)
        {
            StringCopy(szTemp , NULL_STRING, SIZE_OF_ARRAY(szTemp) );

            // get the type of the Com port present
            dwCode = GetSubString(szString,TOKEN_DEBUGPORT,szTemp);

            //display error message if there is no COM port found at all in the OS option
            //changed for displaying error
            if(StringLengthW(szTemp,0 )== 0 )
            {
                ShowMessageEx(stderr, TRUE, 1, GetResString(IDS_ERROR_NO_COM_PORT), dwId );
                bRes = resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            // remove the /debugport=comport switch if it is present from the Boot Entry
            if( EXIT_FAILURE == removeSubString(szString,szTemp) )
            {
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }
            StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
            StringConcat(szTmpBuffer,TOKEN_DEBUGPORT, SIZE_OF_ARRAY(szTmpBuffer)) ;
            StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
            CharUpper(szPort) ;
            StringConcat(szTmpBuffer,szPort, SIZE_OF_ARRAY(szTmpBuffer));

            //check if redirect port is same as that of changed port for this boot entry
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                ShowLastError(stderr);
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            if(StringLengthW(szBoot, 0)!= 0)
            {
                if (StringCompare(szBoot,szPort, TRUE, 0)==0)
                {
                    ShowMessage( stderr, GetResString(IDS_ERROR_REDIRECT_PORT));
                    resetFileAttrib(szPath);
                    SAFECLOSE(stream);
                    DestroyDynamicArray(&arrResults);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }

        }

        //to edit the baud rate value
        if(StringLengthW(szBaudRate, 0)!= 0)
        {
            StringCopy(szTemp , NULL_STRING, SIZE_OF_ARRAY(szTemp) );

            //remove the baud rate switch if it is present.
            GetBaudRateVal(szString,szTemp) ;

            // remove the swithc to be changed.
            if( EXIT_FAILURE == removeSubString(szString,szTemp) )
            {
                resetFileAttrib(szPath);
                SAFECLOSE(stream);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }

            //forming the string to be concatenated to the BootEntry string
            if( StringLength(szTmpBuffer,0) == 0 )
            {
                StringCopy(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
            }
            else
            {
                StringConcat(szTmpBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szTmpBuffer));
            }
            StringConcat(szTmpBuffer,BAUD_RATE, SIZE_OF_ARRAY(szTmpBuffer));
            StringConcat(szTmpBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szTmpBuffer));
            StringConcat(szTmpBuffer,szBaudRate, SIZE_OF_ARRAY(szTmpBuffer));
        }
    }

    //now check if length exceeds the max length allowed for boot entry
    if( StringLength(szString, 0 )+StringLength(szTmpBuffer,0) > MAX_RES_STRING )
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        DestroyDynamicArray(&arrResults);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }
    else
    {
        //append the string containing the modified  port value to the string
        StringConcat(szString,szTmpBuffer, SIZE_OF_ARRAY(szString));
    }
    
    //remove the existing entry
    DynArrayRemove(arrResults, dwId - 1 );

    //insert the new entry
    DynArrayInsertString(arrResults, dwId - 1, szString, 0);

    // Forming the final string from all the key-value pairs
    if (stringFromDynamicArray2( arrResults,&szFinalStr) == EXIT_FAILURE)
    {
        DestroyDynamicArray(&arrResults);
        SAFEFREE(szFinalStr);
        resetFileAttrib(szPath);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }
    
    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SWITCH_CHANGE), dwId );
    }
    else
    {
        SaveLastError();
        ShowLastError(stderr);
        ShowMessage(stderr,GetResString(IDS_NO_ADD_SWITCHES));
        DestroyDynamicArray(&arrResults);
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    bRes = resetFileAttrib(szPath);

    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    SafeCloseConnection(szServer,bConnFlag);
    DestroyDynamicArray(&arrResults);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes) ;
}


VOID GetBaudRateVal(LPTSTR  szString, LPTSTR szTemp)
/*++

  Routine Description    :  Get the Type of Baud Rate  present in Boot Entry

  Parameters             : szString : The String  which is to be searched.
                           szTemp : String which will get the com port type
  Return Type            : VOID
--*/
{

    if(FindString(szString,BAUD_VAL6,0)!=0)
    {
        StringCopy(szTemp,BAUD_VAL6, MAX_RES_STRING);
    }
    else if(FindString(szString,BAUD_VAL7,0)!=0)
    {
        StringCopy(szTemp,BAUD_VAL7, MAX_RES_STRING);
    }
    else if(FindString(szString,BAUD_VAL8,0)!=0)
    {
        StringCopy(szTemp,BAUD_VAL8, MAX_RES_STRING);
    }
    else if(FindString(szString,BAUD_VAL9,0)!=0)
    {
        StringCopy(szTemp,BAUD_VAL9, MAX_RES_STRING);
    }
    else if(FindString(szString,BAUD_VAL10,0)!=0)
    {
        StringCopy(szTemp,BAUD_VAL10, MAX_RES_STRING);
    }

}

DWORD 
ProcessEmsSwitch(  IN DWORD argc, 
                   IN LPCTSTR argv[] 
                )
/*++
 Routine Description:
      Implement the ProcessEmsSwitch switch.

 Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

 Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
--*/

{
    BOOL bUsage = FALSE ;
    BOOL bNeedPwd = FALSE ;
    BOOL bEms = FALSE ;

    DWORD dwId = 0;

    TARRAY arrResults       =    NULL;
    TARRAY arrBootIni       =    NULL;

    FILE *stream = NULL;

    // Initialising the variables that are passed to TCMDPARSER structure
    WCHAR *szServer                       = NULL;
    WCHAR *szUser                         = NULL;
    WCHAR szPassword[MAX_RES_STRING+1]      = NULL_STRING;
    WCHAR szPath[MAX_RES_STRING+1]          = NULL_STRING;
    TCHAR szPort[MAX_RES_STRING+1] = NULL_STRING ;
    BOOL bRes = FALSE ;
    BOOL bFlag = FALSE ;
    DWORD dwCount = 0 ;
    TCHAR szDefault[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szString[255] = NULL_STRING ;
    TCHAR  szBaudRate[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR  szBoot[MAX_RES_STRING+1] = NULL_STRING ;
    LPTSTR szFinalStr = NULL ;
    BOOL bRedirectFlag = FALSE ;
    TCHAR szRedirectBaudrate[MAX_RES_STRING+1] = NULL_STRING ;
    BOOL bRedirectBaudFlag = FALSE ;
    DWORD dwSectionFlag = FALSE ;
    TCHAR szDebugPort[MAX_RES_STRING+1] = NULL_STRING ;
    TCHAR szBootString[MAX_RES_STRING+1] = NULL_STRING ;
    DWORD dwI = 0 ;
    LPCTSTR szToken = NULL ;
    DWORD dwRetVal = 0 ;
    BOOL bConnFlag = FALSE ;
    LPWSTR  pToken=NULL;
    LPWSTR  szTemp=NULL;
    TCMDPARSER2 cmdOptions[9];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_EMS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bEms;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;
    
    
    //usage
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //default option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwId;

        //port option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PORT;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPort;
    pcmdOption->pwszValues = EMS_PORT_VALUES;
    pcmdOption->dwLength= MAX_STRING_LENGTH;

    //baudrate option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BAUD;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY | CP2_MODE_VALUES | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szBaudRate;
    pcmdOption->pwszValues = BAUD_RATE_VALUES_EMS;
    pcmdOption->dwLength= MAX_STRING_LENGTH;


    //default on/off option
    pcmdOption = &cmdOptions[8];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDefault;
    pcmdOption->dwLength= MAX_STRING_LENGTH;


     // Parsing the ems option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

     //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
        return ( EXIT_FAILURE );
    }
    
    //display an error message if the server is empty.
    if( (cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the user enters password without entering username
    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    //if usage is specified
    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
     displayEmsUsage_X86() ;
     FreeMemory((LPVOID *)&szServer );
     FreeMemory((LPVOID *)&szUser );
     return (EXIT_SUCCESS) ;
    }

    //check whether the logged on user is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    //display error message if the user enters not any valid string.
    if( !( ( StringCompare(szDefault,VALUE_ON, TRUE, 0)== 0) || (StringCompare(szDefault,VALUE_OFF, TRUE, 0)== 0 ) ||(StringCompare(szDefault,EDIT_STRING,TRUE,0)== 0) ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }

    //display error message if either port or baud rate is not speicified along with edit option
    if( (StringCompare(szDefault,EDIT_STRING,TRUE, 0)== 0)&& (StringLengthW(szPort, 0)==0) && (StringLengthW(szBaudRate, 0)==0) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_EDIT_SYNTAX));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }

    //display error message if edit option is specified with /id option
    if( (StringCompare(szDefault,EDIT_STRING,TRUE, 0)== 0) && (cmdOptions[5].dwActuals!=0) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }
    
    //display error message if /id is not specified with on/off values
    if( ( (StringCompare(szDefault,ON_STRING,TRUE,0)== 0) || (StringCompare(szDefault,OFF_STRING,TRUE,0)== 0) )&& (cmdOptions[5].dwActuals==0) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_ID_MISSING));
        ShowMessage(stderr,GetResString(IDS_EMS_HELP));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }
    
  
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }


    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, SIZE_OF_ARRAY_IN_CHARS(szServer));
        }
    }


    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    arrResults = CreateDynamicArray();
    if(arrResults == NULL)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        SAFECLOSE(stream);
        return (EXIT_FAILURE);
    }


    arrResults = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arrResults != NULL)
    {
        //getting the number of boot entries
        dwCount = DynArrayGetCount(arrResults);

        //check the validity of boot entry
        if( (StringCompare(szDefault,SWITCH_EDIT,TRUE,0)!= 0) )
        {
            if((dwId<=0 || dwId > dwCount ) )
            {
                ShowMessage(stderr,GetResString(IDS_INVALID_OSID));
                DestroyDynamicArray(&arrResults);
                resetFileAttrib(szPath);
                SafeCloseConnection(szServer,bConnFlag);
                SAFECLOSE(stream);
                return EXIT_FAILURE ;
            }

            if( StringLengthW(DynArrayItemAsString(arrResults, dwId - 1 ), 0) > MAX_RES_STRING )
            {
                ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
                resetFileAttrib(szPath);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                SAFECLOSE(stream);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return (EXIT_FAILURE);
            }
           StringCopy(szString ,DynArrayItemAsString(arrResults, dwId - 1 ), SIZE_OF_ARRAY(szString));
           if((StringLength(szString,0)==0))
           {
               SetLastError(ERROR_NOT_ENOUGH_MEMORY);
               ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
               resetFileAttrib(szPath);
               DestroyDynamicArray(&arrResults);
               SafeCloseConnection(szServer,bConnFlag);
               FreeMemory((LPVOID *)&szServer );
               FreeMemory((LPVOID *)&szUser );
               SAFECLOSE(stream);
               return EXIT_FAILURE ;
           }
        }
    }
    else
    {
       SetLastError(ERROR_NOT_ENOUGH_MEMORY);
       ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
       resetFileAttrib(szPath);
       DestroyDynamicArray(&arrResults);
       SafeCloseConnection(szServer,bConnFlag);
       FreeMemory((LPVOID *)&szServer );
       FreeMemory((LPVOID *)&szUser );
       SAFECLOSE(stream);
       return EXIT_FAILURE ;
    }


    // common code till here . from here process acc to the ON/OFF/EDIT flag.
    if(StringCompare(szDefault,ON_STRING,TRUE,0)==0)
    {
        pToken = StrRChrW(szString, NULL, L'"');
        if(NULL== pToken)
        {
            ShowMessage(stderr,GetResString(IDS_NO_TOKENS));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        pToken++;
        
        //check if redirect port is already present
        if((FindString(pToken, REDIRECT, 0) != 0))
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_REDIRECT_SWITCH));
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        //Display an error message if there is no redirect port present in the
        // bootloader section and the user also does not specify the COM port.
        if ((StringLengthW(szPort, 0)== 0))
        {
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                DestroyDynamicArray(&arrResults);
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE;
            }
            if(StringLengthW(szBoot,0)== 0 )
            {
                ShowMessage(stderr,GetResString(IDS_ERROR_NO_PORT));
                DestroyDynamicArray(&arrResults);
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE;
            }
        }

        //display an error message if the Os Load Options string is more than
        // 254 characters in length.
        if( StringLengthW(szString, 0)+StringLengthW(TOKEN_EMPTYSPACE,0)+StringLength(REDIRECT,0) > MAX_RES_STRING)
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        //add the /redirect into the OS options.
        StringConcat(szString,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szString));
        StringConcat(szString,REDIRECT, SIZE_OF_ARRAY(szString));

        if( (StringLengthW(szPort, 0)!= 0) || (StringLengthW(szBaudRate, 0) != 0) )
        {
            //retrieve the baudrate string from the boot loader string
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,BAUDRATE_STRING,szRedirectBaudrate);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                DestroyDynamicArray(&arrResults);
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE;
            }

            //retreive the Redirect String from the Boot Loader Section
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                DestroyDynamicArray(&arrResults);
                SAFECLOSE(stream);
                resetFileAttrib(szPath);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE;
            }

            //display warning message if the redirect=COMX entry is already present in the BootLoader section.
            if( (StringLengthW(szBoot, 0)!= 0) )
            {
              if( StringLengthW(szPort, 0)!= 0 )
              {
                ShowMessage(stdout,GetResString(IDS_WARN_REDIRECT));
              }
              bRedirectFlag = TRUE ;
            }

            if( (StringLengthW(szRedirectBaudrate, 0)!=0)&&(StringLengthW(szBaudRate, 0)!= 0 ))
            {
                ShowMessage(stdout,GetResString(IDS_WARN_REDIRECTBAUD));
                bRedirectBaudFlag = TRUE ;
            }

            // if the Boot loader section does not
            // contain any port for redirection.
            if(!bRedirectFlag)
            {
                if (StringCompare(szPort,USEBIOSSET,TRUE,0)== 0)
                {
                    StringCopy(szPort,USEBIOSSETTINGS, SIZE_OF_ARRAY(szPort));
                }

                //
                // scan the entire BOOT.INI and check if the specified Port
                // is already present and if so display an error message.
                //

                if(StringLengthW(szPort, 0)!=0)
                {
                    StringCopy(szDebugPort,DEBUGPORT, SIZE_OF_ARRAY(szDebugPort));
                    StringConcat(szDebugPort,szPort, SIZE_OF_ARRAY(szDebugPort));
                }

                arrBootIni = getKeyValueOfINISection( szPath, OS_FIELD );
                if(arrBootIni == NULL)
                {
                    resetFileAttrib(szPath);
                    SafeCloseConnection(szServer,bConnFlag);
                    DestroyDynamicArray(&arrResults);
                    SAFECLOSE(stream);
                    return EXIT_FAILURE ;
                }

                //
                //loop through all the OS entries and check.
                //
                for(dwI = 0 ;dwI <= dwCount-1 ; dwI++ )
                {
                    szTemp = (LPWSTR)DynArrayItemAsString(arrBootIni,dwI);

                    if(StringLengthW(szDebugPort, 0) !=0 )
                    {
                        CharLower(szDebugPort);

                        if(FindString(szTemp,szDebugPort, 0)!= 0)
                        {
                            ShowMessage( stderr, GetResString(IDS_ERROR_DEBUG_PORT));
                            resetFileAttrib(szPath);
                            SafeCloseConnection(szServer,bConnFlag);
                            DestroyDynamicArray(&arrResults);
                            DestroyDynamicArray(&arrBootIni);
                            SAFECLOSE(stream);
                            FreeMemory((LPVOID *)&szServer );
                            FreeMemory((LPVOID *)&szUser );
                            return EXIT_FAILURE ;
                        }
                    }
                }
                //no need free it
                DestroyDynamicArray(&arrBootIni);

                //convert the com port value specified by user to upper case for storing into the ini file.
                CharUpper(szPort);
                if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_REDIRECT,szPort, szPath ) != 0 )
                {
                    ShowMessage(stdout,GetResString(IDS_EMS_CHANGE_BOOTLOADER));
                }
                else
                {
                    ShowMessage(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BLOADER));
                    resetFileAttrib(szPath);
                    SafeCloseConnection(szServer,bConnFlag);
                    DestroyDynamicArray(&arrResults);
                    SAFECLOSE(stream);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
        }

        if(!bRedirectBaudFlag)
        {
            //add the baudrate to the BOOTLOADER section.
            if(StringLengthW(szBaudRate, 0) != 0 )
            {
                if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_BAUDRATE,szBaudRate, szPath ) != 0 )
                {
                    ShowMessage(stdout,GetResString(IDS_EMS_CHANGE_BAUDRATE));
                }
                else
                {
                    ShowMessage(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BAUDRATE));
                    resetFileAttrib(szPath);
                    SafeCloseConnection(szServer,bConnFlag);
                    DestroyDynamicArray(&arrResults);
                    SAFECLOSE(stream);
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
        }

        DynArrayRemove(arrResults, dwId - 1 );

        DynArrayInsertString(arrResults, dwId - 1, szString, 0);

        if (stringFromDynamicArray2( arrResults,&szFinalStr) == EXIT_FAILURE)
        {
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            return EXIT_FAILURE;
        }

         // Writing to the profile section with new key-value pair
         // If the return value is non-zero, then there is an error.
         if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
         {
            ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SWITCH_CHANGE), dwId );
         }
        else
        {
            ShowMessage(stderr,GetResString(IDS_NO_ADD_SWITCHES));
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
    }

    if(StringCompare(szDefault,EDIT_STRING,TRUE,0)==0)
    {
        if (StringCompare(szPort,USEBIOSSET,TRUE,0)== 0)
        {
            StringCopy(szPort,USEBIOSSETTINGS, SIZE_OF_ARRAY(szPort));
        }

        //get the keys of the specified ini section.
        dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,BAUDRATE_STRING,szRedirectBaudrate);
        if (dwSectionFlag == EXIT_FAILURE)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        //get the keys of the specified ini section.
        dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
        if (dwSectionFlag == EXIT_FAILURE)
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        if( (StringLengthW(szRedirectBaudrate, 0) == 0 ) && ((cmdOptions[7].dwActuals!=0)) )
        {
            ShowMessage( stderr,GetResString(IDS_ERROR_BAUDRATE_HELP));
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        if(StringLengthW(szPort, 0) != 0)
        {
            StringCopy(szDebugPort,DEBUGPORT, SIZE_OF_ARRAY(szDebugPort));
            StringConcat(szDebugPort,szPort, SIZE_OF_ARRAY(szDebugPort));
        }

        //get the all boot entries and
        //loop through all the OS entries and check if any of the
        //boot entries contain the same port 
        arrBootIni = getKeyValueOfINISection( szPath, OS_FIELD );
        if(arrBootIni == NULL)
        {
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if(StringLengthW(szDebugPort, 0)!=0)
        {
            for(dwI = 0 ;dwI < dwCount-1 ; dwI++ )
            {
                StringCopy(szBootString ,DynArrayItemAsString(arrBootIni,dwI), MAX_RES_STRING);
                CharLower(szDebugPort);
                if(FindString(szBootString,szDebugPort, 0)!= 0)
                {
                    ShowMessage( stderr, GetResString(IDS_ERROR_DEBUG_PORT));
                    resetFileAttrib(szPath);
                    SafeCloseConnection(szServer,bConnFlag);
                    DestroyDynamicArray(&arrResults);
                    DestroyDynamicArray(&arrBootIni);
                    SAFECLOSE(stream);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
        }
   
        //free it, no need
        DestroyDynamicArray(&arrBootIni);

        // edit the Boot loader section with the redirect values entered by the user.
        CharUpper(szPort);
        if(StringLengthW(szPort, 0)!= 0)
        {
            if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_REDIRECT, szPort, szPath ) != 0 )
            {
                ShowMessage(stdout,GetResString(IDS_EMS_CHANGE_BOOTLOADER));
            }
            else
            {
                ShowMessage(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BLOADER));
                resetFileAttrib(szPath);
                SAFEFREE(szFinalStr);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                SAFECLOSE(stream);
                return EXIT_FAILURE ;
            }
        }

        // edit the Boot loader section with the baudrate values entered by the user.
        if(StringLengthW(szBaudRate, 0)!= 0)
        {
            if( WritePrivateProfileString( BOOTLOADERSECTION,KEY_BAUDRATE, szBaudRate, szPath ) != 0 )
            {
                    ShowMessage(stdout,GetResString(IDS_EMS_CHANGE_BAUDRATE));
            }
            else
            {
                ShowMessage(stderr,GetResString(IDS_EMS_CHANGE_ERROR_BAUDRATE));
                resetFileAttrib(szPath);
                SAFEFREE(szFinalStr);
                DestroyDynamicArray(&arrResults);
                SAFECLOSE(stream);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }
        }
    }

    // if the option value is off.
    if(StringCompare(szDefault,VALUE_OFF,TRUE,0)==0)
    {
        //display an error message if either the com port or baud rate is typed in the command line
        if((StringLengthW(szBaudRate, 0)!=0)||(StringLengthW(szPort, 0)!=0))
        {
            ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_EMS));
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        // display error message if the /redirect  switch is not present in the Boot.ini
        pToken = StrRChrW(szString , NULL, L'"') ;
        if((FindString(pToken,REDIRECT,0) == 0))
        {
            ShowMessage(stderr,GetResString(IDS_NO_REDIRECT_SWITCH));
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

        //remove the /redirect switch from the OS entry specified .
        if( EXIT_FAILURE == removeSubString(szString,REDIRECT) )
        {
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            DestroyDynamicArray(&arrResults);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }

        //display an error message if the Os Load options string is more than
        // 255 characters in length.

        if( StringLengthW(szString, 0) > MAX_RES_STRING)
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            return (EXIT_FAILURE);
        }

        DynArrayRemove(arrResults, dwId - 1 );

        DynArrayInsertString(arrResults, dwId - 1, szString, 0);
        if (stringFromDynamicArray2( arrResults,&szFinalStr) == EXIT_FAILURE)
        {
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE;
        }

         // Writing to the profile section with new key-value pair
         // If the return value is non-zero, then there is an error.
        if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
        {   
            ShowMessageEx(stdout, 1, TRUE,  GetResString(IDS_SWITCH_CHANGE), dwId );
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_NO_ADD_SWITCHES));
            DestroyDynamicArray(&arrResults);
            SAFEFREE(szFinalStr);
            resetFileAttrib(szPath);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }


        /********************************************/
        // scan the entire BOOT.INI and check if the specified Port
        // is already present and if so display an error message.
        //

        StringCopy(szRedirectBaudrate,REDIRECT_SWITCH, SIZE_OF_ARRAY(szRedirectBaudrate));

        arrBootIni = getKeyValueOfINISection( szPath, OS_FIELD );
        if(arrBootIni == NULL)
        {
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            DestroyDynamicArray(&arrResults);
            SAFECLOSE(stream);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        //
        //set the Flag to False.
        //
        bFlag = FALSE ;

        //
        // Loop through all the OS entries and check if any of the
        // entries contain the /redirect switch.If not then set the
        // flag to TRUE and remove the entries from Boot Loader section.

        for(dwI = 0 ;dwI < dwCount ; dwI++ )
         {
             szTemp = (LPWSTR)DynArrayItemAsString(arrBootIni,dwI);
             pToken = StrRChrW(szTemp , NULL, L'"') ;
             if(NULL== pToken)
             {
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arrResults);
                DestroyDynamicArray(&arrBootIni);
                SafeCloseConnection(szServer,bConnFlag);
             }
             pToken++;
             CharLower(szRedirectBaudrate);
             if( FindString(pToken, szRedirectBaudrate, 0)!= 0)
             {
                bFlag = TRUE ;
             }
         }
         //free it, no need
         DestroyDynamicArray(&arrBootIni);

        if(FALSE == bFlag )
        {
            // First check if the Redirect section is present and if so delete
            // the section.
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,REDIRECT_STRING,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                ShowLastError(stderr);
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
            }

            //If the Redirect section is present then delete it.
            if( StringLengthW(szBoot, 0) != 0)
            {
                if(TRUE== deleteKeyFromINISection(KEY_REDIRECT,szPath,BOOTLOADERSECTION))
                {
                    ShowMessage(stdout,GetResString(IDS_REDIRECT_REMOVED));
                }
                else
                {
                    ShowMessage(stdout,GetResString(IDS_ERROR_REDIRECT_REMOVED));
                    SAFEFREE(szFinalStr);
                    SAFECLOSE(stream);
                    bRes = resetFileAttrib(szPath);
                    DestroyDynamicArray(&arrResults);
                    SafeCloseConnection(szServer,bConnFlag);
                }
            }

            // First check if the Redirect section is present and if so delete
            // the section.
            dwSectionFlag = getKeysOfSpecifiedINISection(szPath ,BOOTLOADERSECTION,KEY_BAUDRATE,szBoot);
            if (dwSectionFlag == EXIT_FAILURE)
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arrResults);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE;
            }

            // First check if the Redirection baudrate section is present and if so delete
            // the section.
            if(StringLengthW(szBoot, 0)!=0)
            {
                if(TRUE == deleteKeyFromINISection(KEY_BAUDRATE,szPath,BOOTLOADERSECTION))
                {
                    ShowMessage(stdout,GetResString(IDS_BAUDRATE_REMOVED));
                }
                else
                {
                    ShowMessage(stdout,GetResString(IDS_ERROR_BAUDRATE_REMOVED));
                    SAFEFREE(szFinalStr);
                    SAFECLOSE(stream);
                    bRes = resetFileAttrib(szPath);
                    DestroyDynamicArray(&arrResults);
                     SafeCloseConnection(szServer,bConnFlag);
                }
            }
        }
    }



    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arrResults);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes) ;
}

VOID displayEmsUsage_X86()
/*++
  Routine Description        :  Display the help for the Ems entry option (X86).

  Parameters                 : none

  Return Type                : VOID
--*/
{
    DWORD dwIndex = IDS_EMS_BEGIN_X86 ;
    for(;dwIndex <=IDS_EMS_END_X86;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayDebugUsage_X86()
/*++
   Routine Description           :  Display the help for the Debug  entry option (X86).

  Parameters                     : none

  Return Type                    : VOID
--*/
{
    DWORD dwIndex = IDS_DEBUG_BEGIN_X86 ;
    for(;dwIndex <=IDS_DEBUG_END_X86;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayEmsUsage_IA64()
/*++
  Routine Description        :  Display the help for the Ems entry option (IA64).

  Parameters         : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = IDS_EMS_BEGIN_IA64 ;
    for(;dwIndex <=IDS_EMS_END_IA64;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayDebugUsage_IA64()
/*++
  Routine Description        :  Display the help for the Debug  entry option (IA64).

  Parameters         : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = IDS_DEBUG_BEGIN_IA64 ;
    for(;dwIndex <= IDS_DEBUG_END_IA64 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

DWORD
getKeysOfSpecifiedINISection( 
                             IN LPTSTR sziniFile, 
                             IN LPTSTR sziniSection,
                             IN LPCWSTR szKeyName ,
                             OUT LPTSTR szValue
                             )
/*++
  Routine Description        : This function gets all the keys present in the specified section of
                               an .ini file and then returns the dynamic array containing all the
                               keys

  Parameters                 : LPTSTR sziniFile (in)    - Name of the ini file.
                               LPTSTR szinisection (in) - Name of the section in the boot.ini.

  Return Type        : EXIT_SUCCESS if successfully returns
                       EXIT_FAILURE otherwise
--*/
{

    // Number of characters returned by the GetPrivateProfileString function
    DWORD   len         = 0;
    DWORD   dwLength    = MAX_STRING_LENGTH1 ;
    LPTSTR  inBuf       = NULL ;
    BOOL    bNobreak    = TRUE;

    
    inBuf = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));

    if(inBuf == NULL)
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        SaveLastError();
        return EXIT_FAILURE ;
    }

    do
    {
        // Getting all the keys from the boot.ini file
        len = GetPrivateProfileString( sziniSection,
                             szKeyName,
                             ERROR_PROFILE_STRING1,
                             inBuf,
                             dwLength,
                             sziniFile);

        //if the size of the string is not sufficient then increment the size.
        if(len == dwLength-2)
        {
            dwLength +=100 ;

            if ( inBuf != NULL )
            {
                FreeMemory((LPVOID *) &inBuf );
                inBuf = NULL;
            }

            inBuf = (LPTSTR)AllocateMemory(dwLength*sizeof(TCHAR));
            if(inBuf == NULL)
            {
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                SaveLastError();
                return EXIT_FAILURE;
            }
        }
        else
        {
            bNobreak = FALSE;
            break ;
        }
    }while(TRUE == bNobreak);

    //copy the value into the destination buffer only if
    // the size is less than 255 else return FAILURE.
    //
    if(StringLengthW(inBuf, 0) <= MAX_RES_STRING)
    {
        StringCopy(szValue,inBuf, MAX_RES_STRING);
    }
    else
    {
        SAFEFREE(inBuf);
        SetReason(GetResString(IDS_STRING_TOO_LONG)); 
        return EXIT_FAILURE;
    }

    SAFEFREE(inBuf);
    return EXIT_SUCCESS ;
}

DWORD 
ProcessAddSwSwitch(  IN DWORD argc, 
                     IN LPCTSTR argv[] 
                  )
/*++
 Routine Description:
      Implement the Add Switch switch.

 Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

 Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
--*/
{

    BOOL bUsage = FALSE ;
    BOOL bNeedPwd = FALSE ;
    BOOL bAddSw = FALSE ;
    DWORD dwDefault = 0;
    TARRAY arr      =   NULL;
    TCHAR szkey[MAX_RES_STRING+1] = NULL_STRING;
    FILE *stream = NULL;
    WCHAR *szServer                       = NULL;
    WCHAR *szUser                         = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]      = NULL_STRING;
    WCHAR szPath[MAX_STRING_LENGTH]          = NULL_STRING;
    WCHAR szBuffer[MAX_RES_STRING+1]          = NULL_STRING;
    DWORD dwNumKeys = 0;
    BOOL bRes = FALSE ;
    LPTSTR szFinalStr = NULL ;
    BOOL bFlag = FALSE ;
    TCHAR szMaxmem[10] = NULL_STRING ;
    BOOL bBaseVideo = FALSE ;
    BOOL bSos = FALSE ;
    BOOL bNoGui = FALSE ;
    DWORD dwMaxmem = 0 ;
    LPCTSTR szToken = NULL ;
    DWORD dwRetVal = 0 ;
    BOOL bConnFlag = FALSE ;
    TCMDPARSER2 cmdOptions[10];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_ADDSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bAddSw;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;
    
     //id usage
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //default option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

   //maxmem  option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_MAXMEM;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwMaxmem;

   //basvideo option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BASEVIDEO;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bBaseVideo;

   //nogui option
    pcmdOption = &cmdOptions[8];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_NOGUIBOOT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bNoGui;

   //nogui option
    pcmdOption = &cmdOptions[9];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bSos;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );


    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
        return ( EXIT_FAILURE );
    }

    if( (cmdOptions[6].dwActuals!=0) && (dwMaxmem < 32 ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_MAXMEM_VALUES));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the server is empty.
    if((cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }
    
    //display  an error if password specified without user name
    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //if usage is specified
    if(bUsage)
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
      displayAddSwUsage_X86();
      FreeMemory( (LPVOID *) &szServer );
      FreeMemory( (LPVOID *) &szUser );
      return EXIT_SUCCESS;
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

   //display an error message if the user does not enter even one of
    if((dwMaxmem==0)&& (!bBaseVideo)&& (!bNoGui)&&(!bSos) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //for setting the bNeedPwd
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));

                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, GetBufferSize(szServer)/sizeof(WCHAR));
        }
    }

     bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    //display warning message if local credentials are supplied    
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    // Getting the keys of the Operating system section in the boot.ini file
    arr = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arr == NULL)
    {
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    // Getting the total number of keys in the operating systems section
    dwNumKeys = DynArrayGetCount(arr);

    // Displaying error message if the number of keys is less than the OS entry
    // line number specified by the user
    if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    // Getting the key of the OS entry specified by the user
    if (arr != NULL)
    {
        LPCWSTR pwsz = NULL;
        pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
        if( StringLengthW(pwsz,0) > MAX_RES_STRING)
        {
            ShowMessage( stderr,GetResString(IDS_STRING_TOO_LONG));
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            resetFileAttrib(szPath);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE;
        }

        if(pwsz != NULL)
        {
            StringCopy( szkey,pwsz, SIZE_OF_ARRAY(szkey));
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //if the  max mem switch is specified by the user.
    if(dwMaxmem != 0)
    {

        if(FindString(szkey,MAXMEM_VALUE1,0) != 0)
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_MAXMEM_SWITCH));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( StringLength( szBuffer, 0 ) == 0 )
            {
               StringCopy( szBuffer, TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            else
            {
                StringConcat(szBuffer , TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            StringConcat(szBuffer ,MAXMEM_VALUE1, SIZE_OF_ARRAY(szBuffer));
            StringConcat(szBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szBuffer));
            _ltow(dwMaxmem,szMaxmem,10);
            StringConcat(szBuffer,szMaxmem, SIZE_OF_ARRAY(szBuffer));
        }
    }

    // if the base video is specified by the user.
    if (bBaseVideo)
    {
        if(FindString(szkey,BASEVIDEO_VALUE, 0) != 0)
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_BASEVIDEO_SWITCH));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( StringLength( szBuffer, 0 ) == 0 )
            {
               StringCopy( szBuffer, TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            else
            {
                StringConcat(szBuffer , TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            StringConcat(szBuffer ,BASEVIDEO_SWITCH, SIZE_OF_ARRAY(szBuffer));
        }
    }

    // if the SOS is specified by the user.
   if(bSos)
    {
        if(FindString(szkey,SOS_VALUE, 0) != 0)
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_SOS_SWITCH ) );
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( StringLength( szBuffer, 0 ) == 0 )
            {
               StringCopy( szBuffer, TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            else
            {
                StringConcat(szBuffer , TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            StringConcat(szBuffer ,SOS_SWITCH, SIZE_OF_ARRAY(szBuffer));
        }
    }

   // if the noguiboot  is specified by the user.
   if(bNoGui)
    {
        if(_tcsstr(szkey,NOGUI_VALUE) != 0)
        {
            ShowMessage(stderr,GetResString(IDS_DUPL_NOGUI_SWITCH));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( StringLength( szBuffer, 0 ) == 0 )
            {
               StringCopy( szBuffer, TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            else
            {
                StringConcat(szBuffer , TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            }
            StringConcat(szBuffer ,NOGUI_VALUE, SIZE_OF_ARRAY(szBuffer) );
        }
    }

    if( StringLengthW(szkey, 0)+StringLengthW(szBuffer, 0) > MAX_RES_STRING)
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE;
    }
    else
    {
        StringConcat(szkey , szBuffer, SIZE_OF_ARRAY(szkey));
    }

    DynArrayRemove(arr, dwDefault - 1 );

    DynArrayInsertString(arr, dwDefault - 1, szkey, 0);

    // Setting the buffer to 0, to avoid any junk value
    if (stringFromDynamicArray2( arr,&szFinalStr) == EXIT_FAILURE)
    {
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE;
    }

    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {

        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SWITCH_ADD), dwDefault );
    }
    else
    {
        ShowMessage(stderr,GetResString(IDS_NO_ADD_SWITCHES));
        DestroyDynamicArray(&arr);
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    //reset the file attributes and free the memory and close the connection to the server.
    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arr);
    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory( (LPVOID *) &szServer );
    FreeMemory( (LPVOID *) &szUser );
    return (bRes);
}

DWORD
ProcessRmSwSwitch( IN DWORD argc, 
                   IN LPCTSTR argv[] 
                  )
/*++
 Routine Description:
      This routine is to remove  the switches to the  boot.ini file settings for
      the specified system.
 Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

 Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
--*/
{

    BOOL        bUsage                          = FALSE ;
    BOOL        bNeedPwd                        = FALSE ;
    BOOL        bRmSw                           = FALSE ;
    DWORD       dwDefault                       = 0;
    TARRAY      arr                             = NULL ;
    TCHAR       szkey[255]                      = NULL_STRING;
    FILE        *stream                         = NULL;
    WCHAR       *szServer                       = NULL;
    WCHAR       *szUser                         = NULL;
    WCHAR       szPassword[MAX_STRING_LENGTH]   = NULL_STRING;
    WCHAR       szPath[MAX_RES_STRING+1]          = NULL_STRING;
    DWORD       dwNumKeys                       = 0;
    BOOL        bRes                            = FALSE ;
    LPTSTR      szFinalStr                      = NULL ;
    BOOL        bFlag                           = FALSE ;
    BOOL        bBaseVideo                      = FALSE ;
    BOOL        bSos                            = FALSE ;
    BOOL        bNoGui                          = FALSE ;
    BOOL        bMaxmem                         = 0;
    TCHAR       szTemp[MAX_RES_STRING+1]          = NULL_STRING ;
    TCHAR       szErrorMsg[MAX_RES_STRING+1]      = NULL_STRING ;
    WCHAR       szSubString[MAX_STRING_LENGTH]  = NULL_STRING;
    DWORD       dwCode                          = 0;
    LPCTSTR     szToken                         = NULL ;
    DWORD       dwRetVal                        = 0;
    BOOL            bConnFlag                   = FALSE ;
    TCMDPARSER2     cmdOptions[10];
    PTCMDPARSER2    pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_RMSW;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bRmSw;
    
    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;
    
     //id usage
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //default option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwFlags = CP_VALUE_MANDATORY  | CP2_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

   //maxmem  option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_MAXMEM;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bMaxmem;

   //basvideo option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_BASEVIDEO;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bBaseVideo;

   //nogui option
    pcmdOption = &cmdOptions[8];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_NOGUIBOOT;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bNoGui;

   //sos option
    pcmdOption = &cmdOptions[9];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SOS;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bSos;

     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );
    
    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_RMSW));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if((cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser, 0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }
    
    //display  an error if password specified without user name
    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }


    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
        displayRmSwUsage_X86();
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_SUCCESS);
    }

    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    //display an error message if the user does not enter even one of
    if((!bMaxmem)&& (!bBaseVideo)&& (!bNoGui)&&(!bSos) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_ADDSW));
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }



    //for setting the bNeedPwd
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, MAX_RES_STRING);
        }
    }

    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    //display warning message if local credentials are supplied
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    // Getting the keys of the Operating system section in the boot.ini file
    arr = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arr == NULL)
    {
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    // Getting the total number of keys in the operating systems section
    dwNumKeys = DynArrayGetCount(arr);

    // Displaying error message if the number of keys is less than the OS entry
    // line number specified by the user
    if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    // Getting the key of the OS entry specified by the user
    if (arr != NULL)
    {
        LPCWSTR pwsz = NULL;
        pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
        if(StringLengthW(pwsz,0) > MAX_RES_STRING )
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
            ShowMessage( stderr,szErrorMsg);
            ShowLastError(stderr);
            bRes = resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }

        if(pwsz != NULL)
        {
            StringCopy( szkey,pwsz, SIZE_OF_ARRAY(szkey));
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
            bRes = resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowMessage( stderr, ERROR_TAG);
        ShowLastError(stderr);
        bRes = resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE ;
    }

    //if the  max mem switch is specified by the user.
    if(bMaxmem==TRUE)
    {
        if(FindString(szkey,MAXMEM_VALUE1,0) == 0)
        {
            ShowMessage(stderr,GetResString(IDS_NO_MAXMEM_SWITCH));
            bRes = resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {

            StringCopy(szTemp,NULL_STRING, MAX_RES_STRING);
            dwCode = GetSubString(szkey,MAXMEM_VALUE1,szSubString);

            //remove the substring specified.
            if(dwCode == EXIT_SUCCESS)
            {
                if( EXIT_FAILURE == removeSubString(szkey,szSubString) )
                {
                    resetFileAttrib(szPath);
                    SAFECLOSE(stream);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory( (LPVOID *) &szServer );
                    FreeMemory( (LPVOID *) &szUser );
                    return (EXIT_FAILURE);
                }
            }
        }
    }

    // if the base video is specified by the user.
    if (bBaseVideo==TRUE)
    {
        if(FindString(szkey,BASEVIDEO_VALUE, 0) == 0)
        {
            ShowMessage(stderr,GetResString(IDS_NO_BV_SWITCH));
            bRes = resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( EXIT_FAILURE == removeSubString(szkey,BASEVIDEO_VALUE) )
            {
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arr);
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory( (LPVOID *) &szServer );
                FreeMemory( (LPVOID *) &szUser );
                return (EXIT_FAILURE);
            }
        }
    }

    // if the SOS is specified by the user.
   if(bSos==TRUE)
    {
        if(FindString(szkey,SOS_VALUE, 0) == 0)
        {
            ShowMessage(stderr,GetResString(IDS_NO_SOS_SWITCH ) );
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            if( EXIT_FAILURE == removeSubString(szkey,SOS_VALUE) )
            {
                bRes = resetFileAttrib(szPath);
                DestroyDynamicArray(&arr);
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory( (LPVOID *) &szServer );
                FreeMemory( (LPVOID *) &szUser );
                return (EXIT_FAILURE);
            }
        }
    }

   // if the noguiboot  is specified by the user.
   if(bNoGui==TRUE)
    {

        if(FindString(szkey,NOGUI_VALUE, 0) == 0)
        {
            ShowMessage(stderr,GetResString(IDS_NO_NOGUI_SWITCH));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory( (LPVOID *) &szServer );
            FreeMemory( (LPVOID *) &szUser );
            return EXIT_FAILURE ;
        }
        else
        {
                if( EXIT_FAILURE == removeSubString(szkey,NOGUI_VALUE) )
                {
                    resetFileAttrib(szPath);
                    DestroyDynamicArray(&arr);
                    SAFEFREE(szFinalStr);
                    SAFECLOSE(stream);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory( (LPVOID *) &szServer );
                    FreeMemory( (LPVOID *) &szUser );
                    return EXIT_FAILURE ;
                }
        }
    }

    DynArrayRemove(arr, dwDefault - 1 );

    //DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_STRING_LENGTH1);

    DynArrayInsertString(arr, dwDefault - 1, szkey, 0);
    if (stringFromDynamicArray2( arr,&szFinalStr) == EXIT_FAILURE)
    {
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return EXIT_FAILURE;
    }


    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {
       ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SWITCH_DELETE), dwDefault );
    }
    else
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_NO_SWITCH_DELETE), dwDefault );
        DestroyDynamicArray(&arr);
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
        return (EXIT_FAILURE);
    }

    //reset the file attributes and free the memory and close the connection to the server.
    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arr);
    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    SafeCloseConnection(szServer,bConnFlag);
        FreeMemory( (LPVOID *) &szServer );
        FreeMemory( (LPVOID *) &szUser );
    return (EXIT_SUCCESS);
}

VOID displayAddSwUsage_X86()
/*++
  Routine Description  :  Display the help for the AddSw entry option (X86).

  Parameters           : none

  Return Type          : VOID

--*/
{
    DWORD dwIndex = IDS_ADDSW_BEGIN_X86 ;
    for(;dwIndex <=IDS_ADDSW_END_X86;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayAddSwUsage_IA64()
/*++
  Routine Description  :  Display the help for the AddSw entry option (IA64).

  Arguments               : none

  Return Type              : VOID
--*/
{
    DWORD dwIndex = IDS_ADDSW_BEGIN_IA64 ;
    for(;dwIndex <=IDS_ADDSW_END_IA64;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayRmSwUsage_IA64()
/*++
  Routine Description  :  Display the help for the RmSw entry option (IA64).

  Arguments          : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = IDS_RMSW_BEGIN_IA64 ;
    for(;dwIndex <=IDS_RMSW_END_IA64;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID displayRmSwUsage_X86()
/*++
  Routine Description  :   Display the help for the RmSw entry option (X86).

  Arguments          : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = IDS_RMSW_BEGIN_X86 ;
    for(;dwIndex <=IDS_RMSW_END_X86;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

DWORD 
GetSubString( IN LPTSTR szString,
              IN LPTSTR szPartString,
              OUT LPTSTR pszFullString
             )
/*++
  Routine Description         :  This function retreives a part of the string.

  Parameters                  :
          LPTSTR szString (in)  - String in which substring is to be found.
          LPTSTR szPartString (in)  - Part String whose remaining substring is to be found.
          LPTSTR pszFullString (out)  - String in which substring is to be found.

  Return Type        : DWORD
--*/
{

    TCHAR szTemp[255]= NULL_STRING ;
    LPTSTR pszMemValue = NULL ;
    LPTSTR pszdest = NULL ;

#ifndef _WIN64
    DWORD dwPos = 0;
#else
    INT64 dwPos = 0;
#endif

    pszMemValue = (LPTSTR)FindString(szString,szPartString,0);
    if(pszMemValue == NULL)
    {
        return EXIT_FAILURE ;
    }

    //copy the remaining part of the string into a buffer
    StringCopy(szTemp,pszMemValue, SIZE_OF_ARRAY(szTemp));

    //search for the empty space.
    pszdest = StrChrW(szTemp,_T(' '));
    if (NULL == pszdest)
    {
        //the api returns NULL if it is not able to find the
        // character . This means that the required switch is at the end
        //of the string . so we are copying it fully
        StringCopy(pszFullString,szTemp, MAX_RES_STRING);
        return EXIT_SUCCESS ;
    }

    dwPos = pszdest - szTemp ;
    szTemp[dwPos] = _T('\0');

    StringCopy(pszFullString,szTemp, MAX_RES_STRING);
    return EXIT_SUCCESS ;
}

DWORD 
ProcessDbg1394Switch( IN DWORD argc, 
                      IN LPCTSTR argv[] 
                     )
/*++
 Routine Description:
      This routine is to add/remove  the /debugport=1394
     switches to the  boot.ini file settings for the specified system.
 Arguments:
      [IN]    argc  Number of command line arguments
      [IN]    argv  Array containing command line arguments

 Return Value:
      DWORD (EXIT_SUCCESS for success and EXIT_FAILURE for Failure.)
--*/
{

    BOOL bUsage                             = FALSE ;
    BOOL bNeedPwd                           = FALSE ;
    BOOL bDbg1394                           = FALSE ;
    DWORD dwDefault                         = 0;
    TARRAY arr                              = NULL;
    TCHAR szkey[MAX_RES_STRING+2]           = NULL_STRING;
    FILE *stream                            = NULL;
    WCHAR *szServer                         = NULL;
    WCHAR *szUser                           = NULL;
    WCHAR szPassword[MAX_STRING_LENGTH]     = NULL_STRING;
    WCHAR szPath[MAX_STRING_LENGTH]         = NULL_STRING;
    DWORD dwNumKeys                         = 0;
    BOOL bRes                               = FALSE ;
    LPTSTR szFinalStr                       = NULL ;
    BOOL bFlag                              = FALSE ;
    TCHAR szDefault[MAX_STRING_LENGTH]      = NULL_STRING ;
    TCHAR szTemp[MAX_RES_STRING+1]            = NULL_STRING ;
    TCHAR szBuffer[MAX_RES_STRING+1]            = NULL_STRING ;
    LPTSTR szSubString                      = NULL ;
    DWORD dwCode                            = 0;
    DWORD dwChannel                         = 0;
    TCHAR szChannel[MAX_RES_STRING+1]         = NULL_STRING ;
    LPCTSTR szToken                         = NULL ;
    DWORD dwRetVal                          = 0 ;
    BOOL bConnFlag                          = FALSE ;

    TCMDPARSER2 cmdOptions[8];
    PTCMDPARSER2 pcmdOption;

    SecureZeroMemory(cmdOptions, SIZE_OF_ARRAY(cmdOptions)*sizeof(TCMDPARSER2) );

    //copy * to szPassword
    StringCopy( szPassword, L"*", SIZE_OF_ARRAY(szPassword) );

    //main option
    pcmdOption = &cmdOptions[0];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DBG1394;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bDbg1394;

    //server option
    pcmdOption = &cmdOptions[1];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_SERVER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //user option
    pcmdOption = &cmdOptions[2];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_USER;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;

    //password option
    pcmdOption = &cmdOptions[3];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_PASSWORD;
    pcmdOption->dwFlags = CP2_VALUE_OPTIONAL;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szPassword;
    pcmdOption->dwLength= MAX_STRING_LENGTH;


     // usage
    pcmdOption = &cmdOptions[4];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_USAGE;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bUsage;

    //default option
    pcmdOption = &cmdOptions[5];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = SWITCH_ID;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwDefault;

   //id option
    pcmdOption = &cmdOptions[6];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_CHANNEL;
    pcmdOption->dwFlags =  CP_VALUE_MANDATORY;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &dwChannel;

    //on/off option
    pcmdOption = &cmdOptions[7];
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = CMDOPTION_DEFAULT;
    pcmdOption->dwFlags = CP2_DEFAULT | CP2_MANDATORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = szDefault;
    pcmdOption->dwLength= MAX_STRING_LENGTH;


     // Parsing the copy option switches
    if ( !DoParseParam2( argc, argv, 0, SIZE_OF_ARRAY(cmdOptions ), cmdOptions, 0 ) )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return (EXIT_FAILURE);
    }
   
    szServer = cmdOptions[1].pValue;
    szUser = cmdOptions[2].pValue;
    if( NULL == szUser )
    {
        szUser = (WCHAR *)AllocateMemory( MAX_STRING_LENGTH*sizeof(WCHAR) );
        if( NULL == szUser )
        {
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
            return (EXIT_FAILURE);
        }
    }

    TrimString( szServer, TRIM_ALL );
    TrimString( szUser, TRIM_ALL );

    //check if usage is specified with more than one option
    if( (TRUE == bUsage) && (argc > 3) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
        return ( EXIT_FAILURE );
    }

    //display an error message if the server is empty.
    if((cmdOptions[1].dwActuals!=0)&&(StringLengthW(szServer, 0)==0))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_SERVER));
        return EXIT_FAILURE ;
    }

    //display an error message if the user is empty.
    if((cmdOptions[2].dwActuals!=0)&&(StringLengthW(szUser,0)==0 ))
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_NULL_USER));
        return EXIT_FAILURE ;
    }

    // Displaying query usage if user specified -? with -query option
    if( bUsage )
    {
        if( CheckSystemType(szServer) == EXIT_FAILURE )
        {
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return (EXIT_FAILURE);
        }
       displayDbg1394Usage_X86();
       FreeMemory((LPVOID *)&szServer );
       FreeMemory((LPVOID *)&szUser );
       return (EXIT_SUCCESS);
    }


    //check whether he is administrator or not
    if( IsLocalSystem(szServer) )
    {
        if( !IsUserAdmin() )
        {
            ShowMessage( stderr, GetResString(IDS_NOT_ADMINISTRATOR_32 ));
            ReleaseGlobals();
            return EXIT_FAILURE;
        }
    }

    //
    //display error message if user enters a value
    // other than on or off
    //
    if( ( StringCompare(szDefault,OFF_STRING,TRUE,0)!=0 ) && (StringCompare(szDefault,ON_STRING,TRUE,0)!=0 ) )
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_DEFAULT_MISSING));
        ShowMessage(stderr,GetResString(IDS_1394_HELP));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    if(( StringCompare(szDefault,OFF_STRING,TRUE,0)==0 ) && (cmdOptions[6].dwActuals != 0) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_SYNTAX_DBG1394));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    if(( StringCompare(szDefault,ON_STRING,TRUE,0)==0 ) && (cmdOptions[6].dwActuals == 0) )
    {
        ShowMessage(stderr,GetResString(IDS_MISSING_CHANNEL));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }


    if( ( StringCompare(szDefault,ON_STRING,TRUE,0)==0 ) && (cmdOptions[6].dwActuals != 0) && ( (dwChannel < 1) ||(dwChannel > 64 )) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_CH_RANGE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }


    //display error message if the username is entered with out a machine name
    if( (cmdOptions[1].dwActuals == 0)&&(cmdOptions[2].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_USER_BUT_NOMACHINE));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    if( (cmdOptions[2].dwActuals == 0)&&(cmdOptions[3].dwActuals != 0))
    {
        ShowMessage(stderr, GetResString(IDS_PASSWD_BUT_NOUSER));
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }


    //for setting the bNeedPwd
    if(IsLocalSystem( szServer ) == FALSE )
    {
        // set the bNeedPwd to True or False .
        if ( cmdOptions[3].dwActuals != 0 &&
             szPassword != NULL && StringCompare( szPassword, _T( "*" ), TRUE, 0 ) == 0 )
        {
            // user wants the utility to prompt for the password before trying to connect
            bNeedPwd = TRUE;
        }
        else if ( cmdOptions[ 3 ].dwActuals == 0 &&
                ( cmdOptions[ 1 ].dwActuals != 0 || cmdOptions[ 2 ].dwActuals != 0 ) )
        {
            // -s, -u is specified without password ...
            // utility needs to try to connect first and if it fails then prompt for the password
            bNeedPwd = TRUE;
            if ( szPassword != NULL )
            {
                StringCopy( szPassword, _T( "" ), MAX_STRING_LENGTH );
            }
        }
    }

    if(StrCmpN(szServer,TOKEN_BACKSLASH4,2)==0)
    {
        if(!StrCmpN(szServer,TOKEN_BACKSLASH6,3)==0)
        {
            szToken = _tcstok(szServer,TOKEN_BACKSLASH4);
            if( (szToken == NULL)&&(StringCompare(szServer,TOKEN_BACKSLASH4, TRUE, 0) !=0) )
            {
                ShowMessage( stderr,GetResString(IDS_ERROR_PARSE_NAME));
                return (EXIT_FAILURE);
            }
            StringCopy(szServer,szToken, MAX_RES_STRING);
        }
    }


    // Establishing connection to the specified machine and getting the file pointer
    // of the boot.ini file if there is no error while establishing connection
    bFlag = openConnection( szServer, szUser, szPassword, szPath,bNeedPwd,stream,&bConnFlag);
    if(bFlag == EXIT_FAILURE)
    {
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //display a warning message if the user specifies local system name with -s.
    if( (IsLocalSystem(szServer)==TRUE)&&(StringLengthW(szUser, 0)!=0))
    {
        ShowMessage(stderr,GetResString(WARN_LOCALCREDENTIALS));
    }

    // Getting the keys of the Operating system section in the boot.ini file
    arr = getKeyValueOfINISection( szPath, OS_FIELD );
    if(arr == NULL)
    {
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    // Getting the total number of keys in the operating systems section
    dwNumKeys = DynArrayGetCount(arr);

    // Displaying error message if the number of keys is less than the OS entry
    // line number specified by the user
    if( ( dwDefault <= 0 ) || ( dwDefault > dwNumKeys ) )
    {
        ShowMessage(stderr,GetResString(IDS_INVALID_BOOTID));
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    // Getting the key of the OS entry specified by the user
    if (arr != NULL)
    {
        LPCWSTR pwsz = NULL;
        pwsz = DynArrayItemAsString( arr, dwDefault - 1  ) ;
        if( StringLengthW(pwsz, 0) > MAX_RES_STRING)
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if(pwsz != NULL)
        {
            StringCopy( szkey,pwsz, SIZE_OF_ARRAY(szkey));
        }
        else
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
    }
    else
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        ShowLastErrorEx(stderr, SLE_TYPE_ERROR | SLE_SYSTEM);
        ShowLastError(stderr);
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }


    if(StringCompare(szDefault,ON_STRING,TRUE,0)==0 )
    {
        if(FindString(szkey,DEBUGPORT,0) != 0)
        {
            ShowMessage(stderr,GetResString(IDS_DUPLICATE_ENTRY));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
         }

        if(FindString(szkey,BAUD_TOKEN,0) != 0)
        {

            ShowMessage(stderr,GetResString(IDS_ERROR_BAUD_RATE));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if((FindString(szkey,DEBUG_SWITCH,0) == 0))
        {
            StringCopy(szBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            StringConcat(szBuffer,DEBUG_SWITCH, SIZE_OF_ARRAY(szBuffer));
        }

        if( StringLength(szBuffer,0) == 0 )
        {
            StringCopy(szBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
        }
        else
        {
            StringConcat(szBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
        }
        StringConcat(szBuffer,DEBUGPORT_1394, SIZE_OF_ARRAY(szBuffer)) ;

        if(dwChannel!=0)
        {
            //frame the string and concatenate to the Os Load options if the total length is less than 254.
            StringConcat(szBuffer,TOKEN_EMPTYSPACE, SIZE_OF_ARRAY(szBuffer));
            StringConcat(szBuffer,TOKEN_CHANNEL, SIZE_OF_ARRAY(szBuffer));
            StringConcat(szBuffer,TOKEN_EQUAL, SIZE_OF_ARRAY(szBuffer));
            _ltow(dwChannel,szChannel,10);
            StringConcat(szBuffer,szChannel, SIZE_OF_ARRAY(szBuffer));
        }

        //check if boot entry length exceeds the max. boot entry or not
        if( StringLength(szkey,0)+StringLength(szBuffer,0) > MAX_RES_STRING )
        {
            ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        else
        {
            StringConcat( szkey, szBuffer, SIZE_OF_ARRAY(szkey));
        }
    }

    if(StringCompare(szDefault,OFF_STRING,TRUE,0)==0 )
    {
        if(FindString(szkey,DEBUGPORT_1394,0) == 0)
        {
            ShowMessage(stderr,GetResString(IDS_NO_1394_SWITCH));
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if( EXIT_FAILURE == removeSubString(szkey,DEBUGPORT_1394) )
        {
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFEFREE(szSubString);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }
        if( EXIT_FAILURE == removeSubString(szkey,DEBUG_SWITCH) )
        {
            resetFileAttrib(szPath);
            DestroyDynamicArray(&arr);
            SAFEFREE(szFinalStr);
            SAFEFREE(szSubString);
            SAFECLOSE(stream);
            SafeCloseConnection(szServer,bConnFlag);
            FreeMemory((LPVOID *)&szServer );
            FreeMemory((LPVOID *)&szUser );
            return EXIT_FAILURE ;
        }

        if(FindString(szkey,TOKEN_CHANNEL,0)!=0)
        {
            StringCopy(szTemp,NULL_STRING, MAX_RES_STRING);
            dwCode = GetSubString(szkey,TOKEN_CHANNEL,szTemp);
            if(dwCode == EXIT_FAILURE )
            {
                ShowMessage( stderr,GetResString(IDS_NO_TOKENS));
                resetFileAttrib(szPath);
                DestroyDynamicArray(&arr);
                SAFEFREE(szFinalStr);
                SAFECLOSE(stream);
                SafeCloseConnection(szServer,bConnFlag);
                FreeMemory((LPVOID *)&szServer );
                FreeMemory((LPVOID *)&szUser );
                return EXIT_FAILURE ;
            }

            if(StringLengthW(szTemp, 0)!=0)
            {
                if( EXIT_FAILURE == removeSubString(szkey,szTemp) )
                {
                    resetFileAttrib(szPath);
                    DestroyDynamicArray(&arr);
                    SAFEFREE(szFinalStr);
                    SAFEFREE(szSubString);
                    SAFECLOSE(stream);
                    SafeCloseConnection(szServer,bConnFlag);
                    FreeMemory((LPVOID *)&szServer );
                    FreeMemory((LPVOID *)&szUser );
                    return EXIT_FAILURE ;
                }
            }
        }
    }

    if( StringLengthW(szkey, 0) > MAX_RES_STRING)
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_STRING_LENGTH),MAX_RES_STRING);
        resetFileAttrib(szPath);
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE ;
    }

    DynArrayRemove(arr, dwDefault - 1 );
    DynArrayInsertString(arr, dwDefault - 1, szkey, MAX_RES_STRING+1);
    if (stringFromDynamicArray2( arr,&szFinalStr) == EXIT_FAILURE)
    {
        DestroyDynamicArray(&arr);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        resetFileAttrib(szPath);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return EXIT_FAILURE;
    }

    // Writing to the profile section with new key-value pair
    // If the return value is non-zero, then there is an error.
    if( WritePrivateProfileSection(OS_FIELD, szFinalStr, szPath ) != 0 )
    {
        ShowMessageEx(stdout, 1, TRUE, GetResString(IDS_SUCCESS_CHANGE_OSOPTIONS), dwDefault );
    }
    else
    {
        ShowMessageEx(stderr, 1, TRUE, GetResString(IDS_ERROR_LOAD_OSOPTIONS), dwDefault );
        DestroyDynamicArray(&arr);
        resetFileAttrib(szPath);
        SAFEFREE(szFinalStr);
        SAFECLOSE(stream);
        SafeCloseConnection(szServer,bConnFlag);
        FreeMemory((LPVOID *)&szServer );
        FreeMemory((LPVOID *)&szUser );
        return (EXIT_FAILURE);
    }

    //reset the file attributes and free the memory and close the connection to the server.
    bRes = resetFileAttrib(szPath);
    DestroyDynamicArray(&arr);
    SAFEFREE(szFinalStr);
    SAFECLOSE(stream);
    SafeCloseConnection(szServer,bConnFlag);
    FreeMemory((LPVOID *)&szServer );
    FreeMemory((LPVOID *)&szUser );
    return (bRes);
}

VOID 
displayDbg1394Usage_X86()
// ***************************************************************************
//
//  Routine Description  :  Display the help for the Dbg1394 entry option (X86).
//
//  Arguments          : none
//
//  Return Type        : VOID
//
// ***************************************************************************
{
    DWORD dwIndex = IDS_DBG1394_BEGIN_X86 ;
    for(;dwIndex <=IDS_DBG1394_END_X86;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}

VOID 
displayDbg1394Usage_IA64()
/*++
  Routine Description  :  Display the help for the Dbg1394 entry option (IA64).

  Arguments          : none

  Return Type        : VOID
--*/
{
    DWORD dwIndex = IDS_DBG1394_BEGIN_IA64 ;
    for(;dwIndex <=IDS_DBG1394_END_IA64 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}


DWORD 
GetCPUInfo(LPTSTR szComputerName)
/*++
   Routine Description            : determines if the computer is 32 bit system or 64 bit

   Arguments                      :
      [ in ] szComputerName   : System name

   Return Type                    : DWORD
      TRUE  :   if the system is a  32 bit system
      FALSE :   if the system is a  64 bit system
--*/

{
  HKEY     hKey1 = 0;

  HKEY     hRemoteKey                           = 0;
  TCHAR    szPath[MAX_STRING_LENGTH + 1]        = SUBKEY ;
  DWORD    dwValueSize                          = MAX_STRING_LENGTH + 1;
  DWORD    dwRetCode                            = ERROR_SUCCESS;
  DWORD    dwError                              = 0;
  TCHAR    szTmpCompName[MAX_STRING_LENGTH+4]   = NULL_STRING;
  TCHAR    szVal[MAX_RES_STRING+1]              = NULL_STRING ;
  DWORD    dwLength                             = MAX_STRING_LENGTH ;
  LPTSTR   szReturnValue                        = NULL ;
  DWORD    dwCode                               =  0 ;

   szReturnValue = ( LPTSTR )AllocateMemory( dwLength*sizeof( TCHAR ) );
   if(szReturnValue == NULL)
   {
        return ERROR_NOT_ENOUGH_MEMORY;
   }

   if(StringLengthW(szComputerName,0)!= 0 )
   {
      StringCopy(szTmpCompName,TOKEN_BACKSLASH4, SIZE_OF_ARRAY(szTmpCompName));
      StringConcat(szTmpCompName,szComputerName, SIZE_OF_ARRAY(szTmpCompName));
   }
  else
  {
      StringCopy(szTmpCompName,szComputerName, SIZE_OF_ARRAY(szTmpCompName));
  }

  // Get Remote computer local machine key
  dwError = RegConnectRegistry(szTmpCompName,HKEY_LOCAL_MACHINE,&hRemoteKey);
  if (dwError == ERROR_SUCCESS)
  {
     dwError = RegOpenKeyEx(hRemoteKey,szPath,0,KEY_READ,&hKey1);
     if (dwError == ERROR_SUCCESS)
     {
        dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
        if (dwRetCode == ERROR_MORE_DATA)
        {
            if ( szReturnValue != NULL )
            {
                FreeMemory((LPVOID *) &szReturnValue );
                szReturnValue = NULL;
            }
            szReturnValue    = ( LPTSTR ) AllocateMemory( dwValueSize*sizeof( TCHAR ) );
            if( NULL == szReturnValue )
            {
                RegCloseKey(hKey1);
                RegCloseKey(hRemoteKey);
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            dwRetCode = RegQueryValueEx(hKey1, IDENTIFIER_VALUE, NULL, NULL,(LPBYTE) szReturnValue, &dwValueSize);
        }
        if(dwRetCode != ERROR_SUCCESS)
        {
            RegCloseKey(hKey1);
            RegCloseKey(hRemoteKey);
            SAFEFREE(szReturnValue);
            return ERROR_RETREIVE_REGISTRY ;
        }
     }
     else
     {
        RegCloseKey(hRemoteKey);
        SAFEFREE(szReturnValue);
        return ERROR_RETREIVE_REGISTRY ;
     }
    RegCloseKey(hKey1);
  }
  else
  {
      RegCloseKey(hRemoteKey);
      SAFEFREE(szReturnValue);
      return ERROR_RETREIVE_REGISTRY ;
  }

  RegCloseKey(hRemoteKey);

  StringCopy(szVal,X86_MACHINE, SIZE_OF_ARRAY(szVal));

  //check if the specified system contains the words x86 (belongs to the 32 )
  // set the flag to true if the specified system is 64 bit .

  if( !FindString(szReturnValue,szVal,0))
      {
        dwCode = SYSTEM_64_BIT ;
      }
     else
      {
        dwCode =  SYSTEM_32_BIT ;
      }

  SAFEFREE(szReturnValue);
  return dwCode ;

}//GetCPUInfo


DWORD CheckSystemType(LPTSTR szServer)
/*++

   Routine Description            : determines if the computer is 32 bit system or 64 bit

   Arguments                      :
      [ in ] szServer             : System name

   Return Type                    : DWORD
      EXIT_FAILURE  :   if the system is a  32 bit system
      EXIT_SUCCESS  :   if the system is a  64 bit system

--*/
{

    DWORD dwSystemType = 0 ;
#ifndef _WIN64
    //display the error message if  the target system is a 64 bit system or if error occured in
     //retreiving the information
     dwSystemType = GetCPUInfo(szServer);
    if(dwSystemType == ERROR_RETREIVE_REGISTRY)
    {
        ShowMessage(stderr,GetResString(IDS_ERROR_SYSTEM_INFO));
        return (EXIT_FAILURE);
    }
    if( dwSystemType == ERROR_NOT_ENOUGH_MEMORY )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        return EXIT_FAILURE;
    }
    if(dwSystemType == SYSTEM_64_BIT)
    {
        if(StringLengthW(szServer,0)== 0 )
        {
            ShowMessage(stderr,GetResString(IDS_ERROR_VERSION_MISMATCH));
        }
        else
        {
            ShowMessage(stderr,GetResString(IDS_REMOTE_NOT_SUPPORTED));
        }
        return (EXIT_FAILURE);
    }
#endif
        return EXIT_SUCCESS ;
}

VOID 
SafeCloseConnection( IN LPTSTR szServer,
                     IN BOOL bFlag)
/*++

   Routine Description            : determines if the computer is 32 bit system or 64 bit

   Arguments                      :
      [ in ] szServer             : System name
      [ in ] bFlag                : Flag

   Return Type                    : VOID
--*/
{

    if (bFlag )
    {
        CloseConnection(szServer);
    }
}

VOID 
displayMirrorUsage_IA64()
/*++

   Routine Description            : Display the help for the mirror option (IA64).

   Arguments                      :
                                  : NONE

   Return Type                    : VOID
--*/
{
    DWORD dwIndex = IDS_MIRROR_BEGIN_IA64 ;
    for(;dwIndex <=IDS_MIRROR_END_IA64 ;dwIndex++)
    {
        ShowMessage(stdout,GetResString(dwIndex));
    }
}


LPTSTR 
DivideToken( IN LPTSTR szString,
             IN LPTSTR szFinalString )
/*--

   Routine Description            : It gets the string osfriendly name from a boot entry

   Arguments                      
      [ in  ] szString       : boot entry string
      [ out ] szFinalString  : Output represents the osfriendly name.

   Return Type                    : NULL if any error occurs else
                                    the osfriendly name.
--*/
{
    LPTSTR szTemp=NULL;
    LPTSTR szTemp1=NULL;

    #ifndef _WIN64
        DWORD dwLength = 0 ;
    #else
        INT64 dwLength = 0 ;
    #endif

    if( szString == NULL)
    {
        return NULL ;
    }

    //Find the first occurance of the double quote.
    szTemp = StrChrW(szString,L'=');
    if(NULL==szTemp)
    {
        return NULL ;
    }

    szTemp+=2;

    //Find the last occurance of the single quote.
    szTemp1 = (LPTSTR)StrRChrW(szTemp, NULL, L'\"');
    if(NULL==szTemp1)
    {
        return NULL ;
    }
    dwLength = (szTemp1 - szTemp + 1) ;
    StringCopy(szFinalString,szTemp, (unsigned long)dwLength);

   szFinalString[dwLength] = L'\0';
   return szFinalString ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\bootcfg.h ===
#ifndef __BOOTINI_H
#define __BOOTINI_H
#endif // __BOOTINI_H

//
// constants / defines / enumerations
//

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

//registry path
#define REGISTRY_PATH       L"Software\\Microsoft\\Windows\\CurrentVersion\\Setup"

// Error constants
#define ERROR_CONNECT_SERVERNOTFOUND        0xFFFF0001
#define ERROR_CONNECT_LOGINFAIL             0xFFFF0002
#define ERROR_CONNECT_UNKNOWNERROR          0xFFFF0003
#define ERROR_FMT_INVALID_OPTIONVALUE       _T( "ERROR: Invalid value specified for the option '%s'.\n" )
#define ERROR_FMT_INVALIDOSENTRY            _T( "ERROR: Invalid OS entry line number specified.\nThere are only '%s' OS keys.\n" )

// Exit values
#define EXIT_SUCCESS                        0
#define EXIT_FAILURE                        1

#define STRING20  20
#define FRIENDLY_NAME_LENGTH                  68

// Options
#define CMDOPTION_QUERY                     _T( "query" )
#define CMDOPTION_COPY                      _T( "copy" )
#define CMDOPTION_DELETE                    _T( "delete" )
#define CMDOPTION_USAGE                     _T( "?|h" )
#define CMDOPTION_DEFAULT                   _T( "" )
#define CMDOPTION_RAW                       _T("raw")
#define CMDOPTION_DEFAULTOS                 _T("default")
#define CMDOPTION_TIMEOUT                   _T("timeout")
#define CMDOPTION_DEBUG                     _T("debug")
#define CMDOPTION_EMS                       _T("ems")
#define CMDOPTION_DBG1394                       _T("dbg1394")
#define CMDOPTION_ADDSW                     _T("addsw")
#define CMDOPTION_RMSW                      _T("rmsw")
#define CMDOPTION_APPEND                    _T("a")
#define CMDOPTION_MIRROR                    _T("mirror")
#define CMDOPTION_CHANNEL                   _T("ch")
#define CMDOPTION_LIST                      _T("list")
#define CMDOPTION_ADD                       _T("add")
#define CMDOPTION_UPDATE                    _T("update")

#define OPTION_RAW                          _T("/raw")
#define OPTION_RAW1                         _T("-raw")
#define CMDOPTION_CLONE                     _T("clone")


#define CMDOTHEROPTIONS                     _T( "s|server|u|user|p|password|description|descrip|defaultos|basevideo|baudrate|debugport|maxmem|nodebug|crashdebug|noserialmice|sos|redirect|on|off|edit" )

#define BAUD_RATE_VALUES_EMS          _T("9600|19200|57600|115200")
#define BAUD_RATE_VALUES_DEBUG        _T("9600|19200|38400|57600|115200")

#define COM_PORT_RANGE            _T("COM1|COM2|COM3|COM4")


#define EMS_PORT_VALUES           _T("COM1|COM2|COM3|COM4|BIOSSET")

#define CMDOPTION_DEBUG_VALUES    _T("ON|OFF|EDIT")
#define CMDOPTION_EMS_VALUES    _T("ON|OFF|EDIT")

#define CMDOPTION_EMS_VALUES_IA64    _T("ON|OFF")


#define DEBUGPORT_1394      _T("/debugport=1394")

#define DEBUGPORT           _T("/debugport=")
#define BAUD_TOKEN          _T("/baudrate=")

#define TOKEN_CHANNEL       _T("/channel")

#define TOKEN_BACKSLASH4  _T("\\\\")
#define TOKEN_BACKSLASH6  _T("\\\\\\")


// Other switches or sub-options
#define SWITCH_SERVER                       _T( "s" )
#define SWITCH_USER             _T( "u" )
#define SWITCH_PASSWORD             _T( "p" )
#define SWITCH_TIMEOUT              _T( "to" )
#define SWITCH_DEFAULTOS            _T( "do" )
#define SWITCH_BASEVIDEO            _T( "bv" )
#define SWITCH_DEBUG                _T( "dbg" )
#define SWITCH_BAUDRATE             _T( "br" )
#define SWITCH_DEBUGPORT            _T( "dp" )
#define SWITCH_MAXMEM               _T( "mm" )
#define SWITCH_NODEBUG              _T( "nd" )
#define SWITCH_CRASHDEBUG           _T( "cd" )
#define SWITCH_NOSERIALMICE         _T( "ns" )
#define SWITCH_SOS              _T( "so" )
#define SWITCH_REDIRECT             _T( "re" )
#define SWITCH_DESCRIPTION          _T( "d" )
#define SWITCH_RAWSTRING            _T("raw")
#define TIMEOUT_SWITCH              _T("timeout")
#define SWITCH_PORT                 _T("port")
#define SWITCH_BAUD               _T("baud")
#define SWITCH_NOGUIBOOT          _T("ng")
#define SWITCH_UPTDRV             _T("upddrv")
#define SWITCH_ID               _T("id")
#define SWITCH_EDIT             _T("edit")
#define SWITCH_DISK    		      _T("disk")
#define SWITCH_SOURCEGUID          _T("sg")
#define SWITCH_TARGETGUID          _T("tg")


// Strings
#define OFF_STRING                          _T( "OFF" )
#define ON_STRING                           _T( "ON" )
#define COM_STRING                          _T( "COM" )
#define INIPATH                             _T( "c:\\boottest.ini" )
#define OPERATINGSYSTEMSECTION              _T( "operating systems" )
#define BOOTLOADERSECTION           _T( "boot loader" )

#define  COL_FRIENDLYNAME                       GetResString(IDS_COL_FRIENDLYNAME)
#define  COL_BOOTID                             GetResString(IDS_COL_BOOTID)
#define  COL_BOOTOPTION                             GetResString(IDS_COL_COL_BOOTOPTION)
#define  COL_ARCPATH                        GetResString(IDS_COL_ARCPATH)
#define  OS_HEADER                          GetResString(IDS_OS_HEADER)
#define  DASHES_OS                          GetResString(IDS_DASHES_OS)
#define  BOOT_HEADER                        GetResString(IDS_BOOT_HEADER)
#define  DASHES_BOOTOS                      GetResString(IDS_DASHES_BOOTOS)
#define TIMEOUT_VAL                     GetResString(IDS_TIMEOUT)
#define DEFAULT_OS                      GetResString(IDS_DEFAULT_OS)
#define DEFAULT_ARC                     GetResString(IDS_DEFAULT_ARC)

#define COL_FRIENDLYNAME_WIDTH          AsLong(GetResString(IDS_COL_FRIENDLYNAME_SIZE),10)
#define COL_BOOTID_WIDTH            AsLong(GetResString(IDS_COL_BOOTID_SIZE),10)
#define COL_BOOTOPTION_WIDTH            AsLong(GetResString(IDS_COL_BOOTOPTION_SIZE),10)
#define COL_ARC_WIDTH               AsLong(GetResString(IDS_COL_ARCPATH_SIZE),10)

#define TIMEOUT_WIDTH               AsLong(GetResString(IDS_TIMEOUT_SIZE),10)
#define DEFAULT_ARC_WIDTH           AsLong(GetResString(IDS_DEFAULT_ARC_SIZE),10)


#define KEY_DEFAULT                         _T("default")
#define ONOFFVALUES                         _T(" on off ")
#define KEY_REDIRECT                        _T("redirect")




// Typedefs of standard string sizes
typedef TCHAR STRING256 [ 256 ];

#define ID_DEL_HELP_BEGIN           IDS_DELETE_HELP_BEGIN
#define ID_DEL_HELP_END             IDS_DELETE_HELP_END

#define ID_CHANGE_HELP_BEGIN        IDS_CHANGE_HELP_BEGIN
#define ID_CHANGE_HELP_END          IDS_CHANGE_HELP_END

#define ID_QUERY_HELP_BEGIN         IDS_QUERY_HELP_BEGIN
#define ID_QUERY_HELP_END           IDS_QUERY_HELP_END

#define ID_COPY_HELP_BEGIN          IDS_COPY_HELP_BEGIN
#define ID_COPY_HELP_END            IDS_COPY_HELP_END

#define ID_MAIN_HELP_BEGIN          IDS_MAIN_HELP_BEGIN
#define ID_MAIN_HELP_END            IDS_MAIN_HELP_END


#define RAW_HELP_BEGIN              IDS_RAW_HELP_BEGIN
#define RAW_HELP_END                IDS_RAW_HELP_END

#define TIMEOUT_HELP_BEGIN          IDS_TIMOUTHELP_BEGIN
#define TIMEOUT_HELP_END            IDS_TIMOUTHELP_END

#define DEFAULT_BEGIN               IDS_DEFAULT_BEGIN
#define DEFAULT_END                 IDS_DEFAULT_END

#define ID_MAIN_HELP_BEGIN1         IDS_MAIN_HELP_BEGIN1
#define ID_MAIN_HELP_END1           IDS_MAIN_HELP_END1

#define ID_MAIN_HELP_IA64_BEGIN     IDS_MAIN_HELP_IA64_BEGIN
#define ID_MAIN_HELP_IA64_END       IDS_MAIN_HELP_IA64_END
#define RAW_HELP_IA64_BEGIN         IDS_RAW_HELP_IA64_BEGIN
#define RAW_HELP_IA64_END           IDS_RAW_HELP_IA64_END
#define ID_QUERY_HELP64_BEGIN       IDS_QUERY_HELP64_BEGIN
#define ID_QUERY_HELP64_END         IDS_QUERY_HELP64_END
#define ID_DEL_HELP_IA64_BEGIN      IDS_DELETE_HELP_IA64_BEGIN
#define ID_DEL_HELP_IA64_END        IDS_DELETE_HELP_IA64_END
#define ID_COPY_HELP_IA64_BEGIN     IDS_COPY_HELP_IA64_BEGIN
#define ID_COPY_HELP_IA64_END       IDS_COPY_HELP_IA64_END
#define TIMEOUT_HELP_IA64_BEGIN     IDS_TIMOUTHELP_IA64_BEGIN
#define TIMEOUT_HELP_IA64_END       IDS_TIMOUTHELP_IA64_END
#define DEFAULT_IA64_BEGIN          IDS_DEFAULT_IA64_BEGIN
#define DEFAULT_IA64_END            IDS_DEFAULT_IA64_END



#define SAFEFREE(pVal) \
    FreeMemory((LPVOID *)&pVal); 

#define SIZE_OF_ARRAY_IN_CHARS(x) \
            GetBufferSize(x)/sizeof(WCHAR)

#define SAFECLOSE(stream) \
if(stream != NULL)  \
{ \
    fclose(stream);\
    stream = NULL ; \
}



// function prototypes

// Main functions
DWORD ChangeBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD CopyBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD DeleteBootIniSettings(DWORD argc, LPCTSTR argv[]);
DWORD QueryBootIniSettings(DWORD argc, LPCTSTR argv[]);

DWORD ChangeTimeOut(DWORD argc,LPCTSTR argv[]);
DWORD ChangeDefaultOs(DWORD argc,LPCTSTR argv[]);


// Function used to get all the keys of a specified section in
// the specified INI file
TARRAY getKeysOfINISection( LPTSTR szinifile, LPTSTR sziniSection );

// Function used to get all the key-value pairs of a specified section in
// the specified INI file
TARRAY getKeyValueOfINISection( LPTSTR szinifile, LPTSTR sziniSection );

// Function used to delete a key from a specifed section of the
// specified ini file
BOOL deleteKeyFromINISection( LPTSTR szkey, LPTSTR szinifile, LPTSTR sziniSection );

// Function used to build the INI string containing all the key-value pairs.
LPTSTR stringFromDynamicArray( TARRAY arrKeyValuePairs );

// Function used to remove a sub-string from a given string
DWORD removeSubString( LPTSTR szString, LPCTSTR szSubString );

// Function used to connect to the specified server with the given credentials
// and return the file pointer of the boot.ini file
BOOL openConnection(LPTSTR server, LPTSTR user,
                     LPTSTR password, LPTSTR filepath,BOOL bNeedPwd,FILE *stream,PBOOL pbConnFlag);

VOID FormHeader1(BOOL bHeader,TCOLUMNS *ResultHeader);

// Exit function
VOID properExit( DWORD dwExitCode, LPTSTR szFilePath );

// Usage functions
VOID displayChangeUsage();
VOID displayDeleteUsage();
VOID displayQueryUsage();
VOID displayRawUsage_X86();
VOID displayRawUsage_IA64();
DWORD displayMainUsage_X86();
VOID displayMainUsage_IA64();
VOID displayChangeOSUsage_X86();
VOID displayDefaultEntryUsage_IA64();
VOID displayRmSwUsage_X86();
VOID displayAddSwUsage_X86();

VOID displayQueryUsage_IA64();
VOID displayQueryUsage_X86();
VOID displayCopyUsage_IA64();
VOID displayCopyUsage_X86();
VOID displayChangeUsage_IA64();
VOID displayChangeUsage_X86();
VOID displayDeleteUsage_IA64();
VOID displayDeleteUsage_X86();
VOID displayTimeOutUsage_IA64();

VOID displayTimeOutUsage_X86();
VOID displayEmsUsage_X86();
VOID displayDebugUsage_X86();
VOID displayDebugUsage_IA64();
VOID displayEmsUsage_IA64();
VOID displayRmSwUsage_IA64();
VOID displayAddSwUsage_IA64();

VOID displayDbg1394Usage_X86();
VOID displayDbg1394Usage_IA64();
VOID displayMirrorUsage_IA64() ;
//VOID displayListUsage_IA64();
//VOID displayUpdateUsage_IA64();

// Function used to process the main options

DWORD preProcessOptions( DWORD argc, LPCTSTR argv[],
                        PBOOL pbUsage,
                        PBOOL pbCopy,
                        PBOOL pbQuery,
                        PBOOL pbDelete,
                        PBOOL pbRawString,
                        PBOOL pbDefault,
                        PBOOL pbTimeOut,
                        PBOOL pbDebug,
                        PBOOL pbEms,
                        PBOOL pbAddSw,
                        PBOOL pbRmSw,
                        PBOOL pbDbg1394,
                        PBOOL pbMirror,
                        PBOOL pbList ,
                        PBOOL pbUpdate,
                        PBOOL pbClone
                        );


BOOL resetFileAttrib( LPTSTR szFilePath );

BOOL stringFromDynamicArray1( TARRAY arrKeyValuePairs ,LPTSTR szFinalStr );
DWORD stringFromDynamicArray2( TARRAY arrKeyValuePairs ,LPTSTR *szFinalStr );

BOOL EnumerateOsEntries(PBOOT_ENTRY_LIST *ntBootEntries,PULONG ulLength );

VOID FormHeader(BOOL bHeader,TCOLUMNS *ResultHeader,BOOL bVerbose);

DWORD AppendRawString(  DWORD argc, LPCTSTR argv[] );

DWORD ProcessDebugSwitch(  DWORD argc, LPCTSTR argv[] );

DWORD ProcessEmsSwitch(  DWORD argc, LPCTSTR argv[] );

VOID GetComPortType(LPTSTR  szString,LPTSTR szTemp );

VOID GetBaudRateVal(LPTSTR  szString, LPTSTR szTemp);

DWORD getKeysOfSpecifiedINISection( LPTSTR sziniFile, LPTSTR sziniSection,LPCWSTR szKeyName ,LPTSTR szValue );

DWORD ValidateSwitches(PBOOT_ENTRY bootEntry, LPTSTR szNewFriendlyName ,LPTSTR szRawString);

DWORD ProcessAddSwSwitch(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessRmSwSwitch(  DWORD argc, LPCTSTR argv[] );

DWORD GetSubString(LPTSTR szString,LPTSTR szPartString,LPTSTR szFullString);

DWORD ProcessDbg1394Switch(  DWORD argc, LPCTSTR argv[] );
DWORD ProcessListSwitch_IA64(  DWORD argc, LPCTSTR argv[] );

BOOL IsWin64(void) ;

DWORD GetCPUInfo(LPTSTR szComputerName);
DWORD CheckSystemType(LPTSTR szServer);
VOID SafeCloseConnection(LPTSTR szServer,BOOL bFlag) ;
LPTSTR DivideToken( LPTSTR szString,LPTSTR szFinalString );
//LPWSTR DivideToken( LPWSTR szString );


#define ERROR_TAG               GetResString(IDS_ERROR_TAG)
#define ERROR_LOAD_DLL              GetResString(IDS_ERROR_LOAD)
#define ERROR_NO_NVRAM              GetResString(IDS_ERROR_NO_NVRAM)
#define ERROR_UNEXPECTED            GetResString(IDS_UNEXPECTED_ERROR)
#define ERROR_NO_PRIVILAGE          GetResString(IDS_NO_PRIVILAGE)
#define DELETE_SUCCESS              GetResString(IDS_DELETE_SUCCESS)
#define DELETE_FAILURE              GetResString(IDS_DELETE_FAILURE)


#define IDENTIFIER_VALUE  _T("Identifier")
#define SUBKEY _T("HARDWARE\\DESCRIPTION\\SYSTEM\\CENTRALPROCESSOR\\0")

#define IDENTIFIER_VALUE2 _T("SystemPartition")
#define IDENTIFIER_VALUE3 _T("OsLoaderPath")


#define X86_MACHINE _T("x86")

#define SYSTEM_64_BIT 2
#define SYSTEM_32_BIT 3
#define ERROR_RETREIVE_REGISTRY 4



#define NODEBUG_SWITCH _T("/nodebug")
#define BASEVIDEO_SWITCH _T("/basevideo")
#define DEBUG_SWITCH _T("/debug")
#define DEBUG_SWITCH1 _T("/DEBUG")

#define COM_SWITCH _T("COM")
#define CRASHDEBUG_SWITCH _T("/crashdebug")
#define SOS_SWITCH _T("/sos")
#define REDIRECT_SWITCH _T("/redirect")
#define OS_FIELD _T( "operating systems" )

#define SOS_VALUE _T("/sos")
#define NOGUI_VALUE  _T("/noguiboot")
#define BASEVIDEO_VALUE _T("/basevideo")

#define MAXMEM_VALUE _T("/MAXMEM")
#define MAXMEM_VALUE1 _T("/maxmem")

#define NTDLL_FIELD _T("\\ntdll.dll")

#define TOKEN_EQUAL _T("=")
#define TOKEN_BACKSLASH _T("\"")
#define TOKEN_BRACKET _T('[')
#define TOKEN_DELIM _T('\0')
#define TOKEN_EMPTYSPACE _T(" ")

#define TOKEN_SINGLEQUOTE _T("\"")

#define TOKEN_BACKSLASH4 _T("\\\\")
#define TOKEN_BACKSLASH2 _T("\\")
#define TOKEN_FWDSLASH1 _T("/")
#define TOKEN_C_DOLLAR _T("C$")
#define TOKEN_STAR    _T("*")

#define TOKEN_BOOTINI_PATH _T("boot.ini")
#define TOKEN_DOLLAR _T('$')
#define TOKEN_PATH _T("c:\\boot.ini")
#define TOKEN_COLON _T(':')
#define TOKEN_COLONSYMBOL _T(":")

#define TOKEN_50SPACES _T("                                                 ")
#define TOKEN_1394   _T("1394")

#define TOKEN_NA _T("N/A")
#define TOKEN_NEXTLINE _T("\n")
#define MAX_COLUMNS 4

#define TIMEOUT_MAX 999
#define TIMEOUT_MIN 0

#define READ_MODE  _T("r")
#define READWRITE_MODE _T("r+")

#define BOOT_COLUMNS 2

#define COL0        0
#define COL1        1
#define COL2        2
#define COL3        3

#define TABLE_FORMAT                        GetResString(IDS_FORMAT_TABLE)
#define LIST_FORMAT                     GetResString(IDS_FORMAT_LIST)
#define CSV_FORMAT                      GetResString(IDS_FORMAT_CSV)

#define MAX_INI_LENGTH  2500
#define MAX_STRING_LENGTH1 5000


#define ON_OFF_EDIT _T("ON|OFF|EDIT")

#define TOKEN_DEBUGPORT _T("/debugport")


#define PORT_COM1  _T("/debugport=com1")
#define PORT_COM2  _T("/debugport=com2")
#define PORT_COM3  _T("/debugport=com3")
#define PORT_COM4  _T("/debugport=com4")
#define PORT_1394  _T("/debugport=1394")


#define BAUD_VAL6  _T("/baudrate=19200")
#define BAUD_VAL7  _T("/baudrate=38400")
#define BAUD_VAL8  _T("/baudrate=57600")
#define BAUD_VAL9  _T("/baudrate=115200")
#define BAUD_VAL10  _T("/baudrate=9600")

#define BAUD_RATE       _T("/baudrate")
#define REDIRECT    _T("/redirect")

#define VALUE_OFF _T("off")
#define VALUE_ON _T("on")

#define EDIT_STRING _T("EDIT")

#define KEY_BAUDRATE  _T("redirectbaudrate")

#define USEBIOSSET _T("biosset")

#define USEBIOSSETTINGS _T("USEBIOSSETTINGS")

#define ERROR_PROFILE_STRING _T("ERROR:")

#define ERROR_PROFILE_STRING1 _T("")

#define REDIRECT_STRING _T("redirect")

#define BAUDRATE_STRING _T("redirectbaudrate")

#define MAX_BOOTID_VAL  20

#define STRING255 255

#define STRING10 10


#define DRIVE_C 'C'
#define DRIVE_D 'D'
#define DRIVE_E 'E'
#define DRIVE_F 'F'
#define DRIVE_G 'G'
#define DRIVE_H 'H'
#define DRIVE_I 'I'
#define DRIVE_J 'J'
#define DRIVE_K 'K'
#define DRIVE_L 'L'
#define DRIVE_M 'M'
#define DRIVE_N 'N'
#define DRIVE_O 'O'
#define DRIVE_P 'P'
#define DRIVE_Q 'Q'
#define DRIVE_R 'R'
#define DRIVE_S 'S'
#define DRIVE_T 'T'
#define DRIVE_U 'U'
#define DRIVE_V 'V'
#define DRIVE_W 'W'
#define DRIVE_X 'X'
#define DRIVE_Y 'Y'
#define DRIVE_Z 'Z'


#define OI_SERVER 1
#define OI_USER 2
#define OI_PASSWORD 3

//global variable to store attributes
DWORD g_dwAttributes;

DWORD IsAdminGroup( BOOL *bAdmin );
BOOL GetTokenHandle(OUT PHANDLE hTokenHandle);
BOOL CheckAdminAccess( LPCTSTR pszMachine );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\clone.c ===
#include "pch.h"
#include "resource.h"
#include "BootCfg.h"
#include "BootCfg64.h"
#include <strsafe.h>

//
// custom macros
//
#define NOT                         !

#define FORMAT_FILE_PATH            L"signature(%s)"
#define FORMAT_FILE_PATH_EX         L"signature({%s})"

//
// custom error codes
//
#define ERROR_PARTIAL_SUCCESS       0x40080001
#define ERROR_FAILED                0x40080002

//
// externs
//
extern LIST_ENTRY BootEntries;
extern LIST_ENTRY ActiveUnorderedBootEntries;
extern LIST_ENTRY InactiveUnorderedBootEntries;

//
// parameter / switches index
#define OI_CLONE_MAIN                      0
#define OI_CLONE_SOURCE_GUID               1
#define OI_CLONE_TARGET_GUID               2
#define OI_CLONE_FRIENDLY_NAME_REPLACE     3
#define OI_CLONE_FRIENDLY_NAME_APPEND      4
#define OI_CLONE_BOOT_ID                   5
#define OI_CLONE_DRIVER_UPDATE             6
#define OI_CLONE_HELP                      7
#define OI_CLONE_COUNT                     8

// switch names
#define OPTION_CLONE                          L"clone"
#define OPTION_CLONE_SOURCE_GUID              L"sg"
#define OPTION_CLONE_TARGET_GUID              L"tg"
#define OPTION_CLONE_FRIENDLY_NAME_REPLACE    L"d"
#define OPTION_CLONE_FRIENDLY_NAME_APPEND     L"d+"
#define OPTION_CLONE_BOOT_ID                  L"id"
#define OPTION_CLONE_HELP                     L"?"
#define OPTION_CLONE_DRIVER_UPDATE            L"upddrv"

// default friendly name
#define DEFAULT_FRIENDLY_NAME               GetResString2( IDS_CLONE_DEFAULT_FRIENDLY_NAME, 0 )

// resource strings
#define CLONE_ZERO_BOOT_ENTRIES             GetResString2( IDS_CLONE_ZERO_BOOT_ENTRIES, 0 )
#define CLONE_RANGE_ZERO_BOOT_ENTRIES       GetResString2( IDS_CLONE_RANGE_ZERO_BOOT_ENTRIES, 0 )
#define CLONE_SUCCESS                       GetResString2( IDS_CLONE_SUCCESS, 0 )
#define CLONE_FAILED                        GetResString2( IDS_CLONE_FAILED, 0 )
#define CLONE_PARTIAL                       GetResString2( IDS_CLONE_PARTIAL, 0 )
#define CLONE_INVALID_BOOT_ENTRY            GetResString2( IDS_CLONE_INVALID_BOOT_ENTRY, 0 )
#define CLONE_ALREADY_EXISTS                GetResString2( IDS_CLONE_ALREADY_EXISTS, 0 )
#define CLONE_BOOT_ENTRY_SUCCESS            GetResString2( IDS_CLONE_BOOT_ENTRY_SUCCESS, 0 )
#define CLONE_INVALID_SOURCE_GUID           GetResString2( IDS_CLONE_INVALID_SOURCE_GUID, 0 )
#define CLONE_INVALID_TARGET_GUID           GetResString2( IDS_CLONE_INVALID_TARGET_GUID, 0 )
#define CLONE_INVALID_DRIVER_ENTRY          GetResString2( IDS_CLONE_INVALID_DRIVER_ENTRY, 0 )
#define CLONE_DRIVER_ALREADY_EXISTS         GetResString2( IDS_CLONE_DRIVER_ALREADY_EXISTS, 0 )
#define CLONE_ZERO_DRIVER_ENTRIES           GetResString2( IDS_CLONE_ZERO_DRIVER_ENTRIES, 0 )
#define CLONE_DRIVER_ENTRY_SUCCESS          GetResString2( IDS_CLONE_DRIVER_ENTRY_SUCCESS, 0 )

#define CLONE_DETAILED_TRACE                GetResString2( IDS_CLONE_DETAILED_TRACE, 0 )

#define MSG_ERROR_INVALID_USAGE_REQUEST             GetResString2( IDS_ERROR_INVALID_USAGE_REQUEST, 0 )
#define MSG_ERROR_INVALID_DESCRIPTION_COMBINATION   GetResString2( IDS_ERROR_INVALID_DESCRIPTION_COMBINATION, 0 )
#define MSG_ERROR_INVALID_BOOT_ID_COMBINATION       GetResString2( IDS_ERROR_INVALID_BOOT_ID_COMBINATION, 0 )
#define MSG_ERROR_INVALID_UPDDRV_COMBINATION        GetResString2( IDS_ERROR_INVALID_UPDDRV_COMBINATION, 0 )
#define MSG_ERROR_NO_SGUID_WITH_UPDDRV              GetResString2( IDS_ERROR_NO_SGUID_WITH_UPDDRV, 0 )

//
// internal structure
//
typedef struct __tagCloneParameters
{
    BOOL bUsage;
    LONG lBootId;
    BOOL bVerbose;
    BOOL bDriverUpdate;
    LPWSTR pwszSourcePath;
    LPWSTR pwszTargetPath;
    LPWSTR pwszSourceGuid;
    LPWSTR pwszTargetGuid;
    LPWSTR pwszFriendlyName;
    DWORD dwFriendlyNameType;
} TCLONE_PARAMS, *PTCLONE_PARAMS;

//
// enum's
//
enum {
    BOOTENTRY_FRIENDLYNAME_NONE = 0,
    BOOTENTRY_FRIENDLYNAME_APPEND, BOOTENTRY_FRIENDLYNAME_REPLACE
};

//
// prototypes
//

// parser
DWORD DisplayCloneHelp();
DWORD ProcessOptions( DWORD argc, LPCWSTR argv[], PTCLONE_PARAMS pParams );

// helper functions
DWORD TranslateEFIPathToNTPath( LPCWSTR pwszGUID, LPVOID* pwszPath );
BOOL MatchPath( PFILE_PATH pfpSource, LPCWSTR pwszDevicePath, LPCWSTR pwszFilePath );
DWORD PrepareCompleteEFIPath( PFILE_PATH pfpSource, 
                              LPCWSTR pwszDevicePath, 
                              LPWSTR* pwszEFIPath, DWORD* pdwLength );

// efi driver cloners
DWORD LoadDriverEntries( PEFI_DRIVER_ENTRY_LIST* ppDriverEntries );
LONG FindDriverEntryWithTargetEFI( PEFI_DRIVER_ENTRY_LIST pdeList, DWORD dwSourceIndex,
                                   PEFI_DRIVER_ENTRY pdeSource, LPCWSTR pwszDevicePath );
DWORD DoDriverEntryClone( PEFI_DRIVER_ENTRY_LIST pbeList, 
                          LPCWSTR pwszSourceEFI, LPCWSTR pwszTargetEFI, 
                          LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType, BOOL bVerbose );
DWORD CloneDriverEntry( PEFI_DRIVER_ENTRY pbeSource, LPCWSTR pwszEFIPath, 
                        LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType );

// boot entry cloners
DWORD CloneBootEntry( PBOOT_ENTRY pbeSource, LPCWSTR pwszEFIPath, 
                      LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType );
DWORD DoBootEntryClone( PBOOT_ENTRY_LIST pbeList, LPCWSTR pwszSourceEFI, 
                        LPCWSTR pwszTargetEFI, LONG lIndexFrom, LONG lIndexTo, 
                        LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType, BOOL bVerbose );

//
// functionality
//

DWORD ProcessCloneSwitch_IA64( IN DWORD argc, IN LPCTSTR argv[] )
{
    //
    // local variables
    NTSTATUS status;
    DWORD dwResult = 0;
    DWORD dwLength = 0;
    DWORD dwExitCode = 0;
    TCLONE_PARAMS paramsClone;
    BOOLEAN wasEnabled = FALSE;
    PEFI_DRIVER_ENTRY_LIST pDriverEntries = NULL;
    
    // init to zero's
    ZeroMemory( &paramsClone, sizeof( TCLONE_PARAMS ) );

	// process the command line options
    dwResult = ProcessOptions( argc, argv, &paramsClone );
    if ( dwResult != ERROR_SUCCESS )
    {
        // display one blank line -- for clarity purpose
        ShowMessage( stderr, L"\n" );

        // ...
        dwExitCode = 1;
        ShowLastErrorEx( stderr, SLE_ERROR | SLE_INTERNAL );
        goto cleanup;
    }

	
		
    // check if user requested for help
    if ( paramsClone.bUsage == TRUE )
    {
		// display usage for this option
        DisplayCloneHelp();
        dwExitCode = 0;
        goto cleanup;
    }

    // display one blank line -- for clarity purpose
    ShowMessage( stderr, L"\n" );

    // initialize the EFI -- only if user specifies the index
    if ( paramsClone.bDriverUpdate == FALSE )
    {
        dwResult = InitializeEFI();

        // check the result of load operation
        if ( dwResult != ERROR_SUCCESS )
        {
            // NOTE: message will be displayed in the associated funtions itself
            dwExitCode = 1;
            goto cleanup;
        }
    }
    else if ( paramsClone.bDriverUpdate == TRUE )
    {
        //
        // load the drivers

        // enable the privilege that is necessary to query/set NVRAM.
        status = RtlAdjustPrivilege( SE_SYSTEM_ENVIRONMENT_PRIVILEGE, TRUE, FALSE, &wasEnabled );
        if ( NOT NT_SUCCESS( status ) ) 
	    {
            dwExitCode = 1;
            dwResult = RtlNtStatusToDosError( status );
            SetLastError( dwResult );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
		    goto cleanup;
	    }

        // load the drivers now
        dwResult = LoadDriverEntries( &pDriverEntries );
        if ( dwResult != ERROR_SUCCESS )
        {
            dwExitCode = 1;
            SetLastError( dwResult );
            ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
		    goto cleanup;
        }
    }

    // translate the source guid path into NT path - if needed
    if ( paramsClone.pwszSourceGuid != NULL )
    {
        dwResult = TranslateEFIPathToNTPath( 
            paramsClone.pwszSourceGuid, &paramsClone.pwszSourcePath );
        if ( dwResult != ERROR_SUCCESS )
        {
            dwExitCode = 1;
			ShowMessage( stderr, CLONE_INVALID_SOURCE_GUID );
            goto cleanup;
        }
    }

    // translate the target guid into NT path
    dwResult = TranslateEFIPathToNTPath( 
        paramsClone.pwszTargetGuid, &paramsClone.pwszTargetPath );
    if ( dwResult != ERROR_SUCCESS )
    {
        dwExitCode = 1;
        ShowMessage( stderr, CLONE_INVALID_TARGET_GUID );
        goto cleanup;
    }

    // actual operation ...
    if ( paramsClone.bDriverUpdate == FALSE )
    {
        // by default, if user did not specify the friendly name, we will assume
        // that users wants to the append the default string viz. "(clone)"
        if ( paramsClone.pwszFriendlyName == NULL )
        {
            // determine the length of the default friendly name
            // and allocate buffer with length
            dwLength = StringLength( DEFAULT_FRIENDLY_NAME, 0 ) + 2;
            paramsClone.pwszFriendlyName = AllocateMemory( dwLength + 5 );
            if ( paramsClone.pwszFriendlyName == NULL )
            {
                dwExitCode = 1;
                SetLastError( ERROR_NOT_ENOUGH_MEMORY );
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                goto cleanup;
            }

            // copy the default string into this buffer and 
            // change the friednly name type to append
            paramsClone.dwFriendlyNameType = BOOTENTRY_FRIENDLYNAME_APPEND;
            StringCopy( paramsClone.pwszFriendlyName, DEFAULT_FRIENDLY_NAME, dwLength );
        }

        // do the boot entry cloning
	    dwResult = DoBootEntryClone( 
            NULL, paramsClone.pwszSourcePath, 
            paramsClone.pwszTargetPath, paramsClone.lBootId, -1, 
            paramsClone.pwszFriendlyName, paramsClone.dwFriendlyNameType, paramsClone.bVerbose );
    }
    else if ( paramsClone.bDriverUpdate == TRUE )
    {
        // do the driver cloning
	    dwResult = DoDriverEntryClone( 
            pDriverEntries, paramsClone.pwszSourcePath, paramsClone.pwszTargetPath,  
            paramsClone.pwszFriendlyName, paramsClone.dwFriendlyNameType, paramsClone.bVerbose );
    }

    // determine the exit code based on the error code
    switch( dwResult )
    {
    case ERROR_SUCCESS:
        dwExitCode = 0;
        break;

    case ERROR_FAILED:
        dwExitCode = 1;
        break;

    case ERROR_PARTIAL_SUCCESS:
        dwExitCode = 0;
        break;

    default:
        // can never oocur
        dwExitCode = 1;
        break;
    }

cleanup:

    // release the memory
    FreeMemory( &pDriverEntries );
    FreeMemory( &paramsClone.pwszSourcePath );
    FreeMemory( &paramsClone.pwszTargetPath );
    FreeMemory( &paramsClone.pwszSourceGuid );
    FreeMemory( &paramsClone.pwszTargetGuid );
    FreeMemory( &paramsClone.pwszFriendlyName );

    // return
    return dwExitCode;
}


///////////////////////////////////////////////////////////////////////////////
// boot entries specific implementation
//////////////////////////////////////////////////////////////////////////////


DWORD DoBootEntryClone( PBOOT_ENTRY_LIST pbeList, LPCWSTR pwszSourceEFI, 
                        LPCWSTR pwszTargetEFI, LONG lIndexFrom, LONG lIndexTo, 
                        LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType, BOOL bVerbose )
{
    // local variables
    DWORD dwResult = 0;
    BOOL bClone = FALSE;
    LONG lCurrentIndex = 0;
    BOOL bExitFromLoop = FALSE;
    PLIST_ENTRY pBootList = NULL;
    PBOOT_ENTRY pBootEntry = NULL;
    PFILE_PATH pfpBootFilePath = NULL;
    PMY_BOOT_ENTRY pMyBootEntry = NULL;
    DWORD dwAttempted = 0, dwFailed = 0;

    //
    // check the input parameter
    //
    if ( pwszTargetEFI == NULL || (lIndexTo != -1 && lIndexFrom > lIndexTo) ||
        (dwFriendlyNameType != BOOTENTRY_FRIENDLYNAME_NONE && pwszFriendlyName == NULL) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // pbeList is a unreferenced parameter
    UNREFERENCED_PARAMETER( pbeList );

    // if the 'to' index is not specified, then we treat the 'to' index to match
    // with the 'from' index
    if ( lIndexFrom != -1 && lIndexTo == -1 )
    {
        lIndexTo = lIndexFrom;
    }

    // traverse thru the list of boot entries
    for( pBootList = BootEntries.Flink; pBootList != &BootEntries; pBootList = pBootList->Flink )
    {
        // increment the loop counter
        bClone = FALSE;
        lCurrentIndex = -1;
        dwResult = ERROR_SUCCESS;

        // get the boot entry
        pMyBootEntry = CONTAINING_RECORD( pBootList, MY_BOOT_ENTRY, ListEntry );
        if( NOT MBE_IS_NT( pMyBootEntry ) )
        {
            // this is not a valid boot entry we are looking for skip
            continue;
        }

        // extract the boot id and actual boot entry
        lCurrentIndex = pMyBootEntry->myId;
        pBootEntry = &pMyBootEntry->NtBootEntry;

        // check if the current boot index falls within the index or not
        if ( lIndexFrom != -1 )
        {
            bClone = (lCurrentIndex >= lIndexFrom && lCurrentIndex <= lIndexTo);
        }

        // extended filtering
        if ( pwszSourceEFI != NULL )
        {
            if ( lIndexFrom == -1 || (lIndexFrom != -1 && bClone == TRUE) )
            {
                // extract the boot file path
                pfpBootFilePath = (PFILE_PATH) ADD_OFFSET( pBootEntry, BootFilePathOffset );

                // check whether it matches or not
                bClone = MatchPath( pfpBootFilePath, pwszSourceEFI, NULL );
            }
        }

        // clone the boot entry -- only if filtering results in TRUE
        bExitFromLoop = FALSE;
        if ( bClone == TRUE || (pwszSourceEFI == NULL && lIndexFrom == -1) )
        {
            // increment the attempted list
            dwAttempted++;

            // do the operation
            dwResult = CloneBootEntry( pBootEntry, 
                pwszTargetEFI, pwszFriendlyName, dwFriendlyNameType );

            // check the result
            if ( dwResult != ERROR_SUCCESS )
            {
                // increment the failures count
                dwFailed++;

                // check whether this particular instance of operation is target for
                // multiple entries or single entry 
                if ( lIndexFrom == -1 || ((lIndexTo - lIndexFrom + 1) > 1) )
                {
                    // check the severity for the error occured
                    switch( dwResult )
                    {
                    case STG_E_UNKNOWN:                         // unknown error -- unrecoverable
                    case ERROR_INVALID_PARAMETER:               // code error
                    case ERROR_NOT_ENOUGH_MEMORY:               // unrecovarable case
                        {
                            bExitFromLoop = TRUE;
                            break;
                        }

                    case ERROR_ALREADY_EXISTS:
                        {
                            // duplicate boot entry
                            if ( bVerbose == TRUE )
                            {
                                ShowMessageEx( stdout, 1, TRUE, CLONE_ALREADY_EXISTS, lCurrentIndex );
                            }

                            // ...
                            dwResult = ERROR_SUCCESS;
                            break;
                        }

                    default:
                    case ERROR_FILE_NOT_FOUND:
                    case ERROR_PATH_NOT_FOUND:
                        {
                            // dont know how to handle this case
                            if ( bVerbose == TRUE )
                            {
                                SetLastError( dwResult );
                                SaveLastError();
                                ShowMessageEx( stdout, 2, TRUE, CLONE_INVALID_BOOT_ENTRY, lCurrentIndex, GetReason() );
                            }

                            // ...
                            dwResult = ERROR_SUCCESS;
                            break;
                        }
                    }
                }
                else
                {
                    // since this is a single entry clone operation
                    // break from the loop
                    bExitFromLoop = TRUE;
                }
            }
            else
            {
                if ( bVerbose == TRUE )
                {
                    ShowMessageEx( stdout, 1, TRUE, CLONE_BOOT_ENTRY_SUCCESS, lCurrentIndex );
                }
            }
        }

        // exit from the loop - if needed
        if ( bExitFromLoop == TRUE )
        {
            break;
        }
    }

cleanup:

    // check the result of the operation
    if ( dwResult == ERROR_SUCCESS )
    {
        if ( dwAttempted == 0 )
        {
            // no boot entries at all
            dwResult = ERROR_FAILED;
            if ( lIndexFrom == -1 )
            {
                ShowMessage( stdout, CLONE_ZERO_BOOT_ENTRIES );
            }
            else
            {
                ShowMessage( stdout, CLONE_RANGE_ZERO_BOOT_ENTRIES );
            }
        }
        else 
        {
            // verify whether all requested boot entries are processed or not
            if ( lIndexFrom != -1 && dwAttempted != (lIndexTo - lIndexFrom + 1) )
            {
                // warning - not all boot entries were parsed -- invalid bounds were specified

                //
                // NOTE: in the current implementation, this can never occur
                //       this is because, the input parameters for this option does accept
                //       only the /id which will be treated as 'lIndexStart'
                //
            }

            if ( dwFailed == 0 )
            {
                // nothing failed -- success
                dwResult = ERROR_SUCCESS;
                SetLastError( ERROR_SUCCESS );
                ShowLastErrorEx( stdout, SLE_TYPE_SUCCESS | SLE_SYSTEM );
            }
            else if ( dwAttempted == dwFailed )
            {
                // nothing succeeded -- completely failed
                dwResult = ERROR_FAILED;
                ShowMessage( stderr, CLONE_FAILED );

                // show verbose hint
                if ( bVerbose == FALSE )
                {
                    ShowMessage( stderr, CLONE_DETAILED_TRACE );
                }
            }
            else
            {
                // parital success
                dwResult = ERROR_PARTIAL_SUCCESS;
                ShowMessage( stderr, CLONE_PARTIAL );

                // show verbose hint
                if ( bVerbose == FALSE )
                {
                    ShowMessage( stderr, CLONE_DETAILED_TRACE );
                }
            }
        }
    }
    else
    {
        // check the reason for failure
        switch( dwResult )
        {
        case STG_E_UNKNOWN:                         // unknown error -- unrecoverable
        case ERROR_INVALID_PARAMETER:               // code error
        case ERROR_NOT_ENOUGH_MEMORY:               // unrecovarable case
            {
                SetLastError( dwResult );
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                break;
            }

        case ERROR_ALREADY_EXISTS:
            {
                ShowMessageEx( stdout, 1, TRUE, CLONE_ALREADY_EXISTS, lIndexFrom );
                break;
            }

        default:
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
            {
                SetLastError( dwResult );
                SaveLastError();
                ShowMessageEx( stdout, 2, TRUE, CLONE_INVALID_BOOT_ENTRY, lIndexFrom, GetReason() );
                break;
            }
        }

        // error code
        dwResult = ERROR_FAILED;
    }

    // return
    return dwResult;
}


DWORD CloneBootEntry( PBOOT_ENTRY pbeSource, LPCWSTR pwszEFIPath, 
                      LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType )
{
    //
    // local variables
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;

    // friendly name
    DWORD dwFriendlyNameLength = 0;
    LPWSTR pwszTargetFriendlyName = NULL;
    LPCWSTR pwszSourceFriendlyName = NULL;

    // os options
    DWORD dwOsOptionsLength = 0;
    PWINDOWS_OS_OPTIONS pOsOptions = NULL;

    // boot file path
    DWORD dwEFIPathLength = 0;
    DWORD dwBootFilePathLength = 0;
    PFILE_PATH pfpBootFilePath = NULL;
    LPWSTR pwszFullEFIPath = NULL;

    // boot entry
    ULONG ulId = 0;
    ULONG ulIdCount = 0;
    ULONG* pulIdsArray = NULL;
    DWORD dwBootEntryLength = 0;
    PBOOT_ENTRY pBootEntry = NULL;

    //
    // implementation
    //

    // check the input
    if ( pbeSource == NULL || pwszEFIPath == NULL ||
         (dwFriendlyNameType != BOOTENTRY_FRIENDLYNAME_NONE && pwszFriendlyName == NULL) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // validate the boot file in the source boot entry
    //

    // extract the boot file path
    pfpBootFilePath = (PFILE_PATH) ADD_OFFSET( pbeSource, BootFilePathOffset );

    // attempt to translate the file path
	status = NtTranslateFilePath( pfpBootFilePath, FILE_PATH_TYPE_NT, NULL, &dwBootFilePathLength );

    // reset the pBootFilePath and dwBootFilePathLength variables
    pfpBootFilePath = NULL;
    dwBootFilePathLength = 0;

    // now verify the result of the translation
    if ( NOT NT_SUCCESS( status ) ) 
	{
        if ( status == STATUS_BUFFER_TOO_SMALL )
        {
            // source boot entry is a valid one
            dwResult = ERROR_SUCCESS;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
            goto cleanup;
        }
    }

    //
    // prepare "friendly name"
    //

    // determine the source friendly name and its length
    dwFriendlyNameLength = 0;
    pwszSourceFriendlyName = NULL;
    switch( dwFriendlyNameType )
    {
    case BOOTENTRY_FRIENDLYNAME_NONE:
    case BOOTENTRY_FRIENDLYNAME_APPEND:
        {
            pwszSourceFriendlyName = (LPCWSTR) ADD_OFFSET( pbeSource, FriendlyNameOffset );
            dwFriendlyNameLength = StringLengthW( pwszSourceFriendlyName, 0 ) + 1;
            break;
        }

    default:
        // do nothing
        break;
    }

    // add the length of the friendly name that needs to be added -- if exists
    if ( pwszFriendlyName != NULL )
    {
        dwFriendlyNameLength += StringLengthW( pwszFriendlyName, 0 ) + 1;
    }

    // allocate memory for the friendly name
    pwszTargetFriendlyName = (LPWSTR) AllocateMemory( (dwFriendlyNameLength + 1) * sizeof( WCHAR ) );
    if ( pwszTargetFriendlyName == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // prepare the friendly name
    StringCopyW( pwszTargetFriendlyName, L"", dwFriendlyNameLength );

    // ...
    if ( pwszSourceFriendlyName != NULL )
    {
        StringConcat( pwszTargetFriendlyName, pwszSourceFriendlyName, dwFriendlyNameLength );
    }

    // ...
    if ( pwszFriendlyName != NULL )
    {
        // add one space b/w the existing and concatenating string
        if ( pwszSourceFriendlyName != NULL )
        {
            StringConcat( pwszTargetFriendlyName, L" ", dwFriendlyNameLength );
        }

        // ...
        StringConcat( pwszTargetFriendlyName, pwszFriendlyName, dwFriendlyNameLength );
    }

    //
    // prepare "OS Options"
    //
    // NOTE:
    // -----
    // though the os options are NULL, it will still consume some space (refer the structre of 
    // BOOT_ENTRY -- that is the reason why the default length of OS OPTIONS is ANYSIZE_ARRAY)
    pOsOptions = NULL;
    dwOsOptionsLength = ANYSIZE_ARRAY;      
    if ( pbeSource->OsOptionsLength != 0 )
    {
        // allocate memory for os options
        dwOsOptionsLength = pbeSource->OsOptionsLength;
        pOsOptions = (PWINDOWS_OS_OPTIONS) AllocateMemory( dwOsOptionsLength );
        if ( pOsOptions == NULL )
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        // copy the contents
        CopyMemory( pOsOptions, &pbeSource->OsOptions, dwOsOptionsLength );
    }

    //
    // boot file path
    //

    // the 'FilePath' variable in FILE_PATH variable contains two variables
    // each seperated by a NULL terminated character
    // the first part designates the DEVICE PATH
    // and the second part designated the DIRECTORY / FILE PATH
    // we already have the device path (pwszEFIPath) -- but we need to get the
    // DIRECTORY / FILE PATH -- this we will get from the source boot entry
    pfpBootFilePath = (PFILE_PATH) ADD_OFFSET( pbeSource, BootFilePathOffset );
    dwResult = PrepareCompleteEFIPath( pfpBootFilePath, pwszEFIPath, &pwszFullEFIPath, &dwEFIPathLength );
    if ( dwResult != ERROR_SUCCESS )
    {
        // since the memory reference in pBootFilePath is not allocated
        // in this function, it is important to reset the pointer to NULL
        // this avoids the crash in the program
        pfpBootFilePath = NULL;

        // ...
        goto cleanup;
    }

	// now determine the memory size that needs to be allocated for FILE_PATH structure
	// and align up to the even memory bounday
    pfpBootFilePath = NULL;
	dwBootFilePathLength = FIELD_OFFSET(FILE_PATH, FilePath) + (dwEFIPathLength * sizeof( WCHAR ));

    // allocate memory
    pfpBootFilePath = (PFILE_PATH) AllocateMemory( dwBootFilePathLength );
    if ( pfpBootFilePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // initialize the file path structure
    ZeroMemory( pfpBootFilePath, dwBootFilePathLength );
	pfpBootFilePath->Length = dwBootFilePathLength;
	pfpBootFilePath->Type = FILE_PATH_TYPE_NT;
	pfpBootFilePath->Version = FILE_PATH_VERSION;
	CopyMemory( pfpBootFilePath->FilePath, pwszFullEFIPath, dwEFIPathLength * sizeof( WCHAR ) );

    //
    // finally, create the boot entry
    //

	// determine the size for the BOOT_ENTRY structure
	dwBootEntryLength = FIELD_OFFSET( BOOT_ENTRY, OsOptions )  + 
					    dwOsOptionsLength                      + 
					    (dwFriendlyNameLength * sizeof(WCHAR)) +
					    dwBootFilePathLength                   + 
                        sizeof(WCHAR)                          +  // align the FriendlyName on WCHAR 
                        sizeof(DWORD);                            // align the BootFilePath on DWORD

    // allocate memory
    pBootEntry = (PBOOT_ENTRY) AllocateMemory( dwBootEntryLength );
    if ( pBootEntry == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // ...
	ZeroMemory( pBootEntry, dwBootEntryLength );
	pBootEntry->Id = 0L;
	pBootEntry->Length = dwBootEntryLength;
	pBootEntry->Version = BOOT_ENTRY_VERSION;
    pBootEntry->OsOptionsLength = dwOsOptionsLength;
	pBootEntry->Attributes = BOOT_ENTRY_ATTRIBUTE_DEFAULT;

    // align the friendly name on WCHR boundary
	pBootEntry->FriendlyNameOffset = 
        ALIGN_UP( FIELD_OFFSET(BOOT_ENTRY, OsOptions) + dwOsOptionsLength, WCHAR );

    // align the boot file path on DWORD boundary
    pBootEntry->BootFilePathOffset = 
        ALIGN_UP( pBootEntry->FriendlyNameOffset + (dwFriendlyNameLength * sizeof(WCHAR)), DWORD );

    // fill the boot entry
    CopyMemory( pBootEntry->OsOptions, pOsOptions, dwOsOptionsLength );
    CopyMemory( ADD_OFFSET( pBootEntry, BootFilePathOffset ), pfpBootFilePath, dwBootFilePathLength );
    CopyMemory( 
        ADD_OFFSET( pBootEntry, FriendlyNameOffset ), 
        pwszTargetFriendlyName, (dwFriendlyNameLength * sizeof(WCHAR) ) );

	//
	// add the prepared boot entry
	//
	status = NtAddBootEntry( pBootEntry, &ulId );
    if ( NOT NT_SUCCESS( status ) ) 
	{
        dwResult = RtlNtStatusToDosError( status );
		goto cleanup;
	}
	
    //
    // Add the entry to the boot order.
    //
	ulIdCount = 32L;
    pulIdsArray = (PULONG) AllocateMemory( ulIdCount * sizeof(ULONG) );
    if ( pulIdsArray == NULL )
	{
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // query the boot entry order
    // NOTE: we will doing error check for this function call bit later
    status = NtQueryBootEntryOrder( pulIdsArray, &ulIdCount );

    // need room in the buffer for the new entry.
    if ( 31L < ulIdCount ) 
    {
        // release the current memory allocation for id's
        FreeMemory( &pulIdsArray );

        // allocate new memory and query again
        pulIdsArray = (PULONG) AllocateMemory( (ulIdCount+1) * sizeof(ULONG));
        if ( pulIdsArray == NULL )
	    {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        // ...
        status = NtQueryBootEntryOrder( pulIdsArray, &ulIdCount );
    }    
    
    // check the result of the boot entries query operation
    if ( NOT NT_SUCCESS( status ) )
	{
        dwResult = RtlNtStatusToDosError( status );
        goto cleanup;
    }

    // set the boot entry order
    ulIdCount++;
    *(pulIdsArray + (ulIdCount - 1)) = ulId;
    status = NtSetBootEntryOrder( pulIdsArray, ulIdCount );
    if ( NOT NT_SUCCESS( status ) )
	{
        dwResult = RtlNtStatusToDosError( status );
        goto cleanup;
    }

    // success
    dwResult = ERROR_SUCCESS;

cleanup:

    // release the memory allocated
    FreeMemory( &pOsOptions );
    FreeMemory( &pBootEntry );
    FreeMemory( &pulIdsArray );
    FreeMemory( &pfpBootFilePath );
    FreeMemory( &pwszFullEFIPath );
    FreeMemory( &pwszTargetFriendlyName );

    // return
    return dwResult;
}


///////////////////////////////////////////////////////////////////////////////
// efi drivers specific implementation
//////////////////////////////////////////////////////////////////////////////


DWORD LoadDriverEntries( PEFI_DRIVER_ENTRY_LIST* ppDriverEntries )
{
    //
    // local variables
    DWORD dwSize = 0;
    BOOL bSecondChance = FALSE;
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;
    const DWORD dwDefaultSize = 1024;
    PEFI_DRIVER_ENTRY_LIST pDriverEntries = NULL;

    //
    // implementation
    //

    // check the input
    if ( ppDriverEntries == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // default size is assumed as 1024 bytes
    bSecondChance = FALSE;
    dwSize = dwDefaultSize;

try_again:

    // allocate memory
    pDriverEntries = AllocateMemory( dwSize );
    if ( pDriverEntries == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // try to get the boot entries
    status = NtEnumerateDriverEntries( pDriverEntries, &dwSize );
    if ( NOT NT_SUCCESS( status ) )
    {
        // release the memory that is allocated for target path structure
        FreeMemory( &pDriverEntries );

        // check the error
        if ( status == STATUS_BUFFER_TOO_SMALL && bSecondChance == FALSE )
        {
            // give a second try
            bSecondChance = TRUE;
            goto try_again;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
            goto cleanup;
        }
    }

    // operation is succes
    dwResult = ERROR_SUCCESS;
    *ppDriverEntries = pDriverEntries;

cleanup:

    // need to release memory allocated for Driver entries in this function
    // should do this only in case of failure
    if ( dwResult != ERROR_SUCCESS )
    {
        FreeMemory( &pDriverEntries );
    }

    // return the result
    return dwResult;
}


DWORD DoDriverEntryClone( PEFI_DRIVER_ENTRY_LIST pdeList, 
                          LPCWSTR pwszSourceEFI, LPCWSTR pwszTargetEFI, 
                          LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType, BOOL bVerbose )
{
    // local variables
    LONG lLoop = 0;
    DWORD dwResult = 0;
    BOOL bClone = FALSE;
    BOOL bExitFromLoop = FALSE;
    LPCWSTR pwszDriverName = NULL;
    PFILE_PATH pfpDriverFilePath = NULL;
    PEFI_DRIVER_ENTRY pDriverEntry = NULL;
    PEFI_DRIVER_ENTRY_LIST pdeMasterList = NULL;
    DWORD dwAttempted = 0, dwFailed = 0;

    //
    // check the input parameter
    //
    if ( pdeList == NULL || pwszSourceEFI == NULL || pwszTargetEFI == NULL ||
        (dwFriendlyNameType != BOOTENTRY_FRIENDLYNAME_NONE && pwszFriendlyName == NULL) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // currently, the pwszFriendlyName is not considered -- so it should be NULL
    if ( pwszFriendlyName != NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // traverse thru the list of driver entries
    lLoop = 0;
    bExitFromLoop = FALSE;
    pdeMasterList = pdeList;        // save the pointer the original drivers list
    while ( bExitFromLoop == FALSE )
    {
        // increment the loop counter
        lLoop++;
        bClone = FALSE;
        dwResult = ERROR_SUCCESS;

        // get the reference to the current driver entry
        pDriverEntry = &pdeList->DriverEntry;
        if ( pDriverEntry == NULL )
        {
            // should never occur
            dwResult = (DWORD) STG_E_UNKNOWN;
            bExitFromLoop = TRUE;
            continue;
        }

        //
        // check whether the current driver's device matches with the requested path
        //

        // extract the driver file path
        pfpDriverFilePath = (PFILE_PATH) ADD_OFFSET( pDriverEntry, DriverFilePathOffset );

        // check whether it matches or not
        bClone = MatchPath( pfpDriverFilePath, pwszSourceEFI, NULL );

        // clone the boot entry -- only if filtering results in TRUE
        if ( bClone == TRUE )
        {
            // updated the attempted count
            dwAttempted++;

            // get the driver name (it is nothing but the friendly name)
            pwszDriverName = (LPCWSTR) ADD_OFFSET( pDriverEntry, FriendlyNameOffset );

            // do the operation
            // but before proceeding confirm that this particular 
            // driver entry is not existing
            if ( FindDriverEntryWithTargetEFI( pdeMasterList, lLoop,
                                               pDriverEntry, pwszTargetEFI ) == -1 )
            {
                dwResult = CloneDriverEntry( pDriverEntry, 
                    pwszTargetEFI, pwszFriendlyName, dwFriendlyNameType );
            }
            else
            {
                dwResult = ERROR_ALREADY_EXISTS;
            }

            // check the result
            if ( dwResult != ERROR_SUCCESS )
            {
                // update the failed count
                dwFailed++;

                // check the severity for the error occured
                switch( dwResult )
                {
                case STG_E_UNKNOWN:                         // unknown error -- unrecoverable
                case ERROR_INVALID_PARAMETER:               // code error
                case ERROR_NOT_ENOUGH_MEMORY:               // unrecovarable case
                    {
                        bExitFromLoop = TRUE;
                        break;
                    }

                case ERROR_ALREADY_EXISTS:
                    {
                        // duplicate boot entry
                        if ( bVerbose == TRUE )
                        {
                            ShowMessageEx( stdout, 1, TRUE, CLONE_DRIVER_ALREADY_EXISTS, pwszDriverName );
                        }

                        // ...
                        dwResult = ERROR_SUCCESS;
                        break;
                    }

                default:
                case ERROR_FILE_NOT_FOUND:
                case ERROR_PATH_NOT_FOUND:
                    {
                        // dont know how to handle this case
                        if ( bVerbose == TRUE )
                        {
                            SetLastError( dwResult );
                            SaveLastError();
                            ShowMessageEx( stdout, 2, TRUE, CLONE_INVALID_DRIVER_ENTRY, pwszDriverName, GetReason() );
                        }

                        // ...
                        dwResult = ERROR_SUCCESS;
                        break;
                    }
                }
            }
            else
            {
                if ( bVerbose == TRUE )
                {
                    ShowMessageEx( stdout, 1, TRUE, CLONE_DRIVER_ENTRY_SUCCESS, pwszDriverName );
                }
            }
        }

        // fetch the next pointer
        // do this only if the error the bExitFromLoop is not set in above blocks
        if ( bExitFromLoop == FALSE )
        {
            bExitFromLoop = (pdeList->NextEntryOffset == 0);
            pdeList = (PEFI_DRIVER_ENTRY_LIST) ADD_OFFSET( pdeList, NextEntryOffset );
        }
    }

cleanup:

    // check the result of the operation
    if ( dwResult == ERROR_SUCCESS )
    {
        if ( dwAttempted == 0 )
        {
            // no driver entries at all
            dwResult = ERROR_FAILED;
            ShowMessage( stdout, CLONE_ZERO_DRIVER_ENTRIES );
        }
        else 
        {
            if ( dwFailed == 0 )
            {
                // nothing failed -- success
                dwResult = ERROR_SUCCESS;
                SetLastError( ERROR_SUCCESS );
                ShowLastErrorEx( stdout, SLE_TYPE_SUCCESS | SLE_SYSTEM );
            }
            else if ( dwAttempted == dwFailed )
            {
                // nothing succeeded -- completely failed
                dwResult = ERROR_FAILED;
                ShowMessage( stderr, CLONE_FAILED );

                // show verbose hint
                if ( bVerbose == FALSE )
                {
                    ShowMessage( stderr, CLONE_DETAILED_TRACE );
                }
            }
            else
            {
                // parital success
                dwResult = ERROR_PARTIAL_SUCCESS;
                ShowMessage( stderr, CLONE_PARTIAL );

                // show verbose hint
                if ( bVerbose == FALSE )
                {
                    ShowMessage( stderr, CLONE_DETAILED_TRACE );
                }
            }
        }
    }
    else
    {
        // check the reason for failure
        switch( dwResult )
        {
        default:
        case STG_E_UNKNOWN:                         // unknown error -- unrecoverable
        case ERROR_INVALID_PARAMETER:               // code error
        case ERROR_NOT_ENOUGH_MEMORY:               // unrecovarable case
            {
                SetLastError( dwResult );
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                break;
            }
        }

        // error code
        dwResult = ERROR_FAILED;
    }

    // return
    return dwResult;
}

DWORD CloneDriverEntry( PEFI_DRIVER_ENTRY pdeSource, LPCWSTR pwszEFIPath, 
                        LPCWSTR pwszFriendlyName, DWORD dwFriendlyNameType )
{
    //
    // local variables
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;

    // friendly name
    DWORD dwFriendlyNameLength = 0;
    LPWSTR pwszTargetFriendlyName = NULL;
    LPCWSTR pwszSourceFriendlyName = NULL;

    // driver file path
    DWORD dwEFIPathLength = 0;
    DWORD dwDriverFilePathLength = 0;
    PFILE_PATH pfpDriverFilePath = NULL;
    LPWSTR pwszFullEFIPath = NULL;

    // driver entry
    ULONG ulId = 0;
    ULONG ulIdCount = 0;
    ULONG* pulIdsArray = NULL;
    DWORD dwDriverEntryLength = 0;
    PEFI_DRIVER_ENTRY pDriverEntry = NULL;

    //
    // implementation
    //

    // check the input
    if ( pdeSource == NULL || pwszEFIPath == NULL ||
         (dwFriendlyNameType != BOOTENTRY_FRIENDLYNAME_NONE && pwszFriendlyName == NULL) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // validate the driver file in the source driver entry
    //

    // extract the driver file path
    pfpDriverFilePath = (PFILE_PATH) ADD_OFFSET( pdeSource, DriverFilePathOffset );

    // attempt to translate the file path
	status = NtTranslateFilePath( pfpDriverFilePath, FILE_PATH_TYPE_NT, NULL, &dwDriverFilePathLength );

    // reset the pDriverFilePath and dwDriverFilePathLength variables
    pfpDriverFilePath = NULL;
    dwDriverFilePathLength = 0;

    // now verify the result of the translation
    if ( NOT NT_SUCCESS( status ) ) 
	{
        if ( status == STATUS_BUFFER_TOO_SMALL )
        {
            // source driver entry is a valid one
            dwResult = ERROR_SUCCESS;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
            goto cleanup;
        }
    }

    //
    // prepare "friendly name"
    //

    // determine the source friendly name and its length
    dwFriendlyNameLength = 0;
    pwszSourceFriendlyName = NULL;
    switch( dwFriendlyNameType )
    {
    case BOOTENTRY_FRIENDLYNAME_NONE:
    case BOOTENTRY_FRIENDLYNAME_APPEND:
        {
            pwszSourceFriendlyName = (LPCWSTR) ADD_OFFSET( pdeSource, FriendlyNameOffset );
            dwFriendlyNameLength = StringLengthW( pwszSourceFriendlyName, 0 ) + 1;
            break;
        }

    default:
        // do nothing
        break;
    }

    // add the length of the friendly name that needs to be added -- if exists
    if ( pwszFriendlyName != NULL )
    {
        dwFriendlyNameLength += StringLengthW( pwszFriendlyName, 0 ) + 1;
    }

    // allocate memory for the friendly name
    pwszTargetFriendlyName = (LPWSTR) AllocateMemory( (dwFriendlyNameLength + 1) * sizeof( WCHAR ) );
    if ( pwszTargetFriendlyName == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // prepare the friendly name
    StringCopyW( pwszTargetFriendlyName, L"", dwFriendlyNameLength );

    // ...
    if ( pwszSourceFriendlyName != NULL )
    {
        StringConcat( pwszTargetFriendlyName, pwszSourceFriendlyName, dwFriendlyNameLength );
    }

    // ...
    if ( pwszFriendlyName != NULL )
    {
        // add one space b/w the existing and concatenating string
        if ( pwszSourceFriendlyName != NULL )
        {
            StringConcat( pwszTargetFriendlyName, L" ", dwFriendlyNameLength );
        }

        // ...
        StringConcat( pwszTargetFriendlyName, pwszFriendlyName, dwFriendlyNameLength );
    }

    //
    // driver file path
    //

    // the 'FilePath' variable in FILE_PATH variable contains two variables
    // each seperated by a NULL terminated character
    // the first part designates the DEVICE PATH
    // and the second part designated the DIRECTORY / FILE PATH
    // we already have the device path (pwszEFIPath) -- but we need to get the
    // DIRECTORY / FILE PATH -- this we will get from the source driver entry
    pfpDriverFilePath = (PFILE_PATH) ADD_OFFSET( pdeSource, DriverFilePathOffset );
    dwResult = PrepareCompleteEFIPath( pfpDriverFilePath, pwszEFIPath, &pwszFullEFIPath, &dwEFIPathLength );
    if ( dwResult != ERROR_SUCCESS )
    {
        // since the memory reference in pDriverFilePath is not allocated
        // in this function, it is important to reset the pointer to NULL
        // this avoids the crash in the program
        pfpDriverFilePath = NULL;

        // ...
        goto cleanup;
    }

	// now determine the memory size that needs to be allocated for FILE_PATH structure
	// and align up to the even memory bounday
    pfpDriverFilePath = NULL;
	dwDriverFilePathLength = FIELD_OFFSET(FILE_PATH, FilePath) + (dwEFIPathLength * sizeof( WCHAR ));

    // allocate memory
    pfpDriverFilePath = (PFILE_PATH) AllocateMemory( dwDriverFilePathLength );
    if ( pfpDriverFilePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // initialize the file path structure
    ZeroMemory( pfpDriverFilePath, dwDriverFilePathLength );
	pfpDriverFilePath->Length = dwDriverFilePathLength;
	pfpDriverFilePath->Type = FILE_PATH_TYPE_NT;
	pfpDriverFilePath->Version = FILE_PATH_VERSION;
	CopyMemory( pfpDriverFilePath->FilePath, pwszFullEFIPath, dwEFIPathLength * sizeof( WCHAR ) );

    //
    // finally, create the driver entry
    //

	// determine the size for the EFI_DRIVER_ENTRY structure
	dwDriverEntryLength = 
        FIELD_OFFSET( EFI_DRIVER_ENTRY, DriverFilePathOffset )  + 
        (dwFriendlyNameLength * sizeof(WCHAR))                  +
        dwDriverFilePathLength                                  + 
        sizeof(WCHAR)                                           +  // align the FriendlyName on WCHAR 
        sizeof(DWORD);                                             // align the DriverFilePath on DWORD

    // allocate memory
    pDriverEntry = (PEFI_DRIVER_ENTRY) AllocateMemory( dwDriverEntryLength );
    if ( pDriverEntry == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // ...
	ZeroMemory( pDriverEntry, dwDriverEntryLength );
	pDriverEntry->Id = 0L;
	pDriverEntry->Length = dwDriverEntryLength;
	pDriverEntry->Version = EFI_DRIVER_ENTRY_VERSION;

    // align the friendly name on WCHR boundary
	pDriverEntry->FriendlyNameOffset = ALIGN_UP( sizeof( EFI_DRIVER_ENTRY ), WCHAR );

    // align the driver file path on DWORD boundary
    pDriverEntry->DriverFilePathOffset = 
        ALIGN_UP( pDriverEntry->FriendlyNameOffset + (dwFriendlyNameLength * sizeof(WCHAR)), DWORD );

    // fill the driver entry
    CopyMemory( ADD_OFFSET( pDriverEntry, DriverFilePathOffset ), pfpDriverFilePath, dwDriverFilePathLength );
    CopyMemory( 
        ADD_OFFSET( pDriverEntry, FriendlyNameOffset ), 
        pwszTargetFriendlyName, (dwFriendlyNameLength * sizeof(WCHAR) ) );

	//
	// add the prepared driver entry
	//
	status = NtAddDriverEntry( pDriverEntry, &ulId );
    if ( NOT NT_SUCCESS( status ) ) 
	{
        dwResult = RtlNtStatusToDosError( status );
		goto cleanup;
	}
	
    //
    // ddd the entry to the driver order.
    //
	ulIdCount = 32L;
    pulIdsArray = (PULONG) AllocateMemory( ulIdCount * sizeof(ULONG) );
    if ( pulIdsArray == NULL )
	{
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // query the driver entry order
    // NOTE: we will doing error check for this function call bit later
    status = NtQueryDriverEntryOrder( pulIdsArray, &ulIdCount );

    // need room in the buffer for the new entry.
    if ( 31L < ulIdCount ) 
    {
        // release the current memory allocation for id's
        FreeMemory( &pulIdsArray );

        // allocate new memory and query again
        pulIdsArray = (PULONG) AllocateMemory( (ulIdCount+1) * sizeof(ULONG));
        if ( pulIdsArray == NULL )
	    {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        // ...
        status = NtQueryDriverEntryOrder( pulIdsArray, &ulIdCount );
    }    
    
    // check the result of the driver entries query operation
    if ( NOT NT_SUCCESS( status ) )
	{
        dwResult = RtlNtStatusToDosError( status );
        goto cleanup;
    }

    // set the boot entry order
    ulIdCount++;
    *(pulIdsArray + (ulIdCount - 1)) = ulId;
    status = NtSetDriverEntryOrder( pulIdsArray, ulIdCount );
    if ( NOT NT_SUCCESS( status ) )
	{
        dwResult = RtlNtStatusToDosError( status );
        goto cleanup;
    }

    // success
    dwResult = ERROR_SUCCESS;

cleanup:

    // release the memory allocated
    FreeMemory( &pulIdsArray );
    FreeMemory( &pDriverEntry );
    FreeMemory( &pwszFullEFIPath );
    FreeMemory( &pfpDriverFilePath );
    FreeMemory( &pwszTargetFriendlyName );

    // return
    return dwResult;
}


LONG FindDriverEntryWithTargetEFI( PEFI_DRIVER_ENTRY_LIST pdeList, DWORD dwSourceIndex,
                                   PEFI_DRIVER_ENTRY pdeSource, LPCWSTR pwszDevicePath )
{
    // local variables
    LONG lIndex = 0;
    BOOL bExitFromLoop = FALSE;
    PFILE_PATH pfpFilePath = NULL;
    LPCWSTR pwszFilePath = NULL;
    LPWSTR pwszFullFilePath = NULL;
    PFILE_PATH pfpSourceFilePath = NULL;
    PEFI_DRIVER_ENTRY pDriverEntry = NULL;
    DWORD dw = 0, dwResult = 0, dwLength = 0;

    // check the input parameters
    if ( pdeList == NULL || pdeSource == NULL || pwszDevicePath == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // extract the file path from the source driver entry
    pfpSourceFilePath = (PFILE_PATH) ADD_OFFSET( pdeSource, DriverFilePathOffset );

    // preare the efi path from the source path
    // (replacing the source device path with the target device path)
    //
    // the 'FilePath' variable in FILE_PATH variable contains two variables
    // each seperated by a NULL terminated character
    // the first part designates the DEVICE PATH
    // and the second part designated the DIRECTORY / FILE PATH
    // we already have the device path (pwszEFIPath) -- but we need to get the
    // DIRECTORY / FILE PATH -- this we will get from the source driver entry
    //
    dwResult = PrepareCompleteEFIPath( pfpSourceFilePath, pwszDevicePath, &pwszFullFilePath, &dwLength );
    if ( dwResult != ERROR_SUCCESS )
    {
        goto cleanup;
    }

    // since we already the target device path -- we need the file path
    // extract this info more just prepared full file path
    dw = StringLengthW( pwszFullFilePath, 0 ) + 1;           // +1 for null character
    if ( dw > dwLength )
    {
        // error case -- this should never occure
        dwResult = (DWORD) STG_E_UNKNOWN;
        goto cleanup;
    }

    // ...
    pwszFilePath = pwszFullFilePath + dw;

    // traverse thru the list of driver entries
    lIndex = 0;
    bExitFromLoop = FALSE;
    dwResult = ERROR_NOT_FOUND;
    while ( bExitFromLoop == FALSE )
    {
        // increment the loop counter
        lIndex++;

        // get the reference to the current driver entry
        pDriverEntry = &pdeList->DriverEntry;
        if ( pDriverEntry == NULL )
        {
            // should never occur
            dwResult = (DWORD) STG_E_UNKNOWN;
            bExitFromLoop = TRUE;
            continue;
        }

        // if the current index doesn't match with the one that we are comparing
        // then only proceed with comparision otherwise skip this
        if ( lIndex != dwSourceIndex )
        {
            // extract the driver file path
            pfpFilePath = (PFILE_PATH) ADD_OFFSET( pDriverEntry, DriverFilePathOffset );

            // compare the file paths
            if ( MatchPath( pfpFilePath, pwszDevicePath, pwszFilePath ) == TRUE )
            {
                bExitFromLoop = TRUE;
                dwResult = ERROR_ALREADY_EXISTS;
                continue;
            }
        }

        // fetch the next pointer
        bExitFromLoop = (pdeList->NextEntryOffset == 0);
        pdeList = (PEFI_DRIVER_ENTRY_LIST) ADD_OFFSET( pdeList, NextEntryOffset );
    }

cleanup:

    // release memory
    FreeMemory( &pwszFullFilePath );

    // result
    return ((dwResult == ERROR_ALREADY_EXISTS) ? lIndex : -1);
}


///////////////////////////////////////////////////////////////////////////////
// general helper functions
///////////////////////////////////////////////////////////////////////////////


DWORD TranslateEFIPathToNTPath( LPCWSTR pwszGUID, LPVOID* pwszPath )
{
    //
    // local variables
    HRESULT hr = S_OK;
    BOOL bSecondChance = FALSE;
    BOOL bExtendedFormat = FALSE;
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;

    // file path
    DWORD dwFilePathLength = 0;
    LPWSTR pwszFilePath = NULL;

    // source FILE_PATH
    DWORD dwSourceFilePathSize = 0;
    PFILE_PATH pfpSourcePath = NULL;

    // target FILE_PATH
    DWORD dwLength = 0;
    DWORD dwTargetFilePathSize = 0;
    PFILE_PATH pfpTargetPath = NULL;

    //
    // implementation
    // 

    // check the parameters
    if ( pwszGUID == NULL || pwszPath == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
		goto cleanup;
    }

    // determine whether we need to choose the extended formatting
    // or normal formatting
    bExtendedFormat = ( (*pwszGUID != L'{') && (*(pwszGUID + StringLengthW( pwszGUID, 0 ) - 1) != L'}') );

    // default length
    dwFilePathLength = MAX_STRING_LENGTH;

try_alloc:

    //
    // allocate memory for formatting the EFI path
    pwszFilePath = AllocateMemory( (dwFilePathLength + 1) * sizeof( WCHAR ) );
    if ( pwszFilePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
		goto cleanup;
    }

    // format EFI path
    if ( bExtendedFormat == FALSE )
    {
        hr = StringCchPrintfW( pwszFilePath, dwFilePathLength, FORMAT_FILE_PATH, pwszGUID );
    }
    else
    {
        hr = StringCchPrintfW( pwszFilePath, dwFilePathLength, FORMAT_FILE_PATH_EX, pwszGUID );
    }

    // check the result -- if failed exit
    if ( HRESULT_CODE( hr ) != S_OK )
    {
        // free the currently allocated block
        FreeMemory( &pwszFilePath );

        // increase the memory in blocks for MAX_STRING_LENGTH
        // but do this only 4 times the originally allocated 
        if ( dwFilePathLength == (MAX_STRING_LENGTH * 4) )
        {
            // cannot afford to give some more tries -- exit
            dwResult = (DWORD) STG_E_UNKNOWN;
			goto cleanup;
        }
        else
        {
            dwFilePathLength *= MAX_STRING_LENGTH;
            goto try_alloc;
        }
    }

    // determine the actual length of the file path
    dwFilePathLength = StringLengthW( pwszFilePath, 0 ) + 1;

    // now determine the memory size that needs to be allocated for FILE_PATH structure
    // and align up to the even memory bounday
    dwSourceFilePathSize = FIELD_OFFSET( FILE_PATH, FilePath ) + (dwFilePathLength * sizeof(WCHAR));

    // allocate memory for boot file path -- extra one byte is for safe guarding
    pfpSourcePath = AllocateMemory( dwSourceFilePathSize + 1 );
    if ( pfpSourcePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
		goto cleanup;
    }

    // initialize the source boot path
    ZeroMemory( pfpSourcePath, dwSourceFilePathSize );
    pfpSourcePath->Type = FILE_PATH_TYPE_ARC_SIGNATURE;
    pfpSourcePath->Version = FILE_PATH_VERSION;
    pfpSourcePath->Length = dwSourceFilePathSize;
    CopyMemory( pfpSourcePath->FilePath, pwszFilePath, dwFilePathLength * sizeof(WCHAR) );

    //
    // do the translation
    //
    // default size for the target file path is same as the one for source file path
    //
    bSecondChance = FALSE;
    dwTargetFilePathSize = dwSourceFilePathSize;

try_translate:

    // allocate memory -- extra one byte is for safe guarding
    pfpTargetPath = AllocateMemory( dwTargetFilePathSize + 1);
    if ( pfpTargetPath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
		goto cleanup;
    }
    
    // attempt to translate the file path
    status = NtTranslateFilePath( pfpSourcePath, 
        FILE_PATH_TYPE_NT, pfpTargetPath, &dwTargetFilePathSize );
    if ( NOT NT_SUCCESS( status ) )
    {
        // release the memory that is allocated for target path structure
        FreeMemory( &pfpTargetPath );

        if ( status == STATUS_BUFFER_TOO_SMALL && bSecondChance == FALSE )
        {
            // give a second try
            bSecondChance = TRUE;
            
			goto try_translate;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
			goto cleanup;
        }
    }

    // re-use the memory that is allocated for file path
    // defintely the NT path will be less than the length of ARC Signature
    // NOTE: since we are interested only in the device path, we use StringCopy
    //       which stops at the first null character -- otherwise, if we are interestedd in
    //       complete path, we need to CopyMemory
    dwLength = StringLengthW( (LPCWSTR) pfpTargetPath->FilePath, 0 );
    if ( dwLength < dwFilePathLength - 1 )
    {
        // copy the string contents
        ZeroMemory( pwszFilePath, (dwFilePathLength - 1) * sizeof( WCHAR ) );
        StringCopyW( pwszFilePath, (LPCWSTR) pfpTargetPath->FilePath, dwFilePathLength );
    }
    else
    {
        // re-allocate memory
        dwLength++;
        if ( ReallocateMemory( (VOID*) &pwszFilePath, (dwLength + 1) * sizeof( WCHAR ) ) == FALSE )
        {
            dwResult = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }

        // ...
        ZeroMemory( pwszFilePath, (dwLength + 1) * sizeof( WCHAR ) );
        StringCopyW( pwszFilePath, (LPCWSTR) pfpTargetPath->FilePath, dwLength );
    }

    // translation is success
    // return the translated file path
    dwResult = ERROR_SUCCESS;
    *pwszPath = pwszFilePath;

cleanup:
    // free memory allocated for target path structure 
    FreeMemory( &pfpTargetPath );

    // release the memory allocated for source path structure
    FreeMemory( &pfpSourcePath );

    // release memory allocated for string
    // NOTE: do this only in case of failure
    if ( dwResult != ERROR_SUCCESS )
    {
        // ...
        FreeMemory( &pwszFilePath );

        // re-init the out params to their default values
        *pwszPath = NULL;
    }

    // return the result
    return dwResult;
}


DWORD PrepareCompleteEFIPath( PFILE_PATH pfpSource, 
                              LPCWSTR pwszDevicePath, 
                              LPWSTR* pwszEFIPath, DWORD* pdwLength )
{
    //
    // local variables
    DWORD dwLength = 0;
    LPWSTR pwszBuffer = NULL;
    BOOL bSecondChance = FALSE;
    PFILE_PATH pfpFilePath = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;
    LPCWSTR pwszSourceFilePath = NULL;
    LPCWSTR pwszSourceDevicePath = NULL;

    //
    // implementation
    //

    // check the input
    if ( pfpSource == NULL || 
         pwszDevicePath == NULL ||
         pwszEFIPath == NULL || pdwLength == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // we need to translate the source file path into NT file path format
    //
    dwLength = 1024;

try_again:

    // allocate memory for the file path structure
    pfpFilePath = (PFILE_PATH) AllocateMemory( dwLength );
    if ( pfpFilePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // attempt to translate the file path
	status = NtTranslateFilePath( pfpSource, FILE_PATH_TYPE_NT, pfpFilePath, &dwLength );
    if ( NOT NT_SUCCESS( status ) ) 
	{
        // release the memory that is allocated for target path structure
        FreeMemory( &pfpFilePath );

        if ( status == STATUS_BUFFER_TOO_SMALL && bSecondChance == FALSE )
        {
            // give a second try
            bSecondChance = TRUE;
            goto try_again;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
            goto cleanup;
        }
    }

    // get the pointer to the source device path
    pwszSourceDevicePath = (LPCWSTR) pfpFilePath->FilePath;
    if ( pwszSourceDevicePath == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // check whether the pwszSourceDevicePath and pwszDevicePath that is 
    // passed to the fuction are same or different
    if ( StringCompare( pwszSourceDevicePath, pwszDevicePath, TRUE, 0 ) == 0 )
    {
        dwResult = ERROR_ALREADY_EXISTS;
        goto cleanup;
    }

    // get the length of the source device path -- +1 for null character
    dwLength = StringLengthW( pwszSourceDevicePath, 0 ) + 1;

    // check whether the directory path exists or not
    // this can be easily determined based on the length of the device path
    // and total of the structure
    if ( pfpFilePath->Length <= (FIELD_OFFSET( FILE_PATH, FilePath ) + dwLength) )
    {
        // the condition 'less than' will never be true -- but equal might
        // that means there is no directory path associated to this file path
        // so simply return
        //
        // NOTE: this is only for safety sake -- this case will never occur
        //
        dwResult = (DWORD) STG_E_UNKNOWN;
        goto cleanup;
    }

    //
    // file path exists -- 
    // this is placed very next to device path seperated by '\0' terminator
    pwszSourceFilePath = pwszSourceDevicePath + dwLength;

    // sum the lengths of the device path (passed by the caller) and directory path (got from source file path)
    // NOTE: +3 ==> ( one '\0' character for each path )
    dwLength = StringLengthW( pwszDevicePath, 0 ) + StringLengthW( pwszSourceFilePath, 0 ) + 3;

    // now allocate memory
    // extra one as safety guard
    pwszBuffer = AllocateMemory( (dwLength + 1) * sizeof( WCHAR ) );
    if ( pwszBuffer == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // copy the new device path (which is passed by the caller) to the newly allocated buffer
    StringCopyW( pwszBuffer, pwszDevicePath, dwLength );

    // increment the pointer leaving one space for UNICODE '\0' character
    StringCopyW( pwszBuffer + (StringLengthW( pwszBuffer, 0 ) + 1),
        pwszSourceFilePath, dwLength - (StringLengthW( pwszBuffer, 0 ) + 1) );

    // success
    dwResult = ERROR_SUCCESS;
    *pwszEFIPath = pwszBuffer;
    *pdwLength = dwLength + 1;      // extra one which we allocated as safe guard

cleanup:

    // free the memory allocated for path translation
    FreeMemory( &pfpFilePath );

    // free memory allocated for buffer space
    // NOTE: release this memory only in case of error
    if ( dwResult != ERROR_SUCCESS )
    {
        // ...
        FreeMemory( &pwszBuffer );

        // also, set the 'out' parameters to their default values
        *pdwLength = 0;
        *pwszEFIPath = NULL;
    }

    // return
    return dwResult;
}


BOOL MatchPath( PFILE_PATH pfpSource, LPCWSTR pwszDevicePath, LPCWSTR pwszFilePath )
{
    //
    // local variables
    DWORD dwLength = 0;
    BOOL bSecondChance = FALSE;
    PFILE_PATH pfpFilePath = NULL;
    DWORD dwResult = ERROR_SUCCESS;
    NTSTATUS status = STATUS_SUCCESS;
    LPCWSTR pwszSourceFilePath = NULL;
    LPCWSTR pwszSourceDevicePath = NULL;

    //
    // implementation
    //

    // check the input
    if ( pfpSource == NULL || (pwszDevicePath == NULL && pwszFilePath == NULL) )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    // we need to translate the source file path into NT file path format
    //
    dwLength = 1024;

try_again:

    // allocate memory for the file path structure
    pfpFilePath = (PFILE_PATH) AllocateMemory( dwLength );
    if ( pfpFilePath == NULL )
    {
        dwResult = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // attempt to translate the file path
	status = NtTranslateFilePath( pfpSource, FILE_PATH_TYPE_NT, pfpFilePath, &dwLength );
    if ( NOT NT_SUCCESS( status ) ) 
	{
        // release the memory that is allocated for target path structure
        FreeMemory( &pfpFilePath );

        if ( status == STATUS_BUFFER_TOO_SMALL && bSecondChance == FALSE )
        {
            // give a second try
            bSecondChance = TRUE;
            goto try_again;
        }
        else
        {
            // error occured -- cannot recover
            dwResult = RtlNtStatusToDosError( status );
            goto cleanup;
        }
    }

    // get the pointer to the source device path
    pwszSourceDevicePath = (LPCWSTR) pfpFilePath->FilePath;
    if ( pwszSourceDevicePath == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // get the length of the source device path -- +1 for null character
    dwLength = StringLengthW( pwszSourceDevicePath, 0 ) + 1;

    // check whether the file path exists or not
    // this can be easily determined based on the length of the device path
    // and total of the structure
    if ( pfpFilePath->Length <= (FIELD_OFFSET( FILE_PATH, FilePath ) + dwLength) )
    {
        // the condition 'less than' will never be true -- but equal might
        // that means there is no file path associated to this file_path
        // so simply return
        //
        // NOTE: this is only for safety sake -- this case will never occur
        //
        dwResult = (DWORD) STG_E_UNKNOWN;
        goto cleanup;
    }

    //
    // file path exists -- 
    // this is placed very next to device path seperated by '\0' terminator
    pwszSourceFilePath = pwszSourceDevicePath + dwLength;

    // check whether the pwszSourceDevicePath and pwszDevicePath that 
    // is passed to the fuction are same or different
    if ( pwszDevicePath != NULL && 
         StringCompare( pwszSourceDevicePath, pwszDevicePath, TRUE, 0 ) != 0 )
    {
        dwResult = ERROR_NOT_FOUND;
        goto cleanup;
    }

    // check whether the pwszSourceFilePath and pwszFilePath that 
    // is passed to the fuction are same or different
    if ( pwszFilePath != NULL && 
         StringCompare( pwszSourceFilePath, pwszFilePath, TRUE, 0 ) != 0 )
    {
        dwResult = ERROR_NOT_FOUND;
        goto cleanup;
    }

    // entries matched
    dwResult = ERROR_ALREADY_EXISTS;

cleanup:

    // free the memory allocated for path translation
    FreeMemory( &pfpFilePath );

    // return
    return (dwResult == ERROR_ALREADY_EXISTS);
}


///////////////////////////////////////////////////////////////////////////////
// parser
///////////////////////////////////////////////////////////////////////////////


DWORD ProcessOptions( DWORD argc, 
                      LPCWSTR argv[],
                      PTCLONE_PARAMS pParams )
{
    //
    // local variables
    DWORD dwResult = 0;
    BOOL bClone = FALSE;
    PTCMDPARSER2 pcmdOption = NULL;
    TCMDPARSER2 cmdOptions[ OI_CLONE_COUNT ];
    
    // check inputs
    if ( argc == 0 || argv == NULL || pParams == NULL )
    {
        dwResult = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // init the entire structure with zero's
	ZeroMemory( cmdOptions, SIZE_OF_ARRAY( cmdOptions )* sizeof( TCMDPARSER2 ) );

    // -clone
    pcmdOption = &cmdOptions[ OI_CLONE_MAIN ];
    pcmdOption->dwCount = 1;
    pcmdOption->pValue = &bClone;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->pwszOptions = OPTION_CLONE;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );

    // -?
    pcmdOption = &cmdOptions[ OI_CLONE_HELP ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwFlags = CP2_USAGE;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->pValue = &pParams->bUsage;
    pcmdOption->pwszOptions = OPTION_CLONE_HELP;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );

    // -sg
    pcmdOption = &cmdOptions[ OI_CLONE_SOURCE_GUID ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_CLONE_SOURCE_GUID;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;

    // -tg
    pcmdOption = &cmdOptions[ OI_CLONE_TARGET_GUID ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_TEXT;
    pcmdOption->pwszOptions = OPTION_CLONE_TARGET_GUID;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL | CP2_MANDATORY;

    // -d
    pcmdOption = &cmdOptions[ OI_CLONE_FRIENDLY_NAME_REPLACE ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_TEXT;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = OPTION_CLONE_FRIENDLY_NAME_REPLACE;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;

    // -d+
    pcmdOption = &cmdOptions[ OI_CLONE_FRIENDLY_NAME_APPEND ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_TEXT;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );
    pcmdOption->pwszOptions = OPTION_CLONE_FRIENDLY_NAME_APPEND;
    pcmdOption->dwFlags = CP2_ALLOCMEMORY | CP2_VALUE_TRIMINPUT | CP2_VALUE_NONULL;

    // -id
    pcmdOption = &cmdOptions[ OI_CLONE_BOOT_ID ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_UNUMERIC;
    pcmdOption->pValue = &pParams->lBootId;
    pcmdOption->pwszOptions = OPTION_CLONE_BOOT_ID;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );

    // -upgdrv
    pcmdOption = &cmdOptions[ OI_CLONE_DRIVER_UPDATE ];
    pcmdOption->dwCount = 1;
    pcmdOption->dwType = CP_TYPE_BOOLEAN;
    pcmdOption->pwszOptions = OPTION_CLONE_DRIVER_UPDATE;
    pcmdOption->pValue = &pParams->bDriverUpdate;
    StringCopyA( pcmdOption->szSignature, "PARSER2", 8 );

    //
    // do the parsing
    pParams->bVerbose = TRUE;           // default value -- user need not specify "/v" explicitly
    if ( DoParseParam2( argc, argv, OI_CLONE_MAIN, OI_CLONE_COUNT, cmdOptions, 0 ) == FALSE )
    {
        dwResult = GetLastError();
        goto cleanup;
    }

    //
    // validate the input parameters
    //

    // check the usage option
    if ( pParams->bUsage == TRUE  )
    {
        if ( argc > 3 )
        {
            // no other options are accepted along with -? option
            dwResult = (DWORD) MK_E_SYNTAX;
            SetReason( MSG_ERROR_INVALID_USAGE_REQUEST );
            goto cleanup;
        }
        else
        {
            // no need of furthur checking of the values
            dwResult = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    // -d and -d+ are mutually exclusive -- 
    // that is, -d and -d+ cannot be specified at a time -- 
    // but it is ok even if both are not specified
    if ( cmdOptions[ OI_CLONE_FRIENDLY_NAME_APPEND ].pValue != NULL &&
         cmdOptions[ OI_CLONE_FRIENDLY_NAME_REPLACE ].pValue != NULL )
    {
        dwResult = (DWORD) MK_E_SYNTAX;
        SetReason( MSG_ERROR_INVALID_DESCRIPTION_COMBINATION );
        goto cleanup;
    }

    // get the buffer pointers allocated by command line parser
    pParams->dwFriendlyNameType = BOOTENTRY_FRIENDLYNAME_NONE;
    pParams->pwszSourceGuid = cmdOptions[ OI_CLONE_SOURCE_GUID ].pValue;
    pParams->pwszTargetGuid = cmdOptions[ OI_CLONE_TARGET_GUID ].pValue;
    if ( cmdOptions[ OI_CLONE_FRIENDLY_NAME_APPEND ].pValue != NULL )
    {
        pParams->dwFriendlyNameType = BOOTENTRY_FRIENDLYNAME_APPEND;
        pParams->pwszFriendlyName = cmdOptions[ OI_CLONE_FRIENDLY_NAME_APPEND ].pValue;
    }
    else if ( cmdOptions[ OI_CLONE_FRIENDLY_NAME_REPLACE ].pValue != NULL )
    {
        pParams->dwFriendlyNameType = BOOTENTRY_FRIENDLYNAME_REPLACE;
        pParams->pwszFriendlyName = cmdOptions[ OI_CLONE_FRIENDLY_NAME_REPLACE ].pValue;
    }

    // -id and -sg are mutually exclusive options
    // also, -upddrv also should not be specified when -id is specified
    if ( cmdOptions[ OI_CLONE_BOOT_ID ].dwActuals != 0 )
    {
        if ( pParams->pwszSourceGuid != NULL || pParams->bDriverUpdate == TRUE )
        {
            dwResult = (DWORD) MK_E_SYNTAX;
            SetReason( MSG_ERROR_INVALID_BOOT_ID_COMBINATION );
            goto cleanup;
        }
    }
    else
    {
        // default value
        pParams->lBootId = -1;
    }

    // -d or -d+ should not be specified when -upddrv is specified
    if ( pParams->pwszFriendlyName != NULL && pParams->bDriverUpdate == TRUE )
    {
        dwResult = (DWORD) MK_E_SYNTAX;
        SetReason( MSG_ERROR_INVALID_UPDDRV_COMBINATION );
        goto cleanup;
    }

    // -sg should be specified when -upddrv switch is specified
    if ( pParams->bDriverUpdate == TRUE && pParams->pwszSourceGuid == NULL )
    {
        dwResult = (DWORD) MK_E_SYNTAX;
        SetReason( MSG_ERROR_NO_SGUID_WITH_UPDDRV );
        goto cleanup;
    }

    // success
    dwResult = ERROR_SUCCESS;

cleanup:

    // return
    return dwResult;
}


DWORD DisplayCloneHelp()
{
    // local variables
    DWORD dwIndex = IDS_CLONE_BEGIN_IA64 ;

    // ...
    for(;dwIndex <=IDS_CLONE_END_IA64;dwIndex++)
    {
        ShowMessage( stdout, GetResString(dwIndex) );
    }

    // return
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\pch.h ===
#ifndef __PCH_H
#define __PCH_H

#if !defined( SECURITY_WIN32 ) && !defined( SECURITY_KERNEL ) && !defined( SECURITY_MAC )
#define SECURITY_WIN32
#endif

// include header file only once
#pragma once

//
// public Windows header files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <Security.h>
#include <SecExt.h>

#include <windows.h>
#include <wchar.h>
#include <io.h>
#include <sys/stat.h>
#include <limits.h>
#include "Shlwapi.h"
#include "winbase.h"

//
// public Windows header files
//
#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>
#include <ntexapi.h>


//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <conio.h>
#include <tchar.h>
#include <Winioctl.h>
#include <Rpcdce.h>
#include <crtdbg.h>
#include <diskguid.h>
#include <rpc.h>
#include <Lm.h>
#include <sddl.h>
#include <malloc.h>

#include "cmdline.h"
#include "cmdlineres.h"

//
// private Common header files
//

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\clip\clip.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\choice\pch.h ===
/*++

    Copyright (c) Microsoft Corporation

    Module Name:

       pch.h

    Abstract:

        Pre-compiled header declaration
       files that has to be pre-compiled into .pch file

    Author:

      Wipro Technologies 22-June.-2001  (Created it)

    Revision History:

      Wipro Technologies

--*/

#ifndef __PCH_H
#define __PCH_H

#pragma once    // include header file only once

//
// public Windows header files

#define CMDLINE_VERSION         200


#include <windows.h>
#include <shlwapi.h>
#include <tchar.h>
#include <strsafe.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <ctype.h>
#include <errno.h>

//
// private Common header files
//
#include "cmdlineres.h"
#include "cmdline.h"

// End of file pch.h
#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\choice\choice.h ===
/*++

Copyright (c) Microsoft    Corporation

Module Name:

    Choice.h

Abstract:

  This module  contains    function definitions required by Choice.cpp

Author:
     Wipro Technologies    22-June.-2001  (Created    it)

Revision History:

--*/
#ifndef    _CHOICE_H
#define    _CHOICE_H

#include "resource.h"

// Defines
#define    MAX_NUM_RECS            2
#define    OPEN_BRACKET           L"["
#define    CLOSED_BRACKET           L"]?"
#define    COMMA                   L","
#define    SPACE                    L" "
//#define    OUTOUT_DEVICE_ERROR       1000    // this    value should not be    in resource.h
#define    MAX_COMMANDLINE_OPTION      7     //    Maximum    Command    Line options

#define    EXIT__FAILURE             255
#define    NULL_U_STRING                 L"\0"
#define    NULL_U_CHAR                L'\0'

#define    EXIT_SUCCESS            0
#define    FREQUENCY_IN_HERTZ       1500
#define    DURETION_IN_MILI_SEC    500
#define    MILI_SEC_TO_SEC_FACTOR    1000
#define    TIMEOUT_MIN                   0
#define    TIMEOUT_MAX                  9999
#define    DEFAULT_CHOICE            GetResString(IDS_DEFAULT_CHOICE)



// following are indxes    used for command line parameter
#define    ID_HELP                0
#define    ID_CHOICE            1
#define    ID_PROMPT_CHOICE    2
#define    ID_CASE_SENSITIVE    3

#define    ID_DEFAULT_CHOICE    4
#define    ID_TIMEOUT_FACTOR    5
#define    ID_MESSAGE_STRING    6

#define    END_OF_LINE                L"\n"
/*#define    RELEASE_MEMORY_EX( block )    \
    if ( NULL!=(block)    )           \
    {                                \
        delete [] (block);            \
        (block)    = NULL;                \
    }                                \
    1

#define    DESTROY_ARRAY( array )    \
    if ( NULL != (array) )    \
    {    \
        DestroyDynamicArray( &(array) );    \
        (array)    = NULL;\
    }    \
    1*/

BOOL
ProcessCMDLine(
    IN DWORD argc,
    IN LPCWSTR argv[],
    OUT    TCMDPARSER2 *pcmdParcerHead,
    OUT    PBOOL  pbUsage,
    OUT    LPWSTR pszChoice,
    OUT    PBOOL  pbCaseSensitive,
    OUT    PBOOL  pbShowChoice,
    OUT    PLONG  plTimeOutFactor,
    OUT    LPWSTR pszDefaultChoice,
    OUT    LPWSTR pszMessage);

void ShowUsage(void); // displays the help

BOOL
BuildPrompt(
    IN    TCMDPARSER2 *pcmdParcer,
    IN    BOOL       bShowChoice,
    IN    LPWSTR       pszChoice,
    IN    LPWSTR       pszMessage,
    OUT    LPWSTR       pszPromptStr);



DWORD
UniStrChr(
    IN LPWSTR pszBuf,
    IN WCHAR  szChar);
    

DWORD
GetChoice(
    IN LPCWSTR pszPromptStr,
    IN LONG       lTimeOutFactor,
    IN BOOL       bCaseSensitive,
    IN LPWSTR  pszChoice,
    IN LPCWSTR pszDefaultChoice,
    OUT    PBOOL  pbErrorOnCarriageReturn);

BOOL
  CheckforDuplicates( IN LPWSTR    lpszChoice );

/*void
MakeErrorMsg(
    IN    HRESULT    hr,
    OUT    LPWSTR    pszErrorMsg);*/

BOOL
WINAPI HandlerRoutine( DWORD dwCtrlType    ) ;


// End of file
#endif // _CHOICE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\choice\resource.h ===
#define IDS_INCORRECT_SYNTAX        1
#define IDS_D_WITHOUT_T             2
#define IDS_T_INVALID_VALUE         3

#define IDS_D_BIG                   4
#define IDS_D_NOT_MATCHED_TO_C      5
#define IDS_D_MISSING               6
#define IDS_TYPE_HELP               7
//#define ID_UNKNOWN_HANLDE           8
#define IDS_C_EMPTY                 9

#define IDS_DUPLICATE_CHOICE        10
#define IDS_CHOICE_INVALID          11

#define IDS_MESSAGE_OVERFLOW        12
#define IDS_TWO_BYTES_NOTALLOWED    13
#define IDS_TFACTOR_NULL_STIRNG     14
#define IDS_INVALID_TIMEOUT_FACTOR  15
#define IDS_FILE_EMPTY              16
#define IDS_DEFAULT_CHOICE          17
#define IDS_ERR_CHARUPPER           18
#define IDS_DEFAULT_EMPTY           19


#define IDS_HELP1                50
#define IDS_HELP2                51
#define IDS_HELP3                52
#define IDS_HELP4                53
#define IDS_HELP5                54
#define IDS_HELP6                55
#define IDS_HELP7                56
#define IDS_HELP8                57
#define IDS_HELP9                58
#define IDS_HELP10               59
#define IDS_HELP11               60
#define IDS_HELP12               61
#define IDS_HELP13               62
#define IDS_HELP14               63
#define IDS_HELP15               64
#define IDS_HELP16               65
#define IDS_HELP17               66
#define IDS_HELP18               67
#define IDS_HELP19               68
#define IDS_HELP20               69
#define IDS_HELP21               70
#define IDS_HELP22               71
#define IDS_HELP23               72
#define IDS_HELP24               73
#define IDS_HELP25               74
#define IDS_HELP26               75
#define IDS_HELP27               76
#define IDS_HELP28               77
#define IDS_HELP29               78
#define IDS_HELP30               79
#define IDS_HELP31               80
#define IDS_HELP32               81
#define IDS_HELP33               82
#define IDS_HELP34               83
#define IDS_HELP35               84
#define IDS_HELP36               85
#define IDS_HELP37               86
#define IDS_HELP38               87
#define IDS_HELP39               88
#define IDS_HELP40               89
#define IDS_HELP41               90
#define IDS_HELP42               91
#define IDS_HELP43               92
#define IDS_HELP44               93
#define IDS_HELP45               94
#define IDS_HELP46               95
#define IDS_HELP47               96
#define IDS_HELP48               97
#define IDS_HELP_END             98
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\clip\resource.h ===
#define IDS_MAIN_HELP_BEGIN 101
#define IDS_HELP_LINE2      102
#define IDS_HELP_LINE3      103
#define IDS_HELP_LINE4      104
#define IDS_HELP_LINE5      105
#define IDS_HELP_LINE6      106
#define IDS_HELP_LINE7      107
#define IDS_HELP_LINE8      108
#define IDS_HELP_LINE9      109
#define IDS_HELP_LINE10     110
#define IDS_HELP_LINE11     111
#define IDS_HELP_LINE12     112
#define IDS_HELP_LINE13     113
#define IDS_HELP_LINE14     114
#define IDS_MAIN_HELP_END   115

#define IDS_CLIP_ERROR                  201
#define IDS_ERROR_OPENING_CLIPBOARD     202
#define IDS_ERROR_EMPTYING_CLIPBOARD    203
#define IDS_ERROR_CLOSING_CLIPBOARD     204
#define IDS_HELP_MESSAGE                206
#define IDS_MULTIBYTE_WIDECHAR_FAILED           207
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\clip\pch.h ===
#ifndef __PCH_H
#define __PCH_H

// include header file only once
#pragma once

//
// public Windows header files
//
#include <windows.h>
#include <windowsx.h>
#include <tchar.h>

//
// public C header files
//
#include <stdio.h>
#include <stdlib.h>
#include <shlwapi.h>
#include <stdarg.h>
#include <shellapi.h>

//
// private Common header files
//
#include "cmdline.h"
#include "cmdlineres.h"

#endif  // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\choice\choice.c ===
/*++

Copyright (c) Microsoft Corporation

Module Name:

    Choice.c

Abstract:

    Choice is a Win32 console application designed to duplicate
    the functionality of the choice.com utility found in MSDOS version
    6.0.  Rather than simply using the C run-time routines, choice
    utilizes Win32 console routines and the signalling abilities of the
    file objects.

Author:
     Wipro Technologies 2-July.-2001  (Created it)

Revision History:

--*/
#include "pch.h"
#include "choice.h"

DWORD 
__cdecl wmain(
            IN DWORD argc,
            IN LPCWSTR argv[] )
/*++

  Routine description   : Main function which calls all the other main functions
                          depending on the option specified by the user.

  Arguments:
          [in] argc     : argument count specified at the command prompt.
          [in] argv     : arguments specified at the command prompt.

  Return Value        : DWORD
         0            : If the utility successfully performs the operation.
         1            : If the utility is unsuccessful in performing the specified
                        operation.
--*/
{


    TCMDPARSER2 cmdOptions[ MAX_COMMANDLINE_OPTION ]; //command line options

    WCHAR  szChoice[MAX_STRING_LENGTH] ; // to store options for /c
    WCHAR  szMessage[256] ; // Message to be shown for
    WCHAR  szPromptStr[512] ;//Message finaly prompted
    WCHAR  szDefaultChoice[256] ; //default choice string
    WCHAR  wszBuffer[2*MAX_RES_STRING] ;


    BOOL          bShowChoice      = FALSE;//choice to be shown or not
    BOOL          bCaseSensitive   = FALSE; // choice will be case sensitive or not
    BOOL          bUsage           = FALSE; // is help required
    LONG          lTimeoutFactor   = 0; //Time out factor
    BOOL          bReturn          = FALSE; // Stores the return value
    DWORD         lReturnValue     = EXIT__FAILURE; // Return value of application
    BOOL          bErrorOnCarriageReturn = FALSE;
    
    HRESULT hr;


    SecureZeroMemory(szChoice, MAX_STRING_LENGTH * sizeof(WCHAR));
    SecureZeroMemory(szMessage, 256 * sizeof(WCHAR));
    SecureZeroMemory(szPromptStr, 512 * sizeof(WCHAR));
    SecureZeroMemory(szDefaultChoice, 256 * sizeof(WCHAR));
    SecureZeroMemory(wszBuffer, (2*MAX_RES_STRING) * sizeof(WCHAR));
    

    bReturn =    ProcessCMDLine( argc,
                             argv,
                             &cmdOptions[ 0 ], // Command line struct
                             &bUsage,          // Is help
                             szChoice,         // Choice
                             &bCaseSensitive,  // Casesensitive
                             &bShowChoice,     // Show Choice
                             &lTimeoutFactor,  // Timeout factor
                             szDefaultChoice,  // Timeout choice
                             szMessage         // Message
                             );

    if( FALSE == bReturn)
    {
        // Show Error message on screen depending on Reason Set
        
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
         
        
        // Release all global memory allocation. This allocation are done
        // by common functionality.
        ReleaseGlobals();
        return EXIT__FAILURE;
    }

    if ( TRUE == bUsage)
    {
        ShowUsage(); // Display Usage
        // Release all global memory allocation. This allocation are done
        // by common functionality.
        ReleaseGlobals();
        return EXIT_SUCCESS;
    }

    // Check if timeout factor is 0


    bReturn = BuildPrompt( cmdOptions,
                           bShowChoice,
                           szChoice,
                           szMessage,
                           szPromptStr); // Show message on Prompt.
    if (FALSE == bReturn)
    {
        // Release all global memory allocation. This allocation are done
        // by common functionality.
        ReleaseGlobals();
        return EXIT__FAILURE;
    }

    if((cmdOptions[ ID_TIMEOUT_FACTOR ].dwActuals > 0) &&
       ( 0 == lTimeoutFactor ))
    {
        // Release all global memory allocation. This allocation are done
        // by common functionality.

        // Safely return from utility
        
        SecureZeroMemory(wszBuffer, 2*MAX_STRING_LENGTH);
        
        hr = StringCchPrintf(wszBuffer, SIZE_OF_ARRAY(wszBuffer), L"%s%s\n", _X(szPromptStr), _X2(szDefaultChoice));
        if(FAILED(hr))
        {
           SetLastError(HRESULT_CODE(hr));
           return EXIT__FAILURE;
        }

        ShowMessage(stdout,wszBuffer); 
         
        ReleaseGlobals();
        return UniStrChr( szChoice, szDefaultChoice[0] );
        
    }

    // Now wait for input OR expire of timeout
    lReturnValue =  GetChoice( szPromptStr,
                               lTimeoutFactor,
                               bCaseSensitive,
                               szChoice,
                               szDefaultChoice,
                               &bErrorOnCarriageReturn);

    if(EXIT__FAILURE == lReturnValue)
    {
        if(bErrorOnCarriageReturn == FALSE)
        {
        // Show Error message on screen depending on Reason Set
            
            StringCopyW( szPromptStr, GetReason(), 2*MAX_STRING_LENGTH );

            
            if(StringLengthW(szPromptStr, 0) == 0)
            {
                ShowMessage(stderr, szPromptStr);
                ShowMessage(stderr, GetResString(IDS_FILE_EMPTY));

            }
            else
            {
                hr = StringCchPrintf(szPromptStr, SIZE_OF_ARRAY(szPromptStr), L"\n%s %s", TAG_ERROR, GetReason());
                if(FAILED(hr))
                {
                   SetLastError(HRESULT_CODE(hr));
                   return EXIT__FAILURE;
                }

                ShowMessage(stderr, szPromptStr); 
            }

        }
        else
        {
                ShowMessage(stderr, GetReason());
        }
        // Release all global memory allocation. This allocation are done
        // by common functionality.
        ReleaseGlobals();
        return EXIT__FAILURE;
    }


    // Release all global memory allocation. This allocation are done
    // by common functionality.
    ReleaseGlobals();
    return lReturnValue;
}
// End of function wmain

BOOL
ProcessCMDLine(
    IN DWORD argc,
    IN LPCWSTR argv[],
    OUT TCMDPARSER2 *pcmdParcerHead,
    OUT PBOOL  pbUsage,
    OUT LPWSTR pszChoice,
    OUT PBOOL  pbCaseSensitive,
    OUT PBOOL  pbShowChoice,
    OUT PLONG  plTimeOutFactor,
    OUT LPWSTR pszDefaultChoice,
    OUT LPWSTR pszMessage)
/*++
   Routine Description:
    This function will prepare column structure for DoParseParam Function.

   Arguments:
        IN argc              : Command line argument count
        IN argv              : Command line argument
        OUT pcmdParcerHead       : Pointer to Command line parcer structure
        OUT pbUsage          : Stores the status if help required
        OUT pszChoice        : Stores choices given
        OUT pbCaseSensitive  : Stores the status if choices are case-sensitive
        OUT pbShowChoice     : Stores the status if choices to be shown
        OUT plTimeOutFactor  : Stores time out factor
        OUT pszDefaultChoice : Stores default choices
        OUT pszMessage       : Stores message string
   Return Value:
         TRUE :   Return successfully
         FALSE:   Return due to error
--*/
{
    BOOL          bReturn    = FALSE;// strore return value
    
    WCHAR  szErrorMsg[64] ;
    WCHAR  szCharac[2] ;
    WCHAR  szTemp[128] ;
    WCHAR  szTimeFactor[MAX_STRING_LENGTH] ;
    TCMDPARSER2*  pcmdParcer = NULL;
    TCMDPARSER2*  pcmdTmp    = NULL;
    DWORD        dw         =0;
    DWORD        dwVal          =0;
    DWORD        dwcount = 0;
    DWORD       dwLen = 0;
    
    WCHAR*      pszStopTimeFactor = NULL;
    HRESULT hr;

    const WCHAR* wszOptionHelp            =    L"?";  //OPTION_HELP
    const WCHAR* wszOptionChoice          =    L"C" ;       //OPTION_CHOICE   
    const WCHAR* wszOptionPromptChoice    =    L"N" ; //OPTION_PROMPT_CHOICE
    const WCHAR* wszOptionCaseSensitive   =    L"CS" ;   //OPTION_CASE_SENSITIVE
    const WCHAR* wszOptionDefaultChoice   =    L"D" ;  //wszOptionDefaultChoice  
    const WCHAR* wszOptionTimeoutFactor   =    L"T" ; //OPTION_TIMEOUT_FACTOR
    const WCHAR* wszOptionDefaultString   =    L"M" ; //OPTION_DEFAULT_STRING

    SecureZeroMemory(szErrorMsg, 64 * sizeof(WCHAR));
    SecureZeroMemory(szCharac, 2 * sizeof(WCHAR));
    SecureZeroMemory(szTemp, 128 * sizeof(WCHAR));
    SecureZeroMemory(szTimeFactor, MAX_STRING_LENGTH * sizeof(WCHAR));


    // Check validity of Pointer
    if( (NULL == pcmdParcerHead)   ||
        (NULL == pbUsage)          ||
        (NULL == pszChoice)        ||
        (NULL == pbCaseSensitive)  ||
        (NULL == pbShowChoice)     ||
        (NULL == plTimeOutFactor)  ||
        (NULL == pszDefaultChoice) ||
        (NULL == pszMessage))
    {
        SetLastError( RPC_X_NULL_REF_POINTER );
        SaveLastError();
        return bReturn;
    }


    // Filling m_cmdOptions structure
    // -?
    
    pcmdParcer = pcmdParcerHead + ID_HELP;

    StringCopyA( pcmdParcer->szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_BOOLEAN;
    
    pcmdParcer-> pwszOptions = wszOptionHelp;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;

    pcmdParcer->dwFlags  = CP2_USAGE;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = pbUsage;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;

    pcmdParcer-> pFunction     = NULL;
    pcmdParcer-> pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;


    // -c choices
    pcmdParcer = pcmdParcerHead + ID_CHOICE;
    
    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_TEXT;
    
    pcmdParcer-> pwszOptions = wszOptionChoice;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags    = 0;
    pcmdParcer->dwCount    = 1;
    pcmdParcer->dwActuals  = 0;
    pcmdParcer->pValue     = pszChoice;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;


    //-n Show choice
    pcmdParcer = pcmdParcerHead + ID_PROMPT_CHOICE;

    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_BOOLEAN;
    
    pcmdParcer-> pwszOptions = wszOptionPromptChoice;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags   = 0;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = pbShowChoice;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;


    // -cs case sensitive
    pcmdParcer = pcmdParcerHead + ID_CASE_SENSITIVE;

    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_BOOLEAN;
    
    pcmdParcer-> pwszOptions = wszOptionCaseSensitive;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags   = 0;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = pbCaseSensitive;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;



    // -d default choice
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    
    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_TEXT;
    
    pcmdParcer-> pwszOptions = wszOptionDefaultChoice;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags   = CP2_VALUE_TRIMINPUT;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = pszDefaultChoice;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;


    // -t time-out factor
    pcmdParcer = pcmdParcerHead + ID_TIMEOUT_FACTOR;

    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_TEXT;
    
    pcmdParcer-> pwszOptions = wszOptionTimeoutFactor;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags   = CP2_VALUE_TRIMINPUT;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = szTimeFactor;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;



    // -m message text
    pcmdParcer = pcmdParcerHead + ID_MESSAGE_STRING;
    
    StringCopyA( pcmdParcer-> szSignature, "PARSER2\0", 8 );
    
    pcmdParcer-> dwType = CP_TYPE_TEXT;
    
    pcmdParcer-> pwszOptions = wszOptionDefaultString;
    pcmdParcer-> pwszFriendlyName = NULL;
    pcmdParcer-> pwszValues = NULL;
    pcmdParcer->dwFlags   = CP2_VALUE_TRIMINPUT;
    pcmdParcer->dwCount   = 1;
    pcmdParcer->dwActuals = 0;
    pcmdParcer->pValue    = pszMessage;
    pcmdParcer->dwLength    = MAX_STRING_LENGTH;
    
    pcmdParcer->pFunction     = NULL;
    pcmdParcer->pFunctionData = NULL;
    pcmdParcer-> dwReserved = 0;
    pcmdParcer-> pReserved1 = NULL;
    pcmdParcer-> pReserved2 = NULL;
    pcmdParcer-> pReserved3 = NULL;

    // re-assign it to head position
    pcmdParcer = pcmdParcerHead;
    
    bReturn = DoParseParam2( argc, argv, -1, MAX_COMMANDLINE_OPTION, pcmdParcer, 0);
    if( FALSE == bReturn) // Invalid commandline
    {
        // Reason is already set by DoParseParam
        return FALSE;
    }

    
    if( TRUE == *pbUsage )
    {
        if(2 == argc  )
        {
            return( TRUE );
        }
        else
        {
            
            StringCopyW( szErrorMsg, GetResString( IDS_INCORRECT_SYNTAX ), SIZE_OF_ARRAY(szErrorMsg) );
            
            SetReason( szErrorMsg );
            return FALSE;

        }

    }

    // /d can be specified only if /t is specified.
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    pcmdTmp    = pcmdParcerHead + ID_TIMEOUT_FACTOR;
    if((pcmdParcer-> dwActuals > 0 ) &&( 0 == pcmdTmp-> dwActuals ))
    {
        // Error String will be ..
        //Invalid syntax. /D can be specified only when /T is
        //specified.
        //Type CHOICE /? for usage.
       
        StringCopyW( szTemp, GetResString( IDS_D_WITHOUT_T ), SIZE_OF_ARRAY(szTemp) );
        
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }

    // /f should come if /d is given
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    pcmdTmp    = pcmdParcerHead + ID_TIMEOUT_FACTOR;
    if(( 0 == pcmdParcer-> dwActuals ) &&( pcmdTmp-> dwActuals > 0 ) )
    {
        // Error String will be ..
        // Invalid syntax. /D missing.
        // Type CHOICE /? for usage.
        
        StringCopyW( szTemp, GetResString( IDS_D_MISSING ), SIZE_OF_ARRAY(szTemp) );
        
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }

    // Time factor value should be in range TIMEOUT_MIN - TIMEOUT_MAX
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    
    if(pcmdParcer-> dwActuals > 0 && szTimeFactor != NULL && StringLengthW(szTimeFactor, 0) == 0)
    {
       
       StringCopyW( szTemp, GetResString( IDS_TFACTOR_NULL_STIRNG ), SIZE_OF_ARRAY(szTemp) );
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;

    }

    *plTimeOutFactor = wcstol(szTimeFactor,&pszStopTimeFactor,10);
    
    if((errno == ERANGE) || (NULL != pszStopTimeFactor && StringLengthW(pszStopTimeFactor, 0) != 0))
    {
        
        StringCopyW( szTemp, GetResString( IDS_INVALID_TIMEOUT_FACTOR ), SIZE_OF_ARRAY(szTemp) );
        SetReason(szTemp);
        return FALSE;

    }

    if( pcmdParcer-> dwActuals > 0 &&
      (( *plTimeOutFactor < TIMEOUT_MIN)||
       ( *plTimeOutFactor > TIMEOUT_MAX )))
    {
        // Error String will be ..
        // Invalid syntax. Valid range for /t is (0 - 99).
        // Type CHOICE /? for usage.
       
       hr = StringCchPrintf(szTemp, SIZE_OF_ARRAY(szTemp), GetResString(IDS_T_INVALID_VALUE),TIMEOUT_MIN,TIMEOUT_MAX);
       if(FAILED(hr))
        {
           SetLastError(HRESULT_CODE(hr));
           SaveLastError();
           return FALSE;
        }

       
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }

    // if /c is specified then it cannot be empty
    pcmdParcer = pcmdParcerHead + ID_CHOICE;

    
    if( pcmdParcer-> dwActuals > 0 && (StringLengthW( pszChoice, 0 ) == 0))
    {
        // Error String will be ..
        // Invalid syntax. Choice cannot be empty.
       
       StringCopyW( szTemp, GetResString( IDS_C_EMPTY ), SIZE_OF_ARRAY(szTemp) );
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }

    if( pcmdParcer-> dwActuals > 0)
    {

        
        dwVal = StringLengthW( pszChoice, 0 );

        for(dwcount;dwcount < dwVal;dwcount++)
        {
           szCharac[0] = pszChoice[dwcount];
           szCharac[1] = '\0';
            if((dwLen = StringLengthInBytes(szCharac)) > 1)
            {
                
                StringCopyW( szTemp, GetResString( IDS_TWO_BYTES_NOTALLOWED ), SIZE_OF_ARRAY(szTemp) );
               // Set the reason in memory
               SetReason(szTemp);

                return FALSE;
            }
        }

        for(dw;dw < dwVal;dw++)
        {
            if( ((DWORD)pszChoice[dw]) <= 47 ||
                (((DWORD)pszChoice[dw]) > 122 &&((DWORD)pszChoice[dw]) < 127)||
                (((DWORD)pszChoice[dw]) > 57 &&((DWORD)pszChoice[dw]) < 65 ) ||
                (((DWORD)pszChoice[dw]) > 90 &&((DWORD)pszChoice[dw]) < 97 ) ||
                ((DWORD)pszChoice[dw]) == 160)
            {
               
               StringCopyW( szTemp, GetResString( IDS_CHOICE_INVALID ), SIZE_OF_ARRAY(szTemp) );
               // Set the reason in memory
               SetReason(szTemp);
               return FALSE;

            }
        }

    }

    // if /c is not specified then make default choice as "YN"
    pcmdParcer = pcmdParcerHead + ID_CHOICE;
    if(0 == pcmdParcer-> dwActuals)
    {
        
        StringCopyW( pszChoice, DEFAULT_CHOICE, MAX_STRING_LENGTH);
    }


    pcmdParcer = pcmdParcerHead + ID_CHOICE;
    if((pcmdParcer-> dwActuals > 0 ) && ( FALSE == *pbCaseSensitive ))
    {
        dw = 0;
        for(dw;dw < dwVal;dw++)
        {
            if( ((DWORD)pszChoice[dw]) <= 127 )
            {
                if(0 == CharUpperBuff( pszChoice+dw, 1))
                {
                   
                   StringCopyW( szTemp, GetResString( IDS_ERR_CHARUPPER ), SIZE_OF_ARRAY(szTemp) );
                   // Set the reason in memory
                   SetReason(szTemp);
                   return FALSE;

                }

            }

        }

    }

    //now check for duplicates in choice
    if(FALSE == CheckforDuplicates( pszChoice ) )
    {
        
        StringCopyW( szTemp, GetResString( IDS_DUPLICATE_CHOICE ), SIZE_OF_ARRAY(szTemp) );
       // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }

    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    if( pcmdParcer-> dwActuals > 0 )
    {
        
        if(0 == StringLengthW( pszDefaultChoice, 0 ))
        {
           
           StringCopyW( szTemp, GetResString( IDS_DEFAULT_EMPTY ), SIZE_OF_ARRAY(szTemp) );
           // Set the reason in memory
           SetReason(szTemp);
           return FALSE;

        }

        if( FALSE == *pbCaseSensitive )
        {
            // Make the string to upper case
            if( ((DWORD)pszDefaultChoice[0]) <= 127 )
            {
                
                if( 0 == CharUpperBuff( pszDefaultChoice, StringLengthW( pszDefaultChoice, 0 )))
                {
                   
                   StringCopyW( szTemp, GetResString( IDS_ERR_CHARUPPER ), SIZE_OF_ARRAY(szTemp) );
                   // Set the reason in memory
                   SetReason(szTemp);
                   return FALSE;
                }
            }
        }

    }

    // length of /d cannot be more than one character
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    

    if(( pcmdParcer-> dwActuals > 0 ) &&(StringLengthW( pszDefaultChoice, 0 ) > 1 ))
    {
        // Error String will be ..
        // Invalid syntax. /D7/2/2001 accepts only single character.
        // Type CHOICE /? for usage.
        
        StringCopyW( szTemp, GetResString( IDS_D_BIG ), SIZE_OF_ARRAY(szTemp) );
        
        // Set the reason in memory
       SetReason(szTemp);
       return FALSE;
    }


    // check if timeout choice is given in choice list
    pcmdParcer = pcmdParcerHead + ID_DEFAULT_CHOICE;
    if (pcmdParcer-> dwActuals > 0 )
    {
        
        if(0 == UniStrChr( pszChoice, pszDefaultChoice[ 0 ] ))
        {
            // Error String will be ..
            // Invalid syntax. Time Factor choice not in specified choices.
            // Type CHOICE /? for usage.
            
            StringCopyW( szTemp, GetResString( IDS_D_NOT_MATCHED_TO_C ), SIZE_OF_ARRAY(szTemp) );
            
            // Set the reason in memory
            SetReason( szTemp );
            return FALSE;
        }
    }

    pcmdParcer = pcmdParcerHead + ID_MESSAGE_STRING;
    if(pcmdParcer-> dwActuals > 0)
    {
        
        if( StringLengthW(pszMessage, 0) > MAX_STRING_LENGTH )
        {
            
            StringCopyW( szTemp, GetResString( IDS_MESSAGE_OVERFLOW ), SIZE_OF_ARRAY(szTemp) );
            SetReason( szTemp );
            return FALSE;
        }
    }
    return TRUE;
}
// End of function ProcessCMDLine

void
ShowUsage( void )
/*--
Routine Description
    This function shows help message for CHOICE
Arguments:
    NONE
Return Value
    None
--*/
{
    DWORD dwIndx = 0; // Index Variable

    for(dwIndx = IDS_HELP1; dwIndx <= IDS_HELP_END; dwIndx++ )
    {
       
        ShowMessage( stdout, GetResString( dwIndx ) );
    }

    return;
}
// End of function ShowUsage

BOOL
BuildPrompt(
    IN  TCMDPARSER2 *pcmdParcer,
    IN  BOOL       bShowChoice,
    IN  LPWSTR     pszChoice,
    IN  LPWSTR     pszMessage,
    OUT LPWSTR     pszPromptStr)
/*++
   Routine Description:
    This function will Build command message prompt

   Arguments:
        [IN]  pcmdParcer    : Pointer to Command line parcer structure
        [IN]  bShowChoice   : Stores the status, if choice to be shown
        [IN]  pszChoice     : Choice string
        [IN]  pszMessage    : Message String
        [OUT] pszPromptStr  : Final String to be shown on screen

   Return Value:
         TRUE     if success
         FALSE    if failure
--*/
{
  
  WCHAR     szChar[32] ;
  
  LPWSTR        pszTemp = NULL; // Temp. string pointer

  SecureZeroMemory(szChar, 32 * sizeof(WCHAR));

  // Check for validity of pointer variables
  if (( NULL == pcmdParcer) ||
      ( NULL == pszPromptStr))
  {
      return FALSE;
  }

  szChar[1] = NULL_U_CHAR; // make second character as end of line
  // check if /M is given if given copy it to prompt string
  pcmdParcer +=  ID_MESSAGE_STRING;

  if( pcmdParcer-> dwActuals > 0 )
    {
        
        StringCopyW( pszPromptStr, pszMessage, 2*MAX_STRING_LENGTH );
        
        StringConcat(pszPromptStr, SPACE, 2*MAX_STRING_LENGTH);
    }

  if( TRUE == bShowChoice )
    {
      return TRUE;
    }

   // now append '[' to it
   
   StringConcat(pszPromptStr, OPEN_BRACKET, 2*MAX_STRING_LENGTH);
   // now append prompt characters to it
   pszTemp = pszChoice;

   do
   {
       szChar[ 0 ] = pszTemp[ 0 ]; // always assing first character of
                                   //m_pszChoice as first character is
                                   // changing in this loop

      
      StringConcat(pszPromptStr, szChar, 2*MAX_STRING_LENGTH);
      // now append a COMMA to this
      // comma will be appended only if length of m_pszChoise
      // is grester than 1
      
      if( StringLengthW( pszTemp, 0 ) > 1 )
      
       {
          
          StringConcat(pszPromptStr, COMMA, 2*MAX_STRING_LENGTH);
       }
      pszTemp = CharNext( pszTemp );
   
   }while( StringLengthW( pszTemp, 0 ) != 0);

   // now close the bracket
   
   StringConcat(pszPromptStr, CLOSED_BRACKET, 2*MAX_STRING_LENGTH);

   return TRUE;
}
// End of function BuildPrompt

DWORD
UniStrChr(
    IN LPWSTR pszBuf,
    IN WCHAR  szChar
    )
/*++
   Routine Description:
      This function finds the character in given string
   Arguments:
      [IN] pszBuf    : Target String in which character is be find
      [IN] szChar       : Character to be found
    Return Value:
         returned string pointer after the character found.
--*/
{
    LONG lPos = 0;
   // find the character in string
   while( NULL_U_CHAR != *pszBuf ) // Loop till string teminated character found
                         // 0 is always teminated character
   {
       lPos++;
       if ( *(pszBuf++) == szChar )
       {
            
              return(lPos) ;
       }

    }
    return(0);

}
// End of function UniStrChr

DWORD
GetChoice(
    IN LPCWSTR pszPromptStr,
    IN LONG    lTimeOutFactor,
    IN BOOL    bCaseSensitive,
    IN LPWSTR  pszChoice,
    IN LPCWSTR pszDefaultChoice,
    OUT PBOOL  pbErrorOnCarriageReturn)
/*++
   Routine Description:
     This function get choice from console OR wait for timeout

   Arguments:
    IN pszPromptStr     : String to be shown as prompt
    IN lTimeOutFactor   : Time out factor
    IN bCaseSensitive   : Stores the state, if choice is case-sensitive
    IN pszChoice        : Choice string
    IN pszDefaultChoice : Default choice character
    OUT pbErrorOnCarriageReturn : True, if there is an error on carriage return
   Return Value:
         DWORD
--*/
{
    //This function reads the keyboard and handles the I/O
    HANDLE  hInput          = 0;// Stores the input handle device
    HANDLE  hOutput         = 0;// Stores the output handle device
    DWORD   dwSignal        = 0;// Stores return value for WaitForSingleObject
    
    DWORD   dwBytesRead     = 0;// Stores number of byes read from console
    DWORD   dwBytesRead2     = 0;// Stores number of byes read from console
    DWORD   dwMode          = 0;// Stores mode for input device
    
    DWORD   lTimeBefore     = 0;
    DWORD   lTimeAfter      = 0;
    DWORD   lPosition       = 0;
    DWORD   dwRead          = 0L;
    BOOL    bSuccess        = FALSE; // Stores return value
    BOOL    bStatus         = TRUE;
    BOOL    bIndirectionInput   = FALSE;
    BOOL    bGetChoice = FALSE;
    WCHAR   szTempChar      = NULL_U_CHAR;     // Temperory variable
    WCHAR   szTempBuf[ MAX_RES_STRING ] = L"\0";  // Temp. string variable
    CHAR    chTmp = '\0';
    WCHAR   wchTmp = NULL_U_CHAR;
    CHAR    szAnsiBuf[ 10 ] = "\0";     // buffer of two characters is enough -- but still
    INPUT_RECORD InputBuffer[ MAX_NUM_RECS ] = {0};


    SecureZeroMemory(szTempBuf, MAX_RES_STRING * sizeof(WCHAR));

    // Get handle for Input device
    hInput =  GetStdHandle( STD_INPUT_HANDLE );

    if( INVALID_HANDLE_VALUE == hInput)
    {
        
        SaveLastError();
        return EXIT__FAILURE;
    }

    if( ( hInput != (HANDLE)0x0000000F )&&( hInput != (HANDLE)0x00000003 ) && ( hInput != INVALID_HANDLE_VALUE ) )
    {

        bIndirectionInput   = TRUE;
    }


    // Get handle for Output device
    hOutput =  GetStdHandle( STD_OUTPUT_HANDLE );

    if( INVALID_HANDLE_VALUE == hOutput )
    {
        
        SaveLastError();
        return EXIT__FAILURE;
    }

    // Get console mode, so we can change the input mode
    bSuccess = GetConsoleMode( hInput, &dwMode );
    if ( TRUE == bSuccess)
    {
        // turn off line input and echo
        dwMode &= ~( ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT );
        bSuccess = SetConsoleMode( hInput, dwMode );

        if (FALSE == bSuccess)
        {
           
            SaveLastError();
            return EXIT__FAILURE;

        }

        if ( FlushConsoleInputBuffer( hInput ) == FALSE )
        {
            
            SaveLastError();
            return EXIT__FAILURE;
        } 

       
    }

 

    // Show prompt message on screen.....

    
      ShowMessage( stdout, _X(pszPromptStr) );

    bStatus = SetConsoleCtrlHandler( &HandlerRoutine, TRUE );
    if ( FALSE == bStatus )
    {
        
        SaveLastError();
        return EXIT__FAILURE;
    }

    // init the ANSI buffer with 0's in it
    ZeroMemory( szAnsiBuf, SIZE_OF_ARRAY( szAnsiBuf ) * sizeof( CHAR ) );

    while( FALSE == bGetChoice)
    {
        //The WaitForSingleObject function returns when one of the
        // following occurs:
        // 1. The specified object is in the signaled state i.e. Key press
        //    from keyboard
        //  2.The time-out interval elapses.

        lTimeBefore = GetTickCount();

        dwSignal = WaitForSingleObject(  hInput,
                                        ( lTimeOutFactor ) ?
                                        ( lTimeOutFactor * MILI_SEC_TO_SEC_FACTOR)
                                        : INFINITE );
        lTimeAfter = GetTickCount();


        switch(dwSignal)
        {
            case WAIT_OBJECT_0:          // The input buffer has something
            {                            // get first character

                szTempBuf[ 1 ] = NULL_U_CHAR;
                // Get character from console
                if ( bIndirectionInput == FALSE )
                {

                    if( PeekConsoleInput(hInput, InputBuffer, MAX_NUM_RECS, &dwRead ) == FALSE )
                        {
                            
                            SaveLastError();
                            ReleaseGlobals();
                            return( EXIT__FAILURE );
                        }

                    //Ignore all the virtual keys like tab,break,scroll lock etc...

                        if(((InputBuffer[0].Event.KeyEvent.wVirtualKeyCode >= VK_LEFT)
                           && (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode <= VK_DOWN))
                           ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_HOME)
                           ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_END)
                           ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_INSERT)
                           || (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_DELETE)
                           ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_PRIOR)
                           ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_NEXT)
                           ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_TAB)
                           ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_SPACE))

                        {
                            
                            if( lTimeOutFactor )
                            {
                                lTimeOutFactor -= ( DWORD )(( lTimeAfter - lTimeBefore) /  MILI_SEC_TO_SEC_FACTOR);
                            }
                            if(0 == Beep( FREQUENCY_IN_HERTZ, DURETION_IN_MILI_SEC ))
                            {
                                if(TRUE == IsConsoleFile(stdout))
                                {
                                    
                                    ShowMessage(stdout, L"\a");
                                }
                            }
                            if ( FlushConsoleInputBuffer( hInput ) == FALSE )
                            {
                                
                                SaveLastError();
                                return EXIT__FAILURE;
                            }

                            break;
                        }
                        else if((InputBuffer[0].Event.KeyEvent.wVirtualKeyCode >= VK_F1)
                              && (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode <= VK_F16)
                              || (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE)
                              || ((InputBuffer[0].Event.KeyEvent.wVirtualKeyCode >= VK_LBUTTON)
                              && (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode <= VK_XBUTTON2))
                              ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_PAUSE)
                              ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_CAPITAL)
                              ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_NUMLOCK)
                              ||(InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_SCROLL)
                              ||  ((InputBuffer[0].Event.KeyEvent.wVirtualKeyCode >= VK_SELECT)
                               && (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode <= VK_SNAPSHOT))
                              ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_HELP)
                              ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_LWIN)
                               ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_RWIN)
                               ||  (InputBuffer[0].Event.KeyEvent.wVirtualKeyCode == VK_APPS)
                               )
                        {
                            if( lTimeOutFactor )
                            {
                                lTimeOutFactor -= ( DWORD )(( lTimeAfter - lTimeBefore) /  MILI_SEC_TO_SEC_FACTOR);
                            }
                            
                            if ( FlushConsoleInputBuffer( hInput ) == FALSE )
                            {
                                
                                SaveLastError();
                                return EXIT__FAILURE;
                            }

                            break;
                         }
                         
                    //Ignore changing the focus,doing alt+tab etc..

                    if(FOCUS_EVENT == InputBuffer[0].EventType
                       || (VK_MENU == InputBuffer[0].Event.KeyEvent.wVirtualKeyCode )
                       ||(VK_CONTROL == InputBuffer[0].Event.KeyEvent.wVirtualKeyCode)
                       ||(VK_SHIFT == InputBuffer[0].Event.KeyEvent.wVirtualKeyCode)
                       ||WINDOW_BUFFER_SIZE_EVENT == InputBuffer[0].EventType
                       ||MOUSE_EVENT == InputBuffer[0].EventType
                       ||MENU_EVENT == InputBuffer[0].EventType
                       ||(FALSE == InputBuffer[0].Event.KeyEvent.bKeyDown))
                    {
                        if( lTimeOutFactor )
                        {
                          lTimeOutFactor -= ( DWORD )(( lTimeAfter - lTimeBefore) /  MILI_SEC_TO_SEC_FACTOR);
                        }

                        if ( FlushConsoleInputBuffer( hInput ) == FALSE )
                        {

                            SaveLastError();
                            return EXIT__FAILURE;
                        }

                        break;

                    }

                    StringCopyW( szTempBuf, NULL_U_STRING, MAX_RES_STRING );
                  
                    bSuccess = ReadConsole(hInput,
                                        szTempBuf,
                                        MAX_RES_STRING,
                                        &dwBytesRead,
                                        NULL);



                    if ( FALSE == bSuccess)
                    {

                        SaveLastError();
                        return EXIT__FAILURE;
                    }
                }
                else
                {

                    //read the contents of file
                    if ( ReadFile(hInput, &chTmp, 1, &dwBytesRead, NULL) == FALSE )
                    {
                            if(ERROR_BROKEN_PIPE == GetLastError())
                            {
                                // End of the pipe is reached, so inform the caller
                                *pbErrorOnCarriageReturn = TRUE;
                                StringCopyW( szTempBuf, GetResString(IDS_FILE_EMPTY), MAX_RES_STRING );
                                SetReason( szTempBuf );                             
                            }
                            else
                            {
                                SaveLastError();
                            }
                            return EXIT__FAILURE;
                    }
                    else
                    {
                        szAnsiBuf[ 0 ] = chTmp;
                        dwBytesRead2 = SIZE_OF_ARRAY( szTempBuf );
                        GetAsUnicodeString2( szAnsiBuf, szTempBuf, &dwBytesRead2 );
                        wchTmp = szTempBuf[ 0 ];
                    }


                    if ( (dwBytesRead == 0)) //|| wchTmp == CARRIAGE_RETURN))
                    {
                        
                        if((StringLengthW((LPWSTR)pszDefaultChoice, 0)) != 0)
                        {

                            WaitForSingleObject(  hInput,( lTimeOutFactor * MILI_SEC_TO_SEC_FACTOR));

                            
                            ShowMessage( stdout, _X(pszDefaultChoice) );
                            
                            ShowMessage( stdout, _X(END_OF_LINE) );
                            return UniStrChr( pszChoice, pszDefaultChoice[0] );
                            

                        }
                        else
                        {
                            *pbErrorOnCarriageReturn = TRUE;
                            
                            StringCopyW( szTempBuf, GetResString(IDS_FILE_EMPTY), MAX_RES_STRING );
                            SetReason( szTempBuf );
                            return EXIT__FAILURE;
                        }

                    }

                    szTempBuf[0] = wchTmp;

                }


                //exit if non ascii character is given


                if( ((DWORD)szTempBuf[0]) <= 47 ||
                (((DWORD)szTempBuf[0])> 122 &&((DWORD)szTempBuf[0])< 127)||
                (((DWORD)szTempBuf[0])> 57 &&((DWORD)szTempBuf[0])< 65 ) ||
                (((DWORD)szTempBuf[0])> 90 &&((DWORD)szTempBuf[0])< 97 ) ||
                ((DWORD)szTempBuf[0])== 255)
                {
                    if(0 == Beep( FREQUENCY_IN_HERTZ, DURETION_IN_MILI_SEC ))
                    {
                        if(TRUE == IsConsoleFile(stdout))
                        {
                            
                           ShowMessage( stdout, L"\a" );
                        }
                    }

                    if ( FALSE == bIndirectionInput && FlushConsoleInputBuffer( hInput ) == FALSE )
                    {
                        
                        SaveLastError();
                        return EXIT__FAILURE;
                    }

                    if( lTimeOutFactor )
                    {
                        lTimeOutFactor -= ( DWORD )( lTimeAfter - lTimeBefore) /  MILI_SEC_TO_SEC_FACTOR;
                    }

                    break;
                }


                if ( FALSE == bCaseSensitive )
                {
                    if( ((DWORD)szTempBuf[0]) <= 127 )
                    {
                        if(0 == CharUpperBuff( szTempBuf, 1 ))
                        {
                           
                           StringCopyW( szTempBuf, GetResString(IDS_ERR_CHARUPPER), MAX_RES_STRING );
                           // Set the reason in memory
                           SetReason(szTempBuf);
                           return EXIT__FAILURE;
                        }

                    }
                }

                szTempChar = szTempBuf[ 0 ]; // Get first character

                lPosition = UniStrChr( pszChoice, szTempChar );
                
                szTempBuf[ 1 ] = NULL_U_CHAR; // Make second character as NULL

                if (0 != lPosition)
                {
                    StringCchPrintfW( szTempBuf,SIZE_OF_ARRAY(szTempBuf), L"%c\n", szTempChar );

                    // show the input character  on output console
                      
                      ShowMessage( stdout, _X(szTempBuf) );
                      return lPosition;
                }
                else // Character enterted not matches with Specified choice
                {
                    if(0 == Beep( FREQUENCY_IN_HERTZ, DURETION_IN_MILI_SEC ))
                    {
                        if(TRUE == IsConsoleFile(stdout))
                        {
                            
                            ShowMessage( stdout, L"\a" );
                        }
                    }

                    if ( FALSE == bIndirectionInput && FlushConsoleInputBuffer( hInput ) == FALSE )
                    {
                        
                        SaveLastError();
                        return EXIT__FAILURE;
                    }

                    if( lTimeOutFactor )
                    {
                        lTimeOutFactor -= ( DWORD )( lTimeAfter - lTimeBefore) /  MILI_SEC_TO_SEC_FACTOR;
                    }

                }
            }
                break;
            case WAIT_TIMEOUT:      // The timeout exhausted
            {

                // Show timeout message on screen
                
                ShowMessage( stdout, _X(pszDefaultChoice) );
                
                ShowMessage( stdout, _X(END_OF_LINE) );
                return UniStrChr( pszChoice, pszDefaultChoice[0] );
                

            }
                break;
            default:
                break;
        }
    }
     
  return EXIT__FAILURE;
}
// End of function GetChoice

BOOL
  CheckforDuplicates( IN LPWSTR lpszChoice
                    )
/*++
   Routine Description:
     This function checks for the duplicate choices

   Arguments:
    IN  lpszChoice      : The list of choices in which the duplication of choice is to be checked

   Return Value:
         TRUE on success and FALSE on failure

--*/
{
    WCHAR  wTemp = NULL_U_CHAR;

    while( lpszChoice[0] )
    {
        wTemp = lpszChoice[0];
        lpszChoice++;

        if( NULL != wcschr( lpszChoice, wTemp ) )
            return FALSE;
    }

    return TRUE;
}
//end of checkforDuplicate function


BOOL WINAPI HandlerRoutine(
  DWORD dwCtrlType
)
/*++
   Routine Description:
    This function handles the control key CTRL+C and CTRL+BREAK.

   Arguments:
        IN dwCtrlType : Error control type

   Return Value:
       TRUE on success and FALSE on failure
--*/
{
    // check for CTRL+C key
    if ( ( dwCtrlType == CTRL_C_EVENT ) ||( dwCtrlType == CTRL_BREAK_EVENT ) )
    {
        exit ( FALSE);
    }

    // for remaining keys return false
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\clip\clip.cpp ===
/*++


  Copyright (C) Microsoft Corporation
  All rights reserved.

  Module Name: clip.cpp

  Abstract
      Clip.exe copies input from console standard input (stdin)
      to the Windows clipboard in CF_TEXT format.

  Author:

      Author: Charles Stacy Harris III
        Date:   15 March 1995

  Revision History:

      Oct 1996 - (a-martih)
        Resolved bug 15274 - reporting errors did not work.

    Feb 1997 - (a-josehu)
        Resolved bug 69727  - app hangs when clip typed on cmd line
        Add -? /? Help message
        Remove MessageBox from ReportError

    July 2nd 2001 - Wipro Technologies
        Changed to have the localization.
        Handled for exceptions.

--*/

#include "pch.h"
#include "resource.h"


//
// function prototypes
//
BOOL DisplayHelp();
DWORD Clip_OnCreate();
BYTE* ReadFileIntoMemory( HANDLE hFile, DWORD *cb );
BOOL SaveDataToClipboard( IN LPVOID pvData, IN DWORD dwSize, UINT uiFormat );
DWORD ProcessOptions( DWORD argc, LPCWSTR argv[], PBOOL pbUsage );

//
// implementation
//

DWORD
__cdecl wmain( IN DWORD argc,
               IN LPCWSTR argv[] )
/*++

    Routine description : main function which calls necessary functions to copy the
                          contents of standart input file onto clipboard

    Arguments           : Standard arguments for wmain

    Return Value        : DWORD
           0            : if it is successful
           1            : if it is failure
--*/
{
    DWORD dwStatus = 0;
    BOOL bUsage = FALSE;

    // process the command line options
    dwStatus = ProcessOptions( argc, argv, &bUsage );

    // check the result
    if( EXIT_FAILURE == dwStatus )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // parser will not allow this situation -- but still better to check
    else if( TRUE == bUsage && argc > 2 )
    {
        SetLastError( (DWORD) MK_E_SYNTAX );
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
        ShowMessage( stderr, GetResString2( IDS_HELP_MESSAGE, 0 ) );
        dwStatus = EXIT_FAILURE;
    }

    // user requested to display the usage
    else if( TRUE == bUsage )
    {
        dwStatus = EXIT_SUCCESS;
        DisplayHelp();
    }

    // original functionality
    else if ( dwStatus == EXIT_SUCCESS )
    {
        dwStatus = Clip_OnCreate();
    }

    ReleaseGlobals();
    return dwStatus;
}

DWORD
Clip_OnCreate()
/*++

    Routine Description : copies the contents of clipboard
                            1. Open the clipboard
                            2. Empty the clipboard
                            3. Copy stdin into memory
                            4. Set the clipboard data


    Arguments:
         [ in  ]  argc      : argument count
         [ in  ]  argv      : a pointer to command line argument

      Return Type      : DWORD
                    returns EXIT_SUCCESS or EXIT_FAILURE according copying to clipboard
                    successful or not.
--*/
{
    DWORD dwSize = 0;
    LONG lLength = 0; 
    LPVOID pvData = NULL;
    LPWSTR pwszBuffer = NULL;
    HANDLE hStdInput = NULL;
    BOOL bResult = FALSE;
    UINT uiFormat = 0;

    hStdInput = GetStdHandle( STD_INPUT_HANDLE );
    if( INVALID_HANDLE_VALUE == hStdInput )
    {
      return EXIT_FAILURE;
    }

    if ( FILE_TYPE_CHAR == GetFileType( hStdInput ) )   // bug 69727
    {
        // error with GetStdHandle()
        ShowMessageEx( stdout, 2, TRUE, L"\n%s %s", 
            TAG_INFORMATION, GetResString2( IDS_HELP_MESSAGE, 0 ) );
        return EXIT_SUCCESS;
    }

    //place the contents in a global memory from stdin
    pvData = ReadFileIntoMemory( hStdInput, &dwSize );

    //check for allocation failed or not
    if( NULL == pvData )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
        return EXIT_FAILURE;
    }

    //convert contents into console code page if they are unicode
    uiFormat = CF_UNICODETEXT;
    if ( IsTextUnicode( pvData, dwSize, NULL ) == FALSE )
    {
        lLength = MultiByteToWideChar( 
            GetConsoleOutputCP(), 0, (LPCSTR) pvData, -1, NULL, 0);

        if( lLength > 0 )
        {
            pwszBuffer = (LPWSTR) AllocateMemory( (lLength + 5) * sizeof(WCHAR) );
            if( pwszBuffer == NULL )
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                FreeMemory( &pvData );
                return EXIT_FAILURE;
            }

            lLength = MultiByteToWideChar( 
                GetConsoleOutputCP(),  0, (LPCSTR) pvData, -1, pwszBuffer, lLength );
            if ( lLength <= 0 )
            {
                ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_SYSTEM );
                FreeMemory( &pvData );
                FreeMemory( (LPVOID*) &pwszBuffer );
                return EXIT_FAILURE;
            }

            dwSize = lLength * sizeof( WCHAR );
            FreeMemory( &pvData );
            pvData = pwszBuffer;
        }
        else
        {
            uiFormat = CF_TEXT;
        }
    }

    bResult = SaveDataToClipboard( pvData, dwSize, uiFormat );
    if ( bResult == FALSE )
    {
        ShowLastErrorEx( stderr, SLE_TYPE_ERROR | SLE_INTERNAL );
    }

    // release the memory
    FreeMemory( &pvData );

    return (bResult == TRUE ) ? EXIT_SUCCESS : EXIT_FAILURE;
}


BOOL 
SaveDataToClipboard( IN LPVOID pvData,
                     IN DWORD dwSize,
                     UINT uiFormat )
/*++
       Routine Description :
                   It places the data into clipboard.

       Arguments:
           [ in ]  pvData   : Pointer to memory block whose contents are to 
                              be placed into clipboard.
           [ in ]  dwSize   : Size of the memory block.
           [ in ]  uiFormat : format that needs to copied onto the clipboard
        
       Return Value:
            Returns TRUE if successfully saves,
                    FALSE otherwise.
--*/
{
    // local variables
    HANDLE hClipData = NULL;
    HGLOBAL hGlobalMemory = NULL;
    LPVOID pvGlobalMemoryBuffer = NULL;

    // check the input
    if ( pvData == NULL || dwSize == 0 )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        SaveLastError();
        return FALSE;
    }

    //open the clipboard and display error if it fails
    if( OpenClipboard( NULL ) == FALSE )
    {
        SaveLastError();
        return FALSE;
    }

    //take the ownership for this window on clipboard and display
    //error if it fails
    if( EmptyClipboard() == FALSE )
    {
        SaveLastError();
        CloseClipboard();
        return FALSE;
    }

    hGlobalMemory = GlobalAlloc( GMEM_SHARE | GMEM_MOVEABLE, dwSize + 10 );
    if( hGlobalMemory == NULL )
    {
        SaveLastError();
        CloseClipboard();
        return FALSE;
    }

    if ( (pvGlobalMemoryBuffer = GlobalLock( hGlobalMemory )) == NULL )
    {
        SaveLastError();
        GlobalFree( hGlobalMemory );
        CloseClipboard();
        return FALSE;
    }

    SecureZeroMemory( pvGlobalMemoryBuffer, dwSize + 10 );
    CopyMemory( pvGlobalMemoryBuffer, pvData, dwSize );

    if( FALSE == GlobalUnlock( hGlobalMemory ) )
    {
        if ( GetLastError() != NO_ERROR )
        {
            SaveLastError();
            GlobalFree( hGlobalMemory );
            CloseClipboard();
            return FALSE;
        }
    }

    hClipData = SetClipboardData( uiFormat, hGlobalMemory );
    if( NULL == hClipData )
    {
        SaveLastError();
        GlobalFree( hGlobalMemory );
        CloseClipboard();
        return FALSE;
    }

    //close the clipboard and display error if it fails
    CloseClipboard();

    GlobalFree( hGlobalMemory );
    return TRUE;
}


DWORD
ProcessOptions( IN  DWORD argc,
                IN  LPCWSTR argv[],
                OUT PBOOL pbUsage )
/*++

    Routine Description : Function used to process the main options

    Arguments:
         [ in  ]  argc         : Number of command line arguments
         [ in  ]  argv         : Array containing command line arguments
         [ out ]  pbUsage      : Pointer to boolean variable returns true if
                                 usage option specified in the command line.

      Return Type      : DWORD
        A Integer value indicating EXIT_SUCCESS on successful parsing of
                command line else EXIT_FAILURE

--*/
{
    DWORD dwOptionsCount = 0;
    TCMDPARSER2 cmdOptions[ 1 ];

    dwOptionsCount = SIZE_OF_ARRAY( cmdOptions );
    SecureZeroMemory( cmdOptions, sizeof( TCMDPARSER2 ) * dwOptionsCount );

    StringCopyA( cmdOptions[ 0 ].szSignature, "PARSER2", 8 );
    cmdOptions[ 0 ].dwCount = 1;
    cmdOptions[ 0 ].dwFlags = CP2_USAGE;
    cmdOptions[ 0 ].dwType = CP_TYPE_BOOLEAN;
    cmdOptions[ 0 ].pValue = pbUsage;
    cmdOptions[ 0 ].pwszOptions = L"?";

    if( DoParseParam2( argc, argv, -1,
                       dwOptionsCount, cmdOptions, 0 ) == FALSE )
    {
        return EXIT_FAILURE;
    }

    SetLastError( ERROR_SUCCESS );
    return EXIT_SUCCESS;
}


/*
  ReadFileIntoMemory
  ~~~~~~~~~~~~~~~~~~
  Read the contents of a file into GMEM_SHARE memory.
  This function could be modified to take allocation flags
  as a parameter.
*/
BYTE*
ReadFileIntoMemory( IN  HANDLE hFile,
                    OUT DWORD* pdwBytes )
/*++

    Routine Description : Read the contents of a file into GMEM_SHARE memory.
                          This function could be modified to take allocation
                          flags as a parameter.
    Arguments:
         [ in  ]  hFile : Handle to a file which is nothing but handle to
                          stdin file.
         [ out] cb   : returns the copied buffer length

      Return Type       : Handle to memory object.


--*/
{
    BYTE* pb = NULL;
    DWORD dwNew = 0;
    DWORD dwRead = 0;
    DWORD dwAlloc = 0;
    const size_t dwGrow = 1024;

    // check the inputs
    if ( hFile == NULL || pdwBytes == NULL )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return FALSE;
    }

    do
    {
        if ( dwAlloc - dwRead < dwGrow )
        {
            dwAlloc += dwGrow;
            if( NULL == pb  )
            {
                pb = (BYTE*) AllocateMemory( dwAlloc + 10 );
            }
            else if( FALSE == ReallocateMemory( (LPVOID*) &pb, dwAlloc + 10 ) )
            {
                FreeMemory( (LPVOID*) &pb );
                SetLastError( ERROR_OUTOFMEMORY );
                return NULL;
            }
        }

        if ( FALSE == ReadFile( hFile, pb + dwRead, (dwAlloc - dwRead), &dwNew, 0 ) )
        {
            break;
        }

        dwRead += dwNew;
    } while (dwNew != 0 );

    *pdwBytes = dwRead;
    SecureZeroMemory( pb + dwRead, (dwAlloc - dwRead) );
    SetLastError( ERROR_SUCCESS );
    return pb;
}


BOOL
DisplayHelp()
/*++

    Routine Description     : Displays the help usage to console or to file
                              if redirected.

    Arguments:


    Return Type             : EXIT_SUCCESS if successful,EXIT_FAILURE otherwise.

--*/

{
    //changing the help by taking the strings from resource file
    for( DWORD dw=IDS_MAIN_HELP_BEGIN;dw<=IDS_MAIN_HELP_END;dw++)
    {
        ShowMessage( stdout, GetResString2( dw, 0 ) );
    }

    SetLastError( ERROR_SUCCESS );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\bootini\resource.h ===
#define IDS_MAIN_USAGE                  1
#define IDS_QUERY_USAGE                 2
#define IDS_CHANGE_USAGE                3
#define IDS_COPY_USAGE                  4
#define IDS_DELETE_USAGE                5

#define IDS_DELETE_HELP_BEGIN           6
#define IDS_STRING7                     7
#define IDS_STRING8                     8
#define IDS_STRING9                     9
#define IDS_STRING10                    10
#define IDS_STRING11                    11
#define IDS_STRING12                    12
#define IDS_STRING13                    13
#define IDS_STRING14                    14
#define IDS_STRING15                    15
#define IDS_STRING16                    16
#define IDS_STRING17                    17
#define IDS_STRING18                    18
#define IDS_STRING19                    19
#define IDS_STRING20                    20
#define IDS_STRING21                    21
#define IDS_STRING22                    22
#define IDS_DELETE_HELP_END             23

#define IDS_QUERY_HELP_BEGIN            73
#define IDS_STRING74                    74
#define IDS_STRING75                    75
#define IDS_STRING76                    76
#define IDS_STRING77                    77
#define IDS_STRING78                    78
#define IDS_STRING79                    79
#define IDS_STRING80                    80
#define IDS_STRING81                    81
#define IDS_STRING82                    82
#define IDS_STRING83                    83
#define IDS_STRING84                    84
#define IDS_STRING85                    85
#define IDS_QUERY_HELP_END              86

#define IDS_COPY_HELP_BEGIN             87
#define IDS_STRING88                    88
#define IDS_STRING89                    89
#define IDS_STRING90                    90
#define IDS_STRING91                    91
#define IDS_STRING92                    92
#define IDS_STRING93                    93
#define IDS_STRING94                    94
#define IDS_STRING95                    95
#define IDS_STRING96                    96
#define IDS_STRING97                    97
#define IDS_STRING98                    98
#define IDS_STRING99                    99
#define IDS_STRING100                   100
#define IDS_STRING101                   101
#define IDS_STRING102                   102
#define IDS_STRING103                   103
#define IDS_STRING104                   104
#define IDS_COPY_HELP_END               105

#define IDS_ERROR_TAG                   124

#define IDS_INVALID_BOOTID          125
#define IDS_TIMEOUT_CHANGE          126
#define IDS_TIMEOUT_NO_CHANGE       127
#define IDS_REDIRECT_CHANGE         128
#define IDS_REDIRECT_NO_CHANGE      129
#define IDS_OS_CHANGE               130
#define IDS_OS_NO_CHANGE            131
#define IDS_NO_ADD_SWITCHES         132
#define IDS_NO_REMOVE_SWITCHES      133
#define IDS_COPY_OS                 134
#define IDS_ONLY_ONE_OS             135
#define IDS_DELETE_OS               136
#define IDS_CONNECT_SYSTEM          137
#define IDS_BOOTINI                 138
#define IDS_READWRITE_BOOTINI       139
#define IDS_READING_BOOTINI         140
#define IDS_RESET_ERROR             141
#define IDS_QUERY_HELP64_BEGIN      142
#define IDS_QUERY_HELP64A           143
#define IDS_QUERY_HELP64B           144
#define IDS_QUERY_HELP64C           145
#define IDS_QUERY_HELP64D           146
#define IDS_QUERY_HELP64E           147
#define IDS_QUERY_HELP64_END        148

#define IDS_ERROR_LOAD          1480
#define IDS_ERROR_NO_NVRAM      149
#define IDS_UNEXPECTED_ERROR        150
#define IDS_NO_PRIVILAGE        151
#define IDS_DELETE_SUCCESS      152
#define IDS_DELETE_FAILURE      153
#define IDS_ERROR_TIMEOUT       154
#define IDS_ERROR_REDIRECT      155
#define IDS_DEF_CHANGE          156
#define IDS_ADD_FAILURE         157
#define IDS_ADD_SUCCESS         158
#define IDS_COL_BOOTID              159
#define IDS_COL_FRIENDLYNAME        160
#define IDS_COL_COL_BOOTOPTION      161
#define IDS_COL_FRIENDLYNAME_SIZE   162
#define IDS_COL_BOOTID_SIZE         163
#define IDS_COL_BOOTOPTION_SIZE     164
#define IDS_FORMAT_TABLE            165
#define IDS_FORMAT_LIST             166
#define IDS_FORMAT_CSV              167
#define IDS_COL_ARCPATH         168
#define IDS_COL_ARCPATH_SIZE    169
#define IDS_OS_HEADER           170
#define IDS_DASHES_OS           171
#define IDS_BOOT_HEADER         172
#define IDS_DASHES_BOOTOS       173
#define IDS_DEFAULT_ARC         174
#define IDS_TIMEOUT             175
#define IDS_DEFAULT_OS          176
#define IDS_DEFAULT_ARC_SIZE    177
#define IDS_TIMEOUT_SIZE        178
#define IDS_RAW_USAGE           179

#define IDS_RAW_HELP_BEGIN      180
#define IDS_RAW_HELP1           181
#define IDS_RAW_HELP2           182
#define IDS_RAW_HELP3           183
#define IDS_RAW_HELP4           184
#define IDS_RAW_HELP5           185
#define IDS_RAW_HELP6           186
#define IDS_RAW_HELP7           187
#define IDS_RAW_HELP8           188
#define IDS_RAW_HELP9           189
#define IDS_RAW_HELP10          190
#define IDS_RAW_HELP11          191
#define IDS_RAW_HELP12          192
#define IDS_RAW_HELP13          193
#define IDS_RAW_HELP14          194
#define IDS_RAW_HELP15          195
#define IDS_RAW_HELP16          196
#define IDS_RAW_HELP17          197
#define IDS_RAW_HELP18          198
#define IDS_RAW_HELP19          199
#define IDS_RAW_HELP20          200
#define IDS_RAW_HELP21          201
#define IDS_RAW_HELP_END        202

#define IDS_SWITCH_ADD          203
#define IDS_SWITCH_SKIP         204
#define IDS_SWITCH_REMOVE       205
#define IDS_COPY_SUCCESS        206
#define IDS_DEL_SUCCESS         207

#define IDS_RAW_HELP_IA64_BEGIN 300
#define IDS_RAW_HELP1_IA64      301
#define IDS_RAW_HELP2_IA64      302
#define IDS_RAW_HELP3_IA64      303
#define IDS_RAW_HELP4_IA64      304
#define IDS_RAW_HELP5_IA64      305
#define IDS_RAW_HELP6_IA64      306
#define IDS_RAW_HELP7_IA64      307
#define IDS_RAW_HELP8_IA64      308
#define IDS_RAW_HELP9_IA64      309
#define IDS_RAW_HELP10_IA64     310
#define IDS_RAW_HELP11_IA64     311
#define IDS_RAW_HELP12_IA64     312
#define IDS_RAW_HELP13_IA64     313
#define IDS_RAW_HELP14_IA64     314
#define IDS_RAW_HELP15_IA64     315
#define IDS_RAW_HELP_IA64_END   316

#define IDS_DELETE_HELP_IA64_BEGIN  325
#define IDS_DELETE_HELP1_IA64       326
#define IDS_DELETE_HELP2_IA64       327
#define IDS_DELETE_HELP3_IA64       328
#define IDS_DELETE_HELP4_IA64       329
#define IDS_DELETE_HELP5_IA64       330
#define IDS_DELETE_HELP6_IA64       331
#define IDS_DELETE_HELP7_IA64       332
#define IDS_DELETE_HELP8_IA64       333
#define IDS_DELETE_HELP_IA64_END    334

#define IDS_COPY_ERROR          349

#define IDS_COPY_HELP_IA64_BEGIN    350
#define IDS_COPY_HELP1_IA64         351
#define IDS_COPY_HELP2_IA64         352
#define IDS_COPY_HELP3_IA64         353
#define IDS_COPY_HELP4_IA64         354
#define IDS_COPY_HELP5_IA64         355
#define IDS_COPY_HELP6_IA64         356
#define IDS_COPY_HELP7_IA64         357
#define IDS_COPY_HELP8_IA64         358
#define IDS_COPY_HELP9_IA64         359
#define IDS_COPY_HELP10_IA64        360
#define IDS_COPY_HELP_IA64_END      361

#define IDS_ERROR_MODIFY_TIMEOUT      370
#define IDS_SUCCESS_MODIFY_TIMEOUT    371
#define IDS_ERROR_MODIFY_NEXTBOOTID   372
#define IDS_SUCCESS_MODIFY_NEXTBOOTID 373
#define IDS_ERROR_MODIFY_HEADLESS     374
#define IDS_SUCCESS_MODIFY_HEADLESS   375
#define IDS_SUCCESS_DEFAULT_ENTRY     376
#define IDS_ERROR_DEFAULT_ENTRY       377


#define IDS_SUCCESS_OSOPTIONS 400
#define IDS_ERROR_OSOPTIONS   401
#define IDS_INFO_NOTWINDOWS   402



#define IDS_TIMOUTHELP_BEGIN        403
#define IDS_TIMOUTHELP1             404
#define IDS_TIMOUTHELP2             405
#define IDS_TIMOUTHELP3             406
#define IDS_TIMOUTHELP4             407
#define IDS_TIMOUTHELP5             408
#define IDS_TIMOUTHELP6             409
#define IDS_TIMOUTHELP7             410
#define IDS_TIMOUTHELP8             411
#define IDS_TIMOUTHELP9             412
#define IDS_TIMOUTHELP10            413
#define IDS_TIMOUTHELP11            414
#define IDS_TIMOUTHELP12            415
#define IDS_TIMOUTHELP13            416
#define IDS_TIMOUTHELP14            417
#define IDS_TIMOUTHELP_END          418

#define IDS_DEFAULT_BEGIN           420
#define IDS_DEFAULT1                421
#define IDS_DEFAULT2                422
#define IDS_DEFAULT3                423
#define IDS_DEFAULT4                424
#define IDS_DEFAULT5                425
#define IDS_DEFAULT6                426
#define IDS_DEFAULT7                427
#define IDS_DEFAULT8                428
#define IDS_DEFAULT9                429
#define IDS_DEFAULT10               430
#define IDS_DEFAULT11               431
#define IDS_DEFAULT12               432
#define IDS_DEFAULT13               433
#define IDS_DEFAULT14               434
#define IDS_DEFAULT_END             435

#define IDS_TIMEOUT_USAGE           437
#define IDS_DEFAULTOS_USAGE         438
#define IDS_ERR_CHANGE              439
#define IDS_INVALID_OSID            440
#define IDS_TIMEOUT_RANGE           441


#define IDS_TIMOUTHELP_IA64_BEGIN   450
#define IDS_TIMOUTHELP1_IA64        451
#define IDS_TIMOUTHELP2_IA64        452
#define IDS_TIMOUTHELP3_IA64        453
#define IDS_TIMOUTHELP4_IA64        454
#define IDS_TIMOUTHELP5_IA64        455
#define IDS_TIMOUTHELP6_IA64        456
#define IDS_TIMOUTHELP7_IA64        457
#define IDS_TIMOUTHELP8_IA64        458
#define IDS_TIMOUTHELP_IA64_END     459

#define IDS_MAIN_HELP_BEGIN         500
#define IDS_MAIN_HELP1              501
#define IDS_MAIN_HELP2              502
#define IDS_MAIN_HELP3              503
#define IDS_MAIN_HELP4              504
#define IDS_MAIN_HELP5              505
#define IDS_MAIN_HELP6              506
#define IDS_MAIN_HELP7              507
#define IDS_MAIN_HELP8              508
#define IDS_MAIN_HELP9              509
#define IDS_MAIN_HELP10             510
#define IDS_MAIN_HELP11             511
#define IDS_MAIN_HELP12             512
#define IDS_MAIN_HELP13             513
#define IDS_MAIN_HELP14             514
#define IDS_MAIN_HELP15             515
#define IDS_MAIN_HELP16             516
#define IDS_MAIN_HELP17             517
#define IDS_MAIN_HELP18             518
#define IDS_MAIN_HELP19             519
#define IDS_MAIN_HELP_END           520

#define IDS_MAIN_HELP_IA64_BEGIN    850
#define IDS_MAIN_HELP1_IA64         851
#define IDS_MAIN_HELP2_IA64         852
#define IDS_MAIN_HELP3_IA64         853
#define IDS_MAIN_HELP4_IA64         854
#define IDS_MAIN_HELP5_IA64         855
#define IDS_MAIN_HELP6_IA64         856
#define IDS_MAIN_HELP7_IA64         857
#define IDS_MAIN_HELP8_IA64         858
#define IDS_MAIN_HELP9_IA64         859
#define IDS_MAIN_HELP10_IA64        860
#define IDS_MAIN_HELP11_IA64        861
#define IDS_MAIN_HELP12_IA64        862
#define IDS_MAIN_HELP13_IA64        863
#define IDS_MAIN_HELP14_IA64        864
#define IDS_MAIN_HELP15_IA64        865
#define IDS_MAIN_HELP16_IA64        866
#define IDS_MAIN_HELP17_IA64        867
#define IDS_MAIN_HELP18_IA64        868
#define IDS_MAIN_HELP19_IA64        869
#define IDS_MAIN_HELP20_IA64        870
#define IDS_MAIN_HELP21_IA64        871
#define IDS_MAIN_HELP22_IA64        872
#define IDS_MAIN_HELP23_IA64        873
#define IDS_MAIN_HELP24_IA64        874
#define IDS_MAIN_HELP25_IA64        875
#define IDS_MAIN_HELP26_IA64        876
#define IDS_MAIN_HELP27_IA64        877
#define IDS_MAIN_HELP28_IA64        878
#define IDS_MAIN_HELP29_IA64        879
#define IDS_MAIN_HELP30_IA64        880
#define IDS_MAIN_HELP31_IA64        881
#define IDS_MAIN_HELP32_IA64        882
#define IDS_MAIN_HELP33_IA64        883
#define IDS_MAIN_HELP34_IA64        884
#define IDS_MAIN_HELP35_IA64        885
#define IDS_MAIN_HELP36_IA64        886
#define IDS_MAIN_HELP37_IA64        887
#define IDS_MAIN_HELP38_IA64        888
#define IDS_MAIN_HELP39_IA64        889
#define IDS_MAIN_HELP40_IA64        890
#define IDS_MAIN_HELP41_IA64        891
#define IDS_MAIN_HELP42_IA64        892
#define IDS_MAIN_HELP43_IA64        893
#define IDS_MAIN_HELP44_IA64        894
#define IDS_MAIN_HELP45_IA64        895
#define IDS_MAIN_HELP46_IA64        896
#define IDS_MAIN_HELP_IA64_END      897


#define IDS_DEFAULT_IA64_BEGIN   580
#define IDS_DEFAULT1_IA64        581
#define IDS_DEFAULT2_IA64        582
#define IDS_DEFAULT3_IA64        583
#define IDS_DEFAULT4_IA64        584
#define IDS_DEFAULT5_IA64        585
#define IDS_DEFAULT6_IA64        586
#define IDS_DEFAULT7_IA64        587
#define IDS_DEFAULT_IA64_END     588


#define IDS_MAIN_HELP_BEGIN1      590
#define IDS_MAIN_HELP1A           591
#define IDS_MAIN_HELP2A           592
#define IDS_MAIN_HELP3A           593
#define IDS_MAIN_HELP4A           594
#define IDS_MAIN_HELP5A           595
#define IDS_MAIN_HELP6A           596
#define IDS_MAIN_HELP7A           597
#define IDS_MAIN_HELP8A           598
#define IDS_MAIN_HELP9A           599
#define IDS_MAIN_HELP10A          600
#define IDS_MAIN_HELP11A          601
#define IDS_MAIN_HELP12A          602
#define IDS_MAIN_HELP13A          603
#define IDS_MAIN_HELP14A          604
#define IDS_MAIN_HELP15A          605
#define IDS_MAIN_HELP16A          606
#define IDS_MAIN_HELP17A          607
#define IDS_MAIN_HELP18A          608
#define IDS_MAIN_HELP19A          609
#define IDS_MAIN_HELP20A          610
#define IDS_MAIN_HELP21A          611
#define IDS_MAIN_HELP22A          612
#define IDS_MAIN_HELP23A          613
#define IDS_MAIN_HELP24A          614
#define IDS_MAIN_HELP25A          615
#define IDS_MAIN_HELP26A          616
#define IDS_MAIN_HELP27A          617
#define IDS_MAIN_HELP28A          618
#define IDS_MAIN_HELP29A          619
#define IDS_MAIN_HELP30A          620
#define IDS_MAIN_HELP31A          621
#define IDS_MAIN_HELP32A          622
#define IDS_MAIN_HELP33A          623
#define IDS_MAIN_HELP34A          624
#define IDS_MAIN_HELP35A          625
#define IDS_MAIN_HELP36A          626
#define IDS_MAIN_HELP37A          627
#define IDS_MAIN_HELP_END1        628


#define IDS_SWITCH_CHANGE            630
#define IDS_ERROR_NO_COM_PORT        631
#define IDS_ERROR_NO_BAUD_VAL        632
#define IDS_ERROR_NO_DBG_SWITCH      633
#define IDS_ERROR_DUPLICATE_COM_PORT 634
#define IDS_ERROR_DUPLICATE_BAUD_VAL 635
#define IDS_EMS_CHANGE_BOOTLOADER    636
#define IDS_EMS_CHANGE_ERROR_BLOADER 637
#define IDS_NO_REDIRECT_SWITCH       638
#define IDS_INVALID_SYNTAX_OFF       639
#define IDS_DUPL_REDIRECT_SWITCH     640
#define IDS_EMS_CHANGE_BAUDRATE      641
#define IDS_EMS_CHANGE_ERROR_BAUDRATE 642

#define IDS_EMS_BEGIN_X86    645
#define IDS_EMS1             646
#define IDS_EMS2             647
#define IDS_EMS3             648
#define IDS_EMS4             649
#define IDS_EMS5             650
#define IDS_EMS6             651
#define IDS_EMS7             652
#define IDS_EMS8             653
#define IDS_EMS9             654
#define IDS_EMS10            655
#define IDS_EMS11            656
#define IDS_EMS12            657
#define IDS_EMS13            658
#define IDS_EMS14            659
#define IDS_EMS15            660
#define IDS_EMS16            661
#define IDS_EMS17            662
#define IDS_EMS18            663
#define IDS_EMS19            664
#define IDS_EMS20            665
#define IDS_EMS21            666
#define IDS_EMS22            667
#define IDS_EMS23            668
#define IDS_EMS24            669
#define IDS_EMS25            670
#define IDS_EMS26            671
#define IDS_EMS27            672
#define IDS_EMS28            673
#define IDS_EMS29            674
#define IDS_EMS30            675
#define IDS_EMS31            676
#define IDS_EMS32            677
#define IDS_EMS33            678
#define IDS_EMS_END_X86      679

#define IDS_DEBUG_BEGIN_X86  680
#define IDS_DEBUG1           681
#define IDS_DEBUG2           682
#define IDS_DEBUG3           683
#define IDS_DEBUG4           684
#define IDS_DEBUG5           685
#define IDS_DEBUG6           686
#define IDS_DEBUG7           687
#define IDS_DEBUG8           688
#define IDS_DEBUG9           689
#define IDS_DEBUG10          690
#define IDS_DEBUG11          691
#define IDS_DEBUG12          692
#define IDS_DEBUG13          693
#define IDS_DEBUG14          694
#define IDS_DEBUG15          695
#define IDS_DEBUG16          696
#define IDS_DEBUG17          697
#define IDS_DEBUG18          698
#define IDS_DEBUG19          699
#define IDS_DEBUG20          700
#define IDS_DEBUG21          701
#define IDS_DEBUG22          702
#define IDS_DEBUG23          703
#define IDS_DEBUG24          704
#define IDS_DEBUG25          705
#define IDS_DEBUG26          706
#define IDS_DEBUG27          707
#define IDS_DEBUG_END_X86    708


#define IDS_WARN_REDIRECT     712
#define IDS_WARN_REDIRECTBAUD 713
#define IDS_DUPL_DEBUG        714


#define IDS_EMS_BEGIN_IA64   715
#define IDS_EMS1A            716
#define IDS_EMS2A            717
#define IDS_EMS3A            718
#define IDS_EMS4A            719
#define IDS_EMS5A            720
#define IDS_EMS6A            721
#define IDS_EMS7A            722
#define IDS_EMS8A            723
#define IDS_EMS9A            724
#define IDS_EMS10A           725
#define IDS_EMS11A           726
#define IDS_EMS_END_IA64     727


#define IDS_DEBUG_BEGIN_IA64  740
#define IDS_DEBUG1A          741
#define IDS_DEBUG2A          742
#define IDS_DEBUG3A          743
#define IDS_DEBUG4A          744
#define IDS_DEBUG5A          745
#define IDS_DEBUG6A          746
#define IDS_DEBUG7A          747
#define IDS_DEBUG8A          748
#define IDS_DEBUG9A          749
#define IDS_DEBUG10A         750
#define IDS_DEBUG11A         751
#define IDS_DEBUG12A         752
#define IDS_DEBUG13A         753
#define IDS_DEBUG14A         754
#define IDS_DEBUG15A         755
#define IDS_DEBUG16A         756
#define IDS_DEBUG17A         757
#define IDS_DEBUG18A         758
#define IDS_DEBUG19A         759
#define IDS_DEBUG_END_IA64   760

#define IDS_DEBUG_ABSENT      770
#define IDS_DEBUG_PORT_ABSENT 771
#define IDS_INVALID_SYNTAX    772
#define IDS_SUCCESS_CHANGE_OSOPTIONS 773
#define IDS_ERROR_CHANGE_OSOPTIONS 774
#define IDS_DUPL_REDIRECT       775

#define IDS_ERROR_BOOT_OPTIONS 776
#define IDS_REDIRECT_ABSENT 777
#define IDS_INVALID_EDIT_SYNTAX 778
#define IDS_USER_BUT_NOMACHINE 779
#define IDS_PASSWD_BUT_NOUSER  780
#define IDS_ERROR_NO_PORT      781
#define IDS_ERROR_NULL_SERVER  782
#define IDS_ERROR_NULL_USER    783
#define IDS_DUPLICATE_ENTRY    784
#define IDS_DUPLICATE_BAUD_RATE 785

#define WARN_LOCALCREDENTIALS   787
#define IDS_MAX_BOOTID          788
#define IDS_INVALID_OPERATION   789
#define IDS_DUPL_NOGUI_SWITCH  790
#define IDS_DUPL_SOS_SWITCH   791
#define IDS_DUPL_BASEVIDEO_SWITCH  792
#define IDS_DUPL_MAXMEM_SWITCH    793
#define IDS_ERROR_MAXMEM_VALUES   794
#define IDS_NO_MAXMEM_SWITCH    795
#define IDS_NO_SOS_SWITCH       796
#define IDS_NO_BV_SWITCH  797
#define IDS_NO_NOGUI_SWITCH   798
#define IDS_SWITCH_DELETE       799
#define IDS_NO_SWITCH_DELETE  800
#define IDS_NO_MAXMEM               801

#define IDS_ADDSW_BEGIN_X86     900
#define IDS_ADDSW1      901
#define IDS_ADDSW2      902
#define IDS_ADDSW3      903
#define IDS_ADDSW4      904
#define IDS_ADDSW5      905
#define IDS_ADDSW6      906
#define IDS_ADDSW7      907
#define IDS_ADDSW8      908
#define IDS_ADDSW9      909
#define IDS_ADDSW10     911
#define IDS_ADDSW11     912
#define IDS_ADDSW12     913
#define IDS_ADDSW13     914
#define IDS_ADDSW14     915
#define IDS_ADDSW15     916
#define IDS_ADDSW16     917
#define IDS_ADDSW17     918
#define IDS_ADDSW18     919
#define IDS_ADDSW19     920
#define IDS_ADDSW20     921
#define IDS_ADDSW21     922
#define IDS_ADDSW22     923
#define IDS_ADDSW23     924
#define IDS_ADDSW24     925
#define IDS_ADDSW25     926
#define IDS_ADDSW26     927
#define IDS_ADDSW27     928
#define IDS_ADDSW28     929
#define IDS_ADDSW29     930
#define IDS_ADDSW30     931
#define IDS_ADDSW_END_X86       932

#define IDS_ADDSW_BEGIN_IA64    940
#define IDS_ADDSW1A     941
#define IDS_ADDSW2A     942
#define IDS_ADDSW3A     943
#define IDS_ADDSW4A     944
#define IDS_ADDSW5A     945
#define IDS_ADDSW6A     946
#define IDS_ADDSW7A     947
#define IDS_ADDSW8A     948
#define IDS_ADDSW9A     949
#define IDS_ADDSW10A        951
#define IDS_ADDSW11A    952
#define IDS_ADDSW12A    953
#define IDS_ADDSW13A        954
#define IDS_ADDSW14A        955
#define IDS_ADDSW15A        956
#define IDS_ADDSW16A        957
#define IDS_ADDSW17A        958
#define IDS_ADDSW18A        959
#define IDS_ADDSW19A        960
#define IDS_ADDSW20A        961
#define IDS_ADDSW21A        962
#define IDS_ADDSW22A        963
#define IDS_ADDSW23A        964
#define IDS_ADDSW_END_IA64  965



#define IDS_RMSW_BEGIN_X86  970
#define IDS_RMSW1           971
#define IDS_RMSW2           972
#define IDS_RMSW3           973
#define IDS_RMSW4           974
#define IDS_RMSW5           975
#define IDS_RMSW6           976
#define IDS_RMSW7           977
#define IDS_RMSW8           978
#define IDS_RMSW9           979
#define IDS_RMSW10          980
#define IDS_RMSW11          981
#define IDS_RMSW12          982
#define IDS_RMSW13          983
#define IDS_RMSW14          984
#define IDS_RMSW15          985
#define IDS_RMSW16          986
#define IDS_RMSW17          987
#define IDS_RMSW18          988
#define IDS_RMSW19          989
#define IDS_RMSW20          990
#define IDS_RMSW21          991
#define IDS_RMSW22          992
#define IDS_RMSW23          993
#define IDS_RMSW24          994
#define IDS_RMSW25          995
#define IDS_RMSW26          996
#define IDS_RMSW27          997
#define IDS_RMSW28          998
#define IDS_RMSW29          999
#define IDS_RMSW_END_X86    1000

#define IDS_RMSW_BEGIN_IA64  1010
#define IDS_RMSW1A          1011
#define IDS_RMSW2A          1012
#define IDS_RMSW3A          1013
#define IDS_RMSW4A          1014
#define IDS_RMSW5A          1015
#define IDS_RMSW6A          1016
#define IDS_RMSW7A          1017
#define IDS_RMSW8A          1018
#define IDS_RMSW9A          1019
#define IDS_RMSW10A         1020
#define IDS_RMSW11A         1021
#define IDS_RMSW12A         1022
#define IDS_RMSW13A         1023
#define IDS_RMSW14A         1024
#define IDS_RMSW15A         1025
#define IDS_RMSW16A         1026
#define IDS_RMSW17A         1027
#define IDS_RMSW18A         1028
#define IDS_RMSW19A         1029
#define IDS_RMSW20A         1030
#define IDS_RMSW21A         1031
#define IDS_RMSW_END_IA64   1032


#define IDS_NO_COM_PORT  1050
#define IDS_OPTION_SNTAX_ERROR 1051
#define IDS_OPTION_SYNTAX   1052

#define IDS_INVALID_SYNTAX_ADDSW  1070
#define IDS_INVALID_SYNTAX_RMSW  1071
#define IDS_INVALID_SYNTAX_DEBUG  1072
#define IDS_INVALID_SYNTAX_EMS  1073

#define IDS_NO_1394_SWITCH   1080
#define IDS_DUPL_1394_SWITCH 1081
#define IDS_ERROR_LOAD_OSOPTIONS 1082
#define IDS_INVALID_SYNTAX_DBG1394 1083
#define IDS_INVALID_CH_RANGE    1084


#define  IDS_DBG1394_BEGIN_IA64   2000
#define  IDS_DBG1394_IA64A      2001
#define  IDS_DBG1394_IA64B      2002
#define  IDS_DBG1394_IA64C      2003
#define  IDS_DBG1394_IA64D      2004
#define  IDS_DBG1394_IA64E      2005
#define  IDS_DBG1394_IA64F      2006
#define  IDS_DBG1394_IA64G      2007
#define  IDS_DBG1394_IA64H      2008
#define  IDS_DBG1394_IA64I      2009
#define  IDS_DBG1394_IA64J      2010
#define  IDS_DBG1394_IA64K      2011
#define  IDS_DBG1394_IA64L      2012
#define  IDS_DBG1394_IA64M      2013
#define  IDS_DBG1394_IA64N      2014
#define  IDS_DBG1394_IA64O      2015
#define  IDS_DBG1394_IA64P      2016
#define  IDS_DBG1394_IA64Q      2017
#define  IDS_DBG1394_IA64R      2018
#define  IDS_DBG1394_END_IA64   2019



#define IDS_DBG1394_BEGIN_X86   2025
#define IDS_DBG1394A            2026
#define IDS_DBG1394B            2027
#define IDS_DBG1394C            2028
#define IDS_DBG1394D            2029
#define IDS_DBG1394E            2030
#define IDS_DBG1394F            2031
#define IDS_DBG1394G            2032
#define IDS_DBG1394H            2033
#define IDS_DBG1394I            2034
#define IDS_DBG1394J            2035
#define IDS_DBG1394K            2036
#define IDS_DBG1394L            2037
#define IDS_DBG1394M            2038
#define IDS_DBG1394N            2039
#define IDS_DBG1394O            2040
#define IDS_DBG1394P            2041
#define IDS_DBG1394Q            2042
#define IDS_DBG1394R            2043
#define IDS_DBG1394S            2044
#define  IDS_DBG1394T           2045
#define  IDS_DBG1394U           2046


#define IDS_DBG1394_END_X86    2055
#define IDS_ERROR_1394_REMOVE  2056
#define IDS_ERROR_VERSION_MISMATCH 2057
#define IDS_ERROR_SYSTEM_INFO  2058
#define IDS_ERROR_ID_MISSING   2060
#define IDS_EMS_HELP        2061
#define IDS_ERROR_EDIT_1394_SWITCH    2062
#define IDS_1394_HELP 2063
#define IDS_ERROR_BAUDRATE_HELP  2064
#define IDS_ERROR_DEFAULT_MISSING 2065
#define IDS_REMOTE_NOT_SUPPORTED  2066

#define WARNING_STRING  2067
#define IDS_CANNOT_ADD_BAUDRATE 2068
#define IDS_1394_ALREADY_PRESENT 2069

#define IDS_ERROR_QUERY_BOOTENTRY   2080
#define IDS_ERROR_ENUM_BOOTENTRY    2081
#define IDS_ERROR_QUERY_BOOTOPTIONS 2082
#define IDS_ERROR_MODIFY_BOOTENTRY  2083
#define IDS_ERROR_UNEXPECTED        2084
#define IDS_ERROR_SET_BOOTENTRY     2085

#define IDS_INSUFF_PRIV     2086
#define IDS_NO_EFINVRAM     2087
#define IDS_NO_DEBUGPORT    2088
#define IDS_NO_TOKENS       2089

#define IDS_MIRROR_BEGIN_IA64   3000
#define IDS_MIRROR_IA64A        3001
#define IDS_MIRROR_IA64B        3002
#define IDS_MIRROR_IA64C        3003
#define IDS_MIRROR_IA64D        3004
#define IDS_MIRROR_IA64E        3005
#define IDS_MIRROR_IA64F        3006
#define IDS_MIRROR_IA64G        3007
#define IDS_MIRROR_IA64H        3008
#define IDS_MIRROR_IA64I        3009
#define IDS_MIRROR_IA64J        3010
#define IDS_MIRROR_IA64K        3011
#define IDS_MIRROR_IA64L        3012
#define IDS_MIRROR_IA64M        3013
#define IDS_MIRROR_IA64N        3014
#define IDS_MIRROR_IA64O        3015
#define IDS_MIRROR_IA64P        3016
#define IDS_MIRROR_IA64Q        3017
#define IDS_MIRROR_IA64R        3018
#define IDS_MIRROR_IA64S        3019

#define IDS_MIRROR_END_IA64     3020
#define IDS_NO_FWDSLASH         3021
#define IDS_NO_FILE             3022

#define IDS_OUTPUT_IA64A        3040
#define IDS_OUTPUT_IA64B        3041
#define IDS_OUTPUT_IA64C        3042
#define IDS_OUTPUT_IA64D        3043
#define IDS_OUTPUT_IA64E        3044
#define IDS_OUTPUT_IA64F        3045
#define IDS_OUTPUT_IA64G        3046
#define IDS_OUTPUT_IA64H        3047
#define IDS_OUTPUT_IA64I        3048
#define IDS_OUTPUT_IA64J        3049
#define IDS_OUTPUT_IA64K        3050
#define IDS_OUTPUT_IA64L        3051
#define IDS_OUTPUT_IA64M        3052
#define IDS_OUTPUT_IA64N        3053
#define IDS_OUTPUT_IA64O        3054
#define IDS_MIRROR_SYNTAX       3055
#define IDS_LIST_SYNTAX         3056
#define IDS_UPDATE_SYNTAX       3057
#define IDS_OUTPUT_IA64P        3058

#define IDS_ERROR_DRIVE         3065
#define IDS_HEADER1             3066
#define IDS_HEADER2             3067

#define IDS_ERROR_DISPLAY       3068
#define IDS_ERROR_READ          3069
#define IDS_ERROR_GPT           3070
#define IDS_ERROR_GPT_HEADER    3071
#define IDS_ERROR_MEM_GPT       3072
#define IDS_ERROR_READ_GPT_ENTRIES 3073
#define IDS_ERROR_DUMP_GPT_ENTRIES 3074
#define IDS_INFO_DUMP_GPT_ENTRIES  3075
#define IDS_PARTITION1             3076
#define IDS_PARTITION2             3077

#define IDS_PARTITION3              3078
#define IDS_START_LBA              3079
#define IDS_PARTITION4              3080
#define IDS_PARTITION5              3081
#define IDS_ERROR_READ_GEOMETRY     3082
#define IDS_HEADER2_DASH            3083
#define IDS_HEADER_DASH1            3084

#define IDS_ERROR_STRING_LENGTH     3090
#define IDS_ERROR_STRING_LENGTH1    3091
#define IDS_ERROR_DEBUG_PORT        3092
#define IDS_ERROR_REDIRECT_PORT     3093
#define IDS_ERROR_FRIENDLY_NAME     3094

#define IDS_LIST_BEGIN_IA64         3200
#define IDS_LIST_IA64A              3201
#define IDS_LIST_IA64B              3202
#define IDS_LIST_IA64C              3203
#define IDS_LIST_IA64D              3204
#define IDS_LIST_IA64E              3205
#define IDS_LIST_IA64F              3206
#define IDS_LIST_IA64G              3207
#define IDS_LIST_IA64H              3208
#define IDS_LIST_IA64I              3209
#define IDS_LIST_END_IA64           3210

#define IDS_UPDATE_BEGIN_IA64       3300
#define IDS_UPDATE_IA64A            3301
#define IDS_UPDATE_IA64B            3302
#define IDS_UPDATE_IA64C            3303
#define IDS_UPDATE_IA64D            3304
#define IDS_UPDATE_IA64E            3305
#define IDS_UPDATE_IA64F            3306
#define IDS_UPDATE_IA64G            3307
#define IDS_UPDATE_IA64H            3308
#define IDS_UPDATE_IA64I            3309
#define IDS_UPDATE_IA64J            3310
#define IDS_UPDATE_IA64K            3311
#define IDS_UPDATE_IA64L            3312
#define IDS_UPDATE_END_IA64         3313

#define IDS_INVALID_GUID            3500
#define IDS_INVALID_DISK            3501
#define IDS_GUID_FOUND              3502
#define IDS_GUID_ABSENT             3503
#define IDS_TOKEN_ABSENT            3504
#define IDS_GUID_MODIFIED           3505
#define IDS_ERROR_ENUMERATE         3506
#define IDS_FIND_BOOT_ENTRY         3507
#define IDS_FIND_BOOT_ENTRY_NULL    3508
#define IDS_TRANSLATE_FAIL          3509
#define IDS_MODIFY_FAIL             3510
#define IDS_FIND_FAIL               3511
#define IDS_ALREADY_UPDATED         3512

#define IDS_LIST0                   3650
#define IDS_LIST1                   3651
#define IDS_LIST2                   3652
#define IDS_LIST3                   3653
#define IDS_LIST4                   3654
#define IDS_LIST5                   3655
#define IDS_LIST6                   3656
#define IDS_LIST7                   3657
#define IDS_LIST8                   3658
#define IDS_LIST9                   3659
#define IDS_LIST10                  3660

#define IDS_PARTITION_ERROR   3700

#define IDS_ERROR_PARTITION_STYLE   3701
#define IDS_ERROR_ADD               3702
#define IDS_MIRROR_ADDED            3703

#define IDS_SET_BOOTENTRY           3704
#define IDS_ERROR_MIRROR            3705
#define IDS_ERROR_BOOT              3706
#define IDS_MIRROR_NAME             3707
#define IDS_COPY_OF                 3708
#define IDS_ERROR_PARSE_NAME        3709

#define IDS_ERROR_BAUD_RATE         3710
#define IDS_ERROR_1394_COM_PORT     3711
#define IDS_STRING_TOO_LONG         3712

#define IDS_ERROR_REDIRECT_REMOVED  3713
#define IDS_ERROR_BAUDRATE_REMOVED  3714
#define IDS_REDIRECT_REMOVED        3715
#define IDS_BAUDRATE_REMOVED        3716
#define IDS_NOT_ADMINISTRATOR       3717
#define IDS_MISSING_CHANNEL         3718
#define IDS_NOT_ADMINISTRATOR_32    3719
#define IDS_FILE_TOO_LONG           3720
#define IDS_NOT_ADMINISTRATOR_64    3721
#define IDS_INVALID_LISTVALUE       3722
#define IDS_NULL_LIST               3723

#define IDS_CLONE_DEFAULT_FRIENDLY_NAME     4001
#define IDS_CLONE_ZERO_BOOT_ENTRIES         4002
#define IDS_CLONE_RANGE_ZERO_BOOT_ENTRIES   4003
#define IDS_CLONE_SUCCESS                   4004
#define IDS_CLONE_FAILED                    4005
#define IDS_CLONE_PARTIAL                   4006
#define IDS_CLONE_INVALID_BOOT_ENTRY        4007    
#define IDS_CLONE_ALREADY_EXISTS            4008
#define IDS_CLONE_BOOT_ENTRY_SUCCESS        4009
#define IDS_CLONE_INVALID_SOURCE_GUID       4010
#define IDS_CLONE_INVALID_TARGET_GUID       4011
#define IDS_CLONE_INVALID_DRIVER_ENTRY      4012    
#define IDS_CLONE_DRIVER_ALREADY_EXISTS     4013
#define IDS_CLONE_ZERO_DRIVER_ENTRIES       4014
#define IDS_CLONE_DRIVER_ENTRY_SUCCESS      4015

#define IDS_CLONE_DETAILED_TRACE            4041

#define IDS_ERROR_INVALID_USAGE_REQUEST             4051
#define IDS_ERROR_INVALID_DESCRIPTION_COMBINATION   4052
#define IDS_ERROR_INVALID_BOOT_ID_COMBINATION       4053
#define IDS_ERROR_INVALID_UPDDRV_COMBINATION        4054
#define IDS_ERROR_NO_SGUID_WITH_UPDDRV              4055


#define IDS_CLONE_BEGIN_IA64	4100
#define IDS_CLONE_IA64A			4101
#define IDS_CLONE_IA64B			4102
#define IDS_CLONE_IA64C			4103
#define IDS_CLONE_IA64D			4104
#define IDS_CLONE_IA64E			4105
#define IDS_CLONE_IA64F			4106
#define IDS_CLONE_IA64G			4107
#define IDS_CLONE_IA64H			4108
#define IDS_CLONE_IA64I			4109
#define IDS_CLONE_IA64J			4110
#define IDS_CLONE_IA64K			4111
#define IDS_CLONE_IA64L			4112
#define IDS_CLONE_IA64M			4113
#define IDS_CLONE_IA64N			4114
#define IDS_CLONE_IA64O			4115
#define IDS_CLONE_IA64P			4116
#define IDS_CLONE_IA64Q			4117
#define IDS_CLONE_IA64R			4118
#define IDS_CLONE_IA64S			4119
#define IDS_CLONE_IA64T			4120
#define IDS_CLONE_IA64U			4121
#define IDS_CLONE_IA64V			4122
#define IDS_CLONE_IA64W			4123
#define IDS_CLONE_IA64X			4124
#define IDS_CLONE_IA64Y			4125
#define IDS_CLONE_IA64Z			4126
#define IDS_CLONE_IA64A1		4127
#define IDS_CLONE_IA64A2		4128
#define IDS_CLONE_IA64A3		4129
#define IDS_CLONE_IA64A4		4130
#define IDS_CLONE_END_IA64		4131
#define IDS_PARTIAL_UPDATE		4132
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\eventconsumerprovider.cpp ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    EventConsumerProvider.CPP

Abstract:
    Contains DLL entry points.  code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks as well as routines that support
    self registration.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#include "pch.h"
#include "EventConsumerProvider.h"
#include "TriggerFactory.h"


// constants / defines / enumerations
#define THREAD_MODEL_BOTH           _T( "Both" )
#define THREAD_MODEL_APARTMENT      _T( "Apartment" )
#define RUNAS_INTERACTIVEUSER       _T( "Interactive User" )
#define FMT_CLS_ID                  _T( "CLSID\\%s" )
#define FMT_APP_ID                  _T( "APPID\\%s" )
#define PROVIDER_TITLE              _T( "Command line Trigger Consumer" )

#define KEY_INPROCSERVER32          _T( "InprocServer32" )
#define KEY_THREADINGMODEL          _T( "ThreadingModel" )
#define KEY_CLSID                   _T( "CLSID" )
#define KEY_APPID                   _T( "APPID" )
#define KEY_RUNAS                   _T( "RunAs" )
#define KAY_DLLSURROGATE            _T( "DllSurrogate" )



// global variables
DWORD               g_dwLocks = 0;              // holds the active locks count
DWORD               g_dwInstances = 0;          // holds the active instances of the component
HMODULE             g_hModule = NULL;           // holds the current module handle
CRITICAL_SECTION    g_critical_sec;             // critical section variable
DWORD               g_criticalsec_count = 0;    // to keep tab on when to release critical section

// {797EF3B3-127B-4283-8096-1E8084BF67A6}
DEFINE_GUID( CLSID_EventTriggersConsumerProvider,
0x797ef3b3, 0x127b, 0x4283, 0x80, 0x96, 0x1e, 0x80, 0x84, 0xbf, 0x67, 0xa6 );

// dll entry point

BOOL
WINAPI DllMain(
    IN HINSTANCE hModule,
    IN DWORD  ul_reason_for_call,
    IN LPVOID lpReserved
    )
/*++
Routine Description:
    Entry point for dll.

Arguments:
    [IN] hModule              : Instance of the caller.
    [IN] ul_reason_for_call   : Reason being called like process attach
                                or process detach.
    [IN] lpReserved           : reserved.

Return Value:
    TRUE if loading is successful.
    FALSE if loading fails.
--*/
{
    // check the reason for this function call
    // if this going to be attached to a process, save the module handle
    if ( DLL_PROCESS_ATTACH == ul_reason_for_call )
    {
        g_hModule = hModule;
        InitializeCriticalSection( &g_critical_sec );
        InterlockedIncrement( ( LPLONG ) &g_criticalsec_count );
    }
    else if ( DLL_PROCESS_DETACH == ul_reason_for_call )
    {
        if ( InterlockedDecrement( ( LPLONG ) &g_criticalsec_count ) == 0 )
        {
            DeleteCriticalSection( &g_critical_sec );
        }
    }
    // dll loaded successfully ... inform the same
    return TRUE;
}


// exported functions

STDAPI
DllCanUnloadNow(
    )
/*++
Routine Description:
    Called periodically by OLE in order to determine if the DLL can be freed.

Arguments:
    none.

Return Value:
    S_OK if there are no objects in use and the class factory  isn't locked.
    S_FALSE if server locks or components still exsists.
--*/
{
    // the dll cannot be unloaded if there are any server locks or active instances
    if ( 0 == g_dwLocks && 0 == g_dwInstances )
    {
        return S_OK;
    }
    // dll cannot be unloaded ... server locks (or) components still alive
    return S_FALSE;
}

STDAPI
DllGetClassObject(
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID* ppv
    )
/*++
Routine Description:
    Called by OLE when some client wants a class factory.
    Return one only if it is the sort of class this DLL supports.

Arguments:
    [IN] rclsid  : CLSID for the class object.
    [IN] riid    : Reference to the identifier of the interface
                   that communicates with the class object.
    [OUT] ppv    : Address of output variable that receives the
                   interface pointer requested in riid.

Return Value:
    returns status.
--*/
{
    // local variables
    HRESULT hr = S_OK;
    CTriggerFactory* pFactory = NULL;

    // check whether this module supports the requested class id
    if ( CLSID_EventTriggersConsumerProvider != rclsid )
    {
        return E_FAIL;          // not supported by this module
    }
    // create the factory
    pFactory = new CTriggerFactory();
    if ( NULL == pFactory )
    {
        return E_OUTOFMEMORY;           // insufficient memory
    }
    // get the requested interface
    hr = pFactory->QueryInterface( riid, ppv );
    if ( FAILED( hr ) )
    {
        delete pFactory;        // error getting interface ... deallocate memory
    }
    // return the result (appropriate result)
    return hr;
}

STDAPI
DllRegisterServer(
    )
/*++
Routine Description:
    Called during setup or by regsvr32.

Arguments:
    none.

Return Value:
    NOERROR.
--*/
{
    // local variables
    HKEY hkMain = NULL;
    HKEY hkDetails = NULL;
    TCHAR szID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szCLSID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szAppID[ LENGTH_UUID ] = NULL_STRING;
    TCHAR szModule[ MAX_PATH ] = NULL_STRING;
    TCHAR szTitle[ MAX_STRING_LENGTH ] = NULL_STRING;
    TCHAR szThreadingModel[ MAX_STRING_LENGTH ] = NULL_STRING;
    TCHAR szRunAs[ MAX_STRING_LENGTH ] = NULL_STRING;
    DWORD dwResult = 0;

    // kick off
    // Note:-
    //      Normally we want to use "Both" as the threading model since
    //      the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    //      the model is "Aparment"
    StringCopy( szTitle, PROVIDER_TITLE, SIZE_OF_ARRAY( szTitle ) );                   // provider title
    GetModuleFileName( g_hModule, szModule, MAX_PATH ); // get the current module name
    StringCopy( szThreadingModel, THREAD_MODEL_BOTH, SIZE_OF_ARRAY( szThreadingModel ) );
    StringCopy( szRunAs, RUNAS_INTERACTIVEUSER, SIZE_OF_ARRAY( szRunAs ) );


    // create the class id path
    // get the GUID in the string format
    StringFromGUID2( CLSID_EventTriggersConsumerProvider, szID, LENGTH_UUID );

    // finally form the class id path
    StringCchPrintf( szCLSID, SIZE_OF_ARRAY( szCLSID ), FMT_CLS_ID, szID );
    StringCchPrintf( szAppID, SIZE_OF_ARRAY( szAppID ), FMT_APP_ID, szID );

    // now, create the entries in registry under CLSID branch
    // create / save / put class id information
    dwResult = RegCreateKey( HKEY_CLASSES_ROOT, szCLSID, &hkMain );
    if( ERROR_SUCCESS != dwResult )
    {
        return dwResult;            // failed in opening the key.
    }
    dwResult = RegSetValueEx( hkMain, NULL, 0, REG_SZ,
        ( LPBYTE ) szTitle, ( StringLength( szTitle, 0 ) + 1 ) * sizeof( TCHAR ) );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        return dwResult;            // failed to set key value.
    }

    // now create the server information
    dwResult = RegCreateKey( hkMain, KEY_INPROCSERVER32, &hkDetails );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        return dwResult;            // failed in opening the key.
    }

    dwResult = RegSetValueEx( hkDetails, NULL, 0, REG_SZ,
        ( LPBYTE ) szModule, ( StringLength( szModule, 0 ) + 1 ) * sizeof( TCHAR ) );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        RegCloseKey( hkDetails );
        return dwResult;            // failed to set key value.
    }

    // set the threading model we support
    dwResult = RegSetValueEx( hkDetails, KEY_THREADINGMODEL, 0, REG_SZ,
        ( LPBYTE ) szThreadingModel, ( StringLength( szThreadingModel, 0 ) + 1 ) * sizeof( TCHAR ) );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        RegCloseKey( hkDetails );
        return dwResult;            // failed to set key value.
    }

    // close the open register keys
    RegCloseKey( hkMain );
    RegCloseKey( hkDetails );

    //
    // now, create the entries in registry under AppID branch
    // create / save / put class id information
    dwResult = RegCreateKey( HKEY_CLASSES_ROOT, szAppID, &hkMain );
    if( ERROR_SUCCESS != dwResult )
    {
        return dwResult;
    }
    dwResult = RegSetValueEx( hkMain, NULL, 0, REG_SZ,
        ( LPBYTE ) szTitle, ( StringLength( szTitle, 0 ) + 1 ) * sizeof( TCHAR ) );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        return dwResult;
    }

    // now set run as information
    dwResult = RegSetValueEx( hkMain, KEY_RUNAS, 0, REG_SZ,
        ( LPBYTE ) szRunAs, ( StringLength( szRunAs, 0 ) + 1 ) * sizeof( TCHAR ) );
    if( ERROR_SUCCESS != dwResult )
    {
        RegCloseKey( hkMain );
        return dwResult;
    }
    // close the open register keys
    RegCloseKey( hkMain );

    // registration is successfull ... inform the same
    return NOERROR;
}

STDAPI
DllUnregisterServer(
    )
/*++
Routine Description:
    Called when it is time to remove the registry entries.

Arguments:
    none.

Return Value:
    NOERROR if unregistration successful.
    Otherwise error.
--*/
{
    // local variables
    HKEY hKey;
    DWORD dwResult = 0;
    TCHAR szID[ LENGTH_UUID ];
    TCHAR szCLSID[ LENGTH_UUID ];
    TCHAR szAppID[ LENGTH_UUID ] = NULL_STRING;

    // create the class id path
    StringFromGUID2( CLSID_EventTriggersConsumerProvider, szID, LENGTH_UUID );

    // finally form the class id path
    StringCchPrintf( szCLSID, SIZE_OF_ARRAY( szCLSID ), FMT_CLS_ID, szID );
    StringCchPrintf( szAppID, SIZE_OF_ARRAY( szAppID ), FMT_APP_ID, szID );

    // open the clsid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, szCLSID, &hKey );
    if ( NO_ERROR != dwResult )
    {
        return dwResult;            // failed in opening the key ... inform the same
    }
    // clsid opened ... first delete the InProcServer32
    RegDeleteKey( hKey, KEY_INPROCSERVER32 );

	// release the key
    RegCloseKey( hKey );

	//reset to NULL
	hKey = NULL ;

    // now delete the clsid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, KEY_CLSID, &hKey );
    if ( NO_ERROR != dwResult )
    {
        return dwResult;            // failed in opening the key ... inform the same
    }

    // delete the clsid also from the registry
    RegDeleteKey( hKey, szID );

	// release the key
    RegCloseKey( hKey );

	//reset to NULL	
	hKey = NULL ;

    // now delete the appid
    dwResult = RegOpenKey( HKEY_CLASSES_ROOT, KEY_APPID, &hKey );
    if ( NO_ERROR != dwResult )
    {
        return dwResult;            // failed in opening the key ... inform the same
    }

    // delete the cls id also from the registry
    RegDeleteKey( hKey, szID );

	// release the key
    RegCloseKey( hKey );

	//reset to NULL
    hKey = NULL ;

    // unregistration is successfull ... inform the same
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\pch.h ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    PCH.H

Abstract:
    Include file for standard system include files,
    or project specific include files that are used frequently, but
    are changed infrequently.
Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __PCH_H
#define __PCH_H

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define CMDLINE_VERSION     200

#include <stdio.h>
#include <stdlib.h>

#include <windows.h>

#include <objbase.h>
#include <initguid.h>
#include <comdef.h>
#include <wbemidl.h>

#include <tchar.h>
#include <wchar.h>
#include <crtdbg.h>
#include <chstring.h>
#include <shlwapi.h>
#include <mstask.h>
#include <strsafe.h>

#include "cmdline.h"

#endif // __PCH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\eventconsumerprovider.h ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    EVENTCONSUMERPROVIDER.H

Abstract:
    Contains global variables to be used in other files.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __EVENT_CONSUMER_PROVIDER_H
#define __EVENT_CONSUMER_PROVIDER_H


// constants / defines / enumerations
#define LENGTH_UUID             128
#define NULL_CHAR               _T( '\0' )
#define NULL_STRING             _T( "\0" )


#define PROVIDER_CLASSNAME                      L"CmdTriggerConsumer"
#define METHOD_RETURNVALUE                      _T( "ReturnValue" )
#define TEC_PROPERTY_TRIGGERID                  _T( "TriggerID" )
#define TEC_PROPERTY_TRIGGERNAME                _T( "TriggerName" )
#define TEC_PROPERTY_DESCRIPTION                _T( "Description" )
#define TEC_PROPERTY_COMMAND                    _T( "Command" )

#define TEC_ADDTRIGGER                          L"AddTrigger"
#define TEC_ADDTRIGGER_TRIGGERNAME              _T( "strTriggerName" )
#define TEC_ADDTRIGGER_DESCRIPTION              _T( "strDescription" )
#define TEC_ADDTRIGGER_COMMAND                  _T( "strCommand" )
#define TEC_ADDTRIGGER_QUERY                    _T( "strQuery" )


// extern(ing) variables ... global usage
extern DWORD                g_dwLocks;          // holds the active locks count
extern DWORD                g_dwInstances;      // holds the active instances of the component
extern CRITICAL_SECTION     g_critical_sec;     // critical section variable
extern HMODULE              g_hModule;  // holds the current module handle

#endif  // __EVENT_CONSUMER_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\resource.h ===
#define IDS_TRIGGERID               1
#define IDS_TRIGGERNAME             2
#define IDS_CREATED                 3
#define IDS_CREATE_FAILED           4
#define IDS_DELETED                 5
#define IDS_DELETE_FAILED           6
#define IDS_TRIGGER_FAILED          7
#define IDS_TRIGGERED               8
#define IDS_TRIGGER_NOT_FOUND       9
#define IDS_ERROR_CODE              10
#define IDS_REASON                  11
#define IDS_ALREADY_TRIGGERED       12
#define IDS_INFO_INVALID_USER       13
#define IDS_INFO_SERVICE_STOPPED    14
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\general.cpp ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    GENERAL.CPP

Abstract:
    Source file that that contains general functions implementation.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#include "pch.h"
#include "EventConsumerProvider.h"
#include "General.h"
#include "resource.h"
extern HMODULE g_hModule;

HRESULT
PropertyGet(
    IN IWbemClassObject* pWmiObject,
    IN LPCTSTR szProperty,
    IN DWORD dwType,
    OUT LPVOID pValue,
    IN DWORD dwSize
    )
/*++
Routine Description:
    Get the value of a property for the given instance .

Arguments:
    [IN] pWmiObject - A pointer to wmi class.
    [IN] szProperty - property name whose value to be returned.
    [IN] dwType     - Data Type of the property.
    [OUT] pValue    - Variable to hold the data.
    [IN] dwSize     - size of the variable.

Return Value:
    HRESULT value.
--*/
{
    // local variables
    HRESULT hr = S_OK;
    VARIANT varValue;
    LPWSTR pwszValue = NULL;
    WCHAR wszProperty[ MAX_STRING_LENGTH ] = L"\0";

    // value should not be NULL
    if ( NULL == pValue || NULL == szProperty || NULL == pWmiObject )
    {
        return E_FAIL;
    }
    // initialize the values with zeros ... to be on safe side
    SecureZeroMemory( pValue, dwSize );
    SecureZeroMemory( wszProperty, MAX_STRING_LENGTH );

    // get the property name in UNICODE version
    StringCopy( wszProperty, szProperty, MAX_STRING_LENGTH );

    // initialize the variant and then get the value of the specified property
    VariantInit( &varValue );
    hr = pWmiObject->Get( wszProperty, 0, &varValue, NULL, NULL );
    if ( FAILED( hr ) )
    {
        // clear the variant variable
        VariantClear( &varValue );

        // failed to get the value for the property
        return hr;
    }

    // get and put the value
    switch( varValue.vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        break;

    case VT_I2:
        *( ( short* ) pValue ) = V_I2( &varValue );
        break;

    case VT_I4:
        *( ( long* ) pValue ) = V_I4( &varValue );
        break;

    case VT_R4:
        *( ( float* ) pValue ) = V_R4( &varValue );
        break;

    case VT_R8:
        *( ( double* ) pValue ) = V_R8( &varValue );
        break;


    case VT_UI1:
        *( ( UINT* ) pValue ) = V_UI1( &varValue );
        break;

    case VT_BSTR:
        {
            // get the unicode value
            pwszValue = V_BSTR( &varValue );

            // get the comptable string
            StringCopy( ( LPTSTR ) pValue, pwszValue, dwSize );

            break;
        }
    default:
        break;
    }

    // clear the variant variable
    VariantClear( &varValue );

    // inform success
    return S_OK;
}

VOID
ErrorLog(
    IN LPCTSTR lpErrString,
    IN LPWSTR lpTrigName,
    IN DWORD dwID
    )
/*++
Routine Description:
    To write the log into log file.

Arguments:
    [IN] lpErrString  - text that hold the status of creating a trigger.
    [IN] lpTrigName   - trigger name.
    [IN] dwID         - TriggerID.
Return Value:
    none.
--*/
{
    LPTSTR         lpTemp = NULL;
    LPSTR          lpFilePath = NULL;
    FILE           *fLogFile = NULL;
    DWORD          dwResult = 0;
    LPTSTR         lpResStr = NULL;


    if( ( NULL == lpErrString ) || ( NULL == lpTrigName ) )
    {
        return;
    }

    lpResStr = ( LPTSTR ) AllocateMemory( ( MAX_RES_STRING1 + 1 ) * sizeof( TCHAR ) );
    lpTemp =  ( LPTSTR )AllocateMemory( ( MAX_RES_STRING1 ) * sizeof( TCHAR ) );
    if( ( NULL == lpTemp ) || ( NULL == lpResStr ) )
    {
        FREESTRING( lpTemp );
        FREESTRING( lpResStr );
        return;
    }

    dwResult =  GetWindowsDirectory( lpTemp, MAX_RES_STRING1 );
    if( 0 == dwResult )
    {
        FREESTRING( lpTemp );
        FREESTRING( lpResStr );
        return;
    }

    StringConcatEx( lpTemp, LOG_FILE_PATH );
    CreateDirectory( lpTemp, NULL );
    StringConcatEx( lpTemp, LOG_FILE );

    lpFilePath =  ( LPSTR )AllocateMemory( ( MAX_RES_STRING1 ) * sizeof( TCHAR ) );
    if( NULL == lpFilePath )
    {
        FREESTRING( lpTemp );
        FREESTRING( lpResStr );
        return;
    }
    dwResult = MAX_RES_STRING1;
    GetAsMultiByteString2( lpTemp, lpFilePath, &dwResult );

    SecureZeroMemory( lpTemp, MAX_RES_STRING * sizeof( TCHAR ) );

    if ( (fLogFile  = fopen( lpFilePath, "a" )) != NULL )
    {
        LPSTR  lpReason =  NULL;
        lpReason =  ( LPSTR )AllocateMemory( ( MAX_RES_STRING1 ) * sizeof( TCHAR ) );
        if( NULL == lpReason )
        {
            FREESTRING( lpTemp );
            FREESTRING( lpResStr );
            FREESTRING( lpFilePath );
            fclose( fLogFile );
            return;
        }

        BOOL bFlag = GetFormattedTime( lpTemp );
        if( FALSE == bFlag )
        {
            FREESTRING( lpResStr );
            FREESTRING( lpFilePath );
            return;
        }

        ShowMessage( fLogFile, NEW_LINE );
        ShowMessage( fLogFile, lpTemp );

        SecureZeroMemory( lpTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        LoadStringW( g_hModule, IDS_TRIGGERNAME, lpResStr, MAX_RES_STRING1 );
        StringCopyEx( lpTemp, lpResStr );
        StringConcatEx( lpTemp, lpTrigName );
        ShowMessage( fLogFile, NEW_LINE );
        ShowMessage( fLogFile, lpTemp );

        SecureZeroMemory( lpTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        LoadStringW( g_hModule, IDS_TRIGGERID, lpResStr, MAX_RES_STRING1 );
        StringCchPrintf( lpTemp, MAX_RES_STRING1, lpResStr, dwID );
        ShowMessage( fLogFile, NEW_LINE );
        ShowMessage( fLogFile, lpTemp );

        SecureZeroMemory( lpTemp, MAX_RES_STRING1 * sizeof( TCHAR ) );
        StringConcatEx( lpTemp, lpErrString );
        ShowMessage( fLogFile, NEW_LINE );
        ShowMessage( fLogFile, lpTemp );
        FREESTRING( lpReason );
        fclose( fLogFile );
    }

    FREESTRING( lpTemp );
    FREESTRING( lpResStr );
    FREESTRING( lpFilePath );
}

BOOL
GetFormattedTime(
    OUT LPTSTR lpDate
    )
/*++
Routine Description:
    Get the system date and time in specified format .

Arguments:
    [OUT] lpDate  - string that holds the current date.

Return Value:
    None.
--*/
{
    TCHAR szTime[MAX_STRING_LENGTH];
    INT   cch = 0;

    if( NULL == lpDate )
    {
        return FALSE;
    }

    cch =  GetDateFormat( LOCALE_USER_DEFAULT, 0, NULL, DATE_FORMAT, szTime, SIZE_OF_ARRAY( szTime ) );

    if( 0 == cch )
    {
        return FALSE;
    }
    // cch includes null terminator, change it to a space to separate from time.
    szTime[ cch - 1 ] = ' ';

    // Get time and format to characters

    cch = GetTimeFormat( LOCALE_USER_DEFAULT, NULL, NULL, TIME_FORMAT, szTime + cch, SIZE_OF_ARRAY( szTime ) - cch );
    if( 0 == cch )
    {
        return FALSE;
    }
    StringCopyEx( lpDate, ( LPTSTR )szTime );
    return TRUE;
}

BOOL
ProcessFilePath(
    IN LPTSTR szInput,
    OUT LPTSTR szFirstString,
    OUT LPTSTR szSecondString
    )
/*++
Routine Description:
    This routine splits the input parameters into 2 substrings and returns it.

Arguments:
    [IN] szInput         : Input string.
    [OUT] szFirstString  : First Output string containing the path of the
                           file.
    [OUT] szSecondString : The second  output containing the paramters.

Return Value :
    A BOOL value indicating TRUE on success else FALSE
    on failure
--*/
{

    WCHAR *pszSep = NULL ;

    WCHAR szTmpString[MAX_RES_STRING] = L"\0";
    WCHAR szTmpInStr[MAX_RES_STRING] = L"\0";
    WCHAR szTmpOutStr[MAX_RES_STRING] = L"\0";
    WCHAR szTmpString1[MAX_RES_STRING] = L"\0";
    DWORD dwCnt = 0 ;
    DWORD dwLen = 0 ;

#ifdef _WIN64
    INT64 dwPos ;
#else
    DWORD dwPos ;
#endif

    //checking if the input parameters are NULL and if so
    // return FAILURE. This condition will not come
    // but checking for safety sake.

    if( (szInput == NULL) || (StringLength(szInput, 0)==0))
    {
        return FALSE ;
    }

    StringCopy(szTmpString, szInput, SIZE_OF_ARRAY(szTmpString));
    StringCopy(szTmpString1, szInput, SIZE_OF_ARRAY(szTmpString1));
    StringCopy(szTmpInStr, szInput, SIZE_OF_ARRAY(szTmpInStr));

    // check for first double quote (")
    if ( szTmpInStr[0] == _T('\"') )
    {
        // trim the first double quote
        StrTrim( szTmpInStr, _T("\""));

        // check for end double quote
        pszSep  = (LPWSTR)FindChar(szTmpInStr,_T('\"'), 0) ;

        // get the position
        dwPos = pszSep - szTmpInStr + 1;
    }
    else
    {
        // check for the space
        pszSep  = (LPWSTR)FindChar(szTmpInStr, _T(' '), 0) ;

        // get the position
        dwPos = pszSep - szTmpInStr;

    }

    if ( pszSep != NULL )
    {
        szTmpInStr[dwPos] =  _T('\0');
    }
    else
    {
        StringCopy(szFirstString, szTmpString, MAX_RES_STRING);
        StringCopy(szSecondString, L"\0", MAX_RES_STRING);
        return TRUE;
    }

    // intialize the variable
    dwCnt = 0 ;

    // get the length of the string
    dwLen = StringLength ( szTmpString, 0 );

    // check for end of string
    while ( ( dwPos <= dwLen )  && szTmpString[dwPos++] != _T('\0') )
    {
        szTmpOutStr[dwCnt++] = szTmpString[dwPos];
    }

    // trim the executable and arguments
    StrTrim( szTmpInStr, _T("\""));
    StrTrim( szTmpInStr, _T(" "));

    StringCopy(szFirstString, szTmpInStr, MAX_RES_STRING);
    StringCopy(szSecondString, szTmpOutStr, MAX_RES_STRING);

    // return success
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\general.h ===
/*++
    Copyright (c) Microsoft Corporation

Module Name:
    GENERAL.H

Abstract:
    Contains General functions prototypes.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __GENERAL_H
#define __GENERAL_H

// constants
#define LOG_FILE_PATH               _T( "\\system32\\wbem\\logs\\" )
#define NEW_LINE                    _T( "\n" )
#define LOG_FILE                    _T( "CmdTriggerConsumer.log" )
#define JOB                         _T( ".job" )
#define CHAR_SPACE                  _T( ' ' )
#define STRING_SPACE                _T( " " )
#define SINGLE_QUOTE_CHAR           _T( '\"' )
#define SINGLE_QUOTE_STRING         _T( "\"" )
#define NULL_CHAR                   _T( '\0' )
#define DATE_FORMAT                 L"ddd',' MMM dd yyyy"
#define TIME_FORMAT                 L"hh':'mm':'ss tt"

#define TRIM_SPACES                 TEXT(" \0")
#define MAX_RES_STRING1             500

// macros
#define SAFERELEASE( pIObj ) \
    if ( pIObj != NULL ) \
    { \
        pIObj->Release();   \
        pIObj = NULL;   \
    }

#define FREESTRING( pStr ) \
    if ( pStr ) \
    { \
        FreeMemory( ( LPVOID * ) &( pStr ) ); \
    }

#define ONFAILTHROWERROR(hResult) \
    if (FAILED(hResult)) \
    { \
        _com_issue_error(hResult); \
    }

#define SAFEBSTRFREE(bstrVal) \
    if (bstrVal != NULL) \
    { \
        SysFreeString(bstrVal); \
    }

// public function prototypes
LPCTSTR
ErrorString(
    HRESULT hRes
    );

HRESULT
PropertyGet(
    IWbemClassObject* pWmiObject,
    LPCTSTR szProperty,
    DWORD dwType,
    LPVOID pValue,
    DWORD dwSize
    );

HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCTSTR szProperty,
    LPCTSTR szValue
    );

HRESULT
PropertyPut(
    IWbemClassObject* pWmiObject,
    LPCTSTR szProperty,
    DWORD dwValue
    );

VOID
ErrorLog(
    LPCTSTR lpErrString,
    LPWSTR lpTrigName,
    DWORD dwID
    );

BOOL
GetFormattedTime( 
    LPTSTR lpDate
    );

ITaskScheduler*
GetTaskScheduler(
    );

BOOL
ProcessFilePath(
    LPTSTR szInput,
    LPTSTR szFirstString,
    LPTSTR szSecondString );

#endif // __GENERAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerconsumer.h ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERCONSUMER.H

Abstract:
    Contains CTriggerConsumer definition.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __TRIGGER_CONSUMER_H
#define __TRIGGER_CONSUMER_H

// event consumer class
class CTriggerConsumer : public IWbemUnboundObjectSink
{
private:
    DWORD m_dwCount;            // holds the object reference count

    ITaskScheduler* GetTaskScheduler();

public:
    CTriggerConsumer();
    ~CTriggerConsumer();

    // IUnknown members
    STDMETHODIMP_(ULONG)
    AddRef(
        void
        );
    STDMETHODIMP_(ULONG)
    Release(
        void
        );
    STDMETHODIMP
    QueryInterface(
        IN REFIID riid,
        OUT LPVOID* ppv
        );

    // This routine ultimately receives the event.
    STDMETHOD
    (IndicateToConsumer)(
        IN IWbemClassObject* pLogicalConsumer,
        IN LONG lNumObjects,
        IN IWbemClassObject** ppObjects
        );

};

#endif          // __TRIGGER_CONSUMER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerconsumer.cpp ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERCONSUMER.CPP

Abstract:
    Contains CEventConsumer implementation.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#include "pch.h"
#include "EventConsumerProvider.h"
#include "General.h"
#include "TriggerConsumer.h"
#include "resource.h"

extern HMODULE g_hModule;

#define PROPERTY_COMMAND        _T( "Action" )
#define PROPERTY_TRIGID         _T( "TriggerID" )
#define PROPERTY_NAME           _T( "TriggerName" )
#define PROPERTY_SHEDULE        _T( "ScheduledTaskName" )
#define SPACE                   _T( " " )
#define SLASH                   _T( "\\" )
#define NEWLINE                 _T( "\0" )


CTriggerConsumer::CTriggerConsumer(
    )
/*++
Routine Description:
    Constructor for CTriggerConsumer class for initialization.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // initialize the reference count variable
    m_dwCount = 0;
}

CTriggerConsumer::~CTriggerConsumer(
    )
/*++
Routine Description:
    Desstructor for CTriggerConsumer class.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // there is nothing much to do at this place ...
}

STDMETHODIMP
CTriggerConsumer::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppv
    )
/*++
Routine Description:
    Returns a pointer to a specified interface on an object
    to which a client currently holds an interface pointer.

Arguments:
    [IN] riid : Identifier of the interface being requested.
    [OUT] ppv :Address of pointer variable that receives the
               interface pointer requested in riid. Upon successful
               return, *ppvObject contains the requested interface
               pointer to the object.

Return Value:
    NOERROR if the interface is supported.
    E_NOINTERFACE if not.
--*/
{
    // initialy set to NULL
    *ppv = NULL;

    // check whether interface requested is one we have
    if ( riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink )
    {
        //
        // yes ... requested interface exists
        *ppv = this;        // set the out parameter for the returning the requested interface
        this->AddRef();     // update the reference count
        return NOERROR;     // inform success
    }

    // interface is not available
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CTriggerConsumer::AddRef(
    void
    )
/*++
Routine Description:
    The AddRef method increments the reference count for
    an interface on an object. It should be called for every
    new copy of a pointer to an interface on a given object.

Arguments:
    none.

Return Value:
    Returns the value of the new reference count.
--*/
{
    // increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

STDMETHODIMP_(ULONG)
CTriggerConsumer::Release(
    void
    )
/*++
Routine Description:
    The Release method decreases the reference count of the object by 1.

Arguments:
    none.

Return Value:
    Returns the new reference count.
--*/
{
    // decrement the reference count ( thread safe ) and check whether
    // there are some more references or not ... based on the result value
    DWORD dwCount = 0;
    dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
    if ( 0 == dwCount )
    {
        // free the current factory instance
        delete this;
    }

    // return the no. of instances references left
    return dwCount;
}

STDMETHODIMP
CTriggerConsumer::IndicateToConsumer(
    IN IWbemClassObject* pLogicalConsumer,
    IN LONG lNumObjects,
    IN IWbemClassObject **ppObjects
    )
/*++
Routine Description:
    IndicateToConsumer method is called by Windows Management
    to actually deliver events to a consumer.

Arguments:
    [IN] pLogicalCosumer : Pointer to the logical consumer object
                           for which this set of objects is delivered.
    [IN] lNumObjects     : Number of objects delivered in the array that follows.
    [IN] ppObjects       : Pointer to an array of IWbemClassObject
                           instances which represent the events  delivered.

Return Value:
    Returns WBEM_S_NO_ERROR if successful.
    Otherwise error.
--*/
{
    TCHAR                   szCommand[ MAX_STRING_LENGTH ] = NULL_STRING;
    TCHAR                   szName[ MAX_STRING_LENGTH ] = NULL_STRING;
    TCHAR                   szTask[ MAX_STRING_LENGTH ] = NULL_STRING;
    TCHAR                   szPath[ MAX_STRING_LENGTH ] = NULL_STRING;
    DWORD                   dwID = 0;

    HRESULT                 hRes = 0;
    BOOL                    bResult = FALSE;

    VARIANT                 varValue;
    VARIANT                 varScheduler;
    ITaskScheduler *pITaskScheduler = NULL;
    IEnumWorkItems *pIEnum = NULL;
    ITask *pITask = NULL;

    SecureZeroMemory( szCommand, MAX_STRING_LENGTH * sizeof( TCHAR ) );
    SecureZeroMemory( szName, MAX_STRING_LENGTH * sizeof( TCHAR ) );
    SecureZeroMemory( szPath, MAX_STRING_LENGTH * sizeof( TCHAR ) );
    SecureZeroMemory( szTask, MAX_STRING_LENGTH * sizeof( TCHAR ) );

    // get the 'Item' property values out of the embedded object.
    hRes = PropertyGet( pLogicalConsumer, PROPERTY_COMMAND, 0, szCommand, SIZE_OF_ARRAY( szCommand ) );
    if ( FAILED( hRes ) )
    {
        return hRes;
    }
    // get the trigger name.
    hRes = PropertyGet( pLogicalConsumer, PROPERTY_NAME, 0, szName, SIZE_OF_ARRAY( szName ) );
    if( FAILED( hRes ) )
    {
        return hRes;
    }

    VariantInit( &varScheduler );
    hRes = pLogicalConsumer->Get( PROPERTY_SHEDULE, 0, &varScheduler, NULL, NULL );
    if( FAILED( hRes ) )
    {
        VariantClear( &varScheduler );
        return hRes;
    }

    try
    {
        StringCopy( szTask, ( LPCWSTR ) _bstr_t( varScheduler ), SIZE_OF_ARRAY( szTask ) );
    }
    catch( _com_error& e )
    {
        VariantClear( &varScheduler );
        return e.Error();
    }

    VariantInit( &varValue );
    hRes = pLogicalConsumer->Get( PROPERTY_TRIGID, 0, &varValue, NULL, NULL );
    if( FAILED( hRes ) )
    {
        VariantClear( &varScheduler );
        VariantClear( &varValue );
        return hRes;
    }

    if( VT_NULL == varValue.vt || VT_EMPTY == varValue.vt )
    {
        VariantClear( &varScheduler );
        VariantClear( &varValue );
        return WBEM_E_INVALID_PARAMETER;
    }

    dwID = varValue.lVal;
    VariantClear( &varValue );

    try
    {
        LPWSTR *lpwszNames = NULL;
        DWORD dwFetchedTasks = 0;
        TCHAR szActualTask[MAX_STRING_LENGTH] = NULL_STRING;

        pITaskScheduler = GetTaskScheduler();
        if ( NULL == pITaskScheduler )
        {
            hRes = E_FAIL;
            ONFAILTHROWERROR( hRes );
        }

        hRes = pITaskScheduler->Enum( &pIEnum );
        ONFAILTHROWERROR( hRes );
        while ( SUCCEEDED( pIEnum->Next( 1,
                                       &lpwszNames,
                                       &dwFetchedTasks ) )
                          && (dwFetchedTasks != 0))
        {
            while (dwFetchedTasks)
            {
                // Convert the Wide Charater to Multi Byte value.
                StringCopy( szActualTask, lpwszNames[ --dwFetchedTasks ], SIZE_OF_ARRAY( szActualTask ) );

                // Parse the TaskName to remove the .job extension.
                szActualTask[StringLength( szActualTask, 0 ) - StringLength( JOB, 0) ] = NULL_CHAR;

                StrTrim( szActualTask, TRIM_SPACES );
                CHString strTemp;
                strTemp = varScheduler.bstrVal;
                if( StringCompare( szActualTask, strTemp, TRUE, 0 ) == 0 )
                {
                    hRes = pITaskScheduler->Activate( szActualTask, IID_ITask, (IUnknown**) &pITask );
                    ONFAILTHROWERROR( hRes );
                    hRes = pITask->Run();
                    ONFAILTHROWERROR( hRes );
                    bResult = TRUE;
                }
                CoTaskMemFree( lpwszNames[ dwFetchedTasks ] );

            }//end while
            CoTaskMemFree( lpwszNames );
        }
        EnterCriticalSection( &g_critical_sec );
        if( TRUE == bResult )
        {
            HRESULT phrStatus;
            Sleep( 10000 );
            hRes = pITask->GetStatus( &phrStatus );
            ONFAILTHROWERROR( hRes );
            switch(phrStatus)
            {
              case SCHED_S_TASK_READY:
                    LoadStringW( g_hModule, IDS_TRIGGERED, szTask, MAX_STRING_LENGTH );
                    break;
              case SCHED_S_TASK_RUNNING:
                    LoadStringW( g_hModule, IDS_TRIGGERED, szTask, MAX_STRING_LENGTH );
                   break;
              case SCHED_S_TASK_NOT_SCHEDULED:
                    LoadStringW( g_hModule, IDS_TRIGGER_FAILED, szTask, MAX_STRING_LENGTH );
                   break;
              default:
                    LoadStringW( g_hModule, IDS_TRIGGER_NOT_FOUND, szTask, MAX_STRING_LENGTH );
            }
            ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
        }
        else
        {
            LoadStringW( g_hModule, IDS_TRIGGER_NOT_FOUND, szTask, MAX_STRING_LENGTH );
            ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
        }
        LeaveCriticalSection( &g_critical_sec );
    } //try
    catch(_com_error& e)
    {
        IWbemStatusCodeText *pIStatus   = NULL;
        BSTR                bstrErr     = NULL;
        LPTSTR              lpResStr = NULL;

        VariantClear( &varScheduler );
        lpResStr = ( LPTSTR ) AllocateMemory( MAX_RES_STRING );

        if ( NULL != lpResStr )
        {
            if (SUCCEEDED(CoCreateInstance(CLSID_WbemStatusCodeText, 0,
                                        CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText,
                                        (LPVOID*) &pIStatus)))
            {
                if (SUCCEEDED(pIStatus->GetErrorCodeText(e.Error(), 0, 0, &bstrErr)))
                {
                    StringCopy( lpResStr, bstrErr, ( GetBufferSize( lpResStr )/ sizeof( WCHAR ) ) );
                }
                SAFEBSTRFREE(bstrErr);
                EnterCriticalSection( &g_critical_sec );
                LoadStringW( g_hModule, IDS_TRIGGER_FAILED, szTask, MAX_STRING_LENGTH );
                LoadStringW( g_hModule, IDS_ERROR_CODE, szCommand, MAX_STRING_LENGTH );
                StringCchPrintf( szPath, SIZE_OF_ARRAY( szPath ), szCommand, e.Error() );
                StringConcat( szTask, szPath, SIZE_OF_ARRAY( szTask ) );
                LoadStringW( g_hModule, IDS_REASON, szCommand, MAX_STRING_LENGTH );
                StringCchPrintf( szPath, SIZE_OF_ARRAY( szPath ), szCommand , lpResStr );
                StringConcat( szTask, szPath, SIZE_OF_ARRAY( szTask ) );
                ErrorLog( ( LPCTSTR ) szTask, szName, dwID );
                LeaveCriticalSection( &g_critical_sec );
            }
			SAFERELEASE( pITaskScheduler );
			SAFERELEASE( pIEnum );
			SAFERELEASE( pITask );
            SAFERELEASE(pIStatus);
            FreeMemory( (LPVOID*)&lpResStr );
            return( e.Error() );
        }
    }//catch
    catch( CHeap_Exception  )
    {
        VariantClear( &varScheduler );
		SAFERELEASE( pITaskScheduler );
		SAFERELEASE( pIEnum );
		SAFERELEASE( pITask );
        return E_OUTOFMEMORY;
    }
    SAFERELEASE( pITaskScheduler );
    SAFERELEASE( pIEnum );
	SAFERELEASE( pITask );
    VariantClear( &varScheduler );
    return WBEM_S_NO_ERROR;
}

ITaskScheduler*
CTriggerConsumer::GetTaskScheduler(
    )
/*++
Routine Description:
    This routine gets task scheduler interface.

Arguments:
    none.

Return Value:
    Returns ITaskScheduler interface.
--*/
{
    HRESULT hRes = S_OK;
    ITaskScheduler *pITaskScheduler = NULL;

    hRes = CoCreateInstance( CLSID_CTaskScheduler, NULL, CLSCTX_ALL,
                           IID_ITaskScheduler,(LPVOID*) &pITaskScheduler );
    if( FAILED(hRes))
    {
        return NULL;
    }
    hRes = pITaskScheduler->SetTargetComputer( NULL );
    return pITaskScheduler;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerfactory.h ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERFACTORY.H

Abstract:
    Contains CTriggerFactory definition.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __TRIGGER_FACTORY
#define __TRIGGER_FACTORY

// class factory for the provider
class CTriggerFactory : public IClassFactory
{
public:
    CTriggerFactory();
    ~CTriggerFactory();

    // IUnknown interface members
    STDMETHODIMP_(ULONG)
    AddRef(
        VOID
        );
    STDMETHODIMP_(ULONG)
    Release(
        VOID
        );
    STDMETHODIMP
    QueryInterface(
        IN REFIID riid,
        OUT LPVOID* ppv
        );

    // IClassFactory interface members
    STDMETHODIMP
    CreateInstance(
        IN LPUNKNOWN pUnknownOutter,
        IN REFIID riid,
        OUT LPVOID* ppvObject
        );
    STDMETHODIMP
    LockServer(
        IN BOOL bLock
        );

protected:
    DWORD m_dwCount;            // holds the object reference count
};

#endif      // __TRIGGER_FACTORY
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerfactory.cpp ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERFACTORY.CPP

Abstract:
    Contains the class factory. This creates objects when connections are requested.

Author:
    Vasundhara .G

Revision History :
    Vasundhara .G 9-oct-2k : Created It.
--*/

#include "pch.h"
#include "EventConsumerProvider.h"
#include "TriggerProvider.h"
#include "TriggerFactory.h"

CTriggerFactory::CTriggerFactory(
    )
/*++
Routine Description:
    Constructor for CTriggerFactory class   for initialization.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // initialize the reference count variable
    m_dwCount = 0;
}

CTriggerFactory::~CTriggerFactory(
    )
/*++
Routine Description:
    Destructor for CTriggerFactory class for releasing resources.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // there is nothing much to do at this place ... can be inlined, but
}

STDMETHODIMP
CTriggerFactory::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppv
    )
/*++
Routine Description:
    QueryInterface required to be overridden for a class derived from IUnknown
    interface.

Arguments:
    [IN] riid : which has the ID value of the interface being called.
    [OUT] ppv : pointer to the interface requested.

Return Value:
    NOERROR if successful.
    E_NOINTERFACE if unsuccessful
--*/
{
    // initialy set to NULL
    *ppv = NULL;

    // check whether interface requested is one we have
    if ( riid == IID_IUnknown || riid == IID_IClassFactory )
    {
        //
        // yes ... we have the requested interface
        *ppv=this;          // set the out parameter for the returning the requested interface
        this->AddRef();     // update the reference count
        return NOERROR;     // inform success
    }

    // interface is not available
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG)
CTriggerFactory::AddRef(
    void
    )
/*++
Routine Description:
    Addref required to be overridden for a class derived from IUnknown interface.

Arguments:
    none.

Return Value:
    returns value of reference member.
--*/
{
    // increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

STDMETHODIMP_(ULONG)
CTriggerFactory::Release(
    void
    )
/*++
Routine Description:
    Release required to be overridden for a class derived from IUnknown interface.

Arguments:
    none.

Return Value:
    returns value of reference member, g_lCObj.
--*/
{
    DWORD dwCount;

    // decrement the reference count ( thread safe ) and check whether
    // there are some more references or not ... based on the result value
    dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
    if ( 0 == dwCount )
    {
        // free the current factory instance
        delete this;
    }

    // return the no. of instances references left
    return dwCount;
}

STDMETHODIMP
CTriggerFactory::CreateInstance(
    IN LPUNKNOWN pUnknownOutter,
    IN REFIID riid,
    OUT LPVOID* ppvObject
    )
/*++
Routine Description:
    Creates an object of the specified CLSID and retrieves
    an interface pointer to this object.

Arguments:
    [IN] pUnknownOutter : If the object is being created as part of an
                          aggregate, then pIUnkOuter must be the outer
                          unknown. Otherwise, pIUnkOuter must be NULL.
    [IN] riid           : The IID of the requested interface.
    [OUT] ppvObject     : A pointer to the interface pointer identified by riid.

Return Value:
    NOERROR if successful.
    Otherwise  error value.
--*/
{
    // local variables
    HRESULT hr;
    CTriggerProvider* pProvider = NULL;

    // kick off
    *ppvObject = NULL;
    hr = E_OUTOFMEMORY;
    if ( NULL != pUnknownOutter )
    {
        return CLASS_E_NOAGGREGATION;       // object doesn't support aggregation.
    }
    // create the Initialize object.
    pProvider = new CTriggerProvider();
    if ( NULL == pProvider )
    {
        return E_OUTOFMEMORY;       // ran out of memory
    }
    // get the pointer to the requested interface
    hr = pProvider->QueryInterface( riid, ppvObject );
    if ( FAILED( hr ) )
    {
        delete pProvider;           // interface not available ... de-allocate memory
    }
    // return the appropriate result
    return hr;
}

STDMETHODIMP
CTriggerFactory::LockServer(
    IN BOOL bLock
    )
/*++
Routine Description:
    Increments or decrements the lock count of the DLL.
    If the lock count goes to zero and there are no objects,
    the DLL  is allowed to unload.

arguments:
    [IN] bLock : specifying whether to increment or decrement the lock count.

Returns Value:
    NOERROR always.
--*/
{
    // based on the request update the locks count
    if ( bLock )
    {
        InterlockedIncrement( ( LPLONG ) &g_dwLocks );
    }
    else
    {
        InterlockedDecrement( ( LPLONG ) &g_dwLocks );
    }
    // inform success
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\compress.h ===
#include "resource.h"


#define     MAX_OPTIONS         8
#define     FILE_NOT_FOUND      L"*&%"
#define     BLANK_LINE          L"\n"
#define     ILLEGAL_CHR         L"/\"<>|"

#define     CMDOPTION_RENAME    L"R"
#define     CMDOPTION_UPDATE    L"D"
#define     CMDOPTION_SUPPRESS  L"S"
#define     CMDOPTION_ZX        L"ZX"
#define     CMDOPTION_Z         L"Z"
#define     CMDOPTION_ZQ        L"ZQ"
#define     CMDOPTION_DEFAULT   L""
#define     CMDOPTION_USAGE     L"?"



#define MSZIP_ALG          (ALG_FIRST + 128)
#define QUANTUM_ALG        (ALG_FIRST + 129)
#define LZX_ALG            (ALG_FIRST + 130)


#define DEFAULT_ALG        ALG_FIRST


#define OI_RENAME       0
#define OI_UPDATE       1
#define OI_SUPPRESS     2
#define OI_ZX           3
#define OI_Z            4
#define OI_DEFAULT      5
#define OI_USAGE        6

#define     SAFE_FREE(p)  \
                    if( p!=NULL ) \
                    { \
                        free(p); \
                        p = NULL; \
                    }
#define     EMPTY_SPACE  L" "

DWORD DisplayHelpUsage();

DWORD ProcessOptions( IN DWORD argc,
                      IN LPCWSTR argv[],
                      OUT PBOOL pbRename,
                      OUT PBOOL pbNoLogo,
                      OUT PBOOL pbUpdate,
                      OUT PBOOL pbZ,
                      OUT PBOOL pbZx,
                      OUT PTARRAY pArrVal,
                      OUT PBOOL pbUsage
                    );

DWORD CheckArguments( IN  BOOL bRename,
                      IN  TARRAY FileArr,
                      OUT PTARRAY OutFileArr,
                      OUT PBOOL bTarget
                     );
DWORD DoCompress( IN TARRAY FileArr,
                IN BOOL   bRename,
                IN BOOL   bUpdate,
                IN BOOL   bSuppress,
                IN BOOL   bZx,
                IN BOOL   bZ,
                IN BOOL   bTarget
                );

extern BOOL
 FileTimeIsNewer( LPWSTR pszFile1,
                  LPWSTR pszFile2 );
extern WCHAR
MakeCompressedNameW(
    LPWSTR pszFileName);

extern BOOL ProcessNotification(LPWSTR pszSource,
                                LPWSTR pszDest,
                                WORD wNotification
                                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\compress\compress.c ===
#include "pch.h"
#include "compress.h"


DWORD
_cdecl wmain(DWORD argc,
             LPCWSTR argv[] )
/*++
        Routine Description     :   This is the main routine which calls other routines
                                    for processing the options and finding the files.

        [ IN ]  argc            :   A DWORD variable having the argument count.

        [ IN ]  argv            :   An array of constant strings of command line options.


        Return Value        :   DWORD
            Returns successfully if function is success otherwise return failure.

--*/
{
    TARRAY FileArr;
    TARRAY OutFileArr;
    DWORD  dwStatus                     =   0;
    DWORD  dwCount                      =   0;
    DWORD  dwLoop                       =   0;
    BOOL   bStatus                      =   FALSE;
    BOOL   bRename                      =   FALSE;
    BOOL   bNoLogo                      =   FALSE;
    BOOL   bUpdate                      =   FALSE;
    BOOL   bZx                          =   FALSE;
    BOOL   bZ                           =   FALSE;
    BOOL   bUsage                       =   FALSE;
    WCHAR  *wszPattern                  =   NULL;
    DWORD  dw                           =   0;
    BOOL   bFound                       =   FALSE;
    BOOL   bTarget                      =   FALSE;

    WCHAR               szFileName[MAX_RES_STRING]  =   NULL_STRING;
    WCHAR               szFileName1[MAX_RES_STRING] =   NULL_STRING;
    WCHAR               szDirectory[MAX_RES_STRING] =   NULL_STRING;
    WCHAR               szBuffer[MAX_RES_STRING]    =   NULL_STRING;


    if( argc<=1 )
    {
        DISPLAY_MESSAGE( stderr, GetResString( IDS_INVALID_SYNTAX ) );
        DISPLAY_MESSAGE( stderr, GetResString( IDS_HELP_MESSAGE) );
        return( EXIT_FAILURE);
    }

    dwStatus = ProcessOptions( argc, argv,
                                &bRename,
                                &bNoLogo,
                                &bUpdate,
                                &bZ,
                                &bZx,
                                &FileArr,
                                &bUsage);
    if( EXIT_FAILURE == dwStatus )
    {
        DestroyDynamicArray( &FileArr);
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    if( TRUE == bUsage )
    {
        DisplayHelpUsage();
        DestroyDynamicArray( &FileArr);
        ReleaseGlobals();
        return(EXIT_SUCCESS);
    }

    OutFileArr = CreateDynamicArray();
    if( NULL == OutFileArr )
    {
        SetLastError( ERROR_OUTOFMEMORY );
        SaveLastError();
        swprintf( szBuffer, L"%s %s", GetResString(IDS_TAG_ERROR), GetReason() );
        DISPLAY_MESSAGE( stderr, _X(szBuffer) );
        DestroyDynamicArray( &FileArr);
        ReleaseGlobals();
        return EXIT_FAILURE;
    }

    dwStatus = CheckArguments( bRename, FileArr, &OutFileArr, &bTarget  );
    if( EXIT_FAILURE == dwStatus )
    {
        DestroyDynamicArray( &OutFileArr);
        DestroyDynamicArray( &FileArr);
        ReleaseGlobals();
        return( EXIT_FAILURE );
    }

    dwCount = DynArrayGetCount( OutFileArr );

    //the input file list not neccessary, destroy it
    DestroyDynamicArray(&FileArr );

    dwStatus =  DoCompress( OutFileArr, bRename, bUpdate, bNoLogo, bZx, bZ, bTarget);

    ReleaseGlobals();
    DestroyDynamicArray( &OutFileArr);

    return( dwStatus );

}

DWORD CheckArguments( IN  BOOL bRename,
                      IN  TARRAY FileArr,
                      OUT PTARRAY OutFileArr,
                      OUT PBOOL bTarget
                     )
/*++
     Routine Description: Checks the validity of input files and returns
                          full path names of files and target file specification.
     Arguments          :

        [ IN ] bRename  :   A boolean variable specified whether rename option is specified
                            or not.

        [ IN ] FileArr  :   A dynamic array of list of files specified at command prompt.

        [ OUT ] OutFileArr: A dynamic array consists of complete file paths to be compressed.

        [ OUT ] bTarget :   A boolean variable represents whether target file is specified or
                            not.

  Return Value  :   DWORD
               Returns EXIT_SUCCESS if syntax of files is correct, returns EXIT_FAILURE
               otherwise.

--*/
{
    WIN32_FIND_DATA     fData;
    HANDLE              hFData;
    DWORD               dwCount                     =   0;
    DWORD               dw                          =   0;
    DWORD               dwAttr                      =   0;
    LPWSTR              szTempFile                  =   NULL;
    LPWSTR              szTemp                      =   NULL;
    WCHAR*              szTemp1                     =   NULL;
    WCHAR*              szTemp2                     =   NULL;
    WCHAR*              szFileName1                 =   NULL;
    WCHAR*              szDirectory                 =   NULL;
    WCHAR               szFileName[MAX_RES_STRING]  =   NULL_STRING;
    WCHAR               szBuffer[MAX_RES_STRING]    =   NULL_STRING;
    BOOL                bFound                      =   FALSE;
    DWORD               cb                          =   0;


    //get the count of files
    dwCount = DynArrayGetCount( FileArr );

    //check if destination is not specified without rename specification
    if(  1 == dwCount  && FALSE == bRename)
    {
        DISPLAY_MESSAGE( stderr, GetResString( IDS_NO_DESTINATION_SPECIFIED ) );
        return( EXIT_FAILURE );
    }

    //convert the source file names into full path names
    for( dw=0; dw<=dwCount-1; dw++ )
    {
        szTempFile = (LPWSTR)DynArrayItemAsString( FileArr, dw );
        if( NULL == szTempFile )
            continue;

        lstrcpy( szFileName, szTempFile );


        //if the filename is a pattern, then find the matched files
        if( (szTemp=wcsstr(szFileName, L"?")) != NULL  || (szTemp = wcsstr( szFileName, L"*" )) != NULL )
        {
            //get the directory path from given file pattern
            if( (szTemp = wcsstr(szFileName, L"\\")) != NULL )
            {
                szDirectory = malloc( lstrlen(szFileName)*sizeof(WCHAR) );
                if( NULL == szDirectory )
                {
                    DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                    DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                    SetLastError( ERROR_OUTOFMEMORY );
                    SaveLastError();
                    DISPLAY_MESSAGE( stderr, GetReason() );
                    return( EXIT_FAILURE );
                }
                lstrcpy( szDirectory, szFileName );
                szTemp1 = wcsrchr( szDirectory, L'\\');
                szTemp1++;
                *szTemp1 = 0;

            }
            hFData = FindFirstFileEx( szFileName,
                              FindExInfoStandard,
                              &fData,
                              FindExSearchNameMatch,
                              NULL,
                              0);

            //if no file found insert File Not Found code
            if( INVALID_HANDLE_VALUE  == hFData )
                break;

            do
            {
                if( lstrcmp(fData.cFileName, L".")!=0 && lstrcmp(fData.cFileName, L"..") != 0 &&
                    !(FILE_ATTRIBUTE_DIRECTORY & fData.dwFileAttributes) )
                {
                    //copy the file into temporary file and get the full path for that file
                    if( szDirectory != NULL )
                        szFileName1 = malloc( (lstrlen(szDirectory)+lstrlen(fData.cFileName)+10)*sizeof(WCHAR) );
                    else
                        szFileName1 = malloc( (lstrlen(fData.cFileName)+10)*sizeof(WCHAR) );
                    if(NULL == szFileName1 )
                    {
                        DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                        DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                        SetLastError( ERROR_OUTOFMEMORY );
                        SaveLastError();
                        DISPLAY_MESSAGE( stderr, GetReason() );
                        return( EXIT_FAILURE );
                    }
                    if( szDirectory != NULL )
                        swprintf( szFileName1, L"%s%s", szDirectory, fData.cFileName );
                    else
                        lstrcpy( szFileName1, fData.cFileName );

                    DynArrayAppendString( *OutFileArr, szFileName1, lstrlen(szFileName1) );
                    SAFE_FREE( szFileName1 );
                    bFound = TRUE;
                }

            }while(FindNextFile(hFData, &fData));
            FindClose(hFData);

            //if not found insert file not found into array
            if( !bFound )
                DynArrayAppendString( *OutFileArr, FILE_NOT_FOUND, lstrlen(FILE_NOT_FOUND) );
            SAFE_FREE( szDirectory );
        }
        else
        {
            //append the file
            DynArrayAppendString( *OutFileArr, szFileName, lstrlen(szFileName) );
        }

    }

    //check if more than two source files specified and destination is a directory or not
    //get count
    dwCount = DynArrayGetCount( *OutFileArr );

    if(  dwCount<=1 && FALSE == bRename )
    {
        DISPLAY_MESSAGE( stderr, GetResString( IDS_NO_DESTINATION_SPECIFIED ) );
        return( EXIT_FAILURE );
    }

    *bTarget = FALSE;

    if( 2==dwCount )
    {
        //get the target file
        szTempFile = (LPWSTR)DynArrayItemAsString( *OutFileArr, dwCount-1 );
		if ( NULL == szTempFile )
		{
			//No need to break here..continue..
		}

        dwAttr = GetFileAttributes( szTempFile );

        if( -1 == dwAttr )
        {
            if( FALSE == bRename )
                *bTarget = TRUE;
        }
        else
            if(  (dwAttr & FILE_ATTRIBUTE_DIRECTORY) )
                *bTarget = TRUE;
            else
                if( FALSE == bRename )
                    *bTarget = TRUE;
    }


    //if multiple source files specified
    if( dwCount > 2 )
    {
        //get the target file
        szTempFile = (LPWSTR)DynArrayItemAsString( *OutFileArr, dwCount-1 );
		if ( NULL == szTempFile )
		{
			//No need to break here..continue
		}

        dwAttr = GetFileAttributes( szTempFile );

        //check for nonexisting file
        if( -1 == dwAttr && FALSE == bRename )
        {
            DISPLAY_MESSAGE( stderr, GetResString( IDS_DIRECTORY_NOTFOUND) );
            return( EXIT_FAILURE );
        }

        //if target name is not directory and bRename is not specified
        if( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) && FALSE == bRename )
        {
            DISPLAY_MESSAGE( stderr, GetResString( IDS_INVALID_DIRECTORY ) );
            return( EXIT_FAILURE );
        }

        if( (dwAttr & FILE_ATTRIBUTE_DIRECTORY)  )
            *bTarget = TRUE;

    }

    return EXIT_SUCCESS;
}

DWORD DoCompress( IN TARRAY FileArr,
                IN BOOL   bRename,
                IN BOOL   bUpdate,
                IN BOOL   bNoLogo,
                IN BOOL   bZx,
                IN BOOL   bZ,
                IN BOOL   bTarget
                )
/*++
        Routine Description : This routine compresses the specified files into target files.

        Arguments:

            [ IN ]  FileArr : A list of source and target files for compression.

            [ IN ]  bRename : A boolean varaible specifies whether output file is a rename of
                              source file or not.

            [ IN ]  bUpdate : A boolean varaible specifies compress if outof date.

            [ IN ]  bUpdate : A boolean varaible specifies if copy right info display or not.

            [ IN ]  bZx     : A boolean varaible specifies LZX compression apply or not.

            [ IN ]  bZ      : A boolean varaible specifies ZIP compression apply or not.

            [ IN ]  dwZq    : A varaible specifies level of Quantom compression to apply if specified.

            [ IN ]  bTarget : A boolean varaible tells whether target file is specified or not.

        Return Value    :

              EXIT_SUCCESS if succefully compressed all the files, return EXIT_FAILURE otherwise.

--*/
{
    TARRAY OutFileArr;
    PLZINFO pLZI;
    TCOMP Level;
    TCOMP Mem;

    DWORD   dwStatus                        =   0;
    DWORD   dwCount                     =   0;
    DWORD   dwLoop                      =   0;
    DWORD   dw                          =   0;
    DWORD   dwAttr                      =   0;
    BOOL    bFound                      =   FALSE;
    WCHAR   wchTemp                     =   0;
    LPWSTR  szLastfile                  =   NULL;
    LPWSTR  szSourcefile                =   NULL;
    WCHAR*  szTargetfile                =   NULL;
    WCHAR*  szOutfile                   =   NULL;
    CHAR*   szSourcefiletmp             =   NULL;
    CHAR*   szOutfiletmp                =   NULL;
    WCHAR   szBuffer[MAX_PATH]          =   NULL_STRING;
    DWORD   fError                      =   0;
    float   cblTotInSize                =   0.0;
    float   cblTotOutSize               =   0.0;
    float   cblAdjInSize                =   0;
    float   cblAdjOutSize               =   0;
    DWORD   dwFilesCount                =   0;
    int     cb                          =   0;


    dwCount = dwLoop = DynArrayGetCount( FileArr );

    //take the last file as target file
    if( bTarget )
    {
        szLastfile = (LPWSTR)DynArrayItemAsString( FileArr, dwCount-1 );
		if ( NULL == szLastfile )
		{
			//No need to break here..continue..
		}

        dwLoop--;
    }

    //intialize the global buffers
    pLZI = InitGlobalBuffersEx();
    if (!pLZI)
    {
      DISPLAY_MESSAGE( stderr, L"Unable to initialize\n" );
      return EXIT_FAILURE;
    }
    if( bZx )
    {
                // LZX. Also set memory.
                //Mem = (TCOMP)atoi("");

                Mem = (TCOMP)0;

                if((Mem < (tcompLZX_WINDOW_LO >> tcompSHIFT_LZX_WINDOW))
                || (Mem > (tcompLZX_WINDOW_HI >> tcompSHIFT_LZX_WINDOW))) {

                    Mem = (tcompLZX_WINDOW_LO >> tcompSHIFT_LZX_WINDOW);
                }

                byteAlgorithm = LZX_ALG;
                DiamondCompressionType = TCOMPfromLZXWindow( Mem );
    }
    else if( bZ )
        {
            DiamondCompressionType = tcompTYPE_MSZIP;
                    byteAlgorithm = MSZIP_ALG;
        }
        else
        {
                DiamondCompressionType = 0;
                byteAlgorithm = DEFAULT_ALG;
        }

/*  no quantom support for this shipment
    if(dwZq != 0 )
        {
         //
                // Quantum. Also set level.
                //


                Level = (TCOMP)dwZq;

                //not supported yet, keep this for the time sake
                //Mem = (p = strchr(argv[i]+3,',')) ? (TCOMP)atoi(p+1) : 0;
                Mem = 0;

                if((Level < (tcompQUANTUM_LEVEL_LO >> tcompSHIFT_QUANTUM_LEVEL))
                || (Level > (tcompQUANTUM_LEVEL_HI >> tcompSHIFT_QUANTUM_LEVEL)))
                {

                    Level = ((tcompQUANTUM_LEVEL_HI - tcompQUANTUM_LEVEL_LO) / 2)
                          + tcompQUANTUM_LEVEL_LO;

                    Level >>= tcompSHIFT_QUANTUM_LEVEL;
                }

                if((Mem < (tcompQUANTUM_MEM_LO >> tcompSHIFT_QUANTUM_MEM))
                || (Mem > (tcompQUANTUM_MEM_HI >> tcompSHIFT_QUANTUM_MEM)))
                {

                    Mem = ((tcompQUANTUM_MEM_HI - tcompQUANTUM_MEM_LO) / 2)
                        + tcompQUANTUM_MEM_LO;

                    Mem >>= tcompSHIFT_QUANTUM_MEM;
                }

                byteAlgorithm = QUANTUM_ALG;
                DiamondCompressionType = TCOMPfromTypeLevelMemory(
                                            tcompTYPE_QUANTUM,
                                            Level,
                                            Mem
                                            );
        }

*/
    //display one blank line
    DISPLAY_MESSAGE( stdout, BLANK_LINE );

    if( !bNoLogo )
    {
        DISPLAY_MESSAGE( stdout, GetResString( IDS_BANNER_TEXT ) );
        DISPLAY_MESSAGE( stdout, GetResString( IDS_VER_PRODUCTVERSION_STR ) );
    }

    //now compress the source files one by one
    for( dw=0; dw<dwLoop; dw++ )
    {
        //get the source file
        szSourcefile = (LPWSTR)DynArrayItemAsString( FileArr, dw );
        if( NULL == szSourcefile )
            continue;

        if( lstrcmp( szSourcefile, FILE_NOT_FOUND) == 0 )
        {
            DISPLAY_MESSAGE( stderr, GetResString( IDS_FILE_NOTFOUND ) );
            continue;
        }

        //get file attributes
        dwAttr = GetFileAttributes( szSourcefile );

        //check if file exist or not
        if( -1 == dwAttr )
        {
            DISPLAY_MESSAGE1( stderr, szBuffer, GetResString( IDS_NO_SOURCEFILE ), szSourcefile );
            continue;
        }

        //skip if it is a direcotry
        if( dwAttr & FILE_ATTRIBUTE_DIRECTORY )
            continue;


        //make the target file
        //check if it is a directory
        if( bTarget )
        {
            dwAttr = GetFileAttributes( szLastfile );

            if( -1 != dwAttr  && (dwAttr & FILE_ATTRIBUTE_DIRECTORY))
            {
                szTargetfile = malloc( (lstrlen(szLastfile)+lstrlen(szSourcefile)+10)*sizeof(WCHAR) );
                if(NULL == szTargetfile )
                {
                    DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                    DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                    SetLastError( ERROR_OUTOFMEMORY );
                    SaveLastError();
                    DISPLAY_MESSAGE( stderr, GetReason() );
                    return( EXIT_FAILURE );
                }
                swprintf( szTargetfile, L"%s\\%s", szLastfile, szSourcefile );
            }
            else
            {
                szTargetfile = malloc( (lstrlen(szLastfile)+10)*sizeof(WCHAR) );
                if(NULL == szTargetfile )
                {
                    DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                    DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                    SetLastError( ERROR_OUTOFMEMORY );
                    SaveLastError();
                    DISPLAY_MESSAGE( stderr, GetReason() );
                    return( EXIT_FAILURE );
                }
                    swprintf( szTargetfile, L"%s", szLastfile );
            }

        }
        else
        {
            //obviously rename has specified, copy source file into target file
            szTargetfile = malloc( (lstrlen(szSourcefile)+10)*sizeof(WCHAR) );
            if(NULL == szTargetfile )
            {
                DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                SetLastError( ERROR_OUTOFMEMORY );
                SaveLastError();
                DISPLAY_MESSAGE( stderr, GetReason() );
                return( EXIT_FAILURE );
            }
            lstrcpy( szTargetfile, szSourcefile);
        }

        //allocate memory for szOutfile
        szOutfile = malloc( (lstrlen(szTargetfile)+10)*sizeof(WCHAR) );
        if(NULL == szTargetfile )
        {
            DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
            DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
            SetLastError( ERROR_OUTOFMEMORY );
            SaveLastError();
            DISPLAY_MESSAGE( stderr, GetReason() );
            SAFE_FREE( szTargetfile );
            return( EXIT_FAILURE );
        }
        lstrcpy( szOutfile, szTargetfile );

        if( bRename )
            MakeCompressedNameW( szTargetfile );

        if (( !bUpdate ) ||
              ( FileTimeIsNewer( szSourcefile, szTargetfile )))
         {

                //if the diamond compression type is given
               if(DiamondCompressionType)
               {
                   //convert source file and target file names from wide char string to char strings
                   //this is because the API in lib is written for char strings only
                 cb = WideCharToMultiByte( CP_THREAD_ACP, 0, szSourcefile, lstrlen( szSourcefile ),
                                      szSourcefiletmp, 0, NULL, NULL );

                 szSourcefiletmp = malloc( (cb+10)*sizeof(char) );
                 if(NULL == szTargetfile )
                 {
                    DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                    DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                    SetLastError( ERROR_OUTOFMEMORY );
                    SaveLastError();
                    DISPLAY_MESSAGE( stderr, GetReason() );
                    SAFE_FREE( szTargetfile );
                    SAFE_FREE( szOutfile );
                    return( EXIT_FAILURE );
                 }

                 cb = WideCharToMultiByte( CP_THREAD_ACP, 0, szOutfile, lstrlen( szOutfile ),
                                      szOutfiletmp, 0, NULL, NULL );
                 szOutfiletmp = malloc( (cb+10)*sizeof(char) );
                 if(NULL == szTargetfile )
                 {
                    DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                    DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                    SetLastError( ERROR_OUTOFMEMORY );
                    SaveLastError();
                    DISPLAY_MESSAGE( stderr, GetReason() );
                    SAFE_FREE( szTargetfile );
                    SAFE_FREE( szOutfile );
                    return( EXIT_FAILURE );
                 }

                 ZeroMemory(szSourcefiletmp, lstrlen(szSourcefile)+10 );
                 ZeroMemory(szOutfiletmp, lstrlen(szOutfile)+10);

                 if( FALSE == WideCharToMultiByte( CP_THREAD_ACP, 0, szSourcefile, lstrlen( szSourcefile ),
                                      szSourcefiletmp, cb+10, NULL, NULL ) )
                 {
                     SaveLastError();
                     DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                     DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                     DISPLAY_MESSAGE( stderr, GetReason() );
                     SAFE_FREE( szTargetfile );
                     SAFE_FREE( szOutfile );
                     SAFE_FREE( szSourcefiletmp );
                     SAFE_FREE( szOutfiletmp );
                     return EXIT_FAILURE;
                 }

                 if( FALSE == WideCharToMultiByte( CP_THREAD_ACP, 0, szOutfile, lstrlen( szOutfile ),
                                      szOutfiletmp, cb+10, NULL, NULL ) )
                 {
                     SaveLastError();
                     DISPLAY_MESSAGE( stderr, GetResString(IDS_TAG_ERROR) );
                     DISPLAY_MESSAGE( stderr, EMPTY_SPACE );
                     DISPLAY_MESSAGE( stderr, GetReason() );
                     SAFE_FREE( szTargetfile );
                     SAFE_FREE( szOutfile );
                     SAFE_FREE( szSourcefiletmp );
                     SAFE_FREE( szOutfiletmp );
                     return EXIT_FAILURE;
                 }

                 fError = DiamondCompressFile(ProcessNotification, szSourcefiletmp,
                                                 szOutfiletmp,bRename,pLZI);
               }
               else
               {
                 fError = Compress(ProcessNotification, szSourcefile,
                                     szOutfile, byteAlgorithm, bRename, pLZI);
               }



          if(fError == TRUE)
          {
             bFound = TRUE;
             dwFilesCount++;

             if (pLZI && pLZI->cblInSize && pLZI->cblOutSize)
             {

                // Keep track of cumulative statistics.
                cblTotInSize += pLZI->cblInSize;
                cblTotOutSize += pLZI->cblOutSize;

                // Display report for each file.
               fwprintf(stdout, GetResString( IDS_FILE_REPORT ),szSourcefile, pLZI->cblInSize, pLZI->cblOutSize,
                   (INT)(100 - ((100 * (LONGLONG) pLZI->cblOutSize) / pLZI->cblInSize)));

             }
             else
             {
                fwprintf( stderr, GetResString( IDS_EMPTY_FILE_REPORT ), 0,0 );

             }
             // Separate individual file processing message blocks by a blank line.
             DISPLAY_MESSAGE( stdout, BLANK_LINE );

          }
         }
        else
        {
            DISPLAY_MESSAGE( stdout, GetResString( IDS_FILE_ALREADY_UPDATED ) );
             FreeGlobalBuffers(pLZI);
             SAFE_FREE( szTargetfile );
             SAFE_FREE( szOutfile );
             SAFE_FREE( szSourcefiletmp );
             SAFE_FREE( szOutfiletmp );
             return( EXIT_SUCCESS );
        }

       SAFE_FREE( szTargetfile );
       SAFE_FREE( szOutfile );
       SAFE_FREE( szSourcefiletmp );
       SAFE_FREE( szOutfiletmp );

    }

    // Free memory used by ring buffer and I/O buffers.
   FreeGlobalBuffers(pLZI);

   // Display cumulative report for multiple files.
   if (dwFilesCount >= 1 && bFound)
   {

      cblAdjInSize = cblTotInSize;
      cblAdjOutSize =  cblTotOutSize;

      while (cblAdjInSize > 100000)
      {
        cblAdjInSize /= 2;
        cblAdjOutSize /= 2;
      }

      cblAdjOutSize += (cblAdjInSize / 200);    // round off (+0.5%)

      if (cblAdjOutSize < 0)
      {
        cblAdjOutSize = 0;
      }

      fwprintf(stdout, GetResString( IDS_TOTAL_REPORT ), dwFilesCount, (DWORD)cblTotInSize, (DWORD)cblTotOutSize,
             (INT)(100 - 100 * cblAdjOutSize / cblAdjInSize));
    }

   SAFE_FREE( szTargetfile );
   SAFE_FREE( szOutfile );
   SAFE_FREE( szSourcefiletmp );
   SAFE_FREE( szOutfiletmp );

   if( bFound )
        return EXIT_SUCCESS;
   else
       return EXIT_FAILURE;
}


DWORD ProcessOptions( IN DWORD argc,
                      IN LPCWSTR argv[],
                      OUT PBOOL pbRename,
                      OUT PBOOL pbNoLogo,
                      OUT PBOOL pbUpdate,
                      OUT PBOOL pbZ,
                      OUT PBOOL pbZx,
                      OUT PTARRAY pArrVal,
                      OUT PBOOL pbUsage
                    )
/*++

    Routine Description : Function used to process the main options

    Arguments:
         [ in  ]  argc           : Number of command line arguments
         [ in  ]  argv           : Array containing command line arguments
         [ out ]  pbRename       : A pointer to boolean variable returns TRUE if Rename option is specified.
         [ out ]  pbNoLogo       : A pointer to boolean variable returns TRUE if Suppress option is specified.
         [ out ]  pbUpdate       : A pointer to boolean variable returns TRUE if Update option is specified.
         [ out ]  pbZx           : A pointer to boolean variable returns TRUE if Zx option is specified.
         [ out ]  pbZ            : A pointer to boolean variable returns TRUE if Z option is specified.
         [ out ]  dwZq           : A pointer to a DWORD variable returns value for quantom compression.
         [ out ]  pArrVal        : A pointer to dynamic array returns file names specified as default options.
         [ out ]  pbUsage        : A pointer to boolean variable returns TRUE if Usage option is specified.

      Return Type      : DWORD
        A Integer value indicating EXIT_SUCCESS on successful parsing of
                command line else EXIT_FAILURE

--*/
{
    BOOL    bStatus             =   0;
    DWORD   dwAttr              =   0;
    LPWSTR  szFilePart          =   NULL;
    LPWSTR  szBuffer            =   NULL;
    WCHAR   szBuffer1[MAX_PATH] =   NULL_STRING;
    DWORD   dwCount             =   0;
    DWORD   dw                  =   0;
    DWORD   pos                 =   0;
    TCMDPARSER cmdOptions[]={
        {CMDOPTION_RENAME,      0,         1,0,pbRename,        NULL_STRING,NULL,NULL},
        {CMDOPTION_UPDATE,      0,         1,0,pbUpdate,        NULL_STRING,NULL,NULL},
        {CMDOPTION_SUPPRESS,    0,         1,0,pbNoLogo ,       NULL_STRING,NULL,NULL},
        {CMDOPTION_ZX,          0,         1,0,pbZx,            NULL_STRING,NULL,NULL},
        {CMDOPTION_Z,           0,         1,0,pbZ,             NULL_STRING,NULL,NULL},
        {CMDOPTION_DEFAULT,     0,         0,0,pArrVal,         NULL_STRING,NULL,NULL},
        {CMDOPTION_USAGE,       CP_USAGE,  1,0,pbUsage,         NULL_STRING,NULL,NULL}
    };

    *pArrVal=CreateDynamicArray();
    if( NULL == *pArrVal  )
    {
        DISPLAY_MESSAGE( stderr, GetResString(IDS_NO_MEMORY) );
        return( EXIT_FAILURE );
    }


    //set the flags for options
    cmdOptions[OI_DEFAULT].pValue = pArrVal;
    cmdOptions[OI_DEFAULT].dwFlags = CP_DEFAULT |  CP_MODE_ARRAY | CP_TYPE_TEXT;
//  cmdOptions[OI_ZQ].dwFlags      = CP_VALUE_MASK | CP_TYPE_UNUMERIC | CP_VALUE_MANDATORY;

    //process the command line options and display error if it fails
    if( DoParseParam( argc, argv, SIZE_OF_ARRAY(cmdOptions ), cmdOptions ) == FALSE )
    {
        DISPLAY_MESSAGE(stderr, GetResString(IDS_ERROR_TAG) );
        DISPLAY_MESSAGE(stderr,GetReason());
        return( EXIT_FAILURE );
    }

    //if usage specified with any other value display error and return with failure
    if( ( TRUE == *pbUsage ) && ( argc > 2 ) )
    {
        DISPLAY_MESSAGE( stderr, GetResString(IDS_INVALID_SYNTAX) );
        return( EXIT_FAILURE );
    }

    if( TRUE == *pbUsage )
        return( EXIT_SUCCESS);

/*
    if( cmdOptions[OI_ZQ].dwActuals != 0 && cmdOptions[OI_Z].dwActuals != 0 )
    {
        DISPLAY_MESSAGE( stderr, GetResString(IDS_MORETHAN_ONE_OPTION ) );
        DISPLAY_MESSAGE( stderr, GetResString( IDS_HELP_MESSAGE) );
        return( EXIT_FAILURE );
    }

    //dont allow more than one option
    if( cmdOptions[OI_ZQ].dwActuals != 0 && cmdOptions[OI_ZX].dwActuals != 0 )
    {
        DISPLAY_MESSAGE( stderr, GetResString(IDS_MORETHAN_ONE_OPTION ) );
        DISPLAY_MESSAGE( stderr, GetResString( IDS_HELP_MESSAGE) );
        return( EXIT_FAILURE );
    }
*/
    if( cmdOptions[OI_ZX].dwActuals != 0 && cmdOptions[OI_Z].dwActuals != 0 )
    {
        DISPLAY_MESSAGE( stderr, GetResString(IDS_MORETHAN_ONE_OPTION ) );
        DISPLAY_MESSAGE( stderr, GetResString( IDS_HELP_MESSAGE) );
        return( EXIT_FAILURE );
    }

/*
    //check if wrong value is specified for zq quantom level
    if( cmdOptions[OI_ZQ].dwActuals != 0  && !(*pdwZq>=1 && *pdwZq<=7) )
    {
        DISPLAY_MESSAGE( stderr, GetResString( IDS_ERROR_QUANTOM_LEVEL ) );
        DISPLAY_MESSAGE( stderr, GetResString( IDS_HELP_MESSAGE) );
        return(EXIT_FAILURE);
    }
*/

    dwCount = DynArrayGetCount( *pArrVal );
    if( 0 == dwCount )
    {
        DISPLAY_MESSAGE( stderr, GetResString( IDS_NO_FILE_SPECIFIED ) );
        return( EXIT_FAILURE );
    }

    //this is to check if illegal characters are specified in file name
    for(dw=0; dw<dwCount; dw++ )
    {
        szBuffer=(LPWSTR)DynArrayItemAsString( *pArrVal, dw);
        if( NULL == szBuffer )
            continue;
        pos = wcscspn( szBuffer, ILLEGAL_CHR );
        if( pos< (DWORD)lstrlen(szBuffer) )
        {
            DISPLAY_MESSAGE1( stderr, szBuffer1, GetResString( INVALID_FILE_NAME ), szBuffer );
            return( EXIT_FAILURE );
        }
    }


    return( EXIT_SUCCESS );

}

DWORD DisplayHelpUsage()
/*++
        Routine Description     :   This routine is to display the help usage.

        Return Value        :   DWORD
            Returns success.

--*/
{
    DWORD dw = 0;

    for(dw=IDS_MAIN_HELP_BEGIN;dw<=IDS_MAIN_HELP_END;dw++)
        DISPLAY_MESSAGE(stdout, GetResString(dw) );
    return( EXIT_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerprovider.h ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERPROVIDER.H

Abstract:
    Contains CTriggerProvider definition.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#ifndef __TRIGGER_PROVIDER_H
#define __TRIGGER_PROVIDER_H

// typedefs
typedef TCHAR STRINGVALUE[ MAX_STRING_LENGTH + 1 ];

#define ERROR_TRIGNAME_ALREADY_EXIST_EX    MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 1 )
#define ERROR_TRIGGER_NOT_DELETED_EX       MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 2 )
#define ERROR_TRIGGER_NOT_FOUND_EX         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 3 )
#define ERROR_INVALID_USER_EX              MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 4 )
#define WARNING_INVALID_USER_EX            MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 5 )
#define ERROR_TRIGGER_ID_EXCEED_EX         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 6 )
#define ERROR_TRIGGER_CORRUPTED_EX         MAKE_HRESULT( SEVERITY_ERROR, FACILITY_ITF, 7 )

#define ERROR_TRIGNAME_ALREADY_EXIST    1
#define ERROR_TRIGGER_NOT_DELETED       2
#define ERROR_TRIGGER_NOT_FOUND         3
#define WARNING_INVALID_USER            2

#define MAX_TRIGGERNAME_LENGTH          196
#define MAX_TRIGGEID_VALUE              4294967295

#define ERROR_SCHDEULE_TASK_INVALID_USER   0x80041310
#define ERROR_TASK_SCHDEULE_SERVICE_STOP   0x80041315
#define EXE_STRING                  _T( ".exe" )
#define CREATE_METHOD_NAME          _T( "CreateETrigger" )
#define DELETE_METHOD_NAME          _T( "DeleteETrigger" )
#define QUERY_METHOD_NAME           _T( "QueryETrigger" )

#define CREATE_METHOD_NAME_EX        _T( "CreateETriggerEx" )
#define DELETE_METHOD_NAME_EX        _T( "DeleteETriggerEx" )
#define QUERY_METHOD_NAME_EX         _T( "QueryETriggerEx" )
#define IN_TRIGGER_ID               L"TriggerID"
#define IN_TRIGGER_NAME             L"TriggerName"
#define IN_TRIGGER_DESC             L"TriggerDesc"
#define IN_TRIGGER_ACTION           L"TriggerAction"
#define IN_TRIGGER_QUERY            L"TriggerQuery"
#define IN_TRIGGER_USER             L"RunAsUser"
#define IN_TRIGGER_PWD              L"RunAsPwd"
#define IN_TRIGGER_TSCHDULER        L"ScheduledTaskName"
#define RETURN_VALUE                L"ReturnValue"
#define OUT_RUNAS_USER              L"RunAsUser"
#define UNIQUE_TASK_NAME            _T( "%s%d%d" )

#define NAMESPACE                   L"root\\cimv2"
#define CONSUMER_CLASS              L"CmdTriggerConsumer"
#define TRIGGER_ID                  L"TriggerID"
#define TRIGGER_NAME                L"TriggerName"
#define TRIGGER_DESC                L"TriggerDesc"
#define TRIGGER_ACTION              L"Action"
#define TASK_SHEDULER               L"ScheduledTaskName"

#define FILTER_CLASS                L"__EventFilter"
#define FILTER_NAME                 L"Name"
#define FILTER_QUERY_LANGUAGE       L"QueryLanguage"
#define QUERY_LANGUAGE              L"WQL"
#define FILTER_QUERY                L"Query"

#define BINDINGCLASS                L"__FilterToConsumerBinding"
#define CONSUMER_BIND               L"Consumer"
#define FILTER_BIND                 L"Filter"

#define REL_PATH                    L"__RELPATH"
#define BIND_CONSUMER_PATH          _T( "CmdTriggerConsumer.TriggerID=%d" )
#define TRIGGER_INSTANCE_NAME       _T( "SELECT * FROM CmdTriggerConsumer WHERE TriggerName = \"%s\"" )
#define BIND_FILTER_PATH            _T( "__EventFilter.Name=\"" )
#define BACK_SLASH                  L"\""
#define DOUBLE_SLASH                L"\\\"\""
#define EQUAL                       _T( '=' )
#define DOUBLE_QUOTE                _T( '"' )
#define END_OF_STRING               _T( '\0' )
#define FILTER_PROP                 _T( "__FilterToConsumerBinding.Consumer=\"%s\",Filter=\"__EventFilter.Name=\\\"" )
#define FILTER_UNIQUE_NAME          _T( "CmdTriggerConsumer.%d%d:%d:%d%d/%d/%d" )
#define CONSUMER_QUERY              _T("SELECT * FROM CmdTriggerConsumer WHERE TriggerName = \"%s\"")
#define VALID_QUERY                 _T("__instancecreationevent where targetinstance isa \"win32_ntlogevent\"")
#define EVENT_LOG                   _T("win32_ntlogevent")
#define INSTANCE_EXISTS_QUERY       L"select * from CmdTriggerConsumer"



// provider class
class CTriggerProvider : public IDispatch,
                         public IWbemEventConsumerProvider,
                         public IWbemServices, public IWbemProviderInit
{
private:
    DWORD m_dwCount;            // holds the object reference count
    BOOL  m_MaxTriggers;

    // WMI related stuff
    LPWSTR m_pwszLocale;
    IWbemContext* m_pContext;
    IWbemServices*  m_pServices;

// construction / destruction
public:
    CTriggerProvider();
    ~CTriggerProvider();

// methods
private:

    HRESULT
    CreateTrigger(
        IN VARIANT varTName,
        IN VARIANT varTDesc,
        IN VARIANT varTAction,
        IN VARIANT varTQuery,
        IN VARIANT varRUser,
        IN VARIANT varRPwd,
        OUT HRESULT *phRes = NULL
        );

    HRESULT
    DeleteTrigger(
        IN VARIANT varTName,
        OUT DWORD *dwTrigId
        );

    HRESULT
    QueryTrigger(
        IN VARIANT  varScheduledTaskName,
        OUT CHString &szRunAsUser
        );

    HRESULT
    ValidateParams(
        IN VARIANT varTrigName,
        IN VARIANT varTrigAction,
        IN VARIANT varTrigQuery,
        IN VARIANT varRUser
        );

    HRESULT
    SetUserContext(
        IN VARIANT varRUser,
        IN VARIANT varRPwd,
        IN VARIANT varTAction,
        IN CHString &szscheduler
        );

    HRESULT
    DeleteTaskScheduler(
        IN CHString strTScheduler
        );

    HRESULT
    CTriggerProvider::GetTaskScheduler( 
        OUT ITaskScheduler   **ppITaskScheduler
        );

    VOID
    GetUniqueTScheduler(
        OUT CHString& szScheduler,
        IN DWORD dwTrigID,
        IN VARIANT varTrigName
        );

// [ implementation of ] interfaces members
public:

    // IUnknown members
    STDMETHODIMP_(ULONG)
    AddRef(
        VOID
        );
    STDMETHODIMP_(ULONG)
    Release(
        VOID
        );
    STDMETHODIMP
    QueryInterface(
        IN REFIID riid,
        OUT LPVOID* ppv
        );

    // IDispatch interface
    STDMETHOD
    ( GetTypeInfoCount )(
        OUT THIS_ UINT FAR* pctinfo
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    STDMETHOD
    ( GetTypeInfo )(
        IN THIS_ UINT itinfo,
        IN LCID lcid,
        OUT ITypeInfo FAR* FAR* pptinfo
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    STDMETHOD
    ( GetIDsOfNames )(
        IN THIS_ REFIID riid,
        IN OLECHAR FAR* FAR* rgszNames,
        IN UINT cNames,
        IN LCID lcid,
        OUT DISPID FAR* rgdispid
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    STDMETHOD
    ( Invoke )(
        IN THIS_ DISPID dispidMember,
        IN REFIID riid,
        IN LCID lcid,
        IN WORD wFlags,
        IN DISPPARAMS FAR* pdispparams,
        OUT VARIANT FAR* pvarResult,
        OUT EXCEPINFO FAR* pexcepinfo,
        OUT UINT FAR* puArgErr
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    // ****
    // IWbemProviderInit members

    HRESULT
    STDMETHODCALLTYPE Initialize(
        IN LPWSTR pszUser,
        IN LONG lFlags,
        IN LPWSTR pszNamespace,
        IN LPWSTR pszLocale,
        IN IWbemServices *pNamespace,
        IN IWbemContext *pCtx,
        IN IWbemProviderInitSink *pInitSink
        );


    // IWbemServices members
    HRESULT
    STDMETHODCALLTYPE OpenNamespace(
        IN const BSTR Namespace,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE CancelAsyncCall(
        IN IWbemObjectSink __RPC_FAR *pSink
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE QueryObjectSink(
        IN long lFlags,
        OUT IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE GetObject(
        IN const BSTR ObjectPath,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE GetObjectAsync(
        IN const BSTR ObjectPath,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT
    STDMETHODCALLTYPE PutClass(
        IN IWbemClassObject __RPC_FAR *pObject,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE PutClassAsync(
        IN IWbemClassObject __RPC_FAR *pObject,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE DeleteClass(
        IN const BSTR Class,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE DeleteClassAsync(
        IN const BSTR Class,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE CreateClassEnum(
        IN const BSTR Superclass,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE CreateClassEnumAsync(
        IN const BSTR Superclass,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE PutInstance(
        IN IWbemClassObject __RPC_FAR *pInst,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE PutInstanceAsync(
        IN IWbemClassObject __RPC_FAR *pInst,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE DeleteInstance(
        IN const BSTR ObjectPath,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE DeleteInstanceAsync(
        IN const BSTR ObjectPath,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE CreateInstanceEnum(
        IN const BSTR Class,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE CreateInstanceEnumAsync(
        IN const BSTR Class,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    }

    HRESULT
    STDMETHODCALLTYPE ExecQuery(
        IN const BSTR QueryLanguage,
        IN const BSTR Query,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE ExecQueryAsync(
        IN const BSTR QueryLanguage,
        IN const BSTR Query,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE ExecNotificationQuery(
        IN const BSTR QueryLanguage,
        IN const BSTR Query,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        OUT IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE ExecNotificationQueryAsync(
        IN const BSTR QueryLanguage,
        IN const BSTR Query,
        IN long lFlags,
        IN IWbemContext __RPC_FAR *pCtx,
        IN IWbemObjectSink __RPC_FAR *pResponseHandler
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    };

    HRESULT
    STDMETHODCALLTYPE ExecMethod(
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemClassObject* pInParams,
        OUT IWbemClassObject** ppOutParams,
        OUT IWbemCallResult** ppCallResult
        )
    {
        // not implemented at this class level ... handled by base class ( WMI base class )
        return WBEM_E_NOT_SUPPORTED;
    }

    // *** one of method implemented by this provider under IWbemServices interface ***
    HRESULT
    STDMETHODCALLTYPE ExecMethodAsync(
        IN const BSTR strObjectPath,
        IN const BSTR strMethodName,
        IN long lFlags,
        IN IWbemContext* pCtx,
        IN IWbemClassObject* pInParams,
        IN IWbemObjectSink* pResponseHandler
        );

    // ****
    // IWbemEventConsumerProvider members
    // ( this routine allows you to map the one physical consumer to potentially
    //   multiple logical consumers. )
    STDMETHOD
    ( FindConsumer )(
        IN IWbemClassObject* pLogicalConsumer,
        OUT IWbemUnboundObjectSink** ppConsumer
        );
};

#endif      // __TRIGGER_PROVIDER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\admin\cmdline\cmdevtgprov\triggerprovider.cpp ===
/*++
Copyright (c) Microsoft Corporation

Module Name:
    TRIGGERPROVIDER.CPP

Abstract:
    Contains CTriggerProvider implementation.

Author:
    Vasundhara .G

Revision History:
    Vasundhara .G 9-oct-2k : Created It.
--*/

#include "pch.h"
#include "General.h"
#include "EventConsumerProvider.h"
#include "TriggerConsumer.h"
#include "TriggerProvider.h"
#include "resource.h"

extern HMODULE g_hModule;

// holds the value of the next trigger id
#pragma  data_seg(".ProviderSeg")
  _declspec(dllexport) DWORD m_dwNextTriggerID = 0;
#pragma data_seg()


CTriggerProvider::CTriggerProvider(
    )
/*++
Routine Description:
    Constructor for CTriggerProvider class for  initialization.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // update the no. of provider instances count
    InterlockedIncrement( ( LPLONG ) &g_dwInstances );

    // initialize the reference count variable
    m_dwCount = 0;

    // initializations
    m_pContext = NULL;
    m_pServices = NULL;
    m_pwszLocale = NULL;
    m_dwNextTriggerID = 0;
    m_MaxTriggers = FALSE;
}

CTriggerProvider::~CTriggerProvider(
    )
/*++
Routine Description:
    Destructor for CTriggerProvider class.

Arguments:
    None.

Return Value:
    None.
--*/
{
    // release the services / namespace interface ( if exist )
    SAFERELEASE( m_pServices );

    // release the context interface ( if exist )
    SAFERELEASE( m_pContext );

    // if memory is allocated for storing locale information, free it
    if ( NULL != m_pwszLocale )
    {
        delete [] m_pwszLocale;
    }
    // update the no. of provider instances count
    InterlockedDecrement( ( LPLONG ) &g_dwInstances );
    
}

STDMETHODIMP
CTriggerProvider::QueryInterface(
    IN REFIID riid,
    OUT LPVOID* ppv
    )
/*++
Routine Description:
    Returns a pointer to a specified interface on an object
    to which a client currently holds an interface pointer.

Arguments:
    [IN] riid : Identifier of the interface being requested.
    [OUT] ppv : Address of pointer variable that receives the
                interface pointer requested in riid. Upon
                successful return, *ppvObject contains the
                requested interface  pointer to the object.

Return Value:
    NOERROR if the interface is supported.
    E_NOINTERFACE if not.
--*/
{
    // initialy set to NULL 
    *ppv = NULL;

    // check whether interface requested is one we have
    if ( IID_IUnknown == riid )
    {
        // need IUnknown interface
        *ppv = this;
    }
    else if ( IID_IWbemEventConsumerProvider == riid )
    {
        // need IEventConsumerProvider interface
        *ppv = static_cast<IWbemEventConsumerProvider*>( this );
    }
    else if ( IID_IWbemServices == riid )
    {
        // need IWbemServices interface
        *ppv = static_cast<IWbemServices*>( this );
    }
    else if ( IID_IWbemProviderInit == riid )
    {
        // need IWbemProviderInit
        *ppv = static_cast<IWbemProviderInit*>( this );
    }
    else
    {
        // request interface is not available
        return E_NOINTERFACE;
    }

    // update the reference count
    reinterpret_cast<IUnknown*>( *ppv )->AddRef();
    return NOERROR;     // inform success
}

STDMETHODIMP_(ULONG)
CTriggerProvider::AddRef(
    void
    )
/*++
Routine Description:
    The AddRef method increments the reference count for
    an interface on an object. It should be called for every
    new copy of a pointer to an interface on a given object. 

Arguments:
    none.

Return Value:
    Returns the value of the new reference count.
--*/
{
    // increment the reference count ... thread safe
    return InterlockedIncrement( ( LPLONG ) &m_dwCount );
}

STDMETHODIMP_(ULONG)
CTriggerProvider::Release(
    void
    )
/*++
Routine Description:
    The Release method decreases the reference count of  the object by 1.

Arguments:
    none.

Return Value:
    Returns the new reference count.
--*/
{
    // decrement the reference count ( thread safe ) and check whether
    // there are some more references or not ... based on the result value
    DWORD dwCount = 0;
    dwCount = InterlockedDecrement( ( LPLONG ) &m_dwCount );
    if ( 0 == dwCount )
    {
        // free the current factory instance
        delete this;
    }
    
    // return the no. of instances references left
    return dwCount;
}

STDMETHODIMP
CTriggerProvider::Initialize(
    IN LPWSTR wszUser,
    IN LONG lFlags,
    IN LPWSTR wszNamespace,
    IN LPWSTR wszLocale,
    IN IWbemServices* pNamespace,
    IN IWbemContext* pCtx,
    OUT IWbemProviderInitSink* pInitSink )
/*++
Routine Description:
    This is the implemention of IWbemProviderInit. The 
    method is need to initialize with CIMOM.

Arguments:
    [IN] wszUser      : pointer to user name.
    [IN] lFlags       : Reserved.
    [IN] wszNamespace : contains the namespace of WMI.
    [IN] wszLocale    : Locale Name.
    [IN] pNamespace   : pointer to IWbemServices.
    [IN] pCtx         : IwbemContext pointer associated for  initialization.
    [OUT] pInitSink   : a pointer to IWbemProviderInitSink for
                        reporting the initialization status.

Return Value:
    returns HRESULT value.
--*/
{
    HRESULT                   hRes = 0;
    IEnumWbemClassObject      *pINTEConsumer = NULL;
    DWORD                     dwReturned = 0;
    DWORD                     dwTrigId = 0;
    VARIANT                   varTrigId;
    DWORD                     i = 0;

    if( ( NULL == pNamespace ) || ( NULL == pInitSink ) )
    {
        // return failure
        return WBEM_E_FAILED;
    }
    try
    {
        // save the namespace interface ... will be useful at later stages
        m_pServices = pNamespace;
        m_pServices->AddRef();      // update the reference

        // also save the context interface ... will be userful at later stages ( if available )
        if ( NULL != pCtx )
        {
            m_pContext = pCtx;
            m_pContext->AddRef();
        }

        // save the locale information ( if exist )
        if ( NULL != wszLocale )
        {
            m_pwszLocale = new WCHAR [ StringLength( wszLocale, 0 ) + 1 ];
            if ( NULL == m_pwszLocale )
            {
                // update the sink accordingly
                pInitSink->SetStatus( WBEM_E_FAILED, 0 );

                // return failure
                return WBEM_E_OUT_OF_MEMORY;
            }
        }

        // Enumerate TriggerEventConsumer to get the Maximum trigger Id which can be later
        // used to generate unique trigger id value.

        hRes = m_pServices ->CreateInstanceEnum(
                            _bstr_t(CONSUMER_CLASS),
                            WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                            m_pContext, &pINTEConsumer);
            
        if (SUCCEEDED( hRes ) )
        {
            dwReturned = 1;

            // Final Next will return with ulReturned = 0
            while ( 0 != dwReturned )
            {
                IWbemClassObject *pINTCons[5];

                // Enumerate through the resultset.
                hRes = pINTEConsumer->Next( WBEM_INFINITE,
                                        5,              // return just one Logfile
                                        pINTCons,       // pointer to Logfile
                                        &dwReturned );  // number obtained: one or zero

                if ( SUCCEEDED( hRes ) )
                {
                    // Get the trigger id value
                    for( i = 0; i < dwReturned; i++ )
                    {
                        VariantInit( &varTrigId );
                        hRes = pINTCons[i]->Get( TRIGGER_ID, 0, &varTrigId, 0, NULL );
                        SAFERELEASE( pINTCons[i] );
                        
                        if ( SUCCEEDED( hRes ) )
                        {
                            dwTrigId = ( DWORD )varTrigId.lVal;
                            if( dwTrigId > m_dwNextTriggerID )
                            {
                                m_dwNextTriggerID = dwTrigId;
                            }
                        }
                        else
                        {
                            VariantClear( &varTrigId );
                            break;
                        }
                        VariantClear( &varTrigId );
                    }
                }
                else
                {
                    break;
                }
            }  //while
            // got triggerId so set it
            SAFERELEASE( pINTEConsumer );
        }
        //Let CIMOM know your initialized
        //===============================
        if ( SUCCEEDED( hRes ) )
        {
            if( m_dwNextTriggerID >= MAX_TRIGGEID_VALUE )
            {
                hRes = WBEM_E_FAILED;
            }
            else
            {
                m_dwNextTriggerID = m_dwNextTriggerID + 1;
                hRes = pInitSink->SetStatus( WBEM_S_INITIALIZED, 0 );
            }
        }
        else
        {
            hRes = pInitSink->SetStatus( WBEM_E_FAILED, 0);
        }
    }
    catch(_com_error& e)
    {
        hRes = pInitSink->SetStatus( WBEM_E_FAILED, 0);
        return e.Error();
    }
    return hRes;
}

STDMETHODIMP
CTriggerProvider::ExecMethodAsync(
    IN const BSTR bstrObjectPath,
    IN const BSTR bstrMethodName,
    IN long lFlags,
    IN IWbemContext* pICtx,
    IN IWbemClassObject* pIInParams,
    OUT IWbemObjectSink* pIResultSink
    )
/*++
Routine Description:
    This is the Async function implementation.           
    The methods supported is named CreateETrigger and  DeleteETrigger.

Arguments:
    [IN] bstrObjectPath : path of the object for which the method is executed.
    [IN] bstrMethodName : Name of the method for the object.
    [IN] lFlags         : WBEM_FLAG_SEND_STATUS.
    [IN] pICtx          : a pointer to IWbemContext. 
    [IN] pIInParams     : this points to an IWbemClassObject object
                          that contains the properties acting as 
                          inbound parameters for method execution.
    [OUT] pIResultSink  : The object sink receives the result of  the method call. 

Return Value:
    returns HRESULT.
--*/
{
    HRESULT                 hRes = 0;
    HRESULT                 hRes1 = NO_ERROR;
    IWbemClassObject        *pIClass = NULL;
    IWbemClassObject        *pIOutClass = NULL;
    IWbemClassObject        *pIOutParams = NULL;
    VARIANT                 varTriggerName, varTriggerAction, varTriggerQuery,
                            varTriggerDesc, varTemp, varRUser, varRPwd, varScheduledTaskName;
    DWORD                   dwTrigId = 0;
    LPTSTR                  lpResStr = NULL; 
    try
    {
        //set out parameters
        hRes = m_pServices->GetObject( _bstr_t( CONSUMER_CLASS ), 0, pICtx, &pIClass, NULL );
        if( FAILED( hRes ) )
        {
            pIResultSink->SetStatus( 0, hRes, NULL, NULL );
            return hRes;
        }
     
        // This method returns values, and so create an instance of the
        // output argument class.

        hRes = pIClass->GetMethod( bstrMethodName, 0, NULL , &pIOutClass );
        SAFERELEASE( pIClass );
        if( FAILED( hRes ) )
        {
             pIResultSink->SetStatus( 0, hRes, NULL, NULL );
             return hRes;
        }

        hRes  = pIOutClass->SpawnInstance( 0, &pIOutParams );
        SAFERELEASE( pIOutClass );
        if( FAILED( hRes ) )
        {
             pIResultSink->SetStatus( 0, hRes, NULL, NULL );
             return hRes;
        }
        
        VariantInit( &varTriggerName );
        //Check the method name
        if( ( StringCompare( bstrMethodName, CREATE_METHOD_NAME, TRUE, 0 ) == 0 ) ||
            ( StringCompare( bstrMethodName, CREATE_METHOD_NAME_EX, TRUE, 0 ) == 0 ) )
        {
            //  i