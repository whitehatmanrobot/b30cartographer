f (pFileApplns == NULL)
    {
    
        // Not found, create new CFileApplnList object
    
        pFileApplns = new CFileApplnList;
    
        if (!pFileApplns)
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        // Init CFileApplnList object

        hr = pFileApplns->Init(pszFilename);

        if (FAILED(hr))
        {
            delete pFileApplns;
            goto LExit;
        }

        // Add FileApplns object to hash table
    
        if (!CHashTable::AddElem(pFileApplns))
        {
            delete pFileApplns;
            hr = E_FAIL;
            goto LExit;
        }
     }

     // Add the application to the list associated with this file
     hr = pFileApplns->AddApplication(pAppln);

     // Keep this file mapping in the application
     // The application will remove itself from this list
     // when it is uninited.
     
     pAppln->AddFileApplnEntry(pFileApplns);
     
LExit:
    UnLock();
    return hr;
}

/*===================================================================
CFileApplicationMap::ShutdownApplications

Shutdown the applications associated with a file

Parameters:
    pszFilename     pointer to string containing name of the file
    
Returns:
    TRUE if an application was shutdown, FALSE otherwise
===================================================================*/	
BOOL CFileApplicationMap::ShutdownApplications(const TCHAR *pszFilename)
{
    DBG_ASSERT(pszFilename);

    BOOL fResult = TRUE;
    
    Lock();
    
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));

    if (pFileApplns)
    {
        // Get a list of applications we need to shutdown
        
        CPtrArray rgpapplnRestartList;
        pFileApplns->GetShutdownApplications(&rgpapplnRestartList);


        // Now that we have the list of applications we need to shut down
        // we can release the lock
        
        UnLock();

        for (int i = 0; i < rgpapplnRestartList.Count(); i++)
        {
            CAppln *pAppln = (CAppln *)rgpapplnRestartList[i];
            pAppln->Restart();
            pAppln->Release();
        }

		// Flush the script cache if any applications were restarted
		if (rgpapplnRestartList.Count())
			g_ScriptManager.FlushAll();
    }
    else
    {
        // No applications to shut down, release the lock
        UnLock();
        fResult = FALSE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\exec.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executor

Owner: DGottner

File: executor.cpp

This file contains the executor, whose job is to co-ordinate the
execution of Denali scripts.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "exec.h"
#include "response.h"
#include "request.h"
#include "perfdata.h"
#include "memchk.h"
#include <iismsg.h>


// Local declarations
HRESULT ExecuteGlobal(CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ExecuteRequest(CTemplate *pTemplate, CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ReInitIntrinsics(CHitObj *pHitObj, const CIntrinsicObjects &intrinsics,
                            ActiveEngineInfo *pEngineInfo, BOOL fPostGlobal);
HRESULT AllocAndLoadEngines(CHitObj *pHitObj, CTemplate *pTemplate, ActiveEngineInfo *pEngineInfo,
                            CScriptingNamespace *pScriptingNamespace, BOOL fGlobalAsa);
VOID DeAllocAndFreeEngines(ActiveEngineInfo *pEngineInfo, CAppln *pAppln);
CScriptEngine *GetScriptEngine(int iScriptEngine, void *pvData);
HRESULT CallScriptFunctionOfEngine(ActiveEngineInfo &engineInfo, short iScriptBlock, wchar_t *strFunction, CASPObjectContext  *pASPObjectContext = NULL);
HRESULT CallScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction);
HRESULT TestScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction);

/*===================================================================
Execute

Execute a request:
    First determine if Global needs to be called
    then invoke actual requested template

Parameters:
    pTemplate       - pointer to loaded template (could be NULL)
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    fChild          - flag: TRUE when child request (Server.Execute())

Returns:
    S_OK on success
===================================================================*/
HRESULT Execute
(
CTemplate *pTemplate,
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
BOOL fChild
)
    {
    HRESULT hr = S_OK;
    ActiveEngineInfo engineInfo;
    BOOL fRanGlobal = FALSE;

    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

	// Check for valid Session codepage.  We do it here, rather than in CSession::Init in
	// order to avoid generic "New Session Failed" message.
	if (pHitObj->GetCodePage() != CP_ACP && !IsValidCodePage(pHitObj->GetCodePage()))
		{
		HandleErrorMissingFilename(IDE_BAD_CODEPAGE_IN_MB, pHitObj);
		return E_FAIL;
		}

    // Give the engine list to the hitobject
    pHitObj->SetActiveEngineInfo(&engineInfo);

    /*
     * If there is a Global.ASA, call it
     */
    if (pHitObj->GlobalAspPath() && !fChild)
        {
        // Clear out the engine info
        engineInfo.cEngines = 0;
        engineInfo.cActiveEngines = 0;
        engineInfo.rgActiveEngines = NULL;

        // Init the intrinsics
        hr = ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, /* fPostGlobal*/ FALSE);
        if (FAILED(hr))
            return(hr);

        hr = ExecuteGlobal(pHitObj, intrinsics, &engineInfo);

        if (intrinsics.PResponse() && intrinsics.PResponse()->FResponseAborted())
            {
            hr = S_OK;
            goto LExit;
            }

        if (E_SOURCE_FILE_IS_EMPTY == hr)
            // bug 977: silently ignore empty global.asa file
            hr = S_OK;
        else if (FAILED(hr))
            {
            // Bug 481: If global.asa fails due to Response.End (or Response.Redirect),
            //      then halt execution of the calling script.  If the
            //      script fails due to Response.End, then return OK status
            //
            if (hr == DISP_E_EXCEPTION)
                hr = S_OK;

            // In any case, blow out of here
            goto LExit;
            }

        // Running Global.asa added the scripting namespace to the hitobj.  This will cause us problems
        // later, remove it.
        pHitObj->RemoveScriptingNamespace();

        fRanGlobal = TRUE;
        }

    /*
     * If this is not a browser request, then we are done
     * For non-browser requests, we do want to run Global.asa (if any), but there is no real template to run.
     */
    if (!pHitObj->FIsBrowserRequest())
        {
        hr = S_OK;
        goto LExit;
        }

    // Clear out (or re-clear out) the engine info
    engineInfo.cEngines = 0;
    engineInfo.cActiveEngines = 0;
    engineInfo.rgActiveEngines = NULL;

    // Init or Re-Init the intrinsics
    ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, fRanGlobal || fChild);

    if (!fChild)
        {
        // For non-child requests hand new Template to Response object
        // (for child requests already done)
        intrinsics.PResponse()->ReInitTemplate(pTemplate, pHitObj->PSzNewSessionCookie());
        }
    else
        {
        // For child requests hand new engine info to the response object
        intrinsics.PResponse()->SwapScriptEngineInfo(&engineInfo);
        }

    // Run the main template
    if (pTemplate->FScriptless() && !pHitObj->PAppln()->FDebuggable())
        {
        // special case scriptless pages
        hr = intrinsics.PResponse()->WriteBlock(0);
        }
    else
        {
        hr = ExecuteRequest(pTemplate, pHitObj, intrinsics, &engineInfo);
        }

LExit:
	intrinsics.PResponse()->SwapScriptEngineInfo(NULL);
	pHitObj->SetActiveEngineInfo(NULL);
    return hr;
    }

/*===================================================================
ExecRequest

Execute a request for an actual template (not Global.asa)

execute a request by
    - getting the script name
    - loading the script into memory
    - interpreting the opcodes

Parameters:
    pTemplate       - pointer to loaded template
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteRequest(CTemplate                *pTemplate,
                       CHitObj                  *pHitObj,
                       const CIntrinsicObjects  &intrinsics,
                       ActiveEngineInfo         *pEngineInfo)
{
    HRESULT hr = S_OK;
    BOOL    fAborted = FALSE;
    BOOLB   fDebuggerNotifiedOnStart = FALSE;
    BOOL    fServiceDomainEnterred = FALSE;
    CASPObjectContext   *pASPObjectContext = NULL;
    CASPObjectContext   *pPoppedASPObjectContext = NULL;

#ifndef PERF_DISABLE
    BOOLB fPerfTransPending = FALSE;
#endif

    // The template must be valid
    Assert(pTemplate);

    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

    // This function should never be called on a non-browser request
    Assert(pHitObj->FIsBrowserRequest());

    // Remember template's type library wrapper with the HitObj
    if (pTemplate->PTypeLibWrapper())
        pHitObj->SetTypeLibWrapper(pTemplate->PTypeLibWrapper());

    if (pTemplate->FTransacted()) {

#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSTOTAL();
        g_PerfData.Incr_TRANSPENDING();
        fPerfTransPending = TRUE;
#endif
        pASPObjectContext = new CASPObjectContext();

        if (!pASPObjectContext) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        pPoppedASPObjectContext = pHitObj->SetASPObjectContext(pASPObjectContext);
    }

    if (pTemplate->PServicesConfig()) {
        hr = CoEnterServiceDomain(pTemplate->PServicesConfig());
        if (FAILED(hr)) {
            goto LExit;
        }
        fServiceDomainEnterred = TRUE;
    }

	// load script engines
	hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */FALSE);
	if (FAILED(hr)) {
	    pHitObj->SetCompilationFailed();
		goto LExit;
    }

    // If debugging, notify debugger ONPAGESTART
    // BUG 138773: Notify debugger AFTER scripts load
    //    (script must be in running state when AttachTo() is called because debugger may want a code context)
    //
    if (pHitObj->PAppln()->FDebuggable()) {
		pTemplate->AttachTo(pHitObj->PAppln());
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
    }
		
	// bug 1009: if no script engines, do not attempt to do anything
	if(0 == pTemplate->CountScriptEngines())
		goto LExit;

    // run the script by calling primary script engine's global code
    hr = CallScriptFunctionOfEngine(*pEngineInfo,   // engine-info
                                    0,              // primary script engine
                                    NULL,           // call the engine's global code
                                    pHitObj->PASPObjectContext());

    if (fServiceDomainEnterred) {
        fServiceDomainEnterred = FALSE;
        CoLeaveServiceDomain(static_cast<ITransactionStatus *>(pHitObj->PASPObjectContext()));
    }


    if (pTemplate->FTransacted()) {
        fAborted = pHitObj->PASPObjectContext()->FAborted();
    }

    if (FAILED(hr)) {
        /*
         * The cryptically named CONTEXT_E_OLDREF error in this case means that
         * we are trying to run a transacted web page, but DTC isnt running.
         * CONTEXT_E_TMNOTAVAILABLE means the same thing.  God knows why
         */
        if (hr == CONTEXT_E_OLDREF || hr == CONTEXT_E_TMNOTAVAILABLE) {
            HandleErrorMissingFilename(IDE_EXECUTOR_DTC_NOT_RUNNING, pHitObj);
        }

        // Regardless of the error, exit
        goto LExit;
    }

    /*
     * If this is a transacted web page, then run either the OnTransactionCommit
     * or OnTransactionAbort method in the script, if any.
     *
     * If the script writer did an explicit SetAbort, or a component run by the script
     * did a SetAbort, then we run OnTransactionAbort, otherwise run OnTransactionCommit
     */
    if (pTemplate->FTransacted()) {

#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSPERSEC();
#endif

        if (fAborted) {

            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionAbort");

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSABORTED();
#endif
        }
        else {
            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionCommit");

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSCOMMIT();
#endif
        }

        // Ignore UNKNOWNNAME -- this means the author didnt write the method, which is fine
        if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;

        if (FAILED(hr))
            goto LExit;
    }

LExit:

    //
    // Return the engine(s) to cache. Be sure to do this before leaving the services domain
    // after we have deallocated the freed the engines or else the context will leak Variant objects
    // as the reset script code will not make it to the various variant allocated during the running of the script.
    // 
    DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln());

    if (fServiceDomainEnterred) {
        CoLeaveServiceDomain(NULL);
    }

#ifndef PERF_DISABLE
    if (fPerfTransPending)
        g_PerfData.Decr_TRANSPENDING();
#endif

    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // If debugging, notify debugger ONPAGEDONE
    if (fDebuggerNotifiedOnStart) {
        Assert(pHitObj->PAppln()->FDebuggable());
        pTemplate->NotifyDebuggerOnPageEvent(FALSE);
    }

    if (pPoppedASPObjectContext)
        pHitObj->SetASPObjectContext(pPoppedASPObjectContext);

    if (pASPObjectContext)
        pASPObjectContext->Release();

    return hr;
}

/*===================================================================
ExecuteGlobal

UNDONE: handle script engine the same manner as mainline script engines
        with respect to debugging.

Execute code in Global.ASA as part of application or session start or end.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info
    pfDeleteSession - true if global.asa failed, and therefore the caller should

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteGlobal
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo
)
    {
    HRESULT hr = S_OK;
    CTemplate *pTemplate = NULL;
    WORD iEng;
    BOOLB fDebuggerNotifiedOnStart = FALSE;

    BOOL fUnHideRequestAndResponse = FALSE;

    BOOL fOnStartAppln = FALSE;
    BOOL fOnEndAppln = FALSE;
    BOOL fOnEndSession = FALSE;
    BOOL fGlobalAsaInCache;
    BOOL fApplnStarted = FALSE;
    BOOL fServiceDomainEnterred = FALSE;
    CASPObjectContext   *pASPObjectContext = NULL;
    CASPObjectContext   *pPoppedASPObjectContext = NULL;

    UINT    savedCodePage = CP_ACP;
    UINT    loadedCodePage = CP_ACP;

    // The hit obj must be there, be valid, & have a global.asa name
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pHitObj->GlobalAspPath() != NULL && *(pHitObj->GlobalAspPath()) != '\0');

    // Other arg's must be right
    Assert(pEngineInfo != NULL);

    // save the current code page in case LoadTemplate changes it...

    savedCodePage = pHitObj->GetCodePage();

    // Load the script - cache will AddRef
    // bug 1051: load template before possibly removing response object (in switch block, below),
    // so error reporting to browser will work
    hr = LoadTemplate(pHitObj->GlobalAspPath(), pHitObj, &pTemplate, intrinsics, /* fGlobalAsa */ TRUE, &fGlobalAsaInCache);
    if (FAILED(hr))
        goto LExit;

    // get the codepage again so that we can later compare to see if the initial code
    // page should be reverted

    loadedCodePage = pHitObj->GetCodePage();

    Assert(pTemplate != NULL);

    // Remember GLOBAL.ASA's type library wrapper with the application
    // on the first request

    if (pHitObj->FStartApplication() && pTemplate->PTypeLibWrapper())
        {
        pHitObj->PAppln()->SetGlobTypeLibWrapper(pTemplate->PTypeLibWrapper());
        }

    if (pTemplate->FTransacted()) {

        pASPObjectContext = new CASPObjectContext();

        if (!pASPObjectContext) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        pPoppedASPObjectContext = pHitObj->SetASPObjectContext(pASPObjectContext);
    }

    if (pTemplate->PServicesConfig()) {
        hr = CoEnterServiceDomain(pTemplate->PServicesConfig());
        if (FAILED(hr)) {
            goto LExit;
        }
        fServiceDomainEnterred = TRUE;
    }

    Assert(pHitObj->FIsValidRequestType());

    // Figure out which events to trigger
    if (pHitObj->FIsBrowserRequest())
        {
        fOnStartAppln = pHitObj->FStartApplication();

        if (fOnStartAppln)
            {
            // Hide response and request intrinsics from namespace
            pHitObj->HideRequestAndResponseIntrinsics();

            // Flag that intrinsics need to be un-hidden back in.
            fUnHideRequestAndResponse = TRUE;
            }
        }
    else if (pHitObj->FIsSessionCleanupRequest())
        {
        fOnEndSession = TRUE;
        }
    else if (pHitObj->FIsApplnCleanupRequest())
        {
        fOnEndAppln = TRUE;
        }

    // If debugging, notify debugger ONPAGESTART
    if (pHitObj->PAppln()->FDebuggable())
        {
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
        }

    hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */TRUE);
    if (FAILED(hr))
        goto LExit;

    // BUG 93991: Defer registration of new document with debugger until after script engines have
    //            been loaded
    //
    if (!fGlobalAsaInCache && pHitObj->PAppln()->FDebuggable())
        pTemplate->AttachTo(pHitObj->PAppln());

    // bug 975: if no script engines, do not attempt to call event functions
    if(0 == pTemplate->CountScriptEngines())
        goto LExit;

    /*
     * Call event functions as required
     * bug 459: event functions may be in any script engine
     */

    // First run Application_OnStart
    if (fOnStartAppln)
        {
        pHitObj->SetEventState(eEventAppOnStart);

        hr = CallScriptFunction(*pEngineInfo, L"Application_OnStart");

        if (SUCCEEDED(hr) || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND ||
            intrinsics.PResponse()->FResponseAborted())
            {
            if (fUnHideRequestAndResponse)
                {
                pHitObj->UnHideRequestAndResponseIntrinsics();
                fUnHideRequestAndResponse = FALSE;
                }

            fApplnStarted = TRUE;
            hr = S_OK;
            }
        else
            {
            goto LExit;
            }
        }

    if (pHitObj->FStartSession())
        {
    // If application on start was run, add Response and Request names to script engines
        if (fOnStartAppln)
            {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                {
                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_RESPONSE, FALSE)))
                    goto LExit;

                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_REQUEST, FALSE)))
                    goto LExit;
                }
            }

        pHitObj->SetEventState(eEventSesOnStart);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnStart");

        if (FAILED(hr) && hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND &&
            !intrinsics.PResponse()->FResponseAborted())
            {
            // Mark session as on-start-failed - to be deleted soon
            pHitObj->SessionOnStartFailed();
            }
        else
            {
            if (SUCCEEDED(hr))
                {
                // Mark as on-start-invoked -- need to wait for timeout
                pHitObj->SessionOnStartInvoked();
                }

            // Check if Session_OnEnd Present
            if (SUCCEEDED(TestScriptFunction(*pEngineInfo, L"Session_OnEnd")))
                {
                // Mark as on-end-present -- need to execute OnEnd later
                pHitObj->SessionOnEndPresent();
                }

            hr = S_OK;
            }

        goto LExit;
        }

    BOOL fImpersonationSet = FALSE;
    BOOL fExecuteOnEnd = TRUE;

    // no need to even attempt to run Session_OnEnd if it isn't present

    if (fOnEndSession && FAILED(TestScriptFunction(*pEngineInfo, L"Session_OnEnd")))
        fOnEndSession = FALSE;

    // same for application_onend

    if (fOnEndAppln && FAILED(TestScriptFunction(*pEngineInfo, L"Application_OnEnd")))
        fOnEndAppln = FALSE;

    if (fOnEndSession || fOnEndAppln) {

        // Is the OnEnd routine supposed to be executed as the Anonymous user?

        if (pHitObj->PAppln()->QueryAppConfig()->fRunOnEndAsAnon()) {

            // if so, but we don't have a valid token, then we can't

            if (pHitObj->PAppln()->QueryAppConfig()->AnonToken() == INVALID_HANDLE_VALUE) {

                MSG_Error(MSG_APPL_ERROR_GETTING_ANON_TOKEN,
                          pHitObj->PAppln()->GetMetabaseKey());

                fExecuteOnEnd = FALSE;
            }

            else {

                fImpersonationSet = ImpersonateLoggedOnUser(pHitObj->PAppln()->QueryAppConfig()->AnonToken());

                if (fImpersonationSet == FALSE) {

                    MSG_Error(MSG_APPL_ERROR_IMPERSONATING_ANON_USER,
                              pHitObj->PAppln()->GetMetabaseKey());

                    fExecuteOnEnd = FALSE;
                }
                else {

                    fImpersonationSet = TRUE;
                }
            }
        }
    }

    if (fOnEndSession && fExecuteOnEnd) {

        pHitObj->SetEventState(eEventSesOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnEnd");

        // We are failing silently here, since there is no corrective action we could take
   }


    if (fOnEndAppln && fExecuteOnEnd) {
        pHitObj->SetEventState(eEventAppOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Application_OnEnd");
        // We are failing silently here, since there is no corrective action we could take
    }

    // need to undo impersonation if it was set when executing the OnEnd
    // routines.  Note that a RevertToSelf is the right thing to do here
    // as there should not have been any impersonation on the thread in
    // the OnEnd case.

    if (fImpersonationSet)
        RevertToSelf();

LExit:

    // restore the codepage in the hit object if it changed after loading
    // and the session's codepage wasn't explicitly set.

    if ((loadedCodePage != savedCodePage)
        && (!pHitObj->FHasSession() || !pHitObj->PSession()->FCodePageSet()))
        pHitObj->SetCodePage(savedCodePage);

    if (fUnHideRequestAndResponse)
        {
        pHitObj->UnHideRequestAndResponseIntrinsics();
        }

    if (FAILED(hr) && (hr != E_SOURCE_FILE_IS_EMPTY) && pHitObj->FStartApplication() && !fApplnStarted)
        {
        pHitObj->ApplnOnStartFailed();
        }

    pHitObj->SetEventState(eEventNone);

    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // Release the template
    if (pTemplate)
        {

        // bug 975: if no script engines, do not do this
        if(pTemplate->CountScriptEngines() > 0)
            // Return the engine(s) to cache
            DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln());

        // If debugging, notify debugger ONPAGEDONE
        if (fDebuggerNotifiedOnStart)
            {
            Assert(pHitObj->PAppln()->FDebuggable());
            pTemplate->NotifyDebuggerOnPageEvent(FALSE);
            }

        pTemplate->Release();
        }

    if (fServiceDomainEnterred)
        CoLeaveServiceDomain(NULL);

    // It is OK if the event function was not found in global.asa
    if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
        {
        hr = S_OK;
        }

    if (pPoppedASPObjectContext)
        pHitObj->SetASPObjectContext(pPoppedASPObjectContext);

    if (pASPObjectContext)
        pASPObjectContext->Release();

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Prepare

Prepare intrinsics for the request processing

Parameters:
    pSession        session holding the instrinsics (can be NULL)

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::Prepare
(
CSession *pSession
)
    {
    HRESULT hr = S_OK;

    if (pSession)
        {
        // get request, response, server from session

        if (SUCCEEDED(hr))
            {
            m_pRequest = pSession->PRequest();
            if (m_pRequest)
                m_pRequest->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = pSession->PResponse();
            if (m_pResponse)
                m_pResponse->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = pSession->PServer();
            if (m_pServer)
                m_pServer->AddRef();
            else
                hr = E_FAIL;
            }
        }
    else
        {
        // create new request, response, server

        if (SUCCEEDED(hr))
            {
            m_pRequest = new CRequest;
            if (!m_pRequest)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = new CResponse;
            if (!m_pResponse)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = new CServer;
            if (!m_pServer)
                hr = E_OUTOFMEMORY;
            }
        }

    // init request, response, server

    if (SUCCEEDED(hr))
        {
        Assert(m_pRequest);
        hr = m_pRequest->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pResponse);
        hr = m_pResponse->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pServer);
        hr = m_pServer->Init();
        }

    // create the scripting namespace

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    // cleanup on error

    if (FAILED(hr))
        Cleanup();

    m_fIsChild = FALSE;
    return hr;
    }

/*===================================================================
CIntrinsicObjects::PrepareChild

Prepare intrinsics structure for a child request

Parameters:
    pResponse       parent intrinsic
    pRequest        parent intrinsic
    pServer         parent intrinsic

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::PrepareChild
(
CResponse *pResponse,
CRequest *pRequest,
CServer *pServer
)
    {
    HRESULT hr = S_OK;

    if (!pResponse || !pRequest || !pServer)
        {
        hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        m_pResponse = pResponse;
        m_pResponse->AddRef();

        m_pRequest = pRequest;
        m_pRequest->AddRef();

        m_pServer = pServer;
        m_pServer->AddRef();

        m_fIsChild = TRUE;
        }

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    if (FAILED(hr))
        Cleanup();

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Cleanup

Cleanup the intrinsics after the request processing

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIntrinsicObjects::Cleanup()
    {
    if (m_pRequest)
        {
        if (!m_fIsChild)
            m_pRequest->UnInit();
        m_pRequest->Release();
        m_pRequest = NULL;
        }

    if (m_pResponse)
        {
        if (!m_fIsChild)
            m_pResponse->UnInit();
        m_pResponse->Release();
        m_pResponse = NULL;
        }

    if (m_pServer)
        {
        if (!m_fIsChild)
            m_pServer->UnInit();
        m_pServer->Release();
        m_pServer = NULL;
        }

    if (m_pScriptingNamespace)
        {
        m_pScriptingNamespace->Release();
        m_pScriptingNamespace = NULL;
        }

    return S_OK;
    }

/*===================================================================
ReInitIntrinsics

Call re-init on each of the intrinsics that require it
to run a new page.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - some engine info
    fPostGlobal     - Is this a reinit after running global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT ReInitIntrinsics
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo,
BOOL fPostGlobal
)
    {
    HRESULT hr;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pEngineInfo != NULL);

    // Hand the new CIsapiReqInfo to the Server object
    // Note on bug 682: We do always need to re-init CServer because it takes the phitobj
    if (FAILED(hr = intrinsics.PServer()->ReInit(pHitObj->PIReq(), pHitObj)))
        goto LExit;

    if (FAILED(hr = intrinsics.PScriptingNamespace()->Init()))
        goto LExit;

    /*
     * Bug 682 & 671 (better fix to 452 & 512)
     * Dont re-init the Request & response objects after running a Global.Asa
     * because, the running of global.asa may have set cookies into request (bug 671), that reinit
     * would wipe, and the global.asa may have output headers (or other stuff) which impacts the response
     * object (bug 512) that we dont want to reset.
     */
    if (!fPostGlobal)
        {
        if (FAILED(hr = intrinsics.PRequest()->ReInit(pHitObj->PIReq(), pHitObj)))
            goto LExit;

        if (FAILED(hr = intrinsics.PResponse()->ReInit(
                                                pHitObj->PIReq(),
                                                pHitObj->PSzNewSessionCookie(),
                                                intrinsics.PRequest(),
                                                GetScriptEngine,
                                                pEngineInfo,
                                                pHitObj
                                                )))
            goto LExit;
        }

LExit:
    return(hr);
    }

/*===================================================================
LoadTemplate

Load a template, cleanup and give appropriate errors on failure.

Parameters:
    szFile          - the file to load a template for
    pHitObj         - pointer to the hit object
    ppTemplate      - The returned loaded template
    fGlobalAsa      - is this for Global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT LoadTemplate
(
const TCHAR                 *szFile,
      CHitObj               *pHitObj,
      CTemplate             **ppTemplate,
const CIntrinsicObjects     &intrinsics,
      BOOL                  fGlobalAsa,
      BOOL                  *pfTemplateInCache)
{
    HRESULT hr;
    DWORD   nRetryCount=0;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(ppTemplate != NULL);
    
    //
    // Verify that we are recieving a valid filename. If not there is something seriously broken.
    // We cannot have a browser request without a URL?
    //
    Assert(szFile);

    if (_tcslen(szFile) == 0)
    {
        // Could not obtain the PathTranslated corresponding to this file.

        // Report a Server 500 Error
        pHitObj->ReportServerError(IDE_500_SERVER_ERROR);

        return E_FAIL;
    }

Retry:
    // Load the script - cache will AddRef
    if (FAILED(hr = g_TemplateCache.Load(
    							fGlobalAsa,
    							szFile,
    							pHitObj->DWInstanceID(),
    							pHitObj,
    							ppTemplate,
    							pfTemplateInCache)))
        {

        // handle the inpage I/O Error.

        // if inpage I/O error is returned, retry the Load up to 5 times...

        if (hr == STATUS_IN_PAGE_ERROR /*0xc0000006*/) {
            if (nRetryCount++ < 5) {

                if (*ppTemplate) {
                    (*ppTemplate)->Release();
                    *ppTemplate = NULL;
                }

                goto Retry;
            }
            else {

                // if retried more than 5 times, give up and return error

                hr = E_COULDNT_OPEN_SOURCE_FILE;
            }
        }

        // CONSIDER moving this cleanup into Template.Load
        if (hr == E_COULDNT_OPEN_SOURCE_FILE)
            {
            // Load error string from string table
            // BUG 731: added if to retrieve the correct header

            WCHAR   szwErr[128];

            CwchLoadStringOfId(IDH_404_OBJECT_NOT_FOUND, szwErr, 128);
            intrinsics.PResponse()->put_Status( szwErr );
            HandleSysError(404, 0, IDE_404_OBJECT_NOT_FOUND, NULL, NULL, pHitObj);
#ifndef PERF_DISABLE
            g_PerfData.Incr_REQNOTFOUND();
#endif
            }
        // fix for bug 371
        if (*ppTemplate)
            {
            (*ppTemplate)->Release();
            *ppTemplate = NULL;
            }

		if (hr == E_OUTOFMEMORY)
			{
			DBGPRINTF((DBG_CONTEXT, "Loading template returned E_OUTOFMEMORY.  Flushing template & Script Cache.\n"));
			g_TemplateCache.FlushAll();
			g_ScriptManager.FlushAll();
			}
        }

    return(hr);
    }

/*===================================================================
AllocAndLoadEngines

Allocate and load all the engines we need

Parameters:
    pHitObj             - The hit object
    pTemplate           - The template we're gonna run
    pEngineInfo         - Engine info to fill in
    pScriptingNamespace - scripting namespace
    fGlobalAsa          - Are we loading engines to run global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT AllocAndLoadEngines
(
CHitObj *pHitObj,
CTemplate *pTemplate,
ActiveEngineInfo *pEngineInfo,
CScriptingNamespace *pScriptingNamespace,
BOOL fGlobalAsa
)
    {
    HRESULT hr = S_OK;
    int iObj;
    WORD iEng;
    WORD iScriptBlock;
    WORD cEngines = pTemplate->CountScriptEngines();

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pTemplate != NULL);
    Assert(pEngineInfo != NULL);
    Assert(pScriptingNamespace != NULL);

    // Load objects from template into hit object
    for (iObj = pTemplate->Count(tcompObjectInfo) - 1; iObj >= 0; --iObj)
        {
        CHAR      *szObjectName = NULL;
        CLSID      clsid;
        CompScope scope;
        CompModel model;
        CMBCSToWChar    convStr;

        // get object-info from template and add to hitobj's list of objects
        hr = pTemplate->GetObjectInfo(iObj, &szObjectName, &clsid, &scope, &model);
        if(FAILED(hr))
            goto LExit;

        hr = convStr.Init(szObjectName);

        if (FAILED(hr))
            goto LExit;

        // ignore error ?
        pHitObj->AddComponent(ctTagged, clsid, scope, model, convStr.GetString());
        }

    // bug 975: if no script engines, exit now
    if(cEngines == 0)
        goto LExit;

    // Allocate space for script engines
    //
    // NOTE: There is a timing problem here in that the response object needs to
    //      be instantiated before we instantiate the script engines, but the
    //      response object needs to be able to access the list of active script
    //      engines, because it may need to halt execution.  To accomplish this,
    //      the response object is passed a pointer to the "EngineInfo" structure
    //      as a pointer, and then we modify the contents of the pointer right under
    //      its nose.  We pass an accessor function via pointer so that response just
    //      sees a void pointer.
    //

    if (cEngines == 1)
        {
        // don't do allocations in case of one engine
        pEngineInfo->rgActiveEngines = & (pEngineInfo->siOneActiveEngine);
        }
    else
        {
        pEngineInfo->rgActiveEngines = new ScriptingInfo[cEngines];
        if (pEngineInfo->rgActiveEngines == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    pEngineInfo->cEngines = cEngines;
    pEngineInfo->cActiveEngines = 0;    // number of SUCCESSFULLY instantiated engines

    // Load all of the script engines in advance.
    for (iScriptBlock = 0; iScriptBlock < cEngines; ++iScriptBlock)
        {
        LPCOLESTR       wstrScript;
        SCRIPTSTATE     nScriptState;

        ScriptingInfo *pScriptInfo = &pEngineInfo->rgActiveEngines[iScriptBlock];
        pTemplate->GetScriptBlock(
                                iScriptBlock,
                                &pScriptInfo->szScriptEngine,
                                &pScriptInfo->pProgLangId,
                                &wstrScript);

        // Populate information required for the line mapping callback.
        //
        pScriptInfo->LineMapInfo.iScriptBlock = iScriptBlock;
        pScriptInfo->LineMapInfo.pTemplate = pTemplate;

        // acquire a script engine by:
        //
        //  getting an engine from the template object (if it has one)
        //  else from the script manager.
        //
        // If we are in debug mode, the templates tend to be greedy and hold
        // onto script engines.  (See notes in scrptmgr.h)
        //
        pScriptInfo->pScriptEngine = NULL;

        if (pHitObj->PAppln()->FDebuggable())
            {
            pScriptInfo->pScriptEngine = pTemplate->GetActiveScript(iScriptBlock);

            if (pScriptInfo->pScriptEngine)
                {
                // If we got one, we don't need to re-init the engine
                nScriptState = SCRIPTSTATE_INITIALIZED;
                hr = static_cast<CActiveScriptEngine *>(pScriptInfo->pScriptEngine)->ReuseEngine(pHitObj, NULL, iScriptBlock, pHitObj->DWInstanceID());
                }
            }

        if (pScriptInfo->pScriptEngine == NULL)
            {
            hr = g_ScriptManager.GetEngine(LOCALE_SYSTEM_DEFAULT,
                                            *(pScriptInfo->pProgLangId),
                                            pTemplate->GetSourceFileName(),
                                            pHitObj,
                                            &pScriptInfo->pScriptEngine,
                                            &nScriptState,
                                            pTemplate,
                                            iScriptBlock);
            }
        if (FAILED(hr))
            goto LExit;

        // BUG 252: Keep track of how many engines we actually instantiate
        ++pEngineInfo->cActiveEngines;

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED || fGlobalAsa)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddObjects(!fGlobalAsa)))
                goto LExit;
            }

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddScriptlet(wstrScript)))
                goto LExit;
            }

        // Add the engine to the scripting namespace
        if (FAILED(hr = pScriptingNamespace->AddEngineToNamespace(
                                                (CActiveScriptEngine *)pScriptInfo->pScriptEngine)))
                goto LExit;

		// Update locale & code page (in case they are different om this page)
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoLocale);
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoCodePage);
        }

    // Add the scripting namespace to each script engine. Because all engines might not
    // implement "lazy instantiation", this code requires all
    // engines are pre-instantiated (which means we can't do it in the above loop.)
    // Add the scripting namespace to the hitobj first
    pHitObj->AddScriptingNamespace(pScriptingNamespace);

    for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
        pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddScriptingNamespace();

    /*
     * Bring all engines, except the "primary engine" (engine 0) when the template
     * isn't global.asa, to runnable state in the order in which script for the 
     * given language was found in the script file.
     */
    for (iEng = fGlobalAsa ? 0 : 1; iEng < pEngineInfo->cActiveEngines; ++iEng)
        {
        hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->MakeEngineRunnable();
        if (FAILED(hr))
            goto LExit;
        }

LExit:
    return(hr);
    }

/*===================================================================
DeAllocAndFreeEngines

Deallocate and free any loaded engines

Parameters:
    pEngineInfo         - Engine info to release

Returns:
    Nothing
===================================================================*/
VOID DeAllocAndFreeEngines
(
ActiveEngineInfo *pEngineInfo,
CAppln *pAppln
)
    {
    WORD iEng;

    Assert(pEngineInfo != NULL);

    if (pEngineInfo->cActiveEngines > 0) {
        if (pEngineInfo->rgActiveEngines == NULL) {
            Assert(pEngineInfo->rgActiveEngines);
        }
        else {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                g_ScriptManager.ReturnEngineToCache(&pEngineInfo->rgActiveEngines[iEng].pScriptEngine, pAppln);
            pEngineInfo->cActiveEngines = 0;
        }
    }
    if (pEngineInfo->cEngines > 1)
        {
        delete pEngineInfo->rgActiveEngines;
        }

    pEngineInfo->cEngines = 0;
    pEngineInfo->rgActiveEngines = NULL;
    }

/*===================================================================
GetScriptEngine

Get a script engine based on index. Return NULL if the index
is not in range.  (this is a callback)

The AllocAndLoadEngines function will create an array of ScriptingInfo
structures that are defined here.  It contains all the infomation
needed to 1. set up the MapScript2SourceLine callback,
2. merge namespaces, 3. set up this callback.

Parameters:
    iScriptEngine - the script engine to retrieve
    pvData      - instance data for the function

Returns:
    The requested script engine or NULL if not such engine

Side effects:
    None
===================================================================*/
CScriptEngine *GetScriptEngine
(
INT iScriptEngine,
VOID *pvData
)
    {
    ActiveEngineInfo *pInfo = static_cast<ActiveEngineInfo *>(pvData);
    if (unsigned(iScriptEngine) >= unsigned(pInfo->cActiveEngines))
        {
        // Note: the caller has no idea how many script engines there are.
        // if the caller asks for an engine out of range, return NULL so they
        // know they have asked for more than there are
        return NULL;
        }

    return(pInfo->rgActiveEngines[iScriptEngine].pScriptEngine);
    }

/*===================================================================
CallScriptFunctionOfEngine

Calls a script engine to execute one of its functions

Returns:
    S_OK on success

Side effects:
    None
===================================================================*/
HRESULT CallScriptFunctionOfEngine
(
ActiveEngineInfo &engineInfo,
short iScriptBlock,
wchar_t *strFunction,
CASPObjectContext   *pASPObjectContext  /* = NULL */
)
{
    HRESULT hr;
    
    Assert(engineInfo.rgActiveEngines != NULL);
    Assert (iScriptBlock <= engineInfo.cEngines);
    
    CScriptEngine *pScriptEngine = (CScriptEngine *)engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine;
    Assert(pScriptEngine != NULL);


    hr = pScriptEngine->Call(strFunction);

    // housekeeping for the transacted case...

    if (pASPObjectContext != NULL) {

        // If the script timed out or there was an unhandled error, then autoabort
        if (SUCCEEDED(hr) && (pScriptEngine->FScriptTimedOut() || pScriptEngine->FScriptHadError()))
        {
            hr = pASPObjectContext->SetAbort();
        }

        // If the script author did not do an explicit SetComplete or SetAbort
        // then do a SetComplete here so Viper will return the transaction
        // completion status to the caller
        if (SUCCEEDED(hr) && !pASPObjectContext->FAborted())
        {
            hr = pASPObjectContext->SetComplete();
        }
    }

    return hr;
}

/*===================================================================
CallScriptFunction

Calls each script engine in turn to execute a script function;
exits when an engine succeeds or we run out of engines.

Returns:
    S_OK on success

Side effects:
    None
===================================================================*/
HRESULT CallScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction
)
    {
    HRESULT hr = E_FAIL;
    int     i;

    for (i = 0; i < engineInfo.cActiveEngines; i++)
        {
        // if execution succeeds, bail
        if (SUCCEEDED(hr = CallScriptFunctionOfEngine(engineInfo, (SHORT)i, strFunction)))
            goto LExit;

        // if execution fails with exception other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            goto LExit;
        }

LExit:
    return hr;
    }

/*===================================================================
TestScriptFunction

Tests each script engine in turn to test [the existance of] a script
function; exits when an engine succeeds or we run out of engines.

Parameters
    ActiveEngineInfo &engineInfo
    wchar_t          *strFunction       functions name


Returns:
    S_OK if exists

Side effects:
    None
===================================================================*/
HRESULT TestScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction
)
    {
    HRESULT hr = E_FAIL;

    for (int i = 0; i < engineInfo.cActiveEngines; i++)
        {
        hr = engineInfo.rgActiveEngines[i].pScriptEngine->
            CheckEntryPoint(strFunction);

        // if execution succeeds, bail
        if (SUCCEEDED(hr))
            break;

        // if fails with result other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            break;
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\glob.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.cpp

Owner: LeiJin

Implementation of Glob class functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "iiscnfgp.h"
#include "debugger.h"
#include "appcnfg.h"
#include "memchk.h"
#include <iismsg.h>

HRESULT	ReadConfigFromMD(CIsapiReqInfo   *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
HRESULT MDUnRegisterProperties();
HRESULT MDRegisterProperties(void);

#define DEFAULTSTRSIZE 1024

#define dwUnlimited 0xFFFFFFFF
const DWORD dwMDDefaultTimeOut	= 30000;
enum eConfigType { eDLLConfig = 0, eAppConfig };

CAspRegistryParams   g_AspRegistryParams;
extern LONG          g_fProceedWithShutdownAppln;
LONG                 g_fProceedWithShutdownGlob = 1;

/*========================================================================================
The following array definition is for D1 to D2 migration only.  It contains the necessary
information reads from D1 ASP settings in registry.

=========================================================================================*/
typedef struct _D1propinfo
	{
	CHAR *szName;			// Name of the property in the registry
	DWORD dwType;			// Type (e.g. REG_DWORD, REG_SZ, etc)
	DWORD cbData;			// How long is the value
	VOID *pData;
	BOOL fSuccess;			// Load from registry successful or not.
	} D1PROPINFO;

#define NUM_D1PROP_NeedMigrated	18
// This index should be match the index in D1PropInfo.
enum D1PropIndex {
	D1Prop_NotExist	= -1,
	D1Prop_BufferingOn = 0,
	D1Prop_LogErrorRequests,
	D1Prop_ScriptErrorsSentToBrowser,
	D1Prop_ScriptErrorMessage,
	D1Prop_ScriptFileCacheSize,
	D1Prop_ScriptEngineCacheMax,
	D1Prop_ScriptTimeout,
	D1Prop_SessionTimeout,
//	D1Prop_MemFreeFactor,
//	D1Prop_MinUsedBlocks,
	D1Prop_AllowSessionState,
	D1Prop_DefaultScriptLanguage,
//	D1Prop_StartConnectionPool,
	D1Prop_AllowOutOfProcCmpnts,
	D1Prop_EnableParentPaths,
// IIS5.0 (from IIS4.0)
	D1Prop_EnableAspHtmlFallback,
	D1Prop_EnableChunkedEncoding,
	D1Prop_EnableTypelibCache,
	D1Prop_ErrorsToNtLog,
	D1Prop_ProcessorThreadMax,
	D1Prop_RequestQueueMax
	};

// This flag is used only in setup time.
BOOL	g_fD1ConfigExist = FALSE;
// The index is defined in D1PropIndex.				
D1PROPINFO	D1PropInfo[] =
	{
	{	"BufferingOn", REG_DWORD, 0, 0, FALSE},
	{	"LogErrorRequests", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorsSentToBrowser", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorMessage", REG_SZ, 0, 0, FALSE},
	{	"ScriptFileCacheSize", REG_DWORD, 0, 0, FALSE},
	{	"ScriptEngineCacheMax", REG_DWORD, 0, 0, FALSE},
	{	"ScriptTimeout", REG_DWORD, 0, 0, FALSE},
	{	"SessionTimeout", REG_DWORD, 0, 0, FALSE},
	{	"AllowSessionState", REG_DWORD, 0, 0, FALSE},
	{	"DefaultScriptLanguage", REG_SZ, 0, 0, FALSE},
	{	"AllowOutOfProcCmpnts", REG_DWORD, 0, 0, FALSE},
	{	"EnableParentPaths", REG_DWORD, 0, 0, FALSE},
// IIS5.0 (from IIS4.0)
	{	"EnableAspHtmlFallback", REG_DWORD, 0, 0, FALSE},
	{	"EnableChunkedEncoding", REG_DWORD, 0, 0, FALSE},
	{	"EnableTypelibCache", REG_DWORD, 0, 0, FALSE},
	{	"ErrorsToNTLog", REG_DWORD, 0, 0, FALSE},
	{	"ProcessorThreadMax", REG_DWORD, 0, 0, FALSE},
	{	"RequestQueueMax", REG_DWORD, 0, 0, FALSE}
	
	};


/*
 * The following array contains all the info we need to create and load
 * all of the registry entries for denali.  See the above PROPINFO structure for details on each of the fields.
 *
 * NOTE: There is an odd thing about initializers and unions.  You must initialize a union with the value of
 * the type of the first element in the union.  In the anonymous union in the PROPINFO structure, we have defined
 * the first type to be DWORD.  Thus, for non-DWORD registry entries, the default value must be cast to a DWORD
 * before being initialized, or initialized using a more explicit mechanism.
 */
/*
 * Info about our properties used by Metabase
 */
typedef struct _MDpropinfo
	{
	INT	id;					// Identifier used in Glob if UserType is IIS_MD_UT_WAM,
							// Identifier used in AppConfig if UserType is ASP_MD_UT_APP.
	INT	iD1PropIndex;		// Index in D1PropInfo. if equals to -1, that it does not exist in D1.
	BOOL fAdminConfig;		// Admin Configurable
	DWORD dwMDIdentifier;	// Metabase identifier
	DWORD dwUserType;		// IIS_MD_UT_WAM(data per Dll) or ASP_MD_UT_APP(data per App)
	DWORD dwType;
	DWORD cbData;
	union					// Default Value
		{
		DWORD dwDefault;	// Default value for DWORDs
		INT idDefault;		// Default value for strings -- the id of the string in the resource
		BYTE *pbDefault;	// Pointer to arbitrary default value
		};
	DWORD dwValueMin;		// For DWORD registry entries, min value allowed
	DWORD dwValueMax;		// For DWORD registry entries, max value allowed
	} MDPROPINFO;

//Some default settings for ASP Metabase
#define ASP_MD_DAttributes	METADATA_INHERIT

const MDPROPINFO rgMDPropInfo[] =
				{

#define THREADGATING_DFLT 0L
#define BUFFERING_DFLT    1L
    //          ID                              D1PropIndex         AdminConfig?        Metabase ID                   UserType      Data Type           cbData    Def, Min, Max

	// Glob Settings
	// -------------
	
	{ IGlob_LogErrorRequests,           D1Prop_LogErrorRequests,        TRUE,   MD_ASP_LOGERRORREQUESTS,            IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
    { IGlob_ScriptFileCacheSize,        D1Prop_ScriptFileCacheSize,     TRUE,   MD_ASP_SCRIPTFILECACHESIZE,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 500L, 0L, dwUnlimited},
	{ IGlob_ScriptEngineCacheMax,       D1Prop_ScriptEngineCacheMax,    TRUE,   MD_ASP_SCRIPTENGINECACHEMAX,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 250L, 0L, dwUnlimited},
				
	{ IGlob_ExceptionCatchEnable,       D1Prop_NotExist,                TRUE,   MD_ASP_EXCEPTIONCATCHENABLE,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_TrackThreadingModel,        D1Prop_NotExist,                TRUE,   MD_ASP_TRACKTHREADINGMODEL,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_AllowOutOfProcCmpnts,       D1Prop_AllowOutOfProcCmpnts,    FALSE,  MD_ASP_ALLOWOUTOFPROCCMPNTS,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	
	// IIS5.0
	{ IGlob_EnableAspHtmlFallback,      D1Prop_EnableAspHtmlFallback,   TRUE,   MD_ASP_ENABLEASPHTMLFALLBACK,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_EnableChunkedEncoding,      D1Prop_EnableChunkedEncoding,   TRUE,   MD_ASP_ENABLECHUNKEDENCODING,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_EnableTypelibCache,         D1Prop_EnableTypelibCache,      TRUE,   MD_ASP_ENABLETYPELIBCACHE,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_ErrorsToNtLog,              D1Prop_ErrorsToNtLog,           TRUE,   MD_ASP_ERRORSTONTLOG,               IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_ProcessorThreadMax,         D1Prop_ProcessorThreadMax,      TRUE,   MD_ASP_PROCESSORTHREADMAX,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 25L, 0L, dwUnlimited},
	{ IGlob_RequestQueueMax,            D1Prop_RequestQueueMax,         TRUE,   MD_ASP_REQEUSTQUEUEMAX,             IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 3000L, 0L, dwUnlimited},
	
    // IIS6.0 & IIS5.1 - Persisted Template Cache
	{ IGlob_PersistTemplateMaxFiles,    D1Prop_NotExist,                TRUE,   MD_ASP_MAXDISKTEMPLATECACHEFILES,   IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 2000L,   0L, dwUnlimited},
    { IGlob_PersistTemplateDir,         D1Prop_NotExist,                TRUE,   MD_ASP_DISKTEMPLATECACHEDIRECTORY,  IIS_MD_UT_WAM, EXPANDSZ_METADATA, dwUnlimited, IDS_DEFAULTPERSISTDIR, 0L, dwUnlimited},
	

    // Application settings
	// --------------------
	
	{ IApp_AllowSessionState,           D1Prop_AllowSessionState,       TRUE,   MD_ASP_ALLOWSESSIONSTATE,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_BufferingOn,                 D1Prop_BufferingOn,             TRUE,   MD_ASP_BUFFERINGON,                 ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), BUFFERING_DFLT, 0L, 1L},
	{ IApp_ScriptLanguage,              D1Prop_DefaultScriptLanguage,   TRUE,   MD_ASP_SCRIPTLANGUAGE,              ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_SCRIPTLANGUAGE, 0L, dwUnlimited},
	{ IApp_EnableParentPaths,           D1Prop_EnableParentPaths,       TRUE,   MD_ASP_ENABLEPARENTPATHS,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_ScriptErrorMessage,          D1Prop_ScriptErrorMessage,      TRUE,   MD_ASP_SCRIPTERRORMESSAGE,          ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_DEFAULTMSG_ERROR, 0L, dwUnlimited},
	{ IApp_SessionTimeout,              D1Prop_SessionTimeout,          TRUE,   MD_ASP_SESSIONTIMEOUT,              ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 20L, 1L, dwUnlimited},
	{ IApp_QueueTimeout,                D1Prop_NotExist,                TRUE,   MD_ASP_QUEUETIMEOUT,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},
	{ IApp_CodePage,                    D1Prop_NotExist,                TRUE,   MD_ASP_CODEPAGE,                    ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), CP_ACP, 0L, dwUnlimited},
	{ IApp_ScriptTimeout,               D1Prop_ScriptTimeout,           TRUE,   MD_ASP_SCRIPTTIMEOUT,               ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 90L, 1L, dwUnlimited},
	{ IApp_ScriptErrorsSenttoBrowser,   D1Prop_ScriptErrorsSentToBrowser, TRUE, MD_ASP_SCRIPTERRORSSENTTOBROWSER,   ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_AllowDebugging,              D1Prop_NotExist,                TRUE,   MD_ASP_ENABLESERVERDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_AllowClientDebug,            D1Prop_NotExist,                TRUE,   MD_ASP_ENABLECLIENTDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},

    // IIS5.0
	{ IApp_EnableApplicationRestart,    D1Prop_NotExist,                TRUE,   MD_ASP_ENABLEAPPLICATIONRESTART,    ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_QueueConnectionTestTime,     D1Prop_NotExist,                TRUE,   MD_ASP_QUEUECONNECTIONTESTTIME,     ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 3L, 1L, dwUnlimited},
	{ IApp_SessionMax,                  D1Prop_NotExist,                TRUE,   MD_ASP_SESSIONMAX,                  ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},

    // IIS5.1 & IIS6.0
	{ IApp_ExecuteInMTA,                D1Prop_NotExist,                TRUE,   MD_ASP_EXECUTEINMTA,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1},
    { IApp_LCID,                        D1Prop_NotExist,                TRUE,   MD_ASP_LCID,                        ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), LOCALE_SYSTEM_DEFAULT, 0L, dwUnlimited},

    // IIS6.0 Only - ServicesWithoutComponents
    { IApp_ServiceFlags,                D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_FLAGS,               ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 7L},
	{ IApp_PartitionGUID,               D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_PARTITION_ID,        ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, 0xffffffff, 0L, dwUnlimited},
	{ IApp_SxsName,                     D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_SXS_NAME,            ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, 0xffffffff, 0L, dwUnlimited},

    // IIS6.0 Only - Misc
	{ IApp_KeepSessionIDSecure,         D1Prop_NotExist,                TRUE,   MD_ASP_KEEPSESSIONIDSECURE,         ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},	
    { IApp_CalcLineNumber,              D1Prop_NotExist,                TRUE,   MD_ASP_CALCLINENUMBER,              ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},	
    { IApp_RunOnEndAsAnon,              D1Prop_NotExist,                TRUE,   MD_ASP_RUN_ONEND_ANON,              ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
    { IApp_BufferLimit,                 D1Prop_NotExist,                TRUE,   MD_ASP_BUFFER_LIMIT,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), DEFAULT_BUFFER_LIMIT, 0L, dwUnlimited},
    { IApp_RequestEntityLimit,         D1Prop_NotExist,                TRUE,   MD_ASP_MAX_REQUEST_ENTITY_ALLOWED,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), DEFAULT_REQUEST_ENTITY_LIMIT, 0L, dwUnlimited}
	};

const DWORD rgdwMDObsoleteIdentifiers[] =
    {MD_ASP_MEMFREEFACTOR,
     MD_ASP_MINUSEDBLOCKS
    };

const UINT cPropsMax = sizeof(rgMDPropInfo) / sizeof(MDPROPINFO);


/*===================================================================
ReadAndRemoveOldD1PropsFromRegistry

Reads whatever old D1 properties are in the registry and
stores the values into D1PropInfo[] global array.
Removes the old properties found from the registry.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Fills in values in Glob
===================================================================*/
BOOL ReadAndRemoveOldD1PropsFromRegistry()
{
	HKEY		hkey = NULL;
	DWORD		iValue;
	BYTE		cTrys = 0;
	DWORD		dwType;
	BYTE		bData[DEFAULTSTRSIZE];			// Size???
	BYTE		*lpRegString = NULL;			// need to use dynamic allocation when we have ERROR_MORE_DATA
	DWORD		cbData;
	HRESULT 	hr = S_OK;

	// Open the key for W3SVC\ASP\Parameters
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP\\Parameters", 0, KEY_READ|KEY_WRITE, &hkey) != ERROR_SUCCESS)
		return(FALSE);

	// Load each of the values
	for (iValue = 0; iValue < NUM_D1PROP_NeedMigrated; iValue++)
		{
		LONG err;
		D1PROPINFO *pPropInfo;

		pPropInfo = &D1PropInfo[iValue];

		cbData = sizeof(bData);
		err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, bData, &cbData);

		if (err == ERROR_MORE_DATA)
		{
			lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData);
			if (lpRegString != NULL)
			{
    			err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, lpRegString, &cbData);
    		}
			else
			{
    			pPropInfo->fSuccess = FALSE;
			    continue;
			}			
		}

		// if get an error, or not the type we expect, then use the default
		if (err != ERROR_SUCCESS || dwType != pPropInfo->dwType)
			{
			pPropInfo->fSuccess = FALSE;
			
			//
			// Free up lpRegString
			//
			if (lpRegString)
			{
                GlobalFree(lpRegString);
                lpRegString = NULL;
			}
			
			continue;
			}
			
		// Success : Got the data, copy it into Glob
		// But first, if this is a DWORD type, make sure it is within allowed Max/Min range
		switch (pPropInfo->dwType)
			{
			case REG_DWORD:
				Assert(cbData == sizeof(DWORD));
				if (cbData == sizeof(DWORD))
				{
					pPropInfo->cbData = cbData;

					//
					// bData is atleast 4 bytes (DEFAULTSTRSIZE > 4 bytes) so bData is always valid even if Prefix tags it as using a
					// possibly uninited value as lpRegString may be used in its place. Ignore PREFIX warning.
					//
					pPropInfo->pData = (VOID *)UIntToPtr((*(DWORD *)bData));
					pPropInfo->fSuccess = TRUE;
				}
				//
				// So if its a DWORD then we are not going to need the lpRegString. Release it.
				//
				if (lpRegString)
				{				
				    GlobalFree(lpRegString) ;
				    lpRegString = NULL;
				}
				
				break;

			case REG_SZ:		
				if (lpRegString == NULL)
				{	// The string fit into default allocation
					lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData * sizeof(WCHAR));
					if (lpRegString == NULL)
						return FALSE;

                    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)bData, -1, (LPWSTR)lpRegString, cbData);

				}
					
				pPropInfo->cbData = cbData * sizeof(WCHAR);
				pPropInfo->pData = (VOID *)lpRegString;
				pPropInfo->fSuccess = TRUE;
				lpRegString = NULL;
				break;
			}

		// remove the value from the registry
   		RegDeleteValueA(hkey, pPropInfo->szName);
		}

    // remove some old properties that 'get lost' in the upgrade
	RegDeleteValueA(hkey, "CheckForNestedVroots");
	RegDeleteValueA(hkey, "EventLogDirection");
	RegDeleteValueA(hkey, "ScriptFileCacheTTL");
	RegDeleteValueA(hkey, "StartConnectionPool");
	RegDeleteValueA(hkey, "NumInitialThreads");
	RegDeleteValueA(hkey, "ThreadCreationThreshold");
	RegDeleteValueA(hkey, "MinUsedBlocks");
	RegDeleteValueA(hkey, "MemFreeFactor");
	RegDeleteValueA(hkey, "MemClsFreeFactor");
	RegDeleteValueA(hkey, "ThreadDeleteDelay");
	RegDeleteValueA(hkey, "ViperRequestQueueMax");

	RegCloseKey(hkey);

	// remove the W3SVC\ASP\Paramaters key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "Parameters");
    	RegCloseKey(hkey);
	    }
	
	// remove the W3SVC\ASP key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "ASP");
    	RegCloseKey(hkey);
	    }
	
	return TRUE;
}

/*==================================================================
MDRegisterProperties
Register info about our properties in the metabase.  This funtion is
called during regsvr32, self-registration time.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Registers denali properties in the metabase
===================================================================*/
HRESULT MDRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	BYTE	szDefaultString[2*DEFAULTSTRSIZE];
	HRESULT	hrT = S_OK;
	BOOL	fNeedMigrated;

	fNeedMigrated = ReadAndRemoveOldD1PropsFromRegistry();

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)(L"\\LM\\W3SVC"),
							METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

    //
    // Remove obsolete metabase settings
    // See rgdwMDObsoleteIdentifiers structure for detail list of properties
    //
    for (iValue = 0; iValue < sizeof(rgdwMDObsoleteIdentifiers)/sizeof(DWORD);
        iValue++)
        {
        hr = pMetabase->DeleteData( hMetabase,
                                    NULL,
                                    rgdwMDObsoleteIdentifiers[iValue],
                                    0);
        if (FAILED(hr))
            {
            if (hr == MD_ERROR_DATA_NOT_FOUND)
                {
                hr = S_OK;
                }
            else
                {
                Assert(FALSE);
                }
            }
        }

    //
    // Set metabase properties
    //
	recMetaData.dwMDDataTag = 0;	// this parameter is not used when setting data
	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		INT	    cch;
		BYTE    aByte[4]; // Temporary buffer
		DWORD   dwLen;
		D1PROPINFO *pD1PropInfo;
		recMetaData.dwMDIdentifier = rgMDPropInfo[iValue].dwMDIdentifier;
		recMetaData.dwMDAttributes = METADATA_INHERIT;
		recMetaData.dwMDUserType = rgMDPropInfo[iValue].dwUserType;
		recMetaData.dwMDDataType = rgMDPropInfo[iValue].dwType;

        dwLen = 0;
        recMetaData.dwMDDataLen = 0;
		recMetaData.pbMDData = (unsigned char *)aByte;

        HRESULT hrGetData = pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwLen);
		
		if (hrGetData == MD_ERROR_DATA_NOT_FOUND)
		    {
		    switch (rgMDPropInfo[iValue].dwType)
    			{
    			case DWORD_METADATA:
    			
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)&(pD1PropInfo->pData);
    						break;
    						}
    					}
    				// Did not migrated.		
    				recMetaData.dwMDDataLen = rgMDPropInfo[iValue].cbData;
    				recMetaData.pbMDData = (unsigned char *)&(rgMDPropInfo[iValue].dwDefault);
    				break;
    				
                case EXPANDSZ_METADATA:
    			case STRING_METADATA:
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)(pD1PropInfo->pData);
    						break;
    						}
    					}

    				//
    				// if its a string and its index is defined as 0xffffffff then just dont load the string and continue.
    				//
    				if (rgMDPropInfo[iValue].idDefault == 0xffffffff)
    					continue;

    				// Did not migrated
    				cch = CwchLoadStringOfId(rgMDPropInfo[iValue].idDefault, (LPWSTR)szDefaultString, DEFAULTSTRSIZE);
    				if (cch == 0)
    				{
    					DBGPRINTF((DBG_CONTEXT, "LoadString failed, id = %d\n", rgMDPropInfo[iValue].idDefault));
   					    recMetaData.dwMDDataLen = cch;
        				recMetaData.pbMDData = NULL;
    				}
    				else
    				{
    				    recMetaData.dwMDDataLen = (cch + 1)*sizeof(WCHAR);
        				recMetaData.pbMDData = szDefaultString;
    				}
    				break;
    				
    			default:
    				// So far, DWORD and STRING are the only 2 types.
    				// Never reach this code path.
    				Assert(FALSE);
    				continue;
    			}
    			
    		// not found - then set
    		hr = pMetabase->SetData(hMetabase, NULL,  &recMetaData);
    		}
        else
            {
    		// don't change if the data is already in the metabase
            hr = S_OK;
            }

    	if (FAILED(hr))
	    	{
	    	DBGPRINTF((DBG_CONTEXT, "Metabase SetData failed, identifier = %08x.\n", rgMDPropInfo[iValue].dwMDIdentifier));
		    }
		}
	hrT = pMetabase->CloseKey(hMetabase);

	if (fNeedMigrated)
		{
		if (D1PropInfo[D1Prop_DefaultScriptLanguage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_DefaultScriptLanguage].pData);
			}
			
		if (D1PropInfo[D1Prop_ScriptErrorMessage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_ScriptErrorMessage].pData);
			}
		}

LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}

/*===================================================================
SetConfigToDefaults

Before loading values from the Metabase, set up default values
in case anything goes wrong.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob)
{
	HRESULT 			hr = S_OK;
	DWORD				dwMDUserType = 0;
	BYTE				*szRegString	= NULL;
	UINT 				iEntry = 0;

	if (fLoadGlob)
		{
		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		}

	for(iEntry = 0; iEntry < cPropsMax; iEntry++)
		{
		if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType)
			continue;

		// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
		// so we dont bother to reset it
		if (fLoadGlob)
			{
			if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
		else
			{
			if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
			
		switch (rgMDPropInfo[iEntry].dwType)
			{
			case DWORD_METADATA:
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				break;
				
			case STRING_METADATA:
            case EXPANDSZ_METADATA:
                if (rgMDPropInfo[iEntry].idDefault == 0xffffffff)
                    continue;
				szRegString = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                if (szRegString == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
				CchLoadStringOfId(rgMDPropInfo[iEntry].idDefault, (LPSTR)szRegString, DEFAULTSTRSIZE);
                if (rgMDPropInfo[iEntry].dwType == EXPANDSZ_METADATA) {
                    BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                    if (pszExpanded == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                           (LPSTR)pszExpanded,
                                                           DEFAULTSTRSIZE);
                    if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                        GlobalFree(szRegString);
                        szRegString = pszExpanded;
                    }
                }
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				break;
				
			default:
				Assert(FALSE);
				break;
			}
		}

	return hr;
}

/*===================================================================
ReadConfigFromMD

Read our properties from the registry.  If our props are missing, the
registry is messed up, try to re-register.  If our props are there, but
one or more values is missing, use the defaults.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	ReadConfigFromMD
(
CIsapiReqInfo   *pIReq,
CAppConfig *pAppConfig,
BOOL fLoadGlob
)
{
	HRESULT 			hr = S_OK;
	HRESULT 			hrT = S_OK;
	DWORD				dwNumDataEntries = 0;
	DWORD				cbRequired = 0;
	DWORD				dwMDUserType = 0;
	DWORD        		cbBuffer;
	BYTE				bBuffer[2000];
	BYTE				*pBuffer = NULL;
	BYTE				*szRegString	= NULL;
	BOOL				fAllocBuffer = FALSE;
	CHAR				szMDOORange[DEFAULTSTRSIZE];
	TCHAR				szMDGlobPath[] = _T("\\LM\\W3SVC");
	TCHAR				*szMDPath = NULL;
	UINT 				iEntry = 0;
	METADATA_GETALL_RECORD	*pMDGetAllRec;
	
	if (fLoadGlob)
		{
		// BUGs 88902, 105745:
		// If we are InProc, then use the "root" path for global values
		// If OutOfProc, then use the app path for global values
		if (pIReq->FInPool())
	    	szMDPath = szMDGlobPath;
	    else
	    	szMDPath = pIReq->QueryPszApplnMDPath();

   		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		szMDPath = pAppConfig->SzMDPath();
		}

	Assert(szMDPath != NULL);

	//
    // At this point szMDPath should never be NULL if it is then we bail out.
    //
	if (!szMDPath)
	{
	    DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: szMDPath is NULL\n"));
		return E_FAIL;
	}

	// PreLoad config data with default, in case anything failed.
    hr = SetConfigToDefaults(pAppConfig, fLoadGlob);
    if (FAILED(hr))
        {
        Assert(FALSE);
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: Setting defaults failed with %x\n",hr));
		return hr;
		}

	// Set flags.
	//
	BOOL fConfigLoaded[cPropsMax];
	for (iEntry = 0; iEntry < cPropsMax; iEntry++) {
		fConfigLoaded[iEntry] = FALSE;
    }

	pBuffer = bBuffer;
    hr = pIReq->GetAspMDAllData(szMDPath,
								dwMDUserType,
								sizeof(bBuffer),
								(unsigned char *)pBuffer,
								&cbRequired,
								&dwNumDataEntries
								);
								
    if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
		pBuffer = (BYTE *)GlobalAlloc(GPTR, cbRequired);
		if (pBuffer == NULL)
			return E_OUTOFMEMORY;

		fAllocBuffer = TRUE;
		cbBuffer = cbRequired;
        hr = pIReq->GetAspMDAllData(szMDPath,
								    dwMDUserType,
								    cbRequired,
								    (unsigned char *)pBuffer,
								    &cbRequired,
								    &dwNumDataEntries);
    }

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: GetAspMDAllData failed with %x\n",hr));
		return hr;
    }
    else {
		INT	cProps = 0;
		
		pMDGetAllRec = (METADATA_GETALL_RECORD *)pBuffer;
		for (UINT iValue = 0; iValue < dwNumDataEntries; iValue ++)
			{
			DWORD dwData;
			DWORD iTemp;
			DWORD cbStr;
			CHAR szMDOORangeFormat[DEFAULTSTRSIZE];

			// Init iEntry to be -1, -1 is invalid for rgMDPropInfo[] Array Index.
			iEntry = -1;
			for (iTemp = 0; iTemp < cPropsMax; iTemp++) {
				if (rgMDPropInfo[iTemp].dwMDIdentifier == pMDGetAllRec->dwMDIdentifier) {
					iEntry = iTemp;
					break;
                }
            }

			// Not found
			if (iEntry == -1) {
				pMDGetAllRec++;
				continue;
            }

			// Do found the entry in rgMDPropInfo, but datatype does not match.
			// Should never happen.
			if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType) {	// GetAllData should filter out the unwanted UserType.
				Assert(FALSE);
				pMDGetAllRec++;
				continue;
            }

			cProps++;
			
			// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
			// so we dont bother to reread it
			if (fLoadGlob) {
				if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
			}
			else {
				if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
            }
				
			switch(pMDGetAllRec->dwMDDataType) {
				case DWORD_METADATA:
					Assert(pMDGetAllRec->dwMDDataLen == sizeof(DWORD));

					dwData = *(UNALIGNED64 DWORD *)(pBuffer + pMDGetAllRec->dwMDDataOffset);

                    if (dwData > rgMDPropInfo[iEntry].dwValueMax) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMax);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMax;
                    }

					if (dwData < rgMDPropInfo[iEntry].dwValueMin) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMin);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMin;
                    }
					
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);

					fConfigLoaded[iEntry] = TRUE;

					break;
					
				case STRING_METADATA:
                case EXPANDSZ_METADATA:
					// bug fix 102010 DBCS fixes (& 99806)
					//cbStr = (pMDGetAllRec->dwMDDataLen) / sizeof(WCHAR);
					cbStr = pMDGetAllRec->dwMDDataLen;
					szRegString = (BYTE *)GlobalAlloc(GPTR, cbStr);
                    if (szRegString == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
					WideCharToMultiByte(CP_ACP, 0, (LPWSTR)(pBuffer + pMDGetAllRec->dwMDDataOffset), -1,
						(LPSTR)szRegString, cbStr, NULL, NULL);
                    if (pMDGetAllRec->dwMDDataType == EXPANDSZ_METADATA) {
                        BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                        if (pszExpanded == NULL) {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                               (LPSTR)pszExpanded,
                                                               DEFAULTSTRSIZE);
                        if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                            GlobalFree(szRegString);
                            szRegString = pszExpanded;
                        }
                    }
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));

					fConfigLoaded[iEntry] = TRUE;
					szRegString = NULL;
					break;
					
				default:
					Assert(FALSE);
					break;
			}
            pMDGetAllRec++;
        }
    }

    if (SUCCEEDED(hr) && !gGlob.m_fMDRead && fLoadGlob)
        gGlob.m_fMDRead = TRUE;

	if (fAllocBuffer == TRUE) {
		GlobalFree(pBuffer);
    }

	return hr;
}

/*==================================================================
CMDGlobConfigSink::CMDGlobConfigSink

Constructor
===================================================================*/
CMDGlobConfigSink::CMDGlobConfigSink()
{
	m_cRef = 1;
	InterlockedCompareExchange(&g_fProceedWithShutdownGlob,0,1);
}

/*==================================================================
CMDGlobConfigSink::~CMDGlobConfigSink

Destructor
===================================================================*/
CMDGlobConfigSink::~CMDGlobConfigSink()
{
	InterlockedCompareExchange(&g_fProceedWithShutdownGlob,1,0);
}

/*==================================================================
CMDGlobConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDGlobConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = NULL;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDGlobConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::Release(void)
	{
	LONG  cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CMDGlobConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
	{
    if (IsShutDownInProgress())
        return S_OK;


	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR	wszMDPath[] = L"/LM/W3SVC/";
	UINT	cSize = 0;


	cSize = wcslen(wszMDPath);
	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
		{
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, cSize + 1))
			{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
				{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
					{
					gGlob.NotifyNeedUpdate();
					return S_OK;
					}

				}
			}
		}

	return S_OK;
	}

/*===================================================================
MDUnRegisterProperties

Remove info about our properties in the Metabase.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Removes denali properties in the Metabase

	// to settings per dll.
===================================================================*/
HRESULT MDUnRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	BYTE	szDefaultString[DEFAULTSTRSIZE];
	BOOL	fMDSaveData = TRUE;
	HRESULT	hrT = S_OK;

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)L"\\LM\\W3SVC",
										METADATA_PERMISSION_WRITE, dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		hr = pMetabase->DeleteData(	hMetabase,
									NULL,
									rgMDPropInfo[iValue].dwMDIdentifier,
									0);
		if (FAILED(hr))
			{
			if (hr == MD_ERROR_DATA_NOT_FOUND)
				{
				hr = S_OK;
				}
			else
				{
				Assert(FALSE);
				}
			}
		}

	hrT = pMetabase->CloseKey(hMetabase);
	// Add data to W3SVC
LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}

HRESULT GetMetabaseIF(IMSAdminBase **hMetabase)
{
	IClassFactory 					*pcsfFactory = NULL;
    HRESULT                         hr;

	hr = CoGetClassObject(
			CLSID_MSAdminBase,
			CLSCTX_SERVER,
			NULL,
			IID_IClassFactory,
			(void **)&pcsfFactory);

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CoGetClassObject failed with %x\n",hr));
        return hr;
    }

	hr = pcsfFactory->CreateInstance(
			NULL,
			IID_IMSAdminBase,
			(void **) hMetabase);

	pcsfFactory->Release();
	
	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CreateInstance failed with %x\n",hr));
		goto LExit;
    }
		
	Assert(*hMetabase != NULL);
	if (FAILED(hr))
		{
		(*hMetabase)->Release();
		(*hMetabase) = NULL;
		goto LExit;
		}
LExit:
    return(hr);
}

/*===================================================================
Cglob::CGlob

Constructor.  Fill glob with some default values.

in:

returns:

Side effects:
===================================================================*/
CGlob::CGlob()
	:
	m_pITypeLibDenali(NULL),
    m_pITypeLibTxn(NULL),
    m_dwNumberOfProcessors(1),
	m_fInited(FALSE),
	m_fMDRead(FALSE),
	m_fNeedUpdate(TRUE),			
	m_dwScriptEngineCacheMax(120),
	m_dwScriptFileCacheSize(dwUnlimited),
	m_fLogErrorRequests(TRUE),
	m_fExceptionCatchEnable(TRUE),
	m_fAllowOutOfProcCmpnts(FALSE),
	m_fAllowDebugging(FALSE),
	m_fTrackThreadingModel(FALSE),
	m_dwMDSinkCookie(0),
	m_pMetabaseSink(NULL),
    m_pMetabase(NULL),
	m_fEnableAspHtmlFallBack(FALSE),
	m_fEnableTypelibCache(TRUE),
	m_fEnableChunkedEncoding(TRUE),  // UNDONE: temp.
	m_fDupIISLogToNTLog(FALSE),
	m_dwRequestQueueMax(500),        // default limit on # of requests
	m_dwProcessorThreadMax(10),
    m_dwPersistTemplateMaxFiles(1000),
    m_pszPersistTemplateDir(NULL)
	{
	SYSTEM_INFO	si;

	
	// Find out how many processors are on this machine
	GetSystemInfo(&si);
	m_dwNumberOfProcessors = si.dwNumberOfProcessors;
	if (m_dwNumberOfProcessors <= 0)
		{
		m_dwNumberOfProcessors = 1;		// Just in case!
		}
	}

/*===================================================================
Cglob::SetGlobValue

Set global values.

in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT	CGlob::SetGlobValue(unsigned int iValue, BYTE *pData)
{
	Assert((iValue < IGlob_MAX) && (pData != NULL));
	
	switch(iValue) {
		case IGlob_LogErrorRequests:
			InterlockedExchange((LPLONG)&m_fLogErrorRequests, *(LONG *)pData);
			break;

		case IGlob_ScriptFileCacheSize:
			InterlockedExchange((LPLONG)&m_dwScriptFileCacheSize, *(LONG *)pData);
			break;
			
		case IGlob_ScriptEngineCacheMax:
			InterlockedExchange((LPLONG)&m_dwScriptEngineCacheMax, *(LONG *)pData);
			break;

		case IGlob_ExceptionCatchEnable:
			InterlockedExchange((LPLONG)&m_fExceptionCatchEnable, *(LONG *)pData);
			break;

		case IGlob_TrackThreadingModel:
			InterlockedExchange((LPLONG)&m_fTrackThreadingModel, *(LONG *)pData);
			break;
			
		case IGlob_AllowOutOfProcCmpnts:
			InterlockedExchange((LPLONG)&m_fAllowOutOfProcCmpnts, *(LONG *)pData);
			break;

        case IGlob_EnableAspHtmlFallback:
			InterlockedExchange((LPLONG)&m_fEnableAspHtmlFallBack, *(LONG *)pData);
            break;

        case IGlob_EnableChunkedEncoding:
			InterlockedExchange((LPLONG)&m_fEnableChunkedEncoding, *(LONG *)pData);
            break;

        case IGlob_EnableTypelibCache:
			InterlockedExchange((LPLONG)&m_fEnableTypelibCache, *(LONG *)pData);
            break;

        case IGlob_ErrorsToNtLog:
			InterlockedExchange((LPLONG)&m_fDupIISLogToNTLog, *(LONG *)pData);
            break;

        case IGlob_ProcessorThreadMax:
			InterlockedExchange((LPLONG)&m_dwProcessorThreadMax, *(LONG *)pData);
            break;

        case IGlob_RequestQueueMax:
			InterlockedExchange((LPLONG)&m_dwRequestQueueMax, *(LONG *)pData);
            break;

        case IGlob_PersistTemplateMaxFiles:
			InterlockedExchange((LPLONG)&m_dwPersistTemplateMaxFiles, *(LONG *)pData);
            break;
			
		case IGlob_PersistTemplateDir:
			GlobStringUseLock();
			if (m_pszPersistTemplateDir != NULL) {
				GlobalFree(m_pszPersistTemplateDir);
			}
			m_pszPersistTemplateDir = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		default:
			break;
	}

	return S_OK;
}

/*===================================================================
HRESULT	CGlob::GlobInit

Get all interesting global values (mostly from registry)

Returns:
	HRESULT - S_OK on success
	
Side effects:
	fills in glob.  May be slow
===================================================================*/
HRESULT CGlob::GlobInit(void)
	{
	HRESULT hr = S_OK;

	m_fInited = FALSE;
	
	ErrInitCriticalSection(&m_cs, hr);
	if (FAILED(hr))
		return(hr);

	hr = MDInit();
	if (FAILED(hr))
		return hr;

	//Finish loading, any registry change from this moment requires Admin Configurable(TRUE) to take
	//affect.  Other registry changes need to have IIS be stopped and restarted.
	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

    // get the registry based ASP parameters

    g_AspRegistryParams.Init();

	return(hr);
	}

/*===================================================================
GlobUnInit

Free all GlobalString Values.

Returns:
	HRESULT - S_OK on success
	
Side effects:
	memory freed.
===================================================================*/
HRESULT CGlob::GlobUnInit(void)
	{
	HRESULT hr = S_OK;

	MDUnInit();

	//
	// Wait for COM to release the Global Sink
	//
	while (!g_fProceedWithShutdownGlob)
		Sleep(100);

	DeleteCriticalSection(&m_cs);

	return(hr);
	}

/*==================================================================
CGlob::MDInit

1. Create Metabase interface.
2. Load Glob configuration Settings from Metabase
2. Register SinkNotify() callback function through Metabase connectionpoint interface.

Returns:
	HRESULT	- S_OK on success

Side effects: Register SinkNotify().
===================================================================*/
HRESULT CGlob::MDInit(void)
{
	HRESULT 						hr = S_OK;
	IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;

    if (FAILED(hr = GetMetabaseIF(&m_pMetabase))) {
        goto LExit;
    }

	m_pMetabaseSink = new CMDGlobConfigSink();
	if (!m_pMetabaseSink)
	    return E_OUTOFMEMORY;
	
	m_dwMDSinkCookie = 0;

	// Init the Glob structure with defaults.  The metabase will actually be read later
	hr = SetConfigToDefaults(NULL, TRUE);
	if (SUCCEEDED(hr)) {
		// Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();

			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
				pConnPoint->Release();
				}
			}
	} else {
        DBGPRINTF((DBG_CONTEXT,"MDInit: SetConfigToDefaults failed with %x\n",hr));
    }
		
	if (FAILED(hr))	//Advise failed
		{
        DBGPRINTF((DBG_CONTEXT,"MDInit: Advise failed with %x\n",hr));
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

LExit:

	return hr;
}

/*==================================================================
CGlob::MDUnInit

1. UnRegister SinkNofity() from Metabase connectionpoint interface.
2. delete m_pMetabaseSink.
3. release interface pointer of m_pMetabase.

Returns:
	HRESULT	- S_OK on success

Side effects: release interface pointer of m_pMetabase
===================================================================*/
HRESULT CGlob::MDUnInit(void)
{
	HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
	IClassFactory 					*pcsfFactory            = NULL;

    if (m_pMetabase != NULL)
		{
		//Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();
			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
				if (FAILED(hr))
					{
                    DBGPRINTF((DBG_CONTEXT, "UnAdvise Glob Config Change Notify failed.\n"));
					}
				pConnPoint->Release();
				m_dwMDSinkCookie = 0;
				}
			}
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

	if (m_pMetabaseSink)
	{
		m_pMetabaseSink->Release();
		m_pMetabaseSink = NULL;
	}

	return hr;
}


/*==================================================================
CMDAppConfigSink::CMDAppConfigSink

Constructor
===================================================================*/
CMDAppConfigSink::CMDAppConfigSink (CApplnMgr *pApplnMgr)
{
	m_cRef = 1;
	m_pApplnMgr = pApplnMgr;	
	InterlockedCompareExchange(&g_fProceedWithShutdownAppln,0,1);
}
	
/*==================================================================
CMDAppConfigSink::~CMDAppConfigSink

Destructor
===================================================================*/
CMDAppConfigSink::~CMDAppConfigSink ()
{
	InterlockedCompareExchange(&g_fProceedWithShutdownAppln,1,0);
}


/*==================================================================
CMDAppConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDAppConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = 0;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDAppConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}
	
/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::Release(void)
	{
	LONG cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}


/*==================================================================
CMDAppConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/

STDMETHODIMP	CMDAppConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
{
     if (IsShutDownInProgress())
        return S_OK;

     return m_pApplnMgr->NotifyAllMBListeners(dwMDNumElements,pcoChangeList);
}

/*===================================================================
CAppConfig::CAppConfig

Returns:
	Nothing

Side Effects:
	None.
===================================================================*/
CAppConfig::CAppConfig()
	:
    m_dwScriptTimeout(45),
    m_dwSessionTimeout(10),
    m_dwQueueTimeout(0xffffffff),
    m_fScriptErrorsSentToBrowser(TRUE),
    m_fBufferingOn(TRUE),
    m_fEnableParentPaths(TRUE),
    m_fAllowSessionState(TRUE),
    m_fAllowOutOfProcCmpnts(FALSE),
    m_fAllowDebugging(FALSE),
    m_fAllowClientDebug(FALSE),
    m_fExecuteInMTA(FALSE),
    m_fEnableApplicationRestart(TRUE),
    m_dwQueueConnectionTestTime(3),
    m_dwSessionMax(0xffffffff),
	m_fInited(FALSE),
    m_fRestartEnabledUpdated(FALSE),
	m_uCodePage(CP_ACP),
	m_fIsValidProglangCLSID(FALSE),
    m_fIsValidPartitionGUID(FALSE),
    m_fSxsEnabled(FALSE),
    m_fTrackerEnabled(FALSE),
    m_fUsePartition(FALSE),
    m_fRunOnEndAsAnon(TRUE),
    m_hAnonToken(INVALID_HANDLE_VALUE),
    m_dwBufferLimit(DEFAULT_BUFFER_LIMIT),
    m_dwRequestEntityLimit(DEFAULT_REQUEST_ENTITY_LIMIT),
    m_cRefs(1)
{
    m_uCodePage = GetACP();

	for (UINT cMsg = 0; cMsg < APP_CONFIG_MESSAGEMAX; cMsg++)
		m_szString[cMsg] = 0;
	
}

/*===================================================================
CAppConfig::Init

Init the CAppConfig.	Only called once.

in:
	CAppln	pAppln	The backpointer to Application.

Side effects:
	Allocate CMDAppConfigSink. Register metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::Init
(
CIsapiReqInfo   *pIReq,
CAppln *pAppln
)
{
    HRESULT                         hr=S_OK;

    //
    // Initialize the Lock
    //
    ErrInitCriticalSection( &m_csLock, hr );
    if (FAILED(hr))
        return hr;

    m_fCSInited = TRUE;
	m_pAppln = pAppln;

    //
	// Read info into Glob structure
	//
	hr = ReadConfigFromMD(pIReq, this, FALSE);

    if (SUCCEEDED(hr)) {
        hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		    								      &m_DefaultScriptEngineProgID);
		// BUG 295239:
		// If it failed, we still should create an application because the error message
		// "New Application Failed" is too confusing for the user.  This is not a fatal error
		// because it is still (theoretically) possible to run scripts (those with explicit language
		// attributes)  Therefore, we reset the hr to S_OK.

		m_fIsValidProglangCLSID = SUCCEEDED(hr);
		hr = S_OK;
    }

    if (SUCCEEDED(hr) && m_szString[IAppMsg_PARTITIONGUID]) {
        BSTR    pbstrPartitionGUID = NULL;
        hr = SysAllocStringFromSz(m_szString[IAppMsg_PARTITIONGUID], 0, &pbstrPartitionGUID, CP_ACP);
        if (FAILED(hr)) {
            Assert(0);
            hr = S_OK;
        }
        else {
            hr = CLSIDFromString(pbstrPartitionGUID, &m_PartitionGUID);
		    m_fIsValidPartitionGUID = SUCCEEDED(hr);
		    hr = S_OK;
        }
        if (pbstrPartitionGUID)
            SysFreeString(pbstrPartitionGUID);
    }

    if (SUCCEEDED(hr) && fRunOnEndAsAnon()) {

        if (pIReq->ServerSupportFunction(HSE_REQ_GET_UNICODE_ANONYMOUS_TOKEN,
                                         pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL),
                                         (DWORD *)&m_hAnonToken,
                                         NULL) == FALSE) {

            // if the SSF fails, just revert the handle to the INVALID_VALUE.  We could fail
            // here, but we don't really know if this will even be needed as there may not be
            // a global.asa or if there is a global.asa, there might not be OnEnd functions.

            m_hAnonToken = INVALID_HANDLE_VALUE;
        }
    }

	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

	return hr;
}

/*===================================================================
CAppConfig::UnInit

UnInit the CAppConfig.	Only called once.

in:
	None.

Side effects:
	DeAllocate CMDAppConfigSink. disconnect metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::UnInit(void)
{
	for (int iStr = 0; iStr < APP_CONFIG_MESSAGEMAX; iStr++)
	{
		if (m_szString[iStr] != NULL)
		{
			GlobalFree(m_szString[iStr]);
			m_szString[iStr] = NULL;
		}
	}

    if (m_hAnonToken != INVALID_HANDLE_VALUE)
        CloseHandle(m_hAnonToken);
	return S_OK;
}


ULONG  STDMETHODCALLTYPE   CAppConfig::AddRef(void)
{
    ULONG cRef = InterlockedIncrement ((LPLONG)&m_cRefs);

    return cRef;
}

ULONG  STDMETHODCALLTYPE   CAppConfig::Release(void)
{
    ULONG cRef = InterlockedDecrement ((LPLONG)&m_cRefs);

    if (m_cRefs == 0)
        delete this;

    return cRef;
}

/*==================================================================
CAppConfig::SinkNotify

Returns:
	HRESULT	- S_OK on success
Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CAppConfig::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
{
    if (IsShutDownInProgress())
        return S_OK;

	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR 	*wszMDPath = NULL;
    BOOL    fWszMDPathAllocd = FALSE;
	UINT	cSize = 0;
    HRESULT hr = S_OK;
    BOOL    fRestartAppln = FALSE;

    // Lock while we are in here to prevent the appconfig object from being
    // cleaned up underneath of us
    Lock();

#if UNICODE
    wszMDPath = SzMDPath();
    cSize = wcslen(wszMDPath);
	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
        wszMDPath = new WCHAR[cSize+2];
        if (wszMDPath == NULL) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }
        fWszMDPathAllocd = TRUE;
        wcscpy(wszMDPath, SzMDPath());
		wszMDPath[cSize] = L'/';
	    wszMDPath[cSize + 1] = 0;
    }
#else
	CHAR * 	szMDPathT = SzMDPath();

	Assert(szMDPathT != NULL);
	DWORD cbStr = strlen(szMDPathT);
	
	wszMDPath = new WCHAR[cbStr + 2]; // Allow for adding trailing '/' and '\0'
	if (wszMDPath == NULL) {
            hr = E_OUTOFMEMORY;
            goto LExit;
    }
    fWszMDPathAllocd = TRUE;
	cSize = MultiByteToWideChar(CP_ACP, 0, szMDPathT, cbStr, wszMDPath, cbStr + 2);
	if (cSize == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto LExit;
    }

	wszMDPath[cSize] = 0;
	wszMDPath[cSize + 1] = 0;

	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
		wszMDPath[cSize] = L'/';
    }
#endif

	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
	{
		DWORD dwMDChangeType = pcoChangeList[iEventNum].dwMDChangeType;
		if ((dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT) || (dwMDChangeType == MD_CHANGE_TYPE_RENAME_OBJECT))
		{
		    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
		    {
                fRestartAppln = TRUE;
		    }
		}
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, min(cSize, wcslen((LPWSTR)pcoChangeList[iEventNum].pszMDPath))))
		{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
			{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_VR_PATH)
				{
				    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
			        {
                        fRestartAppln = TRUE;
				    }
				}

				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
				{
                    if (fNeedUpdate() == FALSE)
					    NotifyNeedUpdate();
                    if ((pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_ASP_ENABLEAPPLICATIONRESTART)
                        && (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0))
                    {
                        NotifyRestartEnabledUpdated();
					    goto LExit;
                    }
				}
			}
		}
	}

LExit:
    UnLock();

    if (fWszMDPathAllocd)
	    delete [] wszMDPath;

    //
    // The Restart() call an potentially delete the parent (no applications locked)
    // If we restart just as we exit the thread then there is no race condition.
    // The two cases where the race could still occur are covered with the locks on the ApplnMgr. The places are
    // (1) NotifyRestartEnabledUpdate which can be used to restart only from AssignApplnToBrowserRequest which is protected by a g_ApplnMgr.Lock() critsec and
    // (2) Another SinkNotify (which will be on another RPC thread and so protected by the same g_ApplnMgr.Lock() critsec
    //

    if (fRestartAppln)
        m_pAppln->Restart(TRUE);

	return hr;
}

/*===================================================================
CAppConfig::szMDPath


in:
	None

returns:
	LPTSTR: ptr to szmetabsekey

Side effects:
	Get MetabaseKey
===================================================================*/
LPTSTR CAppConfig::SzMDPath()
{
	return m_pAppln->GetMetabaseKey();
}

/*===================================================================
CAppConfig::SetValue


in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT CAppConfig::SetValue(unsigned int iValue, BYTE *pData)
{
    HRESULT hr = S_OK;

	Assert((iValue < IApp_MAX) && (pData != NULL));
	
	switch(iValue) {
        case IApp_CodePage: {
            LONG lCodePage = *(LONG *)pData;
            if (lCodePage == 0)
                lCodePage = GetACP();
			InterlockedExchange((LPLONG)&m_uCodePage, lCodePage);
			break;
        }
			
		case IApp_BufferingOn:
			InterlockedExchange((LPLONG)&m_fBufferingOn, *(LONG *)pData);
			break;

		case IApp_ScriptErrorsSenttoBrowser:
			InterlockedExchange((LPLONG)&m_fScriptErrorsSentToBrowser, *(LONG *)pData);
			break;
			
		case IApp_ScriptErrorMessage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTERROR] != NULL) {
				GlobalFree(m_szString[IAppMsg_SCRIPTERROR]);
			}
			m_szString[IAppMsg_SCRIPTERROR] = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		case IApp_ScriptTimeout:
			InterlockedExchange((LPLONG)&m_dwScriptTimeout, *(LONG *)pData);
			break;
			
		case IApp_SessionTimeout:
			InterlockedExchange((LPLONG)&m_dwSessionTimeout, *(LONG *)pData);
			break;

		case IApp_QueueTimeout:
			InterlockedExchange((LPLONG)&m_dwQueueTimeout, *(LONG *)pData);
			break;

		case IApp_EnableParentPaths:
			InterlockedExchange((LPLONG)&m_fEnableParentPaths, !*(LONG *)pData);
			break;

		case IApp_AllowSessionState:
			InterlockedExchange((LPLONG)&m_fAllowSessionState, *(LONG *)pData);
			break;

		case IApp_ScriptLanguage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL) {
				GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
            }
			m_szString[IAppMsg_SCRIPTLANGUAGE] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL) {
				if('\0' == m_szString[IAppMsg_SCRIPTLANGUAGE][0]) {
                    WCHAR wszString[128];
                    CwchLoadStringOfId(IDS_SCRIPTLANGUAGE, wszString, 128);
					MSG_Warning(MSG_APPL_WARNING_DEFAULT_SCRIPTLANGUAGE, m_pAppln->GetMetabaseKey(), wszString);
					GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
					m_szString[IAppMsg_SCRIPTLANGUAGE] = (LPSTR)GlobalAlloc(GPTR, 128);
					CchLoadStringOfId(IDS_SCRIPTLANGUAGE, (LPSTR)m_szString[IAppMsg_SCRIPTLANGUAGE], 128);
                }
            }
            hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		   											      &m_DefaultScriptEngineProgID);
            GlobStringUseUnLock();
			break;

		case IApp_AllowClientDebug:
			InterlockedExchange((LPLONG)&m_fAllowClientDebug, *(LONG *)pData);
			break;

		case IApp_AllowDebugging:
			InterlockedExchange((LPLONG)&m_fAllowDebugging, *(LONG *)pData);
			break;

		case IApp_EnableApplicationRestart:
			InterlockedExchange((LPLONG)&m_fEnableApplicationRestart, *(LONG *)pData);
			break;

		case IApp_QueueConnectionTestTime:
			InterlockedExchange((LPLONG)&m_dwQueueConnectionTestTime, *(LONG *)pData);
			break;

		case IApp_SessionMax:
			InterlockedExchange((LPLONG)&m_dwSessionMax, *(LONG *)pData);
			break;

		case IApp_ExecuteInMTA:
			InterlockedExchange((LPLONG)&m_fExecuteInMTA, *(LONG *)pData);
			break;

		case IApp_LCID:
			InterlockedExchange((LPLONG)&m_uLCID, *(LONG *)pData);
			break;

        case IApp_KeepSessionIDSecure:
            InterlockedExchange((LPLONG)&m_fKeepSessionIDSecure, *(LONG *)pData);
            break;

        case IApp_CalcLineNumber:
            InterlockedExchange((LPLONG)&m_fCalcLineNumber, *(LONG *)pData);
            break;


        case IApp_ServiceFlags:
            InterlockedExchange((LPLONG)&m_fTrackerEnabled, !!((*(LONG *)pData) & IFlag_SF_TrackerEnabled));
            InterlockedExchange((LPLONG)&m_fSxsEnabled,     !!((*(LONG *)pData) & IFlag_SF_SxsEnabled));
            InterlockedExchange((LPLONG)&m_fUsePartition,   !!((*(LONG *)pData) & IFlag_SF_UsePartition));
            break;

        case IApp_PartitionGUID:
			GlobStringUseLock();
			if (m_szString[IAppMsg_PARTITIONGUID] != NULL) {
				GlobalFree(m_szString[IAppMsg_PARTITIONGUID] );
            }
			m_szString[IAppMsg_PARTITIONGUID] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_PARTITIONGUID] != NULL) {
				if('\0' == m_szString[IAppMsg_PARTITIONGUID][0]) {
					GlobalFree(m_szString[IAppMsg_PARTITIONGUID] );
                    m_szString[IAppMsg_PARTITIONGUID] = NULL;
                }
            }
			GlobStringUseUnLock();
            break;

        case IApp_SxsName:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SXSNAME] != NULL) {
				GlobalFree(m_szString[IAppMsg_SXSNAME] );
            }
			m_szString[IAppMsg_SXSNAME] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_SXSNAME] != NULL) {
				if('\0' == m_szString[IAppMsg_SXSNAME][0]) {
					GlobalFree(m_szString[IAppMsg_SXSNAME] );
                    m_szString[IAppMsg_SXSNAME] = NULL;
                }
            }
			GlobStringUseUnLock();
            break;

        case IApp_RunOnEndAsAnon:
			InterlockedExchange((LPLONG)&m_fRunOnEndAsAnon, *(LONG *)pData);
			break;

		case IApp_BufferLimit:
			InterlockedExchange((LPLONG)&m_dwBufferLimit, *(LONG *)pData);
			break;

   		case IApp_RequestEntityLimit:
			InterlockedExchange((LPLONG)&m_dwRequestEntityLimit, *(LONG *)pData);
			break;

		default:
			break;
	}

	return hr;
}

/*===================================================================
CAppConfig::Update
Update settings in CAppConfig.

in:

returns:
	HRESULT

Side effects:
	Update CAppConfig settings.
===================================================================*/
HRESULT CAppConfig::Update(CIsapiReqInfo    *pIReq)
{
	Glob(Lock);
	if (m_fNeedUpdate == TRUE)
		{
		InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
        m_fRestartEnabledUpdated = FALSE;
		}
	else
		{
		Glob(UnLock);
		return S_OK;
		}
	Glob(UnLock);
	return ReadConfigFromMD(pIReq, this, FALSE);
}

/*===================================================================
CAspRegistryParams::Init

Read the registry based ASP Parameters

in:

returns:
	void

===================================================================*/
void CAspRegistryParams::Init()
{
	HKEY		hkey = NULL;
    DWORD       dwType;
    DWORD       cbData;

    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\ASP\\Parameters", 0, KEY_READ, &hkey) != ERROR_SUCCESS)
        return;

    // get DisableF5Attack

    cbData = sizeof(DWORD);
    m_fF5AttackValuePresent = RegQueryValueExA(hkey, "F5AttackDetectionEnabled", 0, &dwType, (LPBYTE)&m_dwF5AttackValue, &cbData) == NO_ERROR;

    // get HangDetRequestThreshold

    cbData = sizeof(DWORD);
    m_fHangDetRequestThresholdPresent = RegQueryValueExA(hkey, "HangDetRequestThreshold", 0, &dwType, (LPBYTE)&m_dwHangDetRequestThreshold, &cbData) == NO_ERROR;

    // get HangDetThreadHungThreshold

    cbData = sizeof(DWORD);
    m_fHangDetThreadHungThresholdPresent = RegQueryValueExA(hkey, "HangDetThreadHungThreshold", 0, &dwType, (LPBYTE)&m_dwHangDetThreadHungThreshold, &cbData) == NO_ERROR;

    // get HangDetConsecIllStatesThreshold

    cbData = sizeof(DWORD);
    m_fHangDetConsecIllStatesThresholdPresent = RegQueryValueExA(hkey, "HangDetConsecIllStatesThreshold", 0, &dwType, (LPBYTE)&m_dwHangDetConsecIllStatesThreshold, &cbData) == NO_ERROR;

    // get HangDetEnabled

    cbData = sizeof(DWORD);
    m_fHangDetEnabledPresent = RegQueryValueExA(hkey, "HangDetEnabled", 0, &dwType, (LPBYTE)&m_dwHangDetEnabled, &cbData) == NO_ERROR;

    // get EnableChangeNotificationForUNC

    cbData = sizeof(DWORD);
    m_fChangeNotificationForUNCPresent = RegQueryValueExA(hkey, "EnableChangeNotificationForUNC", 0, &dwType, (LPBYTE)& m_dwChangeNotificationForUNC, &cbData) == NO_ERROR;

    // get FileMonitoringEnabled

    cbData = sizeof(DWORD);
    m_fFileMonitoringEnabledPresent = RegQueryValueExA(hkey, "FileMonitoringEnabled", 0, &dwType, (LPBYTE)&m_dwFileMonitoringEnabled, &cbData) == NO_ERROR;

    // get FileMonitoringTimeout

    cbData = sizeof(DWORD);
    m_fFileMonitoringTimeoutSecondsPresent = RegQueryValueExA(hkey, "FileMonitoringTimeoutSeconds", 0, &dwType, (LPBYTE)&m_dwFileMonitoringTimeoutSeconds, &cbData) == NO_ERROR;

    // get MaxCSR

    cbData = sizeof(DWORD);
    m_fMaxCSRPresent = RegQueryValueExA(hkey, "MaxCSR", 0, &dwType, (LPBYTE)&m_dwMaxCSR, &cbData) == NO_ERROR;

    // get MaxCPU

    cbData = sizeof(DWORD);
    m_fMaxCPUPresent = RegQueryValueExA(hkey, "MaxCPU", 0, &dwType, (LPBYTE)&m_dwMaxCPU, &cbData) == NO_ERROR;

    // get DisableOOMRecycle

    cbData = sizeof(DWORD);
    m_fDisableOOMRecyclePresent = RegQueryValueExA(hkey, "DisableOOMRecycle", 0, &dwType, (LPBYTE)&m_dwDisableOOMRecycle, &cbData) == NO_ERROR;

    // get DisableLazyContentPropagation

    cbData = sizeof(DWORD);
    m_fDisableLazyContentPropagationPresent = RegQueryValueExA(hkey, "DisableLazyContentPropagation", 0, &dwType, (LPBYTE)&m_dwDisableLazyContentPropagation, &cbData) == NO_ERROR;

    // get ThreadMax

    cbData = sizeof(DWORD);
    m_fTotalThreadMaxPresent = RegQueryValueExA(hkey, "ThreadMax", 0, &dwType, (LPBYTE)&m_dwTotalThreadMax, &cbData) == NO_ERROR;

    // get DisableComPlusCpuMetric

    cbData = sizeof(DWORD);
    m_fDisableComPlusCpuMetricPresent = RegQueryValueExA(hkey, "DisableComPlusCpuMetric", 0, &dwType, (LPBYTE)&m_dwDisableComPlusCpuMetric, &cbData) == NO_ERROR;

    RegCloseKey(hkey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef _ASP_GIP_H
#define _ASP_GIP_H

/*===================================================================
  Includes
===================================================================*/

#include "debug.h"

/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class CGlobalInterfaceAPI
    {
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#ifdef DBG
	inline void AssertValid() const
	    {
        Assert(m_fInited);
        Assert(m_pGIT);
	    }
#else
	inline void AssertValid() const {}
#endif
    };

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register
(
IUnknown *pUnk,
REFIID riid,
DWORD *pdwCookie
)
{
    HRESULT             hr = S_OK;
    IUnknown            *pUnkTemp = NULL;
    IClientSecurity     * pICS = NULL;
    DWORD               dwAuthnSvc = RPC_C_AUTHN_DEFAULT;
    DWORD               dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;
    OLECHAR             *pwszServerPrincName = NULL;
    DWORD               dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
    DWORD               dwImpLevel = RPC_C_IMP_LEVEL_DEFAULT;
    RPC_AUTH_IDENTITY_HANDLE AuthInfo = NULL;
    DWORD               dwCapabilities = EOAC_DEFAULT;

    Assert(m_fInited);
    Assert(m_pGIT);
    
    hr = pUnk->QueryInterface(IID_IUnknown, (VOID**)&pUnkTemp);
    if (SUCCEEDED(hr))
    {
        hr = pUnkTemp->QueryInterface( IID_IClientSecurity, (VOID**) &pICS );
        if (SUCCEEDED(hr))
        {
            hr = pICS->QueryBlanket( pUnkTemp,
                                 &dwAuthnSvc,
                                 &dwAuthzSvc,
                                 &pwszServerPrincName,
                                 &dwAuthnLevel,
                                 &dwImpLevel,
                                 &AuthInfo,
                                 &dwCapabilities );
            if (SUCCEEDED(hr))
            {
                dwCapabilities &= ~EOAC_DYNAMIC_CLOAKING;
                dwCapabilities |= EOAC_STATIC_CLOAKING;
                hr = pICS->SetBlanket( pUnkTemp,
                                       dwAuthnSvc,
                                       dwAuthzSvc,
                                       pwszServerPrincName,
                                       dwAuthnLevel,
                                       dwImpLevel,
                                       AuthInfo,
                                       dwCapabilities );
            }
        }
        else
        {
            hr = S_OK;
        }  
    }
        
    if (SUCCEEDED(hr))
    {
        hr = m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
    }

    if (pwszServerPrincName)
    {
        CoTaskMemFree( pwszServerPrincName );
    }
    
    if (pICS)
    {
        pICS->Release();
        pICS = NULL;
    }
    
    if (pUnkTemp)
    {
        pUnkTemp->Release();
        pUnkTemp = NULL;
    }

    return hr;
}       

inline HRESULT CGlobalInterfaceAPI::Get
(
DWORD dwCookie,
REFIID riid, 
void **ppv
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
    }
        
inline HRESULT CGlobalInterfaceAPI::Revoke
(
DWORD dwCookie
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    }

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\glob.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __Glob_H
#define __Glob_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}

//
//  BUGBUG:: We can have only one instance of CMDGlobConfigSink.
//  ASP Just requires one instance of this object and because we signal a global variable
//  in its destructor. Having multiple instances will cause a bug. Evaluate a change of design, behaviour
//  in case it becomes absolutely necessary that this class needs more instances
//
class CMDGlobConfigSink : public IMSAdminBaseSinkW
        {
        private:
        INT                     m_cRef;
        public:

        CMDGlobConfigSink ();
		~CMDGlobConfigSink();		

        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        };
#define IGlob_LogErrorRequests                                  0x0
#define IGlob_ScriptFileCacheSize                               0x1
#define IGlob_ScriptEngineCacheMax                              0x2
#define IGlob_ExceptionCatchEnable                              0x3
#define IGlob_TrackThreadingModel                               0x4
#define IGlob_AllowOutOfProcCmpnts                              0x5
// IIS5.0
#define IGlob_EnableAspHtmlFallback                             0x6
#define IGlob_EnableChunkedEncoding                             0x7
#define IGlob_EnableTypelibCache                                0x8
#define IGlob_ErrorsToNtLog                                     0x9
#define IGlob_ProcessorThreadMax                                0xa
#define IGlob_RequestQueueMax                                   0xb
#define IGlob_PersistTemplateMaxFiles                           0xc
#define IGlob_PersistTemplateDir                                0xd
#define IGlob_MAX                                               0xe

//forward declaration
class CAppConfig;
//      Glob data object
class CGlob
        {
private:
        // Friends that can access the private data, they are the functions setting the global data.
        friend          HRESULT CacheStdTypeInfos();
        friend          HRESULT ReadConfigFromMD(CIsapiReqInfo  *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend          HRESULT SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

        //Private Data
        ITypeLib                        *m_pITypeLibDenali;     // Denali's type library
        ITypeLib                        *m_pITypeLibTxn;        // Denali's type library
        DWORD                           m_dwNumberOfProcessors;
        BOOL                            m_fInited;
        BOOL                            m_fMDRead;				// Has Metadata been read at least once
        BOOL                            m_fNeedUpdate;          // FALSE, needs reload config data from metabase

        // Metadata configuration settings per dll
        DWORD                           m_dwScriptEngineCacheMax;
        DWORD                           m_dwScriptFileCacheSize;
        BOOL                            m_fLogErrorRequests;
        BOOL                            m_fExceptionCatchEnable;
        BOOL                            m_fAllowDebugging;
        BOOL                            m_fAllowOutOfProcCmpnts;
        BOOL                            m_fTrackThreadingModel;
        DWORD                           m_dwMDSinkCookie;
        CMDGlobConfigSink              *m_pMetabaseSink;
        IMSAdminBase                   *m_pMetabase;

        BOOL    m_fEnableAspHtmlFallBack;
		BOOL    m_fEnableTypelibCache;
		BOOL    m_fEnableChunkedEncoding;
		BOOL    m_fDupIISLogToNTLog;
        DWORD   m_dwRequestQueueMax;
		DWORD   m_dwProcessorThreadMax;
        LPSTR   m_pszPersistTemplateDir;
        DWORD   m_dwPersistTemplateMaxFiles;


        CRITICAL_SECTION        m_cs;                           // Glob Strings need to be protected by CriticalSection

                                                                                    // Functions Pointers for WINNT & WIN95 singal binary compatibility
        //Private functions
        HRESULT         SetGlobValue(unsigned int index, BYTE *lpByte);

public:
        CGlob();

        HRESULT         MDInit(void);
        HRESULT         MDUnInit(void);


public:
        ITypeLib*       pITypeLibDenali()                       {return m_pITypeLibDenali;};            // Denali's type library
        ITypeLib*       pITypeLibTxn()                          {return m_pITypeLibTxn;};            // Denali's type library
	    DWORD           dwNumberOfProcessors()                  {return m_dwNumberOfProcessors;};
    	BOOL            fNeedUpdate()                           {return (BOOLB)m_fNeedUpdate;};
        void            NotifyNeedUpdate();
        DWORD           dwScriptEngineCacheMax()                {return m_dwScriptEngineCacheMax;};
        DWORD           dwScriptFileCacheSize()                 {return m_dwScriptFileCacheSize;};
        BOOLB           fLogErrorRequests()                     {return (BOOLB)m_fLogErrorRequests;};
        BOOLB           fInited()                               {return (BOOLB)m_fInited;};
        BOOLB           fMDRead()                               {return (BOOLB)m_fMDRead;};
        BOOLB           fTrackThreadingModel()                  {return (BOOLB)m_fTrackThreadingModel;};
        BOOLB     		fExceptionCatchEnable()	    		    {return (BOOLB)m_fExceptionCatchEnable;};
        BOOLB     		fAllowOutOfProcCmpnts() 	        	{return (BOOLB)m_fAllowOutOfProcCmpnts;};

        BOOL    fEnableAspHtmlFallBack()   { return m_fEnableAspHtmlFallBack; }
		BOOL    fEnableTypelibCache()      { return m_fEnableTypelibCache; }
		BOOL    fEnableChunkedEncoding()   { return m_fEnableChunkedEncoding; }  // UNDONE: temp.
		BOOL    fDupIISLogToNTLog()        { return m_fDupIISLogToNTLog; }
        DWORD   dwRequestQueueMax()        { return m_dwRequestQueueMax; }
		DWORD   dwProcessorThreadMax()     { return m_dwProcessorThreadMax; }
        DWORD   dwPersistTemplateMaxFiles(){ return m_dwPersistTemplateMaxFiles; }
        LPSTR   pszPersistTemplateDir()    { return m_pszPersistTemplateDir; }

        void            Lock()                                  {EnterCriticalSection(&m_cs);};
        void            UnLock()                                {LeaveCriticalSection(&m_cs);};
        HRESULT         GlobInit(void);
        HRESULT         GlobUnInit(void);

        //Used in Scriptmgr for hashing table setup.
        DWORD           dwThreadMax()                                   {return 10;};
        //Used in ScriptKiller for script killer thread to wake up, might rename this to be
        //ScriptCleanupInterval.
        DWORD           dwScriptTimeout()                               {return 90;};

        HRESULT                     Update(CIsapiReqInfo  *pIReq);

};

inline HRESULT CGlob::Update(CIsapiReqInfo  *pIReq)
{
        Lock();
        if (m_fNeedUpdate == TRUE)
                {
                InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
                }
        else
                {
                UnLock();
                return S_OK;
                }
        UnLock();
        return ReadConfigFromMD(pIReq, NULL, TRUE);
}

inline void CGlob::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}

typedef class CGlob GLOB;
extern class CGlob gGlob;

//      General Access functions.(Backward compatibility).
//      Any non-friends functions should use and only use the following methods. Same macros as before.
//      If elem is a glob string, then, GlobStringUseLock() should be called before the string usage.
//      And GlobStringUseUnLock() should be called after.  The critical section is supposed to protect
//      not only the LPTSTR of global string, but also the memory that LPTSTR points to.
//      Making local copy of global string is recommended.
#define Glob(elem)                              (gGlob.elem())
#define GlobStringUseLock()             (gGlob.Lock())
#define GlobStringUseUnLock()   (gGlob.UnLock())

// class to hold registry based ASP Parameters

class CAspRegistryParams
{
public:
    CAspRegistryParams()
    {
        m_fF5AttackValuePresent = FALSE;
        m_fHangDetRequestThresholdPresent = FALSE;
        m_fHangDetThreadHungThresholdPresent = FALSE;
        m_fHangDetConsecIllStatesThresholdPresent = FALSE;
        m_fHangDetEnabledPresent = FALSE;
        m_fChangeNotificationForUNCPresent = FALSE;
        m_fFileMonitoringEnabledPresent = FALSE;
        m_fFileMonitoringTimeoutSecondsPresent = FALSE;
        m_fMaxCSRPresent = FALSE;
        m_fMaxCPUPresent = FALSE;
        m_fDisableOOMRecyclePresent = FALSE;
        m_fDisableLazyContentPropagationPresent = FALSE;
        m_fTotalThreadMaxPresent = FALSE;
        m_fDisableComPlusCpuMetricPresent = FALSE;
    }

    void        Init();

    HRESULT     GetF5AttackValue(DWORD *pdwResult);
    HRESULT     GetHangDetRequestThreshold(DWORD  *pdwResult);
    HRESULT     GetHangDetThreadHungThreshold(DWORD  *pdwResult);
    HRESULT     GetHangDetConsecIllStatesThreshold(DWORD  *pdwResult);
    HRESULT     GetHangDetEnabled(DWORD  *pdwResult);
    HRESULT     GetChangeNotificationForUNCEnabled(DWORD  *pdwResult);
    HRESULT     GetFileMonitoringEnabled(DWORD  *pdwResult);
    HRESULT     GetFileMonitoringTimeout(DWORD  *pdwResult);
    HRESULT     GetMaxCSR(DWORD  *pdwResult);
    HRESULT     GetMaxCPU(DWORD  *pdwResult);
    HRESULT     GetDisableOOMRecycle(DWORD  *pdwResult);
    HRESULT     GetDisableLazyContentPropagation(DWORD  *pdwResult);
    HRESULT     GetTotalThreadMax(DWORD *pdwResult);
    HRESULT     GetDisableComPlusCpuMetric(DWORD *pdwResult);

private:

    DWORD       m_fF5AttackValuePresent : 1;
    DWORD       m_fHangDetRequestThresholdPresent : 1;
    DWORD       m_fHangDetThreadHungThresholdPresent : 1;
    DWORD       m_fHangDetConsecIllStatesThresholdPresent : 1;
    DWORD       m_fHangDetEnabledPresent : 1;
    DWORD       m_fChangeNotificationForUNCPresent : 1;
    DWORD       m_fFileMonitoringEnabledPresent : 1;
    DWORD       m_fFileMonitoringTimeoutSecondsPresent : 1;
    DWORD       m_fMaxCSRPresent : 1;
    DWORD       m_fMaxCPUPresent : 1;
    DWORD       m_fDisableOOMRecyclePresent : 1;
    DWORD       m_fDisableLazyContentPropagationPresent : 1;
    DWORD       m_fTotalThreadMaxPresent : 1;
    DWORD       m_fDisableComPlusCpuMetricPresent : 1;


    DWORD       m_dwF5AttackValue;
    DWORD       m_dwHangDetRequestThreshold;
    DWORD       m_dwHangDetThreadHungThreshold;
    DWORD       m_dwHangDetConsecIllStatesThreshold;
    DWORD       m_dwHangDetEnabled;
    DWORD       m_dwChangeNotificationForUNC;
    DWORD       m_dwFileMonitoringEnabled;
    DWORD       m_dwFileMonitoringTimeoutSeconds;
    DWORD       m_dwMaxCSR;
    DWORD       m_dwMaxCPU;
    DWORD       m_dwDisableOOMRecycle;
    DWORD       m_dwDisableLazyContentPropagation;
    DWORD       m_dwTotalThreadMax;
    DWORD       m_dwDisableComPlusCpuMetric;

};

inline HRESULT CAspRegistryParams::GetF5AttackValue(DWORD  *pdwResult)
{
    if (m_fF5AttackValuePresent) {
        *pdwResult = m_dwF5AttackValue;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}
inline HRESULT CAspRegistryParams::GetHangDetRequestThreshold(DWORD  *pdwResult)
{
    if (m_fHangDetRequestThresholdPresent) {
        *pdwResult = m_dwHangDetRequestThreshold;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}
inline HRESULT CAspRegistryParams::GetHangDetThreadHungThreshold(DWORD  *pdwResult)
{
    if (m_fHangDetThreadHungThresholdPresent) {
        *pdwResult = m_dwHangDetThreadHungThreshold;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}
inline HRESULT CAspRegistryParams::GetHangDetConsecIllStatesThreshold(DWORD  *pdwResult)
{
    if (m_fHangDetConsecIllStatesThresholdPresent) {
        *pdwResult = m_dwHangDetConsecIllStatesThreshold;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}
inline HRESULT CAspRegistryParams::GetHangDetEnabled(DWORD  *pdwResult)
{
    if (m_fHangDetEnabledPresent) {
        *pdwResult = m_dwHangDetEnabled;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetChangeNotificationForUNCEnabled(DWORD  *pdwResult)
{
    if (m_fChangeNotificationForUNCPresent) {
        *pdwResult = m_dwChangeNotificationForUNC;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetFileMonitoringEnabled(DWORD  *pdwResult)
{
    if (m_fFileMonitoringEnabledPresent) {
        *pdwResult = m_dwFileMonitoringEnabled;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetFileMonitoringTimeout(DWORD  *pdwResult)
{
    if (m_fFileMonitoringTimeoutSecondsPresent) {
        *pdwResult = m_dwFileMonitoringTimeoutSeconds;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetMaxCSR(DWORD *pdwResult)
{

    if (m_fMaxCSRPresent) {
        *pdwResult = m_dwMaxCSR;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetMaxCPU(DWORD *pdwResult)
{

    if (m_fMaxCPUPresent) {
        *pdwResult = m_dwMaxCPU;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetDisableOOMRecycle(DWORD  *pdwResult)
{
    if (m_fDisableOOMRecyclePresent) {
        *pdwResult = m_dwDisableOOMRecycle;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetDisableLazyContentPropagation(DWORD  *pdwResult)
{
    if (m_fDisableLazyContentPropagationPresent) {
        *pdwResult = m_dwDisableLazyContentPropagation;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetTotalThreadMax(DWORD  *pdwResult)
{
    if (m_fTotalThreadMaxPresent) {
        *pdwResult = m_dwTotalThreadMax;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}

inline HRESULT CAspRegistryParams::GetDisableComPlusCpuMetric(DWORD  *pdwResult)
{
    if (m_fDisableComPlusCpuMetricPresent) {
        *pdwResult = m_dwDisableComPlusCpuMetric;
        return S_OK;
    }

    return HRESULT_FROM_WIN32( ERROR_NO_DATA );
}


extern CAspRegistryParams   g_AspRegistryParams;
HRESULT GetMetabaseIF(IMSAdminBase **hMetabase);

#endif // __Glob_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\hashing.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.h

Owner: PramodD

This is the Link list and Hash table class header file.
===================================================================*/

#ifndef HASHING_H
#define HASHING_H

// General purpose hash function
typedef DWORD (*HashFunction)( const BYTE *pBytes, int cBytes );

// Default hash function
extern DWORD DefaultHash( const BYTE *pBytes, int cBytes );

// unicode hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD UnicodeUpcaseHash( const BYTE *pKey, int cbKey );

// multi-byte ucase hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD MultiByteUpcaseHash( const BYTE *pKey, int cbKey );

// Cache pointers. The 4-byte address is the DWORD.
extern DWORD PtrHash( const BYTE *pKey, int );

// CLSID hashing.
extern DWORD CLSIDHash( const BYTE *pKey, int );

/*
The CLinkElem class is intended to be used as a base class for
other link lists and/or hash table implementations.

The name is used for identification and search purposes.

The previous and next pointers are used for traversal.

The Info member is the number of elements in bucket following
this element.

*/

struct CLinkElem
{
	BYTE *		m_pKey;		// Unique key - unknown datatype
	short		m_cbKey;	// length of the key
	short		m_Info;		// Link list element info
	CLinkElem *	m_pPrev;	// Previous element in link list
	CLinkElem *	m_pNext;	// Next element in link list

			CLinkElem();
	virtual	~CLinkElem() {} // Did not allocate so we do not delete
	HRESULT	Init(void *pKey, int cKeyLen);
};

/*
This Hash Table class is used to store and find Named elements
of the type CLinkElem. Classes derived from CLinkElem can use
this class.

The principal requirements for the implementation are:
	Speed of search
	Forward and backward traversal through stored elements

The expected use of this class is as follows.

The user calls the Init method with a size argument to indicate
the number of buckets.

CLinkElems are added to the Hash table using AddElem()

CLinkElems are searched for by name using FindElemByName()

CLinkElems are searched for by index using FindElemByIndex()

CLinkElems are removed by name using DeleteElem()

Reference counting should be implemented by the class derived
from CLinkElem.
*/

#define PREALLOCATED_BUCKETS_MAX    25

class CHashTable
{
protected:
	DWORD				m_fInited : 1;
	DWORD               m_fBucketsAllocated : 1;
	CLinkElem *			m_pHead;
	CLinkElem *			m_pTail;
	CLinkElem **		m_rgpBuckets;
	HashFunction		m_pfnHash;
	UINT				m_cBuckets;
	UINT				m_Count;
	CLinkElem *         m_rgpBucketsBuffer[PREALLOCATED_BUCKETS_MAX];

protected:
    HRESULT             AllocateBuckets();
	virtual BOOL		FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

// inline access functions
public:
	CLinkElem *			Head(void);
	CLinkElem *			Tail(void);
	UINT				Buckets(void);
	UINT				Count(void);

public:
						CHashTable(HashFunction = DefaultHash);
	virtual				~CHashTable(void); // We allocate and need a destructor
	HRESULT				Init(UINT cBuckets = 11);
	HRESULT				UnInit(void);
	void				ReInit();
	CLinkElem *			AddElem(CLinkElem *pElem, BOOL fTestDups = TRUE);
	CLinkElem *			FindElem(const void *pKey, int cKeyLen);
	CLinkElem *			DeleteElem(const void *pKey, int cKeyLen);
	CLinkElem * 		RemoveElem( CLinkElem *pLE );

	void				AssertValid() const;
};

inline CLinkElem *	CHashTable::Head(void) { return m_pHead; }
inline CLinkElem *	CHashTable::Tail(void) { return m_pTail; }
inline UINT			CHashTable::Buckets(void) { return m_cBuckets; }
inline UINT			CHashTable::Count(void) { return m_Count; }

#ifndef DBG
inline void CHashTable::AssertValid() const {}
#endif


/*
 * CHashTableStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to Unicode strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableStr(HashFunction = UnicodeUpcaseHash);

};


/*
 * CHashTableMBStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to multi-byte strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableMBStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableMBStr(HashFunction = MultiByteUpcaseHash);

};

/*
 * CHashTablePtr
 *
 * CHashTable where but the elements are hashed by pointers
 * used as DWORD hash values
 */
class CHashTablePtr : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTablePtr(HashFunction = PtrHash);
};

/*
 * CHashTableCLSID
 *
 * CHashTable where but the elements are hashed by CLSIDs
 */
class CHashTableCLSID : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTableCLSID(HashFunction = CLSIDHash);
};

#endif // HASHING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\hitobj.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: Hitobj.cpp

Owner: DmitryR


This file contains the CHitObj class implementation.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "exec.h"
#include "mtacb.h"
#include "perfdata.h"
#include "debugger.h"
#include "asperror.h"

#include "memchk.h"

#ifdef SCRIPT_STATS

# define REG_ASP_DEBUG_LOCATION "System\\CurrentControlSet\\Services\\W3Svc\\ASP"

# define REG_STR_QUEUE_DEBUG_THRESHOLD "QueueDebugThreshold"
# define REG_DEF_QUEUE_DEBUG_THRESHOLD 25
DWORD g_dwQueueDebugThreshold = 0; // REG_DEF_QUEUE_DEBUG_THRESHOLD;

# define REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD "SendScriptlessOnAtqThread"
# define REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD 1
DWORD g_fSendScriptlessOnAtqThread = REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD;

void
ReadRegistrySettings()
{
    HKEY hkey = NULL;
    DWORD dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_ASP_DEBUG_LOCATION,
                               0, KEY_READ, &hkey);
    if (dwErr == NO_ERROR)
    {
        DWORD dwType, dwBuffer;
        DWORD cbBuffer = sizeof(dwBuffer);

        dwErr = RegQueryValueEx(hkey, REG_STR_QUEUE_DEBUG_THRESHOLD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_dwQueueDebugThreshold = dwBuffer;

        dwErr = RegQueryValueEx(hkey, REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_fSendScriptlessOnAtqThread = dwBuffer;

        RegCloseKey(hkey);
    }

    char szTemp[200];
    sprintf(szTemp, "RRS, err = %d, QueueDebugThreshold = %d, SendScriptlessOnAtqThread = %d\n",
            dwErr, g_dwQueueDebugThreshold, g_fSendScriptlessOnAtqThread);
    OutputDebugString(szTemp);
}


CSmallSpinLock g_lockRequestStats;
LONG           g_cRequests = 0;
LONG           g_cScriptlessRequests = 0;
LONG           g_cHttpExtensionsExecuting = 0;
LONG           g_cConcurrentScriptlessRequests = 0;
LONG           g_cMaxConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumExecTimeScriptlessRequests = 0;
LONG           g_nAvgConcurrentScriptlessRequests = 0;
LONG           g_nAvgExecTimeScriptlessRequests = 0;

#endif // SCRIPT_STATS

DWORD g_nBrowserRequests = 0;
DWORD g_nSessionCleanupRequests = 0;
DWORD g_nApplnCleanupRequests = 0;
LONG  g_nRequestsHung = 0;

IGlobalInterfaceTable *g_pGIT = NULL;

IASPObjectContext  *g_pIASPDummyObjectContext = NULL;

/*===================================================================
CHitObj::CHitObj

Constructor 

Parameters:
    NONE

Returns:
    NONE
===================================================================*/   
CHitObj::CHitObj()
  : m_fInited(FALSE),
    m_ehtType(ehtUnInitedRequest),
    m_hImpersonate(NULL),
    m_pIReq(NULL),
    m_pResponse(NULL),
    m_pRequest(NULL),
    m_pServer(NULL),
    m_pASPObjectContext(NULL),
    m_punkScriptingNamespace(NULL),
    m_pPageCompCol(NULL),
    m_pPageObjMgr(NULL),
    m_pActivity(NULL),
    m_ecsActivityScope(csUnknown),
    m_SessionId(INVALID_ID, 0, 0),
    m_pSession(NULL),
    m_pAppln(NULL),
    m_fRunGlobalAsa(FALSE),
    m_fStartSession(FALSE),
    m_fNewCookie(FALSE),
    m_fStartApplication(FALSE),
    m_fApplnOnStartFailed(FALSE),
    m_fClientCodeDebug(FALSE),
    m_fCompilationFailed(FALSE),
    m_fExecuting(FALSE),
    m_fHideRequestAndResponseIntrinsics(FALSE),
    m_fHideSessionIntrinsic(FALSE),
    m_fDoneWithSession(FALSE),
    m_fRejected(FALSE),
    m_f449Done(FALSE),
    m_fInTransferOnError(FALSE),
    m_pScriptingContext(NULL),
    m_nScriptTimeout(0),
    m_eExecStatus(eExecSucceeded),
    m_eEventState(eEventNone),
    m_uCodePage(CP_ACP),
    m_lcid(LOCALE_SYSTEM_DEFAULT),
    m_dwtTimestamp(0),
    m_pEngineInfo(NULL),
    m_pdispTypeLibWrapper(NULL),
    m_szCurrTemplateVirtPath(NULL),
    m_szCurrTemplatePhysPath(NULL),
    m_pASPError(NULL),
    m_pTemplate(NULL),
    m_fSecure(FALSE),
    m_fRequestTimedout(FALSE)
    {
        m_uCodePage = GetACP();
    }

/*===================================================================
CHitObj::~CHitObj

Destructor

Parameters:
    None 

Returns:
    None
===================================================================*/
CHitObj::~CHitObj( void )
    {
    Assert(!m_fExecuting); // no deletes while still executing

    if (FIsBrowserRequest())
        {
        if (m_hImpersonate != NULL)
            m_hImpersonate = NULL;
            
        if (m_pSession)
            DetachBrowserRequestFromSession();
        }

    if (m_pASPError) // Error object
        {
        m_pASPError->Release();
        m_pASPError = NULL;
        }
        
    if (m_pActivity) // page-level Viper activity
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    StopComponentProcessing();

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    // update request counters in application and session manager
    
    if (m_pAppln)
        {
        if (FIsBrowserRequest())
            {
            m_pAppln->DecrementRequestCount();
            }
        else if (FIsSessionCleanupRequest() && m_pAppln->PSessionMgr())
            {
            m_pAppln->PSessionMgr()->DecrementSessionCleanupRequestCount();
            }
        }

    if (m_pTemplate)
        m_pTemplate->Release();

    // update global request counters
    
    if (FIsBrowserRequest())
        InterlockedDecrement((LPLONG)&g_nBrowserRequests);
    else if (FIsSessionCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nSessionCleanupRequests);
    else if (FIsApplnCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nApplnCleanupRequests);

    if (m_pIReq)
        m_pIReq->Release();

}

/*===================================================================
CHitObj::NewBrowserRequest

Static method. Creates, Inits, Posts new browser request

Parameters:
    pIReq           CIsapiReqInfo
    pfRejected      [out] TRUE if rejected  (optional)
    pfCompeleted    [out] TRUE if comleted  (optional)
    piErrorId       [out] error id          (optional)

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::NewBrowserRequest
(
CIsapiReqInfo *pIReq,
BOOL *pfRejected,
BOOL *pfCompleted,
int  *piErrorId
)
    {
    HRESULT hr = S_OK;
    BOOL fRejected = FALSE;
    BOOL fCompleted = FALSE;
    int  iError = 0;

    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
            hr = pHitObj->BrowserRequestInit(pIReq, &iError);

            if (SUCCEEDED(hr))
                {
                if (pHitObj->FDoneWithSession())
                    {
                    // finished while on I/O thread
                    fCompleted = TRUE;
                    delete pHitObj;
                    pHitObj = NULL;
                    }
                }
            else // if FAILED
                {
                if (iError == IDE_SERVER_TOO_BUSY)
                    fRejected = TRUE;
                }
            
        }

    // Post into Viper
    if (SUCCEEDED(hr) && !fCompleted)
        {
        hr = pHitObj->PostViperAsyncCall();

        if (FAILED(hr))
            fRejected = TRUE;
        }

    if (FAILED(hr) && pHitObj)
    {       
        pHitObj->m_fRejected = TRUE;
        delete pHitObj;
    }

    if (pfRejected)
        *pfRejected = fRejected;
    if (pfCompleted)
        *pfCompleted = fCompleted;
    if (piErrorId)
        *piErrorId = iError;
    
    return hr;
}

/*===================================================================
HRESULT CHitObj::SetCodePage

Set Runtime CodePage, if fAllowSessionState is On, this will set 
Session.CodePage and we should always use Session.CodePage when we
call HitObj.GetCodePage when fAllowSessionState on.

HitObj.CodePage is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    UINT    uCodePage

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetCodePage(UINT uCodePage)
{
    HRESULT hr = S_OK;
    
    if (uCodePage == CP_ACP || IsValidCodePage(uCodePage))
        {
        m_uCodePage = uCodePage == CP_ACP ? GetACP() : uCodePage;

        // If engine info is available, notify the scripts engines that the code
        // page has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoCodePage); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::SetLCID

Set Runtime LCID, if fAllowSessionState is On, this will set 
Session.LCID and we should always use Session.LCID when we
call HitObj.LCID when fAllowSessionState on.

HitObj.LCID is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    LCID    lcid

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetLCID(LCID lcid)
{
    HRESULT hr = S_OK;

    if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
        {
        m_lcid = lcid;

        // If engine info is available, notify the scripts engines that the
        // lcid has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoLocale); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::BrowserRequestInit

Initialize the request object

Parameters:
    CIsapiReqInfo   *pIReq
    int *pErrorId

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::BrowserRequestInit
(
CIsapiReqInfo   *pIReq,
int  *pErrorId 
)
    {
    HRESULT hr;

    m_pIReq = pIReq;

    m_pIReq->AddRef();

    m_ehtType = ehtBrowserRequest;
    InterlockedIncrement((LPLONG)&g_nBrowserRequests);

#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cRequests);
#endif // SCRIPT_STATS

    STACK_BUFFER( serverPortSecureBuff, 8 );
    DWORD cbServerPortSecure;
    if( !SERVER_GET (pIReq,"SERVER_PORT_SECURE", &serverPortSecureBuff, &cbServerPortSecure))
    {
        if (GetLastError() == ERROR_OUTOFMEMORY) 
        {
            return E_OUTOFMEMORY;
        }
    }
    char *szServerPortSecure = (char *)serverPortSecureBuff.QueryPtr();
    m_fSecure = (szServerPortSecure[0] == '1' );

    // Ask W3SVC for the impersonation token so we can later impersonate on Viper's thread
    m_hImpersonate = m_pIReq->QueryImpersonationToken();

    // Uppercase path - BUGBUG - can't Normalize in place!!!!
    Normalize(m_pIReq->QueryPszPathTranslated());

    // Reject direct requests for global.asa file
    if (FIsGlobalAsa(m_pIReq->QueryPszPathTranslated(), m_pIReq->QueryCchPathTranslated()))
        {
        *pErrorId = IDE_GLOBAL_ASA_FORBIDDEN;
        return E_FAIL;
        }

    // Attach to application (or create a new one)
    BOOL fApplnRestarting = FALSE;
    hr = AssignApplnToBrowserRequest(&fApplnRestarting);
    if (FAILED(hr))
        {
		*pErrorId = fApplnRestarting ? IDE_GLOBAL_ASA_CHANGED
									 : IDE_ADD_APPLICATION;
        return E_FAIL;
        }

    // Create page component collection
    hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        *pErrorId = (hr == E_OUTOFMEMORY) ? IDE_OOM : IDE_INIT_PAGE_LEVEL_OBJ;
        return hr;
        }

    // Get Session cookie, and misc flags from http header
    hr = ParseCookiesForSessionIdAndFlags();
    if (FAILED(hr)) // no cookie is not an error -- failed here means OOM
        return hr;

    // Remember script timeout value
    m_nScriptTimeout = m_pAppln->QueryAppConfig()->dwScriptTimeout();

    // Check if the session is needed
    BOOL fAllowSessions = m_pAppln->QueryAppConfig()->fAllowSessionState();
    BOOL fNeedSession = fAllowSessions;

    // Look if the template is cached
    CTemplate *pTemplate = NULL;

    //
    // Find in cache - don't load if not in cache already
    // NOTE: This code path does not validate the source files (does not check if they were modified if Change Notifications are turned off).
    // It merely checks for the existance of the template.
    //
    hr = g_TemplateCache.FindCached
        (
        m_pIReq->QueryPszPathTranslated(),
        DWInstanceID(),
        &pTemplate
        );

    if (hr == S_OK)
        {
        Assert(pTemplate);
        
        // store the template away for later use...
        //pTemplate->AddRef();
        //m_pTemplate = pTemplate;

        if (fAllowSessions)
            {
            // check for session-less templates
            fNeedSession = pTemplate->FSession();
            }
        else
            {
#ifdef SCRIPT_STATS
            if (pTemplate->FScriptless())
                InterlockedIncrement(&g_cScriptlessRequests);
#endif // SCRIPT_STATS

            // check for scipt-less templates to be
            // completed on the I/O thread (when no debugging)
            if (
#ifdef SCRIPT_STATS
                g_fSendScriptlessOnAtqThread &&
#endif // SCRIPT_STATS
                pTemplate->FScriptless() && !m_pAppln->FDebuggable())
                {
#ifdef SCRIPT_STATS
                LONG c = InterlockedIncrement(&g_cConcurrentScriptlessRequests);
                DWORD dwTime = GetTickCount();
#endif // SCRIPT_STATS

                pTemplate->IncrUseCount();

                if (SUCCEEDED(CResponse::WriteScriptlessTemplate(m_pIReq, pTemplate)))
                    {
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQPERSEC();
                    g_PerfData.Incr_REQSUCCEEDED();
#endif
                    m_fDoneWithSession = TRUE;  // do not post to MTS
                    }

#ifdef SCRIPT_STATS
                dwTime = GetTickCount() - dwTime;
                InterlockedDecrement(&g_cConcurrentScriptlessRequests);
                
                g_lockRequestStats.WriteLock();
                    g_nSumExecTimeScriptlessRequests += dwTime;

                    if (c > g_cMaxConcurrentScriptlessRequests)
                        g_cMaxConcurrentScriptlessRequests = c;
                    g_nSumConcurrentScriptlessRequests += c;

                    g_nAvgConcurrentScriptlessRequests = (LONG)
                        (g_nSumConcurrentScriptlessRequests
                         / g_cScriptlessRequests);
                    g_nAvgExecTimeScriptlessRequests = (LONG)
                        (g_nSumExecTimeScriptlessRequests
                         / g_cScriptlessRequests);
                g_lockRequestStats.WriteUnlock();
#endif // SCRIPT_STATS
                }
            }

        // When possible, generate 449 cookies while on I/O thread
        if (!m_fDoneWithSession)
            {
                if (!SUCCEEDED(pTemplate->Do449Processing(this)))
                    g_TemplateCache.Flush(m_pIReq->QueryPszPathTranslated(), DWInstanceID());
            }

        pTemplate->Release();
        }

    // initialize CodePage and LCID to the app defaults...

    m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();

    m_lcid = PAppln()->QueryAppConfig()->uLCID();

    if (!fNeedSession || m_fDoneWithSession)
    {
        m_fInited = TRUE;
        return S_OK;
    }

    // Attach to session or create a new one
    BOOL fNewSession, fNewCookie;
    hr = AssignSessionToBrowserRequest(&fNewSession, &fNewCookie, pErrorId);

    if (FAILED(hr))
        return E_FAIL;

    Assert(m_pSession);
    
    // Move from inside "if (fNewSesson)"
    if (fNewCookie)
        m_fNewCookie = TRUE;

    if (fNewSession)
        {
        m_fStartSession = TRUE;

        if (m_pAppln->FHasGlobalAsa())
            m_fRunGlobalAsa = TRUE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHitObj::AssignApplnToBrowserRequest

Find or create a new appln for this browser request
Does the appln manager locking

Parameters:
    pfApplnRestarting   [out] flag - failed because the appln
                                     found is restarting

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignApplnToBrowserRequest
(
BOOL *pfApplnRestarting
)
    {
    HRESULT hr;
    
    Assert(pfApplnRestarting);
    *pfApplnRestarting = FALSE;
    
    Assert(!m_pAppln);

    TCHAR *szAppMDPath = m_pIReq->QueryPszApplnMDPath();
    if (!szAppMDPath)
        return E_FAIL;
        
    // Lock the application manager
    g_ApplnMgr.Lock();

    // Find by application by metabase key
    CAppln *pAppln;
    hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

    if (hr == S_OK)
        {
        // Reject requests for restarting applications
        if (pAppln->FGlobalChanged())
            {
            *pfApplnRestarting = TRUE;
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }
        // Update appln config from metabase if needed
        else if (pAppln->FConfigNeedsUpdate())
            {
            // If debugging flag has changed, then restart the application
            BOOL fRestartAppln = FALSE;
            BOOL fFlushAll = FALSE;
            pAppln->UpdateConfig(m_pIReq, &fRestartAppln, &fFlushAll);

            if (fRestartAppln)
                {
                pAppln->Restart(TRUE);      // force a restart
                pAppln = NULL;

                if (fFlushAll)  // flush all can only happen when restart is TRUE
                    {
                    // do flush while unlocked
                    g_ApplnMgr.UnLock();
                    g_TemplateCache.FlushAll();
                    g_ApplnMgr.Lock();
                    }
                
                // Find again
                hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

                // Reject if still restarting
                if (hr == S_OK && pAppln->FGlobalChanged())
                    {
                    *pfApplnRestarting = TRUE;
                    g_ApplnMgr.UnLock();
                    return E_FAIL;
                    }
                }
            else
                {
                // adjust sctipt killer timeout
                g_ScriptManager.AdjustScriptKillerTimeout
                    (
                    // application timeout / 2 (in ms)
                    pAppln->QueryAppConfig()->dwScriptTimeout() * 500
                    );
                }
            }
        }
        
    if (hr != S_OK) // Application NOT found
        {
        TCHAR *szAppPhysicalPath = GetSzAppPhysicalPath();
        if (!szAppPhysicalPath)
            {
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }

        // try to create a new one
        hr = g_ApplnMgr.AddAppln
            (
            szAppMDPath, // metabase key 
            szAppPhysicalPath, 
            m_pIReq,
            &pAppln
            );

        if (FAILED(hr))
            {
            g_ApplnMgr.UnLock();
            free (szAppPhysicalPath);
            return hr;
            }

        // Check for GLOBAL.ASA

        TCHAR szGlobalAsaPath[MAX_PATH*2];
        DWORD cchPath = _tcslen(szAppPhysicalPath);
        // 
        // If the Application Path is larger than MAXPATH. Then reject the request
        //
        if (cchPath > MAX_PATH)
            return E_FAIL;

        //
        // ncopy cchPath +2 so that the NullTerminator will be copied too.
        //        
        _tcsncpy(szGlobalAsaPath, szAppPhysicalPath, cchPath + 2);

        // BUG FIX: 102010 DBCS code fixes
        //if (szGlobalAsaPath[cchPath-1] != '\\')
        if ( *CharPrev(szGlobalAsaPath, szGlobalAsaPath + cchPath) != _T('\\'))
            szGlobalAsaPath[cchPath++] = _T('\\');
            
        _tcscpy(szGlobalAsaPath+cchPath, SZ_GLOBAL_ASA);

        // Check if GLOBAL.ASA exists
        BOOL fGlobalAsaExists = FALSE;
        if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
            {
            fGlobalAsaExists = TRUE;
            }
        else if (GetLastError() == ERROR_ACCESS_DENIED)
            {
            // If the current user doesn't have access (could happen when
            // there's an ACL on directory) try under SYSTEM user
            
            if (m_hImpersonate)
                {
                RevertToSelf();
                if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
                    fGlobalAsaExists = TRUE;
                HANDLE hThread = GetCurrentThread();
                SetThreadToken(&hThread, m_hImpersonate);
                }
            }

        if (fGlobalAsaExists)
            pAppln->SetGlobalAsa(szGlobalAsaPath);

        // Start monitoring application directory to
        // catch changes to GLOBAL.ASA even if it's not there
        g_FileAppMap.AddFileApplication(szGlobalAsaPath, pAppln);
        CASPDirMonitorEntry *pDME = NULL;

        //
        // Check if the Registry flag is set to get Notifications for UNC
        // 
        DWORD   fUNCChangeNotify = 0;
        g_AspRegistryParams.GetChangeNotificationForUNCEnabled(&fUNCChangeNotify);

        //
        // If its not a UNC file then go ahead and register for a UNC change notification.
        // If it is then dont register the application for change nofication unless the ChangeNotifications for UNC are enabled in the registry
        //
        HRESULT HRes = S_OK;
        if (!IsFileUNC(szAppPhysicalPath, HRes) || fUNCChangeNotify)
        {
            if (SUCCEEDED (HRes) && RegisterASPDirMonitorEntry(szAppPhysicalPath, &pDME, TRUE))
                pAppln->AddDirMonitorEntry(pDME);
        }


        free(szAppPhysicalPath);
        szAppPhysicalPath = NULL;

        // Update config from registry - don't care about restart
        // application is fresh baked
        pAppln->UpdateConfig(m_pIReq);

        // Adjust script killer timeout to current application
        g_ScriptManager.AdjustScriptKillerTimeout
            (
            // application timeout / 2 (in ms)
            pAppln->QueryAppConfig()->dwScriptTimeout() * 500
            );
        }

    // We have an application at this point
    Assert(pAppln);
    m_pAppln = pAppln;

    // Increment request count before releasing ApplMgr lock
    // to make sure it will not remove the app from under us
    m_pAppln->IncrementRequestCount();

    // Unlock the application manager
    g_ApplnMgr.UnLock();

    return S_OK;
    }
    
/*===================================================================
CHitObj::AssignSessionToBrowserRequest

Find or create a new session for this browser request
Does the session manager locking

Parameters:
    pfNewSession        [out] flag - new session created
    pfNewCookie         [out] flag - new cookie crated
    pErrorId            [out] -- error ID if failed

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignSessionToBrowserRequest
(
BOOL *pfNewSession,
BOOL *pfNewCookie,
int  *pErrorId
)
    {
    Assert(pfNewSession);
    Assert(pfNewCookie);
    
    Assert(!m_pSession);

    // Local vars

    BOOL fTooManySessions = FALSE;
    BOOL fUseNewSession = FALSE;
    BOOL fUseOldSession = FALSE;
    BOOL fUseNewCookie = FALSE;
    
    CSession *pNewSession = NULL; // newly created
    CSession *pOldSession = NULL; // existing session that is found
    
    BOOL fReuseIdAndCookie = FALSE;
    BOOL fValidId = g_SessionIdGenerator.IsValidId(m_SessionId.m_dwId);

    HRESULT hr = S_OK;

    CSessionMgr *pSessionMgr = m_pAppln->PSessionMgr();

    while (1)
        {
        // Try to find session by Id

        if (fValidId)
            {
            pSessionMgr->LockMaster();
            
            pOldSession = NULL;
            HRESULT hrFind = pSessionMgr->FindInMasterHash
                (
                m_SessionId,
                &pOldSession
                );

            // Good old Session?
            if (hrFind == NOERROR) 
                {
                Assert(pOldSession);

                // If AspKeepSessionIDSecure is set in metabase and
                // they are going from a nonsecure to a secure connection then 
                // transition the user from their old http sessionid to their
                // new https secure session id
                if (QueryAppConfig()->fKeepSessionIDSecure() &&
                    FSecure() &&
                    !pOldSession->FSecureSession()
                    )
                {
                    // Generate New Cookie
                    hr = pSessionMgr->GenerateIdAndCookie
                        (
                        &m_SessionId,
                        m_szSessionCookie
                        );
                            
                    if (SUCCEEDED(hr))
                    {
                        hr = pSessionMgr->ChangeSessionId(pOldSession,m_SessionId);
                    }            

                    if (FAILED(hr))
                    {
                        pSessionMgr->UnLockMaster();
                        break;
                    }

                    pOldSession->SetSecureSession(TRUE);
                    fUseNewCookie = TRUE;                    
                }
                
                // Increment request count before unlock to avoid 
                // deletion of the session by other threads
                pOldSession->IncrementRequestsCount();
                pSessionMgr->UnLockMaster();
                fUseOldSession = TRUE;
                break;
                }

            // Bad old Session?
            else if (pOldSession)
                {
                pSessionMgr->UnLockMaster();
                fValidId = FALSE;
                }

            // No old session and we have a new session to insert?
            else if (pNewSession)
                {
                hr = pSessionMgr->AddToMasterHash(pNewSession);
                    
                if (SUCCEEDED(hr))
                    {
                    // Increment request count before unlock to avoid 
                    // deletion of the session by other threads
                    pNewSession->IncrementRequestsCount();
                    fUseNewSession = TRUE;
                    }
                pSessionMgr->UnLockMaster();
                break;
                }

            // No old session and no new session
            else
                {
                pSessionMgr->UnLockMaster();

                if (FSecure () && QueryAppConfig()->fKeepSessionIDSecure())
                    {
                        fValidId = FALSE;
                    }                
                }
            }

        // Generate id and cookie when needed

        if (!fValidId)  // 2nd time generate new id
            {
            hr = pSessionMgr->GenerateIdAndCookie
                (
                &m_SessionId,
                m_szSessionCookie
                );
            if (FAILED(hr))
                break;
            fValidId = TRUE;
            fUseNewCookie = TRUE;
            }
        
        // Create new session object if needed

        if (!pNewSession)
            {
            // Enforce the session limit for the application
            DWORD dwSessionLimit = m_pAppln->QueryAppConfig()->dwSessionMax();
            if (dwSessionLimit != 0xffffffff && dwSessionLimit != 0 &&
                m_pAppln->GetNumSessions() >= dwSessionLimit)
                {
                fTooManySessions = TRUE;
                hr = E_FAIL;
                break;
                }

            hr = pSessionMgr->NewSession(m_SessionId, &pNewSession);
            
            if (FAILED(hr))
                break;
            }
        else
            {
            // Assign new id to already created new session
            pNewSession->AssignNewId(m_SessionId);
            }

        // continue with the loop
        }

    // the results

    if (fUseNewSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pNewSession);

        m_pSession = pNewSession;
        m_pSession->SetSecureSession(FSecure());
        pNewSession = NULL;  // not to be deleted later
        }
    else if (fUseOldSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pOldSession);
        
        m_pSession = pOldSession;
        }
    else
        {
        Assert(FAILED(hr));

        if (hr == COMADMIN_E_PARTITION_ACCESSDENIED)
            PAppln()->LogSWCError(PartitionAccessDenied);
        
        *pErrorId = fTooManySessions ? IDE_TOO_MANY_USERS : IDE_ADD_SESSION;
        }
        
    // cleanup new session if unused
    if (pNewSession)
        {
        pNewSession->UnInit();
        pNewSession->Release();
        pNewSession = NULL;
        }

    if (m_pSession && m_pSession->FCodePageSet()) {
        m_uCodePage = m_pSession->GetCodePage();
    }
    else {
        m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();
    }

    if (m_pSession && m_pSession->FLCIDSet()) {
        m_lcid = m_pSession->GetLCID();
    }
    else {
        m_lcid = PAppln()->QueryAppConfig()->uLCID();
    }

    // return flags
    *pfNewSession = fUseNewSession;
    *pfNewCookie  = fUseNewCookie;
    return hr;
    }

/*===================================================================
CHitObj::DetachBrowserRequestFromSession

Removes session from browser request.
Does session clean-up when needed

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::DetachBrowserRequestFromSession()
    {
    Assert(m_pSession);
    Assert(m_pSession->PAppln());

    if (IsShutDownInProgress() || m_pSession->FInTOBucket())
        {
        // nothing fancy on shutdown
        
        // or if the session is still in the timeout bucket
        // (could happen for rejected requests)
        
        m_pSession->DecrementRequestsCount();
        m_pSession = NULL;
        return S_OK;
        }
        
    CSessionMgr *pSessionMgr = m_pSession->PAppln()->PSessionMgr();
    Assert(pSessionMgr);

     // try to delete this session if this is the last pending request
    if (m_pSession->GetRequestsCount() == 1)
        {
        // convert to lightweight if possible
        m_pSession->MakeLightWeight();

        // check if need to delete now
        if (m_pSession->FShouldBeDeletedNow(TRUE))
            {
            pSessionMgr->LockMaster();

            // check if still need to delete now after locking
            if (m_pSession->FShouldBeDeletedNow(TRUE))
                {
                pSessionMgr->RemoveFromMasterHash(m_pSession);
                pSessionMgr->UnLockMaster();
                
                m_pSession->DecrementRequestsCount();
                pSessionMgr->DeleteSession(m_pSession, TRUE);
                m_pSession = NULL;
                return S_OK;
                }

            pSessionMgr->UnLockMaster();
            }
        }

    // We can end up here for a rejected requests only if there are
    // other (non-rejected) requests for this session.
    //
    // The category of rejected here does not include rejected because
    // of the RequestQueueMax. This only applies to real OOM situations.
    //
    // In case of rejected request or if there are other pending
    // requests for this, session these other requests will take
    // care of reinserting the session into the timeout bucket.
    //
    // Rejected requests are NOT serialized -- they don't run on Viper
    // threads. Inserting the session into a timeout bucket for a
    // rejected request might create a race condition with regular requests.
    
    if (!m_fRejected && m_pSession->GetRequestsCount() == 1)
        {
        // Insert into proper timeout bucket
        if (pSessionMgr->FIsSessionKillerScheduled())
            {
            pSessionMgr->UpdateSessionTimeoutTime(m_pSession);
            pSessionMgr->AddSessionToTOBucket(m_pSession);
            }
        }
    
    m_pSession->DecrementRequestsCount();

    // session is no longer attached to the request
    m_pSession = NULL;
    
    return S_OK;
    }

/*===================================================================
void CHitObj::SessionCleanupInit

Initialize a request object for session cleanup

Parameters:
    CSession *pSession      Session object context

Returns:
    NONE
===================================================================*/
void CHitObj::SessionCleanupInit
(
CSession * pSession
)
    {
    m_ehtType = ehtSessionCleanup;
    InterlockedIncrement((LPLONG)&g_nSessionCleanupRequests);

    m_pSession      = pSession;
    m_pAppln        = pSession->PAppln();
    m_fRunGlobalAsa = TRUE;
    m_pIReq          = NULL;

    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }

    if (m_pAppln->PSessionMgr())
        m_pAppln->PSessionMgr()->IncrementSessionCleanupRequestCount();

    m_fInited = TRUE;
    }

/*===================================================================
void CHitObj::ApplicationCleanupInit

Initializes a request object for application cleanup

Parameters:
    CAppln *        pAppln      Application object context

Returns:
    NONE
===================================================================*/
void CHitObj::ApplicationCleanupInit( CAppln * pAppln )
{
    m_ehtType = ehtApplicationCleanup;
    InterlockedIncrement((LPLONG)&g_nApplnCleanupRequests);

    m_pAppln = pAppln;
    m_fRunGlobalAsa = TRUE;
    m_pIReq = NULL;

    // If OOM here, then cleanup request does not get a server object.
    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }
        
    m_fInited = TRUE;
}

/*===================================================================
CHitObj::ReassignAbandonedSession

Reassign ID of a the session being abandonded thus
detaching it from the client

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::ReassignAbandonedSession()
    {
    HRESULT hr = E_FAIL;
    
    Assert(m_pSession);
    Assert(m_pAppln);
    m_pAppln->AssertValid();

    hr = m_pAppln->PSessionMgr()->GenerateIdAndCookie
        (
        &m_SessionId,
        m_szSessionCookie
        );

    if (SUCCEEDED(hr))
        {
        hr = m_pAppln->PSessionMgr()->ChangeSessionId
            (
            m_pSession,
            m_SessionId
            );
        }
                            
    return hr;
    }

/*===================================================================
void CHitObj::FObjectTag

Check if the object passed in as argument is an object tag
created object.

Parameters:
    IDispatch * pDispatch   pointer to object

Returns:
    TRUE    Is a object tag created object
    FALSE   Otherwise
===================================================================*/
BOOL CHitObj::FObjectTag( IDispatch * pDispatch )
{
    if (!m_pPageObjMgr)
        return FALSE;
        
    BOOL fRet = TRUE;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->
        FindAnyScopeComponentByIDispatch(pDispatch, &pObj);

    return (SUCCEEDED(hr) && pObj);
}

/*  buffer allows space for: <user cookie>  +    CCH_SESSION_ID_COOKIE  +   =   +   <cookie>        +   '\0')
                                50          +       20                  +   1   +   SESSIONID_LEN   +   1
    NOTE we arbitrarily allow 50 bytes for <user cookie>
    NOTE if CCH_SESSION_ID_COOKIE changes, CCH_BUFCOOKIES_DEFAULT must be changed accordingly
*/
#define CCH_BUFCOOKIES_DEFAULT  72 + SESSIONID_LEN

/*===================================================================
CHitObj::ParseCookiesForSessionIdAndFlags

Extracts Cookie from CIsapiReqInfo.

Parameters:

Side Effects:
    Initializes m_SessionId, m_SessionIdR1, m_SessionIdR2 and
                m_szSessionCookie
    Sets m_fClientCodeDebug flag

Returns:
    S_OK        Extracted cookie value successfully
    S_FALSE     Success, but no cookie found
    other       error
===================================================================*/
HRESULT CHitObj::ParseCookiesForSessionIdAndFlags()
    {
    Assert(m_pAppln);
    CAppConfig *pAppConfig = m_pAppln->QueryAppConfig();
    
    // Are we interested in ANY cookies?

    if (!pAppConfig->fAllowSessionState() && 
        !pAppConfig->fAllowClientDebug())
        return S_OK;

    // If session cookie is needed init it

    if (pAppConfig->fAllowSessionState())
        {
        m_SessionId.m_dwId = INVALID_ID;
        m_szSessionCookie[0] = '\0';
        }

    // Get cookies from WAM_EXEC_INFO
    char *szBufCookies = m_pIReq->QueryPszCookie();
    if (!szBufCookies || !*szBufCookies)
        return S_OK; // no cookies

    // Obtain Session Cookie (and ID) if needed
        
    if (pAppConfig->fAllowSessionState())
        {
        char *pT;

        pT = strstr(szBufCookies, m_pAppln->GetSessionCookieName(m_fSecure));
       
        if (pT==NULL && m_fSecure && pAppConfig->fKeepSessionIDSecure())
        {
            pT = strstr(szBufCookies, m_pAppln->GetSessionCookieName(FALSE));
        }

        if (pT)
        {
            pT += CCH_SESSION_ID_COOKIE;
            if (*pT == '=')
            {
                pT++;
                if (strlen( pT ) >= SESSIONID_LEN)
                {
                    memcpy(m_szSessionCookie, pT, SESSIONID_LEN);
                    m_szSessionCookie[SESSIONID_LEN] = '\0';
                }
            }
        }

        // validate and try to decode the session id cookie
        if (m_szSessionCookie[0] != '\0')
            {
            if (FAILED(DecodeSessionIdCookie
                    (
                    m_szSessionCookie,
                    &m_SessionId.m_dwId, 
                    &m_SessionId.m_dwR1,
                    &m_SessionId.m_dwR2
                    )))
                {
                m_SessionId.m_dwId = INVALID_ID;
                m_szSessionCookie[0] = '\0';
                }
            }
        }

    // Look for Client Debug enabling cookie

    if (pAppConfig->fAllowClientDebug())
        {
        if (strstr(szBufCookies, SZ_CLIENT_DEBUG_COOKIE"="))
            m_fClientCodeDebug = TRUE;
        }

    return S_OK;
    }

/*===================================================================
BOOL CHitObj::GetSzAppPhysicalPath

Extracts application directory from WAM_EXEC_INFO

Parameters:

Side Effects:
On success, allocate memory for pszAppPhysicalPath

Returns:
    TRUE        AppPhysicalPath
    FALSE       NULL
===================================================================*/
TCHAR *CHitObj::GetSzAppPhysicalPath()
{
    DWORD  dwSizeofBuffer = 265*sizeof(TCHAR);
    TCHAR  *pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
    CHAR   *pszApplPhysPathVarName;

    if (!pszAppPhysicalPathLocal)
        return NULL;

#if UNICODE
    pszApplPhysPathVarName = "UNICODE_APPL_PHYSICAL_PATH";
#else
    pszApplPhysPathVarName = "APPL_PHYSICAL_PATH";
#endif

    BOOL fFound = m_pIReq->GetServerVariable
        (
        pszApplPhysPathVarName, 
        pszAppPhysicalPathLocal, 
        &dwSizeofBuffer
        );

    if (!fFound)
        {
        DWORD dwErr = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
            // Not Enough Buffer
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
            if (pszAppPhysicalPathLocal)
                {
                // Try again
                fFound = m_pIReq->GetServerVariable
                    (
                    pszApplPhysPathVarName, 
                    pszAppPhysicalPathLocal, 
                    &dwSizeofBuffer
                    );
                }
            }
        }

    if (!fFound) {
        if (pszAppPhysicalPathLocal) {
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = NULL;
        }
    }
    else
        {
        Assert(pszAppPhysicalPathLocal);
        Normalize(pszAppPhysicalPathLocal);
        }

    return pszAppPhysicalPathLocal;
    }

/*===================================================================
CHitObj::InitComponentProcessing

Creates and inits component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::InitComponentProcessing()
    {
    Assert(!m_pPageCompCol);
    Assert(!m_pPageObjMgr);

    HRESULT hr = S_OK;

    // Page component collection

    m_pPageCompCol = new CComponentCollection;
    if (!m_pPageCompCol)
        return E_OUTOFMEMORY;

    hr = m_pPageCompCol->Init(csPage,m_pAppln->QueryAppConfig()->fExecuteInMTA());
    if (FAILED(hr))
    {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        return hr;
    }

    // Page object manager
        
    m_pPageObjMgr = new CPageComponentManager;
    if (!m_pPageObjMgr)
    {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        return E_OUTOFMEMORY;
    }

    hr = m_pPageObjMgr->Init(this);
    if (FAILED(hr))
    {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        delete m_pPageObjMgr;
        m_pPageObjMgr = NULL;
        return hr;
    }

    return S_OK;
    }

/*===================================================================
CHitObj::StopComponentProcessing

Deletes component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::StopComponentProcessing()
    {
    if (m_pPageObjMgr)
        {
        delete m_pPageObjMgr;
        m_pPageObjMgr = NULL;
        }

    if (m_pPageCompCol)
        {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        }

    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
        
    return S_OK;
    }
    
/*===================================================================
CHitObj::GetPageComponentCollection

Returns component collection for page

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetPageComponentCollection
(
CComponentCollection **ppCollection
)
    {
    *ppCollection = m_pPageCompCol;
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetSessionComponentCollection

Returns component collection for session

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetSessionComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pSession)
        {
        *ppCollection = m_pSession->PCompCol();

        if (*ppCollection == NULL             &&  // no collection
            m_eEventState != eEventAppOnStart &&  // not an application
            m_eEventState != eEventAppOnEnd)      //       level event
            {
            // init session collection on demand
            HRESULT hr = m_pSession->CreateComponentCollection();
            if (SUCCEEDED(hr))
                *ppCollection = m_pSession->PCompCol();
            }
        }
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetApplnComponentCollection

Returns component collection for application

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetApplnComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pAppln)
        *ppCollection = m_pAppln->PCompCol();
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::AddComponent

Adds uninstantiated tagged object to appropriate
component collection

Parameters:
    CompType  type
    const CLSID &clsid
    CompScope scope
    CompModel model
    LPWSTR     pwszName
    IUnknown  *pUnk

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AddComponent
(
CompType  type,
const CLSID &clsid,
CompScope scope,
CompModel model,
LPWSTR    pwszName,
IUnknown *pUnk
)
    {
    Assert(m_pPageObjMgr);
    m_pPageObjMgr->AssertValid();
 
    Assert(type == ctTagged);
    
    HRESULT hr = m_pPageObjMgr->AddScopedTagged
        (
        scope, 
        pwszName,
        clsid,
        model
        );

    return hr;
    }

/*===================================================================
CHitObj::GetComponent

Finds CComponentObject by scope and name

Parameters:
    CompScope         scope        can be csUnknown
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    CComponentObject **ppObj       (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT if object fails to instantiate
===================================================================*/
HRESULT CHitObj::GetComponent
(
CompScope          scope, 
LPWSTR             pwszName, 
DWORD              cbName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;
    
    BOOL fNewInstance = FALSE;
    HRESULT hr = m_pPageObjMgr->GetScopedObjectInstantiated
        (
        scope,
        pwszName,
        cbName,
        ppObj,
        &fNewInstance
        );

	if (FAILED(hr))
		return hr;

    // If an object that restricts threading has been instantiateed
    // as the session's tagged <OBJECT>, and the session's activity
    // runs this request, then bind the session's activity to thread

    if ((*ppObj)->GetScope() == csSession  && // session scope component
        m_ecsActivityScope == csSession    && // session scope activity
        fNewInstance                       && // object was just instantiated
        !m_pAppln->QueryAppConfig()->fExecuteInMTA() && // running on STA
        !(*ppObj)->FAgile())                  // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }

    return hr;
    }

/*===================================================================
CHitObj::GetIntrinsic

Finds Intrinsic by name

Parameters:
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    IUnknown        **ppUnk        (out) object found

Returns:
    HRESULT     S_OK on success
                S_FALSE name of the instrinsic but it's missing
                TYPE_E_ELEMENTNOTFOUND if the object not found
===================================================================*/
HRESULT CHitObj::GetIntrinsic
(
LPWSTR     pwszName, 
DWORD      cbName,
IUnknown **ppUnk
)
    {
    Assert(ppUnk);
    *ppUnk = NULL;


    // Lookup table based on (wszName[0] - cbName) % 32
    // Works for both uppper and lower case names

    static enum IntrinsicType
        {
        itUnknown = 0,
        itObjContext,
        itNamespace,
        itAppln,
        itSession,
        itRequest,
        itResponse,
        itServer,
        itASPPageTLB,
        itASPGlobalTLB
        }
    rgitLookupEntries[] =
        {
        /* 0-1   */     itUnknown, itUnknown,
        /* 2     */ itResponse,
        /* 3     */     itUnknown,
        /* 4     */ itRequest,
        /* 5     */ itSession,
        /* 6     */     itUnknown,
        /* 7     */ itServer,
        /* 8     */     itUnknown,
        /* 9     */ itASPGlobalTLB,
        /* 10    */     itUnknown,
        /* 11    */ itAppln,
        /* 12    */     itUnknown,
        /* 13    */ itASPPageTLB,
        /* 14    */     itUnknown,
        /* 15    */ itNamespace,
        /* 16-20 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
        /* 21    */ itObjContext,
        /* 22-31 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
                        itUnknown, itUnknown, itUnknown, itUnknown, itUnknown
        };

    IntrinsicType itType = rgitLookupEntries
        [
        (pwszName[0] - cbName) & 0x1f   // &1f same as %32
        ];

    if (itType == itUnknown)  // most likely
        return TYPE_E_ELEMENTNOTFOUND;

    // Do the string comparison
    BOOL fNameMatch = FALSE;
    
    switch (itType)
        {
    case itNamespace:
        if (_wcsicmp(pwszName, WSZ_OBJ_SCRIPTINGNAMESPACE) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_punkScriptingNamespace;
            }
        break;

    case itResponse:
        if (_wcsicmp(pwszName, WSZ_OBJ_RESPONSE) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IResponse *>(m_pResponse);
            }
        break;

    case itRequest:
        if (_wcsicmp(pwszName, WSZ_OBJ_REQUEST) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IRequest *>(m_pRequest);
            }
        break;
        
    case itSession:
        if (_wcsicmp(pwszName, WSZ_OBJ_SESSION) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideSessionIntrinsic)
                *ppUnk = static_cast<ISessionObject *>(m_pSession);
            }
        break;
        
    case itServer:
        if (_wcsicmp(pwszName, WSZ_OBJ_SERVER) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IServer *>(m_pServer);
            }
        break;
        
    case itAppln:
        if (_wcsicmp(pwszName, WSZ_OBJ_APPLICATION) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IApplicationObject *>(m_pAppln);
            }
        break;
        
    case itObjContext:
        if (_wcsicmp(pwszName, WSZ_OBJ_OBJECTCONTEXT) == 0) {

            // if there isn't an ASPObjectContext, then most likely
            // the asp script is asking for the object context on a 
            // non-transacted page.  Return the Dummy Object Context
            // which will allow ASP to return a friendly error saying
            // that ObjectContext is not available rather than
            // ELEMENT_NOT_FOUND.

            if (m_pASPObjectContext == NULL) {

                if (g_pIASPDummyObjectContext == NULL) {

                    CASPDummyObjectContext  *pContext = new CASPDummyObjectContext();

                    if (pContext == NULL) {
                        return E_OUTOFMEMORY;
                    }
                    g_pIASPDummyObjectContext = static_cast<IASPObjectContext *>(pContext);
                }
                *ppUnk = g_pIASPDummyObjectContext;
			}
            else {

                *ppUnk = static_cast<IASPObjectContext *>(m_pASPObjectContext);
            }
            fNameMatch = TRUE;
        }
        break;

    case itASPPageTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPPAGETLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pdispTypeLibWrapper;
            }
        break;

    case itASPGlobalTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPGLOBALTLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pAppln->PGlobTypeLibWrapper();
            }
        break;
        }

    if      (*ppUnk)        return S_OK;
    else if (fNameMatch)    return S_FALSE;
    else                    return TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::CreateComponent

Server.CreateObject calls this

Parameters:
    clsid       create of this CLSID
    ppDisp      return IDispatch*

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::CreateComponent
(
const CLSID &clsid,
IDispatch **ppDisp
)
    {
    Assert(m_pPageObjMgr);

    CComponentObject *pObj = NULL;
    
    HRESULT hr = m_pPageObjMgr->AddScopedUnnamedInstantiated
        (
        csPage, 
        clsid, 
        cmUnknown,
        NULL,
        &pObj
        );
    if (FAILED(hr))
        {
        *ppDisp = NULL;
        return hr;
        }

    Assert(pObj);

    hr = pObj->GetAddRefdIDispatch(ppDisp);

    if (SUCCEEDED(hr))
        {
        // don't keep the object around unless needed
        if (pObj->FEarlyReleaseAllowed())
            m_pPageObjMgr->RemoveComponent(pObj);
        }

    return hr;
    }

/*===================================================================
CHitObj::SetPropertyComponent

Sets property value to variant

Parameters:
    CompScope         scope        property scope
    LPWSTR             pwszName     property name
    VARIANT            pVariant     property value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetPropertyComponent
(
CompScope scope,
LPWSTR     pwszName, 
VARIANT   *pVariant
)
    {
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->AddScopedProperty(scope, pwszName, 
                                                  pVariant, &pObj);

    // If an object that restricts threading has been assigned as
    // the session property, and the session's activity runs this
    // request, then bind the session's activity to thread

    if (scope == csSession               && // session scope property
        m_ecsActivityScope == csSession  && // session scope activity
        SUCCEEDED(hr)                    && // set property succeed
        !m_pAppln->QueryAppConfig()->fExecuteInMTA() && // running on STA
        pObj && !pObj->FAgile())            // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }
        
    return hr;
    }

/*===================================================================
CHitObj::GetPropertyComponent

Finds property CComponentObject by scope and name

Parameters:
    CompScope         scope        wher to find
    LPWSTR             pwszName     name to find
    CComponentObject **ppObj        (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT
===================================================================*/
HRESULT CHitObj::GetPropertyComponent
(
CompScope         scope, 
LPWSTR             pwszName, 
CComponentObject **ppObj
)
    {
    *ppObj = NULL;
    
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    return m_pPageObjMgr->GetScopedProperty(scope, pwszName, ppObj);
    }

/*===================================================================
CHitObj::SetActivity

Remember activity with CHitObj

Parameters
    CViperActivity *pActivity       Viper activity to remember
                                    (and later delete)

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetActivity
(
CViperActivity *pActivity
)
    {
    Assert(!m_pActivity);
    m_pActivity = pActivity;
    return S_OK;
    }

/*===================================================================
CHitObj::PCurrentActivity

Returns Viper Activity, the current HitObj is running under

Parameters

Returns:
    CViperActivity *
===================================================================*/
CViperActivity *CHitObj::PCurrentActivity()
    {
    CViperActivity *pActivity = NULL;

    switch (m_ecsActivityScope)
        {
        case csPage:
            pActivity = m_pActivity;
            break;
        case csSession:
            Assert(m_pSession);
            pActivity = m_pSession->PActivity();
            break;
        case csAppln:
            Assert(m_pAppln);
            pActivity = m_pAppln->PActivity();
            break;
        }

    return pActivity;
    }

/*===================================================================
CHitObj::PostViperAsyncCall

Asks Viper to calls us back from the right thread to execute
the request.

Used instead of queueing

Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::PostViperAsyncCall()
    {
#ifndef PERF_DISABLE
    BOOL fDecrOnFail = FALSE;
    if (FIsBrowserRequest())
        {
        DWORD dwRequestQueued = g_PerfData.Incr_REQCURRENT();

        fDecrOnFail = TRUE;
        }
#endif

    UpdateTimestamp();  // before posting into queue

    CViperActivity *pApplnAct = m_pAppln ?
        m_pAppln->PActivity() : NULL;
        
    CViperActivity *pSessnAct = m_pSession ?
        m_pSession->PActivity() : NULL;

    HRESULT hr;

    if (pApplnAct)
        {
        m_ecsActivityScope = csAppln;
        hr = pApplnAct->PostAsyncRequest(this);
        }
    else if (pSessnAct)
        {
        m_ecsActivityScope = csSession;
        hr = pSessnAct->PostAsyncRequest(this);
        }
    else
        {
        m_ecsActivityScope = csPage;
        hr = CViperActivity::PostGlobalAsyncRequest(this);
        }
        
#ifndef PERF_DISABLE
    if (FAILED(hr) && fDecrOnFail) {
        g_PerfData.Decr_REQCURRENT();
    }
#endif    

    if (SUCCEEDED(hr) && m_pIReq)
        m_pIReq->SetRequestStatus(HSE_STATUS_PENDING);

    return hr;
    }

/*===================================================================
CHitObj::ViperAsyncCallback

Viper calls us back from the right thread to execute
the request.

Used instead of queueing

Parameters
    BOOL       *pfRePosted   [out] flag TRUE if request re-posted
                             under diff activity (don't delete it)
  
Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::ViperAsyncCallback
(
BOOL *pfRePosted
)
    {
    HRESULT hr = S_OK;
    BOOL fTemplateInCache;
    
    *pfRePosted = FALSE;

    Assert(!m_fExecuting); // no nested executions of the same request
    m_fExecuting = TRUE;
    
    Assert(FIsValidRequestType());

    DWORD dwtWaitTime = ElapsedTimeSinceTimestamp();
    UpdateTimestamp();  // received from the queue

#ifndef PERF_DISABLE
    if (FIsBrowserRequest())
        {
        g_PerfData.Decr_REQCURRENT();
        g_PerfData.Set_REQWAITTIME(dwtWaitTime);
        }
#endif

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest() && IsShutDownInProgress())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Remove the session from it's timeout bucket 
    // while executing the request

    if (m_pSession && m_pSession->FInTOBucket())
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(m_pSession);

    ///////////////////
    // If there's an application level activity we need to make
    // sure this activity is bound to a thread. Could not bind it
    // before because it has to be Viper thread to bind to.

    CViperActivity *pApplnActivity = m_pAppln->PActivity();

    if (pApplnActivity && !pApplnActivity->FThreadBound())
        pApplnActivity->BindToThread();

    ///////////////////
    // Take care of first application request with GLOBAL.ASA
    // Lock application if needed

    BOOL fApplnLocked = FALSE;
    BOOL fFirstAppRequest = FALSE;

    if (FIsBrowserRequest() && m_pAppln->FHasGlobalAsa() &&
                              !m_pAppln->FFirstRequestRun())
        {
        m_pAppln->InternalLock();
        fApplnLocked = TRUE;

        if (!m_pAppln->FFirstRequestRun())
            {
            m_fStartApplication = TRUE;
            m_fRunGlobalAsa = TRUE;
            fFirstAppRequest = TRUE;
            }
        else
            {
            m_pAppln->InternalUnLock();
            fApplnLocked = FALSE;
            }
        }

    ///////////////////
    // Repost under a different activity if needed
    // (do it only after the first app request finished)

    if (!fApplnLocked) // if not processing first app request
        {
        CViperActivity *pSessnAct, *pApplnAct;
        CViperActivity *pRepostToActivity = NULL;
            
        switch (m_ecsActivityScope)
            {
            case csPage:
                // repost to session activity if any
                pSessnAct = m_pSession ? m_pSession->PActivity() : NULL;
                if (pSessnAct)
                    pRepostToActivity = pSessnAct;
                    
                // no break;
            case csSession:
                // repost to application activity if any
                pApplnAct = m_pAppln ? m_pAppln->PActivity() : NULL;
                if (pApplnAct)
                    pRepostToActivity = pApplnAct;
                    
                // no break;
            case csAppln:
                // never repost application activity request
                break;
            }

        if (pRepostToActivity)
            {
            m_fExecuting = FALSE;  // before reposting to avoid nesting
            hr = pRepostToActivity->PostAsyncRequest(this);
            *pfRePosted = SUCCEEDED(hr);
            return hr;
            }
        }

    ///////////////////
    // Cleanup any scripting engines that need to be shut
    // down on this thread, if we are on a thread enabled
    // for debugging
 
    if (m_pAppln->FDebuggable() && FIsBrowserRequest())
        {
        Assert(m_ecsActivityScope == csAppln);
        g_ApplnMgr.CleanupEngines();
        if (!g_dwDebugThreadId)
            g_dwDebugThreadId = GetCurrentThreadId();
        }

    ///////////////////
    // Prepare intrinsics

    CIntrinsicObjects intrinsics;

    m_pServer = NULL;
    m_pResponse = NULL;
    m_pRequest = NULL;
    m_fHideRequestAndResponseIntrinsics = FALSE;
    m_fHideSessionIntrinsic = FALSE;
    m_punkScriptingNamespace = NULL;

    hr = intrinsics.Prepare(m_pSession);

    if (FAILED(hr))  // couldn't setup intrinsics
        {
        if (fApplnLocked)
            m_pAppln->InternalUnLock();
            
#ifndef PERF_DISABLE
        g_PerfData.Incr_REQFAILED();
        g_PerfData.Incr_REQERRORPERSEC();
#endif            
        m_fExecuting = FALSE;
        
        if (FIsBrowserRequest())
            ReportServerError(IDE_SERVER_TOO_BUSY);
            
        return hr;
        }

    if (FIsBrowserRequest())
        {
        m_pResponse = intrinsics.PResponse();
        m_pRequest  = intrinsics.PRequest();
        }
        
    m_pServer = intrinsics.PServer();
    
    Assert(!FIsBrowserRequest() || m_pResponse);

    ///////////////////
    // Point session to this hit object

    if (m_pSession)
        m_pSession->SetHitObj(this);
        
    ///////////////////
    // Impersonate
    
    HANDLE hThread = GetCurrentThread();

    if (FIsBrowserRequest())
    {
         if (!SetThreadToken(&hThread, m_hImpersonate))
         {
#ifdef DBG
                // for debug purposes, it is interesting to know what the error was
                DWORD err = GetLastError();
#endif

                ReportServerError(IDE_IMPERSONATE_USER);
                m_eExecStatus = eExecFailed;
                hr = E_FAIL;
         }
    }

    ///////////////////
    // Make Scripting Context

    if (SUCCEEDED(hr))
        {
        Assert(!m_pScriptingContext);
        
        m_pScriptingContext = new CScriptingContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
            
        if (!m_pScriptingContext)
            hr = E_OUTOFMEMORY;
        }

    ///////////////////
    // Attach to Viper context flow
    
    if (SUCCEEDED(hr))
        {
        hr = ViperAttachIntrinsicsToContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
        }

    ///////////////////
    // Execute

    BOOL fSkipExecute = FALSE; // (need to skip if session-less)

    if (SUCCEEDED(hr))
        {
        CTemplate *pTemplate = NULL;

        if (FIsBrowserRequest())
            {
#ifndef PERF_DISABLE
            g_PerfData.Incr_REQBROWSEREXEC();
#endif
            // Init Response and Server for compiler errors
            m_pResponse->ReInit(m_pIReq, NULL, m_pRequest, NULL, NULL, this);
            m_pRequest->ReInit(m_pIReq, this);
            m_pServer->ReInit(m_pIReq, this);
            
            // Load the script - cache will AddRef
            hr = LoadTemplate(m_pIReq->QueryPszPathTranslated(), this, 
                              &pTemplate, intrinsics,
                              FALSE /* !GlobalAsa */, &fTemplateInCache);

            // In case of ACL on the file (or directory) make sure
            // we don't assume that AppOnStart succeeded on the
            // first try (without the correct impersonation). Setting
            // m_fApplnOnStartFailed will force another try, with the
            // correct impersonation.
            if (fFirstAppRequest && FAILED(hr))
                m_fApplnOnStartFailed = TRUE;

            // Take care of is session-less templates
            if (SUCCEEDED(hr) && !pTemplate->FSession())
                {
                
                if (m_pSession)
                    {
                    // Activity is alright (most likely 
                    // application level) but still there's
                    // a session attached -> hide it
                    m_fHideSessionIntrinsic = TRUE;
                    }
                }
                
            // Take care of the 449 processing (most likely already done on I/O thread)
            if (SUCCEEDED(hr) && !m_fDoneWithSession)
                {
                pTemplate->Do449Processing(this);
                if (m_fDoneWithSession)
                    fSkipExecute = TRUE;  // 449 sent the response
                }
            }

        if (SUCCEEDED(hr) && !fSkipExecute)
            {
            // Execute script
            hr = Execute(pTemplate, this, intrinsics);

            // if we've returned from Execute() and find that m_fRequestTimedout
            // is set, then the request didn't hang.
            if (m_fRequestTimedout) {
                InterlockedDecrement(&g_nRequestsHung);
            }
            
            // OnEndPage
            if (m_pPageObjMgr)
                m_pPageObjMgr->OnEndPageAllObjects();
            }

        // Release the template
        if (pTemplate)
            pTemplate->Release();

        if (FIsBrowserRequest())
            {
            if (!fSkipExecute)
                {
                // Flush response after completing execution
                m_pResponse->FinalFlush(hr);
                }

#ifndef PERF_DISABLE
            g_PerfData.Decr_REQBROWSEREXEC();
#endif
            }
        else if (FIsSessionCleanupRequest())
            {
            // Remove session
            if (m_pSession)
                {
                m_pSession->UnInit();
                m_pSession->Release();
                m_pSession = NULL;
                }
            }
        else if (FIsApplnCleanupRequest())
            {
            // Remove application
            if ( m_pAppln )
                {
                m_pAppln->UnInit();
                m_pAppln->Release();
                m_pAppln = NULL;
                }
            }
        }

    ///////////////////
    // Release Scripting Context
    
    if (m_pScriptingContext)
        {
        m_pScriptingContext->Release();
        m_pScriptingContext = NULL;
        }
        
    ///////////////////
    // Do The Perf Counters

#ifndef PERF_DISABLE
    DWORD dwtExecTime = ElapsedTimeSinceTimestamp();

    if (!fSkipExecute && FIsBrowserRequest())
        {
        g_PerfData.Incr_REQPERSEC();
        g_PerfData.Set_REQEXECTIME(dwtExecTime);
    
        switch (m_eExecStatus)
            {
        case eExecSucceeded:
            if (m_pResponse->FWriteClientError())
                {
                g_PerfData.Incr_REQCOMFAILED();
                g_PerfData.Incr_REQERRORPERSEC();
                }
            else
                {
                g_PerfData.Incr_REQSUCCEEDED();
                }
            break;
            
        case eExecFailed:
            if (hr == E_USER_LACKS_PERMISSIONS)
                {
                g_PerfData.Incr_REQNOTAUTH();
                }
            else if (FIsPreprocessorError(hr))
                {
                g_PerfData.Incr_REQERRPREPROC();
                }
            else if (m_fCompilationFailed)
                {
                g_PerfData.Incr_REQERRCOMPILE();
                }
            else
                {
                g_PerfData.Incr_REQERRRUNTIME();
                }
        
            g_PerfData.Incr_REQFAILED();
            g_PerfData.Incr_REQERRORPERSEC();
            break;
            
        case eExecTimedOut:
            g_PerfData.Incr_REQTIMEOUT();
            break;
            }
        }
#endif    

    ///////////////////
    // Cleanup after first application request
    
    if (fFirstAppRequest && !m_fApplnOnStartFailed && !fSkipExecute)
        m_pAppln->SetFirstRequestRan();

    if (fApplnLocked)
        m_pAppln->InternalUnLock();
    
    ///////////////////
    // make sure script didn't leave application locked

    if (!FIsApplnCleanupRequest())
        m_pAppln->UnLockAfterRequest();

    ///////////////////
    // In order not to refer to intrinsics later
    // remove page component collection
    
    StopComponentProcessing();

	// Unset the impersonation
	SetThreadToken(&hThread, NULL);
                
    ///////////////////
    // Point session to NULL HitObj

    if (m_pSession)
        m_pSession->SetHitObj(NULL);

    m_fExecuting = FALSE;
    
    return hr;
    }

/*===================================================================
CHitObj::ExecuteChildRequest

Executes child browser request

Parameters:
    fTransfer       -- flag -- End execution after this
    szTemplate      -- filename of the template to execute
    szVirtTemplate  -- virt path to template

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::ExecuteChildRequest
(
BOOL fTransfer, 
TCHAR *szTemplate,
TCHAR *szVirtTemplate
)
    {
    HRESULT hr = S_OK;

    // Prepare the new intrinsics structure (with the new scripting namespace)
    CIntrinsicObjects intrinsics;
    intrinsics.PrepareChild(m_pResponse, m_pRequest, m_pServer);
    
    TCHAR *saved_m_szCurrTemplateVirtPath = m_szCurrTemplateVirtPath;
    TCHAR *saved_m_szCurrTemplatePhysPath = m_szCurrTemplatePhysPath;
    // these two fields used for compilation and error reporting
    m_szCurrTemplateVirtPath = szVirtTemplate;
    m_szCurrTemplatePhysPath = szTemplate;
    
    // Load the template from cache
    CTemplate *pTemplate = NULL;
    BOOL fTemplateInCache;
    hr = g_TemplateCache.Load(FALSE, szTemplate, DWInstanceID(), this, &pTemplate, &fTemplateInCache);

    if (FAILED(hr))
        {
        if (pTemplate)
            {
            pTemplate->Release();
            pTemplate = NULL;
            }

        m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
        m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

        // to tell the server object to display the correct error message
        return E_COULDNT_OPEN_SOURCE_FILE;
        }

    // Save HitObj's execution state info
    CComponentCollection  *saved_m_pPageCompCol           = m_pPageCompCol;
    CPageComponentManager *saved_m_pPageObjMgr            = m_pPageObjMgr;
    IUnknown              *saved_m_punkScriptingNamespace = m_punkScriptingNamespace;
    ActiveEngineInfo      *saved_m_pEngineInfo            = m_pEngineInfo;
    IDispatch             *saved_m_pdispTypeLibWrapper    = m_pdispTypeLibWrapper;

    CTemplate *saved_pTemplate = m_pResponse->SwapTemplate(pTemplate);
    void *saved_pvEngineInfo   = m_pResponse->SwapScriptEngineInfo(NULL);

    // Re-Init the saved state
    m_pPageCompCol = NULL;
    m_pPageObjMgr = NULL;
    m_punkScriptingNamespace = NULL;
    m_pEngineInfo = NULL;
    m_pdispTypeLibWrapper = NULL;

    // Create child request components framework
    hr = InitComponentProcessing();

    // Execute
    if (SUCCEEDED(hr))
        {
		// Set status code to 500 in error cases.
		if (FHasASPError())
			m_pResponse->put_Status(L"500 Internal Server Error");

        // Execute [child] script
        hr = ::Execute(pTemplate, this, intrinsics, TRUE);
        
        // OnEndPage
        if (m_pPageObjMgr)
            m_pPageObjMgr->OnEndPageAllObjects();
        }

    // Clean-out new components framework
    StopComponentProcessing();

    // Restore HitObj's execution state info
    m_pPageCompCol           = saved_m_pPageCompCol;
    m_pPageObjMgr            = saved_m_pPageObjMgr;
    m_punkScriptingNamespace = saved_m_punkScriptingNamespace;
    m_pEngineInfo            = saved_m_pEngineInfo;
    SetTypeLibWrapper(saved_m_pdispTypeLibWrapper);
    m_pResponse->SwapTemplate(saved_pTemplate);
    m_pResponse->SwapScriptEngineInfo(saved_pvEngineInfo);
    m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
    m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

    // Cleanup
    if (pTemplate)
        pTemplate->Release();

    if (m_pResponse->FResponseAborted() || fTransfer || FHasASPError())
        {
        // propagate Response.End up the script engine chain
        m_pResponse->End();
        }

    // Done
    return hr;
    }

/*===================================================================
CHitObj::GetASPError

Get ASP Error object. Used for Server.GetLastError()

Parameters
    ppASPError  [out] addref'd error object (new or old)
    
Returns
    HRESULT
===================================================================*/
HRESULT CHitObj::GetASPError
(
IASPError **ppASPError
)
    {
    Assert(ppASPError);
    
    if (m_pASPError == NULL)
        {
        // return bogus one
        *ppASPError = new CASPError;
        return (*ppASPError != NULL) ? S_OK : E_OUTOFMEMORY;
        }
        
    m_pASPError->AddRef();      // return addref'd
    *ppASPError = m_pASPError;
    return S_OK;
    }

/*===================================================================
CHitObj::RejectBrowserRequestWhenNeeded

Request reject-before-execution-started logic

Parameters:
    dwtQueueWaitTime    time request waited in the queue, ms
    pfRejected          OUT flag -- TRUE if rejected

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::RejectBrowserRequestWhenNeeded
(
DWORD dwtQueueWaitTime,
BOOL *pfRejected
)
    {
    Assert(FIsBrowserRequest());
    
    UINT wError = 0;
    
    // If shutting down
    if (IsShutDownInProgress())
        {
        wError = IDE_SERVER_SHUTTING_DOWN;
        }
        
    // If waited long enough need to check if still connected
    if (wError == 0)
        {
        DWORD dwConnTestSec = m_pAppln->QueryAppConfig()->dwQueueConnectionTestTime();
        
        if (dwConnTestSec != 0xffffffff && dwConnTestSec != 0)
            {
            if (dwtQueueWaitTime > (dwConnTestSec * 1000))
                {
                BOOL fConnected = TRUE;
                if (m_pIReq)
                    m_pIReq->TestConnection(&fConnected);

                // if client disconnected -- respond with 'Server Error'
                if (!fConnected)
                    {
                    wError = IDE_500_SERVER_ERROR;
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQCOMFAILED();
#endif                    
                    }
                }
            }
        }
    
    // If waited too long -- reject
    if (wError == 0)
        {
        DWORD dwTimeOutSec = m_pAppln->QueryAppConfig()->dwQueueTimeout();
        
        if (dwTimeOutSec != 0xffffffff && dwTimeOutSec != 0)
            {
            if (dwtQueueWaitTime > (dwTimeOutSec * 1000))
                {
                wError = IDE_SERVER_TOO_BUSY;
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQREJECTED();
#endif
                }
            }
        }

    if (wError)
        {
        m_fExecuting = FALSE; // before 'report error' to disable transfer
        ReportServerError(wError);
        *pfRejected = TRUE;
        }
    else
        {
        *pfRejected = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CHitObj::ReportServerError

Report server error without using the response object

Parameters:
    ErrorID     error message id

Returns:

Side effects:
    None.
===================================================================*/
HRESULT CHitObj::ReportServerError
(
UINT ErrorId
)
{
    // do nothing on non-browser requests or if no WAM_EXEC_INFO
    if (!FIsBrowserRequest() || m_pIReq == NULL)
        return S_OK;

    if (ErrorId)
    {
        Handle500Error(ErrorId, m_pIReq);
    }
         
    SetDoneWithSession();
    return S_OK;
}

#ifdef DBG
/*===================================================================
CHitObj::AssertValid

Test to make sure that the CHitObj object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CHitObj::AssertValid() const
    {
    Assert(m_fInited);
    Assert(FIsValidRequestType());
    if (FIsBrowserRequest())
        {
        Assert(m_pIReq != NULL);
        Assert(m_pPageCompCol != NULL );
        Assert(m_pPageObjMgr != NULL);
        }
    }
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\hashing.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.cpp

Owner: PramodD

This is the Link list and Hash table source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"


/*===================================================================
::DefaultHash

this is a hash algorithm that is highly recommended by Aho,
Seth, and Ulman from the dragon book. (THE compiler reference)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

DWORD DefaultHash(const BYTE *pbKey, int cbKey)
{
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);

    register unsigned uT, uResult = 0;
    register const BYTE *pb = pbKey;

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + *pb++;
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}



/*===================================================================
::UnicodeUpcaseHash

This is Aho, Seth, and Ulman's hash algorithm adapted for wide
character strings.  Their algorithm was not designed for cases
where every other character is 0 (which is how a unicode string
looks if you pretend it's ascii)  Therefore, performance
qualities are unknown for that case.

NOTE: for real Unicode, (not unicode that is merely ANSI converted)
      I have no idea how good a distribution this algorithm will
      produce. (since we are shifting in values > 8 bits now)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

#define toupper(x)  WORD(CharUpper(LPSTR(WORD(x))))

DWORD UnicodeUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on last CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    Assert ((cbKey & 1) == 0);      // cbKey better be even!
    int cwKey = unsigned(cbKey) >> 1;

    register const WORD *pw = reinterpret_cast<const WORD *>(pbKey) + cwKey;

    cwKey = min(cwKey, CCH_HASH);

   
    WCHAR awcTemp[CCH_HASH];

    // copy last cwKey WCHARs of pbKey to last cwKey WCHARs of awcTemp
    wcsncpy(awcTemp + CCH_HASH - cwKey, pw - cwKey, cwKey);
    CharUpperBuffW(awcTemp + CCH_HASH - cwKey, cwKey);

    pw = awcTemp + CCH_HASH;

    while (cwKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + *--pw;
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }
   
    return uResult;
}

DWORD MultiByteUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on first CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    unsigned char achTemp[CCH_HASH + 1];

    // For performance we only HASH on at most CCH_HASH characters.
    cbKey = min(cbKey, CCH_HASH);

    // Copy cbKey chacters into temporary buffer
    memcpy(achTemp, pbKey, cbKey);

    // Add terminating null character
    achTemp[cbKey] = 0;

    // Convert to upper case
    _mbsupr(achTemp);

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + achTemp[cbKey];
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}

/*===================================================================
::PtrHash

Hash function that returns the pointer itself as the
DWORD hash value


Parameters:
    BYTE *  pbKey
    int     cbKey (not used)

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD PtrHash
(
const BYTE *pbKey,
int /* cbKey */
)
    {
    return *(reinterpret_cast<DWORD *>(&pbKey));
    }


/*===================================================================
CLSIDHash

CLSID hash. Uses xor of the first and last DWORD

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD CLSIDHash
(
const BYTE *pbKey,
int cbKey
)
    {
    Assert(cbKey == 16);
    DWORD *pdwKey = (DWORD *)pbKey;
    return (pdwKey[0] ^ pdwKey[3]);
    }

/*===================================================================
CLinkElem::CLinkElem

The Constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkElem::CLinkElem(void)
: m_pKey(NULL),
  m_cbKey(0),
  m_Info(0),
  m_pPrev(NULL),
  m_pNext(NULL)
{
}

/*===================================================================
HRESULT CLinkElem::Init

Initializes class members

Parameters:
    void *  pKey
    int     cbKey

Returns:
    S_OK     Success
    E_FAIL      Error
===================================================================*/
HRESULT CLinkElem::Init( void *pKey, int cbKey )
{
    m_pPrev = NULL;
    m_pNext = NULL;
    m_Info = 0;

    if ( pKey == NULL || cbKey == 0 )
        return E_FAIL;

    m_pKey = static_cast<BYTE *>(pKey);
    m_cbKey = (short)cbKey;

    return S_OK;
}

/*===================================================================
CHashTable::CHashTable

Constructor for CHashTable

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::CHashTable( HashFunction pfnHash )
: m_fInited(FALSE),
  m_fBucketsAllocated(FALSE),
  m_pHead(NULL),
  m_pTail(NULL),
  m_rgpBuckets(NULL),
  m_pfnHash(pfnHash),
  m_cBuckets(0),
  m_Count(0)
{
}

/*===================================================================
CHashTable::~CHashTable

Destructor for CHashTable. Frees allocated bucket array.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::~CHashTable( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
    }
}

/*===================================================================
HRESULT CHashTable::UnInit

Frees allocated bucket array.

Parameters:
    NONE

Returns:
    S_OK     Always
===================================================================*/
HRESULT CHashTable::UnInit( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
        m_fBucketsAllocated = FALSE;
    }

    m_rgpBuckets = NULL;
    m_pHead      = NULL;
    m_pTail      = NULL;
    m_cBuckets   = 0;
    m_Count      = 0;
    m_fInited    = FALSE;

    return S_OK;
}

/*===================================================================
void CHashTable::AssertValid

Verify integrity of the data structure.

NOTE: This function does very deep integrity checks and thus is
      very slow.

Checks performed:

        verify that m_Count is valid
        verify that each element is in the right bucket
        verify prev, next links and info fields
===================================================================*/

#ifdef DBG
void CHashTable::AssertValid() const
{
    CLinkElem *pElem;       // pointer to current link element
    unsigned i;             // index into current bucket
    unsigned cItems = 0;    // actual number of items in the table

    Assert(m_fInited);

    if (m_Count == 0)
    {
        if (m_rgpBuckets)
        {
            BOOL fAllNulls = TRUE;
            // empty hash table - make sure that everything reflects this
            Assert(m_pHead == NULL);
            Assert (m_pTail == NULL);

            for (i = 0; i < m_cBuckets; i++)
            {
                if (m_rgpBuckets[i] != NULL)
                {
                    fAllNulls = FALSE;
                    break;
                }
            }

            Assert(fAllNulls);
        }
        return;
    }

    // If m_Count > 0
    Assert(m_pHead);
    Assert(m_pHead->m_pPrev == NULL);
    Assert(m_pTail != NULL && m_pTail->m_pNext == NULL);
    Assert(m_rgpBuckets);

    // Now verify each entry
    for (i = 0; i < m_cBuckets; ++i)
    {
        pElem = m_rgpBuckets[i];
        while (pElem != NULL)
        {
            // Verify hashing
            Assert ((m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets) == i);

            // Verify links
            if (pElem->m_pPrev)
                {
                Assert (pElem->m_pPrev->m_pNext == pElem);
                }
            else
                {
                Assert (m_pHead == pElem);
                }
                
            if (pElem->m_pNext)
                {
                Assert (pElem->m_pNext->m_pPrev == pElem);
                }
            else
                {
                Assert (m_pTail == pElem);
                }

            // Verify info fields
            Assert (pElem->m_Info >= 0);
            if (pElem != m_rgpBuckets[i])
                {
                Assert (pElem->m_Info == pElem->m_pPrev->m_Info - 1);
                }

            // Prepare for next iteration, stopping when m_Info is zero.
            ++cItems;
            if (pElem->m_Info == 0)
                break;

            pElem = pElem->m_pNext;
        }
    }

    // Verify count
    Assert (m_Count == cItems);
}
#endif



/*===================================================================
HRESULT CHashTable::Init

Initialize CHashTable by allocating the bucket array and
and initializing the bucket link lists.

Parameters:
    UINT    cBuckets    Number of buckets

Returns:
    HRESULT S_OK
            E_OUTOFMEMORY
===================================================================*/
HRESULT CHashTable::Init( UINT cBuckets )
{
    m_cBuckets = cBuckets;
    m_Count = 0;
    m_rgpBuckets = NULL;  // created on demand

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
HRESULT CHashTable::ReInit

Reinitialize CHashTable by deleting everything in it.  - client
is responsible for making the hashtable empty first

Parameters:
    None

Returns:
    None
===================================================================*/
void CHashTable::ReInit()
{
    Assert( m_fInited );

    if (m_rgpBuckets)
        memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));

    m_Count = 0;
    m_pHead = NULL;
    m_pTail = NULL;
}

/*===================================================================
HRESULT CHashTable::AllocateBuckets()

Allocates hash table buckets on demand

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHashTable::AllocateBuckets()
{
    Assert(m_rgpBuckets == NULL);
    Assert(m_fInited);
    Assert(m_cBuckets > 0);

    if (m_cBuckets <= PREALLOCATED_BUCKETS_MAX)
    {
        m_rgpBuckets = m_rgpBucketsBuffer;
    }
    else
    {
        m_rgpBuckets = new CLinkElem * [m_cBuckets];
        if (m_rgpBuckets == NULL)
            return E_OUTOFMEMORY;
        m_fBucketsAllocated = TRUE;
    }

    memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));
    return S_OK;
}

/*===================================================================
BOOL CHashTable::FIsEqual

compare two keys using their lengths and memcmp()

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTable::FIsEqual( const void * pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if (cbKey1 != cbKey2)
        return FALSE;

    return memcmp(pKey1, pKey2, cbKey1) == 0;
}

#pragma optimize("g", off)
/*===================================================================
CHashTable::AddElem

Adds a CLinkElem to Hash table.
User is responsible for allocating the Element to be added.

Parameters:
    CLinkElem * pElem       Object to be added
    BOOL        fTestDups   Look for duplicates if true

Returns:
    Pointer to element added/found.
===================================================================*/
CLinkElem *CHashTable::AddElem( CLinkElem *pElem, BOOL fTestDups )
{
    if (m_rgpBuckets == NULL)
    {
        if (FAILED(AllocateBuckets()))
            return NULL;
    }

    if (pElem == NULL)
        return NULL;

    BOOL        fNew = TRUE;
    DWORD       iT = m_pfnHash( pElem->m_pKey, pElem->m_cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    BOOL        fDebugTestDups = FALSE;

#ifdef DBG
    // In retail, if fTestDups is false, it means that
    // there shouldnt be any dups, so dont bother testing.  Under debug, however
    // we want to be able to assert that there isnt a dup (since there isnt supposed to be one).
    fDebugTestDups = !fTestDups;
#endif

    if (fTestDups || fDebugTestDups)
    {
        while ( pT && fNew )
        {
            if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pElem->m_pKey, pElem->m_cbKey ) )
                fNew = FALSE;
            else if ( pT->m_Info > 0 )
                pT = pT->m_pNext;
            else
                break;
        }
    }

#ifdef DBG
    // If there arent supposed to be any dups, then make sure this element is seen as "new"
    if (fDebugTestDups)
        Assert(fNew);
#endif

#ifdef DUMP_HASHING_INFO
    static DWORD cAdds = 0;
    FILE *logfile = NULL;

    if (cAdds++ > 1000000 && m_Count > 100)
        {
        cAdds = 0;
        if (logfile = fopen("C:\\Temp\\hashdump.Log", "a+"))
            {
            DWORD cZero = 0;
            short iMax = 0;
            DWORD cGte3 = 0;
            DWORD cGte5 = 0;
            DWORD cGte10 = 0;

            fprintf(logfile, "Hash dump: # elements = %d\n", m_Count);
            for (UINT iBucket = 0; iBucket < m_cBuckets; iBucket++)
                {
                if (m_rgpBuckets[iBucket] == NULL)
                    cZero++;
                else
                    {
                    short Info = m_rgpBuckets[iBucket]->m_Info;
                    if (Info > iMax)
                        iMax = Info;
                    if (Info >= 10) cGte10++;
                    else if (Info >= 5) cGte5++;
                    else if (Info >= 3) cGte3++;
                    }
                }
            fprintf(logfile, "Max chain = %d, # 0 chains = %d, # >= 3 = %d, # >= 5 = %d, # >= 10 = %d\n",
                        (DWORD)iMax, cZero, cGte3, cGte5, cGte10);
            fflush(logfile);
            fclose(logfile);
            }
        }
#endif

    if ( fNew )
    {
        if ( pT )
        {
            // There are other elements in bucket
            pT = m_rgpBuckets[iT];
            m_rgpBuckets[iT] = pElem;
            pElem->m_Info = pT->m_Info + 1;
            pElem->m_pNext = pT;
            pElem->m_pPrev = pT->m_pPrev;
            pT->m_pPrev = pElem;
            if ( pElem->m_pPrev == NULL )
                m_pHead = pElem;
            else
                pElem->m_pPrev->m_pNext = pElem;
        }
        else
        {
            // This is the first element in the bucket
            m_rgpBuckets[iT] = pElem;
            pElem->m_pPrev = NULL;
            pElem->m_pNext = m_pHead;
            pElem->m_Info = 0;
            if ( m_pHead )
                m_pHead->m_pPrev = pElem;
            else
                m_pTail = pElem;
            m_pHead = pElem;
        }
        m_Count++;

        AssertValid();
        return pElem;
    }

    AssertValid();
    return pT;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CLinkElem * CHashTable::FindElem

Finds an object in the hash table based on the name.

Parameters:
    void *  pKey
    int     cbKey

Returns:
    Pointer to CLinkElem if found, otherwise NULL.
===================================================================*/
CLinkElem * CHashTable::FindElem( const void *pKey, int cbKey )
{
    AssertValid();

    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    CLinkElem * pRet = NULL;

    while ( pT && pRet == NULL )
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }

    return pRet;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CHashTable::DeleteElem

Removes a CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    void *  pbKey       key
    int     cbKey       length of key

Returns:
    Pointer to element removed, NULL if not found
===================================================================*/
CLinkElem * CHashTable::DeleteElem( const void *pKey, int cbKey )
{
    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    CLinkElem * pRet = NULL;
    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];

    while ( pT && pRet == NULL )// Find it !
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }
    if ( pRet )
    {
        pT = m_rgpBuckets[iT];

        if ( pRet == pT )
        {
            // Update bucket head
            if ( pRet->m_Info > 0 )
                m_rgpBuckets[iT] = pRet->m_pNext;
            else
                m_rgpBuckets[iT] = NULL;
        }
        // Update counts in bucket link list
        while ( pT != pRet )
        {
            pT->m_Info--;
            pT = pT->m_pNext;
        }
        // Update link list
        if ( pT = pRet->m_pPrev )
        {
            // Not the Head of the link list
            if ( pT->m_pNext = pRet->m_pNext )
                pT->m_pNext->m_pPrev = pT;
            else
                m_pTail = pT;
        }
        else
        {
            // Head of the link list
            if ( m_pHead = pRet->m_pNext )
                m_pHead->m_pPrev = NULL;
            else
                m_pTail = NULL;
        }
        m_Count--;
    }

    AssertValid();
    return pRet;
}
#pragma optimize("g", on)

/*===================================================================
CHashTable::RemoveElem

Removes a given CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    CLinkElem * pLE     Element to remove

Returns:
    Pointer to element removed
===================================================================*/
CLinkElem * CHashTable::RemoveElem( CLinkElem *pLE )
{
    CLinkElem *pLET;

    if ( m_rgpBuckets == NULL || pLE == NULL )
        return NULL;

    // Remove this item from the linked list
    pLET = pLE->m_pPrev;
    if (pLET)
        pLET->m_pNext = pLE->m_pNext;
    pLET = pLE->m_pNext;
    if (pLET)
        pLET->m_pPrev = pLE->m_pPrev;
    if (m_pHead == pLE)
        m_pHead = pLE->m_pNext;
    if (m_pTail == pLE)
        m_pTail = pLE->m_pPrev;

    /*
     * If this was the first item in a bucket, then fix up the bucket.
     * Otherwise, decrement the count of items in the bucket for each item
     * in the bucket prior to this item
     */
    if (pLE->m_pPrev == NULL || pLE->m_pPrev->m_Info == 0)
        {
        UINT iBucket;

        // This item is head of a bucket.  Need to find out which bucket!
        for (iBucket = 0; iBucket < m_cBuckets; iBucket++)
            if (m_rgpBuckets[iBucket] == pLE)
                break;
        Assert(iBucket < m_cBuckets && m_rgpBuckets[iBucket] == pLE);

        if (pLE->m_Info == 0)
            m_rgpBuckets[iBucket] = NULL;
        else
            m_rgpBuckets[iBucket] = pLE->m_pNext;
        }
    else
        {
        // This item is in the middle of a bucket chain.  Update counts in preceeding items
        pLET = pLE->m_pPrev;
        while (pLET != NULL && pLET->m_Info != 0)
            {
            pLET->m_Info--;
            pLET = pLET->m_pPrev;
            }
        }

    // Decrement count of total number of items
    m_Count--;

    AssertValid();
    return pLE;
}

/*===================================================================
CHashTableStr::CHashTableStr

Constructor for CHashTableStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableStr::CHashTableStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableStr::FIsEqual

compare two keys using their lengths, treating the keys
as Unicode and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableStr::FIsEqual( const void *  pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _wcsnicmp(static_cast<const wchar_t *>(pKey1), static_cast<const wchar_t *>(pKey2), cbKey1) == 0;
}


/*===================================================================
CHashTableMBStr::CHashTableMBStr

Constructor for CHashTableMBStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableMBStr::CHashTableMBStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableMBStr::FIsEqual

compare two keys using their lengths, treating the keys
as multi-byte strings and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableMBStr::FIsEqual( const void *    pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _mbsnicmp(static_cast<const unsigned char *>(pKey1), static_cast<const unsigned char *>(pKey2), cbKey1) == 0;
}

/*===================================================================
CHashTablePtr::CHashTablePtr

Constructor for CHashTableStr

Parameters:
    HashFunction pfnHash    has function (PtrHash is default)

Returns:
    NONE
===================================================================*/
CHashTablePtr::CHashTablePtr
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTablePtr::FIsEqual

Compare two pointers.
Used by CHashTable to find elements

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key (unused)
    const void *pKey2       second key
    int         cbKey2      length of second key (unused)

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTablePtr::FIsEqual
(
const void *pKey1,
int        /* cbKey1 */,
const void *pKey2,
int         /* cbKey2 */
)
    {
    return (pKey1 == pKey2);
    }

/*===================================================================
CHashTableCLSID::CHashTableCLSID

Constructor for CHashTableCLSID

Parameters:
    HashFunction pfnHash    has function (CLSIDHash is default)

Returns:
    NONE
===================================================================*/
CHashTableCLSID::CHashTableCLSID
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTableCLSID::FIsEqual

Compare two CLSIDs.

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTableCLSID::FIsEqual
(
const void *pKey1,
int         cbKey1,
const void *pKey2,
int         cbKey2
)
    {
    Assert(cbKey1 == sizeof(CLSID) && cbKey2 == sizeof(CLSID));
    return IsEqualCLSID(*((CLSID *)pKey1), *((CLSID *)pKey2));
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\hostinfo.h ===
#ifndef HOST_INFO_H_INCLUDED
#define HOST_INFO_H_INCLUDED

// {1D044690-8923-11d0-ABD2-00A0C911E8B2}
const GUID IID_IHostInfoUpdate =
{ 0x1d044690, 0x8923, 0x11d0, { 0xab, 0xd2, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

enum hostinfo
{
	hostinfoLocale = 0,
	hostinfoCodePage = 1
};

class IHostInfoUpdate : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoUpdate Methods ***

	STDMETHOD(UpdateInfo)(hostinfo hostinfoNew) = 0;
};

// {F8418AE0-9A5D-11d0-ABD4-00A0C911E8B2}
const GUID IID_IHostInfoProvider =
{ 0xf8418ae0, 0x9a5d, 0x11d0, { 0xab, 0xd4, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

class IHostInfoProvider : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoProvider Methods ***

	STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void * * ppvInfo) = 0;
};

#endif // HOST_INFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\hitobj.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Object

File: Hitobj.h

Owner: PramodD

This is the Hit Object header file.
===================================================================*/
#ifndef HITOBJ_H
#define HITOBJ_H

#include "Compcol.h"
#include "Sessmgr.h"
#include "Applmgr.h"
#include "Context.h"
#include "aspresource.h"
#include "exec.h"
#include "glob.h"
#include "memcls.h"
#include "gip.h"
#include "txnsup.h"

#define SESSIONID_LEN   24

// HitObj type
#define EHitType                DWORD
#define ehtUnInitedRequest      0x00000000
#define ehtBrowserRequest       0x00000001
#define ehtSessionCleanup       0x00000002
#define ehtApplicationCleanup   0x00000004

// Execution status (result)
#define EExecStatus             DWORD
#define eExecFailed             0x00000000
#define eExecSucceeded          0x00000001
#define eExecTimedOut           0x00000002

// Current execution state
#define EEventState             DWORD
#define eEventNone              0x00000000
#define eEventAppOnStart        0x00000001
#define eEventSesOnStart        0x00000002
#define eEventAppOnEnd          0x00000004
#define eEventSesOnEnd          0x00000008

// Global interface table
extern IGlobalInterfaceTable *g_pGIT;

extern LONG  g_nRequestsHung;

/*===================================================================
  C H i t O b j
  
The Hit Manager runs in the context of an IIS thread.
It packages up a request, calls Viper async. and 
on callback executes the request
===================================================================*/

class CHitObj
    {
private:
    // Flags and other bit-fields
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fRunGlobalAsa : 1;          // Should we run global.asa
    DWORD m_fStartSession : 1;          // New session
    DWORD m_fNewCookie : 1;             // Is New session cookie?
    DWORD m_fStartApplication : 1;      // New application
    DWORD m_fClientCodeDebug : 1;       // Client code debug enabled?
    DWORD m_fApplnOnStartFailed : 1;    // Application_OnStart failed
    DWORD m_fCompilationFailed : 1;     // Script Compilation error?
    DWORD m_fExecuting : 1;             // Currently inside Viper callback
    DWORD m_fHideRequestAndResponseIntrinsics : 1;  // TRUE while instrinsics are hidden
    DWORD m_fHideSessionIntrinsic : 1;  // TRUE if session intrinsic's hidden
    DWORD m_fDoneWithSession : 1;       // TRUE after DONE_WITH_SESSION
    DWORD m_fRejected : 1;              // TRUE if rejected (not posted)
    DWORD m_f449Done : 1;               // 449 processing done for this request
    DWORD m_fInTransferOnError : 1;     // doing transfer on error (to break infinite)
    DWORD m_fSecure : 1;                // Secure Connection

    EHitType    m_ehtType : 4;          // Type of the request
    EExecStatus m_eExecStatus : 4;      // Error Status // for Perf Counter only
    EEventState m_eEventState : 4;      // Current Event
    CompScope   m_ecsActivityScope : 4; // Which activity running this request?

    LONG        m_fRequestTimedout;     // true if request exceeded its timeout

    // Intrinsics set from inside HitObj
    CSession  *m_pSession;
    CAppln    *m_pAppln;
    CResponse *m_pResponse;
    CRequest  *m_pRequest;
    CServer   *m_pServer;
    CASPObjectContext   *m_pASPObjectContext;

    // IsapiReqInfo

    CIsapiReqInfo   *m_pIReq;

    // Intrinsics set from outside HitObj (to be ref. counted)
    IUnknown *m_punkScriptingNamespace;

    // Component collection of extrinsic objects
    CComponentCollection  *m_pPageCompCol;
    CPageComponentManager *m_pPageObjMgr;

    // Impersonation handle
    HANDLE m_hImpersonate;

    // Viper page-level activity (if no session)
    CViperActivity *m_pActivity;

    // Current session info
    char        m_szSessionCookie[SESSIONID_LEN+4]; // +4 to keep DWORD boundary
    CSessionId  m_SessionId;

    // Context object (for OnStartPage)
    CScriptingContext * m_pScriptingContext;

    // Misc
    long                m_nScriptTimeout;   // Maximum number of seconds script should run
    UINT                m_uCodePage;        // RunTime CodePage
    LCID                m_lcid;             // RunTime LCID
    ActiveEngineInfo   *m_pEngineInfo;      // List of active engines for this hit objext
    IDispatch          *m_pdispTypeLibWrapper;  // Page-level typelib wrapper
    DWORD               m_dwtTimestamp;     // Timestamp for wait time and perf calcs

    // Used to reffer to the current template during the compilation
    TCHAR              *m_szCurrTemplatePhysPath;
    TCHAR              *m_szCurrTemplateVirtPath;

    // ASP Error object
    IASPError          *m_pASPError;

    // Store a pointer to the associated template so as to avoid redundant
    // FindTemplate calls.
    
    CTemplate          *m_pTemplate;

    // Private interfaces
    HRESULT             ParseCookiesForSessionIdAndFlags();
    // Request rejection logic
    HRESULT             RejectBrowserRequestWhenNeeded(DWORD dwtQueueWaitTime, BOOL *pfRejected);


// Public Interfaces
public: 
                        CHitObj();
    virtual             ~CHitObj();

    static HRESULT      NewBrowserRequest(CIsapiReqInfo   *pIReq, 
                                          BOOL *pfRejected = NULL, 
                                          BOOL *pfCompleted = NULL,
                                          int  *piErrorId  = NULL);
                                          
    HRESULT             BrowserRequestInit(CIsapiReqInfo   *pIReq, int * dwId);
    HRESULT             AssignApplnToBrowserRequest(BOOL *pfApplnRestarting);
    HRESULT             AssignSessionToBrowserRequest(BOOL *pfNewSession, BOOL *pfNewCookie, int *pErrorId);
    HRESULT             DetachBrowserRequestFromSession();
    HRESULT             ReassignAbandonedSession();
    
    void                SessionCleanupInit(CSession *pSession);
    void                ApplicationCleanupInit(CAppln *pAppln);
    
    BOOL                SendHeader(const char *szStatus);
    BOOL                SendError(const char *szError);
    
    TCHAR*              GetSzAppPhysicalPath(void);
    void                ApplnOnStartFailed();
    void                SessionOnStartFailed();
    void                SessionOnStartInvoked();
    void                SessionOnEndPresent();
    void                SetEventState(EEventState eEvent);
    EEventState         EventState();

    // Report server error without response object
    HRESULT ReportServerError(UINT ErrorId);

// Component Collection Interfaces

    HRESULT InitComponentProcessing();
    HRESULT StopComponentProcessing();
    
    HRESULT GetPageComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnComponentCollection(CComponentCollection **ppCollection);

    HRESULT AddComponent(CompType type, const CLSID &clsid, CompScope scope,
                         CompModel model, LPWSTR pwszName = NULL,
                         IUnknown *pUnk = NULL);
    HRESULT GetComponent(CompScope scope, LPWSTR pwszName, DWORD cbName,
                         CComponentObject **ppObj);
    HRESULT GetIntrinsic(LPWSTR pwszName, DWORD cbName, IUnknown **ppUnk);
    HRESULT CreateComponent(const CLSID &clsid, IDispatch **ppDisp);
    HRESULT SetPropertyComponent(CompScope scope, LPWSTR pwszName,
                          VARIANT *pVariant);
    HRESULT GetPropertyComponent(CompScope scope, LPWSTR pwszName,
                        CComponentObject **ppObj);

// Viper Integration

    CViperActivity *PActivity();
    CViperActivity *PCurrentActivity();
    HRESULT SetActivity(CViperActivity *pActivity);

    HRESULT PostViperAsyncCall();
    HRESULT ViperAsyncCallback(BOOL *pfRePosted);

// Execute / Transfer

    HRESULT ExecuteChildRequest(BOOL fTransfer, TCHAR *szTemplate, TCHAR *szVirtTemplate);

    HRESULT     GetASPError(IASPError **ppASPError);
    inline void SetASPError(IASPError *pASPError);
    inline BOOL FHasASPError();
    
// inline functions
public:
    CIsapiReqInfo      *PIReq();
    HANDLE              HImpersonate();
    CResponse *         PResponse();
    CRequest *          PRequest();
    CServer *           PServer();
    CAppln *            PAppln();
    CSession *          PSession();
    CASPObjectContext  *PASPObjectContext();
    CASPObjectContext  *SetASPObjectContext(CASPObjectContext  *);
    CPageComponentManager * PPageComponentManager();
    BOOL                FIsBrowserRequest() const;
    BOOL                FIsSessionCleanupRequest() const;
    BOOL                FIsApplnCleanupRequest() const;
    BOOL                FIsValidRequestType() const;
    const char *        PSzNewSessionCookie() const;
    DWORD               SessionId() const;
    CScriptingContext * PScriptingContextGet();
    BOOL                FStartApplication();
    BOOL                FStartSession();
    BOOL                FNewCookie();
    BOOL                FObjectTag(IDispatch * pDispatch);
    BOOL                FHasSession();
    BOOL                FClientCodeDebug();
    BOOL                FDoneWithSession();
    BOOL                FExecuting();
    void                SetFExecuting(BOOL  fValue);
    BOOL                F449Done();
    BOOL                FInTransferOnError();
    BOOL                FSecure();

    void                SetScriptTimeout(long nScriptTimeout);
    long                GetScriptTimeout();
    void                SetExecStatus(EExecStatus status);
    EExecStatus         ExecStatus();
    void                SetActiveEngineInfo(ActiveEngineInfo *);
    void                SetCompilationFailed();
    void                SetDoneWithSession();
    void                Set449Done();
    void                SetInTransferOnError();

    void                SetRequestTimedout();
    
    TCHAR *             GlobalAspPath();
    HRESULT             SetCodePage(UINT uCodePage);    // Proxy function, CodePage is stored in m_pSession
    UINT                GetCodePage();                  // same as above
    HRESULT             SetLCID(LCID lcid);             // Proxy function, LCID is stored in m_pSession
    LCID                GetLCID();                  // same as above

    CAppConfig *        QueryAppConfig();

    TCHAR *              PSzCurrTemplatePhysPath();
    TCHAR *              PSzCurrTemplateVirtPath();
    DWORD               DWInstanceID();

    CTemplate          *GetTemplate();
    void                SetTemplate(CTemplate *);

    // Instead of add/remove to/from component collection use these:
    void HideRequestAndResponseIntrinsics();
    void UnHideRequestAndResponseIntrinsics();
    BOOL FRequestAndResponseIntrinsicsHidden();
    void AddScriptingNamespace(IUnknown *punkNamespace);
    void RemoveScriptingNamespace();

    // Typelib wrapper support
    IDispatch *PTypeLibWrapper();
    void SetTypeLibWrapper(IDispatch *pdisp);

    // Timestamp manipulation
    void  UpdateTimestamp();
    DWORD ElapsedTimeSinceTimestamp();

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  CHitObj inlines
===================================================================*/

inline CIsapiReqInfo   *CHitObj::PIReq()
    {
    return m_pIReq; 
    }
    
inline BOOL CHitObj::FIsBrowserRequest() const
    {
    return (m_ehtType == ehtBrowserRequest);
    }

inline BOOL CHitObj::FIsSessionCleanupRequest() const
    {
    return (m_ehtType == ehtSessionCleanup);
    }
    
inline BOOL CHitObj::FIsApplnCleanupRequest() const
    {
    return (m_ehtType == ehtApplicationCleanup);
    }

inline BOOL CHitObj::FIsValidRequestType() const
    {
    return (FIsBrowserRequest() || 
            FIsSessionCleanupRequest() ||
            FIsApplnCleanupRequest());
    }
    
inline HANDLE CHitObj::HImpersonate()
    {
    return m_hImpersonate; 
    }

inline DWORD CHitObj::SessionId() const 
    {
    return m_SessionId.m_dwId; 
    }

inline const char *CHitObj::PSzNewSessionCookie() const 
    {
    return (m_fNewCookie ? m_szSessionCookie : NULL); 
    }

inline BOOL CHitObj::FStartApplication()
    {
    return m_fStartApplication; 
    }

inline BOOL CHitObj::FStartSession()
    {
    return m_fStartSession; 
    }

inline BOOL CHitObj::FNewCookie() 
    {
    return m_fNewCookie; 
    }

inline BOOL CHitObj::FHasSession()
    {
    return (m_pSession != NULL && !m_fHideSessionIntrinsic);
    }

inline BOOL CHitObj::FClientCodeDebug()
    {
    return m_fClientCodeDebug;
    }

inline BOOL CHitObj::FDoneWithSession()
    {
    return m_fDoneWithSession;
    }

inline BOOL CHitObj::FExecuting()
    {
    return m_fExecuting;
    }

inline void CHitObj::SetFExecuting(BOOL  fValue)
{
    m_fExecuting = fValue;
}

inline BOOL CHitObj::F449Done()
    {
    return m_f449Done;
    }

inline BOOL CHitObj::FInTransferOnError()
    {
    return m_fInTransferOnError;
    }

inline BOOL CHitObj::FSecure()
    {
    return m_fSecure;
    }

inline void CHitObj::SessionOnStartFailed() 
    {
    Assert(m_pSession);
    m_pSession->SetOnStartFailedFlag();
    }
    
inline void CHitObj::ApplnOnStartFailed() 
    {
    m_fApplnOnStartFailed = TRUE;
    
    if (m_pSession)
        SessionOnStartFailed();
    }
    
inline void CHitObj::SessionOnStartInvoked()
    {
    Assert(m_pSession); 
    m_pSession->SetOnStartInvokedFlag(); 
    }

inline void CHitObj::SessionOnEndPresent()
    {
    Assert(m_pSession); 
    m_pSession->SetOnEndPresentFlag(); 
    }

inline DWORD CHitObj::DWInstanceID()
    {
    return (m_pIReq) ? m_pIReq->QueryInstanceId() : 0;
    }

inline CViperActivity *CHitObj::PActivity()
    {
    return m_pActivity; 
    }
    
inline CScriptingContext *CHitObj::PScriptingContextGet()
    {
    return m_pScriptingContext; 
    }
    
inline CResponse *CHitObj::PResponse()
    {
    return m_pResponse; 
    }

inline CRequest *CHitObj::PRequest()
    {
    return m_pRequest; 
    }

inline CServer *CHitObj::PServer()
    {
    return m_pServer; 
    }

inline CAppln *CHitObj::PAppln()
    {
    return m_pAppln;
    }

inline CSession *CHitObj::PSession()
    {
    return m_pSession;
    }

inline CASPObjectContext *CHitObj::PASPObjectContext()
{
    return m_pASPObjectContext;
}

inline CASPObjectContext *CHitObj::SetASPObjectContext(CASPObjectContext *pContext)
{
    CASPObjectContext   *pPoppedContext = m_pASPObjectContext;
    m_pASPObjectContext = pContext;

    return pPoppedContext;
}

inline CPageComponentManager *CHitObj::PPageComponentManager()
    {
    return m_pPageObjMgr;
    }

inline TCHAR *CHitObj::GlobalAspPath()
    {
    if ( m_fRunGlobalAsa )
        return m_pAppln->GetGlobalAsa();
    else
        return NULL;
    }

inline void CHitObj::SetScriptTimeout(long nScriptTimeout)
    {
    m_nScriptTimeout = nScriptTimeout; 
    }
    
inline long CHitObj::GetScriptTimeout()
    {
    return m_nScriptTimeout; 
    }

inline void CHitObj::SetExecStatus(EExecStatus status)
    {
    m_eExecStatus = status;
    }
    
inline EExecStatus CHitObj::ExecStatus()
    {
    return m_eExecStatus;
    }
    
inline EEventState CHitObj::EventState()
    {
    return m_eEventState;
    }

inline void CHitObj::SetEventState(EEventState eState)
    {
    m_eEventState = eState;
    }

inline CAppConfig * CHitObj::QueryAppConfig(void)
    {
    return m_pAppln->QueryAppConfig();
    }
    
inline UINT CHitObj::GetCodePage(void)
    {
    return m_uCodePage == 0 ? GetACP() : m_uCodePage;
    }

inline LCID CHitObj::GetLCID()
    {
    return m_lcid;
    }

inline  VOID CHitObj::SetActiveEngineInfo(ActiveEngineInfo *pActiveEngineInfo)
    {
    m_pEngineInfo = pActiveEngineInfo;
    }

inline void CHitObj::SetCompilationFailed()
    {
    m_fCompilationFailed = TRUE;
    }

inline void CHitObj::SetDoneWithSession()
    {
    Assert(!m_fDoneWithSession);
    m_fDoneWithSession = TRUE;
    }

inline void CHitObj::Set449Done()
    {
    Assert(!m_f449Done);
    m_f449Done = TRUE;
    }

inline void CHitObj::SetInTransferOnError()
    {
    Assert(!m_fInTransferOnError);
    m_fInTransferOnError = TRUE;
    }

inline void CHitObj::SetRequestTimedout()
{
    LONG    fPrev = InterlockedExchange(&m_fRequestTimedout, 1);

    if (fPrev == 0) {
        InterlockedIncrement(&g_nRequestsHung);
    }
}    

inline void CHitObj::HideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = TRUE;
    }
    
inline void CHitObj::UnHideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = FALSE;
    }

inline BOOL CHitObj::FRequestAndResponseIntrinsicsHidden()
    {
    return m_fHideRequestAndResponseIntrinsics;
    }

inline void CHitObj::AddScriptingNamespace(IUnknown *punkNamespace)
    {
    Assert(m_punkScriptingNamespace == NULL);
    Assert(punkNamespace);
    m_punkScriptingNamespace = punkNamespace;
    m_punkScriptingNamespace->AddRef();
    }
    
inline void CHitObj::RemoveScriptingNamespace()
    {
    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
    }
    
inline IDispatch *CHitObj::PTypeLibWrapper()
    {
    return m_pdispTypeLibWrapper;
    }
    
inline void CHitObj::SetTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();
        
    m_pdispTypeLibWrapper = pdisp;
    
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->AddRef();
    }

inline void CHitObj::UpdateTimestamp() 
    {
    m_dwtTimestamp = GetTickCount();
    }
    
inline DWORD CHitObj::ElapsedTimeSinceTimestamp() 
    {
    DWORD dwt = GetTickCount();
    if (dwt >= m_dwtTimestamp)
        return (dwt - m_dwtTimestamp);
    else
        return ((0xffffffff - m_dwtTimestamp) + dwt);
    }

inline TCHAR *CHitObj::PSzCurrTemplatePhysPath()
    {
    if (m_szCurrTemplatePhysPath != NULL) 
        return m_szCurrTemplatePhysPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathTranslated();
    else
        return NULL;
    }
    
inline TCHAR *CHitObj::PSzCurrTemplateVirtPath()
    {
    if (m_szCurrTemplateVirtPath != NULL) 
        return m_szCurrTemplateVirtPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathInfo();
    else
        return NULL;
    }

inline void CHitObj::SetASPError(IASPError *pASPError)
    {
    if (m_pASPError)
        m_pASPError->Release();
    m_pASPError = pASPError;  // passed addref'd
    }

inline BOOL CHitObj::FHasASPError()
    {
    return (m_pASPError != NULL);
    }

inline CTemplate *CHitObj::GetTemplate()
    {
    return m_pTemplate;
    }

inline void CHitObj::SetTemplate(CTemplate *pTemplate)
{
    m_pTemplate = pTemplate;
}

/*===================================================================
  Globals
===================================================================*/

extern DWORD g_nBrowserRequests;
extern DWORD g_nSessionCleanupRequests;
extern DWORD g_nApplnCleanupRequests;

#undef  SCRIPT_STATS

#ifdef SCRIPT_STATS
# include <locks.h>

void
ReadRegistrySettings();

extern CSmallSpinLock g_lockRequestStats;
extern DWORD          g_dwQueueDebugThreshold;
extern DWORD          g_fSendScriptlessOnAtqThread;
extern LONG           g_cRequests;
extern LONG           g_cScriptlessRequests;
extern LONG           g_cHttpExtensionsExecuting;
extern LONG           g_cConcurrentScriptlessRequests;
extern LONG           g_cMaxConcurrentScriptlessRequests;
extern LONGLONG       g_nSumConcurrentScriptlessRequests;
extern LONGLONG       g_nSumExecTimeScriptlessRequests;
extern LONG           g_nAvgConcurrentScriptlessRequests;
extern LONG           g_nAvgExecTimeScriptlessRequests;
#endif // SCRIPT_STATS

#endif // HITOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\htmldump.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ASP Status Html Dump

File: htmldump.cpp

Owner: dmitryr

This file contains the ASP status html dump code
used from IISPROBE.DLL 
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"

#include "memcls.h"
#include "memchk.h"

/*===================================================================
Helper classes and functions
===================================================================*/
class CAspDump
    {
private:
    char *m_szBuffer;
    DWORD m_dwMaxSize;
    DWORD m_dwActSize;

public:
    CAspDump(char *szBuffer, DWORD dwMaxSize)
        {
        m_szBuffer = szBuffer;
        m_dwMaxSize = dwMaxSize;
        m_dwActSize = 0;
        }

    inline void __cdecl Dump(LPCSTR fmt, ...)
        {
        char szStr[512];
        
        va_list marker;
        va_start(marker, fmt);
        vsprintf(szStr, fmt, marker);
        va_end(marker);
        
        DWORD len = strlen(szStr);
            
        if (len > 0 && len < (m_dwMaxSize-m_dwActSize))
            {
            memcpy(m_szBuffer+m_dwActSize, szStr, len+1);
            m_dwActSize += len;
            }
        }

    DWORD GetSize()
        {
        return m_dwActSize;
        }
    };


/*===================================================================
AspStatusHtmlDump

Function called from IISPROBE.DLL
Fills in the buffer with the ASP status as HTML

Parameters:
    szBuffer        buffer to fill in
    pwdSize         in  - max buffer len
                    out - actual buffer len filled

Returns:
    TRUE
===================================================================*/
extern "C"
BOOL WINAPI AspStatusHtmlDump(char *szBuffer, DWORD *pdwSize)
    {
    CAspDump dump(szBuffer, *pdwSize);


    dump.Dump("<table border=1>\r\n");
    
    dump.Dump("<tr><td align=center colspan=2><b>Misc. Globals</b>\r\n");

    dump.Dump("<tr><td>fShutDownInProgress<td>%d\r\n",      g_fShutDownInProgress);
    dump.Dump("<tr><td>nApplications<td>%d\r\n",            g_nApplications);
    dump.Dump("<tr><td>nApplicationsRestarting<td>%d\r\n",  g_nApplicationsRestarting);
    dump.Dump("<tr><td>nSessions<td>%d\r\n",                g_nSessions);
    dump.Dump("<tr><td>nBrowserRequests<td>%d\r\n",         g_nBrowserRequests);
    dump.Dump("<tr><td>nSessionCleanupRequests<td>%d\r\n",  g_nSessionCleanupRequests);
    dump.Dump("<tr><td>nApplnCleanupRequests<td>%d\r\n",    g_nApplnCleanupRequests);
    dump.Dump("<tr><td>pPDM (debugger)<td>%08p\r\n",        g_pPDM);


    dump.Dump("<tr><td align=center colspan=2><b>Selected PerfMon Counters</b>\r\n");

    dump.Dump("<tr><td>Last request's execution time, ms<td>%d\r\n",        *g_PerfData.PLCounter(ID_REQEXECTIME));
    dump.Dump("<tr><td>Last request's wait time, ms<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQWAITTIME));
    dump.Dump("<tr><td>Number of executing requests<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQBROWSEREXEC));
    dump.Dump("<tr><td>Number of requests waiting in the queue<td>%d\r\n",  *g_PerfData.PLCounter(ID_REQCURRENT));
    dump.Dump("<tr><td>Number of rejected requests<td>%d\r\n",              *g_PerfData.PLCounter(ID_REQREJECTED));
    dump.Dump("<tr><td>Total number of requests<td>%d\r\n",                 *g_PerfData.PLCounter(ID_REQTOTAL));
    dump.Dump("<tr><td>Last session's duration, ms<td>%d\r\n",              *g_PerfData.PLCounter(ID_SESSIONLIFETIME));
    dump.Dump("<tr><td>Current number of sessions<td>%d\r\n",               *g_PerfData.PLCounter(ID_SESSIONCURRENT));
    dump.Dump("<tr><td>Total number of sessions<td>%d\r\n",                 *g_PerfData.PLCounter(ID_SESSIONSTOTAL));
    dump.Dump("<tr><td>Number of cached templates<td>%d\r\n",               *g_PerfData.PLCounter(ID_TEMPLCACHE));
    dump.Dump("<tr><td>Number of pending transactions<td>%d\r\n",           *g_PerfData.PLCounter(ID_TRANSPENDING));


    dump.Dump("<tr><td align=center colspan=2><b>Applications</b>\r\n");

	CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        
        dump.Dump("<tr><td colspan=2>%08p\r\n",                         pAppln);
        dump.Dump("<tr><td align=right>metabase key<td>%s\r\n",         pAppln->GetMetabaseKey());
        dump.Dump("<tr><td align=right>physical path<td>%s\r\n",        pAppln->GetApplnPath(SOURCEPATHTYPE_PHYSICAL));
        dump.Dump("<tr><td align=right>virtual path<td>%s\r\n",         pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL));
        dump.Dump("<tr><td align=right>number of sessions<td>%d\r\n",   pAppln->GetNumSessions());
        dump.Dump("<tr><td align=right>number of requests<td>%d\r\n",   pAppln->GetNumRequests());
#if 0
        dump.Dump("<tr><td align=right>global.asa path<td>%s\r\n",      pAppln->FHasGlobalAsa() ? pAppln->GetGlobalAsa() : "n/a");
#endif
        dump.Dump("<tr><td align=right>global changed?<td>%d\r\n",      pAppln->FGlobalChanged());
        dump.Dump("<tr><td align=right>tombstone?<td>%d\r\n",           pAppln->FTombstone());
        dump.Dump("<tr><td align=right>debuggable?<td>%d\r\n",          pAppln->FDebuggable());

        CSessionMgr *pSessionMgr = pAppln->PSessionMgr();

        dump.Dump("<tr><td align=right>session manager<td>%08p\r\n", pSessionMgr);

        if (pSessionMgr)
            {
            
            dump.Dump("<tr><td align=right>session killer scheduled?<td>%d\r\n", pSessionMgr->FIsSessionKillerScheduled());
            dump.Dump("<tr><td align=right>session cleanup requests<td>%d\r\n",  pSessionMgr->GetNumSessionCleanupRequests());
            
            }
        else
            {
            }
        }
    ApplnIterator.Stop();


    dump.Dump("</table>\r\n");

    *pdwSize = dump.GetSize();
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\idgener.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: IdGener.h

Owner: DmitryR

This file contains the declarations for the ID Generator class
===================================================================*/
#ifndef IDGENER_H
#define IDGENER_H

#define INVALID_ID      0xFFFFFFFF

class CIdGenerator
    {
private:
	BOOL              m_fInited;    // Initialized?
	CRITICAL_SECTION  m_csLock;		// Synchronize access
    DWORD             m_dwStartId;  // Starting (seed) Id
	DWORD			  m_dwLastId;   // Last Generated Id
		
public:	
	CIdGenerator();
	~CIdGenerator();
	
public:
	HRESULT Init();
	HRESULT Init(CIdGenerator & StartId);      
	DWORD   NewId();
	BOOL    IsValidId(DWORD dwId);
    };

#endif // IDGENER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\idgener.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: Idgener.cpp

Owner: DmitryR

This is the ID Generator source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Idgener.h"

#include "memchk.h"

/*===================================================================
CIdGenerator::CIdGenerator

NOTE: Constructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::CIdGenerator()
    : m_fInited(FALSE),
      m_dwStartId(0), 
      m_dwLastId(0)
    {
    }

/*===================================================================
CIdGenerator::~CIdGenerator()

NOTE: Destructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::~CIdGenerator()
    {
	if ( m_fInited )
		DeleteCriticalSection( &m_csLock );
    }
		
/*===================================================================
HRESULT CIdGenerator::Init()

NOTE: Seed new starting Id

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init()
    {
    Assert(!m_fInited);
    
    /*===
    
    Seed the starting id
    The starting Id should be:
        1) random
        2) not to close to recently generated starting ids
    To accomplish the above, starting Id is in the 
    following (binary) format:
    
        00TT.TTTT TTTT.TTTT TTT1.RRRR RRRR.RRRR
        
        RRR is random number to introduce some
            randomness
            
        1   is needed to make sure the id is far
            enough from 0
            
        TTT is current time() in 4 second increments.
            This means that 4 second in server restart
            delay translates into 8,192 difference in
            the starting Id (122880 sessions / minute).
            17 bits of 4 sec intervals make a roll over
            time of about 145 hours, hopefully longer
            than a client's connection lifetime (not
            that it REALLY matters).
            
        00  in the highest bits is to make sure it
            doesn't reach 0xffffffff too soon
            
    ===*/
    
    DWORD dwRRR = rand() & 0x00000FFF;
    DWORD dwTTT = (((DWORD)time(NULL)) >> 2) & 0x0001FFFF;
    
    m_dwStartId = (dwTTT << 13) | (1 << 12) | dwRRR;
    m_dwLastId  = m_dwStartId;


    HRESULT hr = S_OK;
	ErrInitCriticalSection( &m_csLock, hr );
	if ( FAILED( hr ) )
		return hr;
			
	m_fInited = TRUE;
	return S_OK;
}

/*===================================================================
HRESULT CIdGenerator::Init(CIdGenerator StartId)   

NOTE: Seed new starting Id with Id passed in

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init(CIdGenerator & StartId)
    {
    Assert(!m_fInited);
    
    m_dwStartId = StartId.m_dwStartId;
    m_dwLastId  = m_dwStartId;

    HRESULT hr = NOERROR;
    ErrInitCriticalSection( &m_csLock, hr );
    if ( FAILED( hr ) )
        return hr;
			
    m_fInited = TRUE;
    return NOERROR;
}

/*===================================================================
DWORD CIdGenerator::NewId()

NOTE: Generates new ID

Parameters:

Returns: generated ID
===================================================================*/
DWORD CIdGenerator::NewId()
    {
    Assert(m_fInited);
    
    DWORD dwId;

    EnterCriticalSection(&m_csLock);
    dwId = ++m_dwLastId;
    LeaveCriticalSection(&m_csLock);
        
    if (dwId == INVALID_ID)
        {
        // doesn't happen very often do critical section again
        // to make the above critical section shorter
        
        EnterCriticalSection(&m_csLock);
        
        // check again in case other thread changed it
        if (m_dwLastId == INVALID_ID)
            m_dwLastId = m_dwStartId;  // roll over
        m_dwLastId++;
        
        LeaveCriticalSection(&m_csLock);
        
        dwId = m_dwLastId;
        }

    return dwId;
    }

/*===================================================================
BOOL CIdGenerator::IsValidId(DWORD dwId)

NOTE: Checks if the given Id is valid (with start-last range)

Parameters:
    DWORD dwId      Id value to check

Returns: generated ID
===================================================================*/
BOOL CIdGenerator::IsValidId
(
DWORD dwId
)
    {
    Assert(m_fInited);
    return (dwId > m_dwStartId && dwId <= m_dwLastId);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\ie449.cpp ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.cpp

Owner: DmitryR

This file contains the implementation of the 449 negotiations w/IE
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "ie449.h"
#include "memchk.h"

/*===================================================================
Globals
===================================================================*/

C449FileMgr *m_p449FileMgr = NULL;

/*===================================================================
Internal funcitons
===================================================================*/
inline BOOL FindCookie
(
char *szCookiesBuf,
char *szCookie,
DWORD cbCookie
)
    {
    char *pch = szCookiesBuf;
    if (pch == NULL || *pch == '\0')
        return FALSE;

    while (1)
        {
        if (strnicmp(pch, szCookie, cbCookie) == 0)
            {
            if (pch[cbCookie] == '=')  // next char must be '='
                return TRUE;
            }

        // next cookie
        pch = strchr(pch, ';');
        if (pch == NULL)
            break;
        while (*(++pch) == ' ') // skip ; and any spaces
            ;
        }

    return FALSE;
    }


/*===================================================================
The API
===================================================================*/

/*===================================================================
Init449
===================================================================*/
HRESULT Init449()
    {
    // init hash table
    m_p449FileMgr = new C449FileMgr;
    if (m_p449FileMgr == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = m_p449FileMgr->Init();
    if (FAILED(hr))
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        return hr;
        }

    return S_OK;
    }

/*===================================================================
UnInit449
===================================================================*/
HRESULT UnInit449()
    {
    if (m_p449FileMgr != NULL)
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        }

    return S_OK;
    }

/*===================================================================
Create449Cookie

Get an existing 449 cookie from cache or create a new one

Parameters
    szName  cookie name
    szFile  script file
    pp449   [out] the cookie

Returns
    HRESULT
===================================================================*/
HRESULT Create449Cookie
(
char *szName,
TCHAR *szFile,
C449Cookie **pp449
)
    {
    HRESULT hr = S_OK;

    // Get the file first
    C449File *pFile = NULL;
    hr = m_p449FileMgr->GetFile(szFile, &pFile);
    if (FAILED(hr))
        return hr;

    // Create the cookie
    hr = C449Cookie::Create449Cookie(szName, pFile, pp449);
    if (FAILED(hr))
        pFile->Release();  // GetFile gave it addref'd

    return hr;
    }

/*===================================================================
Do449Processing

Check
    if the browser is IE5+
    there's no echo-reply: header
    all the cookies are present

Construct and send 449 response if needed

When the response is sent, HitObj is marked as 'done with session'

Parameters
    pHitObj             the request
    rgpCookies          array of cookie requirements
    cCookies            number of cookie requirements

Returns
    HRESULT
===================================================================*/
HRESULT Do449Processing
(
CHitObj *pHitObj,
C449Cookie **rgpCookies,
DWORD cCookies
)
    {
    HRESULT  hr = S_OK;

    if (cCookies == 0)
        return hr;

    //////////////////////////////////////////
    // check the browser

    BOOL fBrowser = FALSE;
    char *szBrowser = pHitObj->PIReq()->QueryPszUserAgent();
    if (szBrowser == NULL || szBrowser[0] == '\0')
        return S_OK; // bad browser

    char *szMSIE = strstr(szBrowser, "MSIE ");
    if (szMSIE)
        {
        char chVersion = szMSIE[5];
        if (chVersion >= '5' && chVersion <= '9')
            fBrowser = TRUE;
        }

#ifdef TINYGET449
    if (strcmp(szBrowser, "WBCLI") == 0)
        fBrowser = TRUE;
#endif

    if (!fBrowser)  // bad browser
        return S_OK;

    //////////////////////////////////////////
    // check the cookies

    char *szCookie = pHitObj->PIReq()->QueryPszCookie();

    // collect the arrays of pointers and sizes for not found cookies.
    // arrays size to at most number of cookies in the template.
    DWORD cNotFound = 0;
    DWORD cbNotFound = 0;
    STACK_BUFFER( tempCookies, 128 );

    if (!tempCookies.Resize(cCookies * sizeof(WSABUF))) {
        return E_OUTOFMEMORY;
    }
    LPWSABUF rgpNotFound = (LPWSABUF)tempCookies.QueryPtr();

    for (DWORD i = 0; SUCCEEDED(hr) && (i < cCookies); i++)
        {
        if (!FindCookie(szCookie, rgpCookies[i]->SzCookie(), rgpCookies[i]->CbCookie()))
            {
            // cookie not found -- append to the list

            hr = rgpCookies[i]->LoadFile();
            if (SUCCEEDED(hr)) // ignore bad files
                {
                rgpNotFound[cNotFound].buf = rgpCookies[i]->SzBuffer();
                rgpNotFound[cNotFound].len = rgpCookies[i]->CbBuffer();
                cbNotFound += rgpCookies[i]->CbBuffer();
                cNotFound++;
                }
            }
        }

    if (!SUCCEEDED(hr))
        return hr;

    if (cNotFound == 0)
        return S_OK;    // everything's found

    //////////////////////////////////////////
    // check echo-reply header

    char szEcho[80];
    DWORD dwEchoLen = sizeof(szEcho);
	if (pHitObj->PIReq()->GetServerVariableA("HTTP_MS_ECHO_REPLY", szEcho, &dwEchoLen)
	    || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	    {
		return S_OK;   // already in response cycle
		}

    //////////////////////////////////////////
    // send the 449 response

    CResponse::WriteBlocksResponse
        (
        pHitObj->PIReq(),   // WAM_EXEC_INFO
        cNotFound,          // number of blocks
        rgpNotFound,        // array of blocks
        cbNotFound,         // total number of bytes in blocks
        NULL,               // text/html
        "449 Retry with",   // status
        "ms-echo-request: execute opaque=\"0\" location=\"BODY\"\r\n"  // extra header
        );

    //////////////////////////////////////////
    // tell HitObj no to write anything else

    pHitObj->SetDoneWithSession();

    return S_OK;
    }

/*===================================================================
Do449ChangeNotification

Change notification processing

Parameters
    szFile  file changed or NULL for all

Returns
    HRESULT
===================================================================*/
HRESULT Do449ChangeNotification
(
TCHAR *szFile
)
    {
    // if m_p449FileMgr is NULL, we're likely getting called after
    // the 449 manager has been UnInited.  Return S_OK in this case.

    if (m_p449FileMgr == NULL)
        return S_OK;

    if (szFile)
        return m_p449FileMgr->Flush(szFile);
    else
        return m_p449FileMgr->FlushAll();
    }


/*===================================================================
Class C449File
===================================================================*/

/*===================================================================
C449File::C449File

Constructor
===================================================================*/
C449File::C449File()
    {
    m_cRefs = 0;
    m_fNeedLoad = 1;
    m_szFile = NULL;
    m_szBuffer = NULL;
    m_cbBuffer = 0;
    m_pDME = NULL;
    m_hFileReadyForUse=NULL;
    m_hrLoadResult= E_FAIL;
    }

/*===================================================================
C449File::~C449File

Destructor
===================================================================*/
C449File::~C449File()
    {
    Assert(m_cRefs == 0);
    if (m_szFile)
        free(m_szFile);
    if (m_szBuffer)
        free(m_szBuffer);
    if (m_pDME)
        m_pDME->Release();
     if(m_hFileReadyForUse != NULL)
        CloseHandle(m_hFileReadyForUse);
    }

/*===================================================================
C449File::Init

Init strings,
Load file for the first time,
Start change notifications
===================================================================*/
HRESULT C449File::Init
(
TCHAR *szFile
)
    {
    // remember the name
    m_szFile = StringDup(szFile);
    if (m_szFile == NULL)
        return E_OUTOFMEMORY;

    // init link element
    CLinkElem::Init(m_szFile, _tcslen(m_szFile)*sizeof(TCHAR));

    // Create event: manual-reset, ready-for-use event; non-signaled
    // Better create event before using it.
    m_hFileReadyForUse = IIS_CREATE_EVENT(
                              "C449File::m_hFileReadyForUse",
                              this,
                              TRUE,     // flag for manual-reset event
                              FALSE     // flag for initial state
                              );
    if (!m_hFileReadyForUse)
        return E_OUTOFMEMORY;

    // load
    m_fNeedLoad = 1;
    HRESULT hr = Load();
    if (FAILED(hr))
        return hr;

    // start directory notifications
    TCHAR *pch = _tcsrchr(m_szFile, _T('\\')); // last backslash
    if (pch == NULL)
        return E_FAIL; // bogus filename?
    CASPDirMonitorEntry *pDME = NULL;
    *pch = _T('\0');
    RegisterASPDirMonitorEntry(m_szFile, &pDME);
    *pch = _T('\\');
    m_pDME = pDME;

    // done
    return S_OK;
    }

/*===================================================================
C449File::Load

Load the file if needed
===================================================================*/
HRESULT C449File::Load()
    {
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BYTE *pbBytes = NULL;
    DWORD dwSize = 0;

    // check if this thread needs to load the file
    if (InterlockedExchange(&m_fNeedLoad, 0) == 0)
    {
        WaitForSingleObject(m_hFileReadyForUse, INFINITE);
        return m_hrLoadResult;
    }


    // cleanup the existing data if any
    if (m_szBuffer)
        free(m_szBuffer);
    m_szBuffer = NULL;
    m_cbBuffer = 0;

    // open the file
    if (SUCCEEDED(hr))
        {
        hFile = AspCreateFile(
            m_szFile,
            GENERIC_READ,          // access (read-write) mode
            FILE_SHARE_READ,       // share mode
            NULL,                  // pointer to security descriptor
            OPEN_EXISTING,         // how to create
            FILE_ATTRIBUTE_NORMAL, // file attributes
            NULL                   // handle to file with attributes to copy
    		);
        if (hFile == INVALID_HANDLE_VALUE)
            hr = E_FAIL;
        }

    // get file size
    if (SUCCEEDED(hr))
        {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            hr = E_FAIL;
        }

    // create mapping
    if (SUCCEEDED(hr))
        {
        hMap = CreateFileMapping(
            hFile, 		    // handle to file to map
            NULL,           // optional security attributes
            PAGE_READONLY,  // protection for mapping object
            0,              // high-order 32 bits of object size
            0,              // low-order 32 bits of object size
            NULL            // name of file-mapping object
            );
        if (hMap == NULL)
            hr = E_FAIL;
        }

    // map the file
    if (SUCCEEDED(hr))
        {
        pbBytes = (BYTE *)MapViewOfFile(
            hMap,           // file-mapping object to map into address space
            FILE_MAP_READ,  // access mode 	
            0,              // high-order 32 bits of file offset
            0,              // low-order 32 bits of file offset
            0               // number of bytes to map
			);
        if (pbBytes == NULL)
            hr = E_FAIL;
        }

    // remember the bytes
    if (SUCCEEDED(hr))
        {
        m_szBuffer = (char *)malloc(dwSize);
        if (m_szBuffer != NULL)
            {
            memcpy(m_szBuffer, pbBytes, dwSize);
            m_cbBuffer = dwSize;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    // cleanup
    if (pbBytes != NULL)
        UnmapViewOfFile(pbBytes);
    if (hMap != NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    // Set the Need Load flag or flag the read event as successful.
    m_hrLoadResult = hr;
    SetEvent(m_hFileReadyForUse);

    return m_hrLoadResult;
    }

/*===================================================================
C449File::Create449File

static constructor
===================================================================*/
HRESULT C449File::Create449File
(
TCHAR *szFile,
C449File **ppFile
)
    {
    HRESULT hr = S_OK;
    C449File *pFile = new C449File;
    if (pFile == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pFile->Init(szFile);
        }

    if (SUCCEEDED(hr))
        {
        pFile->AddRef();
        *ppFile = pFile;
        }
    else if (pFile)
        {
        delete pFile;
        }
    return hr;
    }

/*===================================================================
C449File::QueryInterface
C449File::AddRef
C449File::Release

IUnknown members for C449File object.
===================================================================*/
STDMETHODIMP C449File::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449File::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449File::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}


/*===================================================================
Class C449FileMgr
===================================================================*/

/*===================================================================
C449FileMgr::C449FileMgr

Constructor
===================================================================*/
C449FileMgr::C449FileMgr()
    {
    INITIALIZE_CRITICAL_SECTION(&m_csLock);
    }

/*===================================================================
C449FileMgr::~C449FileMgr

Destructor
===================================================================*/
C449FileMgr::~C449FileMgr()
    {
    FlushAll();
    m_ht449Files.UnInit();
    DeleteCriticalSection(&m_csLock);
    }

/*===================================================================
C449FileMgr::Init

Initialization
===================================================================*/
HRESULT C449FileMgr::Init()
    {
    return m_ht449Files.Init(199);
    }

/*===================================================================
C449FileMgr::GetFile

Find file in the hash table, or create a new one
===================================================================*/
HRESULT C449FileMgr::GetFile
(
TCHAR *szFile,
C449File **ppFile
)
    {
    C449File *pFile = NULL;
    CLinkElem *pElem;

    Lock();

    pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));

    if (pElem)
        {
        // found
        pFile = static_cast<C449File *>(pElem);
        if (!SUCCEEDED(pFile->Load()))
            pFile = NULL;
        else
            pFile->AddRef();    // 1 ref to hand out
        }
    else if (SUCCEEDED(C449File::Create449File(szFile, &pFile)))
        {
        if (m_ht449Files.AddElem(pFile))
            pFile->AddRef();    // 1 for hash table + 1 to hand out
        }

    UnLock();

    *ppFile = pFile;
    return (pFile != NULL) ? S_OK : E_FAIL;
    }

/*===================================================================
C449FileMgr::Flush

Change notification for a single file
===================================================================*/
HRESULT C449FileMgr::Flush
(
TCHAR *szFile
)
    {
    Lock();

    CLinkElem *pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
    if (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pFile->SetNeedLoad(); // next time reload
        }

    UnLock();
    return S_OK;
    }

/*===================================================================
C449FileMgr::FlushAll

Remove all files
FlushAll is always together with template flush
===================================================================*/
HRESULT C449FileMgr::FlushAll()
    {
    // Unlink from hash table first
    Lock();
    CLinkElem *pElem = m_ht449Files.Head();
    m_ht449Files.ReInit();
    UnLock();

    // Walk the list to remove all
    while (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pElem = pElem->m_pNext;
        pFile->Release();
        }

    return S_OK;
    }

/*===================================================================
Class C449Cookie
===================================================================*/

/*===================================================================
C449Cookie::C449Cookie

Constructor
===================================================================*/
C449Cookie::C449Cookie()
    {
    m_cRefs = 0;
    m_szName = NULL;
    m_cbName = 0;
    m_pFile = NULL;
    }

/*===================================================================
C449Cookie::~C449Cookie

Destructor
===================================================================*/
C449Cookie::~C449Cookie()
    {
    Assert(m_cRefs == 0);
    if (m_szName)
        free(m_szName);
    if (m_pFile)
        m_pFile->Release();
    }

/*===================================================================
C449Cookie::Init

Initialize
===================================================================*/
HRESULT C449Cookie::Init
(
char *szName,
C449File *pFile
)
    {
    m_szName = StringDupA(szName);
    if (m_szName == NULL)
        return E_OUTOFMEMORY;
    m_cbName = strlen(m_szName);

    m_pFile = pFile;
    return S_OK;
    }

/*===================================================================
C449Cookie::Create449Cookie

static constructor
===================================================================*/
HRESULT C449Cookie::Create449Cookie
(
char *szName,
C449File *pFile,
C449Cookie **pp449Cookie
)
    {
    HRESULT hr = S_OK;
    C449Cookie *pCookie = new C449Cookie;
    if (pCookie == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pCookie->Init(szName, pFile);
        }

    if (SUCCEEDED(hr))
        {
        pCookie->AddRef();
        *pp449Cookie = pCookie;
        }
    else if (pCookie)
        {
        delete pCookie;
        }

    return hr;
    }

/*===================================================================
C449Cookie::QueryInterface
C449Cookie::AddRef
C449Cookie::Release

IUnknown members for C449Cookie object.
===================================================================*/
STDMETHODIMP C449Cookie::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449Cookie::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449Cookie::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\initguid.c ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: InitGuid.cpp

Owner: AndrewS

Init all guids used by Denali in one place.
We are only allowed to #include objbase with INITGUID set once,
and after that we need to create all our GUIDs.  Otherwise, the
linker complains about redefeined symbols.  We do it here.
===================================================================*/

#define CINTERFACE
#include <objbase.h>
#include <initguid.h>
#include "_asptlb.h"
#include "_asptxn.h"
#include "activscp.h"
#include "activdbg.h"
#include "wraptlib.h"
#include "denguid.h"
#include "asptxn_i.c"

#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\idhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.cpp

Owner: DmitryR

Source file for the new hashing stuff
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idhash.h"
#include "memcls.h"

#include "memchk.h"

/*===================================================================
  C  P t r  A r r a y
===================================================================*/

HRESULT CPtrArray::Insert
(
int iPos,
void *pv
)
    {
    if (!m_rgpvPtrs) // empty?
        {
        m_rgpvPtrs = (void **)malloc(m_dwInc * sizeof(void *));
        if (!m_rgpvPtrs)
            return E_OUTOFMEMORY;
        m_dwSize = m_dwInc;
        m_cPtrs = 0;
        }
    else if (m_cPtrs == m_dwSize) // full?
        {
        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize + m_dwInc) * sizeof(void *)
            );
        if (!pNewPtrs)
            return E_OUTOFMEMORY;
        m_rgpvPtrs = pNewPtrs;
        m_dwSize += m_dwInc;
        }

    if (iPos < 0)
        iPos = 0;
    if ((DWORD)iPos >= m_cPtrs) // append?
        {
        m_rgpvPtrs[m_cPtrs++] = pv;
        return S_OK;
        }

    memmove
        (
        &m_rgpvPtrs[iPos+1],
        &m_rgpvPtrs[iPos],
        (m_cPtrs-iPos) * sizeof(void *)
        );

    m_rgpvPtrs[iPos] = pv;
    m_cPtrs++;
    return S_OK;
    }

HRESULT CPtrArray::Find
(
void *pv,
int *piPos
)
    const
    {
    Assert(piPos);

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            {
            *piPos = i;
            return S_OK;
            }
        }

     // not found
    *piPos = -1;
    return S_FALSE;
    }

HRESULT CPtrArray::Remove
(
void *pv
)
    {
    HRESULT hr = S_FALSE;

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            hr = Remove(i);
        }

    return hr;
    }

HRESULT CPtrArray::Remove
(
int iPos
)
    {
    Assert(iPos >= 0 && (DWORD)iPos < m_cPtrs);
    Assert(m_rgpvPtrs);

    // remove the element
    DWORD dwMoveSize = (m_cPtrs - iPos - 1) * sizeof(void *);
    if (dwMoveSize)
        memmove(&m_rgpvPtrs[iPos], &m_rgpvPtrs[iPos+1], dwMoveSize);
    m_cPtrs--;

    if (m_dwSize > 4*m_dwInc && m_dwSize > 8*m_cPtrs)
        {
        // collapse to 1/4 if size > 4 x increment and less < 1/8 full

        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize / 4) * sizeof(void *)
            );

        if (pNewPtrs)
            {
            m_rgpvPtrs = pNewPtrs;
            m_dwSize /= 4;
            }
        }

    return S_OK;
    }

HRESULT CPtrArray::Clear()
    {
    if (m_rgpvPtrs)
        free(m_rgpvPtrs);

    m_dwSize = 0;
    m_rgpvPtrs = NULL;
    m_cPtrs = 0;
    return S_OK;
    }

/*===================================================================
  C  I d  H a s h  U n i t
===================================================================*/

// Everything is inline for this structure. See the header file.

/*===================================================================
  C  I d  H a s h  A r r a y
===================================================================*/

/*===================================================================
For some hardcoded element counts (that relate to session hash),
ACACHE is used for allocations
This is wrapped in the two functions below.
===================================================================*/
ACACHE_FSA_EXTERN(MemBlock128)
ACACHE_FSA_EXTERN(MemBlock256)
static inline void *AcacheAllocIdHashArray(DWORD cElems)
    {
/* removed because in 64bit land it doesn't work because of padding
    void *pvMem;
    if      (cElems == 13) { pvMem = ACACHE_FSA_ALLOC(MemBlock128); }
    else if (cElems == 31) { pvMem = ACACHE_FSA_ALLOC(MemBlock256); }
   else { pvMem = malloc(2*sizeof(USHORT) + cElems*sizeof(CIdHashElem)); }
*/

    return malloc(offsetof(CIdHashArray, m_rgElems) + cElems*sizeof(CIdHashElem));
    }

static inline void AcacheFreeIdHashArray(CIdHashArray *pArray)
    {
/* removed because in 64bit land it doesn't work because of padding
    if (pArray->m_cElems == 13)      { ACACHE_FSA_FREE(MemBlock128, pArray); }
    else if (pArray->m_cElems == 31) { ACACHE_FSA_FREE(MemBlock256, pArray); }
    else                             { free(pArray); }
*/
    free(pArray);
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Allocates CIdHashArray as a memory block containing var length array.

Parameters:
    cElems          # of elements in the array

Returns:
    Newly created CIdHashArray
===================================================================*/
CIdHashArray *CIdHashArray::Alloc
(
DWORD cElems
)
    {
    CIdHashArray *pArray = (CIdHashArray *)AcacheAllocIdHashArray(cElems);
    if (!pArray)
        return NULL;

    pArray->m_cElems = (USHORT)cElems;
    pArray->m_cNotNulls = 0;
    memset(&(pArray->m_rgElems[0]), 0, cElems * sizeof(CIdHashElem));
    return pArray;
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Frees allocated CIdHashArray as a memory block.
Also frees any sub-arrays.

Parameters:
    pArray          CIdHashArray object to be freed

Returns:
===================================================================*/
void CIdHashArray::Free
(
CIdHashArray *pArray
)
    {
    if (pArray->m_cNotNulls > 0)
        {
        for (DWORD i = 0; i < pArray->m_cElems; i++)
            {
            if (pArray->m_rgElems[i].FIsArray())
                Free(pArray->m_rgElems[i].PArray());
            }
        }

    AcacheFreeIdHashArray(pArray);
    }

/*===================================================================
CIdHashArray::Find

Searches this array and any sub-arrays for an objects with the
given id.

Parameters:
    dwId            id to look for
    ppvObj          object found (if any)

Returns:
    S_OK = found, S_FALSE = not found
===================================================================*/
HRESULT CIdHashArray::Find
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        return m_rgElems[i].PArray()->Find(dwId, ppvObj);

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Add

Adds an object to this (or sub-) array by Id.
Creates new sub-arrays as needed.

Parameters:
    dwId            object id
    pvObj           object to add
    rgusSizes       array of sizes (used when creating sub-arrays)

Returns:
    HRESULT (S_OK = added)
===================================================================*/
HRESULT CIdHashArray::Add
(
DWORD_PTR dwId,
void *pvObj,
USHORT *rgusSizes
)
{
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].FIsEmpty()) {
        m_rgElems[i].SetToObject(dwId, pvObj);
        m_cNotNulls++;
        return S_OK;
    }

    // Advance array of sizes one level deeper
    if (rgusSizes[0]) // not at the end
        ++rgusSizes;

    if (m_rgElems[i].FIsObject()) {

        // this array logic can't handle adding the same ID twice.  It will
        // loop endlessly.  So, if an attempt is made to add the same
        // ID a second, return an error
        if (m_rgElems[i].DWId() == dwId) {
            return E_INVALIDARG;
        }

        // Old object already taken the slot - need to create new array
        // the size of first for three levels is predefined
        // increment by 1 thereafter
        CIdHashArray *pArray = Alloc (rgusSizes[0] ? rgusSizes[0] : m_cElems+1);
        if (!pArray)
            return E_OUTOFMEMORY;

        // Push the old object down into the array
        HRESULT hr = pArray->Add(m_rgElems[i].DWId(),
                                 m_rgElems[i].PObject(),
                                 rgusSizes);
        if (FAILED(hr))
            return hr;

        // Put array into slot
        m_rgElems[i].SetToArray(pArray);
    }

    Assert(m_rgElems[i].FIsArray());
    return m_rgElems[i].PArray()->Add(dwId, pvObj, rgusSizes);
}

/*===================================================================
CIdHashArray::Remove

Removes an object by id from this (or sub-) array.
Removes empty sub-arrays.

Parameters:
    dwId            object id
    ppvObj          object removed (out, optional)

Returns:
    HRESULT (S_OK = removed, S_FALSE = not found)
===================================================================*/
HRESULT CIdHashArray::Remove
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        m_rgElems[i].SetToEmpty();
        m_cNotNulls--;
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        {
        HRESULT hr = m_rgElems[i].PArray()->Remove(dwId, ppvObj);
        if (hr == S_OK && m_rgElems[i].PArray()->m_cNotNulls == 0)
            {
            Free(m_rgElems[i].PArray());
            m_rgElems[i].SetToEmpty();
            }
        return hr;
        }

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Iterate

Calls a supplied callback for each object in the array and sub-arrays.

Parameters:
    pfnCB               callback
    pvArg1, pvArg2      args to path to the callback

Returns:
    IteratorCallbackCode  what to do next?
===================================================================*/
IteratorCallbackCode CIdHashArray::Iterate
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    IteratorCallbackCode rc = iccContinue;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (m_rgElems[i].FIsObject())
            {
            rc = (*pfnCB)(m_rgElems[i].PObject(), pvArg1, pvArg2);

            // remove if requested
            if (rc & (iccRemoveAndContinue|iccRemoveAndStop))
                {
                m_rgElems[i].SetToEmpty();
                m_cNotNulls--;
                }
            }
        else if (m_rgElems[i].FIsArray())
            {
            rc = m_rgElems[i].PArray()->Iterate(pfnCB, pvArg1, pvArg2);

            // remove sub-array if empty
            if (m_rgElems[i].PArray()->m_cNotNulls == 0)
                {
                Free(m_rgElems[i].PArray());
                m_rgElems[i].SetToEmpty();
                }
            }
        else
            {
            continue;
            }

        // stop if requested
        if (rc & (iccStop|iccRemoveAndStop))
            {
            rc = iccStop;
            break;
            }
        }

    return rc;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashArray::DumpStats
(
FILE *f,
int   nVerbose,
DWORD iLevel,
DWORD &cElems,
DWORD &cSlots,
DWORD &cArrays,
DWORD &cDepth
)
    const
    {
    if (nVerbose > 0)
        {
        for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
        fprintf(f, "Array (level=%d addr=%p) %d slots, %d not null:\n",
            iLevel, this, m_cElems, m_cNotNulls);
        }

    cSlots += m_cElems;
    cArrays++;

    if (iLevel > cDepth)
        cDepth = iLevel;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (nVerbose > 1)
            {
            for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
            fprintf(f, "%[%08x:%p@%04d] ", m_rgElems[i].m_dw, m_rgElems[i].m_pv, i);
            }

        if (m_rgElems[i].FIsEmpty())
            {
            if (nVerbose > 1)
                fprintf(f, "NULL\n");
            }
        else if (m_rgElems[i].FIsObject())
            {
            if (nVerbose > 1)
                fprintf(f, "Object\n");
            cElems++;
            }
        else if (m_rgElems[i].FIsArray())
            {
            if (nVerbose > 1)
                fprintf(f, "Array:\n");
            m_rgElems[i].PArray()->DumpStats(f, nVerbose, iLevel+1,
                cElems, cSlots, cArrays, cDepth);
            }
        else
            {
            if (nVerbose > 1)
                fprintf(f, "BAD\n");
            }
        }
    }
#endif
/*===================================================================
  C  I d  H a s h  T a b l e
===================================================================*/

/*===================================================================
CIdHashTable::Init

Initialize id hash table. Does not allocate anything.

Parameters:
    usSize1         size of the first level array
    usSize2         size of the 2nd level arrays (optional)
    usSize3         size of the 3rd level arrays (optional)

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    Assert(!FInited());
    Assert(usSize1);

    m_rgusSizes[0] = usSize1;   // size of first level array
    m_rgusSizes[1] = usSize2 ? usSize2 : 7;
    m_rgusSizes[2] = usSize3 ? usSize3 : 11;
    m_rgusSizes[3] = 0;         // last one stays 0 to indicate
                                // the end of predefined sizes
    m_pArray = NULL;
    return S_OK;
    }

/*===================================================================
CIdHashTable::UnInit

Uninitialize id hash table. Frees all arrays.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::UnInit()
    {
    if (!FInited())
        {
        Assert(!m_pArray);
        return S_OK;
        }

    if (m_pArray)
        CIdHashArray::Free(m_pArray);

    m_pArray = NULL;
    m_rgusSizes[0] = 0;
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::AssertValid

Validates id hash table.

Parameters:

Returns:
===================================================================*/
void CIdHashTable::AssertValid() const
    {
    Assert(FInited());
    }

/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashTable::Dump
(
const char *szFile
)
    const
    {
    Assert(FInited());
    Assert(szFile);

    FILE *f = fopen(szFile, "a");
    if (!f)
        return;

    fprintf(f, "ID Hash Table Dump:\n");

    DWORD cElems = 0;
    DWORD cSlots = 0;
    DWORD cArrays = 0;
    DWORD cDepth = 0;

    if (m_pArray)
        m_pArray->DumpStats(f, 1, 1, cElems, cSlots, cArrays, cDepth);

    fprintf(f, "Total %d Objects in %d Slots, %d Arrays, %d Max Depth\n\n",
        cElems, cSlots, cArrays, cDepth);
    fclose(f);
    }
#endif

/*===================================================================
  C  H a s h  L o c k
===================================================================*/

/*===================================================================
CHashLock::Init

Initialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::Init()
    {
    Assert(!m_fInited);

    HRESULT hr;
    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return hr;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHashLock::UnInit

Uninitialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::UnInit()
    {
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\idhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.h

Owner: DmitryR

Header file for the new hashing stuff
===================================================================*/

#ifndef ASP_IDHASH_H
#define ASP_IDHASH_H

// forward declarations

class  CPtrArray;

class  CHashLock;

struct CIdHashElem;
struct CIdHashArray;
class  CIdHashTable;
class  CIdHashTableWithLock;

struct CObjectListElem;
class  CObjectList;
class  CObjectListWithLock;


// defines for the iterator callback return codes

#define IteratorCallbackCode   DWORD
#define iccContinue            0x00000001  // goto next object
#define iccStop                0x00000002  // stop iterating
#define iccRemoveAndContinue   0x00000004  // remove this, goto next
#define iccRemoveAndStop       0x00000008  // remove this and stop


// typedefs for the iterator callback
typedef IteratorCallbackCode (*PFNIDHASHCB)
                           (void *pvObj, void *pvArg1, void *pvArg2);

/*===================================================================
  C  P t r  A r r a y

Self-reallocating array of void pointers
===================================================================*/
class CPtrArray
    {
private:
    DWORD  m_dwSize;    // allocated size
    DWORD  m_dwInc;     // allocation increment
    void **m_rgpvPtrs;  // array of void pointers
    DWORD  m_cPtrs;     // pointers in the array

public:
    CPtrArray(DWORD dwInc = 8); // 8 pointers is the default increment
    ~CPtrArray();

    // # of elements
    int Count() const;

    // get pointer at position
    void *Get(int i) const;
    // same as operator []
    void *operator[](int i) const;

    // append to array
    HRESULT Append(void *pv);
    // prepend to array
    HRESULT Prepend(void *pv);
    // insert into given position
    HRESULT Insert(int iPos, void *pv);

    // find first position of a pointer
    HRESULT Find(void *pv, int *piPos) const;
    // same as operator []
    int operator[](void *pv) const;

    // remove by position
    HRESULT Remove(int iPos);
    // remove by pointer (all occurances)
    HRESULT Remove(void *pv);

    // remove all
    HRESULT Clear();
    };

// inlines

inline CPtrArray::CPtrArray(DWORD dwInc)
    : m_dwSize(0), m_dwInc(dwInc), m_rgpvPtrs(NULL), m_cPtrs(0)
    {
    Assert(m_dwInc > 0);
    }

inline CPtrArray::~CPtrArray()
    {
    Clear();
    }

inline int CPtrArray::Count() const
    {
    return m_cPtrs;
    }

inline void *CPtrArray::Get(int i) const
    {
    Assert(i >= 0 && (DWORD)i < m_cPtrs);
    Assert(m_rgpvPtrs);
    return m_rgpvPtrs[i];
    }

inline void *CPtrArray::operator[](int i) const
    {
    return Get(i);
    }

inline HRESULT CPtrArray::Append(void *pv)
    {
    return Insert(m_cPtrs, pv);
    }

inline HRESULT CPtrArray::Prepend(void *pv)
    {
    return Insert(0, pv);
    }

inline int CPtrArray::operator[](void *pv) const
    {
    int i;
    if (Find(pv, &i) == S_OK)
        return i;
    return -1; // not found
    }


/*===================================================================
  C  H a s h  L o c k

A wrapper around CRITICAL_SECTION.
===================================================================*/

class CHashLock
    {
private:
    DWORD m_fInited : 1;
    CRITICAL_SECTION m_csLock;

public:
    CHashLock();
    ~CHashLock();

    HRESULT Init();
    HRESULT UnInit();

    void Lock();
    void UnLock();
    };

// inlines

inline CHashLock::CHashLock()
    : m_fInited(FALSE)
    {
    }

inline CHashLock::~CHashLock()
    {
    UnInit();
    }

inline void CHashLock::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }

inline void CHashLock::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock );
    }


/*===================================================================
  C  I d  H a s h  U n i t

8-byte structure -- one element of hash array. Could be:
1) empty, 2) point to an object, 3) point to sub-array
===================================================================*/

struct CIdHashElem
    {
    DWORD_PTR m_dw;
    void *m_pv;

    BOOL FIsEmpty() const;
    BOOL FIsObject() const;
    BOOL FIsArray() const;

    DWORD_PTR DWId() const;
    void *PObject() const;
    CIdHashArray *PArray() const;

    void SetToEmpty();
    void SetToObject(DWORD_PTR dwId, void *pvObj);
    void SetToArray(CIdHashArray *pArray);
    };

// inlines

inline BOOL CIdHashElem::FIsEmpty() const
    {
    return (m_pv == NULL);
    }

inline BOOL CIdHashElem::FIsObject() const
    {
    return (m_dw != 0);
    }

inline BOOL CIdHashElem::FIsArray() const
    {
    return (m_pv != NULL && m_dw == 0);
    }

inline DWORD_PTR CIdHashElem::DWId() const
    {
    return m_dw;
    }

inline void *CIdHashElem::PObject() const
    {
    return m_pv;
    }

inline CIdHashArray *CIdHashElem::PArray() const
    {
    return reinterpret_cast<CIdHashArray *>(m_pv);
    }

inline void CIdHashElem::SetToEmpty()
    {
    m_dw = 0;
    m_pv = NULL;
    }

inline void CIdHashElem::SetToObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    m_dw = dwId;
    m_pv = pvObj;
    }

inline void CIdHashElem::SetToArray
(
CIdHashArray *pArray
)
    {
    m_dw = 0;
    m_pv = pArray;
    }

/*===================================================================
  C  I d  H a s h  A r r a y

Structure to consisting of DWORD (# of elems) and the array of Elems
===================================================================*/

struct CIdHashArray
    {
    USHORT m_cElems;            // total number of elements
    USHORT m_cNotNulls;         // number of not NULL elements
    CIdHashElem m_rgElems[1];   // 1 doesn't matter

    static CIdHashArray *Alloc(DWORD cElems);
    static void Free(CIdHashArray *pArray);

    HRESULT Find(DWORD_PTR dwId, void **ppvObj) const;
    HRESULT Add(DWORD_PTR dwId, void *pvObj, USHORT *rgusSizes);
    HRESULT Remove(DWORD_PTR dwId, void **ppvObj);
    IteratorCallbackCode Iterate(PFNIDHASHCB pfnCB, void *pvArg1, void *pvArg2);

#ifdef DBG
    void DumpStats(FILE *f, int nVerbose, DWORD iLevel,
        DWORD &cElems, DWORD &cSlots, DWORD &cArrays, DWORD &cDepth) const;
#else
    inline void DumpStats(FILE *, int, DWORD,
        DWORD &, DWORD &,  DWORD &, DWORD &) const {}
#endif
    };

/*===================================================================
  C  I d  H a s h  T a b l e

Remembers sizes of arrays on all levels and has a pointer to the
first level array of CIdHashElem elements.
===================================================================*/

class CIdHashTable
    {
private:
    USHORT        m_rgusSizes[4]; // Sizes of arrays on first 4 levels
    CIdHashArray *m_pArray;       // Pointer to first level array

    inline BOOL FInited() const { return (m_rgusSizes[0] != 0); }

public:
    CIdHashTable();
    CIdHashTable(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    ~CIdHashTable();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();

    HRESULT FindObject(DWORD_PTR dwId, void **ppvObj = NULL) const;
    HRESULT AddObject(DWORD_PTR dwId, void *pvObj);
    HRESULT RemoveObject(DWORD_PTR dwId, void **ppvObj = NULL);
    HRESULT RemoveAllObjects();

    HRESULT IterateObjects
        (
        PFNIDHASHCB pfnCB,
        void *pvArg1 = NULL,
        void *pvArg2 = NULL
        );

public:
#ifdef DBG
    void AssertValid() const;
    void Dump(const char *szFile) const;
#else
    inline void AssertValid() const {}
    inline void Dump(const char *) const {}
#endif
    };

// inlines

inline CIdHashTable::CIdHashTable()
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;
    }

inline CIdHashTable::CIdHashTable
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;

    Init(usSize1, usSize2, usSize3);  // use Init to initialize
    }

inline CIdHashTable::~CIdHashTable()
    {
    UnInit();
    }

inline HRESULT CIdHashTable::FindObject
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Find(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::AddObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    Assert(FInited());
    Assert(dwId);
    Assert(pvObj);

    if (!m_pArray)
        {
        m_pArray = CIdHashArray::Alloc(m_rgusSizes[0]);
        if (!m_pArray)
            return E_OUTOFMEMORY;
        }

    return m_pArray->Add(dwId, pvObj, m_rgusSizes);
    }

inline HRESULT CIdHashTable::RemoveObject
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Remove(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::RemoveAllObjects()
    {
    if (m_pArray)
        {
        CIdHashArray::Free(m_pArray);
        m_pArray = NULL;
        }
    return S_OK;
    }

inline HRESULT CIdHashTable::IterateObjects
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    Assert(FInited());
    Assert(pfnCB);

    if (!m_pArray)
        return S_OK;

    return m_pArray->Iterate(pfnCB, pvArg1, pvArg2);
    }

/*===================================================================
  C  I d  H a s h  T a b l e  W i t h  L o c k

CIdHashTable + CRITICAL_SECTION.
===================================================================*/

class CIdHashTableWithLock : public CIdHashTable, public CHashLock
    {
public:
    CIdHashTableWithLock();
    ~CIdHashTableWithLock();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();
    };

// inlines

inline CIdHashTableWithLock::CIdHashTableWithLock()
    {
    }

inline CIdHashTableWithLock::~CIdHashTableWithLock()
    {
    UnInit();
    }

inline HRESULT CIdHashTableWithLock::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    HRESULT hr = CIdHashTable::Init(usSize1, usSize2, usSize3);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();

    return hr;
    }

inline HRESULT CIdHashTableWithLock::UnInit()
    {
    CIdHashTable::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }


/*===================================================================
  C  O b j e c t  L i s t  E l e m

Double linked list element
===================================================================*/

struct CObjectListElem
    {
    CObjectListElem *m_pNext;
    CObjectListElem *m_pPrev;

    CObjectListElem();

    void Insert(CObjectListElem *pPrevElem, CObjectListElem *pNextElem);
    void Remove();

    void *PObject(DWORD dwFieldOffset);
    };

inline CObjectListElem::CObjectListElem()
    : m_pNext(NULL), m_pPrev(NULL)
    {
    }

inline void CObjectListElem::Insert
(
CObjectListElem *pPrevElem,
CObjectListElem *pNextElem
)
    {
    Assert(!pPrevElem || (pPrevElem->m_pNext == pNextElem));
    Assert(!pNextElem || (pNextElem->m_pPrev == pPrevElem));

    m_pPrev = pPrevElem;
    m_pNext = pNextElem;

    if (pPrevElem)
        pPrevElem->m_pNext = this;

    if (pNextElem)
        pNextElem->m_pPrev = this;
    }

inline void CObjectListElem::Remove()
    {
    if (m_pPrev)
        m_pPrev->m_pNext = m_pNext;

    if (m_pNext)
        m_pNext->m_pPrev = m_pPrev;

    m_pPrev = m_pNext = NULL;
    }

inline void *CObjectListElem::PObject(DWORD dwFieldOffset)
    {
    return ((BYTE *)this - dwFieldOffset);
    }

// Macro to get the byte offset of a field in a class
#define OBJECT_LIST_ELEM_FIELD_OFFSET(type, field) \
        (PtrToUlong(&(((type *)0)->field)))

inline CObjectListElem *PListElemField
(
void *pvObj,
DWORD dwFieldOffset
)
    {
    if (!pvObj)
        return NULL;
    return (CObjectListElem *)((BYTE *)pvObj + dwFieldOffset);
    }

/*===================================================================
  C  O b j e c t  L i s t

Double linked list of objects
===================================================================*/

class CObjectList
    {
private:
    CObjectListElem m_Head;   // list head
    DWORD m_dwFieldOffset;    // offset to CObjectListElem member field

public:
    CObjectList();
    ~CObjectList();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();

    HRESULT AddObject(void *pvObj);
    HRESULT RemoveObject(void *pvObj);
    HRESULT RemoveAllObjects();

    // iteration
    void *PFirstObject();
    void *PNextObject(void *pvObj);
    };

// inlines

inline CObjectList::CObjectList()
    : m_dwFieldOffset(0)
    {
    }

inline CObjectList::~CObjectList()
    {
    UnInit();
    }

inline HRESULT CObjectList::Init(DWORD dwFieldOffset)
    {
    m_dwFieldOffset = dwFieldOffset;
    m_Head.m_pPrev = m_Head.m_pNext = NULL;
    return S_OK;
    }

inline HRESULT CObjectList::UnInit()
    {
    RemoveAllObjects();
    return S_OK;
    }

inline HRESULT CObjectList::AddObject(void *pvObj)
    {
    Assert(pvObj);
    // insert between head and its next
    PListElemField(pvObj, m_dwFieldOffset)->Insert(&m_Head, m_Head.m_pNext);
    return S_OK;
    }

inline HRESULT CObjectList::RemoveObject(void *pvObj)
    {
    Assert(pvObj);
    PListElemField(pvObj, m_dwFieldOffset)->Remove();
    return S_OK;
    }

inline HRESULT CObjectList::RemoveAllObjects()
    {
    if (m_Head.m_pNext)
        m_Head.m_pNext = NULL;
    return S_OK;
    }

inline void *CObjectList::PFirstObject()
    {
    return m_Head.m_pNext ? m_Head.m_pNext->PObject(m_dwFieldOffset) : NULL;
    }

inline void *CObjectList::PNextObject(void *pvObj)
    {
    CObjectListElem *pNextElem =
        pvObj ? PListElemField(pvObj, m_dwFieldOffset)->m_pNext : NULL;
    return pNextElem ? pNextElem->PObject(m_dwFieldOffset) : NULL;
    }

/*===================================================================
  C  O b j e c t  L i s t  W i t h  L o c k

CObjectList + CRITICAL_SECTION.
===================================================================*/

class CObjectListWithLock : public CObjectList, public CHashLock
    {
public:
    CObjectListWithLock();
    ~CObjectListWithLock();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();
    };

// inlines

inline CObjectListWithLock::CObjectListWithLock()
    {
    }

inline CObjectListWithLock::~CObjectListWithLock()
    {
    UnInit();
    }

inline HRESULT CObjectListWithLock::Init(DWORD dwFieldOffset)
    {
    HRESULT hr = CObjectList::Init(dwFieldOffset);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();
    return hr;
    }

inline HRESULT CObjectListWithLock::UnInit()
    {
    CObjectList::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }

#endif // ifndef ASP_IDHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\isapireq.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo Object

File: IsapiReq.h

Owner: AndyMorr

===================================================================*/
#ifndef ISAPIREQ_H
#define ISAPIREQ_H

#include <iadmw.h>
#include <string.hxx>
#include "memcls.h"
#include "dbllink.h"

/*
    Mappings of CIsapiReqInfo methods to the proper routines based
    on the UNICODE setting
*/
#ifdef UNICODE
#define QueryPszPathInfo        QueryPszPathInfoW
#define QueryCchPathInfo        QueryCchPathInfoW
#define QueryPszPathTranslated  QueryPszPathTranslatedW
#define QueryCchPathTranslated  QueryCchPathTranslatedW
#define QueryPszApplnMDPath     QueryPszApplnMDPathW
#define QueryCchApplnMDPath     QueryCchApplnMDPathW
#define MapUrlToPath            MapUrlToPathW
#define GetCustomError          GetCustomErrorW
#define GetAspMDData            GetAspMDDataW
#define GetAspMDAllData         GetAspMDAllDataW
#define GetServerVariable       GetServerVariableW
#define GetVirtualPathToken     GetVirtualPathTokenW
#else
#define QueryPszPathInfo        QueryPszPathInfoA
#define QueryCchPathInfo        QueryCchPathInfoA
#define QueryPszPathTranslated  QueryPszPathTranslatedA
#define QueryCchPathTranslated  QueryCchPathTranslatedA
#define QueryPszApplnMDPath     QueryPszApplnMDPathA
#define QueryCchApplnMDPath     QueryCchApplnMDPathA
#define MapUrlToPath            MapUrlToPathA
#define GetCustomError          GetCustomErrorA
#define GetAspMDData            GetAspMDDataA
#define GetAspMDAllData         GetAspMDAllDataA
#define GetServerVariable       GetServerVariableA
#define GetVirtualPathToken     GetVirtualPathTokenA
#endif

// this structure helps passing the vectors of WSABUF without reallocating
// continuous memory
typedef struct
{
    LPWSABUF  pVector1;
    LPWSABUF  pVector2;
    DWORD     dwVectorLen1;
    DWORD     dwVectorLen2;
} WSABUF_VECTORS, *LPWSABUF_VECTORS;

class CIsapiReqInfo;
class CAsyncVectorSendCB;

typedef VOID (*PFN_CLIENT_IO_COMPLETION)( CIsapiReqInfo    *pReqInfo,
                                          PVOID             pContext,
                                          DWORD             cbIO,
                                          DWORD             dwError);

/*===================================================================
  C I s a p i R e q I n f o

Class which encapsulates Request info we need from the ISAPI interface.
Information either comes from the public ISAPI interfaces (SSE and
ServerVariables) or from the private WAM_EXEC_INFO.

===================================================================*/

class CIsapiReqInfo {

private:

    LONG        m_cRefs;
    EXTENSION_CONTROL_BLOCK *m_pECB;

    int         m_cchQueryString;
    int         m_cchApplnMDPathA;
    int         m_cchPathTranslatedA;
    int         m_cchPathInfoA;
    int         m_cchApplnMDPathW;
    int         m_cchPathTranslatedW;
    int         m_cchPathInfoW;
    int         m_cchAppPoolIdA;
    int         m_cchAppPoolIdW;

    DWORD       m_fApplnMDPathAInited    : 1;
    DWORD       m_fApplnMDPathWInited    : 1;
    DWORD       m_fAppPoolIdAInited      : 1;
    DWORD       m_fAppPoolIdWInited      : 1;
    DWORD       m_fPathInfoWInited       : 1;
    DWORD       m_fPathTranslatedWInited : 1;
    DWORD       m_fCookieInited          : 1;
    DWORD       m_fUserAgentInited       : 1;
    DWORD       m_fInstanceIDInited      : 1;
    DWORD       m_fVersionInited         : 1;
    DWORD       m_fFKeepConnInited       : 1;
    DWORD       m_fPendSendCSInited      : 1;
    DWORD       m_fIOCompletionRegistered: 1;
    DWORD       m_fHeadersWritten        : 1;

    DWORD       m_dwInstanceID;

    DWORD       m_dwVersionMajor;
    DWORD       m_dwVersionMinor;

    BOOL        m_fKeepConn;

    BUFFER      m_ApplnMDPathA;
    BUFFER      m_ApplnMDPathW;
    BUFFER      m_AppPoolIdA;
    BUFFER      m_AppPoolIdW;
    BUFFER      m_PathInfoW;
    BUFFER      m_PathTranslatedW;
    BUFFER      m_Cookie;
    BUFFER      m_UserAgent;

    DWORD       m_dwRequestStatus;

    DWORD       m_dwAsyncError;

    CRITICAL_SECTION    m_csPendingSendCS;
    CDblLink    m_listPendingSends;

    IMSAdminBase    *m_pIAdminBase;

public:

    CIsapiReqInfo(EXTENSION_CONTROL_BLOCK *pECB);

    ~CIsapiReqInfo();

    LONG    AddRef() {
        LONG   cRefs = InterlockedIncrement(&m_cRefs);

        return cRefs;
    }

    LONG    Release() {
        LONG    cRefs = InterlockedDecrement(&m_cRefs);
        if (cRefs == 0) {
            delete this;
        }
        return cRefs;
    }

    BOOL    FHeadersWritten() { return m_fHeadersWritten; }

    EXTENSION_CONTROL_BLOCK     *ECB() { return m_pECB; }

    LPSTR QueryPszQueryString();

    DWORD QueryCchQueryString();

    LPSTR QueryPszApplnMDPathA();

    DWORD QueryCchApplnMDPathA();

    LPWSTR QueryPszApplnMDPathW();

    DWORD QueryCchApplnMDPathW();

    LPSTR QueryPszAppPoolIdA();

    DWORD QueryCchAppPoolIdA();

    LPWSTR QueryPszAppPoolIdW();

    DWORD QueryCchAppPoolIdW();

    LPSTR QueryPszPathInfoA();

    DWORD QueryCchPathInfoA();

    LPWSTR QueryPszPathInfoW();

    DWORD QueryCchPathInfoW();

    LPSTR QueryPszPathTranslatedA();

    DWORD QueryCchPathTranslatedA();

    LPWSTR QueryPszPathTranslatedW();

    DWORD QueryCchPathTranslatedW();

    LPSTR QueryPszCookie();

    VOID  SetDwHttpStatusCode( DWORD dwStatus );

    LPBYTE QueryPbData();

    DWORD QueryCbAvailable();

    DWORD QueryCbTotalBytes();

    LPSTR QueryPszContentType();

    LPSTR QueryPszMethod();

    LPSTR QueryPszUserAgent();

    DWORD QueryInstanceId();

    BOOL  IsChild();

    BOOL FInPool();

    BOOL FKeepConn();

    DWORD QueryHttpVersionMajor();

    DWORD QueryHttpVersionMinor();

    HRESULT GetAspMDDataA(CHAR          * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDDataW(WCHAR         * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDAllDataA(CHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    HRESULT GetAspMDAllDataW(WCHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    BOOL GetCustomErrorA(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         CHAR  *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError,
                         BOOL  *pfSendErrorBody = NULL);

    BOOL GetCustomErrorW(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         WCHAR *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError,
                         BOOL  *pfSendErrorBody = NULL);

    HANDLE QueryImpersonationToken();

    HRESULT AppendLogParameter( LPSTR szExtraParam );

    BOOL SendHeader(LPVOID pvStatus,
                    DWORD  cchStatus,
                    LPVOID pvHeader,
                    DWORD  cchHeader,
                    BOOL   fIsaKeepConn);

    BOOL GetServerVariableA(LPSTR   szVarName,
                            LPSTR   pBuffer,
                            LPDWORD pdwSize );

    BOOL GetServerVariableW(LPSTR   szVarName,
                            LPWSTR  pBuffer,
                            LPDWORD pdwSize);

    HRESULT GetVirtualPathTokenA(LPCSTR  szPath,
                                 HANDLE *hToken);

    HRESULT GetVirtualPathTokenW(LPCWSTR  szPath,
                                 HANDLE *hToken);

    BOOL ServerSupportFunction(DWORD   dwHSERequest,
                               LPVOID  pvData,
                               LPDWORD pdwSize,
                               LPDWORD pdwDataType);

    BOOL SendClientResponse(PFN_CLIENT_IO_COMPLETION          pComplFunc,
                            VOID                             *pComplArg,
                            LPHSE_SEND_ENTIRE_RESPONSE_INFO   pHseResponseInfo,
                            LPWSABUF_VECTORS                  pResponseVectors = NULL);

    BOOL TestConnection(BOOL  *pfIsConnected);

    BOOL MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes);

    BOOL MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes);

    BOOL SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes );

    BOOL SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes);

    VOID SetRequestStatus(DWORD  dwRequestStatus)  { m_dwRequestStatus = dwRequestStatus; }

    DWORD GetRequestStatus()                        { return m_dwRequestStatus; }

    HRESULT AddToPendingList(CAsyncVectorSendCB  *pVectorCB);

    void IssueNextSend();

    static  WINAPI AsyncCompletion(EXTENSION_CONTROL_BLOCK * pECB,
                                   PVOID    pContext,
                                   DWORD    cbIO,
                                   DWORD    dwError);

private:

    void             InitVersionInfo();

    IMSAdminBase    *GetMetabaseIF (HRESULT *pHr);

    BOOL             InternalGetServerVariable(LPSTR  pszVar, BUFFER  *pBuffer);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};

/*===================================================================
  C A s y n c V e c t o r S e n d C B

  Class used internally by SendClientResponse to handle async calls
  with VectorSend.

===================================================================*/

class CAsyncVectorSendCB : public CDblLink
{

public:

    CAsyncVectorSendCB();

    CAsyncVectorSendCB(CIsapiReqInfo            *pIReq,
                       void                     *pContext,
                       PFN_CLIENT_IO_COMPLETION  pFunc);

    ~CAsyncVectorSendCB();

    HRESULT     SetElementCount(DWORD  nElements);

    CIsapiReqInfo              *m_pIReq;
    HSE_RESPONSE_VECTOR         m_hseResponseVector;
    void                       *m_pCallerContext;
    PFN_CLIENT_IO_COMPLETION    m_pCallerFunc;
    HSE_VECTOR_ELEMENT         *m_pVectorElements;
    HSE_VECTOR_ELEMENT          m_aVectorElements[16];

        // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\ie449.h ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.h

Owner: DmitryR

This file contains the definitons for the 449 negotiations w/IE
===================================================================*/

#ifndef IE449_H
#define IE449_H

#include "hashing.h"
#include "aspdmon.h"
#include "memcls.h"

// forward declr
class CHitObj;
class C449Cookie;
class C449File;

/*===================================================================
The API
===================================================================*/

// init/uninit on dll level
HRESULT Init449();
HRESULT UnInit449();

// create a new cookie
HRESULT Create449Cookie(char *szName, TCHAR *szFile, C449Cookie **pp449);

// do the work
HRESULT Do449Processing
    (
    CHitObj *pHitObj, 
    C449Cookie **rgpCookies, 
    DWORD cCookies
    );

// change notification processing
HRESULT Do449ChangeNotification(TCHAR *szFile = NULL);

/*===================================================================
C449File class definition
    files are hashed
===================================================================*/
class C449File : public IUnknown, public CLinkElem
    {
private:
    LONG  m_cRefs;              // ref count
    LONG  m_fNeedLoad;          // flag when need to reload (Interlocked)
    TCHAR *m_szFile;             // file name with script
    char *m_szBuffer;           // file contents
    DWORD m_cbBuffer;           // file contents length
    CDirMonitorEntry *m_pDME;   // for change notification support
    HANDLE m_hFileReadyForUse;	 // is the File ready for use by other threads
    HRESULT    m_hrLoadResult;  // record result of load here?

    C449File();       // should be done using Create449Cookie()
    ~C449File();      // should be done using Release()

    HRESULT Init(TCHAR *szFile);

public:
    // public constructor
    static HRESULT Create449File(TCHAR *szFile, C449File **ppFile);

    HRESULT Load();

    inline char *SzBuffer() { return m_szBuffer; }
    inline DWORD CbBuffer() { return m_cbBuffer; }

    inline void SetNeedLoad() 
    {
       	ResetEvent (m_hFileReadyForUse);
    	m_hrLoadResult = E_FAIL;
    	InterlockedExchange(&m_fNeedLoad, 1); 
    }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
C449FileMgr class definition
    file manager keeps the hash table of files
===================================================================*/
class C449FileMgr
    {
private:
    CRITICAL_SECTION m_csLock;
    CHashTableMBStr  m_ht449Files;

    inline void Lock()    { EnterCriticalSection(&m_csLock); }
    inline void UnLock()  { LeaveCriticalSection(&m_csLock); }

public:
    C449FileMgr();
    ~C449FileMgr();
    
    HRESULT Init();

    // find or create a new one
    HRESULT GetFile(TCHAR *szFile, C449File **ppFile);

    // change notification
    HRESULT Flush(TCHAR *szFile);
    HRESULT FlushAll();
    };

/*===================================================================
C449Cookie class definition
    cookie is a cookie -- file pair
===================================================================*/
class C449Cookie : public IUnknown
    {
private:
    LONG      m_cRefs;      // ref count
    char     *m_szName;     // cookie name to check
    DWORD     m_cbName;     // cookie name length
    C449File *m_pFile;      // related file

    C449Cookie();       // should be done using Create449Cookie()
    ~C449Cookie();      // should be done using Release()

    HRESULT Init(char *szName, C449File *pFile);

public:
    // public constructor
    static HRESULT Create449Cookie(char *szName, C449File *pFile, C449Cookie **pp449);

    inline char *SzCookie() { return m_szName; }
    inline DWORD CbCookie() { return m_cbName; }

    inline HRESULT LoadFile() { return m_pFile ? m_pFile->Load() : E_FAIL; }
    inline char   *SzBuffer() { return m_pFile ? m_pFile->SzBuffer() : NULL; }
    inline DWORD   CbBuffer() { return m_pFile ? m_pFile->CbBuffer() : 0; }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

#endif // IE449_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\linkhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: LinkHash.cpp

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "LinkHash.h"
#include "memchk.h"



/*------------------------------------------------------------------
 * C L i n k H a s h
 */

/*===================================================================
CLinkHash::CLinkHash

Constructor for CLinkHash

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkHash::CLinkHash( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
CLinkHash::AddElem

Parameters:
    pElem - item to add to the table.  The item is marked as the most
            recently accessed.

Returns:
    Returns a pointer to the item added
===================================================================*/

CLruLinkElem *CLinkHash::AddElem(CLruLinkElem *pElem, BOOL fTestDups)
    {
    AssertValid();

    CLruLinkElem *pElemAdded = static_cast<CLruLinkElem *>(CHashTable::AddElem(pElem, fTestDups));
    pElemAdded->PrependTo(m_lruHead);

    AssertValid();
    return pElemAdded;
    }



/*===================================================================
CLinkHash::FindElem

Parameters:
    pvKey - pointer to the key to insert
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    moved to the front of the list.
===================================================================*/

CLruLinkElem *CLinkHash::FindElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::FindElem(pvKey, cbKey));
    if (pElemFound)
        {
        pElemFound->PrependTo(m_lruHead);
        AssertValid();
        }

    return pElemFound;
    }



/*===================================================================
CLinkHash::DeleteElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::DeleteElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::DeleteElem(pvKey, cbKey));
    if (pElemFound)
        pElemFound->UnLink();

    AssertValid();
    return pElemFound;
    }



/*===================================================================
CLinkHash::RemoveElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::RemoveElem(CLruLinkElem *pElem)
    {
    AssertValid();

    CLruLinkElem *pElemRemoved = static_cast<CLruLinkElem *>(CHashTable::RemoveElem(pElem));

    Assert (pElemRemoved);
    pElemRemoved->UnLink();

    AssertValid();
    return pElemRemoved;
    }



/*===================================================================
CLinkHash::AssertValid

verify the integrity of the data structure
===================================================================*/

#ifdef DBG
void CLinkHash::AssertValid() const
    {
    // NOTE: avoid calling CHashTable::AssertValid as long as hash table primitives are calling it.
    //  CHashTable::AssertValid();

    m_lruHead.AssertValid();
    for (CDblLink *pLink = m_lruHead.PNext(); pLink != &m_lruHead; pLink = pLink->PNext())
        pLink->AssertValid();
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\linkhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: LinkHash.h

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#ifndef LINKHASH_H
#define LINKHASH_H

#include "hashing.h"
#include "DblLink.h"



/* C L r u L i n k E l e m
 *
 * CLruLink is a CLinkElem with extra links to maintain a circular LRU queue
 *
 * NOTE: Both the CLinkElem list and the CDblLink lists are intrusive.
 *       therefore, we need to use multiple inheritance to make sure that
 *       downcasts from CLruLinkElem will work on both CLinkElem pointers
 *       and CDblLink pointers.  See the ARM, p. 221
 */

class CLruLinkElem : public CLinkElem, public CDblLink
	{
	};



/*
 * C L i n k H a s h
 *
 * CLinkHash differs from CHashTable in that it maintains some extra pointers to
 * maintain a threaded lru queue.
 */

class CLinkHash : public CHashTable
	{
public:
	CLinkHash(HashFunction = DefaultHash);
	
	CLruLinkElem *AddElem(CLruLinkElem *pElem, BOOL fTestDups = TRUE);
	CLruLinkElem *FindElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *DeleteElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *RemoveElem(CLruLinkElem *pElem);

	// you CANNOT compare LRU nodes to NULL to know if you are at the end
	// of the list!  Instead use this member.
	//
	BOOL FLruElemIsEmpty(CLruLinkElem *pElem)
		{
		pElem->AssertValid();
		return pElem == &m_lruHead;
		}

	CLruLinkElem *Begin()		// return pointer to last referenced item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PNext());
		}

	CLruLinkElem *End()			// return pointer to least recently accessed item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PPrev());
		}

	void AssertValid() const;

protected:

	CDblLink	m_lruHead;
	};

#ifndef DBG
	inline void CLinkHash::AssertValid() const {}
#endif
	
#endif // LINKHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\isapireq.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo implementation....

File: IsapiReq.cpp

Owner: AndyMorr

===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"

// undef these here so that we can call the WXI and ECB functions with
// the same name and not be victims of the substituition.

#undef MapUrlToPath
#undef GetCustomError
#undef GetAspMDData
#undef GetAspMDAllData
#undef GetServerVariable

LONG g_nOutstandingAsyncWrites = 0;

/*===================================================================
CIsapiReqInfo::CIsapiReqInfo
===================================================================*/
CIsapiReqInfo::CIsapiReqInfo(EXTENSION_CONTROL_BLOCK *pECB) {

    m_cRefs = 1;

    m_fApplnMDPathAInited = 0;
    m_fApplnMDPathWInited = 0;
    m_fAppPoolIdAInited = 0;
    m_fAppPoolIdWInited = 0;
    m_fPathInfoWInited    = 0;
    m_fPathTranslatedWInited    = 0;
    m_fCookieInited       = 0;
    m_fUserAgentInited    = 0;
    m_fInstanceIDInited   = 0;
    m_fVersionInited      = 0;
    m_fFKeepConnInited    = 0;
    m_fPendSendCSInited   = 0;
    m_fIOCompletionRegistered = 0;
    m_fHeadersWritten     = 0;

    m_dwInstanceID        = 0;

    m_dwVersionMajor      = 1;
    m_dwVersionMinor      = 0;

    m_cchQueryString      = -1;
    m_cchApplnMDPathA     = -1;
    m_cchPathTranslatedA  = -1;
    m_cchPathInfoA        = -1;
    m_cchApplnMDPathW     = -1;
    m_cchPathTranslatedW  = -1;
    m_cchPathInfoW        = -1;
    m_cchAppPoolIdW       = -1;
    m_cchAppPoolIdA       = -1;

    m_fKeepConn           = FALSE;

    m_pIAdminBase         = NULL;

    m_pECB                = pECB;

    m_dwRequestStatus     = HSE_STATUS_SUCCESS;

    m_dwAsyncError        = NOERROR;

}

/*===================================================================
CIsapiReqInfo::~CIsapiReqInfo
===================================================================*/
CIsapiReqInfo::~CIsapiReqInfo() {

    Assert(m_listPendingSends.FIsEmpty());

    if (m_pIAdminBase != NULL) {
        m_pIAdminBase->Release();
        m_pIAdminBase = NULL;
    }

    if (m_fPendSendCSInited)
        DeleteCriticalSection(&m_csPendingSendCS);

    if (m_pECB) {

        DWORD  dwRequestStatus = HSE_STATUS_SUCCESS;

        if ((m_pECB->dwHttpStatusCode >= 500) && (m_pECB->dwHttpStatusCode < 600))
            dwRequestStatus = HSE_STATUS_ERROR;

        else if (m_dwRequestStatus == HSE_STATUS_PENDING)
            dwRequestStatus = m_dwAsyncError ? HSE_STATUS_ERROR : HSE_STATUS_SUCCESS;

        ServerSupportFunction(HSE_REQ_DONE_WITH_SESSION,
                              &dwRequestStatus,
                              NULL,
                              NULL);
    }
}

/*===================================================================
CIsapiReqInfo::QueryPszQueryString
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszQueryString()
{
    return m_pECB->lpszQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryCchQueryString
===================================================================*/
DWORD CIsapiReqInfo::QueryCchQueryString()
{
    if (m_cchQueryString == -1) {
        m_cchQueryString = QueryPszQueryString() ? strlen(QueryPszQueryString()) : 0;
    }

    return m_cchQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszApplnMDPathA()
{
    if (m_fApplnMDPathAInited == FALSE) {
        *((LPSTR)m_ApplnMDPathA.QueryPtr()) = '\0';
        m_fApplnMDPathAInited = InternalGetServerVariable("APPL_MD_PATH", &m_ApplnMDPathA);
    }

    ASSERT(m_fApplnMDPathAInited);

    return (LPSTR)m_ApplnMDPathA.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathA()
{
    if (m_cchApplnMDPathA == -1) {
        m_cchApplnMDPathA = QueryPszApplnMDPathA()
                                ? strlen(QueryPszApplnMDPathA())
                                : 0;
    }

    return(m_cchApplnMDPathA);
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszApplnMDPathW()
{
    if (m_fApplnMDPathWInited == FALSE) {
        *((LPWSTR)m_ApplnMDPathW.QueryPtr()) = L'\0';
        m_fApplnMDPathWInited = InternalGetServerVariable("UNICODE_APPL_MD_PATH", &m_ApplnMDPathW);
    }

    ASSERT(m_fApplnMDPathWInited);

    return (LPWSTR)m_ApplnMDPathW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathW()
{
    if (m_cchApplnMDPathW == -1) {
        m_cchApplnMDPathW = QueryPszApplnMDPathW()
                                ? wcslen(QueryPszApplnMDPathW())
                                : 0;
    }

    return(m_cchApplnMDPathW);
}

/*===================================================================
CIsapiReqInfo::QueryPszAppPoolIdA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszAppPoolIdA()
{
    if (m_fAppPoolIdAInited == FALSE) {
        *((LPSTR)m_AppPoolIdA.QueryPtr()) = '\0';
        m_fAppPoolIdAInited = InternalGetServerVariable("APP_POOL_ID", &m_AppPoolIdA);
    }

    ASSERT(m_fAppPoolIdAInited);

    return (LPSTR)m_AppPoolIdA.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchAppPoolIdA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchAppPoolIdA()
{
    if (m_cchAppPoolIdA == -1) {
        m_cchAppPoolIdA = QueryPszAppPoolIdA()
                                ? strlen(QueryPszAppPoolIdA())
                                : 0;
    }

    return(m_cchAppPoolIdA);
}

/*===================================================================
CIsapiReqInfo::QueryPszAppPoolIdW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszAppPoolIdW()
{
    if (m_fAppPoolIdWInited == FALSE) {
        *((LPWSTR)m_AppPoolIdW.QueryPtr()) = L'\0';
        m_fAppPoolIdWInited = InternalGetServerVariable("UNICODE_APP_POOL_ID", &m_AppPoolIdW);
    }

    ASSERT(m_fAppPoolIdWInited);

    return (LPWSTR)m_AppPoolIdW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchAppPoolIdW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchAppPoolIdW()
{
    if (m_cchAppPoolIdW == -1) {
        m_cchAppPoolIdW = QueryPszAppPoolIdW()
                                ? wcslen(QueryPszAppPoolIdW())
                                : 0;
    }

    return(m_cchAppPoolIdW);
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathInfoA()
{
    return m_pECB->lpszPathInfo;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoA()
{
    if (m_cchPathInfoA == -1) {
        m_cchPathInfoA = QueryPszPathInfoA()
                            ? strlen(QueryPszPathInfoA())
                            : 0;
    }
    return m_cchPathInfoA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathInfoW()
{
    if (m_fPathInfoWInited == FALSE) {
        *((LPWSTR)m_PathInfoW.QueryPtr()) = L'\0';
        m_fPathInfoWInited = InternalGetServerVariable("UNICODE_PATH_INFO", &m_PathInfoW);
    }

    ASSERT(m_fPathInfoWInited);

    return (LPWSTR)m_PathInfoW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoW()
{
    if (m_cchPathInfoW == -1) {
        m_cchPathInfoW = QueryPszPathInfoW()
                            ? wcslen(QueryPszPathInfoW())
                            : 0;
    }
    return m_cchPathInfoW;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathTranslatedA()
{
    return m_pECB->lpszPathTranslated;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedA()
{
    if (m_cchPathTranslatedA == -1) {
        m_cchPathTranslatedA = QueryPszPathTranslatedA()
                                ? strlen(QueryPszPathTranslatedA())
                                : 0;
    }

    return m_cchPathTranslatedA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathTranslatedW()
{
    if (m_fPathTranslatedWInited == FALSE) {
        *((LPWSTR)m_PathTranslatedW.QueryPtr()) = L'\0';
        m_fPathTranslatedWInited = InternalGetServerVariable("UNICODE_PATH_TRANSLATED", &m_PathTranslatedW);
    }

    return (LPWSTR)m_PathTranslatedW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedW()
{
    if (m_cchPathTranslatedW == -1) {
        m_cchPathTranslatedW = QueryPszPathTranslatedW()
                                ? wcslen(QueryPszPathTranslatedW())
                                : 0;
    }

    return m_cchPathTranslatedW;
}

/*===================================================================
CIsapiReqInfo::QueryPszCookie
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszCookie()
{
    if (m_fCookieInited == FALSE) {
        *((LPSTR)m_Cookie.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_COOKIE", &m_Cookie);
        m_fCookieInited = TRUE;
    }

    return (LPSTR)m_Cookie.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::SetDwHttpStatusCode
===================================================================*/
VOID CIsapiReqInfo::SetDwHttpStatusCode(DWORD  dwStatus)
{
    m_pECB->dwHttpStatusCode = dwStatus;
}

/*===================================================================
CIsapiReqInfo::QueryPbData
===================================================================*/
LPBYTE CIsapiReqInfo::QueryPbData()
{
    return m_pECB->lpbData;
}

/*===================================================================
CIsapiReqInfo::QueryCbAvailable
===================================================================*/
DWORD CIsapiReqInfo::QueryCbAvailable()
{
    return m_pECB->cbAvailable;
}

/*===================================================================
CIsapiReqInfo::QueryCbTotalBytes
===================================================================*/
DWORD CIsapiReqInfo::QueryCbTotalBytes()
{
    return m_pECB->cbTotalBytes;
}

/*===================================================================
CIsapiReqInfo::QueryPszContentType
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszContentType()
{
    return m_pECB->lpszContentType;
}

/*===================================================================
CIsapiReqInfo::QueryPszMethod
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszMethod()
{
    return m_pECB->lpszMethod;
}

/*===================================================================
CIsapiReqInfo::QueryPszUserAgent
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszUserAgent()
{
    if (m_fUserAgentInited == FALSE) {
        *((LPSTR)m_UserAgent.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_USER_AGENT", &m_UserAgent);
    }

    return (LPSTR)m_UserAgent.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryInstanceId
===================================================================*/
DWORD CIsapiReqInfo::QueryInstanceId()
{
    if (m_fInstanceIDInited == FALSE) {
        BUFFER  instanceID;
        m_fInstanceIDInited = InternalGetServerVariable("INSTANCE_ID", &instanceID);
        if (m_fInstanceIDInited == TRUE) {
            m_dwInstanceID = atoi((char *)instanceID.QueryPtr());
        }
        else {
            m_dwInstanceID = 1;
        }
    }

    return m_dwInstanceID;
}

/*===================================================================
CIsapiReqInfo::IsChild
===================================================================*/
BOOL CIsapiReqInfo::IsChild()
{

    // BUGBUG: This needs to be implemented

    return FALSE;
}

/*===================================================================
CIsapiReqInfo::FInPool
===================================================================*/
BOOL CIsapiReqInfo::FInPool()
{
    DWORD   dwAppFlag;

    if (ServerSupportFunction(HSE_REQ_IS_IN_PROCESS,
                              &dwAppFlag,
                              NULL,
                              NULL) == FALSE) {

        // BUGBUG:  Need to enable this Assert in future builds.
        //Assert(0);

        // if error, the best we can do is return TRUE here so
        // that ASP picks up its settings from the service level
        return TRUE;
    }
    return !(dwAppFlag == HSE_APP_FLAG_ISOLATED_OOP);
}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMajor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMajor()
{
    InitVersionInfo();

    return m_dwVersionMajor;
}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMinor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMinor()
{
    InitVersionInfo();

    return m_dwVersionMinor;
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataA(CHAR          * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
    return E_NOTIMPL;
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataW(WCHAR         * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    METADATA_RECORD     MetadataRecord;
    DWORD               dwTimeout = 30000;
    HRESULT             hr = S_OK;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    pMetabase = GetMetabaseIF(&hr);

    ASSERT(pMetabase);

    if (pMetabase)
    {
        hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey
                             );

        ASSERT(SUCCEEDED(hr));

        if( SUCCEEDED(hr) )
        {
            MetadataRecord.dwMDIdentifier = dwMDIdentifier;
            MetadataRecord.dwMDAttributes = dwMDAttributes;
            MetadataRecord.dwMDUserType = dwMDUserType;
            MetadataRecord.dwMDDataType = dwMDDataType;
            MetadataRecord.dwMDDataLen = dwMDDataLen;
            MetadataRecord.pbMDData = pbMDData;
            MetadataRecord.dwMDDataTag = dwMDDataTag;

            hr = pMetabase->GetData( hKey,
                                 L"",
                                 &MetadataRecord,
                                 pdwRequiredBufferSize);

            ASSERT(SUCCEEDED(hr));

            pMetabase->CloseKey( hKey );
        }
    }
    else // pMetabase == NULL,  but there was No HRESULT set then we will explicitly set it.
    {
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataA(LPSTR   pszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{
    return E_NOTIMPL;
}

/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataW(LPWSTR  pwszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{

    HRESULT             hr = S_OK;
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    DWORD               dwTimeout = 30000;
    DWORD               dwDataSet;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    //
    // Wide-ize the metabase path
    //

    pMetabase = GetMetabaseIF(&hr);

    ASSERT(pMetabase);

    if (pMetabase)
    {
        hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pwszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey);

        if( SUCCEEDED(hr) )
        {
            hr = pMetabase->GetAllData( hKey,
                                    L"",
                                    METADATA_INHERIT,
                                    dwMDUserType,
                                    ALL_METADATA,
                                    pdwNumDataEntries,
                                    &dwDataSet,
                                    dwDefaultBufferSize,
                                    (UCHAR *)pvBuffer,
                                    pdwRequiredBufferSize);

            ASSERT(SUCCEEDED(hr));

            pMetabase->CloseKey( hKey );
        }
    }
    else // pMetabase == NULL,  but there was No HRESULT set then we will explicitly set it.
    {
        if (SUCCEEDED(hr))
            hr = E_FAIL;
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorA
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorA(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    CHAR  *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError,
                                    BOOL  *pfSendErrorBody)
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorW
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorW(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    WCHAR *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError,
                                    BOOL  *pfSendErrorBody)
{
    BOOL                        fRet;
    HSE_CUSTOM_ERROR_PAGE_INFO  cei;

    STACK_BUFFER(ansiBuf, 1024);

    cei.dwError = dwError;
    cei.dwSubError = dwSubError;
    cei.dwBufferSize = ansiBuf.QuerySize();
    cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();
    cei.pdwBufferRequired = pdwRequiredBufferSize;
    cei.pfIsFileError = pfIsFileError;
    cei.pfSendErrorBody = pfSendErrorBody;

    fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                 &cei,
                                 NULL,
                                 NULL);

    if (!fRet) {
        DWORD   dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            if (ansiBuf.Resize(*pdwRequiredBufferSize) == FALSE) {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            cei.dwBufferSize = ansiBuf.QuerySize();
            cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();

            fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                         &cei,
                                         NULL,
                                         NULL);
        }

        if (!fRet) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    CMBCSToWChar convError;

    if (FAILED(convError.Init((LPCSTR)ansiBuf.QueryPtr()))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    *pdwRequiredBufferSize = (convError.GetStringLen()+1)*sizeof(WCHAR);

    if (*pdwRequiredBufferSize > dwBufferSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    memcpy(pvBuffer, convError.GetString(), *pdwRequiredBufferSize);

    if (*pfIsFileError) {

        CMBCSToWChar    convMime;
        DWORD           fileNameLen = *pdwRequiredBufferSize;

        if (FAILED(convMime.Init((LPCSTR)ansiBuf.QueryPtr()+strlen((LPCSTR)ansiBuf.QueryPtr())+1))) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        *pdwRequiredBufferSize += (convMime.GetStringLen()+1)*sizeof(WCHAR);

        if (*pdwRequiredBufferSize > dwBufferSize) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        memcpy(&((BYTE *)pvBuffer)[fileNameLen], convMime.GetString(), (convMime.GetStringLen()+1)*sizeof(WCHAR));
    }

    return TRUE;
}

/*===================================================================
CIsapiReqInfo::QueryImpersonationToken
===================================================================*/
HANDLE CIsapiReqInfo::QueryImpersonationToken()
{
    HANDLE  hToken = INVALID_HANDLE_VALUE;

    ServerSupportFunction(HSE_REQ_GET_IMPERSONATION_TOKEN,
                          &hToken,
                          NULL,
                          NULL);

    return hToken;

}

/*===================================================================
CIsapiReqInfo::AppendLogParameter
===================================================================*/
HRESULT CIsapiReqInfo::AppendLogParameter(LPSTR extraParam)
{
    if (ServerSupportFunction(HSE_APPEND_LOG_PARAMETER,
                              extraParam,
                              NULL,
                              NULL) == FALSE) {

        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

/*===================================================================
CIsapiReqInfo::SendHeader
===================================================================*/
BOOL CIsapiReqInfo::SendHeader(LPVOID pvStatus,
                               DWORD  cchStatus,
                               LPVOID pvHeader,
                               DWORD  cchHeader,
                               BOOL   fIsaKeepConn)
{
    HSE_SEND_HEADER_EX_INFO     HeaderInfo;

    HeaderInfo.pszStatus = (LPCSTR)pvStatus;
    HeaderInfo.cchStatus = cchStatus;
    HeaderInfo.pszHeader = (LPCSTR) pvHeader;
    HeaderInfo.cchHeader = cchHeader;
    HeaderInfo.fKeepConn = fIsaKeepConn;

    m_fHeadersWritten = TRUE;

    return ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                  &HeaderInfo,
                                  NULL,
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::GetServerVariableA
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableA(LPSTR   szVarName,
                                       LPSTR   pBuffer,
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::GetServerVariableW
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableW(LPSTR   szVarName,
                                       LPWSTR  pBuffer,
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::GetVirtualPathTokenA
===================================================================*/
HRESULT CIsapiReqInfo::GetVirtualPathTokenA(LPCSTR    szPath,
                                            HANDLE    *hToken)
{
    HRESULT     hr = S_OK;

    if (!ServerSupportFunction(HSE_REQ_GET_VIRTUAL_PATH_TOKEN,
                               (LPVOID)szPath,
                               (DWORD *)hToken,
                               NULL)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetVirtualPathTokenW
===================================================================*/
HRESULT CIsapiReqInfo::GetVirtualPathTokenW(LPCWSTR   szPath,
                                            HANDLE    *hToken)
{
    HRESULT     hr = S_OK;

    if (!ServerSupportFunction(HSE_REQ_GET_UNICODE_VIRTUAL_PATH_TOKEN,
                               (LPVOID)szPath,
                               (DWORD *)hToken,
                               NULL)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}

/*===================================================================
CIsapiReqInfo::ServerSupportFunction
===================================================================*/
BOOL CIsapiReqInfo::ServerSupportFunction(DWORD   dwHSERequest,
                                          LPVOID  pvData,
                                          LPDWORD pdwSize,
                                          LPDWORD pdwDataType)
{
    return m_pECB->ServerSupportFunction( (HCONN)m_pECB->ConnID,
                                           dwHSERequest,
                                           pvData,
                                           pdwSize,
                                           pdwDataType );
}

/*===================================================================
CIsapiReqInfo::SendClinetResponse
this routine is used to send all of ASP data to the client. the data
may consist of any combination of the following:
- header information as contained in pResponseInfo->HeaderInfo
- contents of a file if pResponseInfo->cWsaBuf == 0xFFFFFFFF
- non-buffered data if pResponseInfo->cWsaBuf > 0
- buffered data if pResponseVectors != NULL

Note, we are changing the semantics of the HSE_SEND_ENTIRE_RESPONSE_INFO
structure as follows:
- if pResponseInfo->cWsaBuf == 0xFFFFFFFF, then pResponseInfo->rgWsaBuf
  is a pointer to a single WSABUF, containing a file handle rather than
  memory buffer pointer
- we are not reserving entry 0 of the pResponseInfo->rgWsaBuf array, so
  entries 0 - (N-1) contain relevant data

Note, the HeaderInfo strings pszStatus and pszContent are set to NULL
after their placed in the AsyncCB SEND_VECTOR structure to indicate
that we've taken ownership of the memory.  Note that it is also
assumed that the memory was allocated using malloc().
===================================================================*/
BOOL CIsapiReqInfo::SendClientResponse(PFN_CLIENT_IO_COMPLETION          pComplFunc,
                                       VOID                             *pComplArg,
                                       LPHSE_SEND_ENTIRE_RESPONSE_INFO   pResponseInfo,
                                       LPWSABUF_VECTORS                  pResponseVectors)
{
    HRESULT             hr = S_OK;
    DWORD               nElementCount = 0;
    DWORD               dwTotalBytes = 0;
    HSE_VECTOR_ELEMENT  *pVectorElement = NULL;
    HSE_RESPONSE_VECTOR *pRespVector;
    BOOL                fKeepConn;
    CAsyncVectorSendCB  syncVectorSendCB;  // use the async class to manage the resp vector
    CAsyncVectorSendCB  *pVectorSendCB = &syncVectorSendCB;

    // if an error has been recorded during an Async completion, bail out
    // early

    if (m_dwAsyncError) {
        SetLastError(m_dwAsyncError);
        return FALSE;
    }

    // if a completion function was provided, allocate a CAsyncVectorSendCB
    // instead of the stack version

    if (pComplFunc) {

        pVectorSendCB = new CAsyncVectorSendCB(this, pComplArg, pComplFunc);

        if (pVectorSendCB == NULL) {

            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    pRespVector = &pVectorSendCB->m_hseResponseVector;

    Assert( pResponseInfo );
    Assert( (pResponseInfo->cWsaBuf == 0xFFFFFFFF) ||
            (pResponseInfo->cWsaBuf < 0x3FFF) );  // arbitrary logical limit
    Assert( (pResponseInfo->cWsaBuf == 0) || (pResponseInfo->rgWsaBuf != NULL));

    //
    // Set the keep connection flag.  It can only be TRUE if the
    // ISAPI and the client both want keep alive.
    //

    fKeepConn = FKeepConn() && pResponseInfo->HeaderInfo.fKeepConn;

    //
    // Munge the input structure into something that IIsapiCore can
    // understand. Note that ASP sets the number of buffer to be one more
    // than actual and the first buffer is not valid
    //

    if (pResponseInfo->cWsaBuf == 0xFFFFFFFF)
    {
        // indicates a file handle in a single WSABUF
        nElementCount ++;
    }
    else
    {
        nElementCount += pResponseInfo->cWsaBuf;
    }

    // Add the optional raw response vectors
    if (pResponseVectors)
    {
        Assert(pResponseVectors->dwVectorLen1 <= RESPONSE_VECTOR_INTRINSIC_SIZE);
        Assert(pResponseVectors->dwVectorLen2 < 0x3FFF);

        nElementCount += pResponseVectors->dwVectorLen1 + pResponseVectors->dwVectorLen2;
    }

    if (nElementCount == 0) {
        // no body to send. pVectorElement already set to NULL
        goto FillHeaderAndSend;
    }

    Assert( nElementCount < 0x3FFF); // arbitrary logical limit

    // let the VectorSendCB know how many elements are needed.

    if (FAILED(hr = pVectorSendCB->SetElementCount(nElementCount)))
    {
        goto Exit;
    }

    pVectorElement = pVectorSendCB->m_pVectorElements;

#define FILL_HSE_VECTOR_LOOP(cElements, WsaBuf)                                    \
                                                                                   \
    for (DWORD i = 0; i < cElements; i++)                                          \
    {                                                                              \
        if (WsaBuf[i].len == 0)                                                    \
        {                                                                          \
            Assert( nElementCount > 0);                                            \
            nElementCount--;                                                       \
            continue;                                                              \
        }                                                                          \
                                                                                   \
        Assert( !IsBadReadPtr( WsaBuf[i].buf, WsaBuf[i].len));                     \
                                                                                   \
        pVectorElement->ElementType = HSE_VECTOR_ELEMENT_TYPE_MEMORY_BUFFER;       \
        pVectorElement->pvContext = WsaBuf[i].buf;                                 \
        pVectorElement->cbSize = WsaBuf[i].len;                                    \
        dwTotalBytes += WsaBuf[i].len;                                             \
        pVectorElement++;                                                          \
    }

    if (pResponseInfo->cWsaBuf == 0xFFFFFFFF) {
        // we have a file handle rather than a memory buffer
        pVectorElement->ElementType = HSE_VECTOR_ELEMENT_TYPE_FILE_HANDLE;
        pVectorElement->pvContext = pResponseInfo->rgWsaBuf[0].buf;
        pVectorElement->cbSize = pResponseInfo->rgWsaBuf[0].len;
        dwTotalBytes += pResponseInfo->rgWsaBuf[0].len;
        pVectorElement++;
    } else {
        FILL_HSE_VECTOR_LOOP( pResponseInfo->cWsaBuf, pResponseInfo->rgWsaBuf)
    }

    if (pResponseVectors) {
        FILL_HSE_VECTOR_LOOP( pResponseVectors->dwVectorLen1, pResponseVectors->pVector1)

        FILL_HSE_VECTOR_LOOP( pResponseVectors->dwVectorLen2, pResponseVectors->pVector2)
    }
#undef FILL_HSE_VECTOR_LOOP

    // reset to the begining of buffer
    pVectorElement = pVectorSendCB->m_pVectorElements;

FillHeaderAndSend:

    pRespVector->dwFlags        = (pComplFunc ? HSE_IO_ASYNC : HSE_IO_SYNC) |
                                  (!fKeepConn ? HSE_IO_DISCONNECT_AFTER_SEND : 0) |
                                  (pResponseInfo->HeaderInfo.pszHeader ? HSE_IO_SEND_HEADERS : 0);
    pRespVector->pszStatus      = (LPSTR)pResponseInfo->HeaderInfo.pszStatus;
    pRespVector->pszHeaders     = (LPSTR)pResponseInfo->HeaderInfo.pszHeader;
    pRespVector->nElementCount  = nElementCount;
    pRespVector->lpElementArray = pVectorElement;
    dwTotalBytes += pResponseInfo->HeaderInfo.cchStatus;
    dwTotalBytes += pResponseInfo->HeaderInfo.cchHeader;

    // Note that the headers have been written

    if (pResponseInfo->HeaderInfo.pszHeader)
        m_fHeadersWritten = TRUE;

    // by moving these pointers into our SEND_VECTOR, we are taking
    // ownership of the memory.

    pResponseInfo->HeaderInfo.pszStatus = NULL;
    pResponseInfo->HeaderInfo.pszHeader = NULL;

    if (pComplFunc) {

        hr = AddToPendingList(pVectorSendCB);

    }
    else {

        //
        // Send it
        //

        if (ServerSupportFunction(HSE_REQ_VECTOR_SEND,
                                  pRespVector,
                                  NULL,
                                  NULL) == FALSE) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (SUCCEEDED(hr)) {
        pResponseInfo->cbWritten = dwTotalBytes;
    }

Exit:

    if (FAILED(hr))
    {
        SetLastError((HRESULT_FACILITY(hr) == (HRESULT)FACILITY_WIN32)
            ? HRESULT_CODE(hr)
            : ERROR_INVALID_PARAMETER);

        if (pVectorSendCB && (pVectorSendCB != &syncVectorSendCB)) {

            delete pVectorSendCB;
        }

        return FALSE;
    }

    return TRUE;
}

/*===================================================================
CIsapiReqInfo::TestConnection
===================================================================*/
BOOL CIsapiReqInfo::TestConnection(BOOL  *pfIsConnected)
{
    return ServerSupportFunction(HSE_REQ_IS_CONNECTED,
                                 pfIsConnected,
                                 NULL,
                                 NULL);
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathA
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_URL_TO_PATH,
                                  pBuffer,
                                  pdwBytes,
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathW
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_UNICODE_URL_TO_PATH,
                                  pBuffer,
                                  pdwBytes,
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::SyncReadClient
===================================================================*/
BOOL CIsapiReqInfo::SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes )
{
    return m_pECB->ReadClient(m_pECB->ConnID, pvBuffer, pdwBytes);
}

/*===================================================================
CIsapiReqInfo::SyncWriteClient
===================================================================*/
BOOL CIsapiReqInfo::SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes)
{
    return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_SYNC);
}

/*********************************************************************
PRIVATE FUNCTIONS
*********************************************************************/

/*===================================================================
CIsapiReqInfo::InitVersionInfo
===================================================================*/
void CIsapiReqInfo::InitVersionInfo()
{
    if (m_fVersionInited == FALSE) {

        BUFFER  version;

        m_fVersionInited = TRUE;
        m_dwVersionMajor = 1;
        m_dwVersionMinor = 0;

        if (InternalGetServerVariable("SERVER_PROTOCOL", &version)) {

            char *pVersionStr = (char *)version.QueryPtr();

            if ((strlen(pVersionStr) >= 8)
                && (isdigit((UCHAR)pVersionStr[5]))
                && (isdigit((UCHAR)pVersionStr[7]))) {

                m_dwVersionMajor = pVersionStr[5] - '0';
                m_dwVersionMinor = pVersionStr[7] - '0';
            }
        }
    }
}

/*===================================================================
CIsapiReqInfo::InternalGetServerVariable
===================================================================*/
BOOL CIsapiReqInfo::InternalGetServerVariable(LPSTR pszVarName, BUFFER  *pBuf)
{
    BOOL    bRet;
    DWORD   dwRequiredBufSize = pBuf->QuerySize();

    bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                     pszVarName,
                                     pBuf->QueryPtr(),
                                     &dwRequiredBufSize);

    if ((bRet == FALSE) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (!pBuf->Resize(dwRequiredBufSize)) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                         pszVarName,
                                         pBuf->QueryPtr(),
                                         &dwRequiredBufSize);
    }

    return(bRet);
}

/*===================================================================
CIsapiReqInfo::FKeepConn
===================================================================*/
BOOL CIsapiReqInfo::FKeepConn()
{
    if (m_fFKeepConnInited == FALSE) {

        m_fFKeepConnInited = TRUE;
        m_fKeepConn = FALSE;

        InitVersionInfo();

        if (m_dwVersionMajor == 1) {

            if (m_dwVersionMinor == 1) {
                m_fKeepConn = TRUE;
            }

            BUFFER  connectStr;

            if (InternalGetServerVariable("HTTP_CONNECTION", &connectStr)) {

                if (m_dwVersionMinor == 0) {

                    m_fKeepConn = !(_stricmp((char *)connectStr.QueryPtr(), "keep-alive"));
                }
                else if (m_dwVersionMinor == 1) {

                    m_fKeepConn = !!(_stricmp((char *)connectStr.QueryPtr(), "close"));
                }
            }
        }
    }

    return m_fKeepConn;
}

/*===================================================================
CIsapiReqInfo::GetMetabaseIF
===================================================================*/
IMSAdminBase   *CIsapiReqInfo::GetMetabaseIF(HRESULT *pHr)
{
    IMSAdminBase        *pMetabase;

    //
    //Set *pHr to S_OK in case its not initialized
    //
    *pHr    =   S_OK;

    if (m_pIAdminBase == NULL) {
        *pHr = CoCreateInstance(CLSID_MSAdminBase,
                                      NULL,
                                      CLSCTX_ALL,
                                      IID_IMSAdminBase,
                                      (void**)&pMetabase);
        ASSERT(SUCCEEDED(*pHr));

        if ( InterlockedCompareExchangePointer( (VOID**)&m_pIAdminBase, pMetabase, NULL) != NULL )
        {
           pMetabase->Release();
           pMetabase = NULL;
        }
    }
    return m_pIAdminBase;
}

/*===================================================================
CIsapiReqInfo::AddToPendingList

  Places an CAsyncVectorSendCB on the PendingSendCS.  If this is
  the first entry placed on the list, then IssueNextSend() is called
  to start the possible chain of sends.

===================================================================*/
HRESULT CIsapiReqInfo::AddToPendingList(CAsyncVectorSendCB  *pVectorCB)
{

    HRESULT hr = S_OK;

    // initialize the critical section if it hasn't already
    // been initialized.  Note that there isn't a race condition
    // here because there can't be any other thread contenting for
    // this CS until AsyncIOs start to complete.  It's safe to
    // assume that the IO hasn't begun if we've never enterred
    // this routine before...

    if (m_fPendSendCSInited == FALSE) {

        ErrInitCriticalSection(&m_csPendingSendCS, hr);

        if (SUCCEEDED(hr))
            m_fPendSendCSInited = TRUE;
    }

    // similar to the CS above, register the completion function

    if (SUCCEEDED(hr) && (m_fIOCompletionRegistered == FALSE)) {

        if (ServerSupportFunction(HSE_REQ_IO_COMPLETION,
                                  AsyncCompletion,
                                  NULL,
                                  (LPDWORD)this) == FALSE)
                hr = HRESULT_FROM_WIN32(GetLastError());

        if (SUCCEEDED(hr))
            m_fIOCompletionRegistered = TRUE;
    }

    // do not queue new requests if an error was previously recorded

    if (SUCCEEDED(hr)) {
        hr = HRESULT_FROM_WIN32(m_dwAsyncError);
    }

    // we'll return error here if anything went wrong.  Otherwise, we're
    // going to execute the rest of the logic and return S_OK.  Any
    // errors downstream from here will report through the completion
    // functions.

    if (FAILED(hr))
        return hr;

    m_dwRequestStatus = HSE_STATUS_PENDING;

    EnterCriticalSection(&m_csPendingSendCS);

    BOOL fFirstEntry = m_listPendingSends.FIsEmpty();

    pVectorCB->AppendTo(m_listPendingSends);

    LeaveCriticalSection(&m_csPendingSendCS);

    // if the list was empty, then call IssueNextSend() to get things started

    if (fFirstEntry)
        IssueNextSend();

    return S_OK;
}

/*===================================================================
CIsapiReqInfo::IssueNextSend

  Enters the critical section to grab the first entry on the queue.

  Note that the entry is left on the list.  This is the easiest
  way to communicate with the completion routine which
  CAsyncVectorSendCB just completed.

  Errors are handled by creating a "fake" completion - i.e the
  registered completion function is called from here instead of
  by the core.

===================================================================*/
void CIsapiReqInfo::IssueNextSend()
{
    CAsyncVectorSendCB  *pVectorSendCB = NULL;
    HRESULT             hr = S_OK;
    DWORD               dwIOError = 0;

    EnterCriticalSection(&m_csPendingSendCS);

    if (!m_listPendingSends.FIsEmpty()) {

        pVectorSendCB = (CAsyncVectorSendCB *)m_listPendingSends.PNext();

    }

    LeaveCriticalSection(&m_csPendingSendCS);

    if (pVectorSendCB) {

        // increment here that there is about to be an outstanding
        // async write.  Note that it is possible that an error
        // condition could result in the AsyncCompletion being called
        // and that routine decrements this counter.  Again, once were
        // at this point, one way or another, the async completion
        // routine is going to be called.

        InterlockedIncrement(&g_nOutstandingAsyncWrites);


        // check to see if an error was previously recorded

        if (m_dwAsyncError) {
            dwIOError = m_dwAsyncError;
        }

        // otherwise, call HSE_REQ_VECTOR_SEND

        else if (ServerSupportFunction(HSE_REQ_VECTOR_SEND,
                                       &pVectorSendCB->m_hseResponseVector,
                                       NULL,
                                       NULL) == FALSE) {

            dwIOError = GetLastError();

        }

        // if an error has been noted, call the AsyncCompletion to clean
        // things up

        if (dwIOError) {
            CIsapiReqInfo::AsyncCompletion(pVectorSendCB->m_pIReq->m_pECB,
                                           pVectorSendCB->m_pIReq,
                                           0,
                                           dwIOError);
        }
    }
}

/*===================================================================
CIsapiReqInfo::AsyncCompletion

  Called to handle the successful, or unsuccessful, completion of
  a pending async send.

  The logic is pretty straightforward.  Grab the head entry on the
  async pending queue, call the completion function, call
  call IssueNextSend() to keep the send chain going, release this
  reference on the IsapiReqInfo.

===================================================================*/
WINAPI CIsapiReqInfo::AsyncCompletion(EXTENSION_CONTROL_BLOCK * pECB,
                                           PVOID    pContext,
                                           DWORD    cbIO,
                                           DWORD    dwError)
{
    CIsapiReqInfo      *pIReq = (CIsapiReqInfo  *)pContext;
    CAsyncVectorSendCB  *pCB;
    BOOL                fIsEmpty;

    InterlockedDecrement(&g_nOutstandingAsyncWrites);

    // if an error is being reported, note it.
    // do it here, so subsequent new requests do not get added to the queue and dispatched

    if (dwError)
        pIReq->m_dwAsyncError = dwError;

    //
    // the following block is normally executed once, to handle the completed control
    // block. However, in case of an error, we'll itterate on the queue until it drains.
    //
    do {
        // lock the CS and get the head

        EnterCriticalSection(&pIReq->m_csPendingSendCS);

        Assert(!pIReq->m_listPendingSends.FIsEmpty());

        pCB = (CAsyncVectorSendCB *)pIReq->m_listPendingSends.PNext();

        // this wouldn't be good, and likely impossible because if
        // the list is empty, it will return the head pointer.

        Assert(pCB);

        Assert(pIReq == pCB->m_pIReq);

        // remove it from the list

        pCB->UnLink();

        fIsEmpty = pIReq->m_listPendingSends.FIsEmpty();

        LeaveCriticalSection(&pIReq->m_csPendingSendCS);

        // call the client's completion function

        pCB->m_pCallerFunc(pCB->m_pIReq, pCB->m_pCallerContext, cbIO, dwError);

        // we are done with this CAsyncVectorSendCB

        delete pCB;

        // if no error occured, break out and keep going

        if (!dwError) {
            break;
        }

    } while ( !fIsEmpty );

    // keep the sends going, if there are sends to do

    if (!fIsEmpty)
        pIReq->IssueNextSend();
}

/*===================================================================
CAsyncVectorSendCB::CAsyncVectorSendCB

  Base Constructor - clear everything

===================================================================*/
CAsyncVectorSendCB::CAsyncVectorSendCB() {
    m_pIReq             = NULL;
    m_pCallerContext    = NULL;
    m_pCallerFunc       = NULL;
    m_pVectorElements   = m_aVectorElements;

    ZeroMemory(&m_hseResponseVector, sizeof(HSE_RESPONSE_VECTOR));

    ZeroMemory(m_pVectorElements,
               sizeof(m_aVectorElements));

}

/*===================================================================
CAsyncVectorSendCB::CAsyncVectorSendCB

  Overriden Constructor - sets some members based on passed in
  values.

===================================================================*/
CAsyncVectorSendCB::CAsyncVectorSendCB(CIsapiReqInfo            *pIReq,
                                       void                     *pContext,
                                       PFN_CLIENT_IO_COMPLETION  pFunc) {

    ZeroMemory(&m_hseResponseVector, sizeof(HSE_RESPONSE_VECTOR));

    m_pIReq           = pIReq;
    m_pCallerContext  = pContext;
    m_pCallerFunc     = pFunc;
    m_pVectorElements = m_aVectorElements;

    ZeroMemory(m_pVectorElements,
               sizeof(m_aVectorElements));

    pIReq->AddRef();
}

/*===================================================================
CAsyncVectorSendCB::~CAsyncVectorSendCB

  Destructor - cleans up

===================================================================*/
CAsyncVectorSendCB::~CAsyncVectorSendCB() {

    // if m_pVectorElements is not pointing to the built-in array,
    // then it must be allocated memory.  Free it.

    if (m_pVectorElements && (m_pVectorElements != m_aVectorElements))
        free(m_pVectorElements);

    // free the Headers and Status strings, if allocated

    if (m_hseResponseVector.pszHeaders)
        free(m_hseResponseVector.pszHeaders);

    if (m_hseResponseVector.pszStatus)
        free(m_hseResponseVector.pszStatus);

    if (m_pIReq) {
        m_pIReq->Release();
        m_pIReq = NULL;
    }
}

/*===================================================================
CAsyncVectorSendCB::SetElementCount

  Makes sure that m_pVectorElements is sufficiently sized.  If the
  number of elements is less than or equal to the size of the
  built-in array, it is used.  If not, one is allocated.

===================================================================*/
HRESULT     CAsyncVectorSendCB::SetElementCount(DWORD  nElements)
{
    if (nElements <= (sizeof(m_aVectorElements)/sizeof(HSE_VECTOR_ELEMENT)))
        return S_OK;

    m_pVectorElements = (HSE_VECTOR_ELEMENT *)malloc(sizeof(HSE_VECTOR_ELEMENT)*nElements);

    if (m_pVectorElements == NULL) {
        return E_OUTOFMEMORY;
    }

    ZeroMemory(m_pVectorElements,
               nElements * sizeof(HSE_VECTOR_ELEMENT));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\memchk.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.h

Owner: PramodD

This is the Memory Manager header file
===================================================================*/

#ifndef MEMCHK_H
#define MEMCHK_H

#define DENALI_MEMCHK

// Always use these macros, DO NOT ever use DenaliMemXX functions directly

// Function names that SHOULD BE used

#define malloc(x)			DenaliMemAlloc( x, __FILE__, __LINE__ )
#define calloc(x,y)			DenaliMemCalloc( x, y, __FILE__, __LINE__ )
#define realloc(x,y)		DenaliMemReAlloc( x, y, __FILE__, __LINE__ )
#define free(x)				DenaliMemFree( x, __FILE__, __LINE__ )
#define DenaliMemoryInit()	DenaliMemInit( __FILE__, __LINE__ )
#define DenaliMemoryUnInit() DenaliMemUnInit( __FILE__, __LINE__ )
#define DenaliDiagnostics()	DenaliMemDiagnostics( __FILE__, __LINE__ )
#define DenaliIsValid(x)	DenaliMemIsValid(x)

// Functions that are actually linked

extern HRESULT				DenaliMemInit(const char *szFile, int lineno);
extern void					DenaliMemUnInit(const char *szFile, int lineno);
extern void					DenaliMemDiagnostics(const char *szFile, int lineno);
extern void					DenaliLogCall(const char *szLog, const char *szFile, int lineno);
extern void *				DenaliMemAlloc(size_t cSize, const char *szFile, int lineno );
extern void *				DenaliMemCalloc(size_t cNum, size_t cbSize, const char *szFile, int lineno );
extern void					DenaliMemFree(void * p, const char *szFile, int lineno);
extern void *				DenaliMemReAlloc(void * p, size_t cSize, const char *szFile, int lineno);
extern int					DenaliMemIsValid(void * p);

// Redefinition of global operators new and delete
#ifdef __cplusplus

// override for the default operator new
inline void * __cdecl operator new(size_t cSize) 
	{
	return DenaliMemAlloc(cSize, NULL, 0); 
	}

// override for the custom operator new with 3 args
inline void * operator new(size_t cSize, const char *szFile, int lineno)
	{
	return DenaliMemAlloc(cSize, szFile, lineno); 
	}

// override for the default operator delete
inline void __cdecl operator delete(void * p) 
    {
    DenaliMemFree(p, NULL, 0); 
    }

// Macro to grab source file and line number information

#define new					new( __FILE__, __LINE__ )

/*
#define delete DenaliLogCall( "Calling delete operator", __FILE__, __LINE__ ), delete
*/

#endif // __cplusplus

#endif // MEMCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\memcls.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.cpp

Owner: dmitryr

This file contains the code to access ATQ memory cache on per
class basis
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asperror.h"
#include "clcert.h"
#include "context.h"
#include "cookies.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "strlist.h"
#include "tlbcache.h"
#include "memcls.h"

// Don't #include "memchk.h" in this file

/*===================================================================
  DEBUG only

  gs_cTotalObjectsLeaked counts memory leaks

  DebugCheckLeaks() outputs the ATQ cache memory
  leaks into denmem.log

  DEBUG_ACACHE_UNINIT() and DEBUG_ACACHE_FSA_UNINIT() call
  DebugCheckLeaks() in DEBUG mode only
===================================================================*/

#ifdef DBG

static DWORD gs_cTotalObjectsLeaked = 0;

#define SZ_MEMCLS_LOG_FILE  "C:\\TEMP\\MEMCLS.LOG"

static void DebugCheckLeaks(ALLOC_CACHE_HANDLER *pach, const char *szClass)
    {
    ALLOC_CACHE_STATISTICS acStats;
    pach->QueryStats(&acStats);
    DWORD cLeaked = acStats.nTotal - acStats.nFreeEntries;

    if (cLeaked > 0)
        {
        gs_cTotalObjectsLeaked += cLeaked;
        
        DebugFilePrintf
            (
            SZ_MEMCLS_LOG_FILE, 
            "MEMCLS: ATQ allocation cache leak: %d of %s objects.\n",
            cLeaked,
            szClass
            );
        }
    }

#define DEBUG_ACACHE_UNINIT(C)      { DebugCheckLeaks(C::sm_pach, #C);  \
                                      ACACHE_UNINIT(C) }
#define DEBUG_ACACHE_FSA_UNINIT(C)  { DebugCheckLeaks(g_pach##C, #C);   \
                                      ACACHE_FSA_UNINIT(C) }
#else

#define DEBUG_ACACHE_UNINIT(C)      ACACHE_UNINIT(C)
#define DEBUG_ACACHE_FSA_UNINIT(C)  ACACHE_FSA_UNINIT(C)

#endif

/*===================================================================
  For each class with ACACHE_INCLASS_DEFINITIONS() inside add
  here ACACHE_CODE macro.
===================================================================*/

ACACHE_CODE(C449Cookie)
ACACHE_CODE(C449File)
ACACHE_CODE(CASEElem)
ACACHE_CODE(CActiveScriptEngine)
ACACHE_CODE(CAppln)
ACACHE_CODE(CApplnVariants)
ACACHE_CODE(CASPError)
ACACHE_CODE(CAsyncVectorSendCB)
ACACHE_CODE(CClCert)
ACACHE_CODE(CComponentCollection)
ACACHE_CODE(CComponentObject)
ACACHE_CODE(CCookie)
ACACHE_CODE(CDebugResponseBuffer)
ACACHE_CODE(CEngineDispElem)
ACACHE_CODE(CFileApplnList)
ACACHE_CODE(CHitObj)
ACACHE_CODE(CHTTPHeader)
ACACHE_CODE(CIsapiReqInfo)
ACACHE_CODE(CPageComponentManager)
ACACHE_CODE(CPageObject)
ACACHE_CODE(CRequest)
ACACHE_CODE(CRequestData)
ACACHE_CODE(CRequestHit)
ACACHE_CODE(CResponse)
ACACHE_CODE(CResponseBuffer)
ACACHE_CODE(CResponseBufferSet)
ACACHE_CODE(CResponseData)
ACACHE_CODE(CScriptingNamespace)
ACACHE_CODE(CScriptingContext)
ACACHE_CODE(CServer)
ACACHE_CODE(CServerData)
ACACHE_CODE(CSession)
ACACHE_CODE(CSessionVariants)
ACACHE_CODE(CStringList)
ACACHE_CODE(CStringListElem)
ACACHE_CODE(CTemplate)
//ACACHE_CODE(CTemplate::CBuffer)
ACACHE_CODE(CTemplate::CFileMap)
ACACHE_CODE(CTypelibCacheEntry)
ACACHE_CODE(CVariantsIterator)
ACACHE_CODE(CViperActivity)
ACACHE_CODE(CViperAsyncRequest)

/*===================================================================
  For each fixed size allocator add here ACACHE_FSA_DEFINITION macro.
===================================================================*/

ACACHE_FSA_DEFINITION(MemBlock128)
ACACHE_FSA_DEFINITION(MemBlock256)
ACACHE_FSA_DEFINITION(ResponseBuffer)

/*===================================================================
  Defines for cache threshold of each kind
===================================================================*/
#define HARDCODED_PER_APPLN_CACHE_MAX     128
#define HARDCODED_PER_REQUEST_CACHE_MAX   1024
#define HARDCODED_PER_QUEUEITEM_CACHE_MAX 8192
#define HARDCODED_PER_SESSION_CACHE_MAX   8192
#define HARDCODED_PER_SCRPTENG_CACHE_MAX  256
#define HARDCODED_PER_TEMPLATE_CACHE_MAX  2048
#define HARDCODED_PER_RESPONSE_BUFFER_MAX 64
#define HARDCODED_PER_SIZE_BUFFER_MAX     4096

// do scaling per registry setting
DWORD dwMemClsScaleFactor;

#define PER_APPLN_CACHE_MAX     ((HARDCODED_PER_APPLN_CACHE_MAX     * dwMemClsScaleFactor) / 100)
#define PER_REQUEST_CACHE_MAX   ((HARDCODED_PER_REQUEST_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_QUEUEITEM_CACHE_MAX ((HARDCODED_PER_QUEUEITEM_CACHE_MAX * dwMemClsScaleFactor) / 100)
#define PER_SESSION_CACHE_MAX   ((HARDCODED_PER_SESSION_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_SCRPTENG_CACHE_MAX  ((HARDCODED_PER_SCRPTENG_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_TEMPLATE_CACHE_MAX  ((HARDCODED_PER_TEMPLATE_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_RESPONSE_BUFFER_MAX ((HARDCODED_PER_RESPONSE_BUFFER_MAX * dwMemClsScaleFactor) / 100)
#define PER_SIZE_BUFFER_MAX     ((HARDCODED_PER_SIZE_BUFFER_MAX     * dwMemClsScaleFactor) / 100)

/*===================================================================
InitMemCls

To be called from DllInit(). Creates per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_INIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_INIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMemCls()
    {
    // Set the scaling to normal
    dwMemClsScaleFactor = 100;

    // Init the allocators
    
    HRESULT hr = S_OK;

    ACACHE_INIT(C449Cookie,             PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(C449File,               PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(CASEElem,               PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT(CActiveScriptEngine,    PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT_EX(CAppln,              PER_APPLN_CACHE_MAX,    FALSE, hr)
    ACACHE_INIT(CApplnVariants,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CASPError,              PER_RESPONSE_BUFFER_MAX,hr)
    ACACHE_INIT(CAsyncVectorSendCB,     PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CClCert,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentCollection,   PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentObject,     2*PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CCookie,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CDebugResponseBuffer,   PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CEngineDispElem,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CFileApplnList,       2*PER_APPLN_CACHE_MAX,    hr)
    ACACHE_INIT(CHitObj,                PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CHTTPHeader,          2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CIsapiReqInfo,          PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageComponentManager,  PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageObject,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequest,               PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestData,           PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestHit,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponse,              PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseBuffer,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseBufferSet,     PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseData,          PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingContext,      PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingNamespace,    PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServer,                PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServerData,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT_EX(CSession,            PER_SESSION_CACHE_MAX,  FALSE, hr)
    ACACHE_INIT(CSessionVariants,       PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringList,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringListElem,      2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CTemplate,              PER_TEMPLATE_CACHE_MAX, hr)
//    ACACHE_INIT(CTemplate::CBuffer,     PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTemplate::CFileMap,    PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTypelibCacheEntry,     PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CVariantsIterator,      PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperActivity,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperAsyncRequest,     PER_QUEUEITEM_CACHE_MAX,hr)
    
    ACACHE_FSA_INIT(MemBlock128,    128,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(MemBlock256,    256,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(ResponseBuffer, RESPONSE_BUFFER_SIZE, PER_RESPONSE_BUFFER_MAX, hr)

#ifdef DBG
    unlink(SZ_MEMCLS_LOG_FILE);

    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE, 
        "MEMCLS: ATQ allocation cache inited with HRESULT=%08x.\n",
        hr
        );
#endif

    return hr;
    }

/*===================================================================
UnInitMemCls

To be called from DllInit(). Deletes per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_UNINIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_UNINIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMemCls()
    {
#ifdef DBG
    gs_cTotalObjectsLeaked = 0;
#endif

    DEBUG_ACACHE_UNINIT(C449Cookie)
    DEBUG_ACACHE_UNINIT(C449File)
    DEBUG_ACACHE_UNINIT(CASEElem)
    DEBUG_ACACHE_UNINIT(CActiveScriptEngine)
    DEBUG_ACACHE_UNINIT(CAppln)
    DEBUG_ACACHE_UNINIT(CApplnVariants)
    DEBUG_ACACHE_UNINIT(CASPError)
    DEBUG_ACACHE_UNINIT(CAsyncVectorSendCB)
    DEBUG_ACACHE_UNINIT(CClCert)
    DEBUG_ACACHE_UNINIT(CComponentCollection)
    DEBUG_ACACHE_UNINIT(CComponentObject)
    DEBUG_ACACHE_UNINIT(CCookie)
    DEBUG_ACACHE_UNINIT(CDebugResponseBuffer)
    DEBUG_ACACHE_UNINIT(CEngineDispElem)
    DEBUG_ACACHE_UNINIT(CFileApplnList)
    DEBUG_ACACHE_UNINIT(CHitObj)
    DEBUG_ACACHE_UNINIT(CHTTPHeader)
    DEBUG_ACACHE_UNINIT(CIsapiReqInfo)
    DEBUG_ACACHE_UNINIT(CPageComponentManager)
    DEBUG_ACACHE_UNINIT(CPageObject)
    DEBUG_ACACHE_UNINIT(CRequest)
    DEBUG_ACACHE_UNINIT(CRequestData)
    DEBUG_ACACHE_UNINIT(CRequestHit)
    DEBUG_ACACHE_UNINIT(CResponse)
    DEBUG_ACACHE_UNINIT(CResponseBuffer)
    DEBUG_ACACHE_UNINIT(CResponseBufferSet)
    DEBUG_ACACHE_UNINIT(CResponseData)
    DEBUG_ACACHE_UNINIT(CScriptingNamespace)
    DEBUG_ACACHE_UNINIT(CScriptingContext)
    DEBUG_ACACHE_UNINIT(CServer)
    DEBUG_ACACHE_UNINIT(CServerData)
    DEBUG_ACACHE_UNINIT(CSession)
    DEBUG_ACACHE_UNINIT(CSessionVariants)
    DEBUG_ACACHE_UNINIT(CStringList)
    DEBUG_ACACHE_UNINIT(CStringListElem)
    DEBUG_ACACHE_UNINIT(CTemplate)
//    DEBUG_ACACHE_UNINIT(CTemplate::CBuffer)
    DEBUG_ACACHE_UNINIT(CTemplate::CFileMap)
    DEBUG_ACACHE_UNINIT(CTypelibCacheEntry)
    DEBUG_ACACHE_UNINIT(CVariantsIterator)
    DEBUG_ACACHE_UNINIT(CViperActivity)
    DEBUG_ACACHE_UNINIT(CViperAsyncRequest)

    DEBUG_ACACHE_FSA_UNINIT(MemBlock128)
    DEBUG_ACACHE_FSA_UNINIT(MemBlock256)
    DEBUG_ACACHE_FSA_UNINIT(ResponseBuffer)

#ifdef DBG
    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE,
        "MEMCLS: ATQ allocation cache uninited.\n"
        "MEMCLS: Total of %d ASP objects leaked.\n",
        gs_cTotalObjectsLeaked
        );
#endif

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\memcls.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.h

Owner: dmitryr

This file contains #defines to access ATQ memory cache on per
class basis
===================================================================*/

#ifndef MEMCLS_H
#define MEMCLS_H

// ATQ memory cache
#include <acache.hxx>

// To resolve Assert()
#include "debug.h"

// Prototypes

HRESULT InitMemCls();
HRESULT UnInitMemCls();

/*===================================================================
  M A C R O S  to make a class use ACACHE allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a class named CFoo to the per-class basis follow these
    four simple steps:

    1) Inside the class definition include ACACHE_INCLASS_DEFINITIONS():

            class CFoo
                {
                ...


                ACACHE_INCLASS_DEFINITIONS()    // <-add this line
                };

    2) In a source file add the ACACHE_CODE macro outside
       any function body:
       
            ACACHE_CODE(CFoo)                   // <-add this line

    3) In a DLL initialization routine add ACACHE_INIT macro:

            ACACHE_INIT(CFoo, 13, hr)           // <-add this line

       where 13 is the threshold. Use the desired number instead.
       

    4) In a DLL uninitialization routine add ACACHE_UNINIT macro:

            ACACHE_UNINIT(CFoo)                 // <-add this line
            

===================================================================*/

/*

The following macro should be used inside class definition to
enable per-class caching.

The second operator new is needed in case memchk.h [#define]'s new
to this expanded form.

*/

#define ACACHE_INCLASS_DEFINITIONS()                            \
    public:                                                     \
        static void * operator new(size_t);                     \
        static void * operator new(size_t, const char *, int);  \
        static void   operator delete(void *);                  \
        static ALLOC_CACHE_HANDLER *sm_pach;

/*

The following macro should be used once per class in a source
file outside of any functions. The argument is the class name.

*/

#define ACACHE_CODE(C)                                          \
    ALLOC_CACHE_HANDLER *C::sm_pach;                            \
    void *C::operator new(size_t s)                             \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void *C::operator new(size_t s, const char *, int)          \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void C::operator delete(void *pv)                           \
        { Assert(pv); if (sm_pach) sm_pach->Free(pv); }

/*

The following macro should be used once per class in the
DLL initialization routine.
Arguments: class name, cache size, HRESULT var name

*/

#define ACACHE_INIT(C, T, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_INIT_EX(C, T, F, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc, F);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

/*

The following macro should be used once per class in the
DLL uninitialization routine. The argument is the class name.

*/

#define ACACHE_UNINIT(C)                                        \
    { if (C::sm_pach) { delete C::sm_pach; C::sm_pach = NULL; } }


/*===================================================================
  M A C R O S  to create a fixes size allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a fixed size allocator for 1K buffers named Foo
    to the code follow these simple steps:

    1) In a header file include extern definition

            ACACHE_FSA_EXTERN(Foo)

    2) In a source file the actual definition outside
       any function body:
       
            ACACHE_FSA_DEFINITION(Foo)

    3) In a DLL initialization routine add INIT macro:

            ACACHE_FSA_INIT(Foo, 1024, 13, hr)

       where 1024 is the size and 13 is the threshold.
       Use the desired numbers instead.
       
    4) In a DLL uninitialization routine add UNINIT macro:

            ACACHE_FSA_UNINIT(CFoo)

    5) To allocate, do:

            void *pv = ACACHE_FSA_ALLOC(Foo)

    6) To free, do:

            ACACHE_FSA_FREE(Foo, pv)

===================================================================*/

#define ACACHE_FSA_EXTERN(C)                                    \
    extern ALLOC_CACHE_HANDLER *g_pach##C;

#define ACACHE_FSA_DEFINITION(C)                                \
    ALLOC_CACHE_HANDLER *g_pach##C = NULL;

#define ACACHE_FSA_INIT(C, S, T, hr)                            \
    { if (SUCCEEDED(hr)) { Assert(!g_pach##C);                  \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, S };                \
    g_pach##C = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);       \
    hr = g_pach##C ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_FSA_UNINIT(C)                                    \
    { if (g_pach##C) { delete g_pach##C; g_pach##C = NULL; } }

#define ACACHE_FSA_ALLOC(C)                                     \
    ( g_pach##C ? g_pach##C->Alloc() : NULL )

#define ACACHE_FSA_FREE(C, pv)                                  \
    { Assert(pv); if (g_pach##C) g_pach##C->Free(pv); }
    
#endif // MEMCLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\mtacb.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.cpp

Owner: DmitryR

This file contains the implementation of MTA callbacks
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "MTAcb.h"
#include "memchk.h"

/*===================================================================
  MTA Callback Thread

  Worker thread that implements the MTA callback functionality
===================================================================*/
class CMTACallbackThread
    {
private:
    DWORD m_fInited : 1;    // inited?
    DWORD m_fCSInited : 1;  // critical section inited?
    DWORD m_fShutdown : 1;  // shutdown?

    CRITICAL_SECTION  m_csLock;      // callback critical section
    HANDLE            m_hDoItEvent;  // callback requested event
    HANDLE            m_hDoneEvent;  // callback done event
    HANDLE            m_hThread;     // thread handle

    PMTACALLBACK      m_pMTACallback;   // callback function ptr
    void             *m_pvContext;      // arg1
    void             *m_pvContext2;     // arg2
    HRESULT           m_hrResult;       // return code

    // The call callback from MTA thread
    void DoCallback()
        {
        Assert(m_pMTACallback);
        m_hrResult = (*m_pMTACallback)(m_pvContext, m_pvContext2);
        }

    // The thread function
    static unsigned Thread(void *pvArg)
        {
        HRESULT hr;

        Assert(pvArg);
        CMTACallbackThread *pThread = (CMTACallbackThread *)pvArg;

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);  // MTA
        if (FAILED(hr))
            {
            // Bug 87857: Handle failure from CoInitialize
            if (hr == E_INVALIDARG)
                {
                CoUninitialize();
                }
                
            // This shouldnt actually fail.  Not entirely clear what to do if it does
            Assert(FALSE);
            return hr;
            }

        while (!pThread->m_fShutdown)
            {
            DWORD dwRet = MsgWaitForMultipleObjects
                (
                1,
                &(pThread->m_hDoItEvent),
                FALSE,
                INFINITE,
                QS_ALLINPUT
                );

            if (pThread->m_fShutdown)
                break;

            if (dwRet == WAIT_OBJECT_0)
                {
                // Event -> do the callback
                pThread->DoCallback();
                SetEvent(pThread->m_hDoneEvent);
                }
            else
                {
                // Do messages
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
                }
            }

        CoUninitialize();
        return 0;
        }

public:
    // Constructor
    CMTACallbackThread()
        : m_fInited(FALSE), m_fCSInited(FALSE), m_fShutdown(FALSE),
          m_hDoItEvent(NULL), m_hDoneEvent(NULL), m_hThread(NULL),
          m_pMTACallback(NULL)
        {
        }

    // Destructor
    ~CMTACallbackThread()
        {
        // Real cleanup is in UnInit()
        // This is to cleanup after a bad Init()
        if (m_fCSInited)
            DeleteCriticalSection(&m_csLock);
        if (m_hDoItEvent)
            CloseHandle(m_hDoItEvent);
        if (m_hDoneEvent)
            CloseHandle(m_hDoneEvent);
        }

    // Init (real constructor)
    HRESULT Init()
        {
        HRESULT hr = S_OK;

        if (SUCCEEDED(hr))
            {
            ErrInitCriticalSection(&m_csLock, hr);
            m_fCSInited = SUCCEEDED(hr);
            }

        if (SUCCEEDED(hr))
            {
            m_hDoItEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoItEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoItEvent)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_hDoneEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoneEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoneEvent)
                hr = E_OUTOFMEMORY;
            }
        
        // Launch the MTA thread

        unsigned threadId;
        uintptr_t ulThread = _beginthreadex(NULL,
                                            0,
                                            CMTACallbackThread::Thread,
                                            this,
                                            0,
                                            &threadId);
        if (ulThread == 0xffffffff || ulThread == 0)
            hr = E_OUTOFMEMORY;
        else
            m_hThread = (HANDLE)ulThread;

        if (SUCCEEDED(hr))
            m_fInited = TRUE;
        return hr;
        }

    // UnInit (real destructor)
    HRESULT UnInit()
        {
        Assert(m_fInited);

        if (m_hThread)
            {
            // Kill the MTA thread
            m_fShutdown = TRUE;
            SetEvent(m_hDoItEvent);
            WaitForSingleObject(m_hThread, INFINITE);
            CloseHandle(m_hThread);
            m_hThread = NULL;
            }

        if (m_fCSInited)
            {
            DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }

        if (m_hDoItEvent)
            {
            CloseHandle(m_hDoItEvent);
            m_hDoItEvent = NULL;
            }

        if (m_hDoneEvent)
            {
            CloseHandle(m_hDoneEvent);
            m_hDoneEvent = NULL;
            }
    
        m_fInited = FALSE;
        return S_OK;
        }

    // Execute callback
    HRESULT CallCallback
    (
    PMTACALLBACK pMTACallback,
    void        *pvContext,
    void        *pvContext2
    )
        {
        if (m_fShutdown)
            return E_FAIL;

        Assert(m_fInited);
        Assert(pMTACallback);

        HRESULT hr = E_FAIL;
        DWORD   eventSignaled;

        EnterCriticalSection(&m_csLock);

        Assert(m_pMTACallback == NULL);
        m_pMTACallback = pMTACallback;
        m_pvContext  = pvContext;
        m_pvContext2 = pvContext2;
        m_hrResult   = E_FAIL;

        // Tell MTA thread to call back
        SetEvent(m_hDoItEvent);

        // Wait till done
        CoWaitForMultipleHandles(0,
                                 INFINITE,
                                 1,
                                 &m_hDoneEvent,
                                 &eventSignaled);

        // remember HRESULT
        hr = m_hrResult;

        // to make sure we never do it twice
        m_pMTACallback = NULL;

        LeaveCriticalSection(&m_csLock);
        return hr;
        }
    };

// Sole instance of the above
static CMTACallbackThread g_MTACallbackThread;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitMTACallbacks

To be called from DllInit()
Inits the MTA callback processing
Launches the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMTACallbacks()
    {
    return g_MTACallbackThread.Init();
    }

/*===================================================================
UnInitMTACallbacks

To be called from DllUnInit()
Stops the MTA callback processing
Kills the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMTACallbacks()
    {
    return g_MTACallbackThread.UnInit();
    }

/*===================================================================
CallMTACallback

Calls the hack.

Parameters
    PMTACALLBACK  pMTACallback       call this function
    void         *pvContext          pass this to it
    void         *pvContext2         extra arg

Returns:
    HRESULT
===================================================================*/
HRESULT CallMTACallback
(
PMTACALLBACK pMTACallback,
void        *pvContext,
void        *pvContext2
)
    {
    return g_MTACallbackThread.CallCallback
        (
        pMTACallback,
        pvContext,
        pvContext2
        );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\mtacb.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.h

Owner: DmitryR

This file contains the definitons for MTA Callback
===================================================================*/

#ifndef MTACALLBACK_H
#define MTACALLBACK_H

// To be called from DllInit()
HRESULT InitMTACallbacks();

// To be called from DllUnInit()
HRESULT UnInitMTACallbacks();

// The callback function to be called from an MTA thread
typedef HRESULT (__stdcall *PMTACALLBACK)(void *, void *);

HRESULT CallMTACallback
    (
    PMTACALLBACK pMTACallback,          // call this function
    void        *pvContext,             // pass this to it
    void        *pvContext2             // extra arg
    );

#endif // MTACALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\memchk.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.cpp

Owner: PramodD

TODO: restore the IIS5 debug heap wrappers

This is the Memory Manager source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

HANDLE g_hDenaliHeap = NULL;

/*===================================================================
int ::DenaliMemIsValid

Global function which validates an allocated memory pointer

Parameters:
	NONE

Returns:
	1		Valid pointer
	0		Invalid pointer
===================================================================*/
int DenaliMemIsValid( void * pvIn )
{
    return 1;
}

/*===================================================================
::DenaliMemInit

Initializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	S_OK on success
===================================================================*/
HRESULT DenaliMemInit( const char *szFile, int lineno )
{

    g_hDenaliHeap = ::HeapCreate( 0, 0, 0 );

	return g_hDenaliHeap ? S_OK : E_OUTOFMEMORY;
}

/*===================================================================
void ::DenaliMemUnInit

Uninitializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemUnInit( const char *szFile, int lineno )
{
    if (g_hDenaliHeap)
    {
        ::HeapDestroy(g_hDenaliHeap);
        g_hDenaliHeap = NULL;
    }
}

/*===================================================================
void ::DenaliLogCall

Writes source file and line number for log message to log file

Parameters:
	const char *	szLog		Log message
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliLogCall( const char * szLog, const char *szFile, int lineno )
{
    return;
}

/*===================================================================
void ::DenaliMemDiagnostics

Diagnostics for the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemDiagnostics( const char *szFile, int lineno )
{
    return;
}


/*===================================================================
void * ::DenaliMemAlloc

Allocates a block of memory.

Parameters:
	size_t			cSize		Size in bytes to be allocated
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemAlloc( size_t cSize, const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, 0, cSize );
}

/*===================================================================
void ::DenaliMemFree

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer to free
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void DenaliMemFree( void * pIn, const char *szFile, int lineno )
{
    ::HeapFree( g_hDenaliHeap, 0, pIn );
}


/*===================================================================
void * ::DenaliMemCalloc

Allocates and clears a block of memory.

Parameters:
	size_t			cNum		Number of elements to be allocated
	size_t			cbSize		Size in bytes of each element
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemCalloc(size_t cNum, size_t cbSize,
                       const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, HEAP_ZERO_MEMORY, cNum * cbSize );
}


/*===================================================================
void ::DenaliMemReAlloc

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer memory to ReAllocate
	size_t			cSize		Number of bytes to allocate
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	Pointer to allocated block
===================================================================*/
void * DenaliMemReAlloc( void * pIn, size_t cSize, const char *szFile, int lineno )
{
    return ::HeapReAlloc( g_hDenaliHeap, 0, pIn, cSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\perfdata.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.cpp

Owner: DmitryR

PERFMON related data in asp.dll -- source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

// to access metabase
#include <iiscnfg.h>
#include <iwamreg.h>

#ifndef PERF_DISABLE

BOOL g_fPerfInited = FALSE;
CPerfMainBlock g_PerfMain;
CPerfData      g_PerfData;

/*===================================================================
GetCurrentClsId

Static function to find the current WAM CLSID in the metabase

Parameters
    pIReq            to retrieve WAM CLSID from the metabase
    pClsId          [out] CLSID

Returns:
    HRESULT
===================================================================*/
static HRESULT GetCurrentClsId
(
CIsapiReqInfo   *pIReq,
CLSID *pClsId
)
    {
    HRESULT hr = S_OK;

    Assert(pClsId);

    TCHAR *szMDPath = pIReq->QueryPszApplnMDPath();
    if (!szMDPath)
        {
        *pClsId = CLSID_NULL;
        return E_FAIL;
        }

    CLSID ClsId = CLSID_NULL;



    WCHAR wszClsBuffer[80];
    DWORD dwRequiredLen, dwAppMode;
    // Find the application mode, inproc, out-of-proc, or pooled OOP
    hr = pIReq->GetAspMDData(szMDPath,
                                 MD_APP_ISOLATED,
                                 METADATA_INHERIT,
                                 IIS_MD_UT_WAM,
                                 DWORD_METADATA,
                                 sizeof(DWORD),
                                 0,
                                 (unsigned char*) &dwAppMode,
                                 &dwRequiredLen);
    if (SUCCEEDED(hr))
    {
        switch (dwAppMode)
        {
            case eAppRunInProc:
                // preconfigured WAM CLSID for all inproc apps
                wcscpy(wszClsBuffer,
                       L"{99169CB0-A707-11d0-989D-00C04FD919C1}");
                break;
            case eAppRunOutProcIsolated:
                // custom WAM CLSID for non-pooled OOP apps
                hr = pIReq->GetAspMDData(szMDPath,
                                         MD_APP_WAM_CLSID,
                                         METADATA_INHERIT,
                                         IIS_MD_UT_WAM,
                                         STRING_METADATA,
                                         sizeof(wszClsBuffer) / sizeof(WCHAR),
                                         0,
                                         (unsigned char *)wszClsBuffer,
                                         &dwRequiredLen);
                break;
            case eAppRunOutProcInDefaultPool:
                // preconfigured WAM CLSID for the pooled OOP apps
                wcscpy(wszClsBuffer,
                       L"{3D14228D-FBE1-11d0-995D-00C04FD919C1}");
                break;
            default:
                Assert(!"unknown AppMode");
                hr = E_FAIL;
                break;
        }
    }
                            
    if (SUCCEEDED(hr))
    {
        // Convert string to CLSID
    	hr = CLSIDFromString(wszClsBuffer, &ClsId);
    }

    if (SUCCEEDED(hr) && g_fOOP) // always CLSID_NULL if inproc
        *pClsId = ClsId;
    else
        *pClsId = CLSID_NULL;
    
    return hr;
    }

/*===================================================================
PreInitPerfData

Initialize from DllInit
Creates critical sections

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT PreInitPerfData()
    {
    HRESULT hr = S_OK;

    hr = g_PerfData.InitCriticalSections();

    return hr;
    }

/*===================================================================
InitPerfDataOnFirstRequest

Initialize PERFMON related ASP data from first request

Parameters
    pIReq    to retrieve WAM CLSID from the metabase

Returns:
    HRESULT
===================================================================*/
HRESULT InitPerfDataOnFirstRequest
(
CIsapiReqInfo   *pIReq
)
    {
    // access main shared memory
    HRESULT hr = g_PerfMain.Init();

    // access shared memory of this process
    if (SUCCEEDED(hr))
        hr = g_PerfData.Init(GetCurrentProcessId());

    // add this process data to main shared memory
    if (SUCCEEDED(hr))
        hr = g_PerfMain.AddProcess(GetCurrentProcessId());

    if (FAILED(hr))
        {
        g_PerfData.UnInit();
        g_PerfMain.UnInit();
        }

    return hr;
    }

/*===================================================================
UnInitPerfData

UnInitialize PERFMON related ASP data

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitPerfData()
    {
    // stop accessing process shared memory
    g_PerfData.UnInit();
    
    // stop accessing main shared memory
    g_PerfMain.UnInit();

    return S_OK;
    }

/*===================================================================
UnPreInitPerfData

Un-Initialize from DllInit
Creates critical sections

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnPreInitPerfData()
    {
    HRESULT hr = S_OK;

    hr = g_PerfData.UnInitCriticalSections();

    return hr;
    }


#endif  // PERF_DISABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\perfdata.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.h

Owner: DmitryR

PERFMON related data in asp.dll -- header file
===================================================================*/

#ifndef _ASP_PERFDATA_H
#define _ASP_PERFDATA_H

#ifndef PERF_DISABLE

#include "asppdef.h"
#ifndef _ASP_DEBUG_EXT
#include "denali.h"
#endif


/*===================================================================
CPerfData -- PERFMON data for ASP
             CPerfProcBlock 
                + macros to update counters
                + clsid to remember
                + place to update counters before perfmon inited
===================================================================*/

class CPerfData : public CPerfProcBlock
    {
private:
    // Initial counter values (gathered when uninit)
    DWORD m_rgdwInitCounters[C_PERF_PROC_COUNTERS];
    // CLSID
    DWORD m_fValid : 1;
    DWORD m_dwProcId;

public:
    inline CPerfData() 
        : m_fValid(FALSE)
        {
        memset(m_rgdwInitCounters, 0, CB_COUNTERS);
        }

    inline ~CPerfData()
        {
        }

    inline HRESULT Init(DWORD   procId)
        {
        HRESULT hr = InitForThisProcess(procId, m_rgdwInitCounters);
        if (SUCCEEDED(hr))
            {
            m_dwProcId = procId;
            m_fValid = TRUE;
            }
        return hr;
        }

    inline HRESULT UnInit()
        {
        m_fValid = FALSE;
        return CPerfProcBlock::UnInit();
        }

    inline BOOL FValid()
        {
        return m_fValid;
        }

    inline const DWORD ProcId()
        {
        return m_dwProcId;
        }

    // helper inline to get counter address as DWORD *
    inline DWORD *PDWCounter(int i)
        {
        return m_fInited ? &(m_pData->m_rgdwCounters[i])
                         : &(m_rgdwInitCounters[i]);
        }
    
    // helper inline to get counter address as LPLONG
    inline LPLONG PLCounter(int i)
        {
        return (LPLONG)PDWCounter(i);
        }

    // Inlines to change individual counters --------------

    inline void Incr_DEBUGDOCREQ()
        {
        InterlockedIncrement(PLCounter(ID_DEBUGDOCREQ));
        }
    inline void Incr_REQERRRUNTIME()
        {
        InterlockedIncrement(PLCounter(ID_REQERRRUNTIME));
        }
    inline void Incr_REQERRPREPROC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRPREPROC));
        }
    inline void Incr_REQERRCOMPILE()
        {
        InterlockedIncrement(PLCounter(ID_REQERRCOMPILE));
        }
    inline void Incr_REQERRORPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRORPERSEC));
        }
    inline void Add_REQTOTALBYTEIN(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEIN) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Add_REQTOTALBYTEOUT(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEOUT) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Set_REQEXECTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQEXECTIME), (LONG)dw);
        }
    inline void Set_REQWAITTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQWAITTIME), (LONG)dw);
        }
    inline void Incr_REQCOMFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQCOMFAILED));
        }
    inline void Incr_REQBROWSEREXEC()
        {
        InterlockedIncrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Decr_REQBROWSEREXEC()
        {
        InterlockedDecrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Incr_REQFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQFAILED));
        }
    inline void Incr_REQNOTAUTH()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTAUTH));
        }
    inline void Incr_REQNOTFOUND()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTFOUND));
        }
    inline DWORD Incr_REQCURRENT()
        {
        return InterlockedIncrement(PLCounter(ID_REQCURRENT));
        }
    inline void Decr_REQCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_REQCURRENT));
        }
    inline void Incr_REQREJECTED()
        {
        InterlockedIncrement(PLCounter(ID_REQREJECTED));
        }
    inline void Incr_REQSUCCEEDED()
        {
        InterlockedIncrement(PLCounter(ID_REQSUCCEEDED));
        }
    inline void Incr_REQTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_REQTIMEOUT));
        }
    inline DWORD Incr_REQTOTAL()
        {
        return((DWORD)InterlockedIncrement(PLCounter(ID_REQTOTAL)));
        }
    inline void Incr_REQPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQPERSEC));
        }
    inline void Incr_SCRIPTFREEENG()
        {
        InterlockedIncrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Decr_SCRIPTFREEENG()
        {
        InterlockedDecrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Set_SESSIONLIFETIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_SESSIONLIFETIME), (LONG)dw);
        }
    inline void Incr_SESSIONCURRENT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Decr_SESSIONCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Incr_SESSIONTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONTIMEOUT));
        }
    inline void Incr_SESSIONSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONSTOTAL));
        }
    inline void Incr_TEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Decr_TEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Zero_TEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_TEMPLCACHE), 0);
        }
    inline void Incr_TEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHEHITS));
        }
    inline void Incr_TEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHETRYS));
        }
    inline void Incr_MEMORYTEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Decr_MEMORYTEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Zero_MEMORYTEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_MEMORYTEMPLCACHE), 0);
        }
    inline void Incr_MEMORYTEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHEHITS));
        }
    inline void Incr_MEMORYTEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHETRYS));
        }
    inline void Incr_TEMPLFLUSHES()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLFLUSHES));
        }
    inline void Incr_TRANSABORTED()
        {
        InterlockedIncrement(PLCounter(ID_TRANSABORTED));
        }
    inline void Incr_TRANSCOMMIT()
        {
        InterlockedIncrement(PLCounter(ID_TRANSCOMMIT));
        }
    inline void Incr_TRANSPENDING()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Decr_TRANSPENDING()
        {
        InterlockedDecrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Incr_TRANSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_TRANSTOTAL));
        }
    inline void Incr_TRANSPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPERSEC));
        }
    inline void Incr_ENGINECACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_ENGINECACHEHITS));
        }
    inline void Incr_ENGINECACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_ENGINECACHETRYS));
        }
    inline void Incr_ENGINEFLUSHES()
        {
        InterlockedIncrement(PLCounter(ID_ENGINEFLUSHES));
        }

    };

#ifndef _ASP_DEBUG_EXT

// We init PERFMON data on first request
extern BOOL g_fPerfInited;

// Object to access main shared PERFMON memory
extern CPerfMainBlock g_PerfMain;

// Object to access shared memory (incl. counters) for this process
extern CPerfData g_PerfData;

HRESULT PreInitPerfData();

HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq);

HRESULT UnInitPerfData();
HRESULT UnPreInitPerfData();

#endif  // _ASP_DEBUG_EXT

#else

#ifndef _ASP_DEBUG_EXT

inline HRESULT PreInitPerfData()
    {
    return S_OK;
    }

inline HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq) 
    {
    return S_OK; 
    }

inline HRESULT UnInitPerfData()
    {
    return S_OK; 
    }

inline HRESULT UnPreInitPerfData()
    {
    return S_OK; 
    }

#endif  // _ASP_DEBUG_EXT

#endif  // PERF_DISABLE

#endif // _ASP_PERFDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\randgen.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.cpp

Owner: DmitryR

This file contains the implementation of the random number
generator.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "randgen.h"
#include "memchk.h"

/*===================================================================
  Random DWORD using rand()
===================================================================*/
#define RAND_DWORD()  (((rand() & 0xffff) << 16) | (rand() & 0xffff))

/*===================================================================
  Random number generator class
===================================================================*/
class CRandomGenerator
    {
private:
    DWORD m_fInited   : 1;  // inited?
    DWORD m_fCSInited : 1;  // critical section inited?

    HCRYPTPROV        m_hCryptProvider;     // crypt provider
    CRITICAL_SECTION  m_csLock;             // critical section

    DWORD m_cItems;     // number of items in the array
    DWORD *m_pdwItems;  // pointer to the array of random DWORDs
    DWORD m_iItem;      // next random item index

public:
    CRandomGenerator()
        :
        m_fInited(FALSE),
        m_fCSInited(FALSE),
        m_hCryptProvider(NULL),
        m_cItems(0),
        m_pdwItems(NULL),
        m_iItem(0)
        {
        }
        
    ~CRandomGenerator()
        {
        UnInit();
        }

    HRESULT Init(DWORD cItems = 128)
        {
        Assert(!m_fInited);
        
        m_hCryptProvider = NULL;
        
        if (cItems > 0)
            {
            CryptAcquireContext
                (
                &m_hCryptProvider, 
                NULL,
                NULL, 
                PROV_RSA_FULL, 
                CRYPT_VERIFYCONTEXT
                );
            }

        if (!m_hCryptProvider)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

        HRESULT hr;
        ErrInitCriticalSection(&m_csLock, hr);
      	if (FAILED(hr))
      	    return hr;
      	m_fCSInited = TRUE;

      	m_pdwItems = new DWORD[cItems];
      	if (!m_pdwItems)
      	    return E_OUTOFMEMORY;
      	m_cItems = cItems;
      	m_iItem  = cItems;  // to start with new chunk

        m_fInited = TRUE;
        return S_OK;
        }

    HRESULT UnInit()
        {
        if (m_hCryptProvider)
            {
            CryptReleaseContext(m_hCryptProvider, 0);
            m_hCryptProvider = NULL;
            }

        if (m_fCSInited)
            {
     		DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }
        
        if (m_pdwItems)
            {
            delete [] m_pdwItems;
            m_pdwItems = NULL;
            }
        m_cItems = 0;
        m_iItem = 0;

        m_fInited = FALSE;
        return S_OK;
        }

    HRESULT Generate(DWORD *pdwDwords, DWORD cDwords)
        {
        Assert(pdwDwords);
        Assert(cDwords > 0);
        
        Assert(m_fInited);

        DWORD i;
        
        // use CryptGenRandom

        Assert(cDwords <= m_cItems); // requested # of items < m_cItems
        Assert(m_fCSInited);
            
        EnterCriticalSection(&m_csLock);

        if (m_iItem+cDwords-1 >= m_cItems)
            {
            
            BOOL fSucceeded = CryptGenRandom
                (
                m_hCryptProvider, 
                m_cItems * sizeof(DWORD),
                reinterpret_cast<BYTE *>(m_pdwItems)
                );

            if (!fSucceeded)
                {
                // Failed -> Dont use rand() instead throw an error.

                // Unlock, else it will result in a deadlock. NT raid 530674
                LeaveCriticalSection (&m_csLock);
                
                return HRESULT_FROM_WIN32(GetLastError());
                }

            m_iItem = 0; // start over
            }

        for (i = 0; i < cDwords; i++)
            pdwDwords[i] = m_pdwItems[m_iItem++];
        
        LeaveCriticalSection(&m_csLock);

        return S_OK;
        }
    };

// Pointer to the sole instance of the above
static CRandomGenerator *gs_pRandomGenerator = NULL;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitRandGenerator

To be called from DllInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitRandGenerator()
    {
    gs_pRandomGenerator = new CRandomGenerator;
    if (!gs_pRandomGenerator)
        return E_OUTOFMEMORY;

    return gs_pRandomGenerator->Init();
    }

/*===================================================================
UnInitRandGenerator

To be called from DllUnInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitRandGenerator()
    {
    if (gs_pRandomGenerator)
        {
        gs_pRandomGenerator->UnInit();
        delete gs_pRandomGenerator;
        }
    return S_OK;
    }

/*===================================================================
GenerateRandomDword

Returns random DWORD

Parameters

Returns:
    Random number
===================================================================*/
DWORD GenerateRandomDword()
    {
    DWORD dw = 0;
    Assert(gs_pRandomGenerator);
    gs_pRandomGenerator->Generate(&dw, 1);
    return dw;
    }

/*===================================================================
GenerateRandomDwords

Returns random DWORDs

Parameters
    pdwDwords     array of DWORDs to fill
    cDwords       # of DWORDs

Returns:
    Random number
===================================================================*/
HRESULT GenerateRandomDwords
(
DWORD *pdwDwords, 
DWORD  cDwords
)
    {
    Assert(gs_pRandomGenerator);
    return gs_pRandomGenerator->Generate(pdwDwords, cDwords);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\randgen.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.h

Owner: DmitryR

This file contains the definitons for the random number
generator.
===================================================================*/

#ifndef RANDGEN_H
#define RANDGEN_H

// To be called from DllInit()
HRESULT InitRandGenerator();

// To be called from DllUnInit()
HRESULT UnInitRandGenerator();

// The generator funcions
DWORD GenerateRandomDword();
HRESULT GenerateRandomDwords(DWORD *pdwDwords, DWORD cDwords);

#endif // RANDGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\request.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request object

File: Request.h

Owner: CGrant, DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Request_H
#define _Request_H

#include "debug.h"
#include "util.h"
#include "hashing.h"
#include "dispatch.h"
#include "strlist.h"
#include "asptlb.h"
#include "response.h"
#include "memcls.h" 

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

class CCookie;
class CClCert;
class CRequestHit;
class CServVarsIterator;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

enum CollectionType {NONE, SERVERVARIABLE, QUERYSTRING, FORM, COOKIE, CLCERT };
enum FormDataStatus {AVAILABLE, BINARYREADONLY, FORMCOLLECTIONONLY, ISTREAMONLY};

class CRequest;

#define	NUM_REQUEST_HITS 32

/*
 * C R e q u e s t H i t s A r r a y
 *
 * Base class for:
 *      CQueryString
 *      CFormInputs
 *      CCookies
 *      CClCerts
 *
 * Implements self-reallocating array of CRequestHit 
 */

class CRequestHitsArray
    {
protected:    
	DWORD			m_dwCount;			// How many Request hits there are
	DWORD			m_dwHitMax;			// Number of slots available to store Request hits
	CRequestHit**	m_rgRequestHit;		// Array of Request hits

    CRequestHitsArray();
    ~CRequestHitsArray();

    inline HRESULT Init()
        {
        m_dwCount = 0;
        m_dwHitMax = 0;
        m_rgRequestHit = NULL;
        return S_OK;
        }
        
    inline HRESULT ReInit() 
        {
        m_dwCount = 0; 
        return S_OK;
        }

public:
	BOOL AddRequestHit(CRequestHit *pHit);
	
    };

/*
 * C Q u e r y S t r i n g
 *
 * Implements the QueryString object (interface derived from IRequestDictionary)
 */

class CQueryString : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CQueryString(CRequest *, IUnknown *);

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	HRESULT			Init();
	HRESULT         ReInit();

	~CQueryString();
	};
 


/*
 * C S e r v e r V a r i a b l e s
 *
 * Implements the ServerVariables object (interface derived from IRequestDictionary)
 */

class CServerVariables : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CServVarsIterator *	m_pIterator;		// we use an iterator to support integer index

public:
	CServerVariables(CRequest *, IUnknown *);
	HRESULT Init()
		{
		return S_OK;
		}

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// We've added a destructor, but didn't want to change the
	// order of the existing vtbl entries.
	~CServerVariables();
	};


/*
 * C F o r m I n p u t s
 *
 * Implements the Form object (interface derived from IRequestDictionary)
 */

class CFormInputs : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CFormInputs(CRequest *, IUnknown *);
	HRESULT Init();
	HRESULT ReInit();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	~CFormInputs();
	};
 

/*
 * C C o o k i e s
 *
 * Implements the Cookies object (interface derived from IRequestDictionary)
 */

class CCookies : public IRequestDictionaryImpl, public CRequestHitsArray
	{
friend CResponseCookies;
	
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CCookie *			m_pEmptyCookie;		// for when the cookie is not there

public:
	CCookies(CRequest *, IUnknown *);
	~CCookies();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
   	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};
 


/*
 * C C l C e r t s
 *
 * Implements the ClCerts object (interface derived from IRequestDictionary)
 */

class CClCerts : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CClCert *			m_pEmptyClCert;		// for when the clcert is not there

public:
	CClCerts(CRequest *, IUnknown *);
	~CClCerts();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};


/*
 * C R e q u e s t H i t
 *
 * Implements the RequestHit object
 */

class CRequestHit : private CLinkElem
	{
friend class CRequest;
friend class CRequestData;
friend class CQueryString;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CCertRequest;
friend class CResponseCookies;
friend class CRequestIterator;

private:
	BOOL			m_fInited:1;
	BOOL			m_fDuplicate:1;
	CStringList		*m_pQueryData, *m_pFormData;
	CCookie			*m_pCookieData;
	CClCert			*m_pClCertData;

public:
	CRequestHit();
	~CRequestHit();

	HRESULT Init(char *szName, BOOL fDuplicate = FALSE);
	HRESULT AddValue(CollectionType source, char *szValue, CIsapiReqInfo *, UINT lCodePage);
    HRESULT AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen );
	HRESULT AddKeyAndValue(CollectionType source, char *szKey, char *szValue, CIsapiReqInfo *, UINT lCodePage);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*
 * C R e q u e s t D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CRequestData : public IUnknown
    {
friend class CRequest;
friend class CResponse;
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // constructor to pass params to members and init members
    CRequestData(CRequest *pRequest);
    ~CRequestData();

    HRESULT Init();
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

	HRESULT GetEmptyStringList(IDispatch **ppdisp);

	
	CSupportErrorInfo		m_ISupportErrImp;	// Implementation of ISupportErrorInfo for this object
	CIsapiReqInfo *         m_pIReq;			    // CIsapiReqInfo block for HTTP info
	CHitObj	*				m_pHitObj;			// pointer to hitobj for this request
	CHashTableMBStr			m_mpszStrings;		// map sz's to string lists
	BOOL					m_fLoadForm:1;		// do we need to load the body?
	BOOL					m_fLoadQuery:1;		// do we need to load QueryString?
	BOOL					m_fLoadCookies:1;	// do we need to load Cookies?
	BOOL					m_fLoadClCerts:1;	// do we need to load ClCerts?
	FormDataStatus			m_FormDataStatus;	// Is form data available for BinaryRead or Form Collection?
	BYTE *					m_pbAvailableData;	// pointer to available data in CIsapiReqInfo
	size_t					m_cbAvailable;		// number of bytes available in CIsapiReqInfo
	size_t					m_cbTotal;			// Total number of bytes remaining in request
	char *					m_szFormData;		// pointer to form data (allocted or CIsapiReqInfo)
	size_t					m_cbFormData;		// number of bytes allocated for form data
	char *					m_szFormClone;		// clone of form data (LoadVariables clobbers)
	char *					m_szCookie;			// clone of cookie data (this one gets trashed)
	size_t					m_cbCookie;			// number of bytes allocated for the cookie data
	char *					m_szClCert;			// clone of clcert data (this one gets trashed)
	size_t					m_cbClCert;			// number of bytes allocated for the clcert data
    char *                  m_szQueryString;    // query string data
	CStringList *			m_pEmptyString;		// all empty results share the same object
	CQueryString			m_QueryString;		// pointer to the "QueryString" object
	CServerVariables		m_ServerVariables;	// pointer to the "ServerVariables" object
	CFormInputs				m_FormInputs;		// pointer to the "Form" object
	CCookies				m_Cookies;			// pointer to the "Cookies" object
	CClCerts    			m_ClCerts;			// pointer to the "ClCert" object
	ULONG                   m_cRefs;            // ref count

public:
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    DWORD  GetRequestEntityLimit();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

  
/*
 * C R e q u e s t
 *
 * Implements the Request object
 */
class CRequest : public IRequestImpl, public IStream
	{
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CRequestData *m_pData;   // pointer to structure that holds
                             // CRequest properties

    // FTM support
    IUnknown    *m_pUnkFTM;

    UINT GetCodePage();

	HRESULT LoadVariables(CollectionType Source, char *szURL, UINT lCodePage);
	HRESULT LoadCookies(char *szCookies);
	HRESULT LoadClCerts(char *szClCerts, UINT lCodePage);

	HRESULT LoadCertList( LPSTR pszPrefix, LPSTR* pszCertList);
	HRESULT CopyClientData();
    HRESULT GetRequestEnumerator(CollectionType, IUnknown **ppEnumReturn);

    // Added support for chunked Transfer in Request.form  
    HRESULT CopyChunkedClientData();
    HRESULT CopyNonChunkedClientData();	    

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CRequest(IUnknown *punkOuter = NULL);
	~CRequest();

    HRESULT CleanUp();
    HRESULT Init();
    HRESULT UnInit();
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);
	
    inline CIsapiReqInfo *GetIReq()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_pIReq;
        }
        
    inline CLinkElem* CertStoreFindElem(LPSTR pV, int cV)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.FindElem( pV, cV );
        }
        
    inline CLinkElem* CertStoreAddElem(CLinkElem* pH)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.AddElem( pH ); 
        }
        
    inline LPSTR GetCertStoreBuf()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_szClCert; 
        }
        
    inline size_t GetCertStoreSize()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_cbClCert; 
        }
        
    inline void SetCertStore(LPSTR p, size_t s)
        {
        Assert(m_fInited);
        Assert(m_pData);
        m_pData->m_szClCert = p;
        m_pData->m_cbClCert = s;
        }

    inline CHashTable *GetStrings()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return &(m_pData->m_mpszStrings);
        }

	// Non-delegating object IUnknown
	//
	STDMETHODIMP		 QueryInterface(const IID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();
	
	// IRequest functions
	//
	STDMETHODIMP	get_Item(BSTR bstrVar, IDispatch **ppDispReturn);
	STDMETHODIMP	get_QueryString(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Form(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Body(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ServerVariables(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ClientCertificate(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_TotalBytes(long *pcbTotal);
	STDMETHODIMP	BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
ITERATORS:

There are two iterators used for Request - a general purpose
iterator which will iterate through the keys of Cookies, QueryString,
Form.  A special iterator is used for ServerVariables
===================================================================*/

/*
 * C S e r v V a r s I t e r a t o r
 *
 * IEnumVariant implementation for Request.ServerVariables
 */

class CServVarsIterator : public IEnumVARIANT
	{
friend CServerVariables;
	
public:
	CServVarsIterator();
	~CServVarsIterator();

	HRESULT Init(CIsapiReqInfo *pIReq);


	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	wchar_t **m_rgwszKeys;			// array of ISAPI keys
	wchar_t **m_pwszKey;			// current key in gm_rgwszKeys
	wchar_t *m_pwchAllHttp;			// extra keys in ALL_HTTP server variable
	ULONG	m_cKeys;				// total number of keys

	BOOL CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders);
	};


/*
 * C R e q u e s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CRequestIterator : public IEnumVARIANT
	{
public:
	CRequestIterator(CRequest *, CollectionType);
	~CRequestIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CollectionType m_Collection;	// which collection to iterate over?
	CRequest *m_pRequest;			// pointer to the request object
	CRequestHit *m_pRequestHit;		// current bookmark for iteration
	};

BOOL RequestSupportInit();
VOID RequestSupportTerminate();

#endif //_Request_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\response.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.h

Owner: CGrant

This file contains the header info for defining the Response object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _RESPONSE_H
#define _RESPONSE_H

#include "debug.h"
#include "util.h"
#include "template.h"
#include "disptch2.h"
#include "hashing.h"
#include "memcls.h"

const DWORD RESPONSE_BUFFER_SIZE = 2048;
const DWORD BUFFERS_INCREMENT = 256;
const DWORD ALLOCA_LIMIT = 4096;
const DWORD MAX_RESPONSE = 32768;
const DWORD MAX_MESSAGE_LENGTH = 512;
const DWORD RESPONSE_VECTOR_INTRINSIC_SIZE = 128;
const DWORD RESPONSE_VECTOR_INITIAL_ALLOC = 512;
const DWORD RESPONSE_VECTOR_REALLOC_FACTOR = 2;
// the minimum HTML block that is worth referingin the template rather than copying
// to the response buffer is roughly 6 times the size of a VectorSend element. This is
// because each such reference introduces two vector elements (the reference, and the one
// to the response buffer to follow), and during the system call, 2 additional copies are
// allocated. This evals out 6*24=144 bytes
// BUGBUG: might want to change to save long term mem on the expense of short term allocations
const DWORD MAX_HTML_IN_RESPONSE_BUFFER = 6*sizeof(HSE_VECTOR_ELEMENT);

typedef struct
{
    LONG DynamicBlocks;
    LONG ZeroSizeBlocks;
    LONG TotalCopiedHTMLBytes;
    LONG TotalReferencedHTMLBytes;
    LONG HTML16;
    LONG HTML32;
    LONG HTML48;
    LONG HTML64;
    LONG HTML128;
    LONG HTML256;
    LONG HTML512;
    LONG HTML1024;
    LONG HTML2048;
    LONG HTML4096;
    LONG HTML8192;
    LONG HTML16384;
    LONG HTMLbig;
    LONG Vect8;
    LONG Vect16;
    LONG Vect32;
    LONG Vect64;
    LONG Vect96;
    LONG Vect128;
    LONG Vect192;
    LONG Vect256;
    LONG Vect512;
    LONG Vect1024;
    LONG Vect2048;
    LONG Vect4096;
    LONG VectBig;
} ResponseVectorStatistics;

extern ResponseVectorStatistics sRespVecStats;

class CScriptEngine;

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

// fixed size allocator for response buffers
ACACHE_FSA_EXTERN(ResponseBuffer)

// forward refs
class CResponse;
class CRequest;

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//Type for the "Get Active Script Engine" callback
typedef CScriptEngine *(*PFNGETSCRIPT)(int iScriptEngine, void *pvContext);

/*
 * C H T T P H e a d e r L i n k
 *
 */

class CHTTPHeader
	{
private:
    DWORD m_fInited : 1;
    DWORD m_fNameAllocated : 1;
    DWORD m_fValueAllocated : 1;

	char *m_szName;
	char *m_szValue;
	
    DWORD m_cchName;
    DWORD m_cchValue;

    CHTTPHeader *m_pNext;

	char m_rgchLtoaBuffer[20];  // enough for atol

public:
	CHTTPHeader();
	~CHTTPHeader();

	HRESULT InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, char *szValue, BOOL fCopyValue);
	HRESULT InitHeader(char *szName, long lValue);

	char *PSzName();
	char *PSzValue();
	DWORD CchLength();
	
	void  Print(char *szBuf);

	void  SetNext(CHTTPHeader *pHeader);
	CHTTPHeader *PNext();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

// CHTTPHeader inlines

inline char *CHTTPHeader::PSzName()
    {
    Assert(m_fInited);
    return m_szName;
    }

inline char *CHTTPHeader::PSzValue()
    {
    Assert(m_fInited);
    return m_szValue;
    }
	
inline DWORD CHTTPHeader::CchLength()
    {
    Assert(m_fInited);
    return (m_cchName + m_cchValue + 4); // account for ": " and "\r\n"
    }

inline void CHTTPHeader::SetNext(CHTTPHeader *pHeader)
    {
    Assert(m_fInited);
    Assert(!m_pNext);
    m_pNext = pHeader;
    }

inline CHTTPHeader *CHTTPHeader::PNext()
    {
    return m_pNext;
    }

/*
 * C R e s p o n s e V e c t o r
 *
 */

class CResponseVector
{
    LPWSABUF   m_pExtVector;         // Pointer to auxilary vector
    DWORD      m_cExtVectorSize;     // Size of auxilary vector
    DWORD      m_iCurrentEntry;      // Logical index of current entry
    BOOL       m_fEntryIsOpen:1;     // Can we add to current entry?
    DWORD      m_cchTotalBuffered;   // Total of ouput bytes buffered
    WSABUF     m_aVector0[ RESPONSE_VECTOR_INTRINSIC_SIZE ]; // Pre-allocated vector

    HRESULT GrowVector();
    BOOL IsEntryOpen();
    LPWSABUF GetEntry( UINT i);
    DWORD GetEntryCount();

public:
    CResponseVector();
    ~CResponseVector();
    VOID Clear();
    HRESULT Append( char * pData, DWORD cbSize);
    HRESULT Insert( char * pData, DWORD cbSize);
    VOID Close();
    VOID GetVectors( LPWSABUF_VECTORS pWsabuf);
    DWORD BytesBuffered();
};

inline BOOL CResponseVector::IsEntryOpen()
{
    return m_fEntryIsOpen;
}

inline LPWSABUF CResponseVector::GetEntry(UINT i)
{
    return (i < RESPONSE_VECTOR_INTRINSIC_SIZE) ?
             &m_aVector0[i] : m_pExtVector + i - RESPONSE_VECTOR_INTRINSIC_SIZE;
}

inline DWORD CResponseVector::GetEntryCount()
{
    return IsEntryOpen() ? m_iCurrentEntry + 1 : m_iCurrentEntry;
}

inline VOID CResponseVector::GetVectors( LPWSABUF_VECTORS pWsabuf)
{
    DWORD iEntries = GetEntryCount();
    if (iEntries > RESPONSE_VECTOR_INTRINSIC_SIZE)
    {
        pWsabuf->pVector1 = m_aVector0;
        pWsabuf->dwVectorLen1 = RESPONSE_VECTOR_INTRINSIC_SIZE;
        pWsabuf->pVector2 = m_pExtVector;
        pWsabuf->dwVectorLen2 = iEntries - RESPONSE_VECTOR_INTRINSIC_SIZE;
    }
    else
    {
        if (iEntries > 0)
        {
            pWsabuf->pVector1 = m_aVector0;
            pWsabuf->dwVectorLen1 = iEntries;
        }
        else
        {
            pWsabuf->pVector1 = NULL;
            pWsabuf->dwVectorLen1 = 0;
        }

        pWsabuf->pVector2 = NULL;
        pWsabuf->dwVectorLen2 = 0;
    }
}

inline DWORD CResponseVector::BytesBuffered()
{
    return m_cchTotalBuffered;
}

// marks the current entry as closed, so that subsequent Append() will create a new entry
inline VOID CResponseVector::Close()
{
    if (IsEntryOpen())
    {
        m_fEntryIsOpen = FALSE;
        m_iCurrentEntry++;
    }
}

// Create a new entry: close current, append, and close new entry
inline HRESULT CResponseVector::Insert(char * pData, DWORD cbSize)
{
    HRESULT hr;
    Close();
    hr = Append(pData, cbSize);
    Close();
    return hr;
}

class CResponseBufferSet;

/*
 * C R e s p o n s e B u f f e r
 *
 */

class CResponseBuffer
	{
	CResponseBufferSet*	m_pBufferSet;				// Pointer to BufferSet for this object
	CResponseVector 	m_ResponseVector;			// Response vector object
	char				**m_rgpchBuffers;			// Array of pointers to buffers
	char                *m_pchBuffer0;              // In case of 1 element array of pointers
	DWORD				m_cBufferPointers;			// Count of buffer pointers
	DWORD				m_cBuffers;					// Count of buffers we have allocated
	DWORD				m_iCurrentBuffer;			// Array index for the buffer we are currently filling
	DWORD				m_cchOffsetInCurrentBuffer;	// Offset within the current buffer
    DWORD               m_dwBufferLimit;            // max to buffer
	BOOL				m_fInited;					// Initialization status for the object

	HRESULT				GrowBuffers(DWORD cchNewRequest);	// Increase the size of the buffers

public:
	CResponseBuffer();
	~CResponseBuffer();
	HRESULT             Init(CResponseBufferSet * pBufferSet, DWORD  dwBufferLimit);
	char *              GetBuffer(UINT i);
	DWORD               GetBufferSize(UINT i);
	DWORD               CountOfBuffers();
	DWORD               BytesBuffered();
	CResponseVector *   GetResponseVector();
	HRESULT             Write(char* pszSource, DWORD cch, BOOL fChunkData, BOOL fTemplateData = FALSE);
	HRESULT             Clear();
    VOID                SetBufferLimit(DWORD  dwBufferLimit);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline char * CResponseBuffer::GetBuffer(UINT i)
    {
    Assert( i < m_cBuffers );
    return m_rgpchBuffers[i];
    }

inline DWORD CResponseBuffer::GetBufferSize(UINT i)
    {
    Assert( i < m_cBuffers );

    // if buffer is final one, its content-length is current offset
    if ( i == (m_cBuffers - 1 ) )
        {
        return m_cchOffsetInCurrentBuffer;
        }

    // if buffer is other than final one, its content-length is default buffer size
    return RESPONSE_BUFFER_SIZE;
    }

inline DWORD CResponseBuffer::CountOfBuffers()
    {
    return m_cBuffers;
    }

inline DWORD CResponseBuffer::BytesBuffered()
    {
    return m_ResponseVector.BytesBuffered();
    }

inline CResponseVector * CResponseBuffer::GetResponseVector()
    {
    return &m_ResponseVector;
    }

inline VOID CResponseBuffer::SetBufferLimit(DWORD  dwBufferLimit)
{
    m_dwBufferLimit = dwBufferLimit;
}

/*
 * C D e b u g R e s p o n s e B u f f e r
 *
 */

class CDebugResponseBuffer : public CResponseBuffer
    {
private:
    HRESULT Write(const char* pszSource);

public:
	inline CDebugResponseBuffer() {}
	inline ~CDebugResponseBuffer() {}

    HRESULT Start();
    HRESULT End();

    HRESULT InitAndStart(CResponseBufferSet* pBufferSet, DWORD dwBufferLimit);
    HRESULT ClearAndStart();

    // the only real method
	HRESULT AppendRecord
	    (
	    const int cchBlockOffset,
	    const int cchBlockLength,
	    const int cchSourceOffset,
	    const char *pszSourceFile = NULL
	    );
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline HRESULT CDebugResponseBuffer::Write(const char* pszSource)
    {
    return CResponseBuffer::Write((char *)pszSource, strlen(pszSource), FALSE);
    }

inline HRESULT CDebugResponseBuffer::Start()
    {
    return Write("<!--METADATA TYPE=\"ASP_DEBUG_INFO\"\r\n");
    }

inline HRESULT CDebugResponseBuffer::End()
    {
    return Write("-->\r\n");
    }

inline HRESULT CDebugResponseBuffer::InitAndStart(CResponseBufferSet* pBufferSet, 
                                                  DWORD  dwBufferLimit)
    {
    HRESULT hr = CResponseBuffer::Init(pBufferSet, dwBufferLimit);
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

inline HRESULT CDebugResponseBuffer::ClearAndStart()
    {
    HRESULT hr = CResponseBuffer::Clear();
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

/*
 * C R e s p o n s e C o o k i e s
 *
 * Implements the IRequestDictionary interface for writing cookies.
 */

class CResponseCookies : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // for addrefs
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CRequest *			m_pRequest;			// pointer to request object
	CResponse *			m_pResponse;		// pointer to parent object

public:
	CResponseCookies(CResponse *, IUnknown *);
	~CResponseCookies();
	
	HRESULT Init()
		{
		return S_OK;
		}

	HRESULT ReInit(CRequest *);

	// The Big Three
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface
	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// C++ interface to write headers

	size_t QueryHeaderSize();
	char *GetHeaders(char *szBuffer);
	};

/*
 * C R e s p o n s e B u f f e r S e t
 *
 * Structure that holds the response buffer and Debug response buffer
 */

class CResponseBufferSet {

private:

    CResponseBuffer        *m_pResponseBuffer;          // Pointer to response buffer object
    CDebugResponseBuffer   *m_pClientDebugBuffer;       // Pointer to response buffer object for client debugging data
    CTemplate              *m_pTemplate;                // Pointer to the template for this request
    CTemplate              *m_aTemplates[16];           // internal array of templates referenced by this request
    CTemplate             **m_ppTemplates;              // pointer to current array of templates
    DWORD                   m_dwTemplatesRefd;          // count of templates in array
    DWORD                   m_dwArraySize;              // total slots in array
    DWORD                   m_fCurTemplateInArray : 1;  // TRUE if m_pTemplate is in m_aTemplates
    DWORD                   m_fTemplateArrayAllocd : 1; // TRUE if array was allocated

public:

    CResponseBufferSet();
    ~CResponseBufferSet();

    HRESULT Init(DWORD  dwBufferLimit);

    HRESULT InitDebugBuffer(DWORD dwBufferLimit);

    HRESULT AddTemplateToArray();

    static  VOID    SendResponseCompletion(CIsapiReqInfo    *pIReq,
                                           PVOID            pContext,
                                           DWORD            cbIO,
                                           DWORD            dwError);

    // inline helpers

    CResponseBuffer        *PResponseBuffer() { return m_pResponseBuffer; }
    CDebugResponseBuffer   *PClientDebugBuffer() { return m_pClientDebugBuffer; }
    CTemplate              *PTemplate() { return m_pTemplate; }
    VOID                    SetTemplate(CTemplate    *pTemplate) 
    { 
        m_pTemplate = pTemplate;
        m_fCurTemplateInArray = FALSE;
    }
    VOID                    SetBufferLimit(DWORD dwBufferLimit) {
        m_pResponseBuffer->SetBufferLimit(dwBufferLimit);
        if (m_pClientDebugBuffer)
            m_pClientDebugBuffer->SetBufferLimit(dwBufferLimit);
    }

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

};

/*
 * C R e s p o n s e D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CResponseData : public IUnknown
    {
friend CResponse;
friend CResponseCookies;
friend CResponseBuffer;

private:
    // constructor to pass params to members and init members
    CResponseData(CResponse *);
    ~CResponseData();

    HRESULT Init();

	CSupportErrorInfo	    m_ISupportErrImp;	    // Interface to indicate that we support ErrorInfo reporting
	CIsapiReqInfo *         m_pIReq;				    // CIsapiReqInfo block for HTTP info
	CHitObj*				m_pHitObj;			    // pointer to hitobj for this request
    CHTTPHeader*            m_pFirstHeader;	        // List of
    CHTTPHeader*            m_pLastHeader;	        //      headers
	time_t					m_tExpires;			    // date that the HTML output page expires; -1 if no date assigned
	const char*				m_szCookieVal;		    // Value of session id
	const char*             m_pszDefaultContentType;// Default content type (pointer to static string)
    const char*             m_pszDefaultExpires;    // Default expires header value
	char*					m_pszContentType;	    // Content type of response (set by user)
	char*					m_pszCharSet;			// CharSet header of response
	char*					m_pszCacheControl;		// cache-control header of response
	char*					m_pszStatus;		    // HTTP Status to be returned
	BYTE					m_dwVersionMajor;		// Major version of HTTP supported by client
	BYTE					m_dwVersionMinor;		// Minor version of HTTP supported by client
    CResponseBufferSet     *m_pBufferSet;           // Buffer set for response data
	int						m_IsHeadRequest;	    // HEAD request flag 0=uninit, 1=not head, 2=head
	PFNGETSCRIPT			m_pfnGetScript;		    // Pointer to callback function for obtaining CActiveEngine pointers
	void*					m_pvGetScriptContext;   // Pointer to data for for callback function for CActiveEngines
	CResponseCookies		m_WriteCookies;		    // write-only cookie collection
	DWORD					m_fResponseAborted : 1;	// Was "Response.End" invoked?
	DWORD					m_fWriteClientError : 1;// Write Client Failed
	DWORD                   m_fIgnoreWrites : 1;    // Ignore all writes? (in case of custom error)
	DWORD					m_fBufferingOn : 1;		// Buffer response output
	DWORD                   m_fFlushed : 1;         // Has flush been called?
	DWORD                   m_fChunkData : 1;       // Doing HTTP 1.1 chunking?
    DWORD                   m_fChunkDataInited : 1;  // has m_fChunkData been init'd?
	DWORD                   m_fClientDebugMode : 1; // In client debug mode?
	DWORD                   m_fClientDebugFlushIgnored : 1; // Flush request ignored due to client debug?
	ULONG                   m_cRefs;                // ref count
    DWORD                   m_dwBufferLimit;        // max to buffer

    void AppendHeaderToList(CHTTPHeader *pHeader);

public:	
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

    DWORD                   BytesBuffered();
    BOOL                    FChunkData();

    VOID                    SetBufferLimit(DWORD    dwBufferLimit);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline DWORD CResponseData::BytesBuffered()
{
    DWORD   dw = m_pBufferSet->PResponseBuffer()->GetResponseVector()->BytesBuffered();

    if (m_pBufferSet->PClientDebugBuffer())
        dw += m_pBufferSet->PClientDebugBuffer()->GetResponseVector()->BytesBuffered();

    return dw;
}

inline BOOL CResponseData::FChunkData()
{
    if (m_fChunkDataInited == FALSE) {
        // If using HTTP/1.1 and not buffering add length ofTransfer-Encoding headers
        if ((m_dwVersionMinor >= 1) && (m_dwVersionMajor >= 1) &&
            (m_fBufferingOn == FALSE) &&
            !m_pIReq->IsChild()) { // don't chunk child request output

            // UNDONE: Temporary setting to turn off chuncked encoding
            if (Glob(fEnableChunkedEncoding))
                m_fChunkData = TRUE;
        }
        m_fChunkDataInited = TRUE;
    }

    return m_fChunkData;
}

inline VOID CResponseData::SetBufferLimit(DWORD  dwBufferLimit)
{
    m_dwBufferLimit = dwBufferLimit;

    m_pBufferSet->SetBufferLimit(dwBufferLimit);
}

inline void CResponseData::AppendHeaderToList(CHTTPHeader *pHeader)
    {
    if (!m_pLastHeader)
        {
        Assert(!m_pFirstHeader);
        m_pFirstHeader = pHeader;
        }
    else
        {
        Assert(m_pFirstHeader);
        m_pLastHeader->SetNext(pHeader);
        }
    m_pLastHeader = pHeader;
    }


class CStaticWriteFileCB  {

public:

    WSABUF                          m_wsaBuf;

    CStaticWriteFileCB() {
 
        ZeroMemory( &m_wsaBuf, sizeof(WSABUF));   
    
     }

    ~CStaticWriteFileCB() {

        if (m_wsaBuf.buf)
            CloseHandle((HANDLE)m_wsaBuf.buf);
    }
};

/*
 * C R e s p o n s e
 *
 * Implements the Response object
 */
class CResponse : public IResponseImpl,  public IStream
	{

friend CResponseCookies;
friend CResponseBuffer;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CResponseData *m_pData;   // pointer to structure that holds
                              // CResponse properties

    // FTM Support
    IUnknown    *m_pUnkFTM;

	VOID	GetClientVerison(VOID);

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CResponse(IUnknown *punkOuter = NULL);
	~CResponse();

    HRESULT CleanUp();
	HRESULT	Init();
	HRESULT UnInit();
	
	HRESULT	ReInitTemplate(CTemplate* pTemplate, const char *szCookie);

	CTemplate *SwapTemplate(CTemplate* pNewTemplate);
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, const char *szCookie, CRequest *pRequest,
 				   PFNGETSCRIPT pfnGetScript, void *pvGetScriptContext, CHitObj *pHitObj);

	static HRESULT ConstructSimpleHeaders(
                   LPHSE_SEND_HEADER_EX_INFO pHeaderInfo,
                   DWORD cbTotal,
                   char *szMimeType,
                   char *szStatus = NULL,
                   char *szExtraHeaders = NULL);

	HRESULT	ConstructHeaders(LPHSE_SEND_HEADER_EX_INFO pHeaderInfo);
	HRESULT	WriteResponse();
	VOID    FinalFlush(HRESULT);
	HRESULT	WriteSz(CHAR *sz, DWORD cch);
	HRESULT	WriteBSTR(BSTR bstr);

    // append headers of different kind
	HRESULT AppendHeader(BSTR wszName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, char *szValue, BOOL fCopyValue = FALSE);
	HRESULT AppendHeader(char *szName, long lValue);

	// inlines
	inline BOOL	FHeadersWritten();
	inline BOOL	IsHeadRequest(void);
	inline BOOL	FResponseAborted();
	inline BOOL	FWriteClientError();
	inline BOOL FDontWrite();
	inline void SetIgnoreWrites();
    inline CIsapiReqInfo* GetIReq();
    inline const char* PContentType() const;
    inline char *PCustomStatus();
    inline void *SwapScriptEngineInfo(void *pvEngineInfo);
		
	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IResponse functions
	STDMETHODIMP	Write(VARIANT varInput);
	STDMETHODIMP	BinaryWrite(VARIANT varInput);
	STDMETHODIMP	WriteBlock(short iBlockNumber);
	STDMETHODIMP	Redirect(BSTR bstrURL);
	STDMETHODIMP	AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue);
	STDMETHODIMP	Pics(BSTR bstrHeaderValue);	
	STDMETHODIMP	Add(BSTR bstrHeaderValue, BSTR bstrHeaderName);
	STDMETHODIMP	SetCookie(BSTR bstrHeader, BSTR bstrValue, VARIANT varExpires,
							VARIANT varDomain, VARIANT varPath, VARIANT varSecure);
	STDMETHODIMP	Clear(void);
	STDMETHODIMP	Flush(void);
	STDMETHODIMP	End(void);
	STDMETHODIMP	AppendToLog(BSTR bstrLogEntry);
	STDMETHODIMP	get_ContentType(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_ContentType(BSTR bstrContentType);
	STDMETHODIMP	get_CharSet(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_CharSet(BSTR bstrContentType);
	STDMETHODIMP	get_CacheControl(BSTR *pbstrCacheControl);
	STDMETHODIMP	put_CacheControl(BSTR bstrCacheControl);	
	STDMETHODIMP	get_Status(BSTR *pbstrStatusRet);	
	STDMETHODIMP	put_Status(BSTR bstrStatus);
	STDMETHODIMP	get_Expires(VARIANT *pvarExpiresMinutesRet);
	STDMETHODIMP	put_Expires(long lExpiresMinutes);
	STDMETHODIMP	get_ExpiresAbsolute(VARIANT *pvarTimeRet);
	STDMETHODIMP	put_ExpiresAbsolute(DATE dtExpires);
	STDMETHODIMP	get_Buffer(VARIANT_BOOL* fIsBuffering);
	STDMETHODIMP	put_Buffer(VARIANT_BOOL fIsBuffering);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	IsClientConnected(VARIANT_BOOL* fIsBuffering);
    STDMETHODIMP    get_CodePage(long *plVar);
    STDMETHODIMP    put_CodePage(long var);
    STDMETHODIMP    get_LCID(long *plVar);
    STDMETHODIMP    put_LCID(long var);

    // static method to send the entire block using SyncWriteClient
    static HRESULT StaticWrite(CIsapiReqInfo *pIReq,
                               char *pchBuf,
                               DWORD cchBuf = 0,
                               CTemplate     *pTemplate = NULL);

    // static method to send contents of several memory blocks as the entire response (sync)
    static HRESULT WriteBlocksResponse(CIsapiReqInfo *pIReq,
                                             DWORD cBlocks,
                                             LPWSABUF pWsaBuf,
                                             DWORD cbTotal,
                                             char *szMimeType = NULL,
                                             char *szStatus = NULL,
                                             char *szExtraHeaders = NULL);

    // static method to send contents of a file as the entire response (sync)
    static HRESULT SyncWriteFile(CIsapiReqInfo *pIReq,
                                   TCHAR *szFile,
                                   char *szMimeType = NULL,
                                   char *szStatus = NULL,
                                   char *szExtraHeaders = NULL);

    static VOID StaticWriteFileCompletion(CIsapiReqInfo  *pIReq,
                                          PVOID          pContext,
                                          DWORD          cbIO,
                                          DWORD          dwError);

    // static method to send contents of a scriptless template as the entire response (sync)
    static HRESULT WriteScriptlessTemplate(CIsapiReqInfo *pIReq,
                                           CTemplate *pTemplate);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CResponse::FHeadersWritten()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pIReq->FHeadersWritten();
    }

inline BOOL CResponse::FResponseAborted()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fResponseAborted;
    }

inline BOOL CResponse::FWriteClientError()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fWriteClientError;
    }

inline BOOL CResponse::FDontWrite()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return (m_pData->m_fWriteClientError || m_pData->m_fIgnoreWrites);
    }

inline void CResponse::SetIgnoreWrites()
    {
    Assert(m_fInited);
    Assert(m_pData);
    m_pData->m_fIgnoreWrites = TRUE;
    }

inline CIsapiReqInfo* CResponse::GetIReq()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pIReq;
    }

inline const char* CResponse::PContentType() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    if (m_pData->m_pszContentType)
        return m_pData->m_pszContentType;
	else
		return m_pData->m_pszDefaultContentType;
    }

inline char* CResponse::PCustomStatus()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pszStatus;
    }

inline void *CResponse::SwapScriptEngineInfo(void *pvEngineInfo)
    {
    Assert(m_fInited);
    Assert(m_pData);
    void *pvOldEngineInfo = m_pData->m_pvGetScriptContext;
    m_pData->m_pvGetScriptContext = pvEngineInfo;
    return pvOldEngineInfo;
    }

#endif //_RESPONSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\reg.cpp ===
/*===================================================================
Microsoft IIS Active Server Pages

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Registry stuff

File: reg.cpp

Owner: AndrewS/LeiJin
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include <iadmw.h>

#include "comadmin.h"

#include "memchk.h"

#include "Accctrl.h"
#include "aclapi.h"

#include "iiscnfg.h"

//External functions, defined in glob.cpp
extern HRESULT MDRegisterProperties(void);
extern HRESULT MDUnRegisterProperties(void);
// Globals

const REGSAM samDesired =       KEY_READ | KEY_WRITE;

/*
 * Info about our intrinsics used by Register & UnRegister
 */
const char *szClassDesc[] = {  "ASP Response Object",
                               "ASP Request Object",
                               "ASP Request Dictionary",
                               "ASP Server Object",
                               "ASP Application Object",
                               "ASP Session Object",
                               "ASP String List Object",
                               "ASP Read Cookie",
                               "ASP Write Cookie",
                               "ASP Scripting Context Object",
                               "ASP Certificate Object",
                                };

const char *szCLSIDEntry[] = { "CLSID\\{D97A6DA0-A864-11cf-83BE-00A0C90C2BD8}",  // IResponse
                               "CLSID\\{D97A6DA0-A861-11cf-93AE-00A0C90C2BD8}",  // IRequest
                               "CLSID\\{D97A6DA0-A85F-11df-83AE-00A0C90C2BD8}",  // IRequestDictionary
                               "CLSID\\{D97A6DA0-A867-11cf-83AE-01A0C90C2BD8}",  // IServer
                               "CLSID\\{D97A6DA0-A866-11cf-83AE-10A0C90C2BD8}",  // IApplicationObject
                               "CLSID\\{D97A6DA0-A865-11cf-83AF-00A0C90C2BD8}",  // ISessionObject
                               "CLSID\\{D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8}",  // IStringList
                               "CLSID\\{71EAF260-0CE0-11d0-A53E-00A0C90C2091}",  // IReadCookie
                               "CLSID\\{D97A6DA0-A862-11cf-84AE-00A0C90C2BD8}",  // IWriteCookie
                               "CLSID\\{D97A6DA0-A868-11cf-83AE-00B0C90C2BD8}",  // IScriptingContext
                               "CLSID\\{b3192190-1176-11d0-8ce8-00aa006c400c}",  // ICertificate
                               };

const cClassesMax = sizeof(szCLSIDEntry) / sizeof(char *);


/*===================================================================
RegisterIntrinsics

Register info about our intrinsics in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
HRESULT RegisterIntrinsics(void)
{
        static const char szDenaliDLL[] = "asp.DLL";
        static const char szThreadingModel[] = "ThreadingModel";
        static const char szInprocServer32[] = "InprocServer32";
        static const char szFreeThreaded[] = "Both";
        static const char szProgIdKey[] = "ProgId";
        static const char szCLSIDKey[] = "CLSID";

        HRESULT hr = S_OK;
        char            szPath[MAX_PATH];
        char            *pch;
        HKEY            hkeyCLSID = NULL;
        HKEY            hkeyT = NULL;
        DWORD           iClass;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
                return E_FAIL;
        // bug fix 102010 DBCS fixes
        //
        //for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
        //      ;
        //if (pch == szPath)

        pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
        if (pch == NULL)
                {
                Assert(FALSE);
                goto LErrExit;
                }

        strcpy(pch + 1, szDenaliDLL);

        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // install the CLSID key
                // Setting the value of the description creates the key for the clsid
                if ((RegSetValueA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], REG_SZ, szClassDesc[iClass],
                        strlen(szClassDesc[iClass])) != ERROR_SUCCESS))
                        goto LErrExit;

                // Open the CLSID key so we can set values on it
                if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], 0, samDesired, &hkeyCLSID) != ERROR_SUCCESS)
                        goto LErrExit;

                // install the InprocServer32 key and open the sub-key to set the named value
                if ((RegSetValueA(hkeyCLSID, szInprocServer32, REG_SZ, szPath, strlen(szPath)) != ERROR_SUCCESS))
                        goto LErrExit;

                if ((RegOpenKeyExA(hkeyCLSID, szInprocServer32, 0, samDesired, &hkeyT) != ERROR_SUCCESS))
                        goto LErrExit;

                // install the ThreadingModel named value
                if (RegSetValueExA(hkeyT, szThreadingModel, 0, REG_SZ, (const BYTE *)szFreeThreaded,
                                (strlen(szFreeThreaded)+1) * sizeof(char)) != ERROR_SUCCESS)
                        goto LErrExit;

                if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
                        goto LErrExit;
                hkeyT = NULL;

                RegCloseKey(hkeyCLSID);
                hkeyCLSID = NULL;
                }


        return hr;

LErrExit:
    if (hkeyT)
        RegCloseKey(hkeyT);
    
    if (hkeyCLSID)
        RegCloseKey(hkeyCLSID);
    
    return E_FAIL;
}

/*===================================================================
UnRegisterKey

Given a string which is the name of a key under HKEY_CLASSES_ROOT,
delete everything under that key and the key itself from the registry
(why the heck isnt there an API that does this!?!?)

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes a key & all subkeys from the registry
===================================================================*/
HRESULT UnRegisterKey(CHAR *szKey)
{
        HKEY            hkey = NULL;
        CHAR            szKeyName[255];
        DWORD           cbKeyName;
        LONG            errT;

        // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
        if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szKey, 0, samDesired, &hkey) != ERROR_SUCCESS)
                goto LErrExit;

        // Enumerate all its subkeys, and delete them
        while (TRUE)
                {
                cbKeyName = sizeof(szKeyName);
                if ((errT = RegEnumKeyExA(hkey, 0, szKeyName, &cbKeyName, 0, NULL, 0, NULL)) != ERROR_SUCCESS)
                        break;

                if ((errT = RegDeleteKeyA(hkey, szKeyName)) != ERROR_SUCCESS)
                        goto LErrExit;
                }

        // Close the key, and then delete it
        if ((errT = RegCloseKey(hkey)) != ERROR_SUCCESS)
                return(E_FAIL);
        if ((errT = RegDeleteKeyA(HKEY_CLASSES_ROOT, szKey)) != ERROR_SUCCESS)
                {
        DBGPRINTF((DBG_CONTEXT, "Deleting key %s returned %d\n",
                    szKey, GetLastError()));
                return(E_FAIL);
                }

        return S_OK;

LErrExit:
    if (hkey)
        RegCloseKey(hkey);
    
    return E_FAIL;
}

/*===================================================================
UnRegisterIntrinsics

UnRegister the info about our intrinsics from the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali objects from the registry
===================================================================*/
HRESULT UnRegisterIntrinsics(void)
{
        HRESULT         hr = S_OK, hrT;
        DWORD           iClass;

        // Now delete the keys for the objects
        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
                if (FAILED(hrT = UnRegisterKey((CHAR *)szCLSIDEntry[iClass])))
                        hr = hrT;       // Hold onto the error, but keep going

                }

        return hr;
}


/*===================================================================
RegisterTypeLib

Register denali typelib in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        register denali typelib in the registry
===================================================================*/
HRESULT RegisterTypeLib(void)
{
        HRESULT hr;
        ITypeLib *pITypeLib = NULL;

        char szFile[MAX_PATH+4];

        BSTR    bstrFile;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szFile, MAX_PATH))
                return E_FAIL;

        // There are two type libraries: First the standard ASP typelib
        //              then the typelib for the Transacted Script Context object.
        //              Load them both.

        // First type lib, from default (first ITypeLib entry) location
        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
                return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if (pITypeLib) {
            pITypeLib->Release();
            pITypeLib = NULL;
        }

        SysFreeString(bstrFile);

        if (FAILED(hr))
            return hr;

        // now register the Transacted Script Context Object

        strcat(szFile, "\\2");

        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
            return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if (pITypeLib) {
            pITypeLib->Release();
            pITypeLib = NULL;
        }

        SysFreeString(bstrFile);

        return hr;
}
/*===================================================================
UnRegisterTypeLib

UnRegister denali typelib in the registry.  Note: Only the current version used by asp.dll is removed.

Returns:
        HRESULT - S_OK on success

Side effects:
        unregister denali typelib in the registry
===================================================================*/
HRESULT UnRegisterTypeLib(void)
{
    HRESULT hr;
    ITypeLib *pITypeLib = NULL;
    TLIBATTR *pTLibAttr = NULL;

    char    szFile[MAX_PATH + 4];
    BSTR    bstrFile;

    // Get the path and name of Denali
    if (!GetModuleFileNameA(g_hinstDLL, szFile, MAX_PATH))
            return E_FAIL;

    hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
    if (FAILED(hr))
            return hr;

    hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
    if(SUCCEEDED(hr) && pITypeLib)
    {
        hr = pITypeLib->GetLibAttr(&pTLibAttr);
        if(SUCCEEDED(hr) && pTLibAttr)
        {
            hr = UnRegisterTypeLib( pTLibAttr->guid,
                                    pTLibAttr->wMajorVerNum,
                                    pTLibAttr->wMinorVerNum,
                                    pTLibAttr->lcid,
                                    pTLibAttr->syskind);

            pITypeLib->ReleaseTLibAttr(pTLibAttr);
            pTLibAttr = NULL;
        }
        pITypeLib->Release();
        pITypeLib = NULL;
    }

    SysFreeString(bstrFile);

    // unregister the Txn typelib
    strcat(szFile, "\\2");

    hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
    if (FAILED(hr))
            return hr;

    hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
    if(SUCCEEDED(hr) && pITypeLib)
    {
        hr = pITypeLib->GetLibAttr(&pTLibAttr);
        if(SUCCEEDED(hr) && pTLibAttr)
        {
            hr = UnRegisterTypeLib( pTLibAttr->guid,
                                    pTLibAttr->wMajorVerNum,
                                    pTLibAttr->wMinorVerNum,
                                    pTLibAttr->lcid,
                                    pTLibAttr->syskind);

            pITypeLib->ReleaseTLibAttr(pTLibAttr);
            pTLibAttr = NULL;
        }
        pITypeLib->Release();
        pITypeLib = NULL;
    }

    SysFreeString(bstrFile);

    return hr;
}


HRESULT CreateCompiledTemplatesTempDir()
{
    HRESULT                 hr = S_OK;
	BYTE                    szRegString[MAX_PATH];
    BYTE                    pszExpanded[MAX_PATH];
    int                     result = 0;
    EXPLICIT_ACCESSA        ea[2];
    PACL                    pNewDACL = NULL;
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;


    // read the temp dir name for the persistant templ
    // cache.

    CchLoadStringOfId(IDS_DEFAULTPERSISTDIR, (LPSTR)szRegString, MAX_PATH);

    result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                       (LPSTR)pszExpanded,
                                       MAX_PATH);

    if ((result <= MAX_PATH) && (result > 0)) {
        CreateDirectoryA((LPCSTR)pszExpanded,NULL);
    }

    // this next section of code will place the SYSTEM and IWAM_<ComputerName>
    // ACEs on the directorie's ACL

    ZeroMemory(ea, sizeof(EXPLICIT_ACCESSA) * 2);

    ea[0].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[0].grfAccessMode = GRANT_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;

    ea[1].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[1].grfAccessMode = GRANT_ACCESS;
    ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea[1].Trustee.ptstrName = "IIS_WPG";

    // Admin privilages.
    if (!AllocateAndInitializeSid(&NtAuthority,
                                       2,            // 2 sub-authorities
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0,0,0,0,0,0,
                                       (PSID *)(&ea[0].Trustee.ptstrName)))
        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAclA(2,
                                    ea,
                                    NULL,
                                    &pNewDACL)) != ERROR_SUCCESS);

    // set the ACL on the directory

    else hr = SetNamedSecurityInfoA((LPSTR)pszExpanded,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    pNewDACL,
                                    NULL);
    if (pNewDACL)
        LocalFree(pNewDACL);

    if (ea[0].Trustee.ptstrName)
        FreeSid(ea[0].Trustee.ptstrName);

    return(hr);
}


/*===================================================================
DllRegisterServer

Entry point used by RegSvr32.exe to register the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
STDAPI DllRegisterServer(void)
        {
        HRESULT             hr = E_FAIL;
        HRESULT             hrCoInit;

        hrCoInit = CoInitialize(NULL);

        if (FAILED(InitializeResourceDll()))
            goto LErr;
    
    // First try to unregister some stuff
    // This is important when we are registering on top of
    // an old IIS 3.0 Denali registration
    // Don't care if fails
        UnRegisterEventLog();
        UnRegisterIntrinsics();
        UnRegisterTypeLib();


    // Now do the registration

        if (FAILED(hr = MDRegisterProperties()))
                goto LErr;

        // Register NT event log
        if(FAILED(hr = RegisterEventLog()))
                goto LErr;

        if (FAILED(hr = RegisterTypeLib()))
                goto LErr;

        // Register our intrinsics
        if (FAILED(hr = RegisterIntrinsics()))
                goto LErr;
      
        if (FAILED(hr = CreateCompiledTemplatesTempDir()))
            goto LErr;

LErr:
        UninitializeResourceDll();
        if (SUCCEEDED(hrCoInit))
                CoUninitialize();
        return(hr);
        }

/*===================================================================
DllUnregisterServer

Entry point used by RegSvr32.exe to unregister the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali registrations from the registry
===================================================================*/
STDAPI DllUnregisterServer(void)
        {
        HRESULT hr = S_OK, hrT;
        HRESULT hrCoInit;

        hrCoInit = CoInitialize(NULL);

        hrT = InitializeResourceDll();
        if (FAILED(hrT))
            hr = hrT;
        
        hrT = UnRegisterEventLog();
        if (FAILED(hrT))
                hr = hrT;

        hrT = MDUnRegisterProperties();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterIntrinsics();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterTypeLib();
        if (FAILED(hrT))
                hr = hrT;

        // UNDONE BUG 80063: Ignore errors from this call
#ifdef UNDONE
        if (FAILED(hrT))
                hr = hrT;
#endif

        UninitializeResourceDll();

        if (SUCCEEDED(hrCoInit))
                CoUninitialize();

        return(hr);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\request.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: request object

File: request.cpp

Owner: CGrant, DGottner

This file contains the code for the implementation of the Request object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "request.h"
#include "cookies.h"
#include "clcert.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


static char HexToChar(LPSTR);
static char DecodeFromURL(char **pszSource, char *szStop, char *szDest, UINT uCodePage, BOOL fIgnoreCase = FALSE);

struct {
    int     varLen;
    char    *szVarName;
} g_sUNICODEVars [] = {

    {3, "URL"},
    {9, "PATH_INFO"},
    {9, "AUTH_USER"},
    {9, "CACHE_URL"},
    {10,"LOGON_USER"},
    {11,"REMOTE_USER"},
    {11,"SCRIPT_NAME"},
    {11,"APP_POOL_ID"},
    {12,"APPL_MD_PATH"},
    {15,"PATH_TRANSLATED"},
    {17,"SCRIPT_TRANSLATED"},
    {18,"APPL_PHYSICAL_PATH"},
    {20,"UNMAPPED_REMOTE_USER"},
    {-1,""}
};

/*------------------------------------------------------------------
 * C R e q u e s t H i t
 */

/*===================================================================
CRequestHit::CRequestHit

Constructor

Parameters:
    None
===================================================================*/

CRequestHit::CRequestHit()
    {
    m_fInited = FALSE;
    m_fDuplicate = FALSE;
    m_pQueryData = m_pFormData = NULL;
    m_pCookieData = NULL;
    m_pClCertData = NULL;
    }



/*===================================================================
CRequestHit::~CRequestHit

Destructor
===================================================================*/

CRequestHit::~CRequestHit()
    {
    if (m_pQueryData != NULL)
        m_pQueryData->Release();

    if (m_pFormData != NULL)
        m_pFormData->Release();

    if (m_pCookieData != NULL)
        m_pCookieData->Release();

    if (m_pClCertData != NULL)
        m_pClCertData->Release();

    if (m_fDuplicate)
        delete m_pKey;
    }



/*===================================================================
CRequestHit::Init

Constructor

Parameters:
    szName - pointer to string containing name
    fDuplicate - TRUE if we should dup the string

Returns:
    E_OUTOFMEMORY, E_FAIL, or S_OK
===================================================================*/

HRESULT CRequestHit::Init(char *szName, BOOL fDuplicate)
    {
    if (m_fInited)
        return E_FAIL;

    m_fDuplicate = fDuplicate;
    if (fDuplicate)
        {
        char *szNewKey = new char [strlen(szName) + 1];
        if (szNewKey == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(CLinkElem::Init(strcpy(szNewKey, szName), strlen(szName))))
            return E_FAIL;
        }
    else
        if (FAILED(CLinkElem::Init(szName, strlen(szName))))
            return E_FAIL;

    m_fInited = TRUE;
    return S_OK;
    }




/*===================================================================
CRequestHit::AddValue

Parameters:
    source - type of the value (QueryString or Body)
    szValue - the value as a null-terminated string.
    lCodePage - the CodePage used when retrieve the data

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestHit::AddValue
(
CollectionType Source,
char *szValue,
CIsapiReqInfo   *pIReq,
UINT lCodePage
)
    {
    HRESULT hResult;
    CStringList **ppValues = NULL;

    switch (Source)
        {
    case QUERYSTRING:
        ppValues = &m_pQueryData;
        break;

    case FORM:
        ppValues = &m_pFormData;
        break;

    case COOKIE:
        if (m_pCookieData == NULL)
            {
            m_pCookieData = new CCookie(pIReq, lCodePage);

            if (m_pCookieData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pCookieData->Init()))
                return hResult;
            }

        return m_pCookieData->AddValue(szValue);

    case CLCERT:
        if (m_pClCertData == NULL)
            {
            m_pClCertData = new CClCert;

            if (m_pClCertData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pClCertData->Init()))
                return hResult;
            }

        return m_pClCertData->AddValue(szValue);

    default:
        return E_FAIL;
        }

    if (*ppValues == NULL)
        {
        *ppValues = new CStringList;
        if (*ppValues == NULL)
            return E_OUTOFMEMORY;
        }

    if (FAILED(hResult = (*ppValues)->AddValue(szValue, FALSE, lCodePage)))
        return hResult;

    return S_OK;
    }



HRESULT CRequestHit::AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen )
    {
    HRESULT hResult;

    if (m_pClCertData == NULL)
        {
        m_pClCertData = new CClCert;

        if (m_pClCertData == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hResult = m_pClCertData->Init()))
            return hResult;
        }

    return m_pClCertData->AddValue( (LPSTR)pValue, ve, cLen );
    }




/*===================================================================
CRequestHit::AddKeyAndValue

Add a value based on keys for collections that support them.  Currently,
only cookies support them.

Parameters:
    source - type of the value (must be Cookie)
    szKey - the key
    szValue - the value as a null-terminated string.

Returns:
    Returns E_OUTOFMEMORY if memory cannot be allocated,
    E_FAIL if source collection does not support keys,
===================================================================*/
HRESULT CRequestHit::AddKeyAndValue
(
CollectionType Source,
char *szKey,
char *szValue,
CIsapiReqInfo    *pIReq,
UINT    lCodePage
)
{
    HRESULT hResult;

    switch ( Source )
    {
        case COOKIE:
            if (m_pCookieData == NULL)
                {
                m_pCookieData = new CCookie( pIReq , lCodePage);

                if (m_pCookieData == NULL)
                    return E_OUTOFMEMORY;

                if (FAILED(hResult = m_pCookieData->Init()))
                    return hResult;
                }

            return m_pCookieData->AddKeyAndValue(szKey, szValue);

        default:
            return E_FAIL;
    }
}

/*------------------------------------------------------------------
 * C R e q u e s t H i t s A r r a y
 */

/*===================================================================
CRequestHitsArray::CRequestHitsArray

Constructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::CRequestHitsArray()
    : m_dwCount(0), m_dwHitMax(0), m_rgRequestHit(NULL)
    {
    }

/*===================================================================
CRequestHitsArray::~CRequestHitsArray

Destructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::~CRequestHitsArray()
    {
    if (m_rgRequestHit)
        delete [] m_rgRequestHit;
    }

/*===================================================================
CRequestHitsArray::AddRequestHit

Add an element to the array

Parameters:
    pHit    element to add

Returns:
===================================================================*/
BOOL CRequestHitsArray::AddRequestHit
(
CRequestHit *pHit
)
    {
    Assert(pHit);

    if (m_dwCount == m_dwHitMax)
        {
        DWORD dwNewSize = m_dwHitMax + NUM_REQUEST_HITS;
        CRequestHit **ppNewArray = new CRequestHit *[dwNewSize];

        if (ppNewArray == NULL)
            return FALSE;

        ZeroMemory(ppNewArray, sizeof(CRequestHit *) * dwNewSize);

        if (m_dwCount)
            {
            Assert(m_rgRequestHit);

            // Copy pointers from old array
            memcpy
                (
                ppNewArray,
                m_rgRequestHit,
                m_dwCount * sizeof(CRequestHit *)
                );

            // free old array
            delete [] m_rgRequestHit;
            }
         else
            {
            Assert(m_rgRequestHit == NULL);
            }

        m_rgRequestHit = ppNewArray;
        m_dwHitMax = dwNewSize;
        }

    m_rgRequestHit[m_dwCount++] = pHit;
    return TRUE;
    }

/*------------------------------------------------------------------
 * C Q u e r y S t r i n g
 */

/*===================================================================
CQueryString::CQueryString

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CQueryString::CQueryString(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CQueryString::~CQueryString

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CQueryString::~CQueryString()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CQueryString::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.

===================================================================*/
HRESULT CQueryString::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CQueryString::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CQueryString::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CQueryString::QueryInterface
CQueryString::AddRef
CQueryString::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CQueryString::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CQueryString::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CQueryString::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CQueryString::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Look up QueryString using the "ServerVariables" collection -
            // The LoadVariables() function trashes QueryPszQueryString() in the CIsapiReqInfo
            //
            DWORD dwQStrSize;

            STACK_BUFFER( queryStrBuff, 256 );

            if (!SERVER_GET(m_pRequest->GetIReq(), "QUERY_STRING", &queryStrBuff, &dwQStrSize)) {
                if (GetLastError() == ERROR_OUTOFMEMORY) {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                }
                else {
                    hrReturn = E_FAIL;
                }
                goto LExit;
            }

            char *szQueryString = (char *)queryStrBuff.QueryPtr();

            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szQueryString, 0, &bstrT,m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && (int) m_dwCount == 0))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pQueryData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;

        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CQueryString::get_Count(int *pcValues)
    {
    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CQueryString::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CQueryString::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(QUERYSTRING, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C F o r m I n p u t s
 */

/*===================================================================
CFormInputs::CFormInputs

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CFormInputs::CFormInputs(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CFormInputs::CFormInputs

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CFormInputs::~CFormInputs()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CFormInputs::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.
===================================================================*/
HRESULT CFormInputs::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CFormInputs::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CFormInputs::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CFormInputs::QueryInterface
CFormInputs::AddRef
CFormInputs::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CFormInputs::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CFormInputs::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CFormInputs::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CFormInputs::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_OK if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;                // ascii version of the key
    CWCharToMBCS    convKey;
    IDispatch       *pSListReturn;         // value of the key
    CRequestHit     *pRequestHit;          // pointer to request bucket
    BOOL            fDataAvail = FALSE;    // true if data seen from client

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        // BUG:895 (JHITTLE) added to check for null result set
        // this fixes the out of memory error when the form
        // data is NULL
        //
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }
    else
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            if (fDataAvail)
                {
                BSTR bstrT;
                if (FAILED(SysAllocStringFromSz(m_pRequest->m_pData->m_szFormClone, 0, &bstrT,m_pRequest->GetCodePage())))
                    {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    }
                V_VT(pvarReturn) = VT_BSTR;
                V_BSTR(pvarReturn) = bstrT;
                }

            // If there was no data available, status & return value are already set
            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    pRequestHit = NULL;
    if (! fDataAvail)       // Quick check before we do an expensive lookup
        goto LNotFound;

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pFormData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;
        goto LExit;
        }

LNotFound: // Return "Empty"
    if(vt != VT_BSTR)
        {
        hrReturn = E_FAIL;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
        goto LExit;
        }

    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CFormInputs::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;


    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Key

Function called from DispInvoke to get keys from the form inputs collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CFormInputs::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(FORM, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C C o o k i e s
 */

/*===================================================================
CCookies::CCookies

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CCookies::CCookies(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyCookie = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CCookies::CCookies

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CCookies::~CCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyCookie)
        m_pEmptyCookie->Release();
    }


/*===================================================================
CCookies::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CCookies::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CCookies::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CCookies::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CCookies::QueryInterface
CCookies::AddRef
CCookies::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CCookies::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CCookies::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CCookies::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CCookies::get_Item

Function called from DispInvoke to get values from the Cookies collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );
    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of HTTP_COOKIE.
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPCookie = 1; // At the least we will need space for '\0'

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    cbHTTPCookie += pCookie->GetHTTPCookieSize() + pRequestHit->m_cbKey + 1;
                }

            // Allocate space for the HTTP_COOKIE value
            //
            if (cbHTTPCookie > REQUEST_ALLOC_MAX)
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
                hrReturn = E_FAIL;
                goto LExit;
                }
            if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());

            // Step 2: create the value of HTTP_COOKIE
            //
            char *szDest = szHTTPCookie;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pCookie->GetHTTPCookie(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return Empty Cookie
    if (!m_pEmptyCookie)
        {
        // create on demand
        if ((m_pEmptyCookie = new CCookie(m_pRequest->GetIReq(), m_pRequest->GetCodePage())) != NULL)
            hrReturn = m_pEmptyCookie->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyCookie)
        hrReturn = m_pEmptyCookie->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Key

Function called from DispInvoke to get keys from the cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Key(VARIANT varKey, VARIANT *pVar)
{
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CCookies::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(COOKIE, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C C l C e r t s
 */

/*===================================================================
CClCerts::CClCerts

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CClCerts::CClCerts(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyClCert = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CClCerts::ClCerts

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CClCerts::~CClCerts()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyClCert)
        m_pEmptyClCert->Release();
    }

/*===================================================================
CClCerts::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CClCerts::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
CClCerts::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CClCerts::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CClCerts::QueryInterface
CClCerts::AddRef
CClCerts::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CClCerts::QueryInterface(REFIID riid, void **ppv)
    {
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IRequestDictionary || riid == IID_IDispatch)
        *ppv = this;

    else if (riid == IID_ISupportErrorInfo)
        *ppv = &m_ISupportErrImp;

    if (*ppv != NULL)
        {
        static_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CClCerts::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CClCerts::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CClCerts::get_Item

Function called from DispInvoke to get values from the ClCerts collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_FALSE if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of CLCERT
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPClCert = 1;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    cbHTTPClCert += pClCert->GetHTTPClCertSize() + pRequestHit->m_cbKey + 1;
                }

            STACK_BUFFER( tempClCert, 256);

            if (!tempClCert.Resize(cbHTTPClCert)) {
			    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPClCert = static_cast<char *>(tempClCert.QueryPtr());

            // Step 2: create the value of CLCERT
            //
            char *szDest = szHTTPClCert;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pClCert->GetHTTPClCert(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPClCert, 0, &bstrT)))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey)))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
    		szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CClCert *pDictionary = pRequestHit->m_pClCertData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (!m_pEmptyClCert)
        {
        // create on demand
        if ((m_pEmptyClCert = new CClCert) != NULL)
            hrReturn = m_pEmptyClCert->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyClCert)
        hrReturn = m_pEmptyClCert->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Key

Function called from DispInvoke to get keys from the certificate collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CClCerts::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CClCerts::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CClCerts::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(CLCERT, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C S e r v e r V a r i a b l e s
 */

/*===================================================================
CServerVariables::CServerVariables

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::CServerVariables(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary),
      m_pIterator(NULL)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CServerVariables::~CServerVariables

Destructor

Parameters:
    None

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::~CServerVariables( )
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pIterator)
        m_pIterator->Release();
    }

/*===================================================================
CServerVariables::QueryInterface
CServerVariables::AddRef
CServerVariables::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CServerVariables::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServerVariables::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CServerVariables::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CServerVariables::get_Item

Function called from DispInvoke to get values from the ServerVariables
collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.

NOTE:
    This code is basically an enacpsulation from the SERVER_GET macro,
    only more efficient, since it only looks up the key once on average
    unfortunately, the only way to get good memory utilization with
    ISAPI is to use _alloca() with lookups, which means we can't
    encapsulate the lookup logic very well.
===================================================================*/

HRESULT CServerVariables::get_Item(VARIANT varKey, VARIANT *pvarReturn)
{

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    DWORD           dwValSize;             // buffer size

    char            *szKey;                // pointer to ASCII value of varKey
    char            *szValue;
    WCHAR           *wszValue;

    BOOL            fSuccess;              // TRUE when call to GetServerVariable succeeds
    UINT            uCodePage = GetACP();
    CWCharToMBCS    convKey;
    BOOL            fUnicodeVar = FALSE;

    STACK_BUFFER( tempVal, 128 );

    dwValSize = tempVal.QuerySize();
    szValue = (char *)tempVal.QueryPtr();
    wszValue = (WCHAR *)tempVal.QueryPtr();

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4)) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    vt = V_VT(pvarKey);
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;      // initial value of Nothing

    switch (vt) {

        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;

        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
                hrReturn = E_FAIL;
                goto LExit;
            }

            // Other error, FALL THROUGH to wrong type case

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
    }

    uCodePage = m_pRequest->GetCodePage();

    if (vt == VT_BSTR) {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }
    else {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator) {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            if (FAILED (hrReturn = m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
                goto LExit;
        }
        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0))) {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
        }
        if (FAILED(hrReturn = convKey.Init(m_pIterator->m_rgwszKeys[iCount - 1], uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }

    if (strncmp(convKey.GetString(), "UNICODE_", 7) == 0) {
        fSuccess = false;
        goto SkipLookup;
    }


    // in IIS6, there are a number of variables that are UNICODE.  To
    // access them, you simply place UNICODE_ infront of the name.
    // Two approaches could be taken here. One would be to always
    // try for a UNICODE_ var and fallback to the non-UNICODE var
    // if the lookup fails.  This can be costly.  The second, and
    // chosen method here, would be to maintain a list of vars
    // that have UNICODE_ versions.

    // this char array is declared on the stack and is currently only
    // 32 chars.  It only needs to be as big as the largest UNICODE
    // var name.  Which is UNICODE_UNMAPPED_REMOTE_USER.

    char            szUNICODEName[32];

    // search the list to see if this is one of the UNICODE_ vars.
    // the list is sorted by length of string.  The current list is
    // not all that long, so a sequential search is not that expensive
    // in the scheme of things.

    for (int i=0;
         (g_sUNICODEVars[i].varLen != -1)
             && (convKey.GetStringLen() >= g_sUNICODEVars[i].varLen);
         i++) {

        // the 'for' loop allows in anything which is at least as long
        // as the current entry.  The following 'if' will check for
        // for an exact length match and then a string compare.

        if ((convKey.GetStringLen() == g_sUNICODEVars[i].varLen)
            && (strcmp(convKey.GetString(), g_sUNICODEVars[i].szVarName) == 0)) {

            // if a hit is made, set the fUnicodeVar = TRUE so that the
            // right ISAPI lookup routine is called and the right StringList
            // AddValue is called.

            fUnicodeVar = TRUE;

            // build up the UNICODE_ version into the stack temp array

            strcpyExA(strcpyExA(szUNICODEName,"UNICODE_"),convKey.GetString());

            // reassign the key name to this value

            szKey = szUNICODEName;

            break;
        }
    }

    fSuccess = fUnicodeVar
                ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);

    if (!fSuccess && (dwValSize > tempVal.QuerySize())) {
        if (dwValSize > REQUEST_ALLOC_MAX) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            hrReturn = E_FAIL;
            goto LExit;
        }

        if (tempVal.Resize(dwValSize) == FALSE) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }
        szValue = static_cast<char *>(tempVal.QueryPtr());
        wszValue = static_cast<WCHAR *>(tempVal.QueryPtr());
        fSuccess = fUnicodeVar
                    ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                    : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);
    }

SkipLookup:

    if (fSuccess) {
        // Create return value
        CStringList *pValue = new CStringList;
        if (pValue == NULL) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }

        // add the value and QueryInterface for IDispatch interface - strdup the input string
        if (FAILED(hrReturn = (fUnicodeVar
                                  ? pValue->AddValue(wszValue, TRUE)
                                  : pValue->AddValue(szValue, TRUE, uCodePage))))
            goto LExit;

        if (FAILED(pValue->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        // Release temporary (QueryInterface AddRef'd)
        pValue->Release();
        goto LExit;
    }
    else {
        if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&V_DISPATCH(pvarReturn))))
            hrReturn = E_FAIL;
    }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
}

/*===================================================================
CServerVariables::get_Key

Function called from DispInvoke to get keys from the server variables collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CServerVariables::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    HRESULT hrReturn = S_OK;
    int iCount = 0;
    BSTR bstrT = NULL;

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;
        vt = V_VT(pvarKey);
        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // At this point the VT of pvarKey should be VT_I4 or VT_BSTR
    Assert((vt == VT_I4) || (vt == VT_BSTR));

    if (vt == VT_I4)
        {
        // We were passed in a number.
        // Look up the key by integer index

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator)
            {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator)
                {
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            if (FAILED(hrReturn = m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
                goto LExit;
            }

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        // Create a BSTR containing the key for this variant
        bstrT = SysAllocString(m_pIterator->m_rgwszKeys[iCount - 1]);
        if (!bstrT)
            {
            hrReturn = E_OUTOFMEMORY;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            goto LExit;
            }
        }
    else
        {
        // We were passed in a BSTR. Check to see if there
        // is a server variable for this key

        char szBuffer;
        DWORD dwValSize = sizeof(szBuffer);
        UINT uCodePage = m_pRequest->GetCodePage();

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }

        BOOL fSuccess = m_pRequest->GetIReq()->GetServerVariableA(szKey, &szBuffer, &dwValSize);

        DWORD dwError = 0;

        if (!fSuccess)
            {
            dwError = GetLastError();
            }

        // If the error was that we had insufficient buffer then
        // there is a server variable for that key

        if (fSuccess || dwError == ERROR_INSUFFICIENT_BUFFER)
            {
            bstrT = SysAllocString(V_BSTR(pvarKey));
            if (!bstrT)
                {
                hrReturn = E_OUTOFMEMORY;
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
                }
            }
         else if (dwError != ERROR_INVALID_INDEX)
            {

            // Any other error indicates an unexpected failure

            hrReturn = HRESULT_FROM_WIN32(dwError);
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
            goto LExit;
            }
        }

    // If we found a key, copy it into the out parmater
    if (bstrT)
        {
        V_BSTR(pVar) = bstrT;
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CServerVariables::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CServerVariables::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // We use the CServVarsIterator to manange
    // the count of sv and integer index
    if (!m_pIterator)
        {
        m_pIterator = new CServVarsIterator;
        if (!m_pIterator)
            {
            *pcValues = 0;
            return E_OUTOFMEMORY;
            }
        if (FAILED (hrReturn = m_pIterator->Init(m_pRequest->m_pData->m_pIReq)))
            return hrReturn;
        }

    *pcValues = m_pIterator->m_cKeys;

    return hrReturn;
    }

/*===================================================================
CServerVariables::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CServerVariables::get__NewEnum(IUnknown **ppEnumReturn)
    {
    HRESULT hrReturn = S_OK;
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CServVarsIterator *pIterator = new CServVarsIterator;
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    if (FAILED(hrReturn = pIterator->Init(m_pRequest->GetIReq())))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, ((hrReturn==E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED));
        return hrReturn;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }


/*------------------------------------------------------------------
 * C R e q u e s t D a t a
 */

/*===================================================================
CRequestData::CRequestData

Constructor

Parameters:
    CRequest *pRequest

Returns:
    Nothing.
===================================================================*/
CRequestData::CRequestData
(
CRequest *pRequest
)
    : m_ISupportErrImp(static_cast<IRequest *>(pRequest), this, IID_IRequest),
      m_QueryString(pRequest, this),
      m_ServerVariables(pRequest, this),
      m_FormInputs(pRequest, this),
      m_Cookies(pRequest, this),
      m_ClCerts(pRequest, this),
      m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_FormDataStatus = AVAILABLE;
    m_pbAvailableData = NULL;
    m_cbAvailable = 0;
    m_cbTotal = 0;
    m_szFormData = NULL;
    m_cbFormData = 0;
    m_szFormClone = NULL;
    m_szCookie = NULL;
    m_cbCookie = 0;
    m_szClCert = NULL;
    m_cbClCert = 0;
    m_szQueryString = NULL;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_pEmptyString = NULL;
    }

/*===================================================================
CRequestData::~CRequestData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CRequestData::~CRequestData()
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL) {
        CRequestHit *pNext = static_cast<CRequestHit *>(pNukeElem->m_pNext);
        delete pNukeElem;
        pNukeElem = pNext;
    }

    m_mpszStrings.UnInit();

    if (m_pEmptyString)
        m_pEmptyString->Release();

    if (m_szFormData)
        free(m_szFormData);

    if (m_szFormClone)
        free(m_szFormClone);

    if (m_szCookie)
        free(m_szCookie);

    if (m_szClCert)
        free(m_szClCert);

    if (m_szQueryString)
        free(m_szQueryString);
    }

/*===================================================================
CRequestData::Init

Init

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::Init()
    {
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
        hr = m_mpszStrings.Init();

    if (SUCCEEDED(hr))
        hr = m_QueryString.Init();

    if (SUCCEEDED(hr))
        hr = m_FormInputs.Init();

    if (SUCCEEDED(hr))
        hr = m_Cookies.Init();

    if (SUCCEEDED(hr))
        hr = m_ClCerts.Init();

    if (SUCCEEDED(hr))
        hr = m_ServerVariables.Init();

    return hr;
    }

/*===================================================================
CRequestData::ReInit

ReInit -- associate with new CIsapiReqInfo and HitObj

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::ReInit
(
CIsapiReqInfo   *pIReq,
CHitObj *pHitObj
)
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL)
        {
        CRequestHit *pNext = static_cast<CRequestHit *>
            (
            pNukeElem->m_pNext
            );
        delete pNukeElem;
        pNukeElem = pNext;
        }
    m_mpszStrings.ReInit();

    m_QueryString.ReInit();
    m_FormInputs.ReInit();
    m_Cookies.ReInit();
    m_ClCerts.ReInit();

    m_pIReq = pIReq;
    m_pHitObj = pHitObj;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_FormDataStatus = AVAILABLE;

    if (pIReq)
        {
        m_pbAvailableData = pIReq->QueryPbData();
        m_cbAvailable = pIReq->QueryCbAvailable();
        m_cbTotal = pIReq->QueryCbTotalBytes();
        }
    else
        {
        m_pbAvailableData = NULL;
        m_cbAvailable = 0;
        m_cbTotal = 0;
        }

    if (m_szFormData)
        {
        m_szFormData[0] = '\0';
        m_szFormClone[0] = '\0';
        }

    if (m_szCookie)
        m_szCookie[0] = '\0';

    if (m_szClCert)
        m_szClCert[0] = '\0';

    return S_OK;
    }

/*===================================================================
CRequestData::GetEmptyStringList

Get empty string list's IDispatch *
Create empty string list on demand
===================================================================*/
HRESULT CRequestData::GetEmptyStringList
(
IDispatch **ppdisp
)
    {
    if (!m_pEmptyString)
        {
        m_pEmptyString = new CStringList;
        if (!m_pEmptyString)
            {
            *ppdisp = NULL;
            return E_FAIL;
            }
        }
    return m_pEmptyString->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppdisp));
    }

/*===================================================================
CRequestData::QueryInterface
CRequestData::AddRef
CRequestData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CRequestData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CRequestData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CRequestData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }

DWORD CRequestData::GetRequestEntityLimit()
{
    if (m_pHitObj)
        return m_pHitObj->QueryAppConfig()->dwRequestEntityLimit();
    else
        return DEFAULT_REQUEST_ENTITY_LIMIT;
}


/*------------------------------------------------------------------
 * C R e q u e s t
 */

/*===================================================================
CRequest::CRequest

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CRequest::CRequest(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pUnkFTM(NULL),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IRequest);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CRequest::~CRequest

Destructor

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
CRequest::~CRequest()
{
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count

    if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }
}

/*===================================================================
CRequest::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CRequest::CleanUp()
{
    if (m_pData)
    {
        m_pData->Release();
        m_pData = NULL;
    }

    return S_OK;
}

/*===================================================================
CRequest::Init

Allocates m_pData.
Performs any intiailization of a CRequest that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.
===================================================================*/

HRESULT CRequest::Init()
    {

    HRESULT hr = S_OK;
    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    // Create the FTM
    if (m_pUnkFTM == NULL)
    {
        hr = CoCreateFreeThreadedMarshaler((IUnknown*)((IRequestImpl*)this), &m_pUnkFTM );

        if ( FAILED(hr) )
        {
            Assert( m_pUnkFTM == NULL );
            return (hr);
        }
    }
    Assert( m_pUnkFTM != NULL );


    m_pData = new CRequestData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    hr = m_pData->Init();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CRequest::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CRequest::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    // Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)
	CoDisconnectObject(static_cast<IRequestImpl *>(this), 0);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
Request::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    CIsapiReqInfo *pIReq       CIsapiReqInfo
    CHitObj *pHitObj          HitObj

Returns:
    HRESULT
===================================================================*/

HRESULT CRequest::ReInit
(
CIsapiReqInfo *pIReq,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    return m_pData->ReInit(pIReq, pHitObj);
    }

/*===================================================================
CRequest::GetCodePage

GetCodePage from current HitObj

Parameters:

Returns:
    CodePage
===================================================================*/
UINT CRequest::GetCodePage()
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);
    return m_pData->m_pHitObj->GetCodePage();
    }

/*===================================================================
CRequest::LoadCookies

Load the Request map with values from the HTTP_COOKIE variable.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.

Bugs:
    This code assumes that dictionary cookies are well-formed.
    If they are not, then the results will be unpredictable.

    The dictionary cookies are gauranteed to be well-formed if
    Response.Cookies is used.  If other means, such as a direct
    use of the <META> tag, or if Response.SetCookie is used, we
    are at the mercy of the script writer.
===================================================================*/

HRESULT CRequest::LoadCookies(char *szData)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (szData == NULL)
        return S_OK;

    // Each cookie definition is moved to a buffer so that we don't
    // overwrite the value of HTTP_COOKIE.  We can save a strcpy()
    // call since 'DecodeFromURL' can copy for us.
    //

    size_t cbCookie = strlen(szData) + 1;

    if (cbCookie > m_pData->m_cbCookie)
    {
        char *pszCookie = static_cast <char*> ((m_pData->m_cbCookie == 0) ?
                              malloc(cbCookie) :
                              realloc(m_pData->m_szCookie, cbCookie));

        if (pszCookie == NULL)
        {
            //
            // Free up memory already allocated to the cookies
            //
            if(m_pData->m_szCookie)
            {
                free (m_pData->m_szCookie);
                m_pData->m_szCookie = NULL;
                m_pData->m_cbCookie = 0;
            }

            return E_OUTOFMEMORY;
        }

        m_pData->m_szCookie = pszCookie;
        m_pData->m_cbCookie = cbCookie;
    }

    char *szDest = m_pData->m_szCookie;
    char chDelimiter;           // delimiter that we found to stop the scan

    while (*szData != '\0')
        {
        char *szName, *szPartialValue;

        // Get the cookie name
        chDelimiter = DecodeFromURL(&szData, ";=", szName = szDest, GetCodePage(), FALSE);
        szDest = strchr(szDest, '\0') + 1;

        if (chDelimiter == '=')
            {
            // if DecodeFromURL stop scanning because of an equal sign, then the browser sent
            // a value for this cookie

            // Get the cookie's value
            chDelimiter = DecodeFromURL(&szData, ";=", szPartialValue = szDest, GetCodePage(), FALSE);
            szDest = strchr(szDest, '\0') + 1;

            // discard the denali session ID
            if (strncmp(szName, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
                {
                // DENALISESSIONID better not have non-alphabetics in it!  expecting
                // termination with ';' or NUL.
                //
                continue;
                }
            }
        else if (*szName == '\0')
            {
            continue;
            }
        else
            {
            // either we hit a ';' char or end of string.  In either case, this indicates that
            // the cookie has no value.  Set the szPartialValue to an empty string and set the
            // delimiter to ';' to trick the remainder of this function into thinking that the
            // cookie does have a value and that is a simple value (i.e. no sub-cookies).

            chDelimiter = ';';
            szPartialValue = "";
            }

        // Add this cookie to the Request
        CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, add it to the array of request hits
            if (!m_pData->m_Cookies.AddRequestHit(pRequestHit))
                {
                return E_OUTOFMEMORY;
                }
            }
        else if (pRequestHit->m_pCookieData)    // a cookie by this name already exists
            {
            if (chDelimiter == '=')                     // eat the rest of this cookie
                DecodeFromURL(&szData, ";", szDest, GetCodePage());    // no need to advance szDest

            continue;                               // discard later cookies
            }

        // The cookie value may be in the form <key1=value1&key2=value2...>
        // or not. If there is an '=' sign present, that lets us know if it
        // is a cookie dictionary or a simple value.
        //
        // We assume that '=' signs that are part of the cookie are escaped in hex.
        //
        if (chDelimiter != '=')
            {
            if (FAILED(hResult = pRequestHit->AddValue(COOKIE, szPartialValue, m_pData->m_pIReq, GetCodePage())))
                return hResult;
            }
        else
            {
            char *szKey = szPartialValue;     // already got the key
            for (;;)
                {
                char *szValue;
                chDelimiter = DecodeFromURL(&szData, ";&", szValue = szDest, GetCodePage(), FALSE);
                szDest = strchr(szDest, '\0') + 1;

                if (FAILED(hResult = pRequestHit->AddKeyAndValue(COOKIE, szKey, szValue, m_pData->m_pIReq, GetCodePage())))
                    return hResult;

                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                // get the key, exit when NUL terminator found
                chDelimiter = DecodeFromURL(&szData, "=;", szKey = szDest,  GetCodePage(), FALSE);
                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                szDest = strchr(szDest, '\0') + 1;
                }
            }

        }

        return S_OK;
    }


#define CB_CERT_DEFAULT     4096
/*===================================================================
CRequest::LoadClCerts

Load the Request map with values from the CIsapiReqInfo

Parameters:
    szData - ptr to CIsapiReqInfo

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/

HRESULT CRequest::LoadClCerts(char *szData, UINT lCodePage)
{
    HRESULT         hres = S_OK;
    CERT_CONTEXT_EX CertContextEx;
    CCertRequest    CertReq( this );

    STACK_BUFFER( tempCert, CB_CERT_DEFAULT );

    ZeroMemory( &CertContextEx, sizeof(CERT_CONTEXT_EX) );

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    CIsapiReqInfo *pIReq = reinterpret_cast<CIsapiReqInfo *>(szData);

    // allocate certificate buffer
    CertContextEx.cbAllocated = tempCert.QuerySize();
    CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

    // get certificate info from web server
    if ( !pIReq->ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX,
                                       &CertContextEx,
                                       NULL,
                                       NULL ) )
    {
        DWORD   dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            // buffer was too small - realloc and call again
            Assert( CertContextEx.cbAllocated < CertContextEx.CertContext.cbCertEncoded );
            CertContextEx.cbAllocated = CertContextEx.CertContext.cbCertEncoded;

            // If CB_CERT_DEFAULT wasn't enough, we want to allocate from the heap, rather then the stack

            if (tempCert.Resize(CertContextEx.cbAllocated) == FALSE) {
                hres = E_OUTOFMEMORY;
                goto LExit;
            }
            CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

            if ( !pIReq->ServerSupportFunction(
                                               HSE_REQ_GET_CERT_INFO_EX,
                                               &CertContextEx,
                                               NULL,
                                               NULL ) )
            {
                // if we fail a second time, just bail
                // NOTE this should never happen?
                dwErr = GetLastError();
                Assert(dwErr != ERROR_INSUFFICIENT_BUFFER);
                hres = HRESULT_FROM_WIN32(dwErr);
                goto LExit;
            }

        }
        else if ( dwErr == ERROR_INVALID_PARAMETER )
        {
            // not supported (old IIS)
            hres = S_OK;
            goto LExit;
        }
        else
        {
            hres = HRESULT_FROM_WIN32(dwErr);
            goto LExit;
        }
    }

    if(CertContextEx.CertContext.cbCertEncoded == 0)
    {
        hres = CertReq.NoCertificate();
    }
    else
    {
        hres = CertReq.ParseCertificate( CertContextEx.CertContext.pbCertEncoded,
                                         CertContextEx.CertContext.cbCertEncoded,
                                         CertContextEx.CertContext.dwCertEncodingType,
                                         CertContextEx.dwCertificateFlags,
                                         lCodePage );
    }


LExit:
    SecureZeroMemory( &CertContextEx, sizeof(CERT_CONTEXT_EX));
    return hres;

}



/*===================================================================
CRequest::LoadVariables

Load the Request map with values from a URL encoded string

WARNING:  This function modifies the passed szData!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter
    lCodePage   UINT, the codepage used in retrieving the data

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::LoadVariables(CollectionType Source, char *szData, UINT lCodePage)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (Source == COOKIE)                          // cookies are a special case
        return LoadCookies(szData);                // handle them specially

    if (Source == CLCERT)                          // clcerts are a special case
        return LoadClCerts(szData, lCodePage);     // handle them specially

    if (szData == NULL)         // treat NULL as "no data available"
        return S_OK;

    if (Source == QUERYSTRING) {

        if (m_pData->m_szQueryString) {
            free(m_pData->m_szQueryString);
        }
        if (!(m_pData->m_szQueryString = (char *)malloc(strlen(szData)+1)))
            return E_OUTOFMEMORY;

        strcpy(m_pData->m_szQueryString, szData);
        szData = m_pData->m_szQueryString;
    }

    while (*szData != '\0')
        {
        char *szName, *szValue;

        DecodeFromURL(&szData, "=", szName = szData,  lCodePage, FALSE);
        DecodeFromURL(&szData, "&", szValue = szData, lCodePage, FALSE);

        // this is to handle the case where an un-named pair was passed.
        // skip it and process the next named pair
        //
        if(*szName == '\0')
            continue;

        CRequestHit *pRequestHit = static_cast<CRequestHit *>
            (
            GetStrings()->FindElem(szName, strlen(szName))
            );
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, so we should add it
            // to the array of request
            if (Source == QUERYSTRING)
                {
                if (!m_pData->m_QueryString.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            else if (Source == FORM)
                {
                if (!m_pData->m_FormInputs.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            }

        if (FAILED(hResult = pRequestHit->AddValue(Source, szValue, m_pData->m_pIReq, lCodePage)))
            return hResult;

        }

    return S_OK;
    }

/*===================================================================
CRequest::QueryInterface
CRequest::AddRef
CRequest::Release

IUnknown members for CRequest object.
===================================================================*/

STDMETHODIMP CRequest::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IRequest || iid == IID_IDenaliIntrinsic)
        *ppvObj = static_cast<IRequest *>(this);

    else if (iid == IID_ISupportErrorInfo)
        {
        if (m_pData)
            *ppvObj = &(m_pData->m_ISupportErrImp);
        }

    // Support IStream for ADO/XML
    else if (iid == IID_IStream )
        {
        *ppvObj = static_cast<IStream *>(this);
        }

    else if (IID_IMarshal == iid)
        {
            Assert( m_pUnkFTM != NULL );

            if ( m_pUnkFTM == NULL )
            {
                return E_UNEXPECTED;
            }

            return m_pUnkFTM->QueryInterface( iid, ppvObj);

        }

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequest::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CRequest::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CRequest::CheckForTombstone

Tombstone stub for IRequest methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CRequest::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IRequest,
        IDE_REQUEST,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CRequest::get_QueryString

Return the QueryString dictionary
===================================================================*/

HRESULT CRequest::get_QueryString(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_QueryString.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }


/*===================================================================
CRequest::get_Form

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_Form(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Body

Return the Body dictionary (alias for Form dictionary)
===================================================================*/

HRESULT CRequest::get_Body(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Cookies

Return the Cookies dictionary
===================================================================*/

HRESULT CRequest::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_Cookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ClientCertificate

Return the ClCerts dictionary
===================================================================*/

HRESULT CRequest::get_ClientCertificate(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ClCerts.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ServerVariables

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_ServerVariables(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ServerVariables.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Item

Function called from DispInvoke to get values from any one of four
collections. Search order is "ServerVariables", "QueryString",
"Form", "Cookies", "ClientCertificate"

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pVarReturn  VARIANT *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::get_Item(BSTR bstrName, IDispatch **ppDispReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    UINT            lCodePage = GetACP();
    CWCharToMBCS    convName;
    char            *szName;

    // If BinaryRead has been called, the Form collection is no longer available
    // so we insist that the script writer specify which collection to use
    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_GENERICCOLLECTION_NA);
        return E_FAIL;
        }

    // At this point, we are forced to load the QueryString, Form, Cookies
    // and ClientCertificate
    // collections even though it will only come from one of these.
    //
    if (m_pData->m_fLoadQuery)
        {
        // QueryString can contains DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(QUERYSTRING, GetIReq()->QueryPszQueryString(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadQuery = FALSE;
        }

    if (m_pData->m_fLoadCookies)
        {
        char *szCookie = GetIReq()->QueryPszCookie();

        if (FAILED(LoadVariables(COOKIE, szCookie, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadCookies = FALSE;
        }

    if (m_pData->m_fLoadClCerts)
        {
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(CLCERT, (char*)GetIReq(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadClCerts = FALSE;
        }

    if (m_pData->m_fLoadForm)
        {
        HRESULT hrGetData = CopyClientData();
        if (FAILED(hrGetData))
            return hrGetData;

        // Form can contain DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(FORM, m_pData->m_szFormData, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadForm = FALSE;
        }

    // Convert name to ANSI
    //
    HRESULT hr;
    if (FAILED(hr = convName.Init(bstrName, lCodePage))) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return hr;
        }
        hr = NO_ERROR;
        szName = "";
    }
    else {
        szName = convName.GetString();
    }
    // Look up the name in the collections
    //
    CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
    if (pRequestHit)
        {
        IUnknown *pValues = NULL;
        if (pRequestHit->m_pQueryData)
            pValues = pRequestHit->m_pQueryData;

        else if (pRequestHit->m_pFormData)
            pValues = pRequestHit->m_pFormData;

        else if (pRequestHit->m_pCookieData)
            pValues = pRequestHit->m_pCookieData;

        else if (pRequestHit->m_pClCertData)
            pValues = pRequestHit->m_pClCertData;

        if (pValues == NULL)
            goto NotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppDispReturn))))
            return E_FAIL;

        return S_OK;
        }

NotFound:
    // Look in server variables
    VARIANT varKey, varValue;

    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstrName;

    if (m_pData->m_ServerVariables.get_Item(varKey, &varValue) == S_OK)
        {
        Assert (V_VT(&varValue) == VT_DISPATCH);
        *ppDispReturn = V_DISPATCH(&varValue);

        return S_OK;
        }

    if (FAILED(m_pData->GetEmptyStringList(ppDispReturn)))
        return E_FAIL;

    return S_OK;
    }



/*===================================================================
CRequest::CopyClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer
===================================================================*/

HRESULT CRequest::CopyClientData()
{
    HRESULT hr = S_OK;

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    STACK_BUFFER(tempContent, 1024 );

    CIsapiReqInfo *pIReq = m_pData->m_pIReq;

    // assert that the data is in the format we want
    //
	// we need to scan the content type for the supported header,
	// the client my send multiple headers so use strstr to search
	// the header string this is a HOT_FIX for NT BUG:208530
	//
	if (pIReq->QueryPszContentType())
    {
        size_t cbQueryPszContentType = (strlen(pIReq->QueryPszContentType()) + 1);
        if (cbQueryPszContentType > REQUEST_ALLOC_MAX)
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            return E_FAIL;
        }

        if (tempContent.Resize(cbQueryPszContentType) == FALSE)
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return E_FAIL;
        }

        CHAR *szQueryPszContentType = _strlwr(
							        strcpy(
								        static_cast<char *>(tempContent.QueryPtr()),
								        pIReq->QueryPszContentType()
								        ));
        if (strstr(szQueryPszContentType, "application/x-www-form-urlencoded") == NULL)
            return S_OK;
    }
	else
		return S_OK;

	//
	// Determine if it is chunked or not.
	//
    DWORD dwVarSize = 0;
    STACK_BUFFER( varBuff, 128 );

    if (SERVER_GET(pIReq, "HTTP_TRANSFER_ENCODING", &varBuff, &dwVarSize) &&
        (!stricmp(static_cast<char *>(varBuff.QueryPtr()),"chunked")))
          hr = CopyChunkedClientData();
    else
        hr = CopyNonChunkedClientData();

    // Clone the data (LoadVariables will destroy the data)

    // Allocate memory for clone. It should theoritically be equal to the size of FormData.
    if (SUCCEEDED(hr))
    {
        m_pData->m_szFormClone = static_cast<char *>(malloc(m_pData->m_cbFormData));
        if (m_pData->m_szFormClone == NULL)
            return E_OUTOFMEMORY;

        // Actually perform the copy of data.
        memcpy(m_pData->m_szFormClone, m_pData->m_szFormData, m_pData->m_cbFormData);
    }

    return hr;
}

	
/*===================================================================
CRequest::CopyChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when Data is being sent in a chunks.
===================================================================*/
HRESULT CRequest::CopyChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;

    // Try to initially allocate units 4K,16K,32K....
    // For the current implementation we shall stop at 32K
    // Which will bring us to an allocation of (48) +4+8+16+32 +32 +32 + .....
    //
    DWORD allocUnit = 4096;    // 0001 0000 0000 0000 B

    DWORD cbAvailable = pIReq->QueryCbAvailable();

    // Copy the data available and 1 byte for NULL_TERMINATOR.
    DWORD cbFormData = (cbAvailable + 1);

    // Check for rollover. If cbAvailable is greater than cbAvailable+1 then "Houston, we have a problem."
    if (cbAvailable >= cbFormData || cbAvailable > m_pData->GetRequestEntityLimit())
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    // Alloc the 4K extra memory.
    cbFormData += allocUnit;

    // Check again for overflow. Be paranoid.
    if (cbAvailable >= cbFormData)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    char * pszFormData = m_pData->m_szFormData;; // The pointer to the previous memory location in case realloc fails.


    if (m_pData->m_cbFormData == 0)
    {
        m_pData->m_cbFormData = cbFormData;
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData));
    }
    else if (cbFormData > m_pData->m_cbFormData)
    {
        m_pData->m_cbFormData = cbFormData;
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData));
    }

    if (m_pData->m_szFormData == NULL)
    {
        if (pszFormData)
            free (pszFormData);
        m_pData->m_cbFormData = 0;

        return E_OUTOFMEMORY;
    }

    char * pszOffset;
    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    memcpy( m_pData->m_szFormData,
            pIReq->QueryPbData(),
            cbAvailable );

    pszOffset = m_pData->m_szFormData + cbAvailable;
    DWORD cBytesToRead = allocUnit;
    DWORD cBytesRead = cBytesToRead;

    DWORD cbCurrentFormData = cbFormData;

    //
    // Call ReadClient until we have read all the data
    //
    while (cBytesToRead > 0)
    {
        if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
            break;

        cBytesToRead -= cBytesRead;

        if ((DIFF(pszOffset - m_pData->m_szFormData) + cBytesRead) > m_pData->GetRequestEntityLimit())
        {
            // We exceeded the requestEntity limit
            free (m_pData->m_szFormData);
            m_pData->m_szFormData = NULL; // So that the destructor will not free it too.
            m_pData->m_cbFormData = 0;

            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
            return E_FAIL;
        }


        if (cBytesToRead == 0)
        {
            // Dont allocatate anything larger than 32K unit else double the size of the allocation Unit.
            if (allocUnit < 0x8000)
                allocUnit = allocUnit << 1;

            cbCurrentFormData = cbFormData;

            // Adjust buffer size
            cbFormData += allocUnit;

            // save pointer to location before realloc in case of failure.
            pszFormData =  m_pData->m_szFormData;

            if (cbCurrentFormData >= cbFormData)
            {
                // A rollover occurred, we need to free the memory and return failure.
                if (pszFormData)
                {
                    free (pszFormData);
                    m_pData->m_szFormData = NULL;
                }
                m_pData->m_cbFormData = 0;

                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
                return E_FAIL;
            }

            // Allocate new memory.
            m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData,
                            m_pData->m_cbFormData = cbFormData));
            // Check for out of memory.
            if (m_pData->m_szFormData == NULL)
            {
                if (pszFormData)
                    free (pszFormData);
                m_pData->m_cbFormData = 0;

                return E_OUTOFMEMORY;
            }

            // Adjust offset.
            // Need to subtract 1 to compensate for the '\0' which we have allocated memory for
            // while calculating cbFormData. The '\0' will be added at the very end.
            pszOffset = m_pData->m_szFormData + cbFormData - allocUnit -1;
            cBytesToRead = allocUnit;

        }
        else
        {
            pszOffset += cBytesRead;
        }
        cBytesRead = cBytesToRead;
    }

    //
    // Adjust cbFormData to read the currect count of data.
    //
    m_pData->m_cbFormData -= cBytesToRead;

    //
    // Add the NULL terminator. The -1 is necessary to compensate for the +1 during cbFormData.
    //
    m_pData->m_szFormData[m_pData->m_cbFormData - 1] = '\0';

    return S_OK;
}
	
/*===================================================================
CRequest::CopyNonChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when the Content Length is known and
===================================================================*/
HRESULT CRequest::CopyNonChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;
    //
    // Allocate enough space for the form data and a copy
    //

    size_t cbTotal = pIReq->QueryCbTotalBytes();

    // Copy the data available and 1 byte for NULL_TERMINATOR.
    size_t cbFormData = (cbTotal + 1);

    // Check for rollover. If cbAvailable is greater than cbAvailable+1 then "Houston, we have a problem."
    if (cbTotal >= cbFormData || cbTotal > m_pData->GetRequestEntityLimit())
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    char * pszFormData = m_pData->m_szFormData;

    if (m_pData->m_cbFormData == 0)
    {
        m_pData->m_cbFormData = cbFormData;
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData));
    }
    else if (cbFormData > m_pData->m_cbFormData)
    {
        m_pData->m_cbFormData = cbFormData;
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData));
    }

    if (m_pData->m_szFormData == NULL)
    {
        if (pszFormData)
            free (pszFormData);
        m_pData->m_cbFormData = 0;

        return E_OUTOFMEMORY;
    }

    char * pszOffset;

    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // Load the data
    //
    if (pIReq->QueryCbTotalBytes() <= pIReq->QueryCbAvailable())
        {
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbTotalBytes() ); // bytes are available now
        }
    else
        {
        // Some bytes are in the CIsapiReqInfo buffer, we must call ReadClient for others
        // First copy the data in the CIsapiReqInfo buffer
        //
        // To fall into this case, QueryCbAvailable should be less than cbTotal.
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbAvailable() );

        DWORD cBytesToRead = pIReq->QueryCbTotalBytes() - pIReq->QueryCbAvailable();
        DWORD cBytesRead = cBytesToRead;
        pszOffset = m_pData->m_szFormData + pIReq->QueryCbAvailable();

        // Call ReadClient until we have read all the data
        //
        while (cBytesToRead > 0)
            {
            if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
            {
                // Client closed the connection. We need to free allocated memory.
                if (m_pData->m_szFormData)
                {
                    free (m_pData->m_szFormData);
                    m_pData->m_szFormData = NULL;
                    m_pData->m_cbFormData = 0;
                }
                return E_FAIL;
            }

            cBytesToRead -= cBytesRead;
            pszOffset += cBytesRead;
            cBytesRead = cBytesToRead;
            }
        }
    m_pData->m_szFormData[pIReq->QueryCbTotalBytes()] = '\0';


    return S_OK;

}

/*===================================================================
CResponse::GetRequestIterator

Provide a default implementation of get__NewEnum for the Request
collections because most of the collections can use this
implementation.

Parameters:
    Collection - the type of iterator to create
    ppEnumReturn - on return, this points to the new enumeration

Returns:
    Can return E_FAIL or E_OUTOFMEMORY

Side effects:
    None.
===================================================================*/

HRESULT CRequest::GetRequestEnumerator(CollectionType WhichCollection, IUnknown **ppEnumReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(this, WhichCollection);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary,
                    IDE_REQUEST,
                    (hrInit == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponse::get_TotalBytes

Presents the number of bytes to expect in the request body

Parameters:
    pcBytes - pointer to long where we will place the number
              of bytes to expect in the request body

Returns:
    Can return E_FAIL

Side effects:
    None.
===================================================================*/

HRESULT CRequest::get_TotalBytes(long *pcbTotal)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (pcbTotal == NULL)
        return E_FAIL;

    Assert(m_pData->m_pIReq);
    *pcbTotal = (long) m_pData->m_pIReq->QueryCbTotalBytes();
    return S_OK;
    }

/*===================================================================
CResponse::BinaryRead

Read bytes from the Request Body to a SafeArray of VT_U1.

Parameters:
     pvarCount     - pointer to variant where we will find the number
                  of bytes to read in the request body, and where
                  we will store the number of bytes we read.

     pvarReturn - pointer to variant that will contain the SafeArray we create


Returns:
    HRESULT

Side effects:
    Allocates memory.
===================================================================*/

HRESULT CRequest::BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    SAFEARRAYBOUND rgsabound[1];
    size_t cbToRead = 0;
    size_t cbRead = 0;
    BYTE *pbData = NULL;

    Assert(m_pData->m_pIReq);
    Assert(pvarCount);
    Assert(pvarReturn);

    // Set the variant type of the output parameter
    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    if (m_pData->m_FormDataStatus == FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINARYREAD_NA);
		hr = E_FAIL;
		goto error;
        }

    // Convert the byte count variant to a long
    if (FAILED(hr = VariantChangeTypeEx(pvarCount, pvarCount, m_pData->m_pHitObj->GetLCID(), 0,  VT_I4)))
        {
        switch (hr)
            {
            case E_OUTOFMEMORY:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_OOM);
                break;
            case DISP_E_OVERFLOW:
                hr = E_FAIL;
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_RESPONSE_UNABLE_TO_CONVERT);
                break;
            case DISP_E_TYPEMISMATCH:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_TYPE_MISMATCH);
                break;
            default:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_UNEXPECTED);
            }
            goto error;
        }

    cbToRead = V_I4(pvarCount);
    V_I4(pvarCount) = 0;

	if ((signed long) cbToRead < 0)
		{
		ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINREAD_BAD_ARG);
		hr = E_FAIL;
		goto error;
		}


    // If 0 bytes are requested, or available we're done
    if (cbToRead == 0 || m_pData->m_cbTotal == 0)
        return S_OK;

    // Allocate a SafeArray for the data
    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    rgsabound[0].lLbound = 0;
    if (cbToRead > m_pData->m_cbTotal)
        cbToRead = m_pData->m_cbTotal;

    // If more than RequestEntityLimit bytes have been requested return failure.
    // Since we allocate cbToRead and finally copy only cbToRead this is a safe place to check
    if (cbToRead > m_pData->GetRequestEntityLimit())
    {
    	ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
		hr = E_FAIL;
		goto error;	
    }

    rgsabound[0].cElements = cbToRead;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto error;
        }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
        hr = E_UNEXPECTED;
        goto error;
        }

    // There is no turning back now. The Request.Form collection will
    // no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
        {
        m_pData->m_FormDataStatus = BINARYREADONLY;
        m_pData->m_fLoadForm = FALSE;
        }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy
    // of the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    if (cbToRead <= m_pData->m_cbAvailable)
        {
        memcpy(pbData, m_pData->m_pbAvailableData, cbToRead);
        m_pData->m_pbAvailableData += cbToRead;
        m_pData->m_cbAvailable -= cbToRead;
        m_pData->m_cbTotal -= cbToRead;
        V_I4(pvarCount) = cbToRead;
        }
    else
        {
        if (m_pData->m_cbAvailable > 0)
            {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            V_I4(pvarCount) = m_pData->m_cbAvailable;
            cbToRead -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
            }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;
        while (cbToRead)
            {
            cbRead = cbToRead;
            if (!GetIReq()->SyncReadClient(pbData, (DWORD *)&cbRead) || (cbRead == 0))
                {
                SafeArrayUnaccessData(V_ARRAY(pvarReturn));
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
                hr = E_FAIL;
                goto error;
                }
            pbData += cbRead;
            V_I4(pvarCount) += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cbToRead -= cbRead;
            }
    }

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));
    return S_OK;

error:
    VariantClear(pvarReturn);
    return(hr);
    }


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CRequest::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    if (pv == NULL)
        return E_POINTER;

    ULONG cbReadDummy;
    if (pcbRead == NULL)
        pcbRead = &cbReadDummy;

    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != ISTREAMONLY)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                    IDE_REQUEST_STREAMONLY);
        return E_FAIL;
    }

    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    if (cb > m_pData->m_cbTotal)
        cb = m_pData->m_cbTotal;

    // If they requested more data than we have have set in the RequestEntityLimit return a NOT Allowed error.
    // Since cb is the maximum data that will be copied. It is safe to do the check here.
    if (cb > m_pData->GetRequestEntityLimit())
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
        return E_FAIL;
    }

    // There is no turning back now. The Request.Form collection and
    // Request.BinaryRead will no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
    {
        m_pData->m_FormDataStatus = ISTREAMONLY;
        m_pData->m_fLoadForm = FALSE;
    }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy of
    // the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    BYTE* pbData = static_cast<BYTE*>(pv);

    if (cb <= m_pData->m_cbAvailable)
    {
        memcpy(pbData, m_pData->m_pbAvailableData, cb);
        m_pData->m_pbAvailableData += cb;
        m_pData->m_cbAvailable -= cb;
        m_pData->m_cbTotal -= cb;
        *pcbRead = cb;
    }
    else
    {
        *pcbRead = 0;
        if (m_pData->m_cbAvailable > 0)
        {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            *pcbRead = m_pData->m_cbAvailable;
            cb -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
        }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;

        while (cb > 0)
        {
            DWORD cbRead = cb;
            if ((!GetIReq()->SyncReadClient(pbData, &cbRead)) || (cbRead == 0))
            {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                            IDE_UNEXPECTED);
                return E_FAIL;
            }
            pbData += cbRead;
            *pcbRead += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cb -= cbRead;
        }
    }

    return S_OK;
}


STDMETHODIMP CRequest::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    return E_NOTIMPL;
}


STDMETHODIMP CRequest::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    // We can only do a seek if we're in the first, pre-read portion of the
    // form data
    if (m_pData->m_pbAvailableData == NULL)
        return E_FAIL;

    BYTE* pbAvailableData;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        // relative to beginning of stream
        pbAvailableData = m_pData->m_pIReq->QueryPbData() + dlibMove.LowPart;
        break;
    case STREAM_SEEK_CUR:
        // relative to current position in stream
        pbAvailableData = m_pData->m_pbAvailableData + dlibMove.LowPart;
        break;
    case STREAM_SEEK_END:
        // relative to end of stream; not supported
        return E_FAIL;
    };

    // Does the new offset fall within the initial header?
    if (m_pData->m_pIReq->QueryPbData() <= pbAvailableData
        &&  pbAvailableData < m_pData->m_pIReq->QueryPbData()
                              + m_pData->m_pIReq->QueryCbAvailable())
    {
        DWORD dwDiff = DIFF(pbAvailableData - m_pData->m_pIReq->QueryPbData());
        m_pData->m_pbAvailableData = pbAvailableData;
        m_pData->m_cbAvailable = m_pData->m_pIReq->QueryCbAvailable() - dwDiff;
        m_pData->m_cbTotal = m_pData->m_pIReq->QueryCbTotalBytes() - dwDiff;
        // Return the new position, if wanted
        if (plibNewPosition != NULL)
            plibNewPosition->LowPart = dwDiff;
        return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CRequest::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}


#ifdef DBG
/*===================================================================
CRequest::AssertValid

Test to make sure that the CRequest object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CRequest::AssertValid() const
    {
    }
#endif // DBG



/*===================================================================
HexToChar

Convert two digit hex string to a hex byte

Parameters:
    szHex - pointer to two digit hex string

Return Value:
    the character value of the hex string
===================================================================*/

char HexToChar(LPSTR szHex)
    {
    char chResult, chDigit;

    chDigit = (char)CharUpperA((LPSTR)szHex[0]);
    chResult = (chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0')) << 4;

    chDigit = (char)CharUpperA((LPSTR)szHex[1]);
    chResult |= chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0');

    return chResult;
    }



/*===================================================================
DecodeFromURL

Convert two digit hex string to a hex byte

WARNING:  This function modifies the passed pszSource!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    pszSource    - in/out parameter points to a substring in the URL which
                   contains a Name=Value pair
    szDelimiters - a set of delimiters for this field
    szDest       - pointer to buffer to hold the substring

Return Value:
    Returns the actual delimiter that caused parsing to halt.
===================================================================*/

char DecodeFromURL(char **pszSource, char *szDelimiters, char *szDest, UINT uCodePage, BOOL fIgnoreCase)
    {
    char  ch;
    char *szSource = *pszSource;
    char *pszDestStart = szDest;
    CPINFO  CpInfo;
    BOOL    fIschLeadingByte = TRUE;
    BOOL    InvalidPercent = FALSE;

    GetCPInfo(uCodePage, (LPCPINFO)&CpInfo);

    while ((ch = *szSource++) != '\0' &&
        ((!strchr(szDelimiters, ch) && fIschLeadingByte) || (!fIschLeadingByte))) {
        InvalidPercent = FALSE;
        switch (ch) {
            case ' ':       // skip whitespace - assume that all whitespace that we need is escaped
            case '\t':      // all these chars are out of trailing byte range
            case '\r':
            case '\n':
            case '\f':
            case '\v':
                Assert(fIschLeadingByte);
                continue;

            case '+':       // '+' is out of trailing byte range, can never be a trailing byte
                *szDest++ = ' ';
                Assert(fIschLeadingByte);
                break;

            case '%':       // '%' is out of trailing byte range, can never be a trailing byte
                if (*szSource == 'u') {
                    if (isxdigit((UCHAR)*(szSource+1)) &&
                        isxdigit((UCHAR)*(szSource+2)) &&
                        isxdigit((UCHAR)*(szSource+3)) &&
                        isxdigit((UCHAR)*(szSource+4))) {
	                    WCHAR   wch[2];
                        int     cch = 1;
    	                wch[0] =  (UCHAR)HexToChar(&szSource[1]) << 8;
        	            wch[0] |= (UCHAR)HexToChar(&szSource[3]);
            	        szSource += 5;

                        // if the current UNICODE value falls into the
                        // range of valid high-Surrogate, check to see if
                        // the next character is in the low-Surrogate
                        // range.

                        if (IsSurrogateHigh(wch[0])
                            && (szSource[0] == '%')
                            && (szSource[1] == 'u')
                            && isxdigit((UCHAR)szSource[2])
                            && isxdigit((UCHAR)szSource[3])
                            && isxdigit((UCHAR)szSource[4])
                            && isxdigit((UCHAR)szSource[5])) {

                            // Well, the current UNICODE value is in the high
                            // range and the next portion of the string is
                            // a UNICODE encoding.  Decode it.

                            wch[1] = (UCHAR)HexToChar(&szSource[2]) << 8;
                            wch[1] |= (UCHAR)HexToChar(&szSource[4]);

                            // Now see if it falls in the range of low-Surrogates

                            if (IsSurrogateLow(wch[1])) {

                                // it does!!!  Up the number of characters in the
                                // string that WideCharToMultiByte is going to
                                // convert.  And advance the source string past this
                                // location.

                                cch = 2;
                                szSource += 6;
                            }
                        }
                	    szDest += WideCharToMultiByte( uCodePage, 0, wch, cch, szDest, 6, NULL, NULL );
                    } else {
                        // What to do here ?
                        // since we have at least the u char after the %,
                        // keep the u and let the show go on
                    }
                    break;
                }
                else {
                    if (isxdigit((UCHAR)*szSource) && isxdigit((UCHAR)*(szSource+1))) {
                        ch = HexToChar(szSource);
		                szSource += 2;
                    }
                    else
                    {
                         // the spurious encoding MUST be removed
                         InvalidPercent = TRUE;
                    }
                }
                // FALL THROUGH to "Normal" case

            default:
                if (fIschLeadingByte == TRUE) {
                    if (CpInfo.MaxCharSize > 1) {
                        // if this is a Leading byte, then, the next one is a trailing byte, we need
                        // not process the next char even the next char is in szDelimiter, next char
                        // is just the second byte of a DBCS char.
                        if (IsDBCSLeadByteEx(uCodePage, ch))
                            fIschLeadingByte = FALSE;
                    }
                }
                else {   // A trailing byte
                    // If we skip a DBCS trailing byte, then, the next char we check is a leading byte
                    Assert(CpInfo.MaxCharSize == 2);
                    fIschLeadingByte = TRUE;
                }
                if (!InvalidPercent) {
                    *szDest++ = ch;
                }
        }
    }

    if (ch == '\0')     // End of String - undo increment of szSource
        --szSource;

    *szDest = '\0';

    if (fIgnoreCase)
        CharUpperA(pszDestStart);

    *pszSource = szSource;

    return ch;
    }




/*------------------------------------------------------------------
 * C S e r v V a r s I t e r a t o r
 */

/*===================================================================
CServVarsIterator::CServVarsIterator

Constructor
===================================================================*/

CServVarsIterator::CServVarsIterator()
    {
    m_rgwszKeys   = NULL;
    m_pwszKey     = NULL;
    m_pwchAllHttp = NULL;
    m_cRefs       = 1;
    m_cKeys       = 0;
    }



/*===================================================================
CServVarsIterator::~CServVarsIterator

Destructor
===================================================================*/

CServVarsIterator::~CServVarsIterator()
    {
    delete m_rgwszKeys;
    delete m_pwchAllHttp;
    }



/*===================================================================
CServVarsIterator::Init

Initialize the iterator by:

    * Getting the value of ALL_HTTP, and parsing it to get the
      extra keys

    * creating a dynamic memory area to hold the ALL_HTTP keys

    * setting m_rgwszKeys by copying pointers from rgwszStandardKeys
      and from ALL_HTTP keys

Parameters:
    pIReq - pointer to CIsapiReqInfo used to query for extra headers

Return Value:
    Returns E_OUTOFMEMORY or S_OK
===================================================================*/

HRESULT CServVarsIterator::Init
(
CIsapiReqInfo *pIReq
)
    {
    static wchar_t *rgwszStandardKeys[] = {
                                            L"ALL_HTTP",
                                            L"ALL_RAW",
                                            L"APPL_MD_PATH",
                                            L"APPL_PHYSICAL_PATH",
                                            L"AUTH_PASSWORD",
                                            L"AUTH_TYPE",
                                            L"AUTH_USER",
                                            L"CERT_COOKIE",
                                            L"CERT_FLAGS",
                                            L"CERT_ISSUER",
                                            L"CERT_KEYSIZE",
                                            L"CERT_SECRETKEYSIZE",
                                            L"CERT_SERIALNUMBER",
                                            L"CERT_SERVER_ISSUER",
                                            L"CERT_SERVER_SUBJECT",
                                            L"CERT_SUBJECT",
                                            L"CONTENT_LENGTH",
                                            L"CONTENT_TYPE",
                                            L"GATEWAY_INTERFACE",
// Purposely left out of IIS 4.0            L"HTTP_CFG_ENC_CAPS",
// Purposely left out of IIS 4.0            L"HTTP_REQ_PWD_EXPIRE",
// Purposely left out of IIS 4.0            L"HTTP_REQ_REALM",
                                            L"HTTPS",
                                            L"HTTPS_KEYSIZE",
                                            L"HTTPS_SECRETKEYSIZE",
                                            L"HTTPS_SERVER_ISSUER",
                                            L"HTTPS_SERVER_SUBJECT",
                                            L"INSTANCE_ID",
                                            L"INSTANCE_META_PATH",
                                            L"LOCAL_ADDR",
                                            L"LOGON_USER",
                                            L"PATH_INFO",
                                            L"PATH_TRANSLATED",
                                            L"QUERY_STRING",
                                            L"REMOTE_ADDR",
                                            L"REMOTE_HOST",
                                            L"REMOTE_USER",
                                            L"REQUEST_METHOD",
// Deleted bogus variable in IIS 4.0        L"SCRIPT_MAP",
                                            L"SCRIPT_NAME",
                                            L"SERVER_NAME",
                                            L"SERVER_PORT",
                                            L"SERVER_PORT_SECURE",
                                            L"SERVER_PROTOCOL",
                                            L"SERVER_SOFTWARE",
// Purposely left out of IIS 4.0            L"UNMAPPED_REMOTE_USER",
                                            L"URL"
                                            };

    const int cStandardKeys = sizeof(rgwszStandardKeys) / sizeof(rgwszStandardKeys[0]);

    // Style note:
    //
    //  pwchExtraKeys points not to just one NUL terminated wide string
    //  but a whole sequence of NUL terminated wide string followed by
    //  a double NUL terminator.  I therefore chose not to use the
    //  standard "wsz" hungarian prefix, instead using "pwch" as
    //  "pointer to wide characters"
    //
    int cwchAlloc = 0, cRequestHeaders = 0;
    DWORD dwHeaderSize = 0;

    STACK_BUFFER( extraKeysBuff, 2048 );

    if (!SERVER_GET(pIReq, "ALL_HTTP", &extraKeysBuff, &dwHeaderSize)) {
        if (GetLastError() == ERROR_OUTOFMEMORY) {
            return E_OUTOFMEMORY;
        }
        else {
            return E_FAIL;
        }
    }

    char            *szExtraKeys = (char *)extraKeysBuff.QueryPtr();
    CMBCSToWChar    convStr;
    HRESULT         hrConvResult;

    if (FAILED(hrConvResult = convStr.Init(szExtraKeys))) {
        return hrConvResult;
    }

    wchar_t *pwchExtraKeys = convStr.GetString();

    if (!CreateKeys(pwchExtraKeys, &cwchAlloc, &cRequestHeaders))
        return E_FAIL;

    // At this point, pwchExtraKeys has the strings.  Copy them
    // into more permanent storage.
    //
    if (cwchAlloc)
        {
        Assert(pwchExtraKeys != NULL);
        if ((m_pwchAllHttp = new wchar_t [cwchAlloc]) == NULL)
            return E_OUTOFMEMORY;

        memcpy(m_pwchAllHttp, pwchExtraKeys, cwchAlloc * sizeof(wchar_t));
        }
    else
        m_pwchAllHttp = NULL;

    // Allocate the array of keys, m_rgwszKeys, and copy the standard
    // ISAPI keys, the extra keys from the request headers, and a
    // terminating NULL to easily mark the end of an iteration.
    //
    if ((m_rgwszKeys = new wchar_t *[cStandardKeys + cRequestHeaders + 1]) == NULL)
        return E_OUTOFMEMORY;

    m_cKeys = cStandardKeys + cRequestHeaders;

    wchar_t **pwszKey = m_rgwszKeys;
    int i;

    for (i = 0; i < cStandardKeys; ++i)
        *pwszKey++ = rgwszStandardKeys[i];

    wchar_t *pwch = m_pwchAllHttp;
    for (i = 0; i < cRequestHeaders; ++i)
        {
        *pwszKey++ = pwch;
        pwch = wcschr(pwch, L'\0') + 1;
        }

    // make sure that cRequestHeaders was equal to the actual number of strings
    // in the pwchAllHttp string table.  (Do this by making sure that we stored
    // the exact amount of bytes and are now at the NULL terminator)
    //
    Assert (*pwch == L'\0' && (pwch - m_pwchAllHttp + 1) == cwchAlloc);

    *pwszKey = NULL;                // terminate the array
    return Reset();                 // reset the iterator
    }



/*===================================================================
CServVarsIterator::CreateKeys

Parse the string from Request.ServerVariables["ALL_HTTP"], then
transform the string into a list of NUL terminated wide strings
in place, terminated with a double NUL.

Parameters:
    pwchKeys -
        Input: Contains the value of Request.ServerVariables["ALL_HTTP"]
                as a wide string

        Output: Contains the keys from Request.ServerVariables["ALL_HTTP"],
                each key is separated by a NUL terminator, and the entire
                list of keys is terminated by a double NUL.

    pwchAlloc -
        Output: Contains the number of wide characters that should be
                allocated to contain the entire list of strings pointed
                to by pwchKeys

    pcRequestHeaders -
        Output: Contains the number of keys that were found in
                Request.ServerVariables["ALL_HTTP"].

Return Value:
    TRUE if successful
===================================================================*/

BOOL CServVarsIterator::CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders)
    {
    wchar_t *pwchSrc = pwchKeys;            // source
    wchar_t *pwchDest = pwchKeys;           // destination

    if (pwchKeys == NULL)
        {
        *pcwchAlloc = 0;
        *pcRequestHeaders = 0;
        return TRUE;
        }

    // Loop over pwchKeys until we hit the NUL terminator
    //
    *pcRequestHeaders = 0;
    while (*pwchSrc)
        {
        // Copy characters up to the ':' and store in pwchDest
        //
        while (*pwchSrc != L':')
            {
            if (*pwchSrc == L'\0')     // better not find End of String yet
                return FALSE;

            *pwchDest++ = *pwchSrc++;
            }

        // now NUL terminate pwchDest, advance pwchSrc, increment cRequestHeaders
        //
        *pwchDest++ = L'\0';
        ++pwchSrc;
        ++*pcRequestHeaders;

        // Skip characters until we find a \r OR \n
        //
        // If wcspbrk returns NULL here, it means there was no terminating
        // \r or \n.  In this case we can exit the loop because there
        // are no more keys (the value must have ran to the end of the
        // string without termination)
        //
        pwchSrc = wcspbrk(pwchSrc, L"\r\n");
        if (! pwchSrc)
            break;

        // we found either \r OR \n. Skip the remaining whitspace char.
        //
        while (*pwchSrc == L'\r' || *pwchSrc == L'\n')
            ++pwchSrc;

        // pwchSrc now points to the next key.
        }

    // terminate with the final NUL.
    *pwchDest++ = L'\0';
    *pcwchAlloc = DIFF(pwchDest - pwchKeys);

    return TRUE;
    }



/*===================================================================
CServVarsIterator::QueryInterface
CServVarsIterator::AddRef
CServVarsIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CServVarsIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CServVarsIterator::Clone

Clone this iterator (standard method)

NOTE:
    Cloning this iterator is quite involved.  (It essentially
    involves copying the allocated memory, then adjusting
    ONLY the dynamic pointers in the rgwszKeys array.)

    Right now, this is NYI, as our client (VBScript)
    does not clone this iterator.
===================================================================*/

STDMETHODIMP CServVarsIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    return E_NOTIMPL;
    }



/*===================================================================
CServVarsIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && *m_pwszKey != NULL)
        {
        BSTR bstrT = SysAllocString(*m_pwszKey);
        if (bstrT == NULL)
            return E_OUTOFMEMORY;
        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

        ++m_pwszKey;
        ++rgVariant;
        --cElements;
        ++*pcElementsFetched;
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Skip(unsigned long cElements)
    {
    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && *m_pwszKey != NULL)
        {
        --cElements;
        ++m_pwszKey;
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CServVarsIterator::Reset()
    {
    m_pwszKey = &m_rgwszKeys[0];
    return S_OK;
    }



/*------------------------------------------------------------------
 * C R e q u e s t I t e r a t o r
 */

/*===================================================================
CRequestIterator::CRequestIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CRequestIterator::CRequestIterator(CRequest *pRequest, CollectionType Collection)
    {
    m_Collection  = Collection;
    m_pRequest    = pRequest;
    m_cRefs       = 1;
    m_pRequestHit = NULL;       // Init() will change this pointer anyway...

    m_pRequest->AddRef();
    }



/*===================================================================
CRequestIterator::CRequestIterator

Destructor
===================================================================*/

CRequestIterator::~CRequestIterator()
    {
    m_pRequest->Release();
    }



/*===================================================================
CRequestIterator::Init

Initialize the iterator by loading the collection that we are
about to iterate over.

Return Value:
    Returns E_FAIL if there were problems loading the collection,
    and possibly E_OUTOFMEMORY.
===================================================================*/

HRESULT CRequestIterator::Init()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    switch (m_Collection)
        {
    case QUERYSTRING:
        if (m_pRequest->m_pData->m_fLoadQuery)
            {
            if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadQuery = FALSE;
            }
        break;

    case FORM:
        if (m_pRequest->m_pData->m_fLoadForm)
            {
            HRESULT hrGetData = m_pRequest->CopyClientData();
            if (FAILED(hrGetData))
                return hrGetData;

            if (FAILED(m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadForm = FALSE;
            }
        break;

    case COOKIE:
        if (m_pRequest->m_pData->m_fLoadCookies)
            {
            char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

            if (FAILED(m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadCookies = FALSE;
            }
        break;

    case CLCERT:
        if (m_pRequest->m_pData->m_fLoadClCerts)
            {
            if (FAILED(m_pRequest->LoadVariables(CLCERT, (char*)m_pRequest->GetIReq(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadClCerts = FALSE;
            }
        break;
        }

    return Reset();
    }



/*===================================================================
CRequestIterator::QueryInterface
CRequestIterator::AddRef
CRequestIterator::Release

IUnknown members for CRequestIterator object.
===================================================================*/

STDMETHODIMP CRequestIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequestIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CRequestIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CRequestIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    CRequestIterator *pNewIterator = new CRequestIterator(m_pRequest, m_Collection);
    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_pRequestHit = m_pRequestHit;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }



/*===================================================================
CRequestIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            {
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pRequestHit->m_pKey), 0, &bstrT,m_pRequest->GetCodePage())))
                return E_OUTOFMEMORY;
            V_VT(rgVariant) = VT_BSTR;
            V_BSTR(rgVariant) = bstrT;

            ++rgVariant;
            --cElements;
            ++*pcElementsFetched;
            }

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Skip(unsigned long cElements)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            --cElements;

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Reset()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    m_pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Tail());
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\scrpteng.h ===
/*
 *
 *
 * C S c r i p t E n g i n e
 *
 * An individual script engine for a given language.  May be used
 * by one and only one client at a time.
 *
 */
class CScriptEngine
	{
public:	
	// public methods
	virtual HRESULT AddScriptlet(LPCOLESTR wstrScript) = 0; // Text of scriptlet

	virtual HRESULT AddObjects(BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT Call(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT MakeEngineRunnable() = 0;

	virtual HRESULT ResetScript() = 0;

	virtual HRESULT AddScriptingNamespace() = 0;

	virtual VOID Zombify() = 0;

	virtual HRESULT InterruptScript(BOOL fAbnormal = TRUE) = 0;

	virtual BOOL FScriptTimedOut() = 0;

	virtual BOOL FScriptHadError() = 0;

	virtual HRESULT UpdateLocaleInfo(hostinfo) = 0;

	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\script.h ===
#ifndef SCRIPT_H
#define SCRIPT_H


/***************************************************************************
	Project: VB Script and JavaScript
	Reviewed:
	Copyright (c) Microsoft Corporation

	This defines the public interface to VB Script and JavaScript.

***************************************************************************/

#include "activscp.h"

typedef void *HSCRIPT;	// Handle to a scripting environment instance
typedef void *HENTRY;	// Handle to a script entry point
typedef unsigned long MODID;
const MODID kmodGlobal = 0;

// PFNOUTPUT is used for all output for the script, including compile errors,
// printing (if ScriptAdmin is called to turn on printing), dumping pcode
// (if requested when ScriptAddScript is called), etc.
typedef void  (_stdcall *PFNOUTPUT)(DWORD, LPCOLESTR, BOOL);

enum SAdminEnum
	{
	scadEnableCreateObject = 1, // Only used in VER1
	scadEnablePrint,
	scadEnableTakeOutTrash,     // Only used in JavaScript
	};

STDAPI ScriptBreakThread(DWORD dwThreadID);


inline void FreeExcepInfo(EXCEPINFO *pei)
	{
	if (pei->bstrSource)
		SysFreeString(pei->bstrSource);
	if (pei->bstrDescription)
		SysFreeString(pei->bstrDescription);
	if (pei->bstrHelpFile)
		SysFreeString(pei->bstrHelpFile);
	memset(pei, 0, sizeof(*pei));
	}

struct ScriptException
	{
	IUnknown *punk;
	BSTR bstrUser;		// user data as provided to AddToScript - binary data
	long ichMin;		// character range of error
	long ichLim;
	long line;			// line number of error (zero based)
	long ichMinLine;	// starting char of the line

	BSTR bstrLine;		// source line (if available)
	BOOL fReported;		// been reported via IScriptSite->OnScriptError?

	// must be last
	EXCEPINFO ei;

	void Clear(void)
		{ memset(this, 0, sizeof(*this)); }

	void Free(void)
		{
		FreeExcepInfo(&ei);
		if (NULL != punk)
			punk->Release();
		if (NULL != bstrUser)
			SysFreeString(bstrUser);
		if (NULL != bstrLine)
			SysFreeString(bstrLine);
		memset(this, 0, offsetof(ScriptException, ei));
		}
	};

/***************************************************************************
	The COM Interfaces
***************************************************************************/

enum
	{
	fdexNil = 0x00,
	fdexDontCreate = 0x01,
	fdexInitNull = 0x02,
	fdexCaseSensitive = 0x04,
	fdexLim = 0x80,
	};
const DWORD kgrfdexAll = fdexLim - 1;


// This is the interface for extensible IDispatch objects.
class IDispatchEx : public IDispatch
	{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(REFIID riid,
		LPOLESTR *prgpsz, UINT cpsz, LCID lcid, DISPID *prgid, DWORD grfdex) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, S_OK if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DISPID id, DISPID *pid,
		BSTR *pbstrName) = 0;
	};


// Interface on owner of an IScript object. To avoid circular refcounts,
// the IScript implementation should not AddRef this interface.
class IScriptSite : public IUnknown
	{
public:
	// IScriptSite Methods

	// NOTE:  OnEnterScript() and OnLeaveScript() will nest, but must be
	// balanced pairs.
	// OnEnterScript() is called before entering the execution loop.
	virtual void STDMETHODCALLTYPE OnEnterScript(void) = 0;
	// OnLeaveScript() is called upon exiting the execution loop.
	virtual void STDMETHODCALLTYPE OnLeaveScript(void) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetActiveScriptSiteWindow(
		IActiveScriptSiteWindow **ppassw) = 0;

	// error feedback - the client should not muck with the sei. We own it.
	virtual HRESULT STDMETHODCALLTYPE OnScriptError(const ScriptException *psei) = 0;

	// LCID support
	virtual LCID STDMETHODCALLTYPE GetUserLcid(void) = 0;

	// call back to get an object for a name
	virtual HRESULT STDMETHODCALLTYPE GetExternObject(long lwCookie, IDispatch ** ppdisp) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE DebugBreakPoint(IUnknown *punk,
		void *pvUser, long cbUser, long ichMin, long ichLim) = 0;
#endif //SCRIPT_DEBUGGER

#if VER2
	virtual DWORD STDMETHODCALLTYPE GetSafetyOptions(void) = 0;
#endif //VER2

	virtual HRESULT STDMETHODCALLTYPE GetInterruptInfo(EXCEPINFO * pexcepinfo) = 0;

	};


enum
	{
	fscrNil = 0x00,
	fscrDumpPcode = 0x01,		// dump pcode to the output function
	fscrPersist = 0x08,			// keep this code on reset
	fscrParseHTMLComments = 0x10,
	fscrReturnExpression = 0x20,// call should return the last expression
	fscrImpliedThis = 0x40,		// 'this.' is optional (for Call)
	fscrDebug = 0x80,			// keep this code around for debugging
	};

#if SCRIPT_DEBUGGER
enum BP_COMMAND
	{
	BPCMD_GET,
	BPCMD_SET,
	BPCMD_CLEAR,
	BPCMD_TOGGLE
	};
#endif //SCRIPT_DEBUGGER

class IScript : public IUnknown
	{
public:
	// IScript methods
	virtual HRESULT STDMETHODCALLTYPE AddToScript(LPCOLESTR pszSrc, MODID mod,
		IUnknown *punk, void *pvData, long cbData, ULONG grfscr,
		HENTRY *phentryGlobal, ScriptException *pse) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObject(LPCOLESTR pszName,
		IDispatch *pdisp, MODID mod = kmodGlobal, long lwCookie = 0) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObjectMember(LPCOLESTR pszName,
		IDispatch *pdisp, DISPID dispID, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetEntryPoint(LPCOLESTR pszName,
		HENTRY *phentry, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE ReleaseEntryPoint(HENTRY hentry) = 0;

	virtual HRESULT STDMETHODCALLTYPE Call(HENTRY hentry, VARIANT *pvarRes,
		int cvarArgs, VARIANT *prgvarArgs, IDispatch *pdispThis = NULL,
		ScriptException *pse = NULL, DWORD grfscr = fscrNil) = 0;

	virtual HRESULT STDMETHODCALLTYPE Break(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Admin(SAdminEnum scad, void *pvArg = NULL,
		MODID mod = kmodGlobal) = 0;
	virtual void STDMETHODCALLTYPE SetOutputFunction(PFNOUTPUT pfn,
		DWORD dwOutput) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetDefaultDispatch(MODID mod,
		IDispatch *pdisp) = 0;

	// psite may be NULL
	virtual void STDMETHODCALLTYPE SetScriptSite(IScriptSite *psite) = 0;
#if WIN16
	virtual HRESULT STDMETHODCALLTYPE
        SetActiveScriptSitePoll(IActiveScriptSiteInterruptPoll *pPoll) = 0;
#endif // WIN16

	virtual void STDMETHODCALLTYPE Enter(void) = 0;
	virtual void STDMETHODCALLTYPE Leave(void) = 0;

	// get an IDispatch wrapper for the module
	virtual HRESULT STDMETHODCALLTYPE GetDispatchForModule(MODID mod,
		IDispatch **ppdisp) = 0;

	// Reset/Clone functionality
	virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Clone(IScript **ppscript) = 0;
	virtual HRESULT STDMETHODCALLTYPE Execute(ScriptException *pse = NULL) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE ToggleBreakPoint(IUnknown *punk, long ich,
		BP_COMMAND bpcmd, long *pichMin, long *pichLim, BOOL *pfSet) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetOneTimeBreakOnEntry(BOOL fSet = TRUE) = 0;
#endif //SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE GetLineNumber(IUnknown *punk, long ich,
		long *pline, long *pichMinLine, long *pichLimLine) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetUserData(IUnknown *punk, BSTR *pbstr) = 0;

#if SUPPORT_SCRIPT_HELPER
#if DBG
    virtual HRESULT STDMETHODCALLTYPE DumpPCode(void) = 0;
#endif // DBG
#endif // SUPPORT_SCRIPT_HELPER
	};

// helper to create a script object
STDAPI CreateScript(IScript **ppscript, PFNOUTPUT pfn = NULL, DWORD dwOutput = 0);

#endif // SCRIPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\response.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.cpp

Owner: CGrant

This file contains the code for the implementation of the Response object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "response.h"
#include "request.h"
#include "Cookies.h"
#include "perfdata.h"

#include "winsock2.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

static const char s_szContentLengthHeader[] = "Content-Length: ";
static const char s_szContentTypeHeader[]   = "Content-Type: ";
static const char s_szCharSetHTML[]         = "; Charset=";
static const char s_szCacheControl[]        = "Cache-control: ";
static const char s_szCacheControlPrivate[] = "Cache-control: private\r\n";
static const char s_szTransferEncoding[]    = "Transfer-Encoding: chunked\r\n";
static const char s_szHTML[]                = "text/html";
static const char s_szCDF[]                 = "application/x-cdf";
static const char s_szDefaultStatus[]       = "200 OK";

#if VECTSTATS

//
// a mechanism to collect statistics about response vector length and fragment sizes
//

#if DEBUG
#define COLLECT_RESP_VECT_STATS TRUE
#else
#define COLLECT_RESP_VECT_STATS FALSE
#endif

static BOOL fCollectRespVectStats = COLLECT_RESP_VECT_STATS;

static VOID RespVectStat_DataSizeStats(BOOL fHtmlData, DWORD cch)
{
    if (!fCollectRespVectStats)
        return;

    if (cch == 0)
        InterlockedIncrement(&sRespVecStats.ZeroSizeBlocks);

    if (fHtmlData)
    {
    	if (cch <= 0x10)
			InterlockedIncrement(&sRespVecStats.HTML16);
    	else if (cch <= 0x20)
			InterlockedIncrement(&sRespVecStats.HTML32);
    	else if (cch <= 0x30)
			InterlockedIncrement(&sRespVecStats.HTML48);
    	else if (cch <= 0x40)
			InterlockedIncrement(&sRespVecStats.HTML64);
    	else if (cch <= 0x80)
			InterlockedIncrement(&sRespVecStats.HTML128);
    	else if (cch <= 0x100)
			InterlockedIncrement(&sRespVecStats.HTML256);
    	else if (cch <= 0x200)
			InterlockedIncrement(&sRespVecStats.HTML512);
    	else if (cch <= 0x400)
			InterlockedIncrement(&sRespVecStats.HTML1024);
    	else if (cch <= 0x800)
			InterlockedIncrement(&sRespVecStats.HTML2048);
    	else if (cch <= 0x1000)
			InterlockedIncrement(&sRespVecStats.HTML4096);
    	else if (cch <= 0x2000)
			InterlockedIncrement(&sRespVecStats.HTML8192);
    	else if (cch <= 0x4000)
			InterlockedIncrement(&sRespVecStats.HTML16384);
    	else
			InterlockedIncrement(&sRespVecStats.HTMLbig);

        if (cch > MAX_HTML_IN_RESPONSE_BUFFER)
            InterlockedExchangeAdd(&sRespVecStats.TotalReferencedHTMLBytes, cch);
        else
            InterlockedExchangeAdd(&sRespVecStats.TotalCopiedHTMLBytes, cch);
    }
    else
    	InterlockedIncrement(&sRespVecStats.DynamicBlocks);
}

static VOID RespVectStat_VectorSizeStats(DWORD ca)
{
    if (!fCollectRespVectStats)
        return;

    if (ca <= 0x8)
        InterlockedIncrement(&sRespVecStats.Vect8);
    else if (ca <= 0x10)
        InterlockedIncrement(&sRespVecStats.Vect16);
    else if (ca <= 0x20)
        InterlockedIncrement(&sRespVecStats.Vect32);
    else if (ca <= 0x40)
        InterlockedIncrement(&sRespVecStats.Vect64);
    else if (ca <= 0x60)
        InterlockedIncrement(&sRespVecStats.Vect96);
    else if (ca <= 0x80)
        InterlockedIncrement(&sRespVecStats.Vect128);
    else if (ca <= 0xC0)
        InterlockedIncrement(&sRespVecStats.Vect192);
    else if (ca <= 0x100)
        InterlockedIncrement(&sRespVecStats.Vect256);
    else if (ca <= 0x200)
        InterlockedIncrement(&sRespVecStats.Vect512);
    else if (ca <= 0x400)
        InterlockedIncrement(&sRespVecStats.Vect1024);
    else if (ca <= 0x800)
        InterlockedIncrement(&sRespVecStats.Vect2048);
    else if (ca <= 0x1000)
        InterlockedIncrement(&sRespVecStats.Vect4096);
    else
        InterlockedIncrement(&sRespVecStats.VectBig);
}

#else // VECTSTATS

#define RespVectStat_DataSizeStats(fHtmlData, ccb)
#define RespVectStat_VectorSizeStats(ca)

#endif // VECTSTATS

ResponseVectorStatistics sRespVecStats = {0};

inline void AddtoTotalByteOut(int cByteOut)
    {
#ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEOUT(cByteOut);
#endif
    }

inline const char *GetResponseMimeType(CIsapiReqInfo *pIReq)
    {
    TCHAR *szPath = pIReq->QueryPszPathTranslated();
    DWORD cch = pIReq->QueryCchPathTranslated();
    if (cch > 4 && _tcscmp(szPath + cch - 4, _T(".CDX")) == 0)
        {
        return s_szCDF;
        }
    else
        {
        return s_szHTML;
        }
    }

/*
 *
 *
 *
 * C R e s p o n s e C o o k i e s
 *
 *
 *
 */

//===================================================================
// CResponseCookies::CResponseCookies
//
// Constructor.
//===================================================================
CResponseCookies::CResponseCookies(CResponse *pResponse, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pResponse)
        pResponse->AddRef();
    m_pResponse = pResponse;

    m_pRequest = NULL;

    CDispatch::Init(IID_IRequestDictionary);
    }

//===================================================================
// CResponseCookies::~CResponseCookies
//
// Destructor.
//===================================================================
CResponseCookies::~CResponseCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();

    if (m_pResponse)
        m_pResponse->Release();
    }

//===================================================================
// CResponseCookies::ReInit
//
// Parameters:
//  pRequest  - pointer to the request object. Will need it to
//              read the request for the cookies
//
// Returns:
//  always S_OK, unlest pRequest is NULL.
//===================================================================
HRESULT CResponseCookies::ReInit(CRequest *pRequest)
    {
    if (pRequest)
        pRequest->AddRef();
    if (m_pRequest)
        m_pRequest->Release();

    m_pRequest = pRequest;      // CRequest is not ref counted, so no need for AddRef/Release

    if (m_pRequest == NULL)
        return E_POINTER;

    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryInterface
CResponseCookies::AddRef
CResponseCookies::Release

IUnknown members for CResponseCookies object.
===================================================================*/

STDMETHODIMP CResponseCookies::QueryInterface(const IID &idInterface, void **ppvObj)
    {
    *ppvObj = NULL;

    if (idInterface == IID_IUnknown || idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = this;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }

STDMETHODIMP_(ULONG) CResponseCookies::AddRef()
    {
    return m_punkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CResponseCookies::Release()
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CResponseCookies::get_Item

Function called from DispInvoke to get values from the Response.Cookies
collection.  If the Cookie does not exist, then a new one is created
and added to the Request dictionary

Parameters:
    varKey      VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CResponseCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    char            *szKey=NULL;         // ascii value of 'varKey'
    CRequestHit     *pRequestHit;   // pointer to request bucket
    DWORD           vt = 0;         // Variant type of key
    CWCharToMBCS    convKey;

    if (m_pResponse->FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // Initialize things
    //
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch(vt)
        {
        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;
        default:
            ExceptionId(IID_IRequestDictionary, IDE_COOKIE, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
        }

    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
                        szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        // Bug 456: Don't allow assignment to DenaliSessionID
        if (strncmp(szKey, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_RESPONSE_MODIFY_SESS_COOKIE);
            hrReturn = E_FAIL;
            goto LExit;
            }

            pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount = 0;
        if (vt == VT_I2)
            {
            iCount = V_I2(pvarKey);
            }
        else
            {
            iCount = V_I4(pvarKey);
            }

        // The Request hits for all cookies are stored with the request object
        if ((iCount < 1) || (iCount > (int) m_pRequest->m_pData->m_Cookies.m_dwCount))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        pRequestHit = m_pRequest->m_pData->m_Cookies.m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound:
    // don't allow empty cookie names
    //
    if (szKey != NULL && *szKey == '\0')
        {
        ExceptionId(IID_IResponse, IDE_COOKIE, IDE_COOKIE_NO_NAME);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // Create a new RequestHit if there is no key by this name
    if (pRequestHit == NULL)
        {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL || FAILED(pRequestHit->Init(szKey, TRUE)))
            {
            if (pRequestHit)
                delete pRequestHit;
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }

        m_pRequest->GetStrings()->AddElem(pRequestHit);
        }

    // Create a new cookie, with an initial unassigned value.
    if (pRequestHit->m_pCookieData == NULL)
        {
        pRequestHit->m_pCookieData = new CCookie(m_pResponse->GetIReq(),m_pRequest->GetCodePage());
        if (pRequestHit->m_pCookieData == NULL || FAILED(pRequestHit->m_pCookieData->Init()))
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    // Add this Request hit to the ResponseCookies array of hits
    if (!m_pRequest->m_pData->m_Cookies.AddRequestHit(pRequestHit))
        {
        return E_OUTOFMEMORY;
        }

    // Query for IWriteCookie
    if (FAILED(pRequestHit->m_pCookieData->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
        {
        Assert (FALSE);
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CResponseCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CResponseCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Count(pcValues);
    }

/*===================================================================
CResponseCookies::get_Key

Function called from DispInvoke to get keys from the response cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CResponseCookies::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Key(varKey, pVar);
    }

/*===================================================================
CResponseCookies::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CResponseCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(m_pRequest, COOKIE);
    if (pIterator == NULL)
        return E_OUTOFMEMORY;

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryHeaderSize

Returns:
    returns the number of bytes required for the cookie headers.
===================================================================*/

size_t CResponseCookies::QueryHeaderSize()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return 0;

    int cbHeaders = 0;

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        // add two bytes for '\r\n'
        //
        // CCookie::GetCookieHeaderSize adds one byte for NUL terminator, so
        // just add one byte here.
        //
        // CResponse::WriteHeaders does not want to know about the NUL yet.
        //
        cbHeaders += pCookie->GetCookieHeaderSize(reinterpret_cast<char *>(pRequestHit->m_pKey)) + 1;
        }

    return cbHeaders;
    }

/*===================================================================
CResponseCookies::GetHeaders

Parameters:
    szBuffer - contains the destination buffer for the cookie header
                text

Returns:
    return a pointer to the NUL character in the destination
===================================================================*/

char *CResponseCookies::GetHeaders(char *szBuffer)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        szBuffer[0] = '\0';
        return szBuffer;
        }

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        szBuffer = pCookie->GetCookieHeader(reinterpret_cast<char *>(pRequestHit->m_pKey), szBuffer);
        szBuffer = strcpyExA(szBuffer, "\r\n");
        }

    return szBuffer;
    }


/*
 *
 *
 *
 * C R e s p o n s e V e c t o r
 *
 *
 *
 */
/*===================================================================
The CResponseVector object maintains a vector of pointers to data blocks in the
response buffers and HTML data in the templates for an efficient VectorSend.
The current entry can be open for accumulating data (extending the size of current
block). Insert() will open a new vector entry for the data block and close it.
Append() adds to the current (open) entry or creates a new entry. Close() closes
the current entry.
====================================================================*/

/*===================================================================
CResponseVector::CResponseVector

Constructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    None

===================================================================*/
CResponseVector::CResponseVector()
{
    m_pExtVector = NULL;
    m_cExtVectorSize = 0;
    m_iCurrentEntry = 0;
    m_fEntryIsOpen = FALSE;
    m_cchTotalBuffered = 0;
}

/*===================================================================
CResponseVector::~CResponseVector

Destructor
Clear() does all the work

Parameters:
    None

Returns:
    Nothing

Side Effects
    Frees memory

===================================================================*/
CResponseVector::~CResponseVector()
{
    Clear();
}

/*===================================================================
CResponseVector::Clear
resets the instance, freeing any dynamically allocated memory

Parameters:
    None

Returns:
    Nothing

Side Effects
    Frees memory

===================================================================*/
VOID CResponseVector::Clear()
{
    // update statistics
    RespVectStat_VectorSizeStats( GetEntryCount());

    // Free auxilary vector
    if (m_pExtVector)
    {
        free(m_pExtVector);
        m_pExtVector = NULL;
    }

    m_cExtVectorSize = 0;
    m_iCurrentEntry = 0;
    m_fEntryIsOpen = FALSE;
    m_cchTotalBuffered = 0;
}

/*===================================================================
CResponseVector::Append
For an open entry, increases the size of buffer the entry points to.
If the entry is closed, a new entry is opened.

Parameters:
    pData   pointer to the new data
    cbSize  size of data

Returns:
    HRESULT

Side Effects
    None

===================================================================*/
HRESULT CResponseVector::Append(char * pData, DWORD cbSize)
{
    HRESULT hr;
    LPWSABUF pEntry;

    if (cbSize == 0)
    { // no point in storing zero size data
        return S_OK;
    }

    Assert( !IsBadReadPtr( pData, cbSize));

    if (IsEntryOpen())
    { // append to an open entry
        pEntry = GetEntry( m_iCurrentEntry);
        Assert(pData == (pEntry->buf + pEntry->len));
        pEntry->len += cbSize;
        m_cchTotalBuffered += cbSize;
        return S_OK;
    }

    if (m_iCurrentEntry >= (RESPONSE_VECTOR_INTRINSIC_SIZE + m_cExtVectorSize))
    { // need to grow the vector
        if (FAILED(hr = GrowVector()))
        {
            return hr;
        }
    }

    m_fEntryIsOpen = TRUE;
    pEntry = GetEntry( m_iCurrentEntry);
    pEntry->len = cbSize;
    pEntry->buf = pData;
    m_cchTotalBuffered += cbSize;

    return S_OK;
}

/*===================================================================
CResponseVector::GrowVector

Allocate space in the auxilary vector. The auxilary vector is created with
RESPONSE_VECTOR_INITIAL_ALLOC elements and grown by a factor of
RESPONSE_VECTOR_REALLOC_FACTOR.
Factor the current size is an efficient method to grow hash and index tables.

Parameters:
    None

Returns:
    HRESULT         Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseVector::GrowVector()
{
    LPVOID pVectorTmp;
    DWORD cNewEntries;

    if (m_pExtVector == NULL)
    {
        // first dynamic allocation
        cNewEntries = RESPONSE_VECTOR_INITIAL_ALLOC;
        pVectorTmp = malloc( cNewEntries * sizeof(WSABUF));
    }
    else
    {
        // expand current auxilary vector
        cNewEntries = RESPONSE_VECTOR_REALLOC_FACTOR * m_cExtVectorSize;
        pVectorTmp = realloc(m_pExtVector, cNewEntries * sizeof(WSABUF));
    }

    if (!pVectorTmp)
        return E_OUTOFMEMORY;

    m_pExtVector = (LPWSABUF)pVectorTmp;
    m_cExtVectorSize = cNewEntries;

    return S_OK;
}


/*
 *
 *
 *
 * C R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
The CResponseBuffer object maintains an array of buffers.
If buffering is turned on, the Response.Write and Response.WriteBlock
methods will write to the buffers in these arrays rather then directly
back to the client. Response.Flush writes the content of the buffers to
the client and then frees the buffers. Response.Clear frees the buffers without
writing to the client
====================================================================*/

/*===================================================================
CResponseBuffer::CResponseBuffer

Constructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    None

===================================================================*/
CResponseBuffer::CResponseBuffer()
    {
    m_pBufferSet = NULL;

    m_rgpchBuffers = &m_pchBuffer0;
    m_cBufferPointers = 1;
    m_pchBuffer0 = NULL;

    m_cBuffers = 0;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    m_dwBufferLimit = DEFAULT_BUFFER_LIMIT;
    m_fInited = FALSE;
    }

/*===================================================================
CResponseBuffer::Init

Initializes the CResponseBuffer object

Parameters:
    CResponseBufferSet *    pointer to bufferset holding this object
    dwBufferLimit           maximum to buffer

Returns:
    S_OK         Success
    E_OUTOFMEMORY   Failure

Side Effects
    Allocates memory

===================================================================*/
HRESULT CResponseBuffer::Init(CResponseBufferSet * pBufferSet,
                              DWORD                dwBufferLimit)
    {
    Assert(pBufferSet);

    // Set the pointer to the enclosing response object
    m_pBufferSet = pBufferSet;
    m_dwBufferLimit = dwBufferLimit;

    m_fInited = TRUE;

    return S_OK;
    }

/*===================================================================
CResponseBuffer::~CResponseBuffer

Destructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    Frees memory

===================================================================*/
CResponseBuffer::~CResponseBuffer()
    {
    Assert(m_rgpchBuffers);

    // Free all the buffers we've allocated
    for (DWORD i = 0; i < m_cBuffers; i++)
        {
        if (m_rgpchBuffers[i])
            {
            ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
            }
        }

    // Free the array of buffer pointers
    // (only if allocated - doesn't point to the member pointer
    if (m_cBufferPointers > 1)
        free(m_rgpchBuffers);
    }

/*===================================================================
CResponseBuffer::GrowBuffers

Increases available buffer space

Parameters:
    cchNewRequest   count of bytes to be accomodated

Returns:
    HRESULT         Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::GrowBuffers(DWORD cchNewRequest)
    {
    Assert(m_fInited);

    // Calculate how many more buffers are needed
    DWORD cAddBuffers = (cchNewRequest+RESPONSE_BUFFER_SIZE-1)/RESPONSE_BUFFER_SIZE;

    // Always at least one must be there already
    Assert(m_rgpchBuffers);
    Assert(m_cBufferPointers);

    // Allocate more buffer pointers if needed
    if (cAddBuffers > (m_cBufferPointers - m_cBuffers)) // doesn't fit?
        {
        char **rgpchTmp;
        DWORD cNewBufferPointers = m_cBufferPointers + cAddBuffers + BUFFERS_INCREMENT;

        if (m_cBufferPointers == 1)
            rgpchTmp = (char **)malloc(cNewBufferPointers*sizeof(char *));
        else
            rgpchTmp = (char **)realloc(m_rgpchBuffers, cNewBufferPointers*sizeof(char *));
        if (!rgpchTmp)
            return E_OUTOFMEMORY;

        // preserve the first buffer pointer in the special case
        // of m_rgpchBuffers initally pointing to a member buffer pointer
        if (m_cBufferPointers == 1)
            rgpchTmp[0] = m_rgpchBuffers[0];

        m_rgpchBuffers = rgpchTmp;
        m_cBufferPointers = cNewBufferPointers;
        }

    // Allocate the new buffers
    for (DWORD i = 0; i < cAddBuffers; i++)
        {
        char *pchTmp = (char *)ACACHE_FSA_ALLOC(ResponseBuffer);
        if (!pchTmp)
            return E_OUTOFMEMORY;
        m_rgpchBuffers[m_cBuffers++] = pchTmp;
        }

    return S_OK;
    }


/*===================================================================
CResponseBuffer::Write

Writes data to the CResponseBuffer object. We first write
a data structure that describes this segment of the buffer.
The data structure identifies which method is doing the
writing, and contains an index to the starting buffer,
the starting offset in that buffer, and the length of the
data. The data itself is then writen to one or more buffers.
New buffers are allocated as needed.
Pointers to the data blocks in the response buffers are added to
the ResponseVector for efficient writeto the client.

Parameters:
    szSource      pointer to buffer to read into the Response buffer
    cch           count of bytes to be read into the Response buffer
    fChunkData    indicates that the data should be chunked
    fTemplateData indicates (HTML) data that can be referenced rather than copied

Returns:
    HRESULT     Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::Write(char* szSource, DWORD cch, BOOL fChunkData, BOOL fTemplateData)
{

    HRESULT hr = S_OK;
    char* pTmp;
    CHAR szBuf[16]; // to hold a sting with length of data + CRLF, if chunking
    int  dwNumLen;

    Assert(m_fInited);

    // nothing to do if chunking and we got a zero junk.

    if ((cch == 0) && fChunkData)
        return S_OK;

    // check to see if we've blown out the buffer limit...

    if ((m_ResponseVector.BytesBuffered() + cch) > m_dwBufferLimit) {

        // dump the current contents so as not to obscure the error with the
        // buffered data

        Clear();

        // generate the error

        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_BUFFER_LIMIT_EXCEEDED);

        // return error so that the script engine stops

        hr = E_FAIL;

        goto lRet;
    }

    // add the chunk info if we're chunking

    if (fChunkData) {

        // chunk length
        _itoa(cch, szBuf, 16);
        dwNumLen = strlen(szBuf);

        // CR LF
        szBuf[dwNumLen]   = '\r';
        szBuf[dwNumLen+1] = '\n';

        // call Write recursively.

        hr = Write(szBuf, dwNumLen+2, FALSE);

        if (FAILED(hr))
            goto lRet;
    }

    // Caclulate how much buffer space we have left
    DWORD cchBufferRemaining;
    if (m_cBuffers)
        cchBufferRemaining = RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer;
    else
        cchBufferRemaining = 0;

    // update statistics
    RespVectStat_DataSizeStats(fTemplateData, cch);

    if (fTemplateData && (cch > MAX_HTML_IN_RESPONSE_BUFFER))
    {
        // don't copy the data, just add it to the response vector
        hr = m_ResponseVector.Insert(szSource, cch);

        if (SUCCEEDED(hr))
            hr = m_pBufferSet->AddTemplateToArray();
    }
    else if (cch <= cchBufferRemaining)
    {
        // Enough space available, copy data to buffer
        pTmp = m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer;
        memcpy(pTmp, szSource, cch);
        hr = m_ResponseVector.Append(pTmp, cch);
        m_cchOffsetInCurrentBuffer += cch;
    }
    else
    {
        // Not enough space in current buffer, allocate more buffers
        hr = GrowBuffers(cch - cchBufferRemaining);
        if (FAILED(hr))
        {
            goto lRet;
        }

        // Copy data to the buffers, we loop to handle
        // the case where the data is larger then the buffer size
        while (cch)
        {
            if (RESPONSE_BUFFER_SIZE == m_cchOffsetInCurrentBuffer)
            {
                m_iCurrentBuffer++;
                m_cchOffsetInCurrentBuffer = 0;
                m_ResponseVector.Close();
            }
            DWORD cchToCopy = min(cch, (RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer));
            pTmp = m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer;
            memcpy(pTmp, szSource, cchToCopy);
            hr = m_ResponseVector.Append(pTmp, cchToCopy);
            m_cchOffsetInCurrentBuffer += cchToCopy;
            if (FAILED(hr))
            {
                goto lRet;
            }
            szSource += cchToCopy;
            cch -= cchToCopy;
        }
    }

    // add the trailing \r\n

    if (fChunkData)
        hr = Write(szBuf+dwNumLen, 2, FALSE);

lRet:
    return hr;
}

/*===================================================================
CResponseBuffer::Clear

  Deletes all information currently in the buffers, and restores
  the buffer array to it's starting state.

Parameters:
    None

Returns:
    S_OK success

Side Effects
    May free memory

===================================================================*/
HRESULT CResponseBuffer::Clear()
    {
    Assert(m_fInited);

    m_ResponseVector.Clear();

    if (m_cBuffers == 0)
        return S_OK;

    // Free all but the first of the allocated buffers
    for (DWORD i = 1; i < m_cBuffers;  i++)
        {
        ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
        m_rgpchBuffers[i] = NULL;
        }

    m_cBuffers = 1;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    return S_OK;
    }

/*
 *
 *
 *
 * C D e b u g R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
CDebugResponseBuffer::AppendRecord

Create client side debugger metadata record and appends it to
the buffer

Parameters:

Returns:
    HRESULT     Indicating success or type of failure
===================================================================*/
HRESULT CDebugResponseBuffer::AppendRecord
(
const int cchBlockOffset,
const int cchBlockLength,
const int cchSourceOffset,
const char *pszSourceFile
)
    {
    HRESULT hr = S_OK;

#define CCH_METADATA_RECORD_MAX 40 // without filename

    if (pszSourceFile)
        {
        char *pszBuf = new char [strlen(pszSourceFile) +
                                 CCH_METADATA_RECORD_MAX + 1];
        if (pszBuf)
            {
            sprintf(pszBuf, "%d,%d,%d,%s\r\n",
                cchBlockOffset, cchBlockLength, cchSourceOffset,
                pszSourceFile);

            hr = Write(pszBuf);
            delete [] pszBuf;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        char szBuf[CCH_METADATA_RECORD_MAX+1];
        sprintf(szBuf, "%d,%d,%d\r\n",
            cchBlockOffset, cchBlockLength, cchSourceOffset);

        hr = Write(szBuf);
        }

#undef CCH_METADATA_RECORD_MAX

    return hr;
    }

/*
 *
 *
 *
 * C H T T P H e a d e r
 *
 *
 *
 */

/*===================================================================
CHTTPHeader::CHTTPHeader

Constructor.
===================================================================*/
CHTTPHeader::CHTTPHeader()
    :
    m_fInited(FALSE),
    m_fNameAllocated(FALSE), m_fValueAllocated(FALSE),
    m_szName(NULL), m_szValue(NULL),
    m_cchName(0), m_cchValue(0),
    m_pNext(NULL)
    {
    }

/*===================================================================
CHTTPHeader::~CHTTPHeader

Destructor
===================================================================*/
CHTTPHeader::~CHTTPHeader()
    {
    if (m_fNameAllocated)
        {
        Assert(m_szName);
        delete [] m_szName;
        }
    if (m_fValueAllocated)
        {
        Assert(m_szValue);
        delete [] m_szValue;
        }
    }

/*===================================================================
HRESULT CHTTPHeader::InitHeader

Functions set the header strings. Agrument types combinations:
    BSTR, BSTR
    hardcoded char*, BSTR
    hardcoded char*, hardcoded char*
    hardcoded char*, int

Parameters:
    Name, Value

Returns:
    S_OK     Success
===================================================================*/
HRESULT CHTTPHeader::InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage /* CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(wszName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    // name

    if (FAILED(hr = convStr.Init(wszName,lCodePage))) {
        if (hr == E_OUTOFMEMORY)
            return hr;
        m_fNameAllocated = FALSE;
        m_szName = "";
    }
    else {
        m_szName = convStr.GetString(TRUE);
        m_fNameAllocated = TRUE;
    }
    m_cchName = strlen(m_szName);

    // value
    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, BSTR wszValue, UINT lCodePage /* = CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(szName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    if (fCopyValue)
        {
        int cch = szValue ? strlen(szValue) : 0;
        if (cch > 0)
            {
            m_szValue = new char[cch+1];
            if (m_szValue == NULL)
                return E_OUTOFMEMORY;
            m_fValueAllocated = TRUE;
            strcpy(m_szValue, szValue);
            m_cchValue = cch;
            }
        else
            {
            m_szValue = NULL;
            m_fValueAllocated = FALSE;
            m_cchValue = 0;
            }
        }
    else
        {
        m_szValue = szValue;
        m_cchValue = strlen(m_szValue);
        m_fValueAllocated = FALSE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, long lValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    ltoa(lValue, m_rgchLtoaBuffer, 10);
    m_szValue = m_rgchLtoaBuffer;
    m_cchValue = strlen(m_szValue);
    m_fValueAllocated = FALSE;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHTTPHeader::Print

Prints the header into a buffer in "Header: Value\r\n" format.

Parameters:
    szBuf       buffer to fill
===================================================================*/
void CHTTPHeader::Print
(
char *szBuf
)
    {
    Assert(m_fInited);

    Assert(m_cchName);
    Assert(m_szName);
    memcpy(szBuf, m_szName, m_cchName);
    szBuf += m_cchName;

    *szBuf++ = ':';
    *szBuf++ = ' ';

    if (m_cchValue)
        {
        Assert(m_szValue);
        memcpy(szBuf, m_szValue, m_cchValue);
        szBuf += m_cchValue;
        }

    *szBuf++ = '\r';
    *szBuf++ = '\n';
    *szBuf = '\0';
    }

/*
 *
 *
 *
 * C R e s p o n s e D a t a
 *
 *
 *
 */

/*===================================================================
CResponseBufferSet::CResponseBufferSet

Constructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CResponseBufferSet::CResponseBufferSet()
{
    m_pResponseBuffer       = NULL;
    m_pClientDebugBuffer    = NULL;
    m_pTemplate             = NULL;
    m_fCurTemplateInArray   = FALSE;
    m_fTemplateArrayAllocd  = FALSE;
    m_aTemplates[0]         = NULL;
    m_dwTemplatesRefd       = 0;
    m_ppTemplates           = m_aTemplates;
    m_dwArraySize           = sizeof(m_aTemplates)/sizeof(CTemplate *);
}

/*===================================================================
CResponseBufferSet::~CResponseBufferSet

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CResponseBufferSet::~CResponseBufferSet()
{
    if (m_pResponseBuffer)
        delete m_pResponseBuffer;
    if (m_pClientDebugBuffer)
        delete m_pClientDebugBuffer;

    // release any templates that were referenced

    for (DWORD  i=0; i < m_dwTemplatesRefd; i++)
        m_aTemplates[i]->Release();

    // delete the template array if it was allocated

    if (m_fTemplateArrayAllocd)
        free(m_ppTemplates);

}

/*===================================================================
CResponseBufferSet::Init

Initializes this object with the CResponseBuffer.

Parameters:
    dwBufferLimit       maximum to buffer

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseBufferSet::Init(DWORD  dwBufferLimit)
{
    HRESULT hr = S_OK;

    m_pResponseBuffer = new CResponseBuffer;

    if (m_pResponseBuffer == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = m_pResponseBuffer->Init(this, dwBufferLimit);

    return hr;
}

/*===================================================================
CResponseBufferSet::InitDebugBuffer

Clears or allocates a new CDebugResponseBuffer.

Parameters:
    dwBufferLimit       maximum to buffer

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseBufferSet::InitDebugBuffer(DWORD   dwBufferLimit)
{
    HRESULT hr = S_OK;

    if (m_pClientDebugBuffer) {
        hr = m_pClientDebugBuffer->ClearAndStart();
    }
    else {
        m_pClientDebugBuffer = new CDebugResponseBuffer;
        if (m_pClientDebugBuffer)
            hr = m_pClientDebugBuffer->InitAndStart(this, dwBufferLimit);
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

/*===================================================================
CResponseBufferSet::AddTemplateToArray

Takes the current m_pTemplate member variable and adds it to the
array of ppTemplates.  A call to this routine likely indicates that
pTemplate memory is being referenced in the response data and so the
lifetime of the Template needs to include the async completion of
writing the data.

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseBufferSet::AddTemplateToArray() {

    DWORD   i;
    HRESULT hr = S_OK;

    // nothing to do if it's already in the array

    if (m_fCurTemplateInArray)
        return hr;

    // check the current list to see if it's already
    // in there.  Because of template swapping caused
    // by child executes, a template could come and go
    // in the response buffer structure.  When the template
    // is set again, it is first assumed to NOT be in the
    // array.

    for (i=0; i < m_dwTemplatesRefd; i++) {

        if (m_pTemplate == m_ppTemplates[i]) {

            // found it.  Note that it's in aldready and return immediately

            m_fCurTemplateInArray = TRUE;
            return S_OK;
        }
    }

    // ok, it's not currently in the array.  We need to add it.

    // first check to make sure that there is enough room in the
    // array for the pointer.

    if (i >= m_dwArraySize) {

        // need to grow the array.  The array grows in 128 entry
        // chunks.

        if (m_fTemplateArrayAllocd) {

            // if it's already been dynamically allocated, then a realloc
            // is in order.

            void       *pTemp;

            // attempt the realloc

            pTemp = realloc(m_ppTemplates, sizeof(CTemplate *)*(m_dwArraySize+128));

            // if it's successful, then update the pointer with the new
            // value.  If not successful, return OOM

            if (pTemp) {

                // up the array size by the 128 chunk

                m_dwArraySize += 128;

                m_ppTemplates = (CTemplate **)pTemp;
            }
            else
                hr = E_OUTOFMEMORY;
        }
        else {

            // blew out the internal array.  Need to allocate from
            // the heap.

            m_ppTemplates = (CTemplate **)malloc(sizeof(CTemplate *) * 128);

            // if successful, note the new array size, copy the internal array
            // in, and note that we've allocated the array.

            if (m_ppTemplates) {
                m_dwArraySize = 128;
                memcpy(m_ppTemplates, m_aTemplates, sizeof(m_aTemplates));
                m_fTemplateArrayAllocd = TRUE;
            }
            else {
                m_ppTemplates = m_aTemplates;
                hr = E_OUTOFMEMORY;
            }
        }
    }

    // if everything is still OK, then there is sufficient room in the array
    // for the template.

    if (SUCCEEDED(hr)) {
        m_ppTemplates[m_dwTemplatesRefd++] = m_pTemplate;
        m_pTemplate->AddRef();
        m_fCurTemplateInArray = TRUE;
    }

    return hr;
}

/*===================================================================
CResponseBufferSet::SendResponseCompletion

Handles Async Write completion.  Really not much to do here.
Just delete the BufferSet object.

Parameters:
    CIsapiReqInfo   *
    PVOID                   // actually CResponseBufferSet
    DWORD          cbIO
    DWORD          dwError

Returns:
    Nothing.
===================================================================*/
VOID CResponseBufferSet::SendResponseCompletion(CIsapiReqInfo    *pIReq,
                                       PVOID            pContext,
                                       DWORD            cbIO,
                                       DWORD            dwError)
{
    CResponseBufferSet  *pBufferSet = (CResponseBufferSet *)pContext;

#ifndef PERF_DISABLE
    AddtoTotalByteOut(cbIO);
#endif

    delete pBufferSet;
}

/*
 *
 *
 *
 * C R e s p o n s e D a t a
 *
 *
 *
 */

/*===================================================================
CResponseData::CResponseData

Constructor

Parameters:
    CResponse *pResponse

Returns:
    Nothing.
===================================================================*/
CResponseData::CResponseData
(
CResponse *pResponse
)
    :
    m_ISupportErrImp(static_cast<IResponse *>(pResponse), this, IID_IResponse),
    m_WriteCookies(pResponse, this),
    m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_pFirstHeader = m_pLastHeader = NULL;
    m_fResponseAborted = FALSE;
    m_fWriteClientError = FALSE;
    m_fIgnoreWrites = FALSE;
    m_fBufferingOn = FALSE;
    m_fFlushed = FALSE;
    m_fChunkData = FALSE;
    m_fChunkDataInited = FALSE;
    m_fClientDebugMode = FALSE;
    m_fClientDebugFlushIgnored = FALSE;
    m_szCookieVal = NULL;
    m_pszDefaultContentType = NULL;
    m_pszContentType = NULL;
    m_pszCharSet = NULL;
    m_pszStatus = NULL;
    m_pszCacheControl = NULL;
    m_dwVersionMajor = 0;
    m_dwVersionMinor = 0;
    m_pBufferSet = NULL;
    m_tExpires = -1;
    m_pszDefaultExpires = NULL;
    m_pfnGetScript = NULL;
    m_pvGetScriptContext = NULL;
    m_dwBufferLimit = DEFAULT_BUFFER_LIMIT;
    }

/*===================================================================
CResponseData::~CResponseData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CResponseData::~CResponseData()
    {
    // points to static string - no need to free
    // m_pszDefaultContentType = NULL;

    // Free any memory associated with the content-type
    if (m_pszContentType)
        free(m_pszContentType);

        // Free any memory associated with the CacheControl
        if (m_pszCacheControl)
                free(m_pszCacheControl);

    // Free any memory associated with the CharSet
    if (m_pszCharSet)
        free(m_pszCharSet);

    // Free any memory associated with the status
    if (m_pszStatus)
        free(m_pszStatus);

    // Free all headers
    CHTTPHeader *pHeader = m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pFirstHeader = m_pLastHeader = NULL;

    if (m_pBufferSet)
        delete m_pBufferSet;
    }

/*===================================================================
CResponseData::Init

Init

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseData::Init()
    {
    HRESULT hr = S_OK;

    m_pIReq = NULL;

    // set the HEAD request flag to 0 un-inited
    m_IsHeadRequest = 0;

    // Initialize header list
    m_pFirstHeader = m_pLastHeader = NULL;

    m_pBufferSet = new CResponseBufferSet;

    if (m_pBufferSet == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = m_pBufferSet->Init(m_dwBufferLimit);

    return hr;
    }

/*===================================================================
CResponseData::QueryInterface
CResponseData::AddRef
CResponseData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CResponseData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CResponseData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CResponseData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }

/*
 *
 *
 *
 * C R e s p o n s e
 *
 *
 *
 */

/*===================================================================
CResponse::CResponse

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CResponse::CResponse(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pUnkFTM(NULL),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IResponse);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CResponse::~CResponse

Destructor

Parameters:
    None

Returns:
    Nothing.

===================================================================*/
CResponse::~CResponse()
{
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count

    if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }

}

/*===================================================================
CResponse::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CResponse::CleanUp()
    {
    if (m_pData)
        {
        m_pData->Release();
        m_pData = NULL;
        }
    return S_OK;
    }

/*===================================================================
CResponse::Init

Allocates m_pData
Performs any intiailization of a CResponse that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::Init()
    {

    HRESULT hr = S_OK;

    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    // Create the FTM
    if (m_pUnkFTM == NULL)
    {
        hr = CoCreateFreeThreadedMarshaler((IUnknown*)((IResponseImpl *)this), &m_pUnkFTM );
    	
        if ( FAILED(hr) )
        {
            Assert( m_pUnkFTM == NULL );
            return (hr);
        }
    }

    Assert( m_pUnkFTM != NULL );

    m_pData = new CResponseData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    hr = m_pData->Init();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CResponse::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    // Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)
	CoDisconnectObject(static_cast<IResponseImpl *>(this), 0);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
CResponse::ReInitTemplate

This function is used to set the template member. It should only
be used for an ordinary script file's template, not for global.asa template.

Parameters:
    Pointer to template

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInitTemplate
(
CTemplate* pTemplate,
const char *szCookieVal
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    Assert(pTemplate != NULL);
    Assert(m_pData->m_pBufferSet->PTemplate() == NULL);

    m_pData->m_pBufferSet->SetTemplate(pTemplate);

    m_pData->m_szCookieVal = szCookieVal;
    return(S_OK);
    }

/*===================================================================
CResponse::SwapTemplate

Temporary substitutes Template in response
Used in child request execution

Parameters:
    Pointer to the new template

Returns:
    Pointer to the old template
===================================================================*/
CTemplate *CResponse::SwapTemplate
(
CTemplate* pNewTemplate
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CTemplate *pOldTemplate = m_pData->m_pBufferSet->PTemplate();

    m_pData->m_pBufferSet->SetTemplate(pNewTemplate);

    return pOldTemplate;
    }

/*===================================================================
CResponse::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    Pointer to CIsapiReqInfo
Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInit
(
CIsapiReqInfo *pIReq,
const char *szCookieVal,
CRequest *pRequest,
PFNGETSCRIPT pfnGetScript,
void *pvGetScriptContext,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CHTTPHeader *pCurr;
    CLinkElem *pT;
    CLinkElem *pNext;

    // set the HEAD request flag to 0 un-inited
    m_pData->m_IsHeadRequest = 0;

    // ReInitialize the WriteCookie dictionary
    if (FAILED(m_pData->m_WriteCookies.ReInit(pRequest)))
        return E_FAIL;

    // points to static string - no need to free
    m_pData->m_pszDefaultContentType = NULL;

    // Free any memory associated with the content type
    if (m_pData->m_pszContentType != NULL)
        {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
        }

    // Free any memory associated with the content type
    if (m_pData->m_pszCharSet != NULL)
        {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
        }


    // Free any memory associated with the status
    if (m_pData->m_pszStatus != NULL)
        {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
        }

    // Free all headers
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pData->m_pFirstHeader = m_pData->m_pLastHeader = NULL;

    m_pData->m_fResponseAborted = FALSE;
    m_pData->m_fWriteClientError = FALSE;
    m_pData->m_fIgnoreWrites = FALSE;
    m_pData->m_pIReq = pIReq;
    m_pData->m_szCookieVal = szCookieVal;
    m_pData->m_pszDefaultContentType = NULL;
    m_pData->m_pszContentType = NULL;
    m_pData->m_pszCharSet = NULL;
    m_pData->m_pszStatus = NULL;
    m_pData->m_pfnGetScript = pfnGetScript;
    m_pData->m_pvGetScriptContext = pvGetScriptContext;
    m_pData->m_pHitObj = pHitObj;
    m_pData->m_tExpires = -1;
    m_pData->m_pszDefaultExpires = NULL;

    // Ask for the HTTP version of the client
    GetClientVerison();

    // Set the default content type
    if (m_pData->m_pIReq)
        m_pData->m_pszDefaultContentType = GetResponseMimeType(m_pData->m_pIReq);

    // Set the buffering flag to the global value
    m_pData->m_fBufferingOn = (pHitObj->QueryAppConfig())->fBufferingOn();
    m_pData->SetBufferLimit(pHitObj->QueryAppConfig()->dwBufferLimit());

    // Buffering always on for client code debug
    if (pHitObj && pHitObj->FClientCodeDebug())
        {
        m_pData->m_fBufferingOn = TRUE;
        m_pData->m_fClientDebugMode = TRUE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }
    else
        {
        m_pData->m_fClientDebugMode = FALSE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode)
        {
        hr = m_pData->m_pBufferSet->InitDebugBuffer(m_pData->m_dwBufferLimit);
        }

    return hr;
    }

/*===================================================================
CResponse::QueryInterface
CResponse::AddRef
CResponse::Release

IUnknown members for CResponse object.

===================================================================*/
STDMETHODIMP CResponse::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (IID_IUnknown == riid || IID_IDispatch == riid || IID_IResponse == riid || IID_IDenaliIntrinsic == riid)
        *ppv = static_cast<IResponse *>(this);

    // Support IStream for ADO/XML
    else if (IID_IStream == riid)
        *ppv = static_cast<IStream *>(this);

    //Indicate that we support error information
    else if (IID_ISupportErrorInfo == riid)
        {
        if (m_pData)
            *ppv = &(m_pData->m_ISupportErrImp);
        }

    else if (IID_IMarshal == riid)
        {
            Assert( m_pUnkFTM != NULL );

            if ( m_pUnkFTM == NULL )
            {
                return E_UNEXPECTED;
            }

            return m_pUnkFTM->QueryInterface( riid, ppv );
        }

    //AddRef any interface we'll return.
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CResponse::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }


STDMETHODIMP_(ULONG) CResponse::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CResponse::GetIDsOfNames

Special-case implementation for Response.WriteBlock and
Response.Write

Parameters:
    riid            REFIID reserved. Must be IID_NULL.
    rgszNames       OLECHAR ** pointing to the array of names to be mapped.
    cNames          UINT number of names to be mapped.
    lcid            LCID of the locale.
    rgDispID        DISPID * caller allocated array containing IDs
                    corresponging to those names in rgszNames.

Return Value:
    HRESULT      S_OK or a general error code.
===================================================================*/
STDMETHODIMP CResponse::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidWrite      = 0x60020013;
    const DISPID dispidWriteBlock = 0x60020014;

    if (cNames == 1)
        {
        // first char 'W'
        if (rgszNames[0][0] == L'w' || rgszNames[0][0] == L'W')
            {
            // swtich on strlen
            switch (wcslen(rgszNames[0]))
                {
            case 5:
                // case insensitive because user can type either way
                if (wcsicmp(rgszNames[0], L"write") == 0)
                    {
                    *rgDispID = dispidWrite;
                    return S_OK;
                    }
                break;
            case 10:
                // case sensitive because only we generate WriteBlock
                if (wcscmp(rgszNames[0], L"WriteBlock") == 0)
                    {
                    *rgDispID = dispidWriteBlock;
                    return S_OK;
                    }
                break;
                }
            }
        }

    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CResponse::CheckForTombstone

Tombstone stub for IResponse methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CResponse::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IResponse,
        IDE_RESPONSE,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CResponse::StaticWrite

Static method. Sends data until either everything is sent
or there's an error.

Parameters:
    pIReq        CIsapiReqInfo to send
    pchBuf      pointer to buffer to send
    cchBuf      number of bytes to send (0 means do strlen())
    pTemplate   pointer to template if pchBuf points into a CTemplate

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::StaticWrite
(
CIsapiReqInfo *pIReq,
char *pchBuf,
DWORD cchBuf,
CTemplate   *pTemplate
)
{
    HRESULT hr = S_OK;
    HSE_SEND_ENTIRE_RESPONSE_INFO HseResponseInfo;
    WSABUF_VECTORS WsabuffVectors;
    LPWSABUF_VECTORS pWsabuffVectors = NULL;
    BOOL fHeadersWritten = pIReq->FHeadersWritten();
    BOOL fHeadRequest = (stricmp(pIReq->QueryPszMethod(), "HEAD") == 0);

    if (fHeadersWritten && fHeadRequest)
        return S_OK;

    ZeroMemory( &HseResponseInfo, sizeof(HSE_SEND_ENTIRE_RESPONSE_INFO));

    CResponseBufferSet  *pBufferSet = new CResponseBufferSet;

    if (pBufferSet == NULL)
        return E_OUTOFMEMORY;

    hr = pBufferSet->Init(DEFAULT_BUFFER_LIMIT);

    if (FAILED(hr))
        goto LExit;

    if (cchBuf == 0)
        cchBuf = strlen(pchBuf);

    if (!fHeadersWritten) {

        hr = ConstructSimpleHeaders( &HseResponseInfo.HeaderInfo, cchBuf,
                                     (char *)GetResponseMimeType(pIReq));

        if (FAILED(hr))
            goto LExit;

        // set fKeepConn to TRUE to indicate that we do prefer that to
        // keep the connection.  SendClientResponse() may decide that
        // it's not possible, though.

        HseResponseInfo.HeaderInfo.fKeepConn = TRUE;
    }

    if (pTemplate)
        pBufferSet->SetTemplate(pTemplate);

    if (fHeadRequest)
        goto LSendResponse;

    hr = pBufferSet->PResponseBuffer()->Write(pchBuf,
                                              cchBuf,
                                              FALSE,               // don't chunk the data
                                              !!pTemplate);        // is data in the template?

    if (FAILED(hr))
        goto LExit;

    CResponseVector * pResponseVector = pBufferSet->PResponseBuffer()->GetResponseVector();
    pResponseVector->GetVectors( &WsabuffVectors);
    pWsabuffVectors = &WsabuffVectors;


LSendResponse:

    if (!pIReq->SendClientResponse(CResponseBufferSet::SendResponseCompletion,
                                              pBufferSet,
                                              &HseResponseInfo,
                                              pWsabuffVectors))
        hr = HRESULT_FROM_WIN32(GetLastError());


LExit:

    // if these values are set, then SendClientResponse didn't take
    // ownership of this memory and it needs to be deleted here

    if (HseResponseInfo.HeaderInfo.pszStatus)
        free((PVOID)HseResponseInfo.HeaderInfo.pszStatus);

    if (HseResponseInfo.HeaderInfo.pszHeader)
        free((PVOID)HseResponseInfo.HeaderInfo.pszHeader);

    if (FAILED(hr)) {

        delete pBufferSet;
    }

    return hr;
}

/*===================================================================
CResponse::SyncWriteFile

Static method.
Sends entire response as a content of the file

Parameters:
    pIReq            CIsapiReqInfo to send
    szFile          file name
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteFile
(
CIsapiReqInfo *pIReq,
TCHAR *szFile,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
{
    HRESULT             hr    = S_OK;
    CStaticWriteFileCB  *pCB  = NULL;
    HANDLE              hFile = INVALID_HANDLE_VALUE;
    DWORD               dwSize;
    HSE_SEND_ENTIRE_RESPONSE_INFO   hseResponseInfo;
    BOOL fHeadersWritten = pIReq->FHeadersWritten();
    BOOL fHeadRequest = (stricmp(pIReq->QueryPszMethod(), "HEAD") == 0);

    if (fHeadersWritten && fHeadRequest)
        return S_OK;

    ZeroMemory( &hseResponseInfo, sizeof(HSE_SEND_ENTIRE_RESPONSE_INFO));

    pCB = new CStaticWriteFileCB;

    if (pCB == NULL) {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    if (szMimeType == NULL)
        szMimeType = (char *)GetResponseMimeType(pIReq);

    // open the file
    hFile = AspCreateFile(szFile,
                       GENERIC_READ,          // access (read-write) mode
                       FILE_SHARE_READ,       // share mode
                       NULL,                  // pointer to security descriptor
                       OPEN_EXISTING,         // how to create
                       FILE_ATTRIBUTE_NORMAL, // file attributes
                       NULL                   // handle to file with attributes to copy
                       );
    if (hFile == INVALID_HANDLE_VALUE)
    {
        DBGERROR((DBG_CONTEXT, "Could not open \"%S\".  Win32 Error = %u\n",
                 szFile, GetLastError()));
        hr = E_FAIL;
        goto LExit;
    }

    // get file size
    dwSize = GetFileSize(hFile, NULL);
    if (dwSize == 0 || dwSize == 0xFFFFFFFF)
    {
        hr = E_FAIL;
        goto LExit;
    }

    hr = ConstructSimpleHeaders( &hseResponseInfo.HeaderInfo, dwSize, szMimeType, szStatus, szExtraHeaders);

    if (FAILED(hr))
        goto LExit;

    if (fHeadRequest)
        goto LSendResponse;

    // this is our way to transfer a file handle in a WSABUF

    hseResponseInfo.cWsaBuf  = 0xFFFFFFFF;
    hseResponseInfo.rgWsaBuf = &(pCB->m_wsaBuf);

    pCB->m_wsaBuf.len = dwSize;
    pCB->m_wsaBuf.buf = (char *)hFile;

    // ownership of the handle has been transferred to the WSABUF
    hFile = INVALID_HANDLE_VALUE;


LSendResponse:

    if (!pIReq->SendClientResponse(CResponse::StaticWriteFileCompletion,
                                   pCB,
                                   &hseResponseInfo)) {
        DWORD   dwError = GetLastError();
        CResponse::StaticWriteFileCompletion(pIReq, pCB, 0, dwError);
        hr = HRESULT_FROM_WIN32(dwError);

        // DO NOT place a goto here!!!  It will mess up the handling
        // of the pCB cleanup.
    }

    // NULL out pCB so that it won't be freed below. The async compl
    // is now responsible for it via either an error above, or by
    // a real completion.  Note that a goto above will mess this up
    // and likely cause a double free.

    pCB = NULL;

LExit:

    // cleanup
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    // if pCB is still non-zero, then it needs to be freed

    if (pCB)
        delete pCB;

    return hr;
}

VOID CResponse::StaticWriteFileCompletion(CIsapiReqInfo  *pIReq,
                                          PVOID          pContext,
                                          DWORD          cbIO,
                                          DWORD          dwError)
{
    CStaticWriteFileCB *pCB = (CStaticWriteFileCB *)pContext;

#ifndef PERF_DISABLE
    AddtoTotalByteOut(cbIO);
#endif

    delete pCB;
}

/*===================================================================
CResponse::WriteScriptlessTemplate

Static method.
Sends entire response as a content of the [scriptless] template.

Parameters:
    pIReq        CIsapiReqInfo to send
    pTemplate    template

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::WriteScriptlessTemplate
(
CIsapiReqInfo *pIReq,
CTemplate *pTemplate
)
    {
    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    Assert(pTemplate && pTemplate->FScriptless());

    HRESULT hr = pTemplate->GetHTMLBlock(0, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);

    if (FAILED(hr))
        return hr;
    if (pbHTML == NULL || cbHTML == 0)
        return E_FAIL;

    hr = StaticWrite(pIReq, pbHTML, cbHTML, pTemplate);

    return hr;
    }

/*===================================================================
CResponse::WriteBlocksResponse

Static method.
Sends entire response as a content of a set of memory blocks.

Parameters:
    pIReq           CIsapiReqInfo to send
    cBlocks         number of blocks
    pWsaBuf         array of cBlocks structures with data pointers and length
    cbTotal         total amount of data
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Note: we also use a WSABUF for file handles. This is encoded by cBlocks == 0xFFFFFFFF

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::WriteBlocksResponse
(
CIsapiReqInfo *pIReq,
DWORD cBlocks,
LPWSABUF pWsaBuf,
DWORD cbTotal,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
{
    HRESULT hr = S_OK;
    HSE_SEND_ENTIRE_RESPONSE_INFO HseResponseInfo;
    WSABUF_VECTORS WsabuffVectors;
    LPWSABUF_VECTORS pWsabuffVectors = NULL;
    BOOL fHeadersWritten = pIReq->FHeadersWritten();
    BOOL fHeadRequest = (stricmp(pIReq->QueryPszMethod(), "HEAD") == 0);

    if (fHeadersWritten && fHeadRequest)
        return S_OK;

    ZeroMemory( &HseResponseInfo, sizeof(HSE_SEND_ENTIRE_RESPONSE_INFO));

    CResponseBufferSet  *pBufferSet = new CResponseBufferSet;

    if (pBufferSet == NULL)
        return E_OUTOFMEMORY;

    hr = pBufferSet->Init(DEFAULT_BUFFER_LIMIT);

    if (FAILED(hr))
        goto LExit;

    if (!fHeadersWritten) {

        if (szMimeType == NULL)
            szMimeType = (char *)GetResponseMimeType(pIReq);

        hr = ConstructSimpleHeaders( &HseResponseInfo.HeaderInfo,
                                     cbTotal,
                                     szMimeType,
                                     szStatus,
                                     szExtraHeaders);

        if (FAILED(hr))
            goto LExit;

        // set fKeepConn to TRUE to indicate that we do prefer that to
        // keep the connection.  SendClientResponse() may decide that
        // it's not possible, though.

        HseResponseInfo.HeaderInfo.fKeepConn = TRUE;
    }

    if (fHeadRequest)
        goto LSendResponse;

    for (DWORD i = 0; SUCCEEDED(hr) && (i < cBlocks); i++) {

        hr = pBufferSet->PResponseBuffer()->Write(pWsaBuf[i].buf,
                                                  pWsaBuf[i].len,
                                                  FALSE);   // dont' chunk the data

        if (FAILED(hr))
            goto LExit;
    }

    CResponseVector * pResponseVector = pBufferSet->PResponseBuffer()->GetResponseVector();
    pResponseVector->GetVectors( &WsabuffVectors);
    pWsabuffVectors = &WsabuffVectors;


LSendResponse:

    if (!pIReq->SendClientResponse(CResponseBufferSet::SendResponseCompletion,
                                              pBufferSet,
                                              &HseResponseInfo,
                                              pWsabuffVectors))
        hr = HRESULT_FROM_WIN32(GetLastError());


LExit:

    // if these values are set, then SendClientResponse didn't take
    // ownership of this memory and it needs to be deleted here

    if (HseResponseInfo.HeaderInfo.pszStatus)
        free((PVOID)HseResponseInfo.HeaderInfo.pszStatus);

    if (HseResponseInfo.HeaderInfo.pszHeader)
        free((PVOID)HseResponseInfo.HeaderInfo.pszHeader);

    if (FAILED(hr)) {

        delete pBufferSet;
    }

    return hr;
}

/*===================================================================
CResponse::ConstructSimpleHeaders

Static method.

Allocates and sets the Header parameters in pHeaderInfo.

NOTE - this routine allocates memory with malloc to populate the
headerinfo parameters.  If this routine fails, it remains the
callers responsibility to clean up any allocated memory.

Parameters:
    pHeaderInfo     HSE_SEND_HEADER_EX_INFO struct to fill out
    cbTotal         bytes to send for ContentLength header
    szMimeType      MimeType
    szStatus        HTTP status string
    szExtraHeaders  other headers

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::ConstructSimpleHeaders
(
LPHSE_SEND_HEADER_EX_INFO pHeaderInfo,
DWORD cbTotal,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
{
    BOOL fCacheControlPrivate = FALSE;

    // defaut status
    if (szStatus == NULL)
    {
        szStatus = (char *)s_szDefaultStatus;
        fCacheControlPrivate = TRUE;
    }
    else
    {
        fCacheControlPrivate = (strcmp(szStatus, s_szDefaultStatus) == 0);
    }

    // extra headers size

    DWORD cbExtra = (szExtraHeaders != NULL) ? strlen(szExtraHeaders) : 0;

    // send the header

    char szLength[20];
    ltoa(cbTotal, szLength, 10);

    DWORD cchContentHeader = (DWORD)(0
      + sizeof(s_szContentTypeHeader)-1     // Content-Type:
      + strlen(szMimeType)                  // text/html
      + 2                                   // \r\n
      + cbExtra                             // Extra headers
      + sizeof(s_szContentLengthHeader)-1   // Content-Length:
      + strlen(szLength)                    // <length>
      + 4                                   // \r\n\r\n
      + 1);                                 // '\0'

    if (fCacheControlPrivate)
        cchContentHeader += sizeof(s_szCacheControlPrivate)-1;

    pHeaderInfo->pszHeader = (LPCSTR)malloc(cchContentHeader);

    if (pHeaderInfo->pszHeader == NULL)
        return E_OUTOFMEMORY;

    char *szBuf = (char *)pHeaderInfo->pszHeader;

    szBuf = strcpyExA(szBuf, s_szContentTypeHeader);
    szBuf = strcpyExA(szBuf, szMimeType);
    szBuf = strcpyExA(szBuf, "\r\n");

    if (cbExtra > 0)
        szBuf = strcpyExA(szBuf, szExtraHeaders);

    if (fCacheControlPrivate)
        szBuf = strcpyExA(szBuf, s_szCacheControlPrivate);

    szBuf = strcpyExA(szBuf, s_szContentLengthHeader);
    szBuf = strcpyExA(szBuf, szLength);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");

    pHeaderInfo->pszStatus = StringDupA(szStatus);

    if (pHeaderInfo->pszStatus == NULL)
        return E_OUTOFMEMORY;

    pHeaderInfo->cchStatus = strlen(szStatus);
    pHeaderInfo->cchHeader = cchContentHeader;
    pHeaderInfo->fKeepConn = FALSE;

    return S_OK;
}


/*===================================================================
CResponse::ConstructHeaders

Fill a buffer with standard HTTP headers and any user created headers.

Parameters:
    pHeaderInfo - pointer to header info structure to fill with header
                details and pointers to content.
    pHeaders    - points to a resizable buffer object, to be sized and
                filled with the header content.

Returns:
    HRESULT     S_OK on success
                E_FAIL if unable to build expires headers
                E_OUTOFMEMORY if memory failure
===================================================================*/
HRESULT CResponse::ConstructHeaders
(
LPHSE_SEND_HEADER_EX_INFO pHeaderInfo
)
{
    CHAR *szBuff = NULL;
    DWORD cch = 0;
    BOOL fContentTypeFound = FALSE;
    HRESULT     hr = S_OK;

    // Static cookie buffer should be enough to fit:
    //   cookie name    20 chars
    //   cookie value   24 chars
    //   decorations    28 = strlen("Set-Cookie: C=V; secure; path=/;\r\n")
#define CCH_STATIC_COOKIE_BUF    88
    char szCookieBuff[CCH_STATIC_COOKIE_BUF];
    DWORD cchCookieBuff = 0;

    AssertValid();

    // Loop through any headers counting up the length
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        cch += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Add the content-type tag
    cch += sizeof(s_szContentTypeHeader)-1;
    cch += strlen(PContentType())+2;

    // Add the Character set tag
    if (m_pData->m_pszCharSet) {
        cch += sizeof(s_szCharSetHTML)-1;
        cch += strlen(m_pData->m_pszCharSet);
    }

    // Add the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL))
        cch += DATE_STRING_SIZE + 11;   // DATE_STRING_SIZE + length("Expires: \r\n")

    // Add the cookies that we will send
    cch += m_pData->m_WriteCookies.QueryHeaderSize()+2;

    // Account for space required by headers we always send back.

    // Prepare cookie if any.
    if (m_pData->m_szCookieVal) {
        char *pchEnd = strcpyExA(szCookieBuff, "Set-Cookie: ");
        pchEnd = strcpyExA(pchEnd, m_pData->m_pHitObj->PAppln()->GetSessionCookieName(m_pData->m_pHitObj->FSecure()));
        pchEnd = strcpyExA(pchEnd, "=");
        pchEnd = strcpyExA(pchEnd, m_pData->m_szCookieVal);

        // If we keep secure sessions secure, and this connection is secure,  add flag to cookie
        if ((m_pData->m_pHitObj->QueryAppConfig()->fKeepSessionIDSecure()) &&
            (m_pData->m_pHitObj->FSecure()))
        {
            pchEnd = strcpyExA(pchEnd,"; secure");
        }

        pchEnd = strcpyExA(pchEnd, "; path=/\r\n");
        cchCookieBuff = strlen(szCookieBuff);
        cch += cchCookieBuff;
        Assert(cchCookieBuff < CCH_STATIC_COOKIE_BUF);
    }
    else {
        szCookieBuff[0] = '\0';
        cchCookieBuff = 0;
    }

    // Will len of cache control header
    if (m_pData->m_pszCacheControl) {
        cch += sizeof(s_szCacheControl)-1;
        cch += strlen(m_pData->m_pszCacheControl)+2;
    }
    else {
        cch += sizeof(s_szCacheControlPrivate)-1;
    }

    if (m_pData->FChunkData())
        cch += sizeof(s_szTransferEncoding)-1;

    // Will terminate with \r\n.  Leave extra space
    cch += 2;

    /*
     * We know how big; allocate memory and build the string.
     */

    if (!(szBuff = (LPSTR)malloc(cch + 1))) {
        return E_OUTOFMEMORY;
    }
    *szBuff = '\0';

    char *szTmpBuf = szBuff;

    pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        pHeader->Print(szTmpBuf);
        szTmpBuf += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Send the content-type tag
    szTmpBuf = strcpyExA(szTmpBuf, s_szContentTypeHeader);
    szTmpBuf = strcpyExA(szTmpBuf, PContentType());

    // Send the CharSet tag if exists
    if (m_pData->m_pszCharSet) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCharSetHTML);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCharSet);
    }

    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    // Send the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL)) {

        // if the script set an expires value, than use it
        if (m_pData->m_tExpires != -1) {
            szTmpBuf = strcpyExA(szTmpBuf, "Expires: ");
            if (FAILED(CTimeToStringGMT(&m_pData->m_tExpires, szTmpBuf))) {
                hr = E_FAIL;
                goto LExit;
            }
            szTmpBuf += strlen(szTmpBuf);
            szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
        }
        // else, use the default value in the metabase.  Note that it already
        // includes the Expires: prefix and \r\n suffix
        else {

            szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszDefaultExpires);
        }
    }

    // send the cookies
    m_pData->m_WriteCookies.GetHeaders(szTmpBuf);
    szTmpBuf += strlen(szTmpBuf);

    // Send the required headers: session id cookie and cache control
    szTmpBuf = strcpyExA(szTmpBuf, szCookieBuff);

    // Send the cache-control tag
    if (m_pData->m_pszCacheControl) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
    }
    else {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControlPrivate);
    }

    // Chunked encoding
    if (m_pData->FChunkData())
        szTmpBuf = strcpyExA(szTmpBuf, s_szTransferEncoding);

    // Add trailing \r\n to terminate headers
    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    Assert(strlen(szBuff) <= cch);

    // Output the headers
    // Failure is not a fatal error, so we still return success
    // but set the m_fWriteClient flag
    CHAR *szStatus = m_pData->m_pszStatus ? m_pData->m_pszStatus
                                          : (CHAR *)s_szDefaultStatus;

    BOOL fKeepConnected =
        (m_pData->m_fBufferingOn && !m_pData->m_fFlushed) || m_pData->FChunkData();

    DWORD cchStatus = strlen(szStatus);
    DWORD cchHeader = strlen(szBuff);

    pHeaderInfo->pszStatus = StringDupA(szStatus);
    pHeaderInfo->cchStatus = cchStatus;
    pHeaderInfo->pszHeader = szBuff;
    pHeaderInfo->cchHeader = cchHeader;
    pHeaderInfo->fKeepConn = fKeepConnected;

LExit:

    if (FAILED(hr) && szBuff)
        free(szBuff);

    return hr;
}

//IResponse interface functions


/*===================================================================
CResponse::WriteResponse

Generic routine to send headers and data to the client.

If headers have not been sent out yet, they will be sent the first time
this routine is called.

If transmission of the headers or data to the client fails, we still
want the calling script to finish execution, so we will return
S_OK, but set the m_fWriteClientError flag. If we are unable
to build the needed headers we will return E_FAIL.

Parameters:
    None

Returns:
    HRESULT     S_OK on success
                E_FAIL if unable to build expires headers
                E_OUTOFMEMORY if memory failure
===================================================================*/
HRESULT CResponse::WriteResponse()
{
    HRESULT hr = S_OK;
    HSE_SEND_ENTIRE_RESPONSE_INFO   HseResponseInfo;
    WSABUF_VECTORS WsabuffVectors;
    LPWSABUF_VECTORS pWsabuffVectors = NULL;
    BOOL fClearBuffers = FALSE;
    CTemplate       *pTemplate = m_pData->m_pBufferSet->PTemplate();

    STACK_BUFFER( tempWSABUFs, 128 );

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FDontWrite())
        return S_OK;

    ZeroMemory( &HseResponseInfo.HeaderInfo, sizeof(HSE_SEND_HEADER_EX_INFO));

    if (!FHeadersWritten())
    {
        if (FAILED(hr = ConstructHeaders( &HseResponseInfo.HeaderInfo)))
        {
            return hr;
        }
    }

    HseResponseInfo.cWsaBuf = 0;
    HseResponseInfo.rgWsaBuf = NULL;

    if (IsHeadRequest())
    {
        if (FHeadersWritten())
            goto LExit;

        goto Send_Response;
    }

    BOOL    fSendDebugBuffers = (m_pData->m_fClientDebugMode && m_pData->m_pBufferSet->PClientDebugBuffer());

    fClearBuffers = TRUE;

    // populate struct with response body buffers (and, if required, debug buffers)

    if (fSendDebugBuffers)
    {
        CResponseBuffer * pClientDebugBuffer = m_pData->m_pBufferSet->PClientDebugBuffer();
        DWORD   cClientDebugBuffers = pClientDebugBuffer->CountOfBuffers();

        if (cClientDebugBuffers)
        {
            HseResponseInfo.cWsaBuf = cClientDebugBuffers;

            if (!tempWSABUFs.Resize(HseResponseInfo.cWsaBuf * sizeof(WSABUF)))
            {
                hr = E_OUTOFMEMORY;
                goto LExit;
            }

            HseResponseInfo.rgWsaBuf = static_cast<WSABUF *>(tempWSABUFs.QueryPtr());

            // fill debug buffers
            for ( UINT i = 0; i < cClientDebugBuffers; i++ )
            {
                HseResponseInfo.rgWsaBuf[i].len = pClientDebugBuffer->GetBufferSize(i);
                HseResponseInfo.rgWsaBuf[i].buf = pClientDebugBuffer->GetBuffer(i);
            }
        }
    }

    CResponseVector * pResponseVector = m_pData->m_pBufferSet->PResponseBuffer()->GetResponseVector();
    pResponseVector->GetVectors( &WsabuffVectors);
    pWsabuffVectors = &WsabuffVectors;


Send_Response:

    BOOL fResponseSent;

    // send entire response (headers and body) at once
    fResponseSent = GetIReq()->SendClientResponse(CResponseBufferSet::SendResponseCompletion,
                                                  m_pData->m_pBufferSet,
                                                  &HseResponseInfo,
                                                  pWsabuffVectors);

    if (fResponseSent)
    {
        m_pData->m_pBufferSet = new CResponseBufferSet();

        if (m_pData->m_pBufferSet == NULL) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        hr = m_pData->m_pBufferSet->Init(m_pData->m_dwBufferLimit);

        if (FAILED(hr))
            goto LExit;

        m_pData->m_pBufferSet->SetTemplate(pTemplate);

        fClearBuffers = FALSE;
    }
    else
    {
        m_pData->m_fWriteClientError = TRUE;
    }

    // we have consumed the buffered data, so clear.
    if (fClearBuffers)
    {
        if (m_pData->m_pBufferSet->PClientDebugBuffer())
        {
            m_pData->m_pBufferSet->PClientDebugBuffer()->Clear();
        }

        m_pData->m_pBufferSet->PResponseBuffer()->Clear();
    }

LExit:

    if (FAILED(hr)) {

        if (HseResponseInfo.HeaderInfo.pszStatus)
            free((PVOID)HseResponseInfo.HeaderInfo.pszStatus);

        if (HseResponseInfo.HeaderInfo.pszHeader)
            free((PVOID)HseResponseInfo.HeaderInfo.pszHeader);
    }

    return hr;
}

/*===================================================================
CResponse::Write

Writes a string to the client.

It accepts a variant as an argument and attempts to coerce that
variant into a BSTR. We convert that BSTR into an ANSI string,
and then hand that ANSI string to Response::WriteSz which sends
it back to the client.

Normally a VT_NULL variant cannot be coerced to a BSTR, but we want
VT_NULL to be a valid input, therefore we explictly handle the case of
variants of type VT_NULL. If the type of the input variant is VT_NULL
we return S_OK, but don't send anything back to the client.

If we are handed a VT_DISPATCH variant, we resolve it by repeatedly calling
Dispatch on the associated pdispVal, until we get back a variant that is not
a VT_DISPATCH. VariantChangeType would ordinarily handle this for us, but the
final resulting variant might be a VT_NULL which VariantChangeType would not
coerce into a BSTR. This is why we have to handle walking down the VT_DISPATC
variants outselves.

Parameters:
    VARIANT     varInput, value: the variant to be converted to string
                                  and written to the client

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Write(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD cch;
    LPSTR szT;
    BSTR  bstr;
    VARIANT varResolved;

    static char szTrue[MAX_MESSAGE_LENGTH];
    static char szFalse[MAX_MESSAGE_LENGTH];

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // If already BSTR (directly or as VARIANT by ref)
    bstr = VariantGetBSTR(&varInput);
    if (bstr != NULL)
        {
        hr = WriteBSTR(bstr);
        goto lRet2;
        }

    // If the variant passed in is a VT_DISPATCH, get its default property
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Check if the variant in is VT_NULL
    if (V_VT(&varResolved) == VT_NULL)
        goto lRet;                  // S_OK, but don't send anything to the client

    // Check if the variant in is VT_BOOL
    if(V_VT(&varResolved) == VT_BOOL)
        {
        if (V_BOOL(&varResolved) == VARIANT_TRUE)
            {
            if (szTrue[0] == '\0')
                cch = CchLoadStringOfId(IDS_TRUE, szTrue, MAX_MESSAGE_LENGTH);
            szT = szTrue;
            }
        else
            {
            if(szFalse[0] == '\0')
                cch = CchLoadStringOfId(IDS_FALSE, szFalse, MAX_MESSAGE_LENGTH);
            szT = szFalse;
            }
        cch = strlen(szT);
        if (FAILED(hr = WriteSz(szT, cch)))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
        goto lRet;
        }

    // Coerce the variant into a bstr if necessary
    if (V_VT(&varResolved) != VT_BSTR)
        {
        if (FAILED(hr = VariantChangeTypeEx(&varResolved, &varResolved, m_pData->m_pHitObj->GetLCID(), 0, VT_BSTR)))
            {
            switch (GetScode(hr))
                {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            goto lRet;
            }
        }

    hr = WriteBSTR(V_BSTR(&varResolved));

lRet:
#ifdef DBG
    hr =
#endif // DBG
    VariantClear(&varResolved);
    Assert(SUCCEEDED(hr));
lRet2:
    return(hr);
    }

/*===================================================================
CResponse::BinaryWrite

Function called from DispInvoke to invoke the BinaryWrite method.

Parameters:
    varInput    Variant which must resolve to an array of unsigned bytes

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::BinaryWrite(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD nDim = 0;
    long lLBound = 0;
    long lUBound = 0;
    void *lpData = NULL;
    DWORD cch = 0;
    VARIANT varResolved;
    SAFEARRAY* pvarBuffer;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // De-reference and de-dispatch the variant
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Coerce the result into an array of VT_UI1 if needed
    if (V_VT(&varResolved) != (VT_ARRAY|VT_UI1))
    {
        if (FAILED(hr = VariantChangeType(&varResolved, &varResolved, 0, VT_ARRAY|VT_UI1)))
        {
            switch (GetScode(hr))
            {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
            goto lRet;
        }
    }

    // We got here, so we must have a variant containing a safe array of UI1 in varResolved
    pvarBuffer = V_ARRAY(&varResolved);

    nDim = SafeArrayGetDim(pvarBuffer);
    if (nDim != 1)
    {
        hr = E_INVALIDARG;
        goto lRet;
    }

    if (FAILED(SafeArrayGetLBound(pvarBuffer, 1, &lLBound)))
    {
        hr = E_INVALIDARG;
        goto lRet;
    }

    if (FAILED(SafeArrayGetUBound(pvarBuffer, 1, &lUBound)))
        {
        hr = E_INVALIDARG;
        goto lRet;
    }

    if (FAILED(SafeArrayAccessData(pvarBuffer, &lpData)))
    {
        hr = E_INVALIDARG;
        goto lRet;
    }
    cch = lUBound - lLBound + 1;

    hr = m_pData->m_pBufferSet->PResponseBuffer()->Write((char *) lpData,
                                                          cch,
                                                          m_pData->FChunkData());

    if (FAILED(hr))
    {
        // We can't buffer the ouput, so quit
        SafeArrayUnaccessData(pvarBuffer);
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        goto lRet;
    }

    else if (!m_pData->m_fBufferingOn)
    {
        // Buffering is off, Flush the data we just added to the response buffer

        hr = WriteResponse();
        if (FAILED(hr)) {
            SafeArrayUnaccessData(pvarBuffer);
            goto lRet;
        }
    }

    hr = SafeArrayUnaccessData(pvarBuffer);

lRet:
    VariantClear(&varResolved);
lRet2:
    return(hr);
}

/*===================================================================
CResponse::WriteSz

Support routine for the Write method to write the string.  Unlike
CResponse::Write(), this routine takes an Ascii string, and is
not intended to be exposed as a method

Parameters:
    sz - String to write as an Ascii string
    cch - Length of string to write

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::WriteSz(CHAR *sz, DWORD cch)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    // don't bother with zero byte writes...

    if (cch == 0)
        goto lRet;

   hr = m_pData->m_pBufferSet->PResponseBuffer()->Write(sz,
                                                        cch,
                                                        m_pData->FChunkData());

   if (SUCCEEDED(hr) && !m_pData->m_fBufferingOn)
        {
            hr = WriteResponse();
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponse::WriteBSTR

Support routine for the Write method

Parameters:
    BSTR - String to write as an Ascii string

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::WriteBSTR(BSTR bstr)
    {
    CWCharToMBCS  convStr;
    HRESULT       hr = NO_ERROR;

    if (FAILED(hr = convStr.Init(bstr, m_pData->m_pHitObj->GetCodePage())));


    else hr = WriteSz(convStr.GetString(), convStr.GetStringLen());

    if (FAILED(hr))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }

    return hr;
    }

/*===================================================================
CResponse::WriteBlock

Function called from DispInvoke to invoke the WriteBlock method.

Parameters:
    Identifier for the HTML block

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
HRESULT CResponse::WriteBlock(short iBlockNumber)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    // bail out (and assert) if template is null
    Assert(m_pData->m_pBufferSet->PTemplate() != NULL);
    if (m_pData->m_pBufferSet->PTemplate() == NULL)
    {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        goto lRet;
    }

    /*
        get ptr and byte count for html block from template
        NOTE: by design, this public template call cannot fail because we give it a block id
        generated during template compilation (instead we assert within and after the call)

        I added the return HRESULT to catch for invalid user access of this method, if a user
        attempts to access this method and passes an invalid array offset it will return the
        error IDE_BAD_ARRAY_INDEX, this really should not happen except for the case of a user
        attempting to access this hidden method.
    */


    hr = m_pData->m_pBufferSet->PTemplate()->GetHTMLBlock(iBlockNumber, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);
    if ( hr != S_OK )
    {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_BAD_ARRAY_INDEX);
        goto lRet;
    }

    Assert(pbHTML);
    Assert(cbHTML > 0);

    if (m_pData->m_fBufferingOn)
    {
        // Buffering is on
        hr = S_OK;

        // Take care of Client Debugger issues
        if (m_pData->m_fClientDebugMode && m_pData->m_pBufferSet->PClientDebugBuffer())
        {
            if (cbSrcOffset) // only if source info is known
            {
                // Write a METADATA line corresponding to this block
                // into ClientDebugBuffer
                ULONG cbPos = m_pData->m_pBufferSet->PResponseBuffer()->BytesBuffered() + 1;
                ULONG cbLen = cbHTML;

                hr  = m_pData->m_pBufferSet->PClientDebugBuffer()->AppendRecord(
                    cbPos, cbLen, cbSrcOffset, pbIncSrcFileName);
            }
        }
    }
        // Write the actual data
    if (SUCCEEDED(hr))
    {
        hr = m_pData->m_pBufferSet->PResponseBuffer()->Write(pbHTML,
                                                             cbHTML,
                                                             m_pData->FChunkData(),
                                                             TRUE);     // data's in template
    }

    if (FAILED(hr))
    {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
    }

    if (SUCCEEDED(hr) && !m_pData->m_fBufferingOn)
        hr = WriteResponse();

lRet:

    return(hr);
}

/*===================================================================
CResponse::GetClientVersion

Uses GetServerVariable to determine the HTTP version of the client.
Borrowed from simiarl code in w3 server Httpreq.cxx, OnVersion()

Parameters:

    None

Returns:
    None
===================================================================*/
VOID CResponse::GetClientVerison()
    {
    if (FAILED(CheckForTombstone()))
        return;

    if (m_pData->m_pIReq)
        {
        m_pData->m_dwVersionMajor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMajor();
        m_pData->m_dwVersionMinor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMinor();
        }
    else
        {
        // Assume version 0.9
        m_pData->m_dwVersionMajor = 0;
        m_pData->m_dwVersionMinor = 9;
        }
    }

/*===================================================================
CResponse::AppendHeader

Functions to add headers of different kind
(hardcoded and user-supplied)

Parameters:
    Name, Value

Returns:
    HRESULT         S_OK if ok

===================================================================*/
HRESULT CResponse::AppendHeader(BSTR wszName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(wszName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, szValue, fCopyValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, long lValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, lValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

/*===================================================================
CResponse::get_ContentType

Functions called from DispInvoke to return the ContentType property.

Parameters:
    pbstrContentTypeRet     BSTR FAR *, return value: pointer to the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ContentType
(
BSTR FAR * pbstrContentTypeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    hr = SysAllocStringFromSz((char *)PContentType(), 0, pbstrContentTypeRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_ContentType

Functions called from DispInvoke to set the ContentType property.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ContentType
(
BSTR bstrContentType
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT       hr = S_OK;
    CWCharToMBCS  convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszContentType) {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrContentType)));

    else if ((m_pData->m_pszContentType = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::get_Status

Function called from DispInvoke to return the Status property.

Parameters:
    pbstrStatusRet      BSTR FAR *, return value: pointer to the Status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Status
(
BSTR FAR * pbstrStatusRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    if (m_pData->m_pszStatus)
        hr = SysAllocStringFromSz(m_pData->m_pszStatus, 0, pbstrStatusRet);
    else
        hr = SysAllocStringFromSz((CHAR *)s_szDefaultStatus, 0, pbstrStatusRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_Status

Function called from DispInvoke to set the ContentType property.

Parameters:
    bstrStatus      BSTR, value: the status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Status
(
BSTR bstrStatus
)
    {
    DWORD dwStatus = 200;

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT      hr = S_OK;
    CWCharToMBCS convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszStatus) {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrStatus)));

    else if ((m_pData->m_pszStatus = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        dwStatus = atol(m_pData->m_pszStatus);
        GetIReq()->SetDwHttpStatusCode(dwStatus);
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_Expires

Function called from DispInvoke to return the Expires property.

Parameters:
    plExpiresTimeRet        long *, return value: pointer to number of minutes until response expires

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Expires
(
VARIANT * pvarExpiresTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // return early if we can
    //
    if (m_pData->m_tExpires == -1)
        {
        V_VT(pvarExpiresTimeRet) = VT_NULL;
        return S_OK;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);

    // get the time difference and round to the nearest minute
    //
    V_VT(pvarExpiresTimeRet) = VT_I4;
    V_I4(pvarExpiresTimeRet) = long((difftime(m_pData->m_tExpires, tNow) / 60) + 0.5);
    return S_OK;
    }

/*===================================================================
CResponse::put_Expires

Functions called from DispInvoke to set the expires property.

Parameters:
    iValue      int, value: the number of minutes until response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Expires
(
long lExpiresMinutes
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);
    time_t tRelativeTime;
    // add the number of minuites.  (must convert to seconds first)
    //
    tRelativeTime = lExpiresMinutes * 60;
    if ((lExpiresMinutes < 0 && tRelativeTime > 0)
        || (lExpiresMinutes > 0 && tRelativeTime < 0))
        {
        // overflow, tRelativeTime could be a small positive integer if lExpiresMinutes is
        // some value like 0x80000010
        // tNow will be overflowed if tRelativeTime is negative
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    tNow += tRelativeTime;

    // Store the date if
    //      a. No date was stored previously
    //      b. This date comes before the previously set date.
    //
    if (m_pData->m_tExpires == -1 || tNow < m_pData->m_tExpires)
        {
        struct tm *ptmGMT = gmtime(&tNow);
        if (ptmGMT == NULL)
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
            return E_FAIL;
            }

        m_pData->m_tExpires = tNow;
        }
        // convert time to GMT
    return S_OK;
    }

/*===================================================================
CResponse::get_ExpiresAbsolute

Function called from DispInvoke to return the ExpiresAbsolute property.

Parameters:
    pbstrTimeRet    BSTR *, return value: pointer to string that will contain
                    the time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ExpiresAbsolute
(
VARIANT *pvarTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    V_VT(pvarTimeRet) = VT_DATE;
    CTimeToVariantDate(&m_pData->m_tExpires, &V_DATE(pvarTimeRet));
    return S_OK;
    }

/*===================================================================
CResponse::put_ExpiresAbsolute

Function called from DispInvoke to set the ExpiresAbsolute property.

Parameters:
    pbstrTime       BSTR, value: time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ExpiresAbsolute
(
DATE dtExpires
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (int(dtExpires) == 0)                    // time specified but no date (assume today)
        {
        time_t tToday;                                          // get the date and time now
        DATE dtToday;

        time(&tToday);
        struct tm *tmToday = localtime(&tToday);

        tmToday->tm_hour = tmToday->tm_min = tmToday->tm_sec = 0;       // reset to midnight
        tToday = mktime(tmToday);

        if (FAILED(CTimeToVariantDate(&tToday, &dtToday)))
            return E_FAIL;

        dtExpires += dtToday;
        }

    time_t tExpires;
    if (FAILED(VariantDateToCTime(dtExpires, &tExpires)))
        {
        ExceptionId(IID_IWriteCookie, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    if (m_pData->m_tExpires == -1 || tExpires < m_pData->m_tExpires)
        {
        m_pData->m_tExpires = tExpires;
        }

    return S_OK;
    }

/*===================================================================
CResponse::put_Buffer

Function called from DispInvoke to set the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, if true turn on buffering of HTML output

Returns:
    HRESULT     S_OK if ok

Side Effects:
    Turning buffering on will cause memory to be allocated.
===================================================================*/
STDMETHODIMP CResponse::put_Buffer
(
VARIANT_BOOL fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // Assume TRUE if not 0
    if (fIsBuffering != VARIANT_FALSE)
        fIsBuffering = VARIANT_TRUE;

    // Ignore no change requests
    if ((fIsBuffering == VARIANT_TRUE) && m_pData->m_fBufferingOn)
        return S_OK;
    if ((fIsBuffering == VARIANT_FALSE) && !m_pData->m_fBufferingOn)
        return S_OK;

    // Ignore if change is not allowed to change (Client Dedug)
    if (m_pData->m_fClientDebugMode)
        return S_OK;

    // Set the new value (error if cannot change)

    if (fIsBuffering == VARIANT_TRUE)
        {
        if (FHeadersWritten())
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = TRUE;
        }
    else // if (fIsBuffering == VARIANT_FALSE)
        {
        if ((m_pData->m_pBufferSet->PResponseBuffer()->BytesBuffered() > 0) ||
            FHeadersWritten())
            {
            // If we already buffered some output it is too late to go back
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_CANT_STOP_BUFFER);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_Buffer

Function called from DispInvoke to get the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, value: if true turn buffering of HTML output
                        is turned on

Returns:
    HRESULT         S_OK if ok

Side Effects:
    None

===================================================================*/
STDMETHODIMP CResponse::get_Buffer
(
VARIANT_BOOL *fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fBufferingOn)
        *fIsBuffering = VARIANT_TRUE;
    else
        *fIsBuffering = VARIANT_FALSE;

    return(hr);
    }

/*===================================================================
CResponse::Redirect

Function called from DispInvoke to invoke the Redirect method.

Parameters:
    bstrURL Unicode BSTR    Value: URL to rediect to

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Redirect(BSTR bstrURL)
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT hr = S_OK;
    DWORD cch = 0;
    DWORD cchURL = 0;
    DWORD cchMessage = 0;
    DWORD cchEncodedURL;
    DWORD cchHtmlEncodedURL;
    PSZ szURL = NULL;
    PSZ szMessage = NULL;
    PSZ pszEncodedURL = NULL;
    PSZ pszURL = NULL;
    CWCharToMBCS  convURL;

    STACK_BUFFER( tempURL, 256 );
    STACK_BUFFER( tempMessage, 256 + 512 );


    // Insist that we have a non-zero length URL
    if (bstrURL)
        cchURL = wcslen(bstrURL);

    if (cchURL == 0)
    {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_NO_URL);
        hr =  E_FAIL;
        goto lRet;
    }

    // Check that we haven't already passed data back to the client
    if (FHeadersWritten())
    {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
    }

    // If buffering is on, clear any pending output
    if (m_pData->m_fBufferingOn)
        Clear();

    // turn buffering on for this response.
    m_pData->m_fBufferingOn = TRUE;

    if (FAILED(hr = convURL.Init(bstrURL, m_pData->m_pHitObj->GetCodePage())))
    {
        if (hr == E_OUTOFMEMORY)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszURL = convURL.GetString();

    cchEncodedURL = URLPathEncodeLen(pszURL);

    if (!tempURL.Resize(cchEncodedURL))
    {
        hr = E_OUTOFMEMORY;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszEncodedURL = (PSZ)tempURL.QueryPtr();

    URLPathEncode(pszEncodedURL, pszURL);

    // for the HTML body, further encode URL
    cchHtmlEncodedURL = HTMLEncodeLen(pszEncodedURL,
                                      m_pData->m_pHitObj->GetCodePage(),
                                      NULL,
                                      FALSE);

    // We need to alloccate memory to build the body redirection message.
    // If our memory requirement is small we allocate memory from the stack,
    // otherwise we allocate from the heap.
    cchMessage = cchHtmlEncodedURL;
    cchMessage += 512; // Allow space for sub-strings coming from resource file.

    if (!tempMessage.Resize(cchMessage))
    {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto lRet;
    }

    szMessage = (PSZ)tempMessage.QueryPtr();

    // Build the body redirection message
    // Redirect(URL), URL must be a valid URL, that is, no DBCS string.
    cch = CchLoadStringOfId(IDE_RESPONSE_REDIRECT1, szMessage, cchMessage);
    if (cchHtmlEncodedURL) {
        HTMLEncode(szMessage + cch,
                   pszEncodedURL,
                   m_pData->m_pHitObj->GetCodePage(),
                   NULL,
                   FALSE);
        cch += cchHtmlEncodedURL-1; // get rid of the terminating \0
    }
    cch += CchLoadStringOfId(IDE_RESPONSE_REDIRECT2, szMessage + cch, cchMessage - cch);

    // Set the status to redirect
    put_Status(L"302 Object moved");

    // Add the location header
    AppendHeader("Location", pszEncodedURL, TRUE);

    // Transmit redirect text to the client, headers will be
    // sent automatically
    if (FAILED(WriteSz(szMessage, cch)))
    {
        hr = E_FAIL;
        goto lRet;
    }

    // No further processing of the script
    End();

lRet:

    return(hr);
}

/*===================================================================
CResponse::Add

Functions called from DispInvoke to Add a header.

This is a compatibility for the ISBU controls.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of header
    bstrHeaderName      Unicode BSTR, value: the name of the header

  Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Add
(
BSTR bstrHeaderValue,
BSTR bstrHeaderName
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return AddHeader(bstrHeaderName, bstrHeaderValue);
    }

/*===================================================================
CResponse::AddHeader

Functions called from DispInvoke to Add a header.

Parameters:
    bstrHeaderName      Unicode BSTR, value: the name of the header
    bstrHeaderValue     Unicode BSTR, value: the value of header

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::AddHeader
(
BSTR bstrHeaderName,
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (bstrHeaderName == NULL || wcslen(bstrHeaderName) == 0)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    if (FAILED(AppendHeader(bstrHeaderName, bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::Clear

Erases all output waiting in buffer.

Parameters
    None

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Clear()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode && m_pData->m_fClientDebugFlushIgnored)
        {
        // Clear after flush in ClientDebugMode is an error
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG);
        }
    else if (!m_pData->m_fBufferingOn)
        {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_BUFFER_NOT_ON);
        }
    else
        {
        AssertValid();
        hr = m_pData->m_pBufferSet->PResponseBuffer()->Clear();

        if (SUCCEEDED(hr))
            {
            if (m_pData->m_fClientDebugMode && m_pData->m_pBufferSet->PClientDebugBuffer())
                hr = m_pData->m_pBufferSet->PClientDebugBuffer()->ClearAndStart();
            }

        if (FAILED(hr))
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
    return(hr);
    }

/*===================================================================
CResponse::Flush

Sends out all HTML waiting in the buffer.

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Flush()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    if (!m_pData->m_fBufferingOn)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_BUFFER_NOT_ON);
        hr = E_FAIL;
        goto lRet;
        }

    // Ignore Response.Flush() in Client Debug Mode
    if (m_pData->m_fClientDebugMode)
        {
        m_pData->m_fClientDebugFlushIgnored = TRUE;
        goto lRet;
        }

    if (FHeadersWritten() && (m_pData->BytesBuffered() == 0))
        goto lRet;

    // We mark this response as having had flush called so
    // that we won't try to do keep-alive
    m_pData->m_fFlushed = TRUE;

    if (FAILED(hr = WriteResponse()))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
lRet:
    return(hr);
    }

/*===================================================================
CResponse::FinalFlush

FinalFlush is called if a script terminates without having yet sent
the response headers. This means we can use the Content-Length headers
to increase efficiency. We add those headers, then send all headers,
and all waiting output.

Returns:
    VOID

===================================================================*/
VOID CResponse::FinalFlush(HRESULT hr_Status)
{
    if (FAILED(CheckForTombstone()))
        return;

    HRESULT hr = S_OK;
    AssertValid();

    if (SUCCEEDED(hr_Status) && FHeadersWritten() && (m_pData->BytesBuffered() == 0) && !m_pData->FChunkData())
        goto lRet;

    if (!FHeadersWritten()
        && FAILED(hr_Status)
        && (hr_Status != E_SOURCE_FILE_IS_EMPTY)
        && (m_pData->BytesBuffered() == 0))
    {
        // If there was an error and and nothing is buffered,
        // send "server error" instead of an empty 200 OK response
        Handle500Error(IDE_500_SERVER_ERROR, GetIReq());
        goto lRet;
    }

    if (FDontWrite())
        goto lRet;

    if (m_pData->FChunkData())
    {
        // Add the closing chars when chunking

        m_pData->m_pBufferSet->PResponseBuffer()->Write("0\r\n\r\n", 5, FALSE);
    }

    // If the headers have not yet been sent, see what needs to be added
    if (!FHeadersWritten())
    {
        DWORD dwLength = m_pData->m_pBufferSet->PResponseBuffer()->BytesBuffered();

        // If buffering, add the Content-Length header
        if (m_pData->m_fBufferingOn)
        {

            if (m_pData->m_fClientDebugMode && m_pData->m_pBufferSet->PClientDebugBuffer())
            {
                // end the buffer with end of METADATA
                m_pData->m_pBufferSet->PClientDebugBuffer()->End();
                dwLength += m_pData->m_pBufferSet->PClientDebugBuffer()->BytesBuffered();
            }

            AppendHeader("Content-Length", (LONG)dwLength);
        }
    }


    if (!m_pData->m_fBufferingOn && !m_pData->FChunkData())
    {
        // We mark this response as having had flush called so
        // that we won't try to do keep-alive
        m_pData->m_fFlushed = TRUE;
    }

    // Write response will send the buffered data, and the headers
    // if they haven't already been sent.
    // While WriteResponse can return an error, there isn't much point
    // in checking the return value since FinalFlush is a void return.

    WriteResponse();

lRet:

    if (m_pData->m_pHitObj)
        m_pData->m_pHitObj->SetDoneWithSession();

}

/*===================================================================
CResponse::End

Stops all further template processing, and returns the current response

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::End()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_pfnGetScript != NULL && m_pData->m_pvGetScriptContext != NULL)
        {
        int i = 0;

        CScriptEngine* pEngine;
        while (NULL != (pEngine = (*m_pData->m_pfnGetScript)(i, m_pData->m_pvGetScriptContext)))
            {
            pEngine->InterruptScript(/*fAbnormal*/ FALSE);
            i++;
            }
        }

    m_pData->m_fResponseAborted = TRUE;
    return S_OK;
    }

/*===================================================================
CResponse::AppendToLog

Append a string to the current log entry.

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

Side Effects:
    NONE
===================================================================*/
STDMETHODIMP CResponse::AppendToLog(BSTR bstrLogEntry)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT       hr = S_OK;
    CWCharToMBCS  convEntry;

    // BUGBUG - should this be 65001?

    if (FAILED(hr = convEntry.Init(bstrLogEntry, m_pData->m_pHitObj->GetCodePage())));

    else hr = GetIReq()->AppendLogParameter(convEntry.GetString());

    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        }
        else {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_LOG_FAILURE);
        }
    }

    return(hr);
    }

/*===================================================================
CResponse::get_Cookies

Return the write-only response cookie dictionary

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();
    return m_pData->m_WriteCookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

#ifdef DBG
/*===================================================================
CResponse::AssertValid

Test to make sure that the CResponse object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CResponse::AssertValid() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pBufferSet->PResponseBuffer());
    Assert(m_pData->m_pIReq);
    }
#endif // DBG


/*===================================================================
IsHeadRequest

This function will check the REQUEST_METHOD and set a BOOL flag in
the class.  If the request method is HEAD the flag will be set to
true.

Also the flag must be reset with each init/reinit call

m_IsHeadRequest == 0    // HEAD request status not set
m_IsHeadRequest == 1    // Not a HEAD request
m_IsHeadRequest == 2    // is a HEAD request

Parameters

Returns:
    void

Side effects:
    sets status flag m_IsHeadRequest

===================================================================*/
BOOL CResponse::IsHeadRequest(void)
    {
    if (FAILED(CheckForTombstone()))
        return FALSE;

    AssertValid();

    if (m_pData->m_IsHeadRequest != 0)
        return ( m_pData->m_IsHeadRequest == 2);

    if (stricmp(GetIReq()->QueryPszMethod(), "HEAD") == 0 )
        m_pData->m_IsHeadRequest = 2;
    else
        m_pData->m_IsHeadRequest = 1;

    return ( m_pData->m_IsHeadRequest == 2);
    }

/*===================================================================
IsClientConnected

This function will return the status of the last attempt to write to
the client. If Ok, it check the connection using new CIsapiReqInfo method

Parameters
    none

Returns:
    VARIANT_BOOL reflecting the status of the client connection
===================================================================*/
STDMETHODIMP CResponse::IsClientConnected(VARIANT_BOOL* fIsClientConnected)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_fWriteClientError)
        {
        *fIsClientConnected = VARIANT_FALSE;
        }
    else
        {
        // assume connected
        BOOL fConnected = TRUE;

        // test
        if (m_pData->m_pIReq)
            m_pData->m_pIReq->TestConnection(&fConnected);

        *fIsClientConnected = fConnected ? VARIANT_TRUE : VARIANT_FALSE;
        }

    return(S_OK);
    }

/*===================================================================
CResponse::get_CharSet

Functions called from DispInvoke to return the CarSet property.

Parameters:
    pbstrCharSetRet     BSTR FAR *, return value: pointer to the CharSet as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CharSet
(
BSTR FAR * pbstrCharSetRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCharSet)
        hr = SysAllocStringFromSz(m_pData->m_pszCharSet, 0, pbstrCharSetRet);
    else
        *pbstrCharSetRet    = NULL;

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CharSet

Functions called from DispInvoke to set the CharSet property.

This function takses a string, which identifies the name of the
character set of the current page, and appends the name of the
character set (for example, " ISO-LATIN-7") specified by the
charsetname to the content-type header in the response object

Notes:

* this function inserts any string in the header, whether or not
it represents a valis charcter set.
* if a single page contains multiple tags contianing response.charset,
each response.charset will replace the cahrset by the previous entry.
As a result, the charset will be set to the value specified by the
last instance of response.charset on a page.
* this command must also be invoked before the first response.write
operation unless buffering is turned on.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CharSet
(
BSTR bstrCharSet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCharSet) {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCharSet)));

    else if ((m_pData->m_pszCharSet = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::Pics

Functions called from DispInvoke to Add a pics header.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of pics header

Takes a string, which is the properly formatted PICS label, and adds
the value specified by the picslabel to the pics-label field of the response header.

Note:

* this function inserts any string in the header, whether or not it
represents a valid PICS lavel.

* current implimentation is a wraper on the addheader method.


Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Pics
(
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (FAILED(AppendHeader("pics-label", bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_CacheControl

Functions called from DispInvoke to return the CacheControl property.

Parameters:
    pbstrCacheControl   BSTR FAR *, return value: pointer to the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CacheControl
(
BSTR FAR * pbstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCacheControl)
        hr = SysAllocStringFromSz(m_pData->m_pszCacheControl, 0, pbstrCacheControl);
    else
        hr = SysAllocStringFromSz( "private", 0, pbstrCacheControl);

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CacheControl

Functions called from DispInvoke to set the CacheControl property.

Parameters:
    bstrCacheControl    BSTR, value: the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CacheControl
(
BSTR bstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCacheControl) {
        free(m_pData->m_pszCacheControl);
        m_pData->m_pszCacheControl = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCacheControl)));

    else if ((m_pData->m_pszCacheControl = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_CodePage

Returns the current code page value for the response

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_CodePage
(
long *plVar
)
{
    Assert(m_pData);
        Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetCodePage();

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0) {
		*plVar = (long) GetACP();
    }
		
	return S_OK;
}

/*===================================================================
CResponse::put_CodePage

Sets the current code page value for the response

Parameters:
    long lVar       code page to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_CodePage
(
long lVar
)
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable
    HRESULT hr = m_pData->m_pHitObj->SetCodePage(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE,
            IDE_SESSION_INVALID_CODEPAGE
            );
        return E_FAIL;
    }

	return S_OK;
}

/*===================================================================
CResponse::get_LCID

Returns the current LCID value for the response

Parameters:
    long *plVar     [out] LCID value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_LCID
(
long *plVar
)
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetLCID();

	// If code page is 0, look up default ANSI code page
	if (*plVar == LOCALE_SYSTEM_DEFAULT) {
		*plVar = (long) GetSystemDefaultLCID();
	}
		
	return S_OK;
}

/*===================================================================
CResponse::put_LCID

Sets the current LCID value for the response

Parameters:
    long lVar       LCID to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_LCID
(
long lVar
)
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable
    HRESULT hr = m_pData->m_pHitObj->SetLCID(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE,
            IDE_TEMPLATE_BAD_LCID
            );
        return E_FAIL;
    }

	return S_OK;
}


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CResponse::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    if (pcbWritten != NULL)
        *pcbWritten = cb;
    return WriteSz((CHAR*) pv, cb);
}

STDMETHODIMP CResponse::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\scrptmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.cpp

Owner: AndrewS

This file contains the implementation of the Scrip Manager,
ie: siting an ActiveX Scripting engine (in our case VBScript) for Denali.

===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "SMHash.h"
#include "perfdata.h"
#include "debugger.h"
#include "wraptlib.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

CScriptManager g_ScriptManager;
IWrapTypeLibs *g_pWrapTypelibs = NULL;

#define RESPONSE_END_ERRORCODE ERROR_OPERATION_ABORTED

HRESULT GetProgLangIdOfName(LPCSTR szProgLangName, PROGLANG_ID *pProgLangId);

//*****************************************************************************
// The following macros are used to catch exceptions thrown from the external
// scripting engines.
//
// Use of TRY/CATCH blocks around calls to the script engine is controlled by
// the DBG compile #define.  If DBG is 1, then the TRY/CATCH blocks are NOT
// used so that checked builds break into the debugger and we can examine why
// the error occurred.  If DBG is 0, then the TRY/CATCH blocks are used and
// exceptions are captured and logged to the browser (if possible) and the NT
// Event log.
//
// The TRYCATCH macros are:
//
//  TRYCATCH(_s, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_HR(_s, _hr, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _hr     - HRESULT to store return from _s
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_NOHITOBJ(_s, _IFStr)
//      Same as TRYCATCH() except there is no Hitobj in the "this" object
//  TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr)
//      Same as TRYCATCH_HR() except there is no Hitobj in the "this" object
//
//  NOTES:
//  The macros also expect that there is a local variable defined in the function
//  the macros is used of type char * named _pFuncName.
//  
//  A minimal test capability is included to allow for random errors to be throw.
//  The test code is compiled in based on the TEST_TRYCATCH #define.
//
//*****************************************************************************

//*****************************************************************************
// TEST_TRYCATCH definitions
//*****************************************************************************
#define TEST_TRYCATCH 0

#if TEST_TRYCATCH
#define  THROW_INTERVAL 57

int g_TryCatchCount = 0;

#define TEST_THROW_ERROR  g_TryCatchCount++; if ((g_TryCatchCount % THROW_INTERVAL) == 0) {THROW(0x80070000+g_TryCatchCount);}
#else
#define TEST_THROW_ERROR  
#endif

//*****************************************************************************
// The following is the heart of the TRYCATCH macros.  The definitions here are
// based on the definition of DBG.  Again, note that when DBG is off that the
// TRYCATCH defines are removed.
//*****************************************************************************

#if DBG == 0

#define START_TRYCATCH do { TRY
#define END_TRYCATCH(_hr, _hitobj, _IFStr) \
    CATCH(nException) \
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF, _hitobj,TRUE,nException,_IFStr,_pFuncName); \
        _hr = nException; \
    END_TRY } while(0)
#else
#define START_TRYCATCH do {
#define END_TRYCATCH(_hr, _hitobj, _IFStr) } while (0)
#endif

//*****************************************************************************
// Definition of TRYCATCH_INT which is used by all of the TRYCATCH macros
// described above.
//*****************************************************************************

#define TRYCATCH_INT(_s, _hr, _hitobj, _IFStr) \
    START_TRYCATCH \
    TEST_THROW_ERROR \
    _hr = _s; \
    END_TRYCATCH(_hr, _hitobj, _IFStr)

//*****************************************************************************
// Here are the actual definitions of the TRYCATCH macros described above.
//*****************************************************************************

#define TRYCATCH(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, m_pHitObj, _IFStr); \
    } while (0)
#define TRYCATCH_HR(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, m_pHitObj, _IFStr)
#define TRYCATCH_NOHITOBJ(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, NULL, _IFStr); \
    } while (0)
#define TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, NULL, _IFStr)

/*===================================================================
CActiveScriptEngine::CActiveScriptEngine

Constructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::CActiveScriptEngine()
	: m_cRef(1), m_fInited(FALSE), m_fZombie(FALSE), m_fScriptLoaded(FALSE), 
	  m_fObjectsLoaded(FALSE), m_fTemplateNameAllocated(FALSE),
	  m_pAS(NULL), m_pASP(NULL), m_pDisp(NULL), m_pHIUpdate(NULL), m_lcid(LOCALE_SYSTEM_DEFAULT),
	  m_pHitObj(NULL), m_szTemplateName(NULL), m_fScriptAborted(FALSE), m_fScriptTimedOut(FALSE), 
	  m_fScriptHadError(FALSE), m_fCorrupted(FALSE), m_fBeingDebugged(FALSE), m_pTemplate(NULL),
	  m_dwInstanceID(0xBADF00D), m_dwSourceContext(0xBADF00D)
	{
	}

/*===================================================================
CActiveScriptEngine::~CActiveScriptEngine

Destructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::~CActiveScriptEngine()
	{

	if (m_fTemplateNameAllocated)
    	delete[] m_szTemplateName;

	if (m_pTemplate)
		m_pTemplate->Release();
	}

/*===================================================================
CActiveScriptEngine::FinalRelease

Call this when we are done with the object - Like release but
it removes all of the interfaces we got, so that the ref.
count can vanish when last external user is done with the engine

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
ULONG CActiveScriptEngine::FinalRelease()
	{
    static const char *_pFuncName = "CActiveScriptEngine::FinalRelease()";

	if (m_pDisp)
		{
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
		}

	if (m_pASP)
		{
		TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
		}

	if (m_pHIUpdate)
		{
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
		}

	if (m_pAS)
		{
		HRESULT hr;
		
		// First "close" the engine
		TRYCATCH_HR(m_pAS->Close(), hr, "IActiveScript::Close()");
		Assert(SUCCEEDED(hr));

		// Then we can release it
		TRYCATCH(m_pAS->Release(), "IActiveScript::Release()");

		m_pAS = NULL;
		}

	ULONG cRefs = Release();
	Assert (cRefs == 0);
	return cRefs;
	}

/*===================================================================
CActiveScriptEngine::Init

Init the script site object.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::Init
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::Init()";
	HRESULT hr;
	UINT cTrys = 0;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;
	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = pHitObj->DWInstanceID();
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

lRetry:
	// Create an instance of the script engine for the given language
	hr = CoCreateInstance(proglang_id, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pAS);
	if (FAILED(hr))
		{
		/*
		 * If some control (or other component) does a CoUninitialize on our thread, we will
		 * never be able to create another object.  In this case, we will get back CO_E_NOTINITIALIZED.
		 * Try (once) to re-initialize and then create the object
		 */
		if (hr == CO_E_NOTINITIALIZED && cTrys++ == 0)
			{
			MSG_Error(IDS_COUNINITIALIZE);
			hr = CoInitialize(NULL);
            if (SUCCEEDED(hr))
			    goto lRetry;
			}
		goto LFail;
		}

    // Remember template name
    hr = StoreTemplateName(szTemplateName);
	if (FAILED(hr))
		goto LFail;
    
	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");
	if (FAILED(hr))
		{
		goto LFail;
		}

	// Tell ActiveScripting which exceptions we want caught
	IActiveScriptProperty *pScriptProperty;
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptProperty, reinterpret_cast<void **>(&pScriptProperty)), hr, "IActiveScript::QueryInterface()");
    if (SUCCEEDED(hr))
    	{
    	static const int rgnExceptionsToCatch[] =
							{
							STATUS_GUARD_PAGE_VIOLATION      ,
							STATUS_DATATYPE_MISALIGNMENT     ,
							STATUS_ACCESS_VIOLATION          ,
							STATUS_INVALID_HANDLE            ,
							STATUS_NO_MEMORY                 ,
							STATUS_ILLEGAL_INSTRUCTION       ,
							STATUS_INVALID_DISPOSITION       , // what's this?  Do we need to catch it?
							STATUS_ARRAY_BOUNDS_EXCEEDED     ,
							STATUS_FLOAT_DENORMAL_OPERAND    ,
							STATUS_FLOAT_DIVIDE_BY_ZERO      ,
							STATUS_FLOAT_INVALID_OPERATION   ,
							STATUS_FLOAT_OVERFLOW            ,
							STATUS_FLOAT_STACK_CHECK         ,
							STATUS_INTEGER_DIVIDE_BY_ZERO    ,
							STATUS_INTEGER_OVERFLOW          ,
							STATUS_PRIVILEGED_INSTRUCTION    ,
							STATUS_STACK_OVERFLOW
							};

    	VARIANT varBoolTrue;
    	VARIANT varExceptionType;

    	V_VT(&varExceptionType) = VT_I4;
    	V_VT(&varBoolTrue) = VT_BOOL;
    	V_BOOL(&varBoolTrue) = -1;

		for (int i = 0; i < (sizeof rgnExceptionsToCatch) / sizeof(int); ++i)
			{
			V_I4(&varExceptionType) = rgnExceptionsToCatch[i];
			TRYCATCH(pScriptProperty->SetProperty(SCRIPTPROP_CATCHEXCEPTION, &varExceptionType, &varBoolTrue), "IActiveScriptProperty::SetProperty");
			}

		pScriptProperty->Release();
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Tell the script parser to init itself
    TRYCATCH_HR(m_pASP->InitNew(), hr, "IActiveScriptParse::InitNew()");
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	m_fInited = TRUE;

LFail:
	if (FAILED(hr))
		{
		if (m_pAS)
			{
			TRYCATCH(m_pAS->Release(),"IActiveScript::Release()");
			m_pAS = NULL;
			}
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::StoreTemplateName

Stores template name inside CActiveScriptEngine. Allocates
buffer or uses internal one if the name fits.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Might allocate memory for long template names
===================================================================*/
HRESULT CActiveScriptEngine::StoreTemplateName
(
LPCTSTR szTemplateName
)
    {
    DWORD cch = _tcslen(szTemplateName);

    if (((cch+1)*sizeof(TCHAR)) <= sizeof(m_szTemplateNameBuf))
        {
        m_szTemplateName = m_szTemplateNameBuf;
        m_fTemplateNameAllocated = FALSE;
        }
    else
        {
    	m_szTemplateName = new TCHAR[cch+1];
    	if (!m_szTemplateName)
            return E_OUTOFMEMORY;
        m_fTemplateNameAllocated = TRUE;
        }
        
	_tcscpy(m_szTemplateName, szTemplateName);
    return S_OK;
    }

/*===================================================================
CActiveScriptEngine::GetASP

Get an ActiveScriptParser interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetASP
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetASP()";
	HRESULT hr;

	Assert(m_pASP == NULL);
	
	m_pASP = NULL;
			
	// Get OLE Scripting parser interface, if any
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptParse, (void **)&m_pASP), hr, "IActiveScript::QueryInterface()");

	if (m_pASP == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIDisp

Get an IDispatch interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIDisp
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIDisp()";

	HRESULT hr;

	Assert(m_pDisp == NULL);
	
	m_pDisp = NULL;
			
	// Get an IDispatch interface to be able to call functions in the script
    
    TRYCATCH_HR(m_pAS->GetScriptDispatch(NULL, &m_pDisp),hr,"IActiveScript::GetScriptDispatch()");

	if (m_pDisp == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIHostInfoUpdate

Get an IHostInfoUpdate interface from ActiveScripting.
This interface is used to advise the scripting engine that
we have new information about the host (change in LCID for example)
If we can't find the interface, we exit succesfully anyway.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIHostInfoUpdate
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIHostInfoUpdate()";
	HRESULT hr = S_OK;

	Assert(m_pHIUpdate == NULL);
	m_pHIUpdate = NULL;
			
	// Get an IHostInfoUpdate interface to be able to call functions in the script
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IHostInfoUpdate, (void **) &m_pHIUpdate),
                hr,
                "IActiveScript::QueryInterface()");

	Assert(SUCCEEDED(hr) || hr == E_NOINTERFACE);

	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::ResetToUninitialized

When we want to reuse and engine, we reset it to an uninited state
before putting it on the FSQ

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::ResetToUninitialized()
{
    static const char *_pFuncName = "CActiveScriptEngine::ResetToUninitialized()";
	HRESULT hr = S_OK;
	
	// Reset our flags
	m_fScriptAborted = FALSE;
	m_fScriptTimedOut = FALSE;
	m_fScriptHadError = FALSE;
	m_fBeingDebugged = FALSE;

	// Release interfaces, they will need to be re-gotten when
	// the engine is reused
	if (m_pASP) {
        TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
    }

	if (m_pDisp) {
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
    }

	if(m_pHIUpdate) {
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
    }

	// Hitobj will no longer be valid
	m_pHitObj = NULL;

	// Set the script state to Uninited
	if (m_pAS) {
        TRYCATCH_HR(ResetScript(), hr, "IActiveScript::SetScriptState()");
    }

	return(hr);
}

/*===================================================================
CActiveScriptEngine::ReuseEngine

Reusing an engine from the FSQ.  Reset stuff

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Sets member variables.
===================================================================*/
HRESULT CActiveScriptEngine::ReuseEngine
(
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::ReuseEngine()";
	HRESULT hr = S_OK;

	/* NOTE: we must reset the hitobj & other members BEFORE calling
	 * any Active Scripting methods (esp. SetScriptSite)  This is
	 * because SetScriptSite queries us for the debug application, which
	 * relies on the hitobj being set.
	 */

	// reset the hitobj
	m_pHitObj = pHitObj;

	// Reset the debug document
	if (pTemplate)
		{
		if (m_pTemplate)
			m_pTemplate->Release();

		m_dwSourceContext = dwSourceContext;
		m_dwInstanceID = dwInstanceID;
		m_pTemplate = pTemplate;
		m_pTemplate->AddRef();
		}

	// If the engine is in the UNITIALIZED state ONLY then tell ActiveScripting
	// that this is our script site.  (Scripts in the debug cache are already initialized)
	SCRIPTSTATE nScriptState;
    TRYCATCH_HR(m_pAS->GetScriptState(&nScriptState), hr, "IActiveScript::GetScriptState()");
	if (FAILED(hr))
		goto LFail;

	if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
		{
        TRYCATCH_HR(m_pAS->SetScriptSite(static_cast<IActiveScriptSite *>(this)),hr, "IActiveScript::SetScriptState()");
		if (FAILED(hr))
			goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	AssertValid();
LFail:
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::MakeClone

We are cloning a running script engine.  Fill this new ActiveScriptEngine
with the cloned ActiveScript.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::MakeClone
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID,
IActiveScript *pAS			// The cloned script engine
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::MakeClone()";
	HRESULT hr;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;

	m_pAS = pAS;

	StoreTemplateName(szTemplateName);

	if (m_pTemplate)
		m_pTemplate->Release();

	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = dwInstanceID;
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

	// We are not yet inited fully but SetScriptSite may call back into us so we must flag inited now.
	m_fInited = TRUE;

	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");

	if (FAILED(hr))
		{
		goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	// Because we are a clone of an already loaded engine, we have script and objects loaded.
	m_fScriptLoaded = TRUE;
	m_fObjectsLoaded = TRUE;

	// We should be valid now.
	AssertValid();
	
LFail:
	if (FAILED(hr))
		{
		m_fInited = FALSE;
		
		if (m_pAS)
			{
			// dont release the passed in script engine on failure
			m_pAS = NULL;
			}
		if (m_pASP)
			{
			TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::InterruptScript

Stop the script from running

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Stops the script from running
===================================================================*/
HRESULT CActiveScriptEngine::InterruptScript
(
BOOL fAbnormal				// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::InterruptScript()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Fill in the excepinfo.  This will be passed to OnScriptError
	memset(&excepinfo, 0x0, sizeof(EXCEPINFO));
	if (fAbnormal)
		{
		m_fScriptTimedOut = TRUE;
		excepinfo.wCode = ERROR_SERVICE_REQUEST_TIMEOUT;
        m_pHitObj->SetRequestTimedout();
		}
	else
		{
		m_fScriptAborted = TRUE;
		excepinfo.wCode = RESPONSE_END_ERRORCODE;		// Error code to ourselves - means Response.End was invoked
		}
	
        TRYCATCH_HR(m_pAS->InterruptScriptThread(SCRIPTTHREADID_BASE,		// The thread in which the engine was instantiated
		           						  &excepinfo,
								          0),
                    hr,
                    "IActiveScript::InterruptScriptThread()");
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::UpdateLocaleInfo

Advise the script engine that we want to update the lcid or
code page

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::UpdateLocaleInfo
(
hostinfo hiNew
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::UpdateLocaleInfo()";
	HRESULT hr = S_OK;
	
	// If no IUpdateHost ineterface is available 
	// just skip the call to UpdateInfo;
	if (m_pHIUpdate)
		TRYCATCH_HR(m_pHIUpdate->UpdateInfo(hiNew), hr, "IHostInfoUpdate::UpdateInfo()");

	return hr;
	}

#ifdef DBG
/*===================================================================
CActiveScriptEngine::AssertValid

Test to make sure that the CActiveScriptEngine object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CActiveScriptEngine::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pAS != NULL);
	Assert(m_pTemplate != NULL);
	}
#endif // DBG

/*
 *
 *
 *
 * I U n k n o w n   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::QueryInterface
CActiveScriptEngine::AddRef
CActiveScriptEngine::Release

IUnknown members for CActiveScriptEngine object.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::QueryInterface
(
REFIID riid,
PVOID *ppvObj
)
	{
	if (ppvObj == NULL)
		{
		Assert(FALSE);
		return E_POINTER;
		} 

	*ppvObj = NULL;

	if (IsEqualIID(riid, IID_IUnknown))
	    {
	    // this IS NOT derived directly from IUnknown
	    // typecast this to something that IS
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSite))
	    {
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSiteDebug))
	    {
		*ppvObj = static_cast<IActiveScriptSiteDebug *>(this);
        }
	else if (IsEqualIID(riid, IID_IHostInfoProvider))
	    {
		*ppvObj = static_cast<IHostInfoProvider *>(this);
        }
        
	if (*ppvObj != NULL)
		{
		AddRef();
		return(S_OK);
		}
	
	return(E_NOINTERFACE);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::AddRef()
	{
	++m_cRef;

	return(m_cRef);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::Release()
	{
	if (--m_cRef)
		return(m_cRef);

	delete this;
	return(0);
	}

/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::GetLCID

Provide the local id for the script to the script engine.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetLCID
(
LCID *plcid
)
	{
	// It is OK to call this before we are fully inited.
	//AssertValid();

	*plcid = ((CActiveScriptEngine *)this)->m_lcid;
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetItemInfo

Provide requested info for a named item to the script engine.  May be
asked for IUnknown, ITypeInfo or both.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetItemInfo
(
LPCOLESTR pcszName,
DWORD dwReturnMask,IUnknown **ppiunkItem,
ITypeInfo **ppti
)
	{
	HRESULT hr;
	AssertValid();
	
	// Assume none
	if (ppti)
		*ppti = NULL;
	if (ppiunkItem)
		*ppiunkItem = NULL;

    CHitObj *pHitObj = m_pHitObj;
    if (pHitObj == NULL)
        {
        // could happen when debugging and re-initializing
        // the scripting engine when storing it in the template
        // in this case GetItemInfo() is called for TYPELIB stuff
        ViperGetHitObjFromContext(&pHitObj);
    	if (pHitObj == NULL)
	        return TYPE_E_ELEMENTNOTFOUND;
        }

    // Calculate name length once
    
    DWORD cbName = CbWStr((LPWSTR)pcszName);
    
	// Special case for intrinsics
	
	IUnknown *punkIntrinsic = NULL;
	hr = pHitObj->GetIntrinsic((LPWSTR)pcszName, cbName, &punkIntrinsic);
	
	if (hr == S_OK)
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem);
    		Assert(punkIntrinsic);
    		punkIntrinsic->AddRef();
    		*ppiunkItem = punkIntrinsic;
		    }
		return S_OK;
	    }
	else if (hr == S_FALSE)
	    {
	    // Missing intrinsic case
	    return TYPE_E_ELEMENTNOTFOUND;
	    }

	// It's not an intrinsic -- try component collection
	
	CComponentObject *pObj = NULL;
	hr = pHitObj->GetComponent(csUnknown, (LPWSTR)pcszName, cbName, &pObj);

	if (hr == S_OK) // object found
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem != NULL);
	    	hr = pObj->GetAddRefdIUnknown(ppiunkItem);
		    }

		if (SUCCEEDED(hr))
		    return S_OK;
	    }

	// Could'n find -- output an error

	HandleItemNotFound(pcszName);
    	
	return hr;
	}

/*===================================================================
CActiveScriptEngine::HandleItemNotFound

Error handling due to item not found in GetItemInfo().

Parameters:
    pcszName        name of the item not found

Returns:
===================================================================*/
void CActiveScriptEngine::HandleItemNotFound
(
LPCOLESTR pcszName
)
    {
    HRESULT         hr = TYPE_E_ELEMENTNOTFOUND;
    
	CHAR 	        *szErrT		= NULL;
	CHAR	        szEngineT[255];
	CHAR	        szErr[255];
	TCHAR	        *szFileNameT = NULL;
    CHAR            *szFileName = NULL;
	CHAR 	        *szLineNum  = NULL;
	CHAR	        *szEngine	= NULL;
	CHAR	        *szErrCode	= NULL;
	CHAR	        *szLongDes	= NULL;
	ULONG 	        ulLineError = 0;
	DWORD	        dwMask = 0x3;
	BOOLB	        fGuessedLine = FALSE;
	UINT	        ErrId = IDE_OOM;
    CWCharToMBCS    convName;

	m_pTemplate->GetScriptSourceInfo(m_dwSourceContext, ulLineError, &szFileNameT, NULL, &ulLineError, NULL, &fGuessedLine);
	//Make a copy for error handling
#if UNICODE
	szFileName = StringDupUTF8(szFileNameT);
#else
    szFileName = StringDupA(szFileNameT);
#endif

    if (!szFileName)
    {
        hr = E_OUTOFMEMORY;
        goto lCleanUp;
    }        

	//get line num
	if (ulLineError)
		{
		szLineNum = (CHAR *)malloc(sizeof(CHAR)*10);
		if (szLineNum)
			_ltoa(ulLineError, szLineNum, 10);
		else
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}
		}
	//get engine
	CchLoadStringOfId(IDS_ENGINE, szEngineT, 255);
	szEngine = StringDupA(szEngineT);
	if (!szEngine)
	{
	    hr = E_OUTOFMEMORY;
	    goto lCleanUp;
	}

	//get informative string

    if (FAILED(hr = convName.Init((LPWSTR)pcszName))) {
        goto lCleanUp;
    }
		
	// Error string is: "Failed to create object 'objname'.  Error code (code)."
	ErrId = IDE_SCRIPT_CANT_LOAD_OBJ;
	LoadErrResString(ErrId, &dwMask, NULL, NULL, szErr);
	if (szErr)
		{
		INT	cch = strlen(szErr);
		szErrT = (CHAR *)malloc((CHAR)(cch + strlen(convName.GetString()) + 1));
		if (!szErrT)
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}

		sprintf(szErrT, szErr, convName.GetString());
		szErrCode = SzScodeToErrorCode(hr);
		}
		
lCleanUp:		
	
	//szErrT is the long description		
	HandleError(ErrId, szFileName, szLineNum, szEngine, szErrCode, szErrT, NULL, m_pHitObj);
    }

/*===================================================================
CActiveScriptEngine::GetDocVersionString

Return a string uniquely identifying the current document version
from Denali's point of view.

I dont think we need this. It is mostly interesting if
the scripting engine is persisting scripts so that it can decide
if a script needs a recompile.  Since the scripting engine is
not persisting anything for us, we dont need to do anything here.

Returns:
	HRESULT.  Always returns E_NOTIMPL.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetDocVersionString
(
BSTR *pbstrVersion
)
	{
	return(E_NOTIMPL);
	}

/*===================================================================
CActiveScriptEngine::RequestItems

If this is called, it means that the Script engine wants us to call
IActiveScript::AddNameItem() for each named item associated with the 
script.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestItems
(
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::RequestItems()";
	HRESULT hr = S_OK;

	AssertValid();
	Assert (m_pHitObj != NULL);

	DWORD grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;

	/*
	 * Intrinsics
	 */

    START_TRYCATCH

	if (m_pHitObj->FIsBrowserRequest())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_RESPONSE, grf);
        Assert(SUCCEEDED(hr));

        hr = m_pAS->AddNamedItem(WSZ_OBJ_REQUEST, grf);
        Assert(SUCCEEDED(hr));
        }
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_SERVER, grf);
	Assert(SUCCEEDED(hr));

	if (m_pHitObj->FHasSession())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_SESSION, grf);
	    Assert(SUCCEEDED(hr));
	    }

    hr = m_pAS->AddNamedItem(WSZ_OBJ_APPLICATION, grf);
	Assert(SUCCEEDED(hr));
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_OBJECTCONTEXT, grf);
	Assert(SUCCEEDED(hr));

	/*
	 * Components from different collections
	 */

	CComponentIterator CompIter(m_pHitObj);
    LPWSTR strObjName;
        
    while (strObjName = CompIter.WStrNextComponentName())
        {
   		hr = m_pAS->AddNamedItem(strObjName, grf);
        if (FAILED(hr))
   			break;
        }
	
	Assert(SUCCEEDED(hr));

	/*
	 * Type library wrappers. (Has to be last in order to be called
	 * only when everything else fails.
	 */

	// Special flag value for typelib wrappers
	grf |= SCRIPTITEM_GLOBALMEMBERS;

	if (m_pHitObj->PTypeLibWrapper())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPPAGETLB, grf);
    	Assert(SUCCEEDED(hr));
	    }

    // GLOBAL.ASA typelib wrapper is added always
    // because each page does not pick up changes to
    // GLOBAL.ASA and there's no way to figure out
    // when TYPELIBs get added to GLOBAL.ASA
    hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPGLOBALTLB, grf);
  	Assert(SUCCEEDED(hr));

    END_TRYCATCH(hr, m_pHitObj, "IActiveScript::AddNamedItem");

	// We are required to return OK
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::RequestTypeLibs 

If this is called, it means that the Script engine wants us to call
IActiveScript::AddTypeLib() for each typelib associated with the 
script.  It is unclear to me that this will ever be called in our case.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestTypeLibs()
	{
	AssertValid();

	// We have no typelibs for the namespace	
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnEnterScript

Host callback to indicate that the script has started executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnEnterScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnLeaveScript

Host callback to indicate that the script has stopped executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnLeaveScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetHostInfo

Host callback to for furnishing LCID and code page info

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetHostInfo(hostinfo hostinfoRequest, void **ppvInfo)
	{

	Assert(hostinfoRequest == hostinfoLocale || hostinfoRequest == hostinfoCodePage);

	HRESULT hr = S_OK;
	
	if (hostinfoRequest == hostinfoLocale)
		{
		// Allocate an LCID and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetLCID();
		}
	else if (hostinfoRequest == hostinfoCodePage)
		{
		// Allocate an code page and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetCodePage();
		}
	else
		hr = E_FAIL;
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::OnScriptTerminate

Host callback to indicate that the script has completed.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptTerminate
(
const VARIANT *pvarResult,
const EXCEPINFO *pexcepinfo
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnStateChange

Host callback to indicate that the script has changed state (e.g. from
Uninitialized to Loaded.)

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnStateChange
(
SCRIPTSTATE ssScriptState
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnScriptError

Host callback to indicate that an error has occured in the script.
We should handle the error.  We will return E_FAIL to indicate that we 
want the script to terminate.

Returns:
	HRESULT.  E_FAIL -- Terminate executing the script.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptError
(
IActiveScriptError __RPC_FAR *pscripterror
)
	{
	Assert(pscripterror);
	AssertValid();

	// Bug 153: If we terminate the script due to Response.End, dont show an error
	// NOTE: ActiveXScripting was failing to pass us our excepinfo.  Use member flags
	// ALSO: ActiveXScripting has fixed the problem of failing to pass us our excepinfo, but the
	// way we are doing this with flags works just fine.  
	if (m_fScriptAborted)
		{
		goto LRet;
		}
	
	if (m_fScriptTimedOut)
		{
            //Load Default Engine from resource
        char  szEngine[128];
        DWORD cch;
        cch = CchLoadStringOfId(IDS_ENGINE, szEngine, 128);
        szEngine[cch] = '\0';
        CHAR    *szFileName;
#if UNICODE
        szFileName = StringDupUTF8(m_pHitObj->PSzCurrTemplateVirtPath());
#else
        szFileName = StringDupA(m_pHitObj->PSzCurrTemplateVirtPath());
#endif

	    HandleError(IDE_SCRIPT_TIMEOUT, 
                    szFileName, 
                    NULL, 
                    StringDupA(szEngine), 
                    NULL, 
                    NULL, 
                    NULL, 
                    m_pHitObj,
                    NULL);

		if(m_pHitObj)
			{
			m_pHitObj->SetExecStatus(eExecTimedOut);
			}
		goto LRet;
		}

	// OnScriptErrorDebug calls OnScriptError.  use this test to be sure we don't log error
	// twice if we are called twice.  (won't happen with present debugging implementation,
	// but externals may change.)
	if (m_fScriptHadError)
		{
		goto LRet;
		}

	m_fScriptHadError = TRUE;				// Note that the script had an error so we can abort transactions (if any)
		
	if (pscripterror)
		{
		// If there was an error in the script, first see if we should pop up the debugger
		// (ONLY bring up Script Debugger; VID will do the right thing on its own)
		//
		// NEW CHANGE: always bring error description to browser, since VID does not
		// give sufficient description.
		//
		
		// With the current TRY_CATCH blocks in place..we should never hit this assert.
		Assert (m_pHitObj);
		
		if (FCaesars() && m_pHitObj && m_pHitObj->PAppln()->FDebuggable())
			DebugError(pscripterror, m_pTemplate, m_dwSourceContext, g_pDebugApp);

		HandleError(pscripterror, m_pTemplate, m_dwSourceContext, NULL, m_pHitObj);
		}

LRet:
	// Bug 99718 return S_OK to tell the script engine that we handled the error ok.
	// Returning E_FAIL would not stop the scripting engine, this was a doc error.
	return(S_OK);
	}


/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::OnScriptErrorDebug

Callback for debugger to query host on what to do on exception.

NOTE: Theoretically, we would set *pfCallOnScriptErrorWhenContinuing
      to TRUE and not call OnScriptError, and set *pfEnterDebugger
      to TRUE or FALSE based on whether debugging is enabled and
      whether user wants to debug.

      However, in practice, *pfCallOnScriptErrorWhenContinuing is
      not honored (OnScriptError is NOT called in any case), and
      the VID team wants us to pretend like we don't implement
      this interface.  However, we always need our "OnScriptError"
      code to execute, so we call our OnScriptError function
      explicitly, then fail

Returns:
	HRESULT.  always returns E_NOTIMPL

Side effects:
	calls OnScriptError
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptErrorDebug
(
IActiveScriptErrorDebug *pscripterror,
BOOL *pfEnterDebugger,
BOOL *pfCallOnScriptErrorWhenContinuing
)
	{
	OnScriptError(pscripterror);
	return E_NOTIMPL;
	} 

/*===================================================================
CActiveScriptEngine::GetDocumentContextFromPosition

Create a document context (file + offset + length) from an offset in the
script.

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::GetDocumentContextFromPosition
(
/* [in] */ DWORD_PTR dwSourceContext,
/* [in] */ ULONG cchTargetOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext)
{
    static const char *_pFuncName = "CActiveScriptEngine::GetDocumentContextFromPosition()";
	TCHAR *szSourceFile;
	ULONG cchSourceOffset;
	ULONG cchSourceText;
	IActiveScriptDebug *pASD;

	// Convert offset in script engine to source location, and get debugging interfaces
	m_pTemplate->GetSourceOffset(m_dwSourceContext, cchTargetOffset, &szSourceFile, &cchSourceOffset, &cchSourceText);
    
    HRESULT  hr;

    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pASD)), 
                                      hr,
                                      "IActiveScript::QueryInterface()");

    if (FAILED(hr))
        return(E_FAIL);

	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szSourceFile, m_pTemplate->GetSourceFileName()) == 0)
		{
		if (
			(*ppDocumentContext = new CTemplateDocumentContext(m_pTemplate, cchSourceOffset, cchSourceText, pASD, m_dwSourceContext, cchTargetOffset))
			 == NULL
		   )
			{
			pASD->Release();
			return E_OUTOFMEMORY;
			}
		}

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szSourceFile, &pIncFile)))
			return E_FAIL;

		if (
			(*ppDocumentContext = new CIncFileDocumentContext(pIncFile, cchSourceOffset, cchSourceText))
			 == NULL
		   )
			{
			TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
			pIncFile->Release();
			return E_OUTOFMEMORY;
			}

		pIncFile->Release();
		}

	TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
	m_fBeingDebugged = TRUE;
	return S_OK;
	}

/*===================================================================
CActiveScriptEngine::GetApplication

Return a pointer to the application that the script resides in.

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetApplication
(
/* [out] */ IDebugApplication **ppDebugApp
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugApp);

		*ppDebugApp = g_pDebugApp;
		(*ppDebugApp)->AddRef();

		return S_OK;
		}
	else
		{
		*ppDebugApp = NULL;
		return E_FAIL;
		}
	}

/*===================================================================
CActiveScriptEngine::GetRootApplicationNode

Return a pointer to the top level node (for browsing)

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetRootApplicationNode
(
/* [out] */ IDebugApplicationNode **ppRootNode
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugAppRoot);

		*ppRootNode = g_pDebugAppRoot;
		(*ppRootNode)->AddRef();
		return S_OK;
		}
	else
		{
		*ppRootNode = NULL;
		return E_FAIL;
		}
	}

/*
 *
 *
 *
 * C S c r i p t E n g i n e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::AddScriptlet

Add a piece of code to the script engine.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Adds script code to the engine. Potentially allocates memory.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptlet
(
LPCOLESTR wstrScript // scriptlet text
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptlet()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Tell ActiveScripting to add the script to the engine

    TRYCATCH_HR(m_pASP->ParseScriptText(
						wstrScript,			// the scriptlet text
						NULL,				// pstrItemName
						NULL,				// punkContext
						//L"</SCRIPT>",		// End Delimiter -- Engine will never see this, but does tell it to strip comments.
						L"STRIP EMBEDDED HTML COMMENTS",    // Tells the ScriptEngine to strip comments INPLACE
						m_dwSourceContext,	// dwSourceContextCookie
						1,					// ulStartingLineNumber
						SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_HOSTMANAGESSOURCE,
						NULL,				// pvarResult
						&excepinfo),		// exception info filled in on error
                hr,
                "IActiveScriptParse::ParseScriptText()");

	if (SUCCEEDED(hr))
		m_fScriptLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddObjects

Add named objects to the script name space

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddObjects
(
BOOL fPersistNames			// = TRUE
)
	{
	HRESULT hr = S_OK;
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// Leverage RequestItems to give AS all the names
	hr = RequestItems(fPersistNames);

	if (SUCCEEDED(hr))
		m_fObjectsLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddAdditionalObject

Add additional named objects to the script name space beyond the
names already added with AddObject.  Note: the caller MUST have
added then names to the HitObj before making this call

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddAdditionalObject
(
LPWSTR strObjName,
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddAdditionalObject()";
	HRESULT hr = S_OK;
	DWORD grf;
	
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// CONSIDER: It would be nice in debug code to walk the hitobj objlist and make sure
	//			that the given name is in there

	/*
	 * Give AS the names
	 */
	grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;
		
    TRYCATCH_HR(m_pAS->AddNamedItem(strObjName, grf), hr, "IActiveScript::AddNamedItem()");

    Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddScriptingNamespace

Add the given scripting namespace object to the engine.

Note that it is added as GLOBALMEMBERS, and Not as ISPERSISTENT

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptingNamespace
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptingNamespace()";
	HRESULT hr = S_OK;
	
	AssertValid();
	Assert(m_pHitObj != NULL);
	
	/*
	 * Give AXS the name and mark it GLOBALMEMBERS so all members are top level names
	 * in the namespace
	 */
    TRYCATCH_HR(m_pAS->AddNamedItem(WSZ_OBJ_SCRIPTINGNAMESPACE, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS), 
                hr,
                "IActiveScript::AddNamedItem()");
	Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::CheckEntryPoint

Determines if the specific named entry point exists in the given script.

Returns:
	S_OK if found
	DISP_E_UNKNOWNNAME if not found
	Other OLE errors may be returned

Side effects:
	None
===================================================================*/
HRESULT CActiveScriptEngine::CheckEntryPoint
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to look for
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::CheckEntryPoint()";
	HRESULT hr;
	DISPID dispid;

	AssertValid();

	if (strEntryPoint == NULL)
		{
		Assert(FALSE);
		hr = DISP_E_UNKNOWNNAME;
		}
	else
		{
		// Get the DISPID of the method to call

        TRYCATCH_HR(m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
	    							 (LPOLESTR *)&strEntryPoint, // Array of names to look up
		    						 1,					// Number of names in array
			    					 m_lcid,			// Locale id
				    				 &dispid),			// returned dispid
                    hr,
                    "IScriptDispatch::GetIDsOfNames()");
								 
		// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
		Assert(hr == S_OK || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
		}
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::Call

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Calls TryCall (optionally from under TRY CATCH) to do the job

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::Call
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
{
	HRESULT hr;
	
	AssertValid();

	if (Glob(fExceptionCatchEnable)) {
    	// Catch any GPFs in VBS, OleAut, or external components

        TRY

            hr = TryCall(strEntryPoint);
        
    	CATCH(nExcept)
    		/*
    		 * Catching a GPF or stack overflow
    		 * Report it to the user, Assert (if debug), and exit with E_UNEXPECTED.
    		 */
    		if (STATUS_STACK_OVERFLOW == nExcept) {
    			HandleErrorMissingFilename(IDE_STACK_OVERFLOW, m_pHitObj);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' overflowed the stack", m_szTemplateName));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' overflowed the stack", m_szTemplateName));
#endif
            }
    		else {	
    			HandleErrorMissingFilename(IDE_SCRIPT_GPF, m_pHitObj, TRUE, nExcept);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' threw an exception (%x).", m_szTemplateName, nExcept));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' threw an exception (%x).", m_szTemplateName, nExcept));
#endif
            }

    		// Dont reuse the engine
    		m_fCorrupted = TRUE;
    		
    		hr = E_UNEXPECTED;
    	END_TRY
    }
    else {
        // Don't catch exceptions
        hr = TryCall(strEntryPoint);
    }

	return(hr);
}

/*===================================================================
CActiveScriptEngine::TryCall

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Called from Call (optionally from under TRY CATCH)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::TryCall
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
	{
	HRESULT hr;
	DISPID dispid;
	DISPPARAMS dispparams;
	UINT nArgErr;

	/*
	 * Before calling any code we will transition the script to "STARTED" state.
	 * This is part of the ActiveXScripting Reset work.
	 */
    hr = m_pAS->SetScriptState(SCRIPTSTATE_STARTED);

	if (FAILED(hr))
		{
		Assert(FALSE);
		goto LRet;
		}
		
	if (strEntryPoint != NULL)
		{
		// Get the DISPID of the method to call
		hr = m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
								 (LPOLESTR *)&strEntryPoint, // Array of names to look up
								 1,					// Number of names in array
								 m_lcid,			// Locale id
								 &dispid);			// returned dispid
		if (FAILED(hr))
			{
			// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
			Assert(hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
			goto LRet;
			}

		// There are no arguments
		memset(&dispparams, 0, sizeof(dispparams));

		// Invoke it
		hr = m_pDisp->Invoke(dispid,			// dispid to invoke
						IID_NULL,				// REFIID - Reserved, must be NULL
						 m_lcid,				// Locale id
						 DISPATCH_METHOD,		// Calling a method, not a property get/put
						 &dispparams,			// pass arguments
						 NULL,					// return value
						 NULL,					// We aren't interested in the exception info
						 &nArgErr);				// if there is a Type Mismatch, which argument was the problem
		}
	
LRet:
	return(hr);
	}


/*
 *
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 *
 *
 */ 

/*===================================================================
CScriptManager::CScriptManager

Constructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::CScriptManager()
	: m_fInited(FALSE), m_idScriptKiller(0)
	{
	}

/*===================================================================
CScriptManager::~CScriptManager

Destructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::~CScriptManager()
	{
	}

/*===================================================================
CScriptManager::Init

Init the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::Init
(
)
	{
    static const char *_pFuncName = "CScriptManager::Init()";
	HRESULT hr;
	BOOL fPLLInited = FALSE;
	BOOL fcsPLLInited = FALSE;
	BOOL fFSQInited = FALSE;
	BOOL fcsFSQInited = FALSE;
	BOOL fRSLInited = FALSE;
	BOOL fcsRSLInited = FALSE;
	DWORD cBuckets;
	DWORD rgPrime[] = { 3, 11, 23, 57, 89 };
	WORD iP;
    IActiveScript *pAST = NULL;
	static const GUID uid_VBScript	= { 0xB54F3741, 0x5B07, 0x11cf, { 0xA4, 0xB0, 0x00, 0xAA, 0x00, 0x4A, 0x55, 0xE8}};
	
	// Illegal to re-init
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Create the critical sections for serializing access to lists
	ErrInitCriticalSection(&m_cSPLL, hr);
	if (FAILED(hr))
		goto LError;
	fcsPLLInited = TRUE;
	ErrInitCriticalSection(&m_csFSQ, hr);
	if (FAILED(hr))
		goto LError;
	fcsFSQInited = TRUE;
	ErrInitCriticalSection(&m_csRSL, hr);
	if (FAILED(hr))
		goto LError;
	fcsRSLInited = TRUE;

	// List of programming language clsid's
	hr = m_hTPLL.Init();
	if (FAILED(hr))
		goto LError;
	fPLLInited = TRUE;

	// Free Script Queue
	// Init it with a prime # of buckets in relation to script engine cache max
	cBuckets = (Glob(dwScriptEngineCacheMax) / 2) + 1;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
			
	hr = m_htFSQ.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fFSQInited = TRUE;

	// Running Script List
	// Init it with a prime # of buckets in relation to max # of threads
	cBuckets = Glob(dwThreadMax) / 2;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
		
	hr = m_htRSL.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fRSLInited = TRUE;

	// Schedule script killer
    m_msecScriptKillerTimeout = Glob(dwScriptTimeout) * 500;
	m_idScriptKiller = ScheduleWorkItem
	    (
	    CScriptManager::ScriptKillerSchedulerCallback,  // callback
	    this,                                           // context
        m_msecScriptKillerTimeout,                      // timeout
        TRUE                                            // periodic
        );
    if (!m_idScriptKiller)
        {
        hr = E_FAIL;
        goto LError;
        }

    // TypeLib support: Create a scripting engine and QI it for the TypeLib wrapper support
    hr = CoCreateInstance(uid_VBScript, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&pAST);
    if (FAILED(hr))
        goto LError;
    TRYCATCH_HR_NOHITOBJ(pAST->QueryInterface(IID_IWrapTypeLibs, (VOID **)&g_pWrapTypelibs),
                         hr,
                         "IActiveScript::QueryInterface()");
    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");        // No longer need the pointer to the engine
    if (FAILED(hr))
        goto LError;
    
	// All OK.  We are inited.
	m_fInited = TRUE;

	goto LExit;
	
LError:
    if (m_idScriptKiller)
        RemoveWorkItem(m_idScriptKiller);
	if (fcsPLLInited)
		DeleteCriticalSection(&m_cSPLL);
	if (fcsFSQInited)
		DeleteCriticalSection(&m_csFSQ);
	if (fcsRSLInited)
		DeleteCriticalSection(&m_csRSL);
	if (fPLLInited)
		m_hTPLL.UnInit();
	if (fFSQInited)
		m_htFSQ.UnInit();
	if (fRSLInited)
		m_htRSL.UnInit();
	if (pAST)
	    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");
	if (g_pWrapTypelibs)
	    {
	    TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
	    g_pWrapTypelibs = NULL;
	    }

LExit:	
	return(hr);
	}

/*===================================================================
CScriptManager::UnInit

UnInit the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::UnInit
(
)
	{
    static const char *_pFuncName = "CScriptManager::UnInit()";
	HRESULT hr = S_OK, hrT;
	
	if (m_fInited)
		{
		// Un-schedule script killer
        if (m_idScriptKiller)
            {
            RemoveWorkItem(m_idScriptKiller);
            m_idScriptKiller = 0;
            }
        
		// Uninit each of the lists.  Attempt to uninit them all, even if we get an error.
		// Dont lose any errors along the way.
		hr = UnInitASEElems();
		hrT = UnInitPLL();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_hTPLL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htFSQ.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htRSL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	

        if (g_pWrapTypelibs)
            {
            TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
            g_pWrapTypelibs = NULL;
            }
            
		// Free the critical sections (bug 1140: do this after freeing everything else)
		DeleteCriticalSection(&m_cSPLL);
		DeleteCriticalSection(&m_csFSQ);
		DeleteCriticalSection(&m_csRSL);

		m_fInited = FALSE;
		}

	return(hr);
	}


/*===================================================================
CScriptManager::AdjustScriptKillerTimeout

Adjust (shorten) script killer timeout when needed.
The caller should take care of the critical sectioning.

Parameters:
    msecNewTimeout    new suggested timeout value (in ms)

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CScriptManager::AdjustScriptKillerTimeout
(
DWORD msecNewTimeout
)
    {
    const DWORD MSEC_MIN_SCRIPT_TIMEOUT = 5000;   // 5 seconds

    if (!m_idScriptKiller)
        return E_FAIL;  // no script killer scheduled

    // don't set to < minimum
    if (msecNewTimeout < MSEC_MIN_SCRIPT_TIMEOUT)
        msecNewTimeout = MSEC_MIN_SCRIPT_TIMEOUT;
        
    if (m_msecScriptKillerTimeout <= msecNewTimeout)
        return S_OK; // the timeout already short enough

    if (ScheduleAdjustTime(
            m_idScriptKiller, 
            msecNewTimeout) == S_OK)
        {
        m_msecScriptKillerTimeout = msecNewTimeout;
        return S_OK;
        }
    else
        {
        return E_FAIL;
        }
    }

/*===================================================================
CScriptManager::GetEngine

Return an engine to the caller.  Ideally, we will find an engine
that already has the given script in it in our Free Script Queue
and will just hand it out.  If there isnt one, then we will look
in the Running Script List and attempt to clone a running script.
Failing that, we will create a new script
engine.  We return an ENGINESTATE state indicating if the engine
is filled with script or not.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::GetEngine
(
LCID lcid,					// The system language to use
PROGLANG_ID& progLangId,	// prog lang id of the script
LPCTSTR szTemplateName,		// Template we want an engine for
CHitObj *pHitObj,			// Hit obj to use in this engine
CScriptEngine **ppSE,		// Returned script engine
ENGINESTATE *pdwState,		// Current state of the engine
CTemplate *pTemplate,		// template which engine is based from
DWORD dwSourceContext		// source context cookie (engine ID)
)
	{
	HRESULT hr = S_OK;
	CActiveScriptEngine *pASE = NULL;
	CASEElem *pASEElem = NULL;
	DWORD dwInstanceID = pHitObj->DWInstanceID();
	
	AssertValid();

	/*	NOTE progLangId must be valid because CTemplate::Compile() 
		fails way upstream of this point if it cannot generate a valid progLangId.
		Unfortunately there is no easy way to assert progLangId is valid ...
	*/

	/*
	 * First try to find the engine in the FSQ
	 *
	 * Note: We are going to enter our CS now, and keep it until we have
	 * secured the engine for ourselves.  Otherwise, it might be possible
	 * for us to get an engine, and then have another thread get the
	 * same engine before we manage to get it off of the FSQ.
	 * This makes the code a little hard to read, but is nessecary.
	 */
	EnterCriticalSection(&m_csFSQ);
#ifndef PERF_DISABLE
    g_PerfData.Incr_ENGINECACHETRYS();
#endif

#ifndef REUSE_ENGINE
    // This will only find fully loaded engines
	hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/TRUE, &pASEElem);
	
#endif
	if (FAILED(hr))
		{
    	LeaveCriticalSection(&m_csFSQ);
		goto LFail;
		}

	if (pASEElem == NULL || pASEElem->PASE() == NULL)
		{
    	LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		// We got an engine we want to use, remove it from FSQ
		(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
        g_PerfData.Decr_SCRIPTFREEENG();
#endif
    	LeaveCriticalSection(&m_csFSQ);

		pASE = pASEElem->PASE();
		Assert(!pASE->FIsZombie());
		Assert(pASE->FFullyLoaded());
		hr = pASE->ReuseEngine(pHitObj, pTemplate, dwSourceContext, dwInstanceID);
		if (FAILED(hr))
			goto LFail;
		
		// Got an engine for sure...so just incr the cache hit count
#ifndef PERF_DISABLE
		g_PerfData.Incr_ENGINECACHEHITS();
#endif
		
		}
		
	/*
	 * If not found, try to find the engine in the RSL and clone it
	 */
	if (pASE == NULL)
		{
		CASEElem *pASEElemRunning = NULL;
		CActiveScriptEngine *pASERunning = NULL;

		// If we do find an engine to clone, dont let anyone at it until we've cloned it
    	EnterCriticalSection(&m_csRSL);

#ifndef CLONE
		hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/FALSE, &pASEElemRunning);
#else	// CLONE
		// Clone turned off - pretend one wasnt found
		pASEElemRunning = NULL;
#endif
		/*
		 * If we didnt find an element, or it was null, or (bug 1225) it was corrupted
		 * by a GPF running a script, or it was a zombie, then leave the CS and continue.
		 */
		if (FAILED(hr) || pASEElemRunning == NULL || pASEElemRunning->PASE() == NULL ||
			pASEElemRunning->PASE()->FIsCorrupted() || pASEElemRunning->PASE()->FIsZombie())
			{
			LeaveCriticalSection(&m_csRSL);
			if (FAILED(hr))
				goto LFail;
			}
		else
	        {
			pASERunning = pASEElemRunning->PASE();
			Assert(pASERunning != NULL);
			}

		if (pASERunning != NULL)
			{
			IActiveScript *pAS, *pASClone;

    		Assert(!pASERunning->FIsZombie());
	    	Assert(pASERunning->FFullyLoaded());

			// Found a running engine, clone it
			pAS = pASERunning->GetActiveScript();
			Assert(pAS != NULL);
			hr = pAS->Clone(&pASClone);

			// We've cloned the engine, we can let go of the CS
			LeaveCriticalSection(&m_csRSL);

			// Scripting engines are not required to implement clone.  If we get an error,
			// just continue on and create a new engine
			if (FAILED(hr))
				{
				Assert(hr == E_NOTIMPL);		// I only expect E_NOTIMPL
				Assert(pASE == NULL);			// the ASE should not be filled in
				pASE = NULL;
				hr = S_OK;
				}
			else
				{
				// Got back a cloned IActiveScript.  Create a new ASE and fill it in
				pASE = new CActiveScriptEngine;
				if (!pASE)
					{
					hr = E_OUTOFMEMORY;
					pASClone->Release();
					goto LFail;
					}
				hr = pASE->MakeClone(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext, dwInstanceID, pASClone);
				if (FAILED(hr))
					{
					// if we failed, we must release the clone AS
					pASClone->Release();
					goto LFail;
					}
				}
			}
		}

	/*
	 * Have an engine that we can reuse
	 */
	if (pASE != NULL)
		{
		// Reusing an engine.  Let the caller know that it is already initialized
		*pdwState = SCRIPTSTATE_INITIALIZED;

		goto LHaveEngine;
		}

	/*
	 * No suitable engine to reuse.  Return a new one
	 */
	pASE = new CActiveScriptEngine;
	if (!pASE)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	hr = pASE->Init(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext);
	if (FAILED(hr))
		goto LFail;

	// This is a new engine, let the caller know it is uninitialized
	*pdwState = SCRIPTSTATE_UNINITIALIZED;

LHaveEngine:
	// Return the engine as a CScriptEngine -- the caller only needs those interfaces
	pASE->AssertValid();				// The engine we're about to give back should be valid
	*ppSE = (CScriptEngine *)pASE;
	
	// Put the engine on the Running Scrips List
	// If we got this engine from the FSQ, reuse that elem.
	if (pASEElem == NULL)
		{
		pASEElem = new CASEElem;
		if (!pASEElem)
			{
			hr = E_OUTOFMEMORY;
			goto LFail;
			}
		hr = pASEElem->Init(pASE);
		if (FAILED(hr))
			{
			Assert(FALSE);		// Shouldnt fail
			delete pASEElem;
			goto LFail;
			}
		}

    /*
     * Above, we may have gotten an engine from the FSQ or cloned on from the RSL or
     * created a new one.  And, we are about to put that engine on the RSL.  However,
     * it is possible that the template in question was flushed due to a change notification
     * while this was going on.  Regardless of how we got the engine, there is the possibility
     * that the template was flushed while we were holding onto an engine which was not on
     * any list (the FSQ or RSL), and so we have an engine which should be flushed but isnt.
     * We can detect this by seeing if the template is marked as being a Zombie.  If it is
     * we must mark this engine as being a zombie too, so it wont be returned to the FSQ when
     * it is done running.  Note that once we add this engine to the RSL we are "safe", because
     * any flushes after that point would correctly zombify the engine.
     */
    EnterCriticalSection(&m_csRSL);    
    if (pTemplate->FIsZombie())
        {
        // The template asking for this engine is obsolete. Make sure that no
        // one else will use this engine by marking it zombie
        DBGPRINTF((DBG_CONTEXT, "[CScriptManager] Zombie template found.\n"));
        (*ppSE)->Zombify();
        }

	(VOID)m_htRSL.AddElem(pASEElem);
	LeaveCriticalSection(&m_csRSL);


	// Set the time that the engine was handed out so we will know when to kill it
	pASE->SetTimeStarted(time(NULL));

LFail:

	Assert(SUCCEEDED(hr) || hr == TYPE_E_ELEMENTNOTFOUND);
	return(hr);
	}

/*===================================================================
CScriptManager::ReturnEngineToCache

Caller is done with the engine.  Return it to the cache.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::ReturnEngineToCache
(
CScriptEngine **ppSE,
CAppln *pAppln
)
{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CActiveScriptEngine *pASE;

	Assert(ppSE != NULL);
	Assert(*ppSE != NULL);

	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	
	// Remove the engine from the Running Script List
	EnterCriticalSection( &m_csRSL );
	hr = FindASEElemInList(static_cast<CActiveScriptEngine *>(*ppSE), /*fFSQ*/FALSE, &pASEElem);
	if (FAILED(hr)) {
		LeaveCriticalSection( &m_csRSL );
		goto LExit;
    }
		
	// Note: Sometimes a script will not be in the RSL!  This occurs when
	//       we are reusing a script that is stored in the CTemplate object.
	//       (When the script is reloaded, it is retrieved directly from the
	//        template, bypassing our code which places engines on the RSL)
	//
	if (pASEElem != NULL)
		m_htRSL.RemoveElem(pASEElem);

	LeaveCriticalSection( &m_csRSL );

	/*
	 * If the engine was zombified while it was running, deallocate it.
	 * Or, if there was a GPF while then engine was running, then it might
	 * be in a corrupted state (bug 1225).  Also remove it in that case.
	 */
	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	if (pASE->FIsZombie() || pASE->FIsCorrupted()) {
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
    }

	HRESULT hrT;
	/*
	 * We want to reuse this engine.  Try to return it to the "Uninitialized"
	 * state.  Some engine languages arent able to do this.  If it fails, deallocate
	 * the engine; it cant be reused.
	 */
	hrT = pASE->ResetToUninitialized();
	if (FAILED(hrT)) {
		// Engine doesnt support this, sigh.  Deallocate and continue.
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
    }

    // Get the pTemplate for this engine
	CTemplate *pTemplate;
	DWORD dwEngine;
	pASE->GetDebugDocument(&pTemplate, &dwEngine);

	// CONSIDER: Better strategy for keeping live scripts?
	// Only remember good (no compiler errors) scripts in the template
	if (pAppln->FDebuggable() && pASE->FFullyLoaded() && pTemplate && !pTemplate->FDontAttach()) {
		// Template is marked as incomplete (invalid) when change notification occurs
		// and template is flushed from cache.  In this case, don't cache in CTemplate
		// object!

		if (pTemplate->FIsValid())
			pTemplate->AddScript(dwEngine, pASE);

		// NOTE: Always release the scripting engine.  Exec code is structured so that it
		//       consumes a reference (either through GetEngine() or CTemplate::GetActiveScript())
		//       and assumes that ReturnToCache will release its reference.
		// CONSIDER: Bad design.  Caller should do the release

		delete pASEElem;
		pASE->Release();
    }
	else {
	    // reuse engines, not debugging
		/*
		 * We removed the engine from the RSL, put it onto the FSQ for potential reuse.
		 *
		 * In certain multi-threaded change-notify situations it is possible
		 * that the template was flushed (zombied) while we were in the middle
		 * of returning this engine to the cache.  That is to say, between the time
		 * that we took the engine off the RSL and when we are going to put it on the FSQ
		 * it might have been flushed. In that case, this engine should
		 * not go into the FSQ, but should be deleted instead.  Check for that case.
		 * Do that inside the FSQ CS so that we are safe from the template getting zombied
		 * after we do the test but before the engine goes into the FSQ.  Also, do not
		 * put template on FSQ during shut down phase, since FSQ may go away soon, and
		 * the final destination of the engine is FinalRelease() anyway.
		 */
    	EnterCriticalSection(&m_csFSQ);
    	if (!pTemplate->FIsZombie() && !IsShutDownInProgress()) {
    		AddToFSQ(pASEElem);
        }
    	else {
    		delete pASEElem;
    		pASE->FinalRelease();
        }
		LeaveCriticalSection(&m_csFSQ);
    }

LExit:
	return(hr);
}

/*===================================================================
CScriptManager::FlushCache

A script has been edited; cached versions must be discarded

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushCache
(
LPCTSTR szTemplateName
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
    // There exists a condition during shutdown where the script
    // manager could be uninited and still have calls made on it.
    // This occurs when there are flush threads outstanding for
    // the template cache during shutdown.  Since the script manager
    // is uninited before the template manager, where a check is made
    // for active flush threads, the script manager indeed could be
    // called after it is uninited.

	if (m_fInited == FALSE)
        return S_OK;

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify engines on the RSL of the given name.
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
		{
		    pASE->Zombify();
#ifndef PERF_DISABLE
		    g_PerfData.Incr_ENGINEFLUSHES();
#endif
		}
		
		pASEElem = pASEElemNext;
		}


	// Now throw out engines on the FSQ of the given name
	// Delete any item with the given name (may be several)
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
			{
			(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
            g_PerfData.Decr_SCRIPTFREEENG();
            g_PerfData.Incr_ENGINEFLUSHES();
#endif
			pASE->FinalRelease();
			delete pASEElem;
			}
		
		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::FlushAll

global.asa changed, everything must go

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushAll
(
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify all engines on the RSL
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASEElem->PASE()->Zombify();
#ifndef PERF_DISABLE
		g_PerfData.Incr_ENGINEFLUSHES();
#endif
		pASEElem = pASEElemNext;
		}

	// Now throw out engines on the FSQ
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		(VOID)m_htFSQ.RemoveElem(pASEElem);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
#ifndef PERF_DISABLE
		g_PerfData.Incr_ENGINEFLUSHES();
		g_PerfData.Decr_SCRIPTFREEENG();
#endif

		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::GetDebugScript

Try to find an engine via template pointer, and query for IActiveScriptDebug,
in the RSL.

Returns:
	An AddRef'ed copy of the script engine if found, or NULL if not.
===================================================================*/
IActiveScriptDebug *
CScriptManager::GetDebugScript
(
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
	EnterCriticalSection(&m_csRSL);

	CASEElem *pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		CTemplate *pScriptTemplate = NULL;
		DWORD dwScriptSourceContext = -1;
		CActiveScriptEngine *pASE = pASEElem->PASE();
		pASE->GetDebugDocument(&pScriptTemplate, &dwScriptSourceContext);

		if (pTemplate == pScriptTemplate && dwSourceContext == dwScriptSourceContext)
			{
			IActiveScript *pActiveScript = pASE->GetActiveScript();
			void *pDebugScript;
			if (SUCCEEDED(pActiveScript->QueryInterface(IID_IActiveScriptDebug, &pDebugScript)))
				{
				pASE->IsBeingDebugged();
				LeaveCriticalSection(&m_csRSL);
				return reinterpret_cast<IActiveScriptDebug *>(pDebugScript);
				}
			else
				{
				LeaveCriticalSection(&m_csRSL);
				return NULL;
				}
			}

		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	LeaveCriticalSection(&m_csRSL);

	return NULL;
	}

/*===================================================================
CScriptManager::FindEngineInList

Try to find an engine of the given name in the given list (either
the FSQ or the RSL.)

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindEngineInList
(
LPCTSTR szTemplateName,	// Template we want an engine for
PROGLANG_ID progLangId,	// what language do we want this engine for
DWORD dwInstanceID,     // which server instance
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	DWORD cb;
	
	AssertValid();
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	// Key is name
	cb = _tcslen(szTemplateName)*sizeof(TCHAR);
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		*ppASEElem = static_cast<CASEElem *>(m_htFSQ.FindElem((VOID *)szTemplateName, cb, 
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		*ppASEElem = static_cast<CASEElem *>(m_htRSL.FindElem((VOID *)szTemplateName, cb,
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csRSL);
		}

	return(hr);
	}

/*===================================================================
CScriptManager::FindASEElemInList

Given an ASE, find its corresponding ASEElem in the hash table. Note
that this is relatively slow because it is doing a linked list traversal
not a hash table lookup.  

CONSIDER: create second hash table to do this quickly.

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindASEElemInList
(
CActiveScriptEngine *pASE,
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	
	AssertValid();
	Assert(pASE != NULL);
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
		}

	while (pASEElem != NULL)
		{
		if (pASE == pASEElem->PASE())
			break;
		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	if (fFSQ)
		LeaveCriticalSection(&m_csFSQ);
	else
		LeaveCriticalSection(&m_csRSL);

	*ppASEElem = pASEElem;
		
	return(hr);
	}

/*===================================================================
CScriptManager::KillOldEngines

Loops through all running engines and kills any engines which are "old"
(presumably they are stuck in an infinite loop in VBS.)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::KillOldEngines
(
BOOLB fKillNow // Kill all engines now if TRUE
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem, *pASEElemNext;
	time_t timeNow;
	time_t timeRunning;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	timeNow = time(NULL);

	EnterCriticalSection(&m_csRSL);
	
	pASEElemNext = static_cast<CASEElem *>(m_htRSL.Head());

	/*
	 * Loop through each element.  Turn it into an ASE.
	 * If it is older than cSeconds, then kill it.
	 */
	while (pASEElemNext)
		{
		pASEElem = pASEElemNext;
		pASEElemNext = static_cast<CASEElem *>(pASEElemNext->m_pNext);
		pASE = pASEElem->PASE();

		timeRunning = timeNow - pASE->TimeStarted();

		if (TRUE == fKillNow || timeRunning >= pASE->GetTimeout())
			{
			// Too old. Kill it.
			pASE->InterruptScript();
			}
		}
	
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::EmptyRunningScriptList

When we are going to shut down, the RSL must be empty.  This routine
kills off all running engines, then waits up to 5 minutes
for the engines to leave the RSL.  Added for Bug 1140

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::EmptyRunningScriptList
(
)
	{
	HRESULT hr;
	UINT cTrys;

	hr = KillOldEngines(TRUE);
	Assert(SUCCEEDED(hr));
	for (cTrys = 0; cTrys < 300; cTrys++)
		{
		if (static_cast<CASEElem *>(m_htRSL.Head()) == NULL)
			break;
		Sleep(1000);			// sleep 1 seconds
		}

	return(S_OK);
	}

/*===================================================================
CScriptManager::UnInitASEElems

Free engines in FSQ and RSL

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitASEElems()
	{
	CASEElem *pASEElem = NULL;
	CASEElem *pASEElemNext = NULL;

	// First the FSQ
	EnterCriticalSection(&m_csFSQ);
	pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csFSQ);

	/*
	 * Next the RSL (note: this really should be empty)
	 *
	 * Bug 1140: This is very dangerous, but we have no choice left at this point
	 */
	EnterCriticalSection(&m_csRSL);
	pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csRSL);
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::AddToFSQ

Add the given ASEElem to the FSQ and to the front of the LRU list

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddToFSQ
(
CASEElem *pASEElem
)
	{
	HRESULT hr = S_OK;

	Assert(pASEElem != NULL);

	// If CacheMax is 0, this is a NoOp
	if (Glob(dwScriptEngineCacheMax) <= 0)
		{
		// delete the passed in ASEElem because it wont be saved
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;

		return(S_OK);
		}

	EnterCriticalSection(&m_csFSQ);

	// Add the element to the FSQ
	(VOID)m_htFSQ.AddElem(pASEElem);

#ifndef PERF_DISABLE
    g_PerfData.Incr_SCRIPTFREEENG();
#endif

	// Check the FSQ LRU too see if it is too long
	CheckFSQLRU();

	LeaveCriticalSection(&m_csFSQ);

	return(hr);
	}

/*===================================================================
CScriptManager::CheckFSQLRU

Check to see if the FSQ is too long, and if so throw out the LRU engine

WARNING: Caller must enter FSQ critical section before calling

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::CheckFSQLRU()
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElemOld;
	CActiveScriptEngine *pASE;

	// If the list isnt too long, noop
	if (m_htFSQ.Count() <= Glob(dwScriptEngineCacheMax) || Glob(dwScriptEngineCacheMax) == 0xFFFFFFFF)
		return(S_OK);

	// FSQLRU list is too long, remove oldest
	Assert (! m_htFSQ.FLruElemIsEmpty( m_htFSQ.End() ));
	pASEElemOld = static_cast<CASEElem *>(m_htFSQ.RemoveElem(m_htFSQ.End()));
	Assert(pASEElemOld != NULL);
	pASE = pASEElemOld->PASE();

#ifndef PERF_DISABLE
    g_PerfData.Decr_SCRIPTFREEENG();
#endif

	// Delete the engine
	delete pASEElemOld;
	pASE->FinalRelease();

	return(hr);
	}

/*===================================================================
CScriptManager::UnInitPLL

Free the names of the script engines

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitPLL()
	{
	CPLLElem *pPLLElem = NULL;
	CPLLElem *pPLLElemNext = NULL;

	pPLLElem = (CPLLElem *)m_hTPLL.Head();

	while (pPLLElem != NULL)
		{
		pPLLElemNext = (CPLLElem *)pPLLElem->m_pNext;
		if (pPLLElem->m_pKey != NULL)
			free((CHAR *)(pPLLElem->m_pKey));
		pPLLElem->m_pKey = NULL;
		delete pPLLElem;
		pPLLElem = pPLLElemNext;
		}
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::ProgLangIdOfLangName

Given a programming language name, get the CLSID of the ActiveX Scripting
Engine which runs that language.

WARNING: Needs to look in the registry for this info.  Maybe slow

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::ProgLangIdOfLangName
(
LPCSTR szProgLang,			// The programming lang of the script
PROGLANG_ID *pProgLangId	// The programming language id
)
	{
	HRESULT hr = S_OK;
	CPLLElem *pPLLElem;
	
	AssertValid();
	
	EnterCriticalSection(&m_cSPLL);
	pPLLElem = (CPLLElem *) m_hTPLL.FindElem((VOID *)szProgLang, strlen(szProgLang));
	if (pPLLElem != NULL)
		{
		*pProgLangId = pPLLElem->ProgLangId();
		}
	else
		{
		// Not already in list, look in registry
		hr = GetProgLangIdOfName(szProgLang, pProgLangId);
		if (FAILED(hr))
			{
			hr = TYPE_E_ELEMENTNOTFOUND;
			goto LExit;
			}

		// Add it to the list so we dont have to re-look it up
		hr = AddProgLangToPLL((CHAR *)szProgLang, *pProgLangId);
		if (FAILED(hr))
			goto LExit;
		}

LExit:
	LeaveCriticalSection(&m_cSPLL);
	return(hr);
	}

/*===================================================================
CScriptManager::AddProgLangToPLL

Keep list of programming language CLSIDs so we dont have to look
them up every time.  Add the given programming language name/id pair
to the Programming Language List.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddProgLangToPLL
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr;
	CPLLElem *pPLLElem = NULL;

	// Put the language clsid on the Programming Language List
	pPLLElem = new CPLLElem;
	if (!pPLLElem)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}

	hr = pPLLElem->Init(szProgLangName, progLangId);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		goto LFail;
		}

	EnterCriticalSection(&m_cSPLL);
	(VOID)m_hTPLL.AddElem(pPLLElem);
	LeaveCriticalSection(&m_cSPLL);

LFail:
	return(hr);
	}

/*===================================================================
CScriptManager::ScriptKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces script killer thread 

Parameters:
    void *pv    context pointer (points to script mgr)
    
Returns:

Side effects:
	None.
===================================================================*/
void WINAPI CScriptManager::ScriptKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    
    CScriptManager *pScriptMgr = reinterpret_cast<CScriptManager *>(pv);
    if (pScriptMgr->m_fInited)
        {
        pScriptMgr->KillOldEngines();
        }
    }

#ifdef DBG
/*===================================================================
CScriptManager::AssertValid

Test to make sure that the CScriptManager object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptManager::AssertValid() const
	{
	Assert(m_fInited);
	}
#endif // DBG



/*
 *
 *
 *
 * C A S E E l e m
 *
 * Active Script Engine Elements
 *
 *
 *
 */ 

/*===================================================================
CASEElem::~CASEElem

Destructor for CASEElem object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CASEElem::~CASEElem()
	{
	}

/*===================================================================
CASEElem::Init

Init the Active Script Engine Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CASEElem::Init
(
CActiveScriptEngine *pASE
)
	{
	HRESULT hr = S_OK;
	TCHAR *szT = pASE->SzTemplateName();

	if (szT == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}

	// Key is name
	hr = CLinkElem::Init((LPVOID) szT, _tcslen(szT)*sizeof(TCHAR));
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		return(hr);
		}

	m_pASE = pASE;

	return(hr);
	}




/*
 *
 *
 *
 * C P L L E l e m
 *
 * Programming Language List Element
 *
 *
 *
 *
 */ 

/*===================================================================
CPLLElem::~CPLLElem

Destructor for CPLLElem object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CPLLElem::~CPLLElem()
	{
	CHAR *szT;

	// Free the memory allocated for the key string
	szT = (CHAR *)m_pKey;
	if (szT != NULL)
		free(szT);
	m_pKey = NULL;
	}

/*===================================================================
CPLLElem::Init

Init the Prog Lang Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Allocates memory
===================================================================*/
HRESULT CPLLElem::Init
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr = S_OK;
	CHAR *szT;
	UINT cch;

	if (szProgLangName == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}
		
	cch = strlen(szProgLangName);
	szT = (CHAR *)malloc(cch+1);
	if (!szT)
		{
		return(E_OUTOFMEMORY);
		}
	strcpy(szT, szProgLangName);
	hr = CLinkElem::Init((LPVOID) szT, cch);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		free(szT);
		return(hr);
		}

	m_ProgLangId = progLangId;

	return(hr);
	}


/*===================================================================
GetProgLangIdOfName

Given the name of a programming language, get its programming
language Id from the registry.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT GetProgLangIdOfName
(
LPCSTR szProgLangName,
PROGLANG_ID *pProgLangId
)
	{
	HRESULT hr = S_OK;
	LONG lT;
	HKEY hkeyRoot, hkeyCLSID;
	DWORD dwType;
	CLSID clsid;
	CHAR szClsid[40];
	DWORD cbData;
	LPOLESTR strClsid;
    CMBCSToWChar    convStr;
	
	// The programming language id is really the CLSID of the scripting engine
	// It is in the registry under HKEY_CLASSES_ROOT.  Under the script name,
	// there is a key for "CLSID".  The CLSID is a value under the 
	// engine name.  E.g. \HKEY_CLASSES_ROOT\VBScript\CLSID
	lT = RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgLangName, 0,
						KEY_READ, &hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));
	lT = RegOpenKeyExA(hkeyRoot, "CLSID", 0,
						KEY_READ, &hkeyCLSID);
	RegCloseKey(hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));

	cbData = sizeof(szClsid);
	lT = RegQueryValueExA(hkeyCLSID, NULL, 0, &dwType, (BYTE *)szClsid, &cbData);
	if (lT != ERROR_SUCCESS)
		{
		hr = HRESULT_FROM_WIN32(lT);
		goto lExit;
		}
	Assert(cbData <= sizeof(szClsid));

	// What we got back was the GUID as a string (e.g. {089999-444....}). Convert to a CLSID

    convStr.Init(szClsid);
	strClsid = convStr.GetString();
	hr = CLSIDFromString(strClsid, &clsid);

	*pProgLangId = clsid;

lExit:
	RegCloseKey(hkeyCLSID);

	return(hr);
	}




/*
 *
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * Scripting namespace object
 *
 *
 *
 */ 

/*===================================================================
CScriptingNamespace::CScriptingNamespace

Constructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CScriptingNamespace::CScriptingNamespace()
	: m_fInited(FALSE), m_cRef(1), m_cEngDispMac(0) 
	{
	}

/*===================================================================
CScriptingNamespace::~CScriptingNamespace

Destructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CScriptingNamespace::~CScriptingNamespace()
	{
	UnInit();
	}

/*===================================================================
CScriptingNamespace::Init

Init the CScriptingNamespace object.

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::Init()
	{
	Assert(m_fInited == FALSE);
	
	m_fInited = TRUE;

	AssertValid();

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::UnInit

Free the script engine dispatch's

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::UnInit()
	{
    static const char *_pFuncName = "CScriptingNamespace::UnInit()";
	CEngineDispElem *pElem = NULL;
	ENGDISPBUCKET *pBucket = NULL;

	if (!m_fInited)
		return(S_OK);
		
	while (!m_listSE.FIsEmpty())
		{
		pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		TRYCATCH_NOHITOBJ(pElem->m_pDisp->Release(),"IScriptDispatch::Release()");
        if (pElem->m_pDispEx) {
		        TRYCATCH_NOHITOBJ(pElem->m_pDispEx->Release(),"IScriptDispatchEx::Release()");
        }
		delete pElem;
		}

    while (!m_listEngDisp.FIsEmpty())
        {
        pBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
        delete pBucket;
        }
		
	m_cEngDispMac = 0;
	m_fInited = FALSE;

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::ReInit

Reinit the scripting namespace object

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::ReInit()
	{
	HRESULT hr;

	hr = UnInit();
	if (SUCCEEDED(hr))
		hr = Init();

	return(hr);
	}

/*===================================================================
CScriptingNamespace::AddEngineToNamespace

Add an engine to the list of engines

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::AddEngineToNamespace(CActiveScriptEngine *pASE)
	{
    static const char *_pFuncName = "CScriptingNamespace::AddEngineToNamespace()";
	HRESULT hr;
	IDispatch *pDisp = NULL;
	CEngineDispElem *pElem;

	AssertValid();
	Assert(pASE != NULL);
	pASE->AssertValid();

    TRYCATCH_HR_NOHITOBJ(pASE->GetActiveScript()->GetScriptDispatch(NULL, &pDisp), 
                         hr,
                         "IActiveScript::GetScriptDispatch()");	// FYI - does addref

	if (FAILED(hr))
		{
		goto LFail;
		}
	else
		if (pDisp == NULL)
			{
			hr = E_FAIL;
			goto LFail;
			}

	// Add the engine to the engine hash table.
	pElem = new CEngineDispElem;
	if (pElem == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	pElem->m_pDisp = pDisp;
    pElem->m_pDispEx = NULL;

    // QI for IDispatchEx if available
    TRYCATCH_NOHITOBJ(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pElem->m_pDispEx),"IScriptDispatch::QueryInterface()");
	
	pElem->AppendTo(m_listSE);

	return(S_OK);
	
LFail:
    if (pDisp) {
		TRYCATCH_NOHITOBJ(pDisp->Release(),"IScriptDispatch::Release()");
    }
	return(hr);
	}

/*===================================================================
CScriptingNamespace::QueryInterface
CScriptingNamespace::AddRef
CScriptingNamespace::Release

IUnknown members for CScriptingNamespace object.
===================================================================*/
STDMETHODIMP CScriptingNamespace::QueryInterface(REFIID iid, void **ppvObj)
	{
	AssertValid();

	if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IDispatchEx)
	    {
		*ppvObj = this;
        AddRef();
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::AddRef(void)
	{
	AssertValid();

	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::Release(void)
	{
	if (--m_cRef > 0)
		return m_cRef;

    delete this;
	return 0;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfoCount

We have no typeinfo, so 0.

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfoCount(UINT *pcInfo)
	{
	AssertValid();
	
	*pcInfo = 0;
	return S_OK;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfo

We dont have a typeinfo

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfo
(
UINT itInfo,
LCID lcid,
ITypeInfo **ppITypeInfo
)
	{
	AssertValid();

	*ppITypeInfo = NULL;
	return(E_NOTIMPL);
	}

/*===================================================================
CScriptingNamespace::GetIDsOfNames

Looks through all the engines we know about, calling GetIdsOfNames on
them till we find the requested name.

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
	{
    static const char *_pFuncName = "CScriptingNamespace::GetIDsOfNames()";
	HRESULT hr;
	CEngineDispElem *pElem;

	AssertValid();

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	/*
	 * Loop through the engines we know about until we find the one that has the requested name
	 * (or hit the end of the list, in which case it is not found)
	 */
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		Assert(pElem->m_pDisp != NULL);
		
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID), 
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
		
		if (SUCCEEDED(hr))
		    {
            return CacheDispID(pElem, rgDispID[0], rgDispID);
			}
		}

	return DISP_E_UNKNOWNNAME;
	}

/*===================================================================
CScriptingNamespace::Invoke

Map the dispID to the correct engine, and pass the invoke on to that
engine.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
	{
    static const char *_pFuncName = "CScriptingNamespace::Invoke()";
	HRESULT hr;
    ENGDISP *pEngDisp;

	AssertValid();
	
	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(dispID, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
	Assert(pEngDisp->pDisp != NULL);
	
    // invoke
	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
	                        (
	                        pEngDisp->dispid, 
	                        riid, 
	                        lcid,
		                    wFlags, 
		                    pDispParams, 
		                    pVarResult, 
		                    pExcepInfo, 
		                    puArgErr
		                    ),
                         hr,
                         "IScriptDispatch::Invoke()");
	
	return hr;
	}

/*===================================================================
CScriptingNamespace::  IDispatchEx implementation stubs
===================================================================*/
STDMETHODIMP CScriptingNamespace::DeleteMemberByDispID(DISPID id)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberName(DISPID id, BSTR *pbstrName)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNameSpaceParent(IUnknown **ppunk)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
    {
    return E_NOTIMPL;
    }
    
/*===================================================================
CScriptingNamespace::GetDispID

IDispatchEx replacement for GetIDsOfNames
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetDispID
(
BSTR bstrName, 
DWORD grfdex, 
DISPID *pid
)
    {
    static const char *_pFuncName = "CScriptingNamespace::GetDispID()";
    HRESULT hr;
	CEngineDispElem *pElem = NULL;
    grfdex &= ~fdexNameEnsure;  // engines shouldn't create new names

    // Try IDispatchEx for all engines that have it
    
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx != NULL)
		    {
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDispEx->GetDispID(bstrName, grfdex, pid), 
                                 hr,
                                 "IScriptDispatchEx::GetDispID()");
		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}

    // Try IDispatch for engines that don't have IDispatchEx
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx == NULL)
		    {
    		Assert(pElem->m_pDisp != NULL);
    		TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames
            		                (
    	        	                IID_NULL,
    		                        &bstrName,
    		                        1,
    		                        LOCALE_SYSTEM_DEFAULT,
    		                        pid
    		                        ),
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
    		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}
	
	return DISP_E_UNKNOWNNAME;
    }
    
/*===================================================================
CScriptingNamespace::Invoke

IDispatchEx replacement for Invoke
===================================================================*/
STDMETHODIMP CScriptingNamespace::InvokeEx
(
DISPID id, 
LCID lcid, 
WORD wFlags, 
DISPPARAMS *pdp,
VARIANT *pVarRes,    
EXCEPINFO *pei,    
IServiceProvider *pspCaller 
)
    {
    static const char *_pFuncName = "CScriptingNamespace::InvokeEx()";
	HRESULT hr;
    ENGDISP *pEngDisp;

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(id, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
    if (pEngDisp->pDispEx != NULL)
        {
        // InvokeEx if the engine supports IDispatchEx
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDispEx->InvokeEx
    	                            (
    	                            pEngDisp->dispid, 
                                    lcid, 
                                    wFlags, 
                                    pdp,
                                    pVarRes,    
                                    pei,    
                                    pspCaller 
    	                            ),
                             hr,
                             "IScriptDispatchEx::InvokeEx()");
        }
    else
        {
        // use IDispatch::Invoke if the engine doesn't support IDispatchEx
    	Assert(pEngDisp->pDisp != NULL);

    	UINT uArgErr;
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
    	                            (
    	                            pEngDisp->dispid, 
    	                            IID_NULL, 
    	                            lcid,
    		                        wFlags, 
    		                        pdp, 
    		                        pVarRes, 
    		                        pei, 
    		                        &uArgErr
    		                        ),
                             hr,
                             "IScriptDispatch::Invoke()");
	    }
	
	return hr;
    }

/*===================================================================
CScriptingNamespace::CacheDispID

Adds new DISPID to the list

Parameters
    pEngine         -- engine for which disp id found
    dispidEngine    -- found dispid
    pdispidCached   -- [out] cached dispid (for ScriptingNamespace)

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::CacheDispID
(
CEngineDispElem *pEngine,
DISPID dispidEngine,
DISPID *pdispidCached
)
	{
	ENGDISPBUCKET *pEngDispBucket;
	
	// See if we need to add another bucket
	if ((m_cEngDispMac % ENGDISPMAX) == 0)
		{
		pEngDispBucket = new ENGDISPBUCKET;
		if (pEngDispBucket == NULL)
			return E_OUTOFMEMORY;

		pEngDispBucket->AppendTo(m_listEngDisp);
		}

    // Navigate to the correct bucket
	unsigned iEngDisp = m_cEngDispMac;
	pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

	pEngDispBucket->rgEngDisp[iEngDisp].dispid  = dispidEngine;
	pEngDispBucket->rgEngDisp[iEngDisp].pDisp   = pEngine->m_pDisp;
	pEngDispBucket->rgEngDisp[iEngDisp].pDispEx = pEngine->m_pDispEx;

	// Return index as the dispid
	*pdispidCached = (DISPID)m_cEngDispMac;
	m_cEngDispMac++;
	return S_OK;
	}
    
/*===================================================================
CScriptingNamespace::FetchDispID

Find ENGDISP by DISPID

Parameters
    dispid      - in
    ppEngDisp   - out

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::FetchDispID
(
DISPID dispid, 
ENGDISP **ppEngDisp
)
    {
	if (dispid >= (DISPID)m_cEngDispMac)
	    return E_FAIL;

	unsigned iEngDisp = dispid;
	ENGDISPBUCKET *pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

    *ppEngDisp = &pEngDispBucket->rgEngDisp[iEngDisp];
    return S_OK;
    }
    

#ifdef DBG
/*===================================================================
CScriptingNamespace::AssertValid

Test to make sure that the CScriptingNamespace object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptingNamespace::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_cRef > 0);
	}
	
#endif // DBG



/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */



/*===================================================================
WrapTypeLibs

Utility routine to take an array of Typelibs, and return an IDispatch
implementation that wraps the array of typelibs.

Parameters:
    ITypeLib **prgpTypeLib  - pointer to an array of typelibs
    UINT cTypeLibs          - count of typelibs in array
    IDispatch **ppDisp      - returned IDispatch

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
HRESULT WrapTypeLibs
(
ITypeLib **prgpTypeLib,
UINT cTypeLibs,
IDispatch **ppDisp
)
	{
	HRESULT hr;
	Assert(g_pWrapTypelibs != NULL);
	Assert(prgpTypeLib != NULL);
	Assert(cTypeLibs > 0);
	Assert(ppDisp != NULL);

    hr = g_pWrapTypelibs->WrapTypeLib(prgpTypeLib, cTypeLibs, ppDisp);
    
	return(hr);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\server.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.h

Owner: CGrant

This file contains the header info for defining the Server object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Server_H
#define _Server_H

#include "debug.h"
#include "dispatch.h"
#include "denguid.h"
#include "memcls.h"

#ifdef USE_LOCALE
extern DWORD g_dwTLS;
#endif

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

// Forward declr
class CHitObj;

/*
 * C S e r v e r D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CServerData
    {
public:    
    // Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ISupportErrImp;

    // CIsapiReqInfo block for HTTP info
    CIsapiReqInfo *m_pIReq;

    // Back pointer to current HitObj (required for the MapPath)
	CHitObj *m_pHitObj;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*
 * C S e r v e r
 *
 * Implements the Server object
 */
class CServer : public IServerImpl
	{
private:

    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CServerData *m_pData;   // pointer to structure that holds
                            // CServer properties

    // FTM Support
    IUnknown    *m_pUnkFTM;
                            
public:
	CServer(IUnknown *punkOuter = NULL);
	~CServer();

    HRESULT Init();
    HRESULT UnInit();
    
    HRESULT ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

    HRESULT MapPathInternal(DWORD dwContextId, WCHAR *wszVirtPath, 
                            TCHAR *szPhysPath, TCHAR *szVirtPath = NULL);

    // Retrieve HitObj
    inline CHitObj *PHitObj() { return m_pData ? m_pData->m_pHitObj : NULL; }

	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IServer functions
	STDMETHODIMP CreateObject(BSTR bstr, IDispatch **ppdispObject);
	STDMETHODIMP MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath);
	STDMETHODIMP HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP get_ScriptTimeout(long * plTimeoutSeconds);
	STDMETHODIMP put_ScriptTimeout(long lTimeoutSeconds);		
	STDMETHODIMP Execute(BSTR bstrURL);
	STDMETHODIMP Transfer(BSTR bstrURL);
	STDMETHODIMP GetLastError(IASPError **ppASPErrorObject);

    // Debug support
    
#ifdef DBG
	inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
	inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
	void AssertValid() const;
#else
	inline void TurnDiagsOn()  {}
	inline void TurnDiagsOff() {}
	inline void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

typedef CServer *PCServer;

#endif //_Server_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\smhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.h

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/

#ifndef SMHASH_H
#define SMHASH_H

#include "LinkHash.h"

/*
 * C S M H a s h
 *
 * CSMHash is identical to CHashTable, but AddElem has differing behavior.
 */
class CSMHash : public CLinkHash
{
public:
	CLruLinkElem *AddElem(CLruLinkElem *pElem);
	CLruLinkElem *FindElem(const void *pKey, int cbKey, PROGLANG_ID proglang_id, DWORD dwInstanceID, BOOL fCheckLoaded);

};

#endif // SMHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\smhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.cpp

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"

/*===================================================================
CSMHash::AddElem

Adds a CLruLinkElem to the SM Hash table.
User is responsible for allocating the Element to be added.

Note: This is identical to the standard CHashTable::AddElem, except
that it allows for elements with duplicate names

Parameters:
	CLruLinkElem *pElem		Object to be added

Returns:
	Pointer to element added/found.
===================================================================*/
CLruLinkElem *CSMHash::AddElem
(
CLruLinkElem *pElem
)
	{
	AssertValid();

    if (m_rgpBuckets == NULL)
        {
        if (FAILED(AllocateBuckets()))
            return NULL;
        }
	
	if (pElem == NULL)
		return NULL;

	UINT			iBucket = m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	
	while (pT)
		{
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			break;
		}

	if (pT)
		{
		// There are other elements in bucket
		pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_Info = pT->m_Info + 1;
		pElem->m_pNext = pT;
		pElem->m_pPrev = pT->m_pPrev;
		pT->m_pPrev = pElem;
		if (pElem->m_pPrev == NULL)
			m_pHead = pElem;
		else
			pElem->m_pPrev->m_pNext = pElem;
		}
	else
		{
		// This is the first element in the bucket
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_pPrev = NULL;
		pElem->m_pNext = m_pHead;
		pElem->m_Info = 0;
		if (m_pHead)
			m_pHead->m_pPrev = pElem;
		else
			m_pTail = pElem;
		m_pHead = pElem;
		}
	m_Count++;
	pElem->PrependTo(m_lruHead);
	AssertValid();
	return pElem;
	}

/*===================================================================
CSMHash::FindElem

Finds a script engine element in the hash table based on the name
and language type.

Parameters:
	void *	pKey			- the key to look for
	int		cbKey			- length of the key to look for
	PROGLANG_ID proglang_id - program language name
	DWORD   dwInstanceID    - instance ID to find
	BOOL	fCheckLoaded	- if true, only return engines flagged as "loaded"

Returns:
	Pointer to CLruLinkElem if found, otherwise NULL.
===================================================================*/
CLruLinkElem * CSMHash::FindElem
(
const void *pKey,
int cbKey,
PROGLANG_ID proglang_id,
DWORD dwInstanceID,
BOOL fCheckLoaded
)
	{
	AssertValid();
	if (m_rgpBuckets == NULL || pKey == NULL)
		return NULL;

	UINT iBucket = m_pfnHash(static_cast<const BYTE *>(pKey), cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	CLruLinkElem *	pRet = NULL;

	/*
	 * We have the right bucket based on the hashed name.  
	 * Search through the bucket chain looking for elements whose name
	 * is correct (multiple names can hash to the same bucket), and 
	 * whose language is the one we want, and (optionally) skip
	 * elements that are not fully "loaded"
	 *
	 * Note: This all relys on intimate knowlege of the format of an ActiveScriptEngine.
	 *			these elements better be ASE's.
	 */
	while (pT && pRet == NULL)
		{
		if (FIsEqual(pT->m_pKey, pT->m_cbKey, pKey, cbKey))
			{
			CASEElem *pASEElem = static_cast<CASEElem *>(pT);
			Assert(pASEElem != NULL);
			CActiveScriptEngine *pASE = pASEElem->PASE();
			Assert(pASE != NULL);
			
			// Element has the right name.  Is it really the one we want?
			if (proglang_id != pASE->ProgLang_Id())
				goto LNext;

			if (dwInstanceID != pASE->DWInstanceID())
				goto LNext;

			if (fCheckLoaded && !pASE->FFullyLoaded())
				goto LNext;

			// Yup, its the right one!
			pRet = pT;
			break;
			}
			
LNext:			
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			{
			// got to the last element in this bucket chain
			break;
			}
		}
		
	if (pRet)
		pRet->PrependTo(m_lruHead);

	AssertValid();
	return pRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\scrptmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.h

Owner: AndrewS

This file contains the declarations for the Script Manager, ie. siting an
ActiveX Scripting engine (in our case VBScript) for Denali.
===================================================================*/

#ifndef __ScrptMgr_h
#define __ScrptMgr_h

#include <dispex.h>

#include "activscp.h"
#include "activdbg.h"
#include "hostinfo.h"
#include "util.h"
#include "HitObj.h"
#include "hashing.h"
#include "memcls.h"
#include "scrpteng.h"


typedef SCRIPTSTATE ENGINESTATE;	// Uninited, Loaded, etc
typedef CLSID PROGLANG_ID;
const CBPROGLANG_ID = sizeof(PROGLANG_ID);

class CActiveScriptSite;
class CActiveScriptEngine;
class CASEElem;
class CScriptingNamespace;
class CAppln;

// SMHash depends on stuff in this include file which must be defined first.
#include "SMHash.h"

/*
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 * Manages script engines, potentially caching them for future use,
 * hands script engines to callers for use.
 *
 */
class CScriptManager
	{
private:
	// private data members
	BOOLB m_fInited;				// Are we initialized?

	/*
	 * Script Engines that are not in use can be reused and 
	 * go on the Free Script Queue.  It is a queue so we can
	 * discard the oldest if we need to.
	 *
	 * Engines that are in use cant be reused.  When an engine
	 * is handed out to be used, it is removed from the FSQ.  When a thread
	 * is done using an engine, it calls ReturnEngineToCache to put it back on
	 * the FSQ.  If the Queue is at max length, the oldest engine on the queue is
	 * freed at that point.  The one returned is put on the front of the queue.
	 *
	 * We also maintain a Running Script List.  This is needed so that if we 
	 * are told to flush a given script from our cache, we can "zombify" any
	 * running scripts that have that script in them (so they will be discarded
	 * when they are done running.)
	 *
	 * Additional note: Though we cant have multiple users of the *same* runing engine
	 * we can "clone" a running engine.  If we get two simulanteous requests for Foo.ASP
	 * we expect that it will be faster to clone the second one from the first one than
	 * to create a second engine for the second request.  Thus, the RSL will be searched
	 * for a given engine to clone if no suitable engine is found on the FSQ.
	 *
	 * DEBUGGING NOTE:
	 *    Once the debugger asks a script engine for a code context cookie, we cannot
	 *    ever let go of the script engine until the debugger detaches.  Therefore, we
	 *    don't cache scripts in the FSQ if debugging is active.  Instead, the scripts
	 *    are placed in the template when execution is finished, there to be doled back
	 *    out when that engine is needed by the debugging engine.
	 *
	 *    CONSIDER:
	 *       We could be smarter about this, and cache scripts UNTIL the debugger either
	 *          a. Asks for a code context from a document context, or
	 *          b. Calls GetDocumentContextFromPosition, in which case, the debugger
	 *             got a code context "behind our virtual backs".
	 *
	 *       If we don't do this, we could, at the very least, only implement this
	 *       debugging behavior when a debugger attaches to our application.
	 *       (i.e. stop caching on attach, then on detach, resume caching, and also
	 *        free scripts that the template objects are holding onto.)
	 */
	CSMHash m_htFSQ;				// Free Script Queue
	CRITICAL_SECTION m_csFSQ;		// Serialize access to FSQ
	CSMHash m_htRSL;				// Running Script List
	CRITICAL_SECTION m_csRSL;		// Serialize access to RSL

	CHashTable 		m_hTPLL;		// Hash table of language engine classid's
	CRITICAL_SECTION m_cSPLL;		// Serialize access to PLL

	DWORD m_idScriptKiller;         // Script killer sched workitem id
	DWORD m_msecScriptKillerTimeout;// Current script killer timeout

	// private methods
	HRESULT UnInitASEElems();
	HRESULT UnInitPLL();
	HRESULT AddProgLangToPLL(CHAR *szProgLangName, PROGLANG_ID progLangId);

    // script killer
	static VOID WINAPI ScriptKillerSchedulerCallback(VOID *pv);

public:	
	// public methods
	CScriptManager();
	~CScriptManager();

	HRESULT Init();
	HRESULT UnInit();

	// Resolves a language name into a prog lang id, adding to engine list (m_hTPLL) if not already there
	HRESULT ProgLangIdOfLangName(LPCSTR szProgLang, PROGLANG_ID *pProgLangId);

	// Return an engine, preferably filled with the script for the given template/language
	HRESULT GetEngine(	LCID lcid,					// The system language to use
						PROGLANG_ID& progLangId,	// prog lang id of the script
						LPCTSTR szTemplateName,		// Template we want an engine for
						CHitObj *pHitObj,			// Hit obj to use in this engine
						CScriptEngine **ppSE,		// Returned script engine
						ENGINESTATE *pdwState,		// Current state of the engine
						CTemplate *pTemplate,		// template (debug document)
						DWORD dwSourceContext);		// script engine index

	HRESULT ReturnEngineToCache(CScriptEngine **, CAppln *);

	// Throw out any cached engines containing a given template
	// (presumably the script changed on disk so the cache is obsolete.)
	HRESULT FlushCache(LPCTSTR szTemplateName);	// Template to throw out of the cache

	HRESULT FlushAll();    // Clear the entire FSQ

	HRESULT KillOldEngines(BOOLB fKillNow = FALSE); // Kill expired scripting engines

	// Bug 1140: Called prior to shutting down script manager to make sure RSL is empty
	HRESULT EmptyRunningScriptList();

    // Adjust (shorten) script killer timeout
    HRESULT AdjustScriptKillerTimeout(DWORD msecNewTimeout);

	// Find running script that corresponds to a template (in one of its script blocks)
	IActiveScriptDebug *GetDebugScript(CTemplate *pTemplate, DWORD dwSourceContext);

private:
	HRESULT FindEngineInList(LPCTSTR szTemplateName, PROGLANG_ID progLangId, DWORD dwInstanceID, BOOL fFSQ, CASEElem **ppASEElem);
	HRESULT FindASEElemInList(CActiveScriptEngine *pASE, BOOL fFSQ, CASEElem **ppASEElem);

	// For threading a FIFO queue through the hash table
	HRESULT AddToFSQ(CASEElem *pASEElem);
	HRESULT CheckFSQLRU();

#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

extern CScriptManager g_ScriptManager;


/*
 *
 *
 * C A c t i v e S c r i p t E n g i n e
 *
 * Object defining methods required to host an ActiveXScripting engine &
 * service requests to that engine.
 *
 */
class CActiveScriptEngine :
				public CScriptEngine,
				public IActiveScriptSite,
				public IActiveScriptSiteDebug,
				public IHostInfoProvider
	{
private:
	// private data members
	UINT m_cRef;				// Reference count
	IDispatch *m_pDisp;			// IDispatch interface on script
	CHitObj *m_pHitObj;			// The hit object contains a list of objects for this run
	LPTSTR m_szTemplateName;	// The name of the template this engine has loaded
	DWORD m_dwInstanceID;		// server instance ID of template this engine has loaded
	TCHAR m_szTemplateNameBuf[64]; // Buffer for short templates to fit to avoid allocs
	PROGLANG_ID m_proglang_id;	// What programming language?
	LCID m_lcid;				// what system language
	IActiveScript *m_pAS;		// The script object sited here
	IActiveScriptParse *m_pASP;	// The script object parser
	IHostInfoUpdate *m_pHIUpdate;// Interface for advising the script that we have new host info
	time_t m_timeStarted;		// Time when the script engine was handed out last.
	CTemplate *m_pTemplate;		// template that acts as debugging document
	DWORD m_dwSourceContext;	// "Cookie" value which is really script engine
	DWORD m_fInited : 1;		// Have we been inited?
	DWORD m_fZombie : 1;		// Do we need to be deleted on last use
	DWORD m_fScriptLoaded : 1;	// Have we been called with script to load yet? (Used for clone)
	DWORD m_fObjectsLoaded : 1;	// Have we been called with a set of objects yet? (Used for clone)
	DWORD m_fBeingDebugged : 1;	// Is this script being debugged now?
	DWORD m_fTemplateNameAllocated : 1; // Is name allocated? (need to free?)

	/*
	 * NOTE: ActiveXScripting:
	 * ActiveXScripting had an undone such that the excepinfo filled in in InteruptScript
	 * was not passed to OnScriptError.  We would have liked to use that mechanism to cause
	 * correct error loging (or suppression) if we interrupt a script.  However,
	 * since ActiveXScripting wasnt passing the info, we didnt know.  We wrote this code to 
	 * handle it ourselves.  They have now fixed it, but the mechanism we implemented works very
	 * well, so we are not going to change it.
	 */
	DWORD m_fScriptAborted : 1;		// The script did a Response.End
	DWORD m_fScriptTimedOut : 1;	// We killed the script on timeout
	DWORD m_fScriptHadError : 1;	// The script had an error while running.  Transacted script should autoabort

	/*
	 * BUG 1225: If there is a GPF running a script, we shouldnt reuse the engine
	 */
	DWORD m_fCorrupted : 1;		// Might the engine be "unsafe" for reuse?

    // handle GetItemInfo() failure
	void HandleItemNotFound(LPCOLESTR pcszName);

	HRESULT StoreTemplateName(LPCTSTR szTemplateName);

public:
	CActiveScriptEngine();
	~CActiveScriptEngine();

	HRESULT Init(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext);

	HRESULT MakeClone(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext,
				DWORD dwInstanceID,
				IActiveScript *pAS);			// The cloned script engine

	HRESULT ReuseEngine(
						CHitObj *pHitObj,
						CTemplate *pTemplate,
						DWORD dwSourceContext,
						DWORD dwInstanceID
						);

	time_t TimeStarted();
	VOID SetTimeStarted(time_t timeStarted);

	BOOL FBeingDebugged();			// Is the script being debugged?
	VOID IsBeingDebugged();			// Notify script that it is being debugged

	HRESULT ResetToUninitialized();
	HRESULT GetASP();
	HRESULT GetIDisp();
	HRESULT GetIHostInfoUpdate();
	IActiveScript *GetActiveScript();
	LPTSTR SzTemplateName();
	BOOL FIsZombie();
	BOOL FIsCorrupted();
	PROGLANG_ID ProgLang_Id();
	DWORD DWInstanceID();
	BOOL FFullyLoaded();
	long GetTimeout();
	BOOL FScriptTimedOut();
	BOOL FScriptHadError();
	void GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext);


	/*
	 * C S c r i p t E n g i n e   M e t h o d s
	 */
	HRESULT AddScriptlet(LPCOLESTR wstrScript);

	HRESULT AddObjects(BOOL fPersistNames = TRUE);

	HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE);

	HRESULT AddScriptingNamespace();
	
	HRESULT Call(LPCOLESTR strEntryPoint);

	HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint);

	HRESULT MakeEngineRunnable()  { return(Call(NULL)); };

	HRESULT ResetScript() { return m_pAS? m_pAS->SetScriptState(SCRIPTSTATE_UNINITIALIZED) : E_FAIL; }

	VOID Zombify();

	HRESULT InterruptScript(BOOL fAbnormal = TRUE);

	HRESULT UpdateLocaleInfo(hostinfo hi);

	HRESULT TryCall(LPCOLESTR strEntryPoint);

	ULONG FinalRelease();

	/*
	 * I U n k n o w n   M e t h o d s
	 */
	STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
	STDMETHOD_(ULONG, AddRef)(VOID);
	STDMETHOD_(ULONG, Release)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e   M e t h o d s
	 */
	STDMETHOD(GetLCID)(LCID *plcid);

	STDMETHOD(GetItemInfo)(LPCOLESTR pcszName,
							DWORD dwReturnMask,
							IUnknown **ppiunkItem,
							ITypeInfo **ppti);

	STDMETHOD(GetDocVersionString)(BSTR *pszVersion);

	STDMETHOD(RequestItems)(BOOL fPersistNames = TRUE);

	STDMETHOD(RequestTypeLibs)(VOID);

	STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult,
								const EXCEPINFO *pexcepinfo);
	STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);

	STDMETHOD(OnScriptError)(IActiveScriptError __RPC_FAR *pscripterror);

	STDMETHOD(OnEnterScript)(VOID);

	STDMETHOD(OnLeaveScript)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
	 */
	STDMETHOD(GetDocumentContextFromPosition)(
			/* [in] */ DWORD_PTR dwSourceContext,
			/* [in] */ ULONG uCharacterOffset,
			/* [in] */ ULONG uNumChars,
			/* [out] */ IDebugDocumentContext **ppsc);

	STDMETHOD(GetApplication)(/* [out] */ IDebugApplication **ppda);

	STDMETHOD(GetRootApplicationNode)(/* [out] */ IDebugApplicationNode **);

	STDMETHOD(OnScriptErrorDebug)(
			/* [in] */ IActiveScriptErrorDebug *pErrorDebug,
			/* [out] */ BOOL *pfEnterDebugger,
			/* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        
	/*
	 * IHostInfoProvider methods
	 */

	 STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void **ppvInfo);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline VOID CActiveScriptEngine::Zombify() { m_fZombie = TRUE; }
inline BOOL CActiveScriptEngine::FFullyLoaded() { return(m_fScriptLoaded && m_fObjectsLoaded); }
inline BOOL CActiveScriptEngine::FIsZombie() { return(m_fZombie); }
inline BOOL CActiveScriptEngine::FIsCorrupted() { return(m_fCorrupted); }
inline time_t CActiveScriptEngine::TimeStarted() { return(m_timeStarted); }
inline VOID CActiveScriptEngine::SetTimeStarted(time_t timeStarted) { m_timeStarted = timeStarted; }
inline IActiveScript *CActiveScriptEngine::GetActiveScript() { return(m_pAS); }
inline LPTSTR CActiveScriptEngine::SzTemplateName() { return(m_szTemplateName); }
inline PROGLANG_ID CActiveScriptEngine::ProgLang_Id() { return(m_proglang_id); }
inline DWORD CActiveScriptEngine::DWInstanceID() { return(m_dwInstanceID); }
inline BOOL CActiveScriptEngine::FBeingDebugged() { return(m_fBeingDebugged); }			// Is the script being debugged?
inline VOID CActiveScriptEngine::IsBeingDebugged() { m_fBeingDebugged = TRUE; }
inline BOOL CActiveScriptEngine::FScriptTimedOut() { return m_fScriptTimedOut; }
inline BOOL CActiveScriptEngine::FScriptHadError() { return m_fScriptHadError; }
inline long CActiveScriptEngine::GetTimeout() { return m_fBeingDebugged? LONG_MAX : m_pHitObj->GetScriptTimeout(); }
inline void CActiveScriptEngine::GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext)
	{
	if (ppTemplate) *ppTemplate = m_pTemplate;
	if (pdwSourceContext) *pdwSourceContext = m_dwSourceContext;
	}

/*
 *
 *
 * C A S E E l e m
 *
 * Script element.  For keeping lists and queues of script engines
 *
 */
class CASEElem : public CLruLinkElem
	{
private:
	CActiveScriptEngine *m_pASE;

public:
	CASEElem() : m_pASE(NULL) {}
	~CASEElem();

	HRESULT Init(CActiveScriptEngine *pASE);
	CActiveScriptEngine *PASE();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline CActiveScriptEngine *CASEElem::PASE() { return(m_pASE); }


/*
 *
 *
 * C P L L E l e m
 *
 * Hash table list element for a Programming Language List.
 *
 */
class CPLLElem : public CLinkElem
	{
private:
	PROGLANG_ID m_ProgLangId;			// clsid for the language
	
public:
	CPLLElem() : m_ProgLangId(CLSID_NULL) {};
	~CPLLElem();

	HRESULT Init(CHAR *szProgLangName, PROGLANG_ID progLangId);
	PROGLANG_ID ProgLangId();
	};

inline PROGLANG_ID CPLLElem::ProgLangId() { return(m_ProgLangId); }


/*
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * We need to keep track of all of the names which different engines (and typeinfos)
 * contribute to the namespace.   All of these names go into this object
 * which we give to each engine with the SCRIPTITEM_GLOBALMEMBERS flag. When
 * ActiveXScripting calls us back on GetIdsOfNames, we will call the engines
 * we have cached until we find the name.  When AXS calls us with Invoke,
 * we will map the id to the appropriate engine and pass on the invoke
 *
 * Data structure note:
 *   We implement the ScriptingNamespace with a linked list of arrays.
 *   This gives reasonable access time and should minimize heap
 *   fragmentation.  In debug mode, the number of buckets is small to
 *   excersize the resize code.
 *
 * NOTE: "ENGDISPMAX" should be a power of two - this will allow the optimizer
 *       to optimize the integer divide and modulus operations with bit-ands and
 *       shifts.  However, the code does not assume that "ENGDISPMAX" is a power
 *       of two.
 */

#ifdef DBG
#define ENGDISPMAX 2
#else
#define ENGDISPMAX 32
#endif

typedef struct _engdisp
	{
	DISPID dispid;				// the dispid that the engine really uses
	IDispatch *pDisp;			// the engine to call for this dispid
	IDispatchEx *pDispEx;	    // the engine to call for this dispid
	} ENGDISP;

typedef struct _engdispbucket : CDblLink
	{
	ENGDISP rgEngDisp[ENGDISPMAX+1];
	} ENGDISPBUCKET;

class CEngineDispElem : public CDblLink
	{
public:
	IDispatch *m_pDisp;
	IDispatchEx *m_pDispEx;
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

class CScriptingNamespace : public IDispatchEx
	{
private:
	ULONG m_cRef;				// Reference count
	BOOLB m_fInited;
	CDblLink m_listSE;			// List of scripting engines (list of CSEElem's)
	UINT m_cEngDispMac;
	CDblLink m_listEngDisp;

    HRESULT CacheDispID(CEngineDispElem *pEngine, DISPID dispidEngine, DISPID *pdispidCached);
    HRESULT FetchDispID(DISPID dispid, ENGDISP **ppEngDisp);

public:
	// public methods
	CScriptingNamespace();
	~CScriptingNamespace();

	HRESULT Init();
	HRESULT UnInit();
	HRESULT ReInit();
	HRESULT AddEngineToNamespace(CActiveScriptEngine *pASE);

    // IUnknown
	STDMETHODIMP QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
    // IDispatch
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
    // IDispatchEx
    STDMETHODIMP DeleteMemberByDispID(DISPID id);
    STDMETHODIMP DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
    STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);
    STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                          VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);

public:
#ifdef DBG
	VOID AssertValid() const;
#else
	VOID AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};


/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */
HRESULT WrapTypeLibs(ITypeLib **prgpTypeLib, UINT cTypeLibs, IDispatch **ppDisp);

#endif // __ScrptMgr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\strlist.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: strlist.cpp

Owner: DGottner

This file contains the code for the implementation of the String List object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "strlist.h"
#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


/*===================================================================
CStringListElem::CStringListElem

Constructor
===================================================================*/
CStringListElem::CStringListElem()
    : 
    m_fBufferInUse(FALSE),
    m_fAllocated(FALSE),
    m_pNext(NULL),
    m_szPointer(NULL)
	{
	}

/*===================================================================
CStringListElem::~CStringListElem

Destructor
===================================================================*/
CStringListElem::~CStringListElem()
	{
	if (m_fAllocated)
		delete [] m_szPointer;

    if (m_pNext)
    	delete m_pNext;
	}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
    lCodePage       codepage to use to convert to UNICODE
===================================================================*/
HRESULT CStringListElem::Init(
    char    *szValue,
    BOOL    fMakeCopy,
    UINT    lCodePage)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        CMBCSToWChar    convStr;
        HRESULT         hr = S_OK;

        if (FAILED(hr = convStr.Init(szValue, lCodePage))) {
            return hr;
        }

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy of the converted
        // string.

        if ((convStr.GetStringLen() + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = convStr.GetString(TRUE);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, convStr.GetString());
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
===================================================================*/
HRESULT CStringListElem::Init(
    WCHAR   *wszValue,
    BOOL    fMakeCopy)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy

        if ((wcslen(wszValue) + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = StringDupW(wszValue);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, wszValue);
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}


/*===================================================================
CStringList::CStringList

Constructor
===================================================================*/

CStringList::CStringList(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_ISupportErrImp(this, pUnkOuter, IID_IStringList)
	{
	m_pBegin = m_pEnd = NULL;
	m_cValues = 0;
	m_cRefs = 1;
	m_pfnDestroy = pfnDestroy;
	CDispatch::Init(IID_IStringList);
	m_lCodePage = GetACP();
	}



/*===================================================================
CStringList::~CStringList

Destructor
===================================================================*/

CStringList::~CStringList()
	{
	if (m_pBegin)
    	delete m_pBegin;
	}



/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(char *szValue, BOOL fDuplicate, UINT lCodePage)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	m_lCodePage = lCodePage;

	HRESULT hr = pElem->Init(szValue, fDuplicate, lCodePage);
    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}

/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(WCHAR *szValue, BOOL fDuplicate)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	HRESULT hr = pElem->Init(szValue, fDuplicate);

    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::QueryInterface
CStringList::AddRef
CStringList::Release

IUnknown members for CStringList object.
===================================================================*/

STDMETHODIMP CStringList::QueryInterface(const IID &iid, void **ppvObj)
	{
	*ppvObj = NULL;

	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IStringList || iid == IID_IDenaliIntrinsic)
	    {
		*ppvObj = this;
		}

	if (iid == IID_ISupportErrorInfo)
		*ppvObj = &m_ISupportErrImp;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CStringList::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStringList::Release()
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CStringList::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CStringList::get_Count(int *pcValues)
	{
	*pcValues = m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::ConstructDefaultReturn

Return comma-separated list for the case where the CStringList
is not indexed.
===================================================================*/

HRESULT CStringList::ConstructDefaultReturn(VARIANT *pvarOut) {
	VariantClear(pvarOut);

	//
	// NEW SEMANTIC: we now return Empty (and not "") if nothing is in the collection
	//
	if (m_cValues == 0)
		return S_OK;		// VariantClear set pvarOut to Empty

    STACK_BUFFER( tempValues, 1024 );

	register CStringListElem *pElem;
	int cBytes = 0;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext())
		cBytes += (wcslen(pElem->QueryValue()) * sizeof(WCHAR));

    // need to account for the ", " and NULL Termination

	cBytes += sizeof(WCHAR) + ((2*(m_cValues - 1)) * sizeof(WCHAR));

    if (!tempValues.Resize(cBytes)) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	WCHAR *szReturn = (WCHAR *)tempValues.QueryPtr();
	szReturn[0] = L'\0';
    WCHAR *szNext = szReturn;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext()) {
		szNext = strcpyExW(szNext, pElem->QueryValue());
		if (pElem->QueryNext() != NULL)
			szNext = strcpyExW(szNext, L", ");
    }

	BSTR bstrT;
	if ((bstrT = SysAllocString(szReturn)) == NULL) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}



/*===================================================================
CStringList::get_Item
===================================================================*/

STDMETHODIMP CStringList::get_Item(VARIANT varIndex, VARIANT *pvarOut)
	{
	long i;
	VariantInit(pvarOut);


	if (V_VT(&varIndex) == VT_ERROR) {
		return ConstructDefaultReturn(pvarOut);
    }

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing variants
	//   Loop through while we have a VT_BYREF until we get the real variant.
	//
	// and changed again...
	//
	// BUG 1609 the prior code was only checking for VT_I4 and jscript passed in a
	// VT_R8 and it failed so now we use the VariantChangeType call to solve the
	// problem

	VARIANT var;		
	VariantInit(&var);
	
	
	HRESULT hr = S_OK;
	if((hr = VariantChangeType(&var, &varIndex ,0,VT_I4)) != S_OK) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_EXPECTING_INT);
		return E_FAIL;
    }

	i = V_I4(&var);		
	VariantClear(&var);

	// END bug 1609

	if (i <= 0 || i > m_cValues) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
		return E_FAIL;
    }

	register CStringListElem *pElem = m_pBegin;
	while (--i > 0)
		pElem = pElem->QueryNext();

	BSTR bstrT;
	if ((bstrT = SysAllocString(pElem->QueryValue())) == NULL ) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}


/*===================================================================
CStringList::get__NewEnum
===================================================================*/

STDMETHODIMP CStringList::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = new CStrListIterator(this);
	if (*ppEnumReturn == NULL)
		{
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	return S_OK;
	}



/*------------------------------------------------------------------
 * C S t r L i s t I t e r a t o r
 */

/*===================================================================
CStrListIterator::CStrListIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CStrListIterator::CStrListIterator(CStringList *pStrings)
	{
	Assert (pStrings != NULL);

	m_pStringList = pStrings;
	m_pCurrent    = m_pStringList->m_pBegin;
	m_cRefs       = 1;

	m_pStringList->AddRef();
	}



/*===================================================================
CStrListIterator::CStrListIterator

Destructor
===================================================================*/

CStrListIterator::~CStrListIterator()
	{
	m_pStringList->Release();
	}



/*===================================================================
CStrListIterator::QueryInterface
CStrListIterator::AddRef
CStrListIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CStrListIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CStrListIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStrListIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CStrListIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CStrListIterator *pNewIterator = new CStrListIterator(m_pStringList);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CStrListIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
		BSTR bstrT = SysAllocString(m_pCurrent->QueryValue());
		if (bstrT == NULL)
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
		V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Reset()
	{
	m_pCurrent = m_pStringList->m_pBegin;
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\server.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.cpp

Owner: CGrant

This file contains the code for the implementation of the Server object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*
 *
 * C S e r v e r
 *
 */

/*===================================================================
CServer::CServer

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
					
Returns:
===================================================================*/
CServer::CServer(IUnknown *punkOuter)
    :
	m_fInited(FALSE),
	m_fDiagnostics(FALSE),
	m_pUnkFTM(NULL),
    m_pData(NULL)
	{
	CDispatch::Init(IID_IServer);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }
	
#ifdef DBG
	m_fDiagnostics = TRUE;
#endif // DBG
	}

/*===================================================================
CServer::~CServer

Destructor

Parameters:
					
Returns:
===================================================================*/
CServer::~CServer()
{
	Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count

    if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }

}

/*===================================================================
CServer::Init

Allocates m_pData.
Performs any intiailization of a CServer that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
	None
					
Returns:
	S_OK on success.
===================================================================*/

HRESULT CServer::Init()
	{
	HRESULT     hr = S_OK;
	
	if (m_fInited)
	    return S_OK; // already inited
	
	Assert(!m_pData);

	// Create the FTM
    if (m_pUnkFTM == NULL)
    {
        hr = CoCreateFreeThreadedMarshaler( (IUnknown*)this, &m_pUnkFTM );
    	
        if ( FAILED(hr) )
        {
            Assert( m_pUnkFTM == NULL );
            return (hr);
        }
    }

    Assert( m_pUnkFTM != NULL );


    m_pData = new CServerData;
    if (!m_pData)
        return E_OUTOFMEMORY;

	m_pData->m_pIReq = NULL;
	m_pData->m_pHitObj = NULL;
	
	m_pData->m_ISupportErrImp.Init(static_cast<IServer *>(this),
	            static_cast<IServer *>(this),
	            IID_IServer);
	
	m_fInited = TRUE;
	return hr;
	}
	
/*===================================================================
CServer::UnInit

Remove m_pData. Make tombstone (UnInited state).

Parameters:
					
Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CServer::UnInit()
	{
	if (!m_fInited)
	    return S_OK; // already uninited

	Assert(m_pData);
    delete m_pData;
    m_pData = NULL;

    // Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)
	CoDisconnectObject(static_cast<IServerImpl *>(this), 0);

    m_fInited = FALSE;
	return S_OK;
	}

/*===================================================================
CServer::ReInit

The only need for a re-init here is to update the CIsapiReqInfo
for this request, the CIsapiReqInfo is required to access the
MapPath Method. Ideally this method should be part of the Request
object

Parameters:
	CIsapiReqInfo *
	CHitObj *
					
Returns:
	S_OK on success.

===================================================================*/
HRESULT CServer::ReInit
(
CIsapiReqInfo * pIReq,
CHitObj *pHitObj
)
	{
	Assert(m_fInited);
	Assert(m_pData);
	
	m_pData->m_pIReq	   = pIReq;
	m_pData->m_pHitObj = pHitObj;
	return S_OK;
	}

/*===================================================================
CServer::MapPathInternal

Map virtual path BSTR into single char buffer
Used by MapPath(), Execute(), Transfer()

Parameters:
    dwContextId     for error messages
    wszVirtPath     path to translate
    szPhysPath      [out] translate into this buffer (MAX_PATH sized)
    szVirtPath      [out, optional] mb virtual path buffer (MAX_PATH sized)
					
Returns:
	S_OK on success.
===================================================================*/
HRESULT CServer::MapPathInternal
(
DWORD dwContextId,
WCHAR *wszVirtPath,
TCHAR *szPhysPath,
TCHAR *szVirtPath
)
    {
	// increment the pointer past leading white spaces
	wchar_t *wszLogicalPath = wszVirtPath;
	while (iswspace(*wszLogicalPath))
		++wszLogicalPath;

	unsigned cchLogicalPath = wcslen(wszLogicalPath);
	if (cchLogicalPath > MAX_PATH-1)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
		}

	else if (cchLogicalPath == 0)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_STR);
		return E_FAIL;
		}		

	// Is this a physical path?
	if (iswalpha(wszLogicalPath[0]) && wszLogicalPath[1] == L':')
		{		
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_PHY_STR);
		return E_FAIL;
		}

	// simple validation: look for invalid characters in string [*?<>,;:'"]
	// and multiple slash characters ie "//" or "\\"
	//
	BOOL fParentPath = FALSE;
	BOOL fEnableParentPaths = m_pData->m_pHitObj->QueryAppConfig()->fEnableParentPaths();
	BOOL fAnyBackslashes = FALSE;
	wchar_t *pwchT = wszLogicalPath;
	while (*pwchT != L'\0')
		{
		switch (*pwchT)
			{
			case L'*': case L':': case L'?': case L'<':
			case L'>': case L',': case L'"':
        		if (dwContextId)
		    		ExceptionId( IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR);
				return E_FAIL;

			case L'.': 				
				if (*++pwchT == L'.')
					{
					if (!fEnableParentPaths)
						{
                		if (dwContextId)
   				    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR3);
   						return E_FAIL;
   						}
   					else
   						{
   						fParentPath = TRUE;
   						++pwchT;
   						}
   					}
				break;
	
			case L'\\':
			    fAnyBackslashes = TRUE;
			case L'/':
				++pwchT;
				if (*pwchT == L'/' || *pwchT == L'\\')
					{
            		if (dwContextId)
   			    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR2);
   					return E_FAIL;
					}
				break;

			default:
				++pwchT;
			}
		}

	// whew! Error handling done!
	// Convert wszLogicalPath to multi-byte

    TCHAR szLogicalPath[MAX_PATH];
#if UNICODE
    wcscpy(szLogicalPath, wszLogicalPath);
#else
    HRESULT hr;
    CWCharToMBCS    convStr;

    if (hr = convStr.Init(wszLogicalPath)) {
        if ((hr == E_OUTOFMEMORY) && dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_OOM);
        return hr;
    }

    if (convStr.GetStringLen() > (MAX_PATH-1)) {
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
    }
    strcpy(szLogicalPath,convStr.GetString());
#endif

    // change all backslashes to forward slashes
	if (fAnyBackslashes)
	    {
	    TCHAR *pbBackslash = szLogicalPath;
	    while (pbBackslash = _tcschr(pbBackslash, _T('\\')))
	        *pbBackslash = _T('/');
	    }

	// is this a Relative path request. I.E. no leading slash
	// if so prepend the path_info string to szLogicalPath

	BOOL fPathAlreadyIsMapped = FALSE;		// Some cases map the path earlier
	if (szLogicalPath[0] != _T('/'))
		{
		if (_tcslen(m_pData->m_pIReq->QueryPszPathInfo()) >= MAX_PATH)
		{
		    if (dwContextId)
        		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		    return E_FAIL;
		}
		
		TCHAR szParentPath[MAX_PATH];
		_tcscpy(szParentPath, m_pData->m_pIReq->QueryPszPathInfo());

		szParentPath[MAX_PATH-1] = _T('\0');

		// Trim off the ASP file name from the PATH_INFO
		TCHAR *pchT = _tcsrchr(szParentPath, _T('/'));
		if (pchT != NULL) *pchT = '\0';

		// If there were parent paths, map the parent now, then append the relative path
		// the relative path to the parent path
		if (fParentPath)
			{
			Assert (fEnableParentPaths);			// Errors should have been flagged upstairs
			DWORD dwPathSize = sizeof(szParentPath);
			if (! m_pData->m_pIReq->MapUrlToPath(szParentPath, &dwPathSize))
				{
        		if (dwContextId)
		    		ExceptionId(IID_IServer,
			    				dwContextId,
				    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
				return E_FAIL;
				}

			fPathAlreadyIsMapped = TRUE;
			}

		// Resolve relative paths
		if (! DotPathToPath(szLogicalPath, szLogicalPath, szParentPath))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

    // return virtual path if requested
	if (szVirtPath)
	    _tcscpy(szVirtPath, szLogicalPath);

	// Map this to a physical file name (if required)
	if (!fPathAlreadyIsMapped)
		{
		DWORD dwPathSize = sizeof(szLogicalPath);
		if (! m_pData->m_pIReq->MapUrlToPath(szLogicalPath, &dwPathSize))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer,
		    				dwContextId,
			    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

	// remove any ending delimiters (unless it's the root directory. The root always starts with drive letter)
	TCHAR *pchT = CharPrev(szLogicalPath, szLogicalPath + _tcslen(szLogicalPath));
	if ((*pchT == _T('/') || *pchT == _T('\\')) && pchT[-1] != _T(':'))
		{
		*pchT = _T('\0');
		}

	// Replace forward slash with back slash
	for (pchT = szLogicalPath; *pchT != _T('\0'); ++pchT)
	    {
		if (*pchT == _T('/'))
			*pchT = _T('\\');
        }

    _tcscpy(szPhysPath, szLogicalPath);
	return S_OK;
    }

/*===================================================================
CServer::QueryInterface
CServer::AddRef
CServer::Release

IUnknown members for CServer object.
===================================================================*/
STDMETHODIMP CServer::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	*ppv = NULL;

	/*
	 * The only calls for IUnknown are either in a nonaggregated
	 * case or when created in an aggregation, so in either case
	 * always return our IUnknown for IID_IUnknown.
	 */

	// BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
	// storing intrinsic objects in the application and session object

	if (IID_IUnknown == riid ||
		IID_IDispatch == riid ||
		IID_IServer == riid ||
		IID_IDenaliIntrinsic == riid)
		*ppv = static_cast<IServer *>(this);

	//Indicate that we support error information
	if (IID_ISupportErrorInfo == riid)
	    {
	    if (m_pData)
    		*ppv = & (m_pData->m_ISupportErrImp);
		}

    if (IID_IMarshal == riid)
        {
            Assert( m_pUnkFTM != NULL );

            if ( m_pUnkFTM == NULL )
            {
                return E_UNEXPECTED;
            }

            return m_pUnkFTM->QueryInterface( riid, ppv );

        }

	//AddRef any interface we'll return.
	if (NULL != *ppv)
		{
		((LPUNKNOWN)*ppv)->AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CServer::AddRef()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->AddRef();
	
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CServer::Release()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->Release();
	
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
	if (cRefs)
		return cRefs;

	delete this;
	return 0;
	}

/*===================================================================
CServer::GetIDsOfNames

Special-case implementation for CreateObject, Execute, Transfer

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CServer::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidCreateObject = 0x60020002;
    const DISPID dispidExecute      = 0x60020007;
    const DISPID dispidTransfer     = 0x60020008;

    if (cNames == 1)
        {
        switch (rgszNames[0][0])
            {
        case L'C':
        case L'c':
            if (wcsicmp(rgszNames[0]+1, L"reateobject") == 0)
                {
                *rgDispID = dispidCreateObject;
                return S_OK;
                }
            break;

        case L'E':
        case L'e':
            if (wcsicmp(rgszNames[0]+1, L"xecute") == 0)
                {
                *rgDispID = dispidExecute;
                return S_OK;
                }
            break;

        case L'T':
        case L't':
            if (wcsicmp(rgszNames[0]+1, L"ransfer") == 0)
                {
                *rgDispID = dispidTransfer;
                return S_OK;
                }
            break;
            }
        }

    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CServer::CheckForTombstone

Tombstone stub for IServer methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CServer::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

	ExceptionId
	    (
	    IID_IServer,
	    IDE_SERVER,
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CServer::CreateObject

Parameters: BSTR containing ProgID
			Variant to fillin with IUknown pointer

Returns: S_OK if successful E_FAIL otherwise

Side effects:
	Creates an instance of an ole automation object
===================================================================*/
STDMETHODIMP CServer::CreateObject(BSTR bstrProgID, IDispatch **ppDispObj)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrProgID == NULL)
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    Assert(m_pData->m_pHitObj);

	*ppDispObj = NULL;

    HRESULT hr;
    CLSID clsid;

	if (Glob(fEnableTypelibCache))
	    {
	    // Use typelib cache to create the component
	
        hr = g_TypelibCache.CreateComponent
                (
                bstrProgID,
                m_pData->m_pHitObj,
                ppDispObj,
                &clsid
                );

    	if (FAILED(hr) && clsid == CLSID_NULL)
            {
            // bad prog id or something
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
            }
	    }
	else
	    {
	    // Don't use typelib cache
	
    	hr = CLSIDFromProgID((LPCOLESTR)bstrProgID, &clsid);
    	if (FAILED(hr))
    	    {
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
    	    }
    	
        hr = m_pData->m_pHitObj->CreateComponent(clsid, ppDispObj);
        }

    if (SUCCEEDED(hr))
        return S_OK;

    // Check if a custom error was already posted
    IErrorInfo *pErrInfo = NULL;
    if (GetErrorInfo(0, &pErrInfo) == S_OK && pErrInfo)
        {
		SetErrorInfo(0, pErrInfo);
        pErrInfo->Release();
        }
    // Standard errors
	else if (hr == E_ACCESSDENIED)
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_DENIED);
	else
	    {
	    if (hr == REGDB_E_CLASSNOTREG)
    	    {
    		BOOL fInProc;
            if (SUCCEEDED(CompModelFromCLSID(clsid, NULL, &fInProc)) && !fInProc)
            	{
        		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_NOTINPROC);
            	}
    	    }
    	else
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	}
    return hr;
    }
	
/*===================================================================
CServer::MapPath

Return the physical path translated from a logical path

Parameters:
	BSTR		bstrLogicalPath
	BSTR FAR *	pbstrPhysicalPath

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::MapPath(BSTR bstrLogicalPath, BSTR FAR * pbstrPhysicalPath)
	{	
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	// Bug 1361: error if no CIsapiReqInfo (presumably called during
	//           Application_OnEnd or Session_OnEnd)
	if (m_pData->m_pIReq == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	AssertValid();
	Assert (pbstrPhysicalPath != NULL);
	*pbstrPhysicalPath = NULL;

    // use MapPathInternal() to do the mapping
	TCHAR szLogicalPath[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER_MAPPATH, bstrLogicalPath, szLogicalPath);
    if (FAILED(hr))
        return hr;

#if UNICODE
    *pbstrPhysicalPath = SysAllocString(szLogicalPath);
    if (*pbstrPhysicalPath == NULL) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
    }
#else
	// Convert the path to wide character
	if (FAILED(SysAllocStringFromSz(szLogicalPath, 0, pbstrPhysicalPath, CP_ACP))) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
		}
#endif
	return S_OK;
	}

/*===================================================================
CServer::HTMLEncode

Encodes a string to HTML standards

Parameters:
	BSTR		bstrIn			value: string to be encoded
	BSTR FAR *	pbstrEncoded	value: pointer to HTML encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::HTMLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
	UINT 	        uCodePage			= m_pData->m_pHitObj->GetCodePage();
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempHTML, 2048 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, uCodePage))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }

    pszstrIn = convIn.GetString();
				
	nstrLen = HTMLEncodeLen(pszstrIn, uCodePage, bstrIn);
	
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempHTML.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char*)tempHTML.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::HTMLEncode( pszEncodedstr, pszstrIn, uCodePage, bstrIn);
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded, uCodePage)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
			
	return hr;
	}


/*===================================================================
CServer::URLEncode

Encodes a query string to URL standards

Parameters:
	BSTR		bstrIn			value: string to be URL encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempURL, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }
	
    pszstrIn = convIn.GetString();
				
	nstrLen = URLEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempURL.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempURL.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::URLPathEncode

Encodes the path portion of a URL or a full URL.  All characters
up to the first '?' are encoded with the following rules:
	o Charcters that are needed to parse the URL are left alone
	o RFC 1630 safe characters are left alone
	o Non-foreign alphanumberic characters are left alone
	o Anything else is escape encoded
Everything after the '?' is not encoded.

Parameters:
	BSTR		bstrIn			value: string to be URL path encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL path encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLPathEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempPath, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }

    pszstrIn = convIn.GetString();
				
	nstrLen = URLPathEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempPath.Resize(nstrLen+2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempPath.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLPathEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::get_ScriptTimeout

Will return the script timeout interval (in seconds)

Parameters:
	long *plTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::get_ScriptTimeout( long * plTimeoutSeconds )
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return(E_FAIL);
		}
	*plTimeoutSeconds = m_pData->m_pHitObj->GetScriptTimeout();
	return S_OK;
}

/*===================================================================
CServer::put_ScriptTimeout

Allows the user to set the timeout interval for a script (in seconds)

Parameters:
	long lTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::put_ScriptTimeout( long lTimeoutSeconds )
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if ( lTimeoutSeconds < 0 )
    	{
		ExceptionId( IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_TIMEOUT );
		return E_FAIL;
	    }
	else
    	{
		if (m_pData->m_pHitObj == NULL)
			{
			ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
			return(E_FAIL);
			}
		m_pData->m_pHitObj->SetScriptTimeout(lTimeoutSeconds);
		return S_OK;
	    }
    }

/*===================================================================
CServer::Execute

Execute an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Execute(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_EXECUTE_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(FALSE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;

		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_EXECUTE_CANTLOAD : IDE_SERVER_EXECUTE_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
CServer::Transfer

Transfer execution an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Transfer(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_TRANSFER_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;

		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_TRANSFER_CANTLOAD : IDE_SERVER_TRANSFER_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
CServer::GetLastError

Get ASPError object for the last error

Parameters:
	ppASPErrorObject    [out] the error object

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::GetLastError(IASPError **ppASPErrorObject)
    {
    *ppASPErrorObject = NULL;

	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

    HRESULT hr = m_pData->m_pHitObj->GetASPError(ppASPErrorObject);

    if (FAILED(hr))
        {
		ExceptionId(IID_IServer, IDE_SERVER, IDE_UNEXPECTED);
		return hr;
        }

    return S_OK;
    }

#ifdef DBG
/*===================================================================
CServer::AssertValid

Test to make sure that the CServer object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
void CServer::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pData);
	Assert(m_pData->m_pIReq);
	}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\sessmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Manager

File: Sessmgr.h

Owner: PramodD

This is the session manager header file.
===================================================================*/
#ifndef SESSMGR_H
#define SESSMGR_H

#include "debug.h"
#include "idhash.h"
#include "idgener.h"
#include "compcol.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "viperint.h"
#include "memcls.h"

/*===================================================================
  #defines
===================================================================*/

// Min/Max session timeout in minutes
#define SESSION_TIMEOUT_MIN		        1		// 1 minute
#define SESSION_TIMEOUT_MAX		        1440	// 1 day

// Master hash table sizes
#define SESSION_MASTERHASH_SIZE1_MAX    499
#define SESSION_MASTERHASH_SIZE2_MAX    31
#define SESSION_MASTERHASH_SIZE3_MAX    13

// Timeout bucket hash tables sizes
#define SESSION_TIMEOUTHASH_SIZE1_MAX   97
#define SESSION_TIMEOUTHASH_SIZE2_MAX   29
#define SESSION_TIMEOUTHASH_SIZE3_MAX   11

// Min/Max # of timeout buckets (hash tables)
#define SESSION_TIMEOUTBUCKETS_MIN      10
#define SESSION_TIMEOUTBUCKETS_MAX      45

// max value of GetTickCount()
#define	DWT_MAX 0xFFFFFFFF

// session killer workitem default wait
#define MSEC_ONE_MINUTE     60000   // 1 min

#include "asptlb.h"

/*===================================================================
  Forward declarations
===================================================================*/

class CAppln;
class CHitObj;
class CSession;

/*===================================================================
  C S e s s i o n V a r i a n t s
===================================================================*/
class CSessionVariants : public IVariantDictionary
	{
private:
    ULONG               m_cRefs;            // ref count
	CSession *			m_pSession;			// pointer to parent object
	CompType            m_ctColType;        // collection type
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName, 
	                              BOOL fVerify = FALSE);

public:
	CSessionVariants();
	~CSessionVariants();

	HRESULT Init(CSession *pSession, CompType ctColType);
	HRESULT UnInit();

	// The Big Three

	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// OLE Automation Interface

	STDMETHODIMP get_Item(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP put_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP putref_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP get_Key(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
  C  S e s s i o n  I D
===================================================================*/
struct CSessionId
    {
	DWORD m_dwId;	// Session Id
	DWORD m_dwR1;	// Session Id random element 1
	DWORD m_dwR2;	// Session Id random element 2

    CSessionId(DWORD dwId = INVALID_ID, DWORD dwR1 = 0, DWORD dwR2 = 0);
    };

inline CSessionId::CSessionId(DWORD dwId, DWORD dwR1, DWORD dwR2)
    {
    m_dwId = dwId;
    m_dwR1 = dwR1;
    m_dwR2 = dwR2;
    }

/*===================================================================
  C  S e s s i o n
===================================================================*/
class CSession : public ISessionObjectImpl
    {

friend class CSessionMgr;
friend class CSessionVariants;

private:

    //========= Misc flags
    
	DWORD m_fInited : 1;		  // Are we initialized?
	DWORD m_fLightWeight : 1;     // Is in lightweight form?
	DWORD m_fOnStartFailed : 1;	  // Session_OnStart failed?
	DWORD m_fOnStartInvoked : 1;  // Session_OnStart invoked?
	DWORD m_fOnEndPresent : 1;    // Need to invoke Session_OnEnd ?
	DWORD m_fTimedOut : 1;        // Session timed out?
	DWORD m_fStateAcquired : 1;   // Any property set (!m_fCanDelete)?
	DWORD m_fCustomTimeout : 1;   // Timeout different from standard?
	DWORD m_fAbandoned : 1;       // Session abandoned?
	DWORD m_fTombstone : 1;       // ASP is done with the session?
	DWORD m_fInTOBucket : 1;      // Session in a timeout bucket?
	DWORD m_fSessCompCol : 1;     // Component collection present?
	DWORD m_fSecureSession : 1;   //  Is the session used over a secure line?
    DWORD m_fCodePageSet : 1;     // CodePage explicitly set?
    DWORD m_fLCIDSet     : 1;     // LCID explicitly set?

	//========= Pointers to related objects
	
	CAppln  *m_pAppln;    // Session's Application
	CHitObj *m_pHitObj;   // Session's current HitObj
	
	//========= Session's dictionaries for presenting component collection
	
	CSessionVariants *m_pTaggedObjects;
	CSessionVariants *m_pProperties;

    //========= Session data

    CSessionId m_Id;        // Session ID + 2 random keys
    DWORD m_dwExternId;     // Session ID to be given out (Session.ID)

    DWORD m_cRefs;          // Ref count
	DWORD m_cRequests;      // Requests count

	// Timeout when current time (in minutes) reaches this
	// The timeout bucket is current_time mod #_of_buckets
	DWORD m_dwmTimeoutTime;
	
	long  m_lCodePage;	    // Code page for this session
	LCID  m_lcid;			// LCID for this session
	long  m_nTimeout;       // Current time value in minutes

	// to make session elem in the timeout bucket
	CObjectListElem m_TOBucketElem;
	
#ifndef PERF_DISABLE
    DWORD m_dwtInitTimestamp; // Timestamp of session creation for PERFMON
#endif

	//========= Session's Component Collection

	// to avoid the memory fragmentation component collection is
	// aggregated here. its validity is indicated by m_fSessCompCol flag
	CComponentCollection m_SessCompCol;  // Session scope objects
	
	//========= Viper Activity of this Session
	
	CViperActivity m_Activity;

	//========= Intrinsics for this Session
	
	CRequest    m_Request;
	CResponse   m_Response;
	CServer     m_Server;

	//========= SupportErrorInfo
	
	// Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;

	// FTM Support
	IUnknown    *m_pUnkFTM;

public:	
	CSession();
	~CSession();

	HRESULT Init(CAppln *pAppln, const CSessionId &Id);

    // Convert to tombstone state
    HRESULT UnInit();

	// Convert to 'light-weight' state if possible
	HRESULT MakeLightWeight();

	// Create/Remove Session's component collection
	HRESULT CreateComponentCollection();
	HRESULT RemoveComponentCollection();

    // Check if the session should be deleted
    BOOL FShouldBeDeletedNow(BOOL fAtEndOfRequest);

	// Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();

	// ISessionObject functions
	STDMETHODIMP get_SessionID(BSTR *pbstrRet);
	STDMETHODIMP get_Timeout(long *plVar);
	STDMETHODIMP put_Timeout(long lVar);
	STDMETHODIMP get_CodePage(long *plVar);
	STDMETHODIMP put_CodePage(long lVar);
	STDMETHODIMP get_Value(BSTR bstr, VARIANT FAR * pvar);
	STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP Abandon();
	STDMETHODIMP get_LCID(long *plVar);
	STDMETHODIMP put_LCID(long lVar);
	STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);
	STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);

	// inline methods to access member properties
	CAppln                *PAppln();
	CHitObj               *PHitObj();
	CComponentCollection  *PCompCol();
	CViperActivity        *PActivity();
	CRequest              *PRequest();
	CResponse             *PResponse();
	CServer               *PServer();
	BOOL                   FCustomTimeout();
	BOOL                   FAbandoned();
	DWORD                  GetId();
	BOOL                   FInTOBucket();
	LCID				   GetLCID();
    long                   GetCodePage();
	DWORD                  GetTimeoutTime();
	BOOL                   FSecureSession(); 


    // inline methods to set member properties
	void    SetHitObj(CHitObj *pHitObj);
	void    SetOnStartFailedFlag();
	void    SetOnStartInvokedFlag();
	void    SetOnEndPresentFlag();
	HRESULT SetLCID(LCID lcid);
	
    // Misc inline methods
	DWORD   IncrementRequestsCount();
	DWORD   DecrementRequestsCount();
    DWORD   GetRequestsCount();
    BOOL    FCanDeleteWithoutExec();
    BOOL    FHasObjects();
	BOOL    FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2);
    void    AssignNewId(const CSessionId &Id);
    void    SetSecureSession(BOOL fSecure); 
    BOOL    FCodePageSet();
    BOOL    FLCIDSet();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  S e s s i o n   inlines
===================================================================*/

inline CAppln *CSession::PAppln()
    {
    Assert(m_fInited);
    return m_pAppln;
    }
    
inline CHitObj *CSession::PHitObj()
    {
    Assert(m_fInited);
    return m_pHitObj;
    }
    
inline CComponentCollection  *CSession::PCompCol()
    {
    Assert(m_fInited);
    return (m_fSessCompCol ? &m_SessCompCol : NULL);
    }
    
inline CViperActivity *CSession::PActivity()
    {
    Assert(m_fInited);
    return &m_Activity;
    }

inline CRequest *CSession::PRequest()
    {
    Assert(m_fInited);
    return &m_Request;
    }
    
inline CResponse *CSession::PResponse()
    {
    Assert(m_fInited);
    return &m_Response;
    }
    
inline CServer *CSession::PServer()
    {
    Assert(m_fInited);
    return &m_Server;
    }

inline BOOL CSession::FCustomTimeout()
    {
    Assert(m_fInited);
    return m_fCustomTimeout;
    }
    
inline BOOL CSession::FAbandoned()
    {
    Assert(m_fInited);
    return m_fAbandoned;
    }
    
inline DWORD CSession::GetId()
    {
    Assert(m_fInited);
    return m_Id.m_dwId;
    }

inline BOOL CSession::FInTOBucket()
    {
    Assert(m_fInited);
    return m_fInTOBucket;
    }

inline LCID CSession::GetLCID()
    {
    Assert(m_fInited);
    return (UINT)m_lcid;
    }

inline long CSession::GetCodePage()
{
    Assert(m_fInited);
    return m_lCodePage == 0 ? GetACP() : m_lCodePage;
}

inline BOOL CSession::FCodePageSet()
{
    Assert(m_fInited);
    return (m_fCodePageSet);
}

inline BOOL CSession::FLCIDSet()
{
    Assert(m_fInited);
    return (m_fLCIDSet);
}

inline DWORD CSession::GetTimeoutTime()
    {
    Assert(m_fInited);
    return m_dwmTimeoutTime;
    }


inline BOOL CSession::FSecureSession()
    {
    Assert(m_fInited);
    return m_fSecureSession;
    }

inline void CSession::SetHitObj(CHitObj *pHitObj)
    {
    Assert(m_fInited);
    Assert(pHitObj ? (m_pHitObj == NULL) : (m_pHitObj != NULL));
    m_pHitObj = pHitObj;
    }
    
inline void CSession::SetOnStartFailedFlag()
    {
    Assert(m_fInited);
    m_fOnStartFailed = TRUE;
    }
    
inline void CSession::SetOnStartInvokedFlag()
    {
    Assert(m_fInited);
    m_fOnStartInvoked = TRUE;
    }

inline void CSession::SetOnEndPresentFlag()
    {
    Assert(m_fInited);
    m_fOnEndPresent = TRUE;
    }
    
inline HRESULT CSession::SetLCID(LCID lcid)
    {
    Assert(m_fInited);
	if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
	    {
	    m_lcid = lcid; 
	    return S_OK;
	    }
	 else
	    {
	    return E_FAIL;
	    }
    }

inline DWORD CSession::IncrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::DecrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::GetRequestsCount()
    {
    Assert(m_fInited);
    return m_cRequests;
    }
    
inline BOOL CSession::FCanDeleteWithoutExec()
    {
    // Return TRUE to delete CSession right away or FALSE to
    // post Viper request to execute Session_OnEnd()
	return (m_fOnStartFailed || !m_fOnEndPresent);
	}

inline BOOL CSession::FHasObjects()
    {
    return m_fSessCompCol && m_SessCompCol.FHasObjects();
    }
    
inline BOOL CSession::FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2)
    {
    Assert(m_fInited);
    return (m_Id.m_dwR1 == dwR1 && m_Id.m_dwR2 == dwR2);
    }

inline void CSession::AssignNewId(const CSessionId &Id)
    {
    Assert(m_fInited);
	m_Id = Id;
    }


inline void CSession::SetSecureSession(BOOL fSecure)
    {
    Assert(m_fInited);
    m_fSecureSession = fSecure;
    }

/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

class CSessionMgr
    {
private:
    // Flags
	DWORD m_fInited : 1;	            // Are we initialized?

    // Application
	CAppln *m_pAppln;

	// Sessions master hash table
	CIdHashTableWithLock m_htidMaster;

	// Number of posted Session Cleanup requests
	DWORD m_cSessionCleanupRequests;

	// Timeout buckets
	DWORD m_cTimeoutBuckets;
	CObjectListWithLock *m_rgolTOBuckets;

    // Session killer scheduler workitem
    DWORD m_idSessionKiller;    // workitem id

    DWORD m_dwmCurrentTime; // current time in minutes since start
    DWORD m_dwtNextSessionKillerTime;  // next session killer time

public:
	CSessionMgr();
	~CSessionMgr();

    // Init/Unit
	HRESULT	Init(CAppln *pAppln);
	HRESULT	UnInit();

    // Add/remove session killer workitem
    HRESULT ScheduleSessionKiller();
    HRESULT UnScheduleSessionKiller();
    BOOL    FIsSessionKillerScheduled();

    // Lock/Unlock master hash table
	HRESULT LockMaster();
    HRESULT UnLockMaster();
    
    // Lock/Unlock a timeout bucket hash table
	HRESULT LockTOBucket(DWORD iBucket);
    HRESULT UnLockTOBucket(DWORD iBucket);

    // Get current time in minute ticks
    DWORD GetCurrentTime();
    // Set the time when the session should be gone
    HRESULT UpdateSessionTimeoutTime(CSession *pSession);
    // Calculate which timeout bucket the session's in
    DWORD GetSessionTOBucket(CSession *pSession);

    // Generate new ID and cookie
    HRESULT GenerateIdAndCookie(CSessionId *pId, char *pszCookie);

    // Create new session object
    HRESULT NewSession(const CSessionId &Id, CSession **ppSession);

    // Reassign session's Id (reinsert session into master hash)
    HRESULT ChangeSessionId(CSession *pSession, const CSessionId &Id);
   
    // Master hash table manipulations
    HRESULT AddToMasterHash(CSession *pSession);
    HRESULT RemoveFromMasterHash(CSession *pSession);
    HRESULT FindInMasterHash(const CSessionId &Id, CSession **ppSession);

    // Insert/remove session into the timeout bucket hash table
    HRESULT AddSessionToTOBucket(CSession *pSession);
    HRESULT RemoveSessionFromTOBucket(CSession *pSession, BOOL fLock = TRUE);

    // Delete session now or queue for deletion
    HRESULT DeleteSession(CSession *pSession, BOOL fInSessActivity = FALSE);

    // Delete expired sessions from a given bucket
    HRESULT DeleteExpiredSessions(DWORD iBucket);

    // Delete all sessions (application shut-down code)
    HRESULT DeleteAllSessions(BOOL fForce);
    // Static iterator call back to delete all sessions
    static IteratorCallbackCode DeleteAllSessionsCB(void *, void *, void *);

    // The Session Killer 
    static VOID WINAPI SessionKillerSchedulerCallback(VOID *pv);

    // Incr/Decr/Get number of posted Session Cleanup requests
    void  IncrementSessionCleanupRequestCount();
    void  DecrementSessionCleanupRequestCount();
    DWORD GetNumSessionCleanupRequests();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

inline BOOL CSessionMgr::FIsSessionKillerScheduled()
    {
    return (m_idSessionKiller != 0);
    }
    
inline HRESULT CSessionMgr::LockMaster()
    {
    m_htidMaster.Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockMaster()
    {
    m_htidMaster.UnLock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::LockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].UnLock();
    return S_OK;
    }

inline DWORD CSessionMgr::GetCurrentTime()
    {
    return m_dwmCurrentTime;
    }

inline HRESULT CSessionMgr::UpdateSessionTimeoutTime(CSession *pSession)
    {
    Assert(pSession);

    // remember when the session times out
    pSession->m_dwmTimeoutTime =
        m_dwmCurrentTime + pSession->m_nTimeout + 1;

    return S_OK;    
    }

inline DWORD CSessionMgr::GetSessionTOBucket(CSession *pSession)
    {
    Assert(pSession->m_fInited);
    return (pSession->m_dwmTimeoutTime % m_cTimeoutBuckets);
    }

inline HRESULT CSessionMgr::AddToMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
 	return m_htidMaster.AddObject(pSession->GetId(), pSession);
    }
    
inline HRESULT CSessionMgr::RemoveFromMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
	return m_htidMaster.RemoveObject(pSession->GetId());
    }

inline void CSessionMgr::IncrementSessionCleanupRequestCount()
    {
    InterlockedIncrement((LPLONG)&m_cSessionCleanupRequests);
    }
    
inline void CSessionMgr::DecrementSessionCleanupRequestCount()
    {
    InterlockedDecrement((LPLONG)&m_cSessionCleanupRequests);
    }

inline DWORD CSessionMgr::GetNumSessionCleanupRequests()
    {
    return m_cSessionCleanupRequests;
    }

/*===================================================================
  G l o b a l s
===================================================================*/

// There are multiple session managers (one per application)
// The following variables are 1 per ASP.DLL

extern unsigned long g_nSessions;
extern CIdGenerator  g_SessionIdGenerator;
extern CIdGenerator  g_ExposedSessionIdGenerator;     

#endif // SESSMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\sessmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Object Manager

File: Sessmgr.cpp

Owner: PramodD

This is the Session Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idgener.h"
#include "perfdata.h"
#include "randgen.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
  G l o b a l s
===================================================================*/

PTRACE_LOG CSession::gm_pTraceLog = NULL;
unsigned long g_nSessions = 0;
CIdGenerator  g_SessionIdGenerator;
CIdGenerator  g_ExposedSessionIdGenerator;
LONG    g_nSessionObjectsActive = 0;

// On app restart post session cleanup requests so many at a time
#define SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX 500

/*===================================================================
   C S e s s i o n V a r i a n t s
===================================================================*/

/*===================================================================
CSessionVariants::CSessionVariants

Constructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::CSessionVariants()
	:
	m_cRefs(1),
	m_pSession(NULL),
	m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
	{
	CDispatch::Init(IID_IVariantDictionary);
	}

/*===================================================================
CSessionVariants::~CSessionVariants

Destructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::~CSessionVariants()
	{
	Assert(!m_pSession);
	}
	
/*===================================================================
CSessionVariants::Init

Initialize object

Parameters:
	pSession    Session
	ctColType   Type of variables to expose in the collection
	                e.g. Tagged objects or Properties

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::Init
(
CSession *pSession,
CompType ctColType
)
	{
	Assert(pSession);
	pSession->AddRef();

	Assert(!m_pSession);

	m_pSession  = pSession;
	m_ctColType = ctColType;
	return S_OK;
	}

/*===================================================================
CSessionVariants::UnInit

UnInitialize object

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::UnInit()
	{
	if (m_pSession)
	    {
	    m_pSession->Release();
	    m_pSession = NULL;
	    }
	return S_OK;
	}
	
/*===================================================================
CSessionVariants::QueryInterface
CSessionVariants::AddRef
CSessionVariants::Release

IUnknown members for CSessionVariables object.
===================================================================*/
STDMETHODIMP CSessionVariants::QueryInterface
(
REFIID iid,
void **ppvObj
)
	{
	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IVariantDictionary)
	    {
	    AddRef();
		*ppvObj = this;
		return S_OK;
        }
	else if (iid == IID_ISupportErrorInfo)
	    {
	    m_ISupportErrImp.AddRef();
		*ppvObj = &m_ISupportErrImp;
		return S_OK;
        }

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CSessionVariants::AddRef()
	{
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CSessionVariants::Release()
	{
	LONG cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}

/*===================================================================
CSessionVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
	vKey		VARIANT
	ppwszName   [out] allocated name
	fVerify     flag - check existance if named

	
Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {

    HRESULT hr = S_OK;
    *ppwszName = NULL;

	VARIANT *pvarKey = &vKey;
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_SESSION)))
            {
		    ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_EXPECTING_STR);
        	VariantClear(&varKeyCopy);
		    return E_FAIL;
		    }
		pvarKey = &varKeyCopy;
		}

    LPWSTR pwszName = NULL;

	switch (V_VT(pvarKey))
		{
		case VT_BSTR:
		    {
		    pwszName = V_BSTR(pvarKey);

		    if (fVerify && pwszName)
		        {
		        CComponentObject *pObj = NULL;

                Assert(m_pSession);
                Assert(m_pSession->PCompCol());

		        if (m_ctColType == ctTagged)
                    m_pSession->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pSession->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found
                }
		    break;
		    }

   		case VT_I1:  case VT_I2:               case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
		case VT_R4:  case VT_R8:
			// Coerce all integral types to VT_I4
			if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
				return E_FAIL;

			// fallthru to VT_I4

		case VT_I4:
		    {
		    int i;

			// Look up the object by index
			i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pSession);
                Assert(m_pSession->PCompCol());

                hr = m_pSession->PCompCol()->GetNameByIndex
                    (
                    m_ctColType,
                    i,
                    &pwszName
                    );

				if (FAILED(hr))
					return DISP_E_BADINDEX;
                }
			else
				{
				ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_BAD_ARRAY_INDEX);
				return E_FAIL;
				}
            break;
            }		
		}


    if (pwszName)
    {
	    *ppwszName = StringDupW(pwszName);
	    if (*ppwszName == NULL)
	        hr = E_OUTOFMEMORY;
    }
	VariantClear(&varKeyCopy);	

  	return hr;
    }

/*===================================================================
CSessionVariants::get_Item

Function called from DispInvoke to get values from the
SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of
	                        - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Item
(
VARIANT varKey,
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

    // Initialize return value
	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;  // return empty variant
	CHitObj *pHitObj = m_pSession->PHitObj();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK; // bogus index - no error

    // Find object by name
	CComponentObject *pObj = NULL;

	if (m_ctColType == ctTagged)
   		{
        pHitObj->GetComponent(csSession, pwszName, CbWStr(pwszName), &pObj);
		if (pObj && (pObj->GetType() != ctTagged))
    		pObj = NULL;
    	}
	else
	    {
        pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
		}

    free(pwszName);

    if (!pObj)
        return S_OK;

    // return the variant
    return pObj->GetVariant(pVar);
	}

/*===================================================================
CSessionVariants::put_Item

IVariantsDictionary implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::put_Item
(
VARIANT varKey,
VARIANT Var
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Resolve the variant
	VARIANT varResolved;
	HRESULT hr = VariantResolveDispatch
	    (
	    &varResolved,
	    &Var,
        IID_ISessionObject,
        IDE_SESSION
        );
	if (FAILED(hr))
		return hr;		// exception already raised

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession,
    	pwszName,
    	&varResolved
    	);

    free(pwszName);
    VariantClear(&varResolved);
	return hr;
    }

/*===================================================================
CSessionVariants::putref_Item

IVariantsDictionary implementation.

Implement property put be reference.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::putref_Item
(
VARIANT varKey,
VARIANT Var
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession,
    	pwszName,
    	&Var
    	);

    free(pwszName);
	return hr;
    }

/*===================================================================
CSessionVariants::get_Key

Function called from DispInvoke to get Keys from the SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);
    if (!pwszName)
        return S_OK;  // no error if bogus index

    // Return BSTr
   	BSTR bstrT = SysAllocString(pwszName);
   	free(pwszName);
   	
	if (!bstrT)
		return E_OUTOFMEMORY;
		
    V_VT(pVar) = VT_BSTR;
	V_BSTR(pVar) = bstrT;
	return S_OK;
	}

/*===================================================================
CSessionVariants::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CSessionVariants::get_Count
(
int *pcValues
)
	{
	*pcValues = 0;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_pSession->PCompCol())
	    {
    	if (m_ctColType == ctTagged)
    		*pcValues = m_pSession->PCompCol()->GetTaggedObjectCount();
    	else
    		*pcValues = m_pSession->PCompCol()->GetPropertyCount();
   		}
		
	return S_OK;
	}

/*===================================================================
CSessionVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CSessionVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
	{
	*ppEnumReturn = NULL;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
	
	CVariantsIterator *pIterator = new CVariantsIterator
	    (
	    m_pSession,
	    m_ctColType
	    );
	if (pIterator == NULL)
		{
		ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CSessionVariants::Remove

Remove item from the collection

Parameters:
	varKey		VARIANT [in]

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::Remove
(
VARIANT varKey
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK;

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        pCompCol->RemoveProperty(pwszName);

    free(pwszName);
	return S_OK;
	}

/*===================================================================
CSessionVariants::RemoveAll

Remove all items from the collection

Parameters:

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::RemoveAll()
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }

	return S_OK;
	}

/*===================================================================
  C  S e s s i o n
===================================================================*/

/*===================================================================
CSession::CSession

Constructor

Parameters:

Returns:
===================================================================*/
CSession::CSession()
    :
    m_fInited(FALSE),
    m_fLightWeight(FALSE),
    m_fOnStartFailed(FALSE),
    m_fOnStartInvoked(FALSE),
    m_fOnEndPresent(FALSE),
    m_fTimedOut(FALSE),
    m_fStateAcquired(FALSE),
    m_fCustomTimeout(FALSE),
    m_fAbandoned(FALSE),
    m_fTombstone(FALSE),
    m_fInTOBucket(FALSE),
	m_fSessCompCol(FALSE),
    m_fCodePageSet(FALSE),
    m_fLCIDSet(FALSE),
    m_Request(static_cast<ISessionObject *>(this)),
	m_Response(static_cast<ISessionObject *>(this)),
	m_Server(static_cast<ISessionObject *>(this)),
	m_pAppln(NULL),
	m_pHitObj(NULL),
	m_pTaggedObjects(NULL),
	m_pUnkFTM(NULL),
	m_pProperties(NULL),
	m_Id(INVALID_ID, 0, 0),
	m_dwExternId(INVALID_ID),
    m_cRefs(1),
	m_cRequests(0),
    m_dwmTimeoutTime(0),
	m_nTimeout(0),
#ifndef PERF_DISABLE
    m_dwtInitTimestamp(0),
#endif
	m_lCodePage(0),
	m_lcid(LOCALE_SYSTEM_DEFAULT),
	m_fSecureSession(FALSE)
    {
    m_lCodePage = GetACP();
	m_ISuppErrImp.Init(static_cast<ISessionObject *>(this),
	                static_cast<ISessionObject *>(this),
	                IID_ISessionObject);
	CDispatch::Init(IID_ISessionObject);

    InterlockedIncrement(&g_nSessionObjectsActive);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }

/*===================================================================
CSession::~CSession

Destructor

Parameters:

Returns:
===================================================================*/
CSession::~CSession()
{
    Assert(m_fTombstone); // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }
}

/*===================================================================
CSession::Init

Initialize CSession object

Parameters:
    pAppln          session's application to remember
    Id              session id

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::Init
(
CAppln *pAppln,
const CSessionId &Id
)
	{
	HRESULT     hr  =   S_OK;
	// Update global sessions counter
    InterlockedIncrement((LPLONG)&g_nSessions);

#ifndef PERF_DISABLE
    g_PerfData.Incr_SESSIONCURRENT();
    g_PerfData.Incr_SESSIONSTOTAL();
    m_dwtInitTimestamp = GetTickCount();
#endif

    // Create the FTM
    if (m_pUnkFTM == NULL)
    {
        hr = CoCreateFreeThreadedMarshaler( (IUnknown*)this, &m_pUnkFTM );
        if ( FAILED(hr) )
        {
            Assert( m_pUnkFTM == NULL );
            return (hr);
        }
    }
    Assert( m_pUnkFTM != NULL );

	// Setup the object

	m_pAppln = pAppln;
    m_Id     = Id;
    m_dwExternId = g_ExposedSessionIdGenerator.NewId();

    // Update application's session count

	m_pAppln->IncrementSessionCount();

	// default to system's ansi code page
	m_lCodePage = pAppln->QueryAppConfig()->uCodePage();
	
    m_lcid = pAppln->QueryAppConfig()->uLCID();

	// default session timeout
	m_nTimeout = pAppln->QueryAppConfig()->dwSessionTimeout();

	// initialize Viper activity
	if (SUCCEEDED(hr))
   	    hr = m_Activity.Init(pAppln->PServicesConfig());

    // mark as Inited and update timestamp
	if (SUCCEEDED(hr))
    	m_fInited = TRUE;

    return hr;
    }

/*===================================================================
CSession::UnInit

UnInitialize CSession object. Convert to tombstone state.

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSession::UnInit()
	{
	Assert(!m_fTombstone);  // don't do it twice

	// Remove from timeout bucket if any
	if (m_fInTOBucket)
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(this);

	// Cleanup the object
    RemoveComponentCollection();

    // Get rid of the intrinsics
    m_Request.UnInit();
	m_Response.UnInit();
	m_Server.UnInit();

    // Get rid of Viper activity
    m_Activity.UnInit();

	// Update global counters
#ifndef PERF_DISABLE
	if (m_fTimedOut)
	    g_PerfData.Incr_SESSIONTIMEOUT();
    g_PerfData.Decr_SESSIONCURRENT();
    DWORD dwt = GetTickCount();
	if (dwt >= m_dwtInitTimestamp)
	    dwt = dwt - m_dwtInitTimestamp;
    else
        dwt = (DWT_MAX - m_dwtInitTimestamp) + dwt;
    g_PerfData.Set_SESSIONLIFETIME(dwt);
#endif

	m_pAppln->DecrementSessionCount();
    InterlockedDecrement((LPLONG)&g_nSessions);

    m_pAppln = NULL;
    m_pHitObj = NULL;

    // Mark this session as Tombstone
	
	m_fTombstone = TRUE;

	// Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)

	CoDisconnectObject(static_cast<ISessionObject *>(this), 0);

	return S_OK;
    }

/*===================================================================
CSession::MakeLightWeight

Convert to 'light-weight' state if possible

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::MakeLightWeight()
    {
    Assert(m_fInited);

    if (m_fLightWeight)
        return S_OK;

    if (m_cRequests > 1)   // requests pending for this session?
        return S_OK;

    if (m_fSessCompCol && !m_SessCompCol.FHasStateInfo())
        {
        // don't remove component collection from under enumerators
        if (!m_pTaggedObjects && !m_pProperties)
            RemoveComponentCollection();
        }

    m_fLightWeight = TRUE;
    return S_OK;
    }

/*===================================================================
CSession::CreateComponentCollection

Create and Init Session's component collection.

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::CreateComponentCollection()
    {
    Assert(!m_fSessCompCol);

    HRESULT hr = m_SessCompCol.Init(csSession, m_pAppln->QueryAppConfig()->fExecuteInMTA());

    if (SUCCEEDED(hr))
        {
        m_fSessCompCol = TRUE;
        }
    else
        {
        RemoveComponentCollection();
        }

	return hr;
    }

/*===================================================================
CSession::RemoveComponentCollection

Remove Session's component collection

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::RemoveComponentCollection()
    {
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }

    if (m_fSessCompCol)
        {
   	    m_SessCompCol.UnInit();
   	    m_fSessCompCol = FALSE;
   	    }

    return S_OK;
    }

/*===================================================================
CSession::FShouldBeDeletedNow

Tests if the session should be deleted

Parameters:
    BOOL fAtEndOfRequest    TRUE if at the end of a request

Returns:
    BOOL    TRUE (should be deleted) or FALSE (shouldn't)
===================================================================*/
BOOL CSession::FShouldBeDeletedNow
(
BOOL fAtEndOfRequest
)
    {
    if (fAtEndOfRequest)
        {
        // Any OTHER requests pending -> don't delete
    	if (m_cRequests > 1)
	        return FALSE;
        }
    else
        {
        // Any requests pending -> don't delete
    	if (m_cRequests > 0)
	        return FALSE;
        }

    // GLOBAL.ASA changed - delete
   	if (m_pAppln->FGlobalChanged())
   	    return TRUE;

    // Failed to start or abandoned - delete
	if (m_fOnStartFailed || m_fAbandoned)
	    return TRUE;

    // Is stateless session? No need for Session_OnEnd?
    if (!m_fSessCompCol    &&  // CompCol gone in MakeLightWeight()
        !m_fStateAcquired  &&  // no other properties set
        !m_fOnStartInvoked &&  // on start was never invoked
        !m_fOnEndPresent)      // on end is not present
        return TRUE;           // -> delete this session

    // don't check timeout here
    return FALSE;
    }

/*===================================================================
CSession::QueryInterface

QueryInterface() -- IUnknown implementation.

Parameters:
    REFIID riid
    void **ppv

Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::QueryInterface
(
REFIID riid,
void **ppv
)
{
	*ppv = NULL;

	if (IID_IUnknown         == riid ||
	    IID_IDispatch        == riid ||
	    IID_ISessionObject   == riid ||
        IID_IDenaliIntrinsic == riid)
	{
		*ppv = static_cast<ISessionObject *>(this);
        ((IUnknown *)*ppv)->AddRef();
		return S_OK;
    }
		
    else if (IID_ISupportErrorInfo == riid)
    {
        m_ISuppErrImp.AddRef();
		*ppv = &m_ISuppErrImp;
		return S_OK;
    }
    else if (IID_IMarshal == riid)
    {
        Assert( m_pUnkFTM != NULL );

        if (m_pUnkFTM == NULL )
        {
            return E_UNEXPECTED;
        }

        return m_pUnkFTM->QueryInterface( riid, ppv );
    }
	else
    {
    	return E_NOINTERFACE;
   	}
    	
}

/*===================================================================
CSession::AddRef

AddRef() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	return cRefs;
    }

/*===================================================================
CSession::Release

Release() -- IUnknown implementation.

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::Release()
{
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	if (cRefs)
		return cRefs;

	delete this;

    InterlockedDecrement(&g_nSessionObjectsActive);

	return 0;
}

/*===================================================================
CSession::CheckForTombstone

Tombstone stub for ISessionObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CSession::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;

	ExceptionId
	    (
	    IID_ISessionObject,
	    IDE_SESSION,
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CSession::get_SessionID

ISessionObject implementation.

Return the session ID to the caller

Parameters:
	BSTR *pbstrRet      [out] session id value

Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_SessionID
(
BSTR *pbstrRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	HRESULT hr = S_OK;

	wchar_t	wszId[15];
	_ultow(m_dwExternId, wszId, 10);
	*pbstrRet = SysAllocString(wszId);
	
	if (*pbstrRet == NULL)
    	{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID,
		    IDE_SESSION_MAP_FAILED
		    );
		hr = E_FAIL;
	    }

	m_fStateAcquired = TRUE;
	return hr;
    }

/*===================================================================
CSession::get_Timeout

ISessionObject implementation.

Return the default or user set timeout interval (in minutes)

Parameters:
    long *plVar         [out] timeout value (in minutes)

Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_Timeout
(
long *plVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	*plVar = m_nTimeout;
	return S_OK;
    }

/*===================================================================
CSession::put_Timeout

ISessionObject implementation.

Allows the user to set the timeout interval (in minutes)

Parameters:
    long lVar         timeout value (in minutes)

Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::put_Timeout
(
long lVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (lVar < SESSION_TIMEOUT_MIN || lVar > SESSION_TIMEOUT_MAX)
    	{
		ExceptionId
    		(
	    	IID_ISessionObject,
	    	IDE_SESSION_ID,
	    	IDE_SESSION_INVALID_TIMEOUT
	    	);
		return E_FAIL;
	    }

	m_fStateAcquired = TRUE;
	m_fCustomTimeout = TRUE;
	
	m_nTimeout = lVar;
	return S_OK;
    }

/*===================================================================
CSession::get_CodePage

ISessionObject implementation.

Returns the current code page value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_CodePage
(
long *plVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	Assert(m_pHitObj);

	*plVar = m_lCodePage;

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0)
		{
		*plVar = (long) GetACP();
		}
		
	return S_OK;
    }

/*===================================================================
CSession::put_CodePage

ISessionObject implementation.

Sets the current code page value for the request

Parameters:
    long lVar       code page to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_CodePage
(
long lVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	// set code page member variable
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetCodePage(lVar);

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID,
		    IDE_SESSION_INVALID_CODEPAGE
		    );
		return E_FAIL;
		}

    m_fCodePageSet = TRUE;

    m_lCodePage = lVar;
		
	// we need to preserve session since the user has set
	// its code page member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }


/*===================================================================
CSession::get_LCID

ISessionObject implementation.

Returns the current lcid value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_LCID
(
long *plVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	Assert(m_pHitObj);

	*plVar = m_lcid;

    if (*plVar == LOCALE_SYSTEM_DEFAULT) {
        *plVar = GetSystemDefaultLCID();
    }
	return S_OK;
    }

/*===================================================================
CSession::put_LCID

ISessionObject implementation.

Sets the current LCID value for the request

Parameters:
    long lVar   LCID to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_LCID
(
long lVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	// set code page member variable
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetLCID(lVar);	

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID,
		    IDE_TEMPLATE_BAD_LCID
		    );
		return E_FAIL;
		}
	
    m_fLCIDSet = TRUE;
    m_lcid = lVar;

	// we need to preserve session since the user has set
	// its lcid member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }

/*===================================================================
CSession::get_Value

ISessionObject implementation.

Will allow the user to retreive a session state variable,
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
	BSTR     bstrName	Name of the variable to get
	VARIANT *pVar		Value/object to get for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_Value
(
BSTR bstrName,
VARIANT *pVar
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}

	VariantInit(pVar); // default variant empty
	
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

	if (pwszName == NULL)
	    return S_OK; // no name - no value - no error
	//_wcsupr(pwszName);

	CComponentObject *pObj = NULL;
	HRESULT hr = S_OK;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

	hr = m_pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
	
    if (SUCCEEDED(hr) && pObj)
        hr = pObj->GetVariant(pVar);

	return S_OK;
    }

/*===================================================================
CSession::putref_Value

ISessionObject implementation.

Will allow the user to assign a session state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
	BSTR 	bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::putref_Value
(
BSTR bstrName,
VARIANT Var
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_ISessionObject, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}

	HRESULT hr;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
		return E_FAIL;
		}
	//_wcsupr(pwszName);

    hr = m_pHitObj->SetPropertyComponent(csSession, pwszName, &Var);

	return hr;
    }

/*===================================================================
CSession::put_Value

ISessionObject implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	BSTR    bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_Value
(
BSTR bstrName,
VARIANT Var
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}

	HRESULT hr;
	VARIANT varResolved;
	
	hr = VariantResolveDispatch
	    (
	    &varResolved,
	    &Var,
        IID_ISessionObject,
        IDE_SESSION
        );

	if (FAILED(hr))
		return hr;		// exception already raised

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);

	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
    	VariantClear( &varResolved );
		return E_FAIL;
		}
	//_wcsupr(pwszName);

    hr = m_pHitObj->SetPropertyComponent
        (
        csSession,
        pwszName,
        &varResolved
        );

	VariantClear( &varResolved );

	return hr;
    }

/*===================================================================
CSession::Abandon

ISessionObject implementation.

Abandon reassignes session id to avoid hitting this session
with incoming requests. Abandoned sessions get deleted ASAP.

Parameters:
	None

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::Abandon()
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

	m_fAbandoned = TRUE;

	// The new session logic allows only one session id per
	// client need to disassociate session from client
	// (good idea when abandoning anyway)
	Assert(m_pHitObj);

    // If execution Session_OnEnd (not a browser request), do nothing
	if (!m_pHitObj->FIsBrowserRequest())
	    return S_OK;
	
   	return m_pHitObj->ReassignAbandonedSession();
    }

/*===================================================================
CSession::get_StaticObjects

Return the session static objects dictionary
===================================================================*/
STDMETHODIMP CSession::get_StaticObjects
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pTaggedObjects)
        {
        m_pTaggedObjects = new CSessionVariants;
        if (!m_pTaggedObjects)
            return E_OUTOFMEMORY;

        HRESULT hr = m_pTaggedObjects->Init(this, ctTagged);
        if (FAILED(hr))
            {
            m_pTaggedObjects->UnInit();
            m_pTaggedObjects->Release();
            m_pTaggedObjects = NULL;
            }
        }

    Assert(m_pTaggedObjects);
	return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

/*===================================================================
CSession::get_Contents

Return the session contents dictionary
===================================================================*/
STDMETHODIMP CSession::get_Contents
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pProperties)
        {
        m_pProperties = new CSessionVariants;
        if (!m_pProperties)
            return E_OUTOFMEMORY;

        HRESULT hr = m_pProperties->Init(this, ctProperty);
        if (FAILED(hr))
            {
            m_pProperties->UnInit();
            m_pProperties->Release();
            m_pProperties = NULL;
            }
        }

    Assert(m_pProperties);
	return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

#ifdef DBG
/*===================================================================
CSession::AssertValid

Test to make sure that the CSession object is currently
correctly formed and assert if it is not.

Returns:
	None

Side effects:
	None.
===================================================================*/
VOID CSession::AssertValid() const
    {	
    Assert(m_fInited);

    if (!m_fTombstone)
        Assert(m_pAppln);
    }
#endif // DBG


/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

/*===================================================================
CSessionMgr::CSessionMgr

CSessionMgr constructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::CSessionMgr()
    :
    m_fInited(FALSE),
    m_pAppln(NULL),
    m_cSessionCleanupRequests(0),
	m_cTimeoutBuckets(0),
	m_rgolTOBuckets(NULL),
    m_idSessionKiller(0),
    m_dwmCurrentTime(0),
    m_dwtNextSessionKillerTime(0)
    {
    }

/*===================================================================
CSessionMgr::~CSessionMgr

CSessionMgr destructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::~CSessionMgr()
    {
    UnInit();
    }

/*===================================================================
HRESULT CSessionMgr::Init

Initializes the Session Manager.
Initializes hash tables.
Schedules session killer.

Parameters:
	pAppln      Application

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::Init
(
CAppln *pAppln
)
    {
    Assert(!m_fInited);

    HRESULT hr;
	m_pAppln = pAppln;

    // Master hash table
	hr = m_htidMaster.Init
	    (
        SESSION_MASTERHASH_SIZE1_MAX,
        SESSION_MASTERHASH_SIZE2_MAX,
        SESSION_MASTERHASH_SIZE3_MAX
	    );
	if (FAILED(hr))
	    return hr;

    // Number of timeout buckets = session timeout in minutes + 1
    m_cTimeoutBuckets =
        m_pAppln->QueryAppConfig()->dwSessionTimeout() + 1;

    if (m_cTimeoutBuckets < SESSION_TIMEOUTBUCKETS_MIN)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MIN;
    else if (m_cTimeoutBuckets > SESSION_TIMEOUTBUCKETS_MAX)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MAX;

	// Timeout buckets hash tables array
	m_rgolTOBuckets = new CObjectListWithLock[m_cTimeoutBuckets];
	if (!m_rgolTOBuckets)
	    return E_OUTOFMEMORY;

    // Each timeout bucket hash table
    for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        {
    	hr = m_rgolTOBuckets[i].Init
    	    (
    	    OBJECT_LIST_ELEM_FIELD_OFFSET(CSession, m_TOBucketElem)
    	    );
    	if (FAILED(hr))
    	    return hr;
        }

    // Schedule session killer
    hr = ScheduleSessionKiller();
    if (FAILED(hr))
        return hr;

    // Start counting time
    m_dwmCurrentTime = 0;

    // Remember the time of the next session killer
    m_dwtNextSessionKillerTime = ::GetTickCount() + MSEC_ONE_MINUTE;

	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
HRESULT CSessionMgr::UnInit

UnInitializes the Session Manager.

Parameters:

Returns:
	S_OK
===================================================================*/
HRESULT CSessionMgr::UnInit( void )
    {
    // Un-schedule session killer
    if (m_idSessionKiller)
        UnScheduleSessionKiller();

    // Timeout buckets
	if (m_rgolTOBuckets)
	    {
        for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        	m_rgolTOBuckets[i].UnInit();
	    delete [] m_rgolTOBuckets;
	    m_rgolTOBuckets = NULL;
	    }
    m_cTimeoutBuckets = 0;	

    // Master hash
	m_htidMaster.UnInit();

	m_fInited = FALSE;
	return S_OK;
    }

/*===================================================================
CSessionMgr::ScheduleSessionKiller

Sets up the session killer workitem for ATQ scheduler

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::ScheduleSessionKiller()
    {
    Assert(!m_idSessionKiller);

    m_idSessionKiller = ScheduleWorkItem
        (
        CSessionMgr::SessionKillerSchedulerCallback,  // callback
        this,                                         // context
        MSEC_ONE_MINUTE,                              // timeout
        TRUE                                          // periodic
        );

    return m_idSessionKiller ? S_OK : E_FAIL;
    }

/*===================================================================
CSessionMgr::UnScheduleSessionKiller

Removes the session killer workitem for ATQ scheduler

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::UnScheduleSessionKiller()
    {
    if (m_idSessionKiller)
        {
        RemoveWorkItem(m_idSessionKiller);
        m_idSessionKiller = 0;
        }
    return S_OK;
    }

/*===================================================================
CSessionMgr::GenerateIdAndCookie

Generate new ID and cookie to be used create new session
or reassign the session ID for an existing session.

Parameters:
    pId             [out] ID
    pszNewCookie    [out] Cookie (buf must be long enough)

Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::GenerateIdAndCookie
(
CSessionId *pId,
char  *pszNewCookie
)
    {
    pId->m_dwId = g_SessionIdGenerator.NewId();
    GenerateRandomDwords(&pId->m_dwR1, 2);

    EncodeSessionIdCookie
        (
        pId->m_dwId,
        pId->m_dwR1,
        pId->m_dwR2,
        pszNewCookie
        );

    return S_OK;
    }

/*===================================================================
CSessionMgr::NewSession

Creates and Inits a new CSession object

Parameters:
    Id            session id
    ppSession     [out] session created

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::NewSession
(
const CSessionId &Id,
CSession **ppSession
)
    {
    Assert(m_fInited);

    HRESULT hr = S_OK;

	CSession *pSession = new CSession;
	if (!pSession)
	    hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr))
	    hr = pSession->Init(m_pAppln, Id);

	if (SUCCEEDED(hr))
	    {
	    Assert(pSession);
        *ppSession = pSession;
	    }
	else
	    {
	    // failed - do cleanup
	    if (pSession)
	        {
	        pSession->UnInit();
	        pSession->Release();
	        }
        *ppSession = NULL;
	    }
		
	return hr;
    }

/*===================================================================
CSessionMgr::ChangeSessionId

Reassigns different session Id to a session.
Updates the master hash.

This method is called when abandoning a session
to disassociate it from the client.

Parameters:
	pSession        session to change id on
    Id		        new session id to assign

Returns:
	S_OK on success
	E_FAIL	on failure
===================================================================*/
HRESULT CSessionMgr::ChangeSessionId
(
CSession *pSession,
const CSessionId &Id
)
    {
    HRESULT hr;

    // During request processing session's not supposed to be
    // in any timeout bucket
    Assert(!pSession->m_fInTOBucket);

    LockMaster();

    // Remove from master hash by Id
    hr = RemoveFromMasterHash(pSession);

    if (SUCCEEDED(hr))
        {
        // Assign new id
        pSession->AssignNewId(Id);

        // Reinsert into master hash by id
        hr = AddToMasterHash(pSession);
        }

    UnLockMaster();

    return hr;
    }

/*===================================================================
CSessionMgr::FindInMasterHash

Finds Session in master hash session id.
Doesn't Lock.

Parameters:
        Id            session id to find
        **ppSession   [out] session found
	
Returns:
	S_OK     good session found
	S_FALSE     session not found or bad session found
===================================================================*/
HRESULT CSessionMgr::FindInMasterHash
(
const CSessionId &Id,
CSession **ppSession
)
    {
    Assert(m_fInited);

	// Find in the hash table
	HRESULT hr = m_htidMaster.FindObject(Id.m_dwId, (void **)ppSession);
	if (hr != S_OK)
	    {
	    // Not found
	    *ppSession = NULL;
	    return hr;
	    }

    // Session found, check if valid
	if ((*ppSession)->m_fAbandoned ||
	    (*ppSession)->m_fTombstone ||
	    !(*ppSession)->FPassesIdSecurityCheck(Id.m_dwR1, Id.m_dwR2))
	    {
	    // Bad session
        hr = S_FALSE;
	    }

	return hr;
	}

/*===================================================================
CSessionMgr::AddSessionToTOBucket

Adds session to the correct timeout bucket.
Locks the timeout bucket.

Parameters:
	pSession        - session to add

Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::AddSessionToTOBucket
(
CSession *pSession
)
    {
    HRESULT hr;

    // Should not be already in a timeout bucket
    Assert(!pSession->m_fInTOBucket);

    DWORD iBucket = GetSessionTOBucket(pSession);

    LockTOBucket(iBucket);

    hr = m_rgolTOBuckets[iBucket].AddObject(pSession);

    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = TRUE;

    UnLockTOBucket(iBucket);

    return hr;
    }

/*===================================================================
CSessionMgr::RemoveSessionToTOBucket

Removes from its timeout bucket if any.
Locks the timeout bucket.

Parameters:
	pSession        - session to remove
	fLock           - lock bucket? (not needed during shutdown)

Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::RemoveSessionFromTOBucket
(
CSession *pSession,
BOOL fLock
)
    {
    HRESULT hr;

    Assert(m_fInited);
    Assert(pSession->m_fInited);

    if (!pSession->m_fInTOBucket)   // not there - no error
        return S_OK;

    DWORD iBucket = GetSessionTOBucket(pSession);

    if (fLock)
        LockTOBucket(iBucket);

    if (pSession->m_fInTOBucket)    // recheck after locking
        hr = m_rgolTOBuckets[iBucket].RemoveObject(pSession);
    else
        hr = S_OK;

    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = FALSE;

    if (fLock)
        UnLockTOBucket(iBucket);

    return hr;
    }

/*===================================================================
CSessionMgr::DeleteSession

Delete now or post for deletion.
Should be called after the session is gone from the hash table

Parameters:
	CSession *pSession        - session to release
    BOOL fInSessionActivity   - TRUE when deleting HitObj's session
                                at the end of request (no Async
                                calls needed)

Returns:
	HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteSession
(
CSession *pSession,
BOOL fInSessionActivity
)
    {
    Assert(pSession);
    pSession->AssertValid();

    // Take care of DELETE NOW case

    BOOL fDeleteNow = pSession->FCanDeleteWithoutExec();

    // If called not from the session's activity and session
    // has objects then need to switch to the right activity
    // to remove the session level objects

    if (!fInSessionActivity && pSession->FHasObjects())
        fDeleteNow = FALSE;

    if (fDeleteNow)
        {
        pSession->UnInit();
        pSession->Release();
		return S_OK;
		}

    // THE ASYNC DELETE LOGIC

	HRESULT hr = S_OK;

	// Make sure session object exists after AsyncCall
	pSession->AddRef();

    // Create new HitObj and init it for session delete

	CHitObj *pHitObj = new CHitObj;
	if (pHitObj)
	    {
	    pHitObj->SessionCleanupInit(pSession);

    	if (fInSessionActivity)
    	    {
    	    // Already inside the correct activity no need to
    	    // push the call through Viper
    	
            BOOL fRequestReposted = FALSE;
            pHitObj->ViperAsyncCallback(&fRequestReposted);
            Assert(!fRequestReposted);  // this better not happen
            delete pHitObj;
    	    }
        else
            {
            // Ask Viper to post the request
        	hr = pHitObj->PostViperAsyncCall();
            if (FAILED(hr))
                delete pHitObj;
        	}
        }
    else
    	{
		hr = E_OUTOFMEMORY;
	    }

    if (FAILED(hr))
        {
        // Out of memery or Viper failed to post a request
        // Force the issue inside TRY CATCH
        // (not always safe to delete in the wrong thread)
        TRY
            hr = pSession->UnInit();
    	CATCH(nExcept)
    	    pSession->m_fTombstone = TRUE;
			CoDisconnectObject(static_cast<ISessionObject *>(pSession), 0);
	        hr = E_UNEXPECTED;
        END_TRY
        pSession->Release();
        }

    pSession->Release(); // Undo AddRef()
    return S_OK;
    }

/*===================================================================
CSessionMgr::DeleteExpiredSessions

Removes expired Sessions from a given timeout bucket

Parameters:
    iBucket     timeout bucket #

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteExpiredSessions
(
DWORD iBucket
)
    {
    LockMaster();

    LockTOBucket(iBucket);

    void *pvSession = m_rgolTOBuckets[iBucket].PFirstObject();

    while (pvSession && !IsShutDownInProgress())
        {
        CSession *pSession = reinterpret_cast<CSession *>(pvSession);
        pvSession = m_rgolTOBuckets[iBucket].PNextObject(pvSession);

        if (pSession->GetRequestsCount() == 0)
            {
            BOOL fTimedOut = pSession->GetTimeoutTime() <= GetCurrentTime();
            BOOL fRemovedFromMasterHash = FALSE;

            if (fTimedOut || pSession->FShouldBeDeletedNow(FALSE))
                {

                if (pSession->GetRequestsCount() == 0) // recheck after lock
                    {
                    RemoveFromMasterHash(pSession);
                    fRemovedFromMasterHash = TRUE;
                    }

                }

            if (fRemovedFromMasterHash)
                {
                if (fTimedOut)
                    pSession->m_fTimedOut = TRUE;

                // delete from timeout bucket
                m_rgolTOBuckets[iBucket].RemoveObject(pSession);
                pSession->m_fInTOBucket = FALSE;

                // delete session object itself (or schedule for deletion)
                DeleteSession(pSession);
                }
            }
        }

    UnLockTOBucket(iBucket);
    UnLockMaster();
    return S_OK;
    }

/*===================================================================
CSessionMgr::DeleteAllSessions

Application shutdown code.

Parameters:
    fForce      flag - force delete?

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteAllSessions
(
BOOL fForce
)
    {
    // Remove session killer so that it wouldn't interfere
    UnScheduleSessionKiller();

    LockMaster();

    HRESULT hr = m_htidMaster.IterateObjects
        (
        DeleteAllSessionsCB,
        this,
        &fForce
        );

    if (fForce)
        m_htidMaster.RemoveAllObjects();

    UnLockMaster();
    return hr;
    }

/*===================================================================
CSessionMgr::DeleteAllSessionsCB

Static iterator callback.
Removes Session regardless.

Parameters:
    pvSession       session passed as void*
    pvSessionMgr    session manager passed as void*
    pvfForce        flag if TRUE - force the issue

Returns:
    IteratorCallbackCode
===================================================================*/
IteratorCallbackCode CSessionMgr::DeleteAllSessionsCB
(
void *pvSession,
void *pvSessionMgr,
void *pvfForce
)
    {
    IteratorCallbackCode rc = iccContinue;

    CSession *pSession = reinterpret_cast<CSession *>(pvSession);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pvSessionMgr);
    BOOL fForce = *(reinterpret_cast<BOOL *>(pvfForce));

	// Try for 5 seconds to post delete for each session
	for (int iT = 0; iT < 10; iT++)
	    {
	    if (pSession->GetRequestsCount() == 0)
	        {
	        if (fForce)
	            {
	            // When forcing delete and there are too many
	            // session cleanup requests quequed
	            // wait for the queue to drain
	            while (pMgr->GetNumSessionCleanupRequests() >= SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
	                Sleep(100);
	            }
	        else // if (!fForce)
	            {
	            // When not forcing delete (on application restart)
	            // don't queue too many sessions at one time
	
	            if (pMgr->GetNumSessionCleanupRequests() < SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
                    rc = iccRemoveAndContinue;
                else
                    rc = iccRemoveAndStop;
                }

            if (pSession->FInTOBucket())
                pMgr->RemoveSessionFromTOBucket(pSession, !fForce);

       		pMgr->DeleteSession(pSession);
   		    break;
            }

        if (!fForce)
            break;

		Sleep(500);
		}

    return rc;
    }

/*===================================================================
CSessionMgr::SessionKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces session killer thread

Parameters:
    void *pv    context pointer (points to appl)

Returns:

Side effects:
    None.
===================================================================*/
void WINAPI CSessionMgr::SessionKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pv);

    // Advance session killer time by 1 [minute]
    pMgr->m_dwmCurrentTime++;

    // Choose the bucket
    DWORD iBucket = pMgr->m_dwmCurrentTime % pMgr->m_cTimeoutBuckets;

    // Kill the sessions
    pMgr->DeleteExpiredSessions(iBucket);

    // Adjust the timeout to stay on the minute boundary
    pMgr->m_dwtNextSessionKillerTime += MSEC_ONE_MINUTE;

    // Calculate wait till next callback wakes up
    DWORD dwtCur  = ::GetTickCount();
    DWORD dwtWait = 5000; //  5 sec if we are already late

//    if (dwtCur < pMgr->m_dwtNextSessionKillerTime)
//        {
        dwtWait = pMgr->m_dwtNextSessionKillerTime - dwtCur;
        if (dwtWait > MSEC_ONE_MINUTE)
            dwtWait = MSEC_ONE_MINUTE; // in case of wrap-around
//        }

    ScheduleAdjustTime(pMgr->m_idSessionKiller, dwtWait);
    }

#ifdef DBG
/*===================================================================
CSessionMgr::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CSessionMgr::AssertValid() const
    {
    Assert(m_fInited);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\strlist.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: StrList.h

Owner: DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _StrList_H
#define _StrList_H

#include "dispatch.h"
#include "asptlb.h"
#include "memcls.h"

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C S t r i n g L i s t E l e m
 *
 * A String list is a linked list of CStringListElem's
 * This approach was chosen because it should cause less fragmentation
 * than an array-based approach. (At least with our current memory
 * management algorithm.)
 */
class CStringListElem
	{
private:
    DWORD   m_fBufferInUse : 1; // buffer instead of pointer?
    DWORD   m_fAllocated : 1;   // free the pointer on destructor?

	CStringListElem	*m_pNext;   // next element

    union
        {
    WCHAR   *m_szPointer;     // valid when m_fBufferInUse is FALSE
    WCHAR    m_szBuffer[48];  // valid when m_fBufferInUse is TRUE
                              // 48 hardcoded only here - sizeof() used elsewhere
        };
    
public:
	CStringListElem();
	~CStringListElem();

	HRESULT Init(char *szValue, BOOL fMakeCopy, UINT  lCodePage);

    HRESULT Init(WCHAR *wszValue, BOOL fMakeCopy);
	
	inline WCHAR *QueryValue()
	    {
	    return (m_fBufferInUse ? m_szBuffer : m_szPointer);
	    }
	    
	inline CStringListElem *QueryNext()
	    {
	    return m_pNext;
	    }
	    
	inline void SetNext(CStringListElem *pNext)
	    {
	    m_pNext = pNext;
	    }
	    
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r i n g L i s t
 *
 * IStringList implementation (includes IDispatch)
 */
class CStringList : public IStringList
	{
friend class CStrListIterator;

protected:
	CSupportErrorInfo	m_ISupportErrImp;	// ISupportError implementation
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CStringListElem		*m_pBegin, *m_pEnd;	// begin & end of string list
	int					m_cValues;			// number of values stored
	long				m_lCodePage;		// CodePage used in converting stored value to proper UNICODE string

	HRESULT ConstructDefaultReturn(VARIANT *);	// construct comma-separated return

public:
	CStringList(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CStringList();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE, UINT lCodePage = CP_ACP);

	HRESULT AddValue(WCHAR *szValue, BOOL fDuplicate = FALSE);

	// IUnknown implementation
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IStringList implementation
	//
	STDMETHODIMP			get_Item(VARIANT varIndex, VARIANT *pvarOut);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnum);
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r L i s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CStrListIterator : public IEnumVARIANT
	{
public:
	CStrListIterator(CStringList *pStrings);
	~CStrListIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG				m_cRefs;		// reference count
	CStringList *		m_pStringList;	// pointer to iteratee
	CStringListElem *	m_pCurrent;		// pointer to current element in target CStringList
	};

#endif  // _StrList_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\template.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.h
Maintained by:  DaveK
Component:      include file for Denali Compiled Template object
==============================================================================*/

#ifndef _TEMPLATE_H
#define _TEMPLATE_H

#include "vector.h"
#include "LinkHash.h"
#include "Compcol.h"
#include "util.h"
#include "activdbg.h"
#include "ConnPt.h"
#include "DblLink.h"
#include "aspdmon.h"
#include "ie449.h"
#include "memcls.h"

#define PER_TEMPLATE_REFLOG 0

/*  NOTE we ensure that C_COUNTS_IN_HEADER is a multiple of 4 because the offsets which follow
    the counts in template header are dword-aligned.  It is easiest (and fastest at runtime)
    to make sure those offsets start on a dword-alignment point; thus no runtime alignment calc
    is needed in GetAddress().
*/
#define C_REAL_COUNTS_IN_HEADER     3       // actual number of count fields in template header
#define C_COUNTS_IN_HEADER          (C_REAL_COUNTS_IN_HEADER/4 + 1) * 4     // allocated number of count fields in template header

#define C_OFFOFFS_IN_HEADER         4       // number of 'ptr-to-ptr' fields in template header
#define CB_TEMPLATE_DEFAULT         2500    // default memory allocation for new template
#define C_TARGET_LINES_DEFAULT      50      // default count of target script lines per engine

#define C_TEMPLATES_PER_INCFILE_DEFAULT 4   // default count of templates per inc-file

#define         SZ_NULL         "\0"
#define         WSTR_NULL      L"\0"
#define         SZ_NEWLINE      "\r\n"
#define         WSZ_NEWLINE      L"\r\n"
const unsigned  CB_NEWLINE      = strlen(SZ_NEWLINE);

const   LPSTR   g_szWriteBlockOpen  = "Response.WriteBlock(";
const   LPSTR   g_szWriteBlockClose = ")";
const   LPSTR   g_szWriteOpen       = "Response.Write(";
const   LPSTR   g_szWriteClose      = ")";

// defaults for buffering interim compile results
#define     C_SCRIPTENGINESDEFAULT  2       // default count of script engines
#define     C_SCRIPTSEGMENTSDEFAULT 20      // default count of script segments
#define     C_OBJECTINFOS_DEFAULT   10      // default count of object-infos
#define     C_HTMLSEGMENTSDEFAULT   20      // default count of HTML segments
#define     C_INCLUDELINESDEFAULT   5       // default count of include lines
#define     CB_TOKENS_DEFAULT       400     // default byte count for tokens

#define     CH_ATTRIBUTE_SEPARATOR  '='     // separator for attribute-value pair
#define     CH_SINGLE_QUOTE         '\''    // single-quote character
#define     CH_DOUBLE_QUOTE         '"'     // double-quote character
#define     CH_ESCAPE               '\\'    // escape character - tells us to ignore following token

// ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
// NOTE we want SECURITY_DESC_DEFAULT_SIZE to be relatively small, since it affects template memory reqt dramatically
#define     SECURITY_DESC_GRANULARITY   128        // 'chunk' size for re-sizing file security descriptor
#define     SECURITY_DESC_DEFAULT_SIZE  256        // initial default size of file security descriptor
#define     SIZE_PRIVILEGE_SET          128        // size of privilege set

// macros
// use outside of CTokenList class
#define SZ_TOKEN(i)                 (*gm_pTokenList).m_bufTokens.PszLocal(i)
#define CCH_TOKEN(i)                (*gm_pTokenList)[i]->m_cb
#define _TOKEN                      CTemplate::CTokenList::TOKEN
// use within CTokenList class
#define CCH_TOKEN_X(i)              (*this)[i]->m_cb
#define BR_TOKEN_X(i)               *((*this)[i])

// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED
enum SOURCEPATHTYPE
    {
    SOURCEPATHTYPE_VIRTUAL = 0,
    SOURCEPATHTYPE_PHYSICAL = 1
    };
#endif

// CTemplate error codes
#define E_COULDNT_OPEN_SOURCE_FILE              0x8000D001L
#define E_SOURCE_FILE_IS_EMPTY                  0x8000D002L
#define E_TEMPLATE_COMPILE_FAILED               0x8000D003L
#define E_USER_LACKS_PERMISSIONS                0x8000D004L
#define E_TEMPLATE_COMPILE_FAILED_DONT_CACHE    0x8000D005L
#define E_TEMPLATE_MAGIC_FAILURE                0x8000D006L

inline BOOL FIsPreprocessorError(HRESULT hr)
    {
    return
        (
        hr == E_SOURCE_FILE_IS_EMPTY                ||
        hr == E_TEMPLATE_COMPILE_FAILED             ||
        hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE  ||
        hr == E_TEMPLATE_MAGIC_FAILURE
        );
    }

//Can not use same index as CErrorInfo anymore.
//Index for lastErrorInfo in Template
#define ILE_szFileName      0
#define ILE_szLineNum       1
#define ILE_szEngine        2
#define ILE_szErrorCode     3
#define ILE_szShortDes      4
#define ILE_szLongDes       5
#define ILE_MAX             6

// forward references
class CTemplate;
class CTemplateCacheManager;
class CHitObj;
class CTokenList;
class CIncFile;
typedef CLSID PROGLANG_ID;  // NOTE also defined in scrptmgr.h; we define here to avoid include file circularity

/*  ============================================================================
    Class:      CByteRange
    Synopsis:   A range of bytes
    NOTE fLocal member is only used if the byte range is stored in a CBuffer

    NOTE 2
        m_pfilemap is really a pointer to a CFileMap - however, it's impossible
        to declare that type here because the CFileMap struct is nested inside
        CTemplate, and C++ won't let you forward declare nested classes.  Since
        the CTemplate definition depends on CByteRange, properly declaring the
        type of "m_pfilemap" is impossible.
*/
class CByteRange
{
public:
    BYTE*   m_pb;               // ptr to bytes
    ULONG   m_cb;               // count of bytes
    ULONG   m_fLocal:1;         // whether bytes are stored in buffer (TRUE) or elsewhere (FALSE)
    UINT    m_idSequence:31;    // byte range's sequence id
    void*   m_pfilemap;         // file the byte range comes from

            CByteRange(): m_pb(NULL), m_cb(0), m_fLocal(FALSE), m_idSequence(0), m_pfilemap(NULL) {}
            CByteRange(BYTE* pb, ULONG cb): m_fLocal(FALSE), m_idSequence(0) {m_pb = pb; m_cb = cb;}
    BOOLB   IsNull() { return((m_pb == NULL) || (m_cb == 0)) ; }
    void    Nullify() { m_pb = NULL; m_cb = 0; }
    void    operator=(const CByteRange& br)
                { m_pb = br.m_pb; m_cb = br.m_cb; m_fLocal = br.m_fLocal; m_idSequence = br.m_idSequence; }
    BOOLB   FMatchesSz(LPCSTR psz);
    void    Advance(UINT i);
    BYTE*   PbString(LPSTR psz, LONG lCodePage);
    BYTE*   PbOneOfAspOpenerStringTokens(LPSTR rgszTokens[], UINT rgcchTokens[],
                                         UINT nTokens, UINT *pidToken);
    BOOLB   FEarlierInSourceThan(CByteRange& br);
};

/*  ============================================================================
    Enum type:  TEMPLATE_COMPONENT
    Synopsis:   A component of a template, e.g. script block, html block, etc.
*/
enum TEMPLATE_COMPONENT
{
    // NOTE enum values and order are tightly coupled with template layout order
    // DO NOT CHANGE
    tcompScriptEngine = 0,
    tcompScriptBlock,
    tcompObjectInfo,
    tcompHTMLBlock,
};

/*  ****************************************************************************
    Class:      CTemplateConnPt
    Synopsis:   Connection point for IDebugDocumentTextEvents
*/
class CTemplateConnPt : public CConnectionPoint
{
public:
    // ctor
    CTemplateConnPt(IConnectionPointContainer *pContainer, const GUID &uidConnPt)
        : CConnectionPoint(pContainer, uidConnPt) {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
};

/*	****************************************************************************
	Class:		CTemplateKey
	Synopsis:	Packaged data to locate template in hash table
	               (instance ID, and template name)
*/	
#define MATCH_ALL_INSTANCE_IDS 0xFFFBAD1D	// unlikely instance ID.  sort of spells "BAD ID"
struct CTemplateKey
	{
	const TCHAR *	szPathTranslated;
	DWORD			dwInstanceID;

	CTemplateKey(const TCHAR *_szPathTranslated = NULL, UINT _dwInstanceID = MATCH_ALL_INSTANCE_IDS)
		: szPathTranslated(_szPathTranslated),
		  dwInstanceID(_dwInstanceID)  {}
	};


/*  ****************************************************************************
    Class:      CTemplate
    Synopsis:   A Denali compiled template.

    NOTE: CTemplate's primary client is CTemplateCacheManager, which maintains
    a cache of compiled templates.

    USAGE
    -----
    The CTemplate class must be used as follows:

    CLASS INIT - InitClass must be called before any CTemplate can be created.

    NEW TEMPLATE - For each new template the client wants to create, the client
      must do the following, in order:
      1) New a CTemplate
      2) Initialize the CTemplate by calling Init, passing a source file name
      3) Load the CTemplate by calling Load; when Load returns, the new CTemplate is ready for use.

    EXISTING TEMPLATE - To use an existing template, the client must:
      1) Call Deliver; when Deliver returns, the existing CTemplate is ready for use.

    CLASS UNINIT - UnInitClass must be called after the last CTemplate has been destroyed.

    To ensure thread-safety, the client must implement a critical section
    around the call to Init.  Init is designed to be as fast as possible,
    so the client can quickly learn that it has a pending template for a given
    source file, and queue up other requests for the same source file.

    CTemplate provides implementations for Debug documents, namely
    IDebugDocumentProvider & IDebugDocumentText
*/
class CActiveScriptEngine;

class CTemplate :
            public CDblLink,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
private:
#include "templcap.h"   // 'captive' classes, only used internally within CTemplate

friend HRESULT InitMemCls();
friend HRESULT UnInitMemCls();

friend class	CTemplateCacheManager;			// TODO: decouple CTemplate class from it's manager class
friend class    CFileMap;
friend class    CIncFile;                       // IncFiles are privy to debugging data structures

// CScriptStore::Init() must access gm_brDefaultScriptLanguage, gm_progLangIdDefault
friend HRESULT  CTemplate::CScriptStore::Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);

private:
    CWorkStore* m_pWorkStore;               // ptr to working storage for source segments
    HANDLE      m_hEventReadyForUse;        // ready-for-use event handle

public:
    BYTE*       m_pbStart;                  // ptr to start of template memory
    ULONG       m_cbTemplate;               // bytes allocated for template
    LONG        m_cRefs;                    // ref count - NOTE LONG required by InterlockedIncrement
    LONG        m_cUseCount;                // count of times template was used
public:
    CTemplateConnPt m_CPTextEvents;         // Connection point for IDebugDocumentTextEvents

    // support for compile-time errors
    BYTE*       m_pbErrorLocation;          // ptr to error location in source file
    UINT        m_idErrMsg;                 // error message id
    UINT        m_cMsgInserts;              // count of insert strings for error msg
    char**      m_ppszMsgInserts;           // array of ptrs to error msg insert strings
    // support for run-time errors and debugging
    UINT        m_cScriptEngines;           // count of script engines
    CActiveScriptEngine **m_rgpDebugScripts;// array (indexed by engine) of scripts CURRENTLY BEING DEBUGGED
    vector<CSourceInfo> *m_rgrgSourceInfos; // array of arrays of script source line infos, one per script engine per target line
	ULONG       m_cbTargetOffsetPrevT;		// running total of last source offset processed
    CRITICAL_SECTION m_csDebuggerDetach;    // CS needed to avoid race condition with detaching from debugger
    CDblLink    m_listDocNodes;             // list of document nodes we are attached to
    CFileMap**  m_rgpFilemaps;              // array of ptrs to filemaps of source files
    CTemplateKey m_LKHashKey;               // bundled info for key (contains copy of m_rgpfilemaps[0] filename to make things simpler
    UINT        m_cFilemaps;                // count of filemaps of source files
    CFileMap**  m_rgpSegmentFilemaps;       // array of filemap ptrs per source segment
    UINT        m_cSegmentFilemapSlots;     // count of per-source-segment filemap ptrs
    LPSTR       m_pszLastErrorInfo[6];      // text of last error - cached for new requests on this template
                                            //  FileName, LineNum, Engine, ShortDes, LongDes
    DWORD       m_dwLastErrorMask;          // cached for new requests on this template
	DWORD		m_hrOnNoCache;				// HRESULT when don't cache is set.
    TCHAR*      m_szApplnVirtPath;          // application virtual path (substring of Application URL)
    TCHAR*      m_szApplnURL;               // application URL (starts with "http://")
    // for best structure packing we all boleans here as bitfields
    unsigned    m_fGlobalAsa:1;             // is template for global.asa file?
    unsigned    m_fIsValid:1;               // is template in valid state?
    unsigned    m_fDontCache:1;             // don't cache this template
    unsigned    m_fReadyForUse:1;           // is template ready for use?

    unsigned    m_fDebuggerDetachCSInited:1;// has debugger attach critical section been initialized?
    unsigned    m_fDontAttach:1;            // should not be attached to debugger (not in cache)
    unsigned    m_fSession:1;               // does this page require session state
    unsigned    m_fScriptless:1;            // doesn't have any scripts

    unsigned    m_fDebuggable:1;            // is this page part of at least one debuggable app?
    unsigned    m_fZombie:1;                // File template is based on has changed since obtained from cache
    unsigned    m_fCodePageSet:1;           // Did template contain a code page directive
    unsigned    m_fLCIDSet:1;               // Did template contain an LCID directive

    unsigned    m_fIsPersisted:1;
    unsigned    m_fIsUNC:1;
    unsigned    m_fIsEncrypted:1;
    unsigned    m_fTemplateLockInited:1;
    
    TransType   m_ttTransacted;             // type of transaction support

    // class-wide support for compilation
    static      CTokenList*     gm_pTokenList;              // array of tokens
    unsigned    m_wCodePage;                                // Compiler Time CodePage
    long        m_lLCID;                                    // Compile Time LCID

    vector<ITypeLib *>  m_rgpTypeLibs;          // array of ptrs to typelibs
    IDispatch*          m_pdispTypeLibWrapper;  // typelib wrapper object

    vector<C449Cookie *> m_rgp449;              // array of ptrs to 449 requests

    LPSTR               m_szPersistTempName;    // filename of persisted template, if any
    void               *m_pHashTable;           // CacheMgr hash table that this template is on

    IUnknown           *m_pServicesConfig;

    static  HANDLE sm_hSmallHeap;
    static  HANDLE sm_hLargeHeap;

	// DirMon related fields.
	BOOL		m_fNeedsMonitoring;
	BOOL		m_fInCheck;
    DWORD		m_dwLastMonitored;
    DWORD		m_dwCacheTag;

    // UNC related last impersonation handle
    DWORD		m_dwLastAccessCheck;
    LPVOID      m_pMostRecentImpersonatedTokenUser;
    PSID		m_pMostRecentImpersonatedSID;
    DWORD		m_cbTokenUser;
    CRITICAL_SECTION m_csTemplateLock;

public:
    /**
     **  Initialization and destruction public interfaces
     **/

    // Initializes CTemplate static members; must be called on denali.dll load
    static HRESULT InitClass();

    // Un-initilaizes CTemplate static members; must be called on denali.dll unload
    static void UnInitClass();

    //  Inits template in preparation for compilation
    //  Called by template cache mgr before calling Load
    HRESULT Init(CHitObj* pHitObj, BOOL fGlobalAsp, const CTemplateKey &rTemplateKey);

    //  Compiles the template from its main source file (and include files, if any)
    HRESULT Compile(CHitObj* pHitObj);

    // Called by requestor of existing template to determine if template is ready for use
    HRESULT Deliver(CHitObj* pHitObj);

    // Given the Token Handle this function will return the pointer to the SID and the token buffer
    HRESULT GetSIDFromTokenHandle (HANDLE tokenHandle, PSID pSid, LPVOID pBuffer, DWORD *pcbSize);

    // Create this template's CServicesConfig object
    HRESULT CreateTransServiceConfig(BOOL  fEnableTracker);

            CTemplate();
            ~CTemplate();
    void    RemoveIncFile(CIncFile* pIncFile);

	// Trace Log info
	static PTRACE_LOG gm_pTraceLog;

public:
#if PER_TEMPLATE_REFLOG
    PTRACE_LOG  m_pTraceLog;
#endif
    
    /*
        'Consumer' public interfaces
        Methods for getting info out of a CTemplate
    */

    // Returns name of source file on which this template is based
    LPTSTR GetSourceFileName(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns virtual path of the source file
    LPTSTR GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns hashing key of the template
    const CTemplateKey *ExtractHashKey() const;

    // Returns version stamp of compiler by which this template was compiled
    LPSTR GetCompilerVersion();

    // Component counts
    USHORT Count(TEMPLATE_COMPONENT tcomp);
    USHORT CountScriptEngines() { return (USHORT)m_cScriptEngines; }

    // Returns i-th script block as ptr to prog lang id and ptr to script text
    void GetScriptBlock(UINT i, LPSTR* pszScriptEngine, PROGLANG_ID** ppProgLangId, LPCOLESTR* pwstrScriptText);

    // Returns i-th object-info as object name, clsid, scope, model
    HRESULT GetObjectInfo(UINT i, LPSTR* ppszObjectName,
            CLSID *pClsid, CompScope *pScope, CompModel *pcmModel);

    // Returns i-th HTML block as ptr, count of bytes, original offset, incl filename
    HRESULT GetHTMLBlock(UINT i, LPSTR* pszHTML, ULONG* pcbHTML, ULONG* pcbSrcOffs, LPSTR* pszSrcIncFile);

    // Returns line number and source file name a given target line in a given script engine.
    void GetScriptSourceInfo(UINT idEngine, int iTargetLine, LPTSTR* pszPathInfo, LPTSTR* pszPathTranslated, ULONG* piSourceLine, ULONG* pichSourceLine, BOOLB* pfGuessedLine);

    // Converts a character offset from the target script to the offset in the source
    void GetSourceOffset(ULONG idEngine, ULONG cchTargetOffset, TCHAR **pszSourceFile, ULONG *pcchSourceOffset, ULONG *pcchSourceText);

    // Converts a character offset from the source document to the offset in the target
    BOOL GetTargetOffset(TCHAR *szSourceFile, ULONG cchSourceOffset, ULONG *pidEngine, ULONG *pcchTargetOffset);

    // Get the character position of a line (directly implements debugging interface)
    HRESULT GetPositionOfLine(CFileMap *pFilemap, ULONG cLineNumber, ULONG *pcCharacterPosition);

    // Get the line # of a character position (directly implements debugging interface)
    HRESULT GetLineOfPosition(CFileMap *pFilemap, ULONG cCharacterPosition, ULONG *pcLineNumber, ULONG *pcCharacterOffsetInLine);

    // Return a RUNNING script based on the engine, or NULL if code context has never been requested yet
    CActiveScriptEngine *GetActiveScript(ULONG idEngine);

    // associate a running script for an engine ID (Use after you get the first code context)
    HRESULT AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine);

    // attach the CTemplate object to an application (debugger tree view)
    HRESULT AttachTo(CAppln *pAppln);

    // detach the CTemplate object from an application (debugger tree view)
    HRESULT DetachFrom(CAppln *pAppln);

    // detach the CTemplate object all applications (and release script engines)
    HRESULT Detach();

    // Signifies last use of template as a recylable object. Any outstanding references
    // should be from currently executing scripts.
    ULONG End();

    // Let debugger know about page start/end
    HRESULT NotifyDebuggerOnPageEvent(BOOL fStart);

    // Generate 449 response in cookie negotiations with IE when needed
    HRESULT Do449Processing(CHitObj *pHitObj);

    HRESULT PersistData(char    *pszTempFilePath);
    HRESULT UnPersistData();
    HRESULT PersistCleanup();
    ULONG   TemplateSize()  { return m_cbTemplate; }

    BOOL FTransacted();
    BOOL FSession();
    BOOL FScriptless();
    BOOL FDebuggable();
    BOOL FIsValid();        // determine if compilation succeeded
    BOOL FTemplateObsolete();
    BOOL FGlobalAsa();
    BOOL FIsZombie();
    BOOL FDontAttach();
    BOOL FIsPersisted();
    BOOL FIsUNC();
    BOOL FIsEncrypted();
    BOOL ValidateSourceFiles        (CIsapiReqInfo *pIReq);
    BOOL FNeedsValidation();
    BOOL CheckTTLTimingWindow(DWORD dwLastMonitored, DWORD timeoutSecs);
    VOID Zombify();

    IUnknown    *PServicesConfig() {return m_pServicesConfig;};

    IDispatch *PTypeLibWrapper();

    void       SetHashTablePtr(void  *pTable) { m_pHashTable = pTable; }
    void      *GetHashTablePtr() { return m_pHashTable; }

    void    IncrUseCount() { InterlockedIncrement(&m_cUseCount); }

public:
    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

private:
    /*  NOTE Compile() works by calling GetSegmentsFromFile followed by WriteTemplate
        Most other private methods support one of these two workhorse functions
    */

    void        AppendMapFile(LPCTSTR szFileSpec, CFileMap* pfilemapParent, BOOLB fVirtual,
                                    CHitObj* pHitObj, BOOLB fGlobalAsp);
    void        GetSegmentsFromFile(CFileMap& filemap, CWorkStore& WorkStore, CHitObj* pHitObj, BOOL fIsHTML = TRUE);
    void        GetLanguageEquivalents();
    void        SetLanguageEquivalent(HANDLE hKeyScriptLanguage, LPSTR szLanguageItem, LPSTR* pszOpen, UINT* pcchOpen, LPSTR* pszClose, UINT* pcchClose);
    void        ThrowError(BYTE* pbErrorLocation, UINT idErrMsg);
    void        AppendErrorMessageInsert(BYTE* pbInsert, UINT cbInsert);
    void        ThrowErrorSingleInsert(BYTE* pbErrorLocation, UINT idErrMsg, BYTE* pbInsert, UINT cbInsert);
    HRESULT     ShowErrorInDebugger(CFileMap* pFilemap, UINT cchErrorLocation, char* szDescription, CHitObj* pHitObj, BOOL fAttachDocument);
    void        ProcessSpecificError(CFileMap& filemap, CHitObj* pHitObj);
    void        HandleCTemplateError(CFileMap* pfilemap, BYTE* pbErrorLocation,
                                        UINT idErrMsg, UINT cInserts, char** ppszInserts, CHitObj *pHitObj);
    void        FreeGoodTemplateMemory();
    void        UnmapFiles();

    // ExtractAndProcessSegment: gets and processes next source segment in search range
    void        ExtractAndProcessSegment(CByteRange& brSearch, const SOURCE_SEGMENT& ssegLeading,
                    _TOKEN* rgtknOpeners, UINT ctknOpeners, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                    CHitObj* pHitObj, BOOL fScriptTagProcessed = FALSE, BOOL fIsHTML = TRUE);
    // Support methods for ExtractAndProcessSegment()
    SOURCE_SEGMENT  SsegFromHTMLComment(CByteRange& brSegment);
    void        ProcessSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                CWorkStore& WorkStore, BOOL fScriptTagProcessed, CHitObj* pHitObj,
                                BOOL fIsHTML);
    void        ProcessHTMLSegment(CByteRange& brHTML, CBuffer& bufHTMLBlocks, UINT idSequence, CFileMap* pfilemapCurrent);
    void        ProcessHTMLCommentSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessScriptSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                        CWorkStore& WorkStore, UINT idSequence, BOOLB fScriptTagProcessed, CHitObj* pHitObj);
    HRESULT     ProcessMetadataSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataTypelibSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataCookieSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
	void		GetScriptEngineOfSegment(CByteRange& brSegment, CByteRange& brEngine, CByteRange& brInclude);
    void        ProcessTaggedScriptSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessObjectSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                                        UINT idSequence);
    void        GetCLSIDFromBrClassIDText(CByteRange& brClassIDText, LPCLSID pclsid);
    void        GetCLSIDFromBrProgIDText(CByteRange& brProgIDText, LPCLSID pclsid);
    BOOLB       FValidObjectName(CByteRange& brName);
    void        ProcessIncludeFile(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    void        ProcessIncludeFile2(CHAR* szFileSpec, CByteRange& brFileSpec, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    BYTE*       GetOpenToken(CByteRange brSearch, SOURCE_SEGMENT ssegLeading, _TOKEN* rgtknOpeners, UINT ctknOpeners, _TOKEN* ptknOpen);
    BYTE*       GetCloseToken(CByteRange brSearch, _TOKEN tknClose);
    _TOKEN      GetComplementToken(_TOKEN tkn);
    SOURCE_SEGMENT  GetSegmentOfOpenToken(_TOKEN tknOpen);
    CByteRange  BrTagsFromSegment(CByteRange brSegment, _TOKEN tknClose, BYTE** ppbCloseTag);
    CByteRange  BrValueOfTag(CByteRange brTags, _TOKEN tknTag);
    BYTE*       GetTagName(CByteRange brTags, _TOKEN tknTagName);

    BOOL        GetTag(CByteRange &brTags, int nIndex = 1);
    BOOL        CompTagName(CByteRange &brTags, _TOKEN tknTagName);

    BOOLB       FTagHasValue(const CByteRange& brTags, _TOKEN tknTag, _TOKEN tknValue);
    void        CopySzAdv(char* pchWrite, LPSTR psz);

    // WriteTemplate: writes the template to a contiguous block of memory
    void    WriteTemplate(CWorkStore& WorkStore, CHitObj* pHitObj);
    // Support methods for WriteTemplate()
    // NOTE Adv suffix on some function names == advance ptr after writing
    void    WriteHeader(USHORT cScriptBlocks,USHORT cObjectInfos, USHORT cHTMLBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteScriptBlockOfEngine(USHORT idEnginePrelim, USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset,
                                        UINT* pcbOffsetToOffset, CHitObj* pHitObj);
    void    WritePrimaryScriptProcedure(USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset, UINT cbScriptBlockStart);
    void    WriteScriptSegment(USHORT idEngine, CFileMap* pfilemap, CByteRange& brScript, UINT* pcbDataOffset, UINT cbScriptBlockStart,
                                BOOL fAllowExprWrite);
    void    WriteScriptMinusEscapeChars(CByteRange brScript, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    BOOLB   FVbsComment(CByteRange& brLine);
    BOOLB   FExpression(CByteRange& brLine);
    void    WriteOffsetToOffset(USHORT cBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteSzAsBytesAdv(LPCSTR szSource, UINT* pcbDataOffset);
    void    WriteByteRangeAdv(CByteRange& brSource, BOOLB fWriteAsBsz, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    void    WriteLongAdv(ULONG uSource, UINT* pcbOffset);
    void    WriteShortAdv(USHORT uSource, UINT* pcbOffset);
    void    MemCpyAdv(UINT* pcbOffset, void* pbSource, ULONG cbSource, UINT cbByteAlign = 0);

    // Memory access primitives
    // NOTE invalid until WriteTemplate() has succeeded
    BYTE*   GetAddress(TEMPLATE_COMPONENT tcomp, USHORT i);

    // Debugging methods
    void    AppendSourceInfo(USHORT idEngine, CFileMap* pfilemap, BYTE* pbSource,
							 ULONG cbSourceOffset, ULONG cbScriptBlockOffset, ULONG cbTargetOffset,
							 ULONG cchSourceText, BOOL fIsHTML);
    UINT    SourceLineNumberFromPb(CFileMap* pfilemap, BYTE* pbSource);
    HRESULT CreateDocumentTree(CFileMap *pfilemapRoot, IDebugApplicationNode **ppDocRoot);
    BOOLB   FIsLangVBScriptOrJScript(USHORT idEngine);

#if 0
    void OutputDebugTables();
    void OutputIncludeHierarchy(CFileMap *pfilemap, int cchIndent);
    void GetScriptSnippets(ULONG cchSourceOffset, CFileMap *pFilemapSource, ULONG cchTargetOffset, ULONG idTargetEngine, wchar_t wszSourceText[], wchar_t wszTargetText[]);
#endif

    void    RemoveFromIncFiles();

    void    ReleaseTypeLibs();
    void    WrapTypeLibs(CHitObj *pHitObj);

    void    Release449();

    HRESULT BuildPersistedDACL(PACL  *ppRetDACL);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

public:
    // memory allocation
    static void* SmallMalloc(SIZE_T dwBytes);
    static void* SmallReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  SmallFree(void* pvMem);

    static void* LargeMalloc(SIZE_T dwBytes);
    static void* LargeReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  LargeFree(void* pvMem);
};

////////////////////////////////////////////////////////////////////////////////
//  Inline functions

// Write a long or short to memory, then advance target-ptr
inline void     CTemplate::WriteLongAdv(ULONG uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(ULONG), sizeof(ULONG)); }
inline void     CTemplate::WriteShortAdv(USHORT uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(USHORT), sizeof(USHORT)); }
inline const CTemplateKey * CTemplate::ExtractHashKey() const
					{ return &m_LKHashKey; }
inline BOOL     CTemplate::FTransacted()
                    { return (m_ttTransacted != ttUndefined); }
inline BOOL     CTemplate::FDebuggable()
                    { return(m_fDebuggable); }
inline BOOL     CTemplate::FSession()
                    { return(m_fSession); }
inline BOOL     CTemplate::FScriptless()
                    { return m_fScriptless; }
inline BOOL     CTemplate::FIsValid()
                    { return(m_fIsValid); }
inline BOOL     CTemplate::FGlobalAsa()
                    { return(m_fGlobalAsa); }
inline BOOL     CTemplate::FIsZombie()
                    { return m_fZombie; }
inline VOID     CTemplate::Zombify()
                    { m_fZombie = TRUE; }
inline BOOL     CTemplate::FDontAttach()
                    { return (m_fDontAttach); }
inline BOOL     CTemplate::FIsPersisted()
                    { return (m_fIsPersisted); }
inline BOOL     CTemplate::FIsUNC()
                    { return (m_fIsUNC); }
inline BOOL     CTemplate::FIsEncrypted()
                    { return (m_fIsEncrypted); }
inline LPTSTR   CTemplate::GetApplnPath(SOURCEPATHTYPE pathtype)
                    { Assert (pathtype == SOURCEPATHTYPE_VIRTUAL); return m_szApplnVirtPath; }
inline IDispatch *CTemplate::PTypeLibWrapper()
                    { return (m_pdispTypeLibWrapper); }


/*  ****************************************************************************
    Class:      CIncFile
    Synopsis:   A file included by one or more templates.

    NOTE: We store an incfile-template dependency by storing a template ptr in m_rgpTemplates.
    This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CIncFile :
            private CLinkElem,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
// CIncFileMap is a friend so that it can manipulate CLinkElem private members and to access m_ftLastWriteTime
friend class CIncFileMap;

private:
    LONG                m_cRefs;            // ref count - NOTE LONG required by InterlockedIncrement
    TCHAR *             m_szIncFile;        // include file name - NOTE we keep this as a stable ptr to hash table key
    CRITICAL_SECTION    m_csUpdate;         // CS for updating the template ptrs array
    vector<CTemplate *> m_rgpTemplates;     // array of ptrs to templates which include this include file
    CTemplateConnPt     m_CPTextEvents;     // Connection point for IDebugDocumentTextEvents
    BOOLB               m_fCsInited;        // has CS been initialized yet?

    CTemplate::CFileMap *GetFilemap();      // Return the filemap pointer from a template

public:
                CIncFile();
    HRESULT     Init(const TCHAR* szIncFile);
                ~CIncFile();
    HRESULT     AddTemplate(CTemplate* pTemplate);
    void        RemoveTemplate(CTemplate* pTemplate);
    CTemplate*  GetTemplate(int iTemplate);
    BOOL        FlushTemplates();
    TCHAR *     GetIncFileName() { return m_szIncFile; }
    void        OnIncFileDecache();

    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

};
#endif /* _TEMPLATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\tlbcache.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.h

Owner: DmitryR

This is the typelibrary cache header file.
===================================================================*/

#ifndef _ASP_TLBCACHE_H
#define _ASP_TLBCACHE_H

/*===================================================================
  Includes
===================================================================*/

#include "compcol.h"
#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

/*===================================================================
  Defines
===================================================================*/

class CHitObj;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

class CTypelibCacheEntry : public CLinkElem
    {
    
friend class CTypelibCache;
    
private:
    DWORD       m_fInited : 1;
    DWORD       m_fIdsCached : 1;
    DWORD       m_fStrAllocated : 1;

    WCHAR      *m_wszProgId;
    CLSID       m_clsid;
    CompModel   m_cmModel;
    DISPID      m_idOnStartPage;
    DISPID      m_idOnEndPage;
    DWORD       m_gipTypelib;

    // buffer to keep prog id (when it fits)
    WCHAR       m_rgbStrBuffer[60];


    CTypelibCacheEntry();
    ~CTypelibCacheEntry();

    HRESULT StoreProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByCLSID(const CLSID &clsid, LPWSTR wszProgid);
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

class CTypelibCache
    {
private:
    DWORD m_fInited : 1;
    CHashTableStr m_htProgIdEntries;
    CHashTableCLSID m_htCLSIDEntries;
    CRITICAL_SECTION m_csLock;

    void Lock()   { EnterCriticalSection(&m_csLock); }
    void UnLock() { LeaveCriticalSection(&m_csLock); }

public:
    CTypelibCache();
    ~CTypelibCache();

    HRESULT Init();
    HRESULT UnInit();

    // to be called from Server.CreateObject
    HRESULT CreateComponent
        (
        BSTR         bstrProgID,
        CHitObj     *pHitObj,
        IDispatch  **ppdisp,
        CLSID       *pclsid
        );

    // to be called from template after mapping ProgId to CLSID
    HRESULT RememberProgidToCLSIDMapping
        (
        WCHAR *wszProgid, 
        const CLSID &clsid
        );
    // to be called from object creation code to update CLSID
    // if changed since mapping
    HRESULT UpdateMappedCLSID
        (
        CLSID *pclsid
        );
        
    };


/*===================================================================
  Globals
===================================================================*/

extern CTypelibCache g_TypelibCache;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\txnsup.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

       txnsup.h

   Abstract:
       Defines class for implementation of transaction routines SetAbort
	   and SetComplete.

   Author:

       Andy Morrison    ( andymorr )     April-2001 

   Revision History:

--*/
#ifndef _TXNSUP_H
#define _TXNSUP_H

#include "asptxn.h"

class CASPObjectContext : public IASPObjectContextImpl, public ITransactionStatus
{
private:
    LONG        m_cRefs;
    BOOL        m_fAborted;

    // FTM Support
    IUnknown    *m_pUnkFTM;

public:

    CASPObjectContext()
    {
        m_cRefs = 1;  
        m_fAborted = FALSE;
        CDispatch::Init(IID_IASPObjectContext, Glob(pITypeLibTxn));

        // Create the FTM
        CoCreateFreeThreadedMarshaler( (IUnknown*)((IASPObjectContextImpl *)this), &m_pUnkFTM );
    };
    
    ~CASPObjectContext()
    {
        if ( m_pUnkFTM != NULL )
        {
            m_pUnkFTM->Release();
            m_pUnkFTM = NULL;
        }
    };
    

   	//Non-delegating object IUnknown

	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // IASPObjectContext

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();

    // ITransactionStatus
    STDMETHODIMP SetTransactionStatus(HRESULT   hr);
    STDMETHODIMP GetTransactionStatus(HRESULT  *pHrStatus);

    BOOL    FAborted()  { return m_fAborted; };

};

inline HRESULT CASPObjectContext::SetAbort()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetAbort();

        pContext->Release();

        m_fAborted = TRUE;
    }
    
    return hr;
}

inline HRESULT CASPObjectContext::SetComplete()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetComplete();

        pContext->Release();

        m_fAborted = FALSE;
    }
    
    return hr;
}

inline HRESULT CASPObjectContext::SetTransactionStatus(HRESULT  hr)
{
    // if m_fAborted is already set, this indicates that the
    // script set it and we should not reset it.

    if (m_fAborted == TRUE);
    
    else if (hr == XACT_E_ABORTED) {
        m_fAborted = TRUE;
    }
    else if (hr == S_OK) {
        m_fAborted = FALSE;
    }

    return S_OK;
}

inline HRESULT CASPObjectContext::GetTransactionStatus(HRESULT  *pHrResult)
{
    if (m_fAborted == TRUE) {
        *pHrResult = XACT_E_ABORTED;
    }
    else {
        *pHrResult = S_OK;
    }

    return S_OK;
}

/*===================================================================
CASPObjectContext::QueryInterface
CASPObjectContext::AddRef
CASPObjectContext::Release

IUnknown members for CASPObjectContext object.

===================================================================*/
inline HRESULT CASPObjectContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
{
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    if (IID_IUnknown == riid 
        || IID_IDispatch == riid 
        || IID_IASPObjectContext == riid)
        *ppv = static_cast<IASPObjectContext *>(this);

    else if (IID_ITransactionStatus == riid)
        *ppv = static_cast<ITransactionStatus *>(this);

    else if (IID_IMarshal == riid) 
    {
        Assert( m_pUnkFTM != NULL );
        
        if ( m_pUnkFTM == NULL )
        {
            return E_UNEXPECTED;
        }
        
        return m_pUnkFTM->QueryInterface( riid, ppv );
    }

    //AddRef any interface we'll return.
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


inline STDMETHODIMP_(ULONG) CASPObjectContext::AddRef(void) {

    return InterlockedIncrement(&m_cRefs);
}


inline STDMETHODIMP_(ULONG) CASPObjectContext::Release(void) {

    LONG cRefs = InterlockedDecrement(&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
}

class CASPDummyObjectContext : public IASPObjectContextImpl
{

private:
    LONG        m_cRefs;
    IUnknown    *m_pUnkFTM;

public:
 CASPDummyObjectContext::CASPDummyObjectContext()
{
    m_cRefs = 1; 
    CoCreateFreeThreadedMarshaler( (IUnknown*)((IASPObjectContextImpl*)this), &m_pUnkFTM );
};

CASPDummyObjectContext::~CASPDummyObjectContext() 
{        
   if ( m_pUnkFTM != NULL )
    {
        m_pUnkFTM->Release();
        m_pUnkFTM = NULL;
    }    
};

   	//Non-delegating object IUnknown

	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // IASPObjectContext

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();
};




/*===================================================================
CASPDummyObjectContext::QueryInterface
CASPDummyObjectContext::AddRef
CASPDummyObjectContext::Release

IUnknown members for CASPDummyObjectContext object.

===================================================================*/
inline HRESULT CASPDummyObjectContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    if (IID_IUnknown == riid 
        || IID_IDispatch == riid 
        || IID_IASPObjectContext == riid)
        *ppv = static_cast<CASPDummyObjectContext *>(this);

    else if (IID_IMarshal == riid) {
        Assert( m_pUnkFTM != NULL );
        if ( m_pUnkFTM == NULL )
        {
            return E_UNEXPECTED;
        }
        return m_pUnkFTM->QueryInterface( riid, ppv );
    }

    //AddRef any interface we'll return.
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


inline STDMETHODIMP_(ULONG) CASPDummyObjectContext::AddRef(void) {
    return InterlockedIncrement(&m_cRefs);
}


inline STDMETHODIMP_(ULONG) CASPDummyObjectContext::Release(void) {

    LONG cRefs = InterlockedDecrement(&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
}

inline HRESULT CASPDummyObjectContext::SetAbort()
{
    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}

inline HRESULT CASPDummyObjectContext::SetComplete()
{
    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\templcap.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

File:			templcap.h
Maintained by:	DaveK
Component:		include file for CTemplate 'captive' classes
				'captive' == only used internally within CTemplate
	
==============================================================================*/

// forward refs
class CBuffer;
class CFileMap;
class DIR_MONTIOR_ENTRY;

/*	============================================================================
	Enum type:	SOURCE_SEGMENT
	Synopsis:	A contiguous segment of a source template, e.g. primary script, html, etc.
*/
enum SOURCE_SEGMENT
	{
	ssegHTML,
	ssegPrimaryScript,
	ssegTaggedScript,
	ssegObject,
	ssegInclude,
	ssegMetadata,
	ssegHTMLComment,
        ssegFPBot,
	};

/*	****************************************************************************
	Class:		CSourceInfo
	Synopsis:	Info on the source of an output

	NOTE: The target offsets are strictly increasing, so it is binary
	      searchable.  (This is good because this is the search key
	      used by the debugger workhorse API, GetSourceContextOfPosition)
	      Beware, however, that source offsets and line #s are not, in
	      general, binary searchable because of #include files being thrown
	      into the mix.

		TODO DBCS:
	      Both the corresponding byte AND character offsets for the source are
	      stored in this table.  Character offsets are used by all of the API
	      interfaces, but the GetText() API must know what byte offset corresponds
	      to a character offset.  To figure this out, GetText() looks for the
	      closest character offset in the file and uses that as its base for
	      figuring out the byte offset.
*/
class CSourceInfo
	{
	public:
		CFileMap *		m_pfilemap;			// filemap to source file
		unsigned		m_cchTargetOffset;	// target offset (target line # implicit)
		unsigned		m_cchSourceOffset;	// character offset of the source line
		unsigned		m_cchSourceText;	// # of characters in the source statement
		unsigned		m_idLine:31;		// line number in source file
		unsigned		m_fIsHTML:1;		// line number is start of HTML block

		// UNSAFE if virtual functions ever added to this class!
		CSourceInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CTargetOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
	            target offsets in the CSourceInfo array
*/
class CTargetOffsetOrder
	{
	public:
		BOOL operator()(const CSourceInfo &si, ULONG ul)
			{ return si.m_cchTargetOffset < ul; }

		BOOL operator()(ULONG ul, const CSourceInfo &si)
			{ return ul < si.m_cchTargetOffset; }
	};

/*	****************************************************************************
	Class:		CBuffer
	Synopsis:	A self-sizing memory buffer
*/
class CBuffer
	{
	private:
		CByteRange*	m_pItems;		// ptr to items (i.e. byte ranges)
		USHORT		m_cSlots;		// count of item slots allocated
		USHORT		m_cItems;		// count of items actually stored
		BYTE*		m_pbData;		// ptr to local data storage for items
		ULONG		m_cbData;		// size of local data storage for items
		ULONG		m_cbDataUsed;	// amount of local data storage actually used

	public:
		CBuffer();
		~CBuffer();
		void		Init(USHORT cItems, ULONG cbData);
		USHORT		Count()	{	return m_cItems;	}
		USHORT		CountSlots()	{	return m_cSlots;	}
		void		GetItem(UINT i, CByteRange& br);
		CByteRange* operator[](UINT i) { return &m_pItems[i]; }
		void		SetItem(UINT i, const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		void		Append(const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		LPSTR		PszLocal(UINT i);

        // Cache on per-class basis
        // ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CScriptStore
	Synopsis:	Working storage for script segments during compilation.

	Terminology
	-----------
	Engine		== a particular script engine (VBScript, JavaScript, etc)
	Segment		== a contiguous chunk of script text in the source file
*/
class CScriptStore
	{
public:
	CBuffer**		m_ppbufSegments;	// ptr to array of ptrs to script segment buffers, one per engine
	UINT			m_cSegmentBuffers;	// count of script segment buffers
	CBuffer			m_bufEngineNames;	// buffer of engine names, one per engine
	PROGLANG_ID* 	m_rgProgLangId;		// array of prog lang ids, one per engine
	
	CScriptStore(): m_ppbufSegments(NULL), m_cSegmentBuffers(0), m_rgProgLangId(NULL) {}
	~CScriptStore();
	HRESULT	Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);
	USHORT 	CountPreliminaryEngines() { return m_bufEngineNames.Count(); }
	HRESULT	AppendEngine(CByteRange& brEngine, PROGLANG_ID*	pProgLangId, UINT idSequence);
	USHORT 	IdEngineFromBr(CByteRange& brEngine, UINT idSequence);
	void	AppendScript(CByteRange& brScript, CByteRange& brEngine, BOOLB fPrimary, UINT idSequence, CFileMap* pfilemap);

	};

/*	****************************************************************************
	Class:		CObjectInfo
	Synopsis:	Information about an object which can be determined at compile time
*/
class CObjectInfo
	{
public:
	CLSID	    m_clsid;	// clsid
	CompScope	m_scope;	// scope: application, session, page
	CompModel	m_model;	// threading model: single, apt, free
	};

/*	****************************************************************************
	Class:		CObjectInfoStore
	Synopsis:	Working storage for object-infos during compilation.
*/
class CObjectInfoStore
	{
public:
	CObjectInfo*	m_pObjectInfos;		// array of object infos
	CBuffer			m_bufObjectNames;	// buffer of object names

	CObjectInfoStore(): m_pObjectInfos(NULL) {}
	~CObjectInfoStore();
	void	Init();
	void	AppendObject(CByteRange& brObjectName, CLSID clsid, CompScope scope, CompModel model, UINT idSequence);
	USHORT	Count() { return m_bufObjectNames.Count(); }

	};

/*	****************************************************************************
	Class:		CWorkStore
	Synopsis:	Working storage for template components
*/
class CWorkStore
	{
public:
	CBuffer				m_bufHTMLSegments;	// buffer of HTML segments
	CObjectInfoStore	m_ObjectInfoStore;	// object-infos store
	CScriptStore		m_ScriptStore;		// script store
	UINT				m_idCurSequence;	// sequence number for current segment
	CByteRange			m_brCurEngine;		// current script engine
	BOOLB				m_fPageCommandsExecuted;	// have we executed page-level @ commands yet?
	BOOLB				m_fPageCommandsAllowed;		// are we allowed to execute page-level @ commands?
													// (will be true iff we have not yet compiled any line of script)
	LPSTR				m_szWriteBlockOpen;			// open  for Response.WriteBlock() equivalent
	LPSTR				m_szWriteBlockClose;		// close for Response.WriteBlock() equivalent
	LPSTR				m_szWriteOpen;				// open  for Response.Write() equivalent
	LPSTR				m_szWriteClose;				// close for Response.Write() equivalent

	// Adding fields to maintain state of the line number calculations (Raid Bug 330171)
	BYTE*				m_pbPrevSource;				// pointer to the location of the last Calc line number call in source file
	UINT				m_cPrevSourceLines;			// corresponding line number to the previous call.
	HANDLE				m_hPrevFile;				// Corresponding file Handle. (Identifing a unique file)

	// Add fields to optimize on the calls to strlen. in CWriteTemplate
	UINT				m_cchWriteBlockOpen;		// size for open  for Response.WriteBlock() equivalent
	UINT				m_cchWriteBlockClose;		// size for close for Response.WriteBlock() equivalent
	UINT				m_cchWriteOpen;				// size for open  for Response.Write() equivalent
	UINT				m_cchWriteClose;			// size for close for Response.Write() equivalent

	
	
	
			CWorkStore();
			~CWorkStore();
	void 	Init();
	USHORT 	CRequiredScriptEngines(BOOL	fGlobalAsa);
	BOOLB 	FScriptEngineRequired(USHORT idEnginePrelim, BOOL	fGlobalAsa);

	};

/*	****************************************************************************
	Class:		CWriteTemplate
	Synopsis:	Class to calculate amount of memory required by the template in advance.
	Allocate the required amount and copy the template components into the contigous memory.
*/



class CWriteTemplate
{
    private:
        CWorkStore*	m_pworkStore;		// Pointer to the workstore. (could use m_pTempale->workStore) here.
        UINT		m_cbMemRequired;	// Counts the estimate (Accurate) of memory required by the template.
        CTemplate* 	m_pTemplate;		// Pointer to the enclosing template class..We require this to call methods of the template.
        BOOLB		m_fWriteScript;		// FALSE - Estimate, TRUE - Write
        CPINFO		m_codePageInfo;		// Code page Information...
        BOOL		m_fCalcLineNumber; // Stores metabase flag for calculation line number. TRUE = Calculate - FALSE = skip
		
        BYTE*		m_pbHeader;			// Pointer to the start of the template memory.

    public :		
        CWriteTemplate ();
        ~CWriteTemplate ();
        void 	Init (CWorkStore* pworkStore, CTemplate* pTemplate, BOOL fCalcLineNumber);
		
		
        void 	WriteScriptBlocks (USHORT  idEnginePrelim, USHORT  idEngine, UINT *pcbDataOffset, UINT    *pcbOffsetToOffset, BOOLB  m_fGlobalAsa);
        void 	WritePrimaryScript (USHORT idEngine, UINT *pcbDataOffset,  UINT cbScriptBlockOffset);
        void 	WriteTaggedScript (USHORT  idEngine, CFileMap* pfilemap, CByteRange brScript, UINT* pcbDataOffset, UINT cbScriptBlockOffset, BOOL fAllowExprWrite);
        void 	ScriptMemoryMinusEscapeChars (CByteRange brScript, UINT *pcbDataOffset, UINT cbPtrOffset);		

        void 	MemCopyAlign (UINT *pcbOffset, void *pbSource, ULONG cbSource, UINT cbByteAlign = 0);
        void 	MemCopyWithWideChar (UINT *pcbOffset, void   *pbSource, ULONG cbSource, UINT cbByteAlign );
        void 	WriteBSTRToMem (CByteRange & brWrite, UINT *pcbOffset );		

        void 	WriteTemplate ();
        void 	WriteTemplateComponents (); 
        void 	RemoveHTMLCommentSuffix(UINT cbStartOffset, UINT *pcbCurrentOffset);

};

/*	****************************************************************************
	Class:		COffsetInfo
	Synopsis:	map byte offsets to character offsets (different for DBCS)
				on line boundaries

	Each CFileMap has an array of these COffsetInfo structures at each line boundary.
	It stores these at the same offsets in the CSourceInfo array so that a simple
	binary search is all that's needed to convert offsets.
*/
class COffsetInfo
	{
	public:
		unsigned		m_cchOffset;		// character offset in file
		unsigned		m_cbOffset;			// byte offset in file

		// UNSAFE if virtual functions ever added to this class!
		COffsetInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CByteOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				byte offsets in the COffsetInfo array
*/
class CByteOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cbOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cbOffset; }
	};

/*	****************************************************************************
	Class:		CCharOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				character offsets in the COffsetInfo array
*/
class CCharOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cchOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cchOffset; }
	};

/*	****************************************************************************
	Class:		CFileMap
	Synopsis:	A memory-mapping of a file

	NOTE: We store an incfile-template dependency by storing an incfile ptr in m_pIncFile.
	This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CFileMap
	{
public:
	TCHAR *					m_szPathInfo;			// file's virtual path (from www root)
	TCHAR *					m_szPathTranslated;		// file's actual file system path
	union {											// NOTE: m_fHasSibling is used to disambiguate these two
		CFileMap*			m_pfilemapParent;		// ptr to filemap of parent file
		CFileMap*			m_pfilemapSibling;		// ptr to next filemap in same level of hierarchy
	};
	CFileMap*				m_pfilemapChild;		// index of first filemap in next lower level of hierarchy
	HANDLE					m_hFile;				// file handle
	HANDLE					m_hMap;					// file map handle
	BYTE*					m_pbStartOfFile;		// ptr to start of file
	CIncFile*				m_pIncFile;				// ptr to inc-file object
	PSECURITY_DESCRIPTOR	m_pSecurityDescriptor;	// ptr to file's security descriptor
	unsigned long			m_dwSecDescSize:30;		// size of security descriptor
	unsigned long			m_fHasSibling:1;		// Does a sibling exist for this node?
	unsigned long			m_fHasVirtPath:1;		// Is m_szPathInfo the virtual or physical path?
	unsigned long			m_fIsUNCPath:1;		    // Is m_szPathTranslated a UNC path?
    unsigned long			m_fIsEncryptedFile:1;   // Is this file encrypted?
	FILETIME	            m_ftLastWriteTime;		// last time the file was written to
	DWORD					m_cChars;				// # of characters in the file	
	vector<COffsetInfo>		m_rgByte2DBCS;			// line-by-line map of byte offsets to DBCS
	CDirMonitorEntry*		m_pDME;				// pointer to directory monitor entry for this file
	DWORD					m_dwFileSize;			// Size of file (cached)

				CFileMap();
				~CFileMap();
	void 		MapFile(LPCTSTR szFileSpec, LPCTSTR szApplnPath, CFileMap* pfilemapParent, BOOL fVirtual, CHitObj* pRequest, BOOL fGlobalAsp);
	void		RemapFile();
	void 		UnmapFile();

	CFileMap*	GetParent();
	void		SetParent(CFileMap *);

	void		AddSibling(CFileMap *);
	CFileMap*	NextSibling() { return m_fHasSibling? m_pfilemapSibling : NULL; }

	BOOL		FIsMapped()
					{ return m_pbStartOfFile != NULL; }

	BOOL		FHasVirtPath() 
					{ return m_fHasVirtPath; }

	BOOL		FHasUNCPath() 
					{ return m_fIsUNCPath; }

	BOOL		FIsEncryptedFile() 
					{ return m_fIsEncryptedFile; }

	BOOL		FCyclicInclude(LPCTSTR szPathTranslated);
	BOOL		GetSecurityDescriptor();
	DWORD      GetSize() {	return m_dwFileSize;}					// return # of bytes
	DWORD		CountChars(WORD wCodePage);							// return # of chars

	// implementation of debugging iterface - CTemplate & CIncFile eventually delegate to this function
	HRESULT		GetText(WORD wCodePage, ULONG cchSourceOffset, WCHAR *pwchText, SOURCE_TEXT_ATTR *pTextAttr, ULONG *pcChars, ULONG cMaxChars);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CTokenList
	Synopsis:	A list of tokens.
*/
class CTokenList
{
public:
	/*	========================================================================
	Enum type:	TOKEN
	Synopsis:	Token type.
				NOTE: keep sync'ed with CTokenList::Init()
	*/
	enum TOKEN
	{
		//======== Opener tokens ==================================
		tknOpenPrimaryScript,	// open primary script segment
		tknOpenTaggedScript,	// open tagged script segment
		tknOpenObject,			// open object segment
		tknOpenHTMLComment,		// open HTML comment
		
		//======== Non-opener tokens ==============================
		tknNewLine,				// new line

		tknClosePrimaryScript,	// close primary script segment
		tknCloseTaggedScript,	// close primary script segment
		tknCloseObject,			// close object segment
		tknCloseHTMLComment,	// close HTML comment
		tknEscapedClosePrimaryScript,	// escaped close-primary-script symbol

		tknCloseTag,			// close object or script tag

		tknCommandINCLUDE,		// server-side include (SSI) INCLUDE command
		
		tknTagRunat,			// RUNAT script/object attribute
		tknTagLanguage,			// LANGUAGE tag: page-level compiler directive or script block attribute
		tknTagCodePage,			// CODEPAGE tag: page-level compiler directive
		tknTagLCID,				// LCID tag: page-level compiler directive
		tknTagTransacted,		// TRANSACTED tag: page-level compiler directive
		tknTagSession,		    // SESSION tag: page-level compiler directive
		tknTagID,				// ID object attribute
		tknTagClassID,			// CLASSID object attribute
		tknTagProgID,			// PROGID object attribute
		tknTagScope,			// SCOPE object attribute
		tknTagVirtual,			// VIRTUAL include file attribute
		tknTagFile,				// FILE include file attribute
		tknTagMETADATA,			// METADATA tag - used by IStudio
//		tknTagSetPriScriptLang,	// sets primary script language, as in <% @ LANGUAGE = VBScript %>
        tknTagName,             // NAME inside METADATA
		tknValueTypeLib,        // TypeLib inside METADATA (has to be before TYPE in the list)
        tknTagType,             // TYPE inside METADATA
        tknTagUUID,             // UUID inside METADATA
        tknTagVersion,          // VERSION inside METADATA
        tknTagStartspan,        // STARTSPAN inside METADATA
        tknTagEndspan,          // ENDSPAN inside METADATA
        tknValueCookie,         // TYPE=Cookie inside METADATA
        tknTagSrc,              // SRC= inside METADATA
		
		tknValueServer,			// Server value - e.g. RUNAT=Server
		tknValueApplication,	// SCOPE=Application
		tknValueSession,		// SCOPE=Session
		tknValuePage,			// SCOPE=Page

		tknVBSCommentSQuote,	// VBS comment symbol
		tknVBSCommentRem,		// VBS comment symbol (alternate)

        tknTagFPBot,            // Front Page webbot tag
		
		tknEOF,					// end-of-file pseudo-token

		tkncAll					// pseudo-token: count of all tokens
	};

	void		Init();
	CByteRange* operator[](UINT i) { return m_bufTokens[i]; }
	CByteRange* operator[](TOKEN tkn) { return operator[]((UINT) tkn); }
	void		AppendToken(TOKEN	tkn, char* psz);
	TOKEN		NextOpenToken(CByteRange& brSearch, TOKEN* rgtknOpeners, UINT ctknOpeners, BYTE** ppbToken, LONG lCodePage);
	void		MovePastToken(TOKEN tkn, BYTE* pbToken, CByteRange& brSearch);
	BYTE*		GetToken(TOKEN tkn, CByteRange& brSearch, LONG lCodePage);

public:
	CBuffer		m_bufTokens;	// tokens buffer
};

/*	****************************************************************************
	Class:		CDocNodeElem
	Synopsis:	contains a pair of document nodes & application it belongs to
*/
class CDocNodeElem : public CDblLink
{
public:
	CAppln                *m_pAppln;
//	IDebugApplicationNode *m_pFileRoot;					// root of directory hierarchy
	IDebugApplicationNode *m_pDocRoot;					// root of template document hierarchy

	// ctor
	CDocNodeElem(CAppln *pAppln, /*IDebugApplicationNode *pFileRoot,*/ IDebugApplicationNode *pDocRoot);

	// dtor
	~CDocNodeElem();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\util.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: AndrewS

This file contains random useful utility functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "MemChk.h"
#include "locale.h"
#include <malloc.h>
#include <mbstring.h>
#include <mbctype.h>
#include "iisdef.h"

extern  CPINFO  g_SystemCPInfo;     // global System CodePage default info.

// ***************************************************************************
// M I S C
// ***************************************************************************

/*===================================================================
Server_ValSize
Server_FindKey

This helper function assists in the implementation of the
SERVER_GET macro

Parameters:
    PIReq        pointer to CIsapiReqInfo
    szBuffer    Buffer to write to
    pdwBufLen   On entry: size of the buffer
                On Exit, actual size of the buffer
                    (required size if buffer was too small)
    szKey       Key to search for

Returns:
    TRUE - it succeeded, string in szBuffer
    FALSE - buffer was too small, *pdwBufLen has required size
===================================================================*/
BOOL Server_FindKey
(
CIsapiReqInfo *PIReq,
char *szBuffer,
DWORD *pdwBufLen,
const char *szKey
)
    {
    // If no buffer, then just calculate the size (old behavior)
    Assert (szBuffer != NULL);

    if (PIReq && PIReq->GetServerVariableA(const_cast<char *>(szKey), szBuffer, pdwBufLen))
        return TRUE;

    szBuffer[0] = '\0';

    // Bug 965: If malicious request comes, do not _alloca, and pretend like we
    //          didn't get anything.  This is OK - the rest of Denali will just assume
    //          there were no cookies, request parameters or client headers.
    //
    if (!PIReq || GetLastError() == ERROR_INVALID_INDEX || *pdwBufLen > REQUEST_ALLOC_MAX)
        {
        *pdwBufLen = 1;
        return TRUE;
        }

    return FALSE;
    }


/*===================================================================
 * F i n d A p p l i c a t i o n P a t h
 *
 * Get application path from CIsapiReqInfo. It gets the metabase key and
 * strips it of prefix.
 *
 * Parameters:
 *    PIReq      - CIsapiReqInfo
 *    pszPath   - [out] the application path (URL)
 *
 * Returns:
 *    HRESULT
 *
 * Allocates pszPath using malloc()
===================================================================*/
HRESULT FindApplicationPath
(
CIsapiReqInfo *PIReq,
TCHAR *szPath,
int cbPath
)
    {
    if (!PIReq)
        return E_FAIL;

    // Extract virtual path from the metabase path
    TCHAR *pch = NULL;
    int   cch = 0;

    // Get the metabase path
    TCHAR *szMDPath = PIReq->QueryPszApplnMDPath();
    if (szMDPath)
        {
        Assert(szMDPath[0] == _T('/'));

        pch = szMDPath;

        // find 4th '/' in "/LM/w3svc/X/root/vroot" after starting '/'
        for (int i = 0; i < 4 && pch != NULL; i++)
            pch = _tcschr(pch+1, _T('/'));

        if (pch)
            cch = _tcslen(pch);
        else
            cch = 1;  // special case of default app -- assume /
        }
    else
        {
        // assume /
        pch = NULL;
        cch = 1;
        }

    if (cch >= (int)(cbPath/sizeof(TCHAR)))
        return E_FAIL;

    _tcscpy(szPath, pch ? pch : _T("/"));

    // remove trailing / if any
    if (cch > 1)
        {
        pch = &szPath[cch - 1];
        if (*pch == _T('/'))
            *pch = _T('\0');
        }

    return S_OK;
    }

/*===================================================================
VariantResolveDispatch

    Convert an IDispatch VARIANT to a (non-Dispatch) VARIANT by
    invoking its default property until the object that remains
    is not an IDispatch.  If the original VARIANT is not an IDispatch
    then the behavior is identical to VariantCopyInd(), with the
    exception that arrays are copied.

Parameters:
    pVarOut      - if successful, the return value is placed here
    pVarIn       - the variant to copy
    GUID *iidObj - the calling interface (for error reporting)
    nObjID       - the Object's name from the resource file

    pVarOut need not be initialized.  Since pVarOut is a new
    variant, the caller must VariantClear this object.

Returns:
    The result of calling IDispatch::Invoke.  (either S_OK or
    the error resulting from the call to Invoke)   may also return
    E_OUTOFMEMORY if an allocation fails

    This function always calls Exception() if an error occurs -
    this is because we need to call Exception() if an IDispatch
    method raises an exception.  Instead of having the client
    worry about whether we called Exception() on its behalf or
    not, we always raise the exception.
===================================================================*/

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjID)
    {
    VARIANT     varResolved;        // value of IDispatch::Invoke
    DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0};
    EXCEPINFO   ExcepInfo;
    HRESULT     hrCopy;

    Assert (pVarIn != NULL && pVarOut != NULL);

    VariantInit(pVarOut);
    if (V_VT(pVarIn) & VT_BYREF)
        hrCopy = VariantCopyInd(pVarOut, pVarIn);
    else
        hrCopy = VariantCopy(pVarOut, pVarIn);

    if (FAILED(hrCopy))
        {
        ExceptionId(iidObj, nObjID, (hrCopy == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrCopy;
        }

    // follow the IDispatch chain.
    //
    while (V_VT(pVarOut) == VT_DISPATCH)
        {
        HRESULT hrInvoke = S_OK;

        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        //
        if (V_DISPATCH(pVarOut) == NULL)
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        else
            {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                                                DISPID_VALUE,
                                                IID_NULL,
                                                LOCALE_SYSTEM_DEFAULT,
                                                DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                                                &dispParamsNoArgs,
                                                &varResolved,
                                                &ExcepInfo,
                                                NULL);
            }

        if (FAILED(hrInvoke))
            {
            if (hrInvoke == DISP_E_EXCEPTION)
                {
                //
                // forward the ExcepInfo from Invoke to caller's ExcepInfo
                //
                Exception(iidObj, ExcepInfo.bstrSource, ExcepInfo.bstrDescription);
                SysFreeString(ExcepInfo.bstrHelpFile);
                }

            else
                ExceptionId(iidObj, nObjID, IDE_UTIL_NO_VALUE);

            VariantClear(pVarOut);
            return hrInvoke;
            }

        // The correct code to restart the loop is:
        //
        //      VariantClear(pVar)
        //      VariantCopy(pVar, &varResolved);
        //      VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //      VariantClear(pVar)
        //      *pVar = varResolved;
        //      VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next interation of the loop will do the VariantInit.
        //
        VariantClear(pVarOut);
        *pVarOut = varResolved;
        }

    return S_OK;
    }

/*===================================================================
VariantGetBSTR

    Gets BSTR from the variant (does one possible indirection)

Parameters:
    var          - VARIANT

Returns:
    BSTR or NULL if none
===================================================================*/
BSTR VariantGetBSTR(const VARIANT *pvar)
    {
    if (V_VT(pvar) == VT_BSTR)                      // straight BSTR
        return V_BSTR(pvar);

    if (V_VT(pvar) == (VT_BYREF|VT_VARIANT))
        {
        VARIANT *pvarRef = V_VARIANTREF(pvar);      // Variant by ref
        if (pvarRef && V_VT(pvarRef) == VT_BSTR)
            return V_BSTR(pvarRef);
        }

    return NULL;
    }

/*===================================================================
Normalize

    Converts a filename IN PLACE to a normalized form so that we don't
    cache identical files with different names (i.e. Foo, foo,
    .\foo, etc)

Algorithm:
    The file is translated to uppercase and forward slash (/)
    characters are converted to backward slash (\)

Return Value:
    cch of normalized string
Note:  This function is used for PathInfo only, and using system ANSI codepage.
===================================================================*/
int Normalize
(
TCHAR *   szSrc  // source string
)
    {
    BOOL    fReturn;

    Assert(szSrc != NULL);

    TCHAR *szTemp = szSrc;

    int cchRet = _tcslen(szSrc);

    _tcsupr(szTemp);

    szTemp = szSrc;
    while (*szTemp)
    {
        if (*szTemp == _T('/'))
            *szTemp = _T('\\');
        szTemp = CharNext(szTemp);
    }

    return cchRet;
}


#ifdef DBG
BOOLB IsNormalized(const TCHAR *sz)
    {
    while (*sz) {
#if !UNICODE
        if (_istlower(*sz))
            return FALSE;
#endif
        if (*sz == _T('/'))
            return FALSE;
        sz = CharNext(sz);
    }
    return TRUE;
}
#endif  // DBG

/*===================================================================
HTMLEncodeLen

HTML Encode len returns an int representing the string size
required to HTMLEncode a string.

Note: This returned value might be exceeds the actually string size needed to
HTMLEncode a string.(since we are going to drop the leading zeros in &#00257;
case.,
the returned value includes the 2 chars for the leading zeros)

Parameters:
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    int storage required to encode string.
===================================================================*/
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    int nstrlen = 1;        // Add NUL space now
    int i       = 0;

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //

        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            nstrlen += 2;
            }

        // Japanese only.
        // Do not encode if character is half-width katakana character.
        // We should use GetStringTypeA to detect half-width katakana char instead of _ismbbkana()???
        // (I used _ismbbkana at this time for performance reason...)
        //
        else if ((uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932 ) && _ismbbkana(*szSrc))
            {
            nstrlen++;
            }

        // Special case character encoding
        //
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 4;

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 5;

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                nstrlen++;
            else
                nstrlen += 6;

        // According RFC, if character code is greater than equal 0x80, encode it.
        //
        // Note: For &#00257;, we might drop the leading zeros, therefore, we are not
        // going to use all 8 chars.  We will need only 6 digits in this case.(&#257;).
        // We need at most 8 chars.
        else if ( bstrIn && (bstrIn[i] >= 0x80) )
       		{
   		    nstrlen += 8;
       		}
		else if ((unsigned char)*szSrc >= 0x80 )
			{
			nstrlen += 6;
            }
        else
            {
            nstrlen++;
            }


       	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);
		i++;
        }

    return nstrlen;
    }

/*===================================================================
HTMLEncode

HTML Encode a string containing the following characters

less than           <       &lt;
greater than        >       &gt;
ampersand           &       &amp;
quote               "       &quot;
any Ascii           ?       &#xxx   (where xxx is the ascii char val)

Parameters:
    szDest - Pointer to the buffer to store the HTMLEncoded string
    szSrc  - Pointer to the source buffer
    fEncodeExtCharOnly - FALSE, Normal encoding
                 TRUE, encodes extended chars, does not encode '<', '>', '&',
and '"'.
    uCodePage - system code page

Returns:
    A pointer to the NUL terminated string.
===================================================================*/
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly)
    {
    char *pszDest = szDest;
	int   i       = 0;

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return pszDest;
        }

    while (*szSrc)
        {
        //
        // The original condition is unsuitable for DBCS.
        // It is possible that new one allows to encode extended character
        // even if running system is DBCS.
        //
		// if Unicode is latin-1 area(<0x100), skip to check DBCS
		// bstrIn == NULL to handle the case were HTMLEncode is called internally
		// and bstrIn is NULL
		//
        // if bstrIn == NULL, chech DBCS
        // if bstrIn != NULL and Unicode is latin-1 area(<0x100), check DBCS
        // else skip to check DBCS
        if (!(bstrIn && bstrIn[i] < 0x100) && ::IsDBCSLeadByteEx(uCodePage, (BYTE)*szSrc))	
            {
            // this is a DBCS code page do not encode the data copy 2 bytes
            // no incremnt because of using CharNextExA at the end of the loop
            *szDest++ = *szSrc;
            *szDest++ = *(szSrc + 1);
            }
        //
        // Japanese only.
        // Do not encode if character is half-width katakana character.
        //
        else if ( (uCodePage == 932 || uCodePage == CP_ACP && ::GetACP() == 932) && _ismbbkana(*szSrc))
            {
            *szDest++ = *szSrc;
            }

        // Special case character encoding
        else if (*szSrc == '<')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&lt;");

        else if (*szSrc == '>')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&gt;");

        else if (*szSrc == '&')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&amp;");

        else if (*szSrc == '"')
            if (fEncodeExtCharOnly)
                *szDest++ = *szSrc;
            else
                szDest = strcpyExA(szDest, "&quot;");

        // According RFC, if character code is greater than equal 0x80, encode it.
        //
	    // BUG 153089 - WideCharToMultiByte would incorrectly convert some
	    // characters above the range of 0x80 so we now use the BSTR as our source
	    // to check for characters that should be encoded.
	    //
	    else if ( bstrIn && (bstrIn[i] >= 0x80))
	    {
            DWORD dwTemp;

	      	// Check if the bstrIn currently points to a surrogate Pair
	      	// Surrogate pairs would account for 2 bytes in the BSTR.
            // High Surrogate = U+D800 <==> U+DBFF
            // Low Surrogate = U+DC00 <==> U+DFFF
	      	if (IsSurrogateHigh( bstrIn[i] ) 	// Check the higher byte.
	      	    && IsSurrogateLow( bstrIn[i+1])) // Check the lower byte too.
	      	{	     	
                dwTemp = (((bstrIn[i] & 0x3ff) << 10) | (bstrIn[i+1] & 0x3ff)) + 0x10000;
	      	    i++; // Increment bstrIn index as surrogatepair was detected.
            } else {
                dwTemp = bstrIn[i];
            }

  	        *szDest++ = '&';
  	        *szDest++ = '#';
	      	
            _ultoa( dwTemp, szDest, 10 );
            szDest += strlen( szDest );

   	     	*szDest++ = ';';     	     		     	      	     	
	    }
	    else if ((unsigned char)*szSrc >= 0x80)
	      	{
	      	// Since this is unsigned char casting, the value of WORD wTemp
	      	// is not going to exceed 0xff(255).  So, 3 digit is sufficient here.
	      	WORD wTemp = (unsigned char)*szSrc;

	        *szDest++ = '&';
	        *szDest++ = '#';
	        for (WORD Index = 100; Index > 0; Index /= 10)
	        	{
	       		*szDest++ = ((unsigned char) (wTemp / Index)) + '0';
	       		wTemp = wTemp % Index;
		       	}
  	     	*szDest++ = ';';
    	    }
       else
            *szDest++ = *szSrc;

    	// increment szSrc and i (they must be kept in sync)
		szSrc = AspCharNextA(WORD(uCodePage), szSrc);
    	
		i++;	// Regular increment of the bstrIn index.
        }

    *szDest = '\0';
    return pszDest;
    }

/*===================================================================
strcpyExA

Copy one string to another, returning a pointer to the NUL character
in the destination

Parameters:
    szDest - pointer to the destination string
    szSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/
char *strcpyExA(char *szDest, const char *szSrc)
    {
    while (*szDest++ = *szSrc++)
        ;

    return szDest - 1;
    }



/*===================================================================
strcpyExW

Copy one wide string to another, returning a pointer to the NUL character
in the destination

Parameters:
    wszDest - pointer to the destination string
    wszSrc - pointer to the source string

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

wchar_t *strcpyExW(wchar_t *wszDest, const wchar_t *wszSrc)
    {
    while (*wszDest++ = *wszSrc++)
        ;

    return wszDest - 1;
    }



/*===================================================================
URLEncodeLen

Return the storage requirements for a URL-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        if (*szSrc & 0x80)              // encode foreign characters
            cbURL += 3;

        else if (*szSrc == ' ')         // encoded space requires only one character
            ++cbURL;

        else if (!isalnum((UCHAR)(*szSrc)))  // encode non-alphabetic characters
            cbURL += 3;

        else
            ++cbURL;

        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
URLEncode

URL Encode a string by changing space characters to '+' and escaping
non-alphanumeric characters in hex.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if (*szSrc == ' ')
            {
            *szDest++ = '+';
            ++szSrc;
            }
        else if ( (*szSrc & 0x80) || !isalnum((UCHAR)(*szSrc)) )
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }



/*===================================================================
DBCSEncodeLen

Return the storage requirements for a DBCS encoded string
(url-encoding of characters with the upper bit set ONLY)

Parameters:
    szSrc  - Pointer to the string to URL Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int DBCSEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // add terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while (*szSrc)
        {
        cbURL += ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))? 3 : 1;
        ++szSrc;
        }

    return cbURL;
    }



/*===================================================================
DBCSEncode

DBCS Encode a string by escaping characters with the upper bit
set - Basically used to convert 8 bit data to 7 bit in contexts
where full encoding is not needed.

Parameters:
    szDest - Pointer to the buffer to store the URLEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *DBCSEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while (*szSrc)
        {
        if ((*szSrc & 0x80) || (!isalnum((UCHAR)(*szSrc)) && !strchr("/$-_.+!*'(),", *szSrc)))
            {
            *szDest++ = '%';
            *szDest++ = hex[BYTE(*szSrc) >> 4];
            *szDest++ = hex[*szSrc++ & 0x0F];
            }

        else
            *szDest++ = *szSrc++;
        }

    *szDest = '\0';
    return szDest;
    }


/*===================================================================
URLPathEncodeLen

Return the storage requirements for a URLPath-Encoded string

Parameters:
    szSrc  - Pointer to the string to URL Path Encode

Returns:
    the number of bytes required to encode the string
===================================================================*/

int URLPathEncodeLen(const char *szSrc)
    {
    int cbURL = 1;      // count terminator now

    // Bug 97049 return 0 on NULL instead of crashing
    if (!szSrc)
        return 0;

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                ++cbURL;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || // encode non-alphabetic characters
                    (*szSrc & 0x80))    // encode foreign characters
                    cbURL += 3;
                else
                    ++cbURL;
            }
        ++szSrc;
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            ++cbURL;
            ++szSrc;
            }
        }

    return cbURL;
    }



/*===================================================================
URLPathEncode

Encodes the path portion of a URL.  All characters up to the first
'?' are encoded with the following rules:
    o Charcters that are needed to parse the URL are left alone:
        '/' '.' ':' '@' '#' '*' '!'
    o Non-foreign alphanumberic characters are left alone
    o Anything else is escape encoded
Everything after the '?' is ignored.

Parameters:
    szDest - Pointer to the buffer to store the URLPathEncoded string
    szSrc  - Pointer to the source buffer

Returns:
    A pointer to the NUL terminator is returned.
===================================================================*/

char *URLPathEncode(char *szDest, const char *szSrc)
    {
    char hex[] = "0123456789ABCDEF";

    // Bug 97049 return on NULL instead of crashing
    if (!szDest)
        return NULL;
    if (!szSrc)
        {
        *szDest = '\0';
        return szDest;
        }

    while ((*szSrc) && (*szSrc != '?'))
        {
        switch (*szSrc)
            {
            // Ignore safe characters
            case '$' :  case '_' :  case '-' :
            case '+' :  case '.' :  case '~' :
            case '&' :
            // Ignore URL syntax elements
            case '/' :  case ':' :  case '@' :
            case '#' :  case '*' :  case '!' :
                *szDest++ = *szSrc++;
                break;

            default:
                if (!isalnum((UCHAR)(*szSrc)) || (*szSrc & 0x80))
                    {
                    *szDest++ = '%';
                    *szDest++ = hex[BYTE(*szSrc) >> 4];
                    *szDest++ = hex[*szSrc++ & 0x0F];
                    }
                else
                    *szDest++ = *szSrc++;
            }
        }

    if (*szSrc == '?')
        {
        while (*szSrc)
            {
            *szDest++ = *szSrc++;
            }
        }

    *szDest = '\0';

    return szDest;
    }



// ***************************************************************************
// T I M E    C O N V E R S I O N    S U P P O R T
// ***************************************************************************

/*===================================================================
CTimeToVariantDate

Converts a time_t structure to a Variant Date structure

Parameters:
    ptNow     - date & time to convert
    pdtResult - DATE output of this function

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult)
    {
    struct tm *ptmNow = localtime(ptNow);
    if (ptmNow == NULL)
        return E_FAIL;

    return
        DosDateTimeToVariantTime(
                ptmNow->tm_mday | ((ptmNow->tm_mon + 1) << 5) | ((ptmNow->tm_year - 80) << 9),
                (unsigned(ptmNow->tm_sec) >> 1) | (ptmNow->tm_min << 5) | (ptmNow->tm_hour << 11),
                pdtResult);
    }



/*===================================================================
VariantDateToCTime

Converts a variant date to a time_t structure used by the "C"
language

Parameters:
    dt       - date to convert to "time_t"
    ptResult - pointer to result which has the value

Returns:
    E_FAIL if things go wrong.
===================================================================*/

HRESULT VariantDateToCTime(DATE dt, time_t *ptResult)
    {
    // Convert the variant time to a documented time format
    //
    unsigned short wDOSDate, wDOSTime;
    if (! VariantTimeToDosDateTime(dt, &wDOSDate, &wDOSTime))
        return E_FAIL;

    // populate a "tm" struct
    //
    struct tm tmConverted;

    tmConverted.tm_sec   = (wDOSTime & 0x1F) << 1;
    tmConverted.tm_min   = (wDOSTime >> 5) & 0x3F;
    tmConverted.tm_hour  = wDOSTime >> 11;
    tmConverted.tm_mday  = wDOSDate & 0x1F;
    tmConverted.tm_mon   = ((wDOSDate >> 5) & 0x0F) - 1;
    tmConverted.tm_year  = (wDOSDate >> 9) + 80;    // adjust for offset from 1980
    tmConverted.tm_isdst = -1;

    // convert the "tm" struct to the number of seconds since Jan 1, 1980
    //
    *ptResult = mktime(&tmConverted);
    return (*ptResult == -1)? E_FAIL : S_OK;
    }



/*===================================================================
CTimeToStringGMT

Converts a C language time_t to a string of the form:

    "Wed, 09-Nov-1999 23:12:40 GMT"

Parameters:
    ptNow    - the time to convert
    szBuffer - pointer to the destination buffer

Returns:
    E_FAIL if something goes wrong

Notes:
    The longest day of the week (in terms of spelling) is "Wednesday";
    the other fields are fixed length. This means that we can
    guarantee the maximum length of szBuffer - there is no need
    for client code to dynamically allocate a buffer.
===================================================================*/
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // The internet standard explicitly says that
    // month and weekday names are in english.
    const char rgstrDOW[7][4] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
    const char rgstrMonth[12][4] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    // convert time to GMT
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        {
        return E_FAIL;
        }

    // send output in internet format
    const char *szDateFormat = fFunkyCookieFormat?
                  "%s, %02d-%s-%d %02d:%02d:%02d GMT"
                : "%s, %02d %s %d %02d:%02d:%02d GMT";

    sprintf(szBuffer, szDateFormat, rgstrDOW[ptmGMT->tm_wday], ptmGMT->tm_mday,
                rgstrMonth[ptmGMT->tm_mon], ptmGMT->tm_year+1900,
                ptmGMT->tm_hour, ptmGMT->tm_min, ptmGMT->tm_sec);

    return S_OK;
    }

/*
// there is a bug in the C-runtime function strftime that will cause
// an AV on the ALPHA on multi-threaded stress the function has been
// re-written to work around this problem
//
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat)
    {
    // convert time to GMT
    //
    struct tm *ptmGMT = gmtime(ptNow);
    if (ptmGMT == NULL)
        return E_FAIL;

    // Set locale to "C" locale.  The internet standard explicitly says that
    // month and weekday names are in english.
    //
    char *lcTimeCurrent = setlocale(LC_TIME, "C");
    if (lcTimeCurrent == NULL)
        return E_FAIL;

    // send output in internet format
    //
    const char *szDateFormat = fFunkyCookieFormat?
                                      "%a, %d-%b-%Y %H:%M:%S GMT"
                                    : "%a, %d %b %Y %H:%M:%S GMT";

    strftime(szBuffer, DATE_STRING_SIZE, szDateFormat, ptmGMT);

    // Restore locale
    //
    if (! setlocale(LC_TIME, lcTimeCurrent))
        return E_FAIL;

    // done
    return S_OK;
    }
*/


// ***************************************************************************
// W I D E    C H A R A C T E R    S U P P O R T
// ***************************************************************************

/*============================================================================
WstrToMBstrEx

Copies a wide character string into an ansi string.

Parameters:
    LPSTR dest      - The string to copy  into
    LPWSTR src      - the input BSTR
    cchBuffer      - the number of CHARs allocated for the destination string.
    lCodePage       - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT WstrToMBstrEx(LPSTR dest, INT cchDest, LPCWSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, cchDest, NULL, NULL);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, 0, NULL, NULL);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }

/*============================================================================
MBstrToWstrEx

Copies a ansi string into an wide character string.

Parameters:
    LPWSTR dest    - The string to copy  into
    LPSTR src      - the input ANSI string
    cchDest        - the number of Wide CHARs allocated for the destination string.
    cchSrc         - the length of the source ANSI string
    lCodePage      - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT MBstrToWstrEx(LPWSTR dest, INT cchDest, LPCSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    DBG_ASSERT(cchDest > 0);

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, cchDest);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, 0);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;
            }
        else
            {
            DBG_ASSERT(FALSE);
            DBGERROR((DBG_CONTEXT, "Last error is %d\n", GetLastError()));
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add
        // it and bump the count.

        dest[cch++] = '\0';
        }

    DBG_ASSERT(cch != 0);
    return cch;
    }


/*============================================================================
SysAllocStringFromSz

Allocate a System BSTR and copy the given ANSI string into it.

Parameters:
    sz              - The string to copy (Note: this IS an "sz", we will stop at the first NULL)
    cch             - the number of ANSI characters in szT.  If 0, will calculate size.
    BSTR *pbstrRet  - the returned BSTR
    lCodePage       - the codepage for conversion

Returns:
    Allocated BSTR in return value
    S_OK on success, E_OUTOFMEMORY on OOM

Side effects:
    Allocates memory.  Caller must deallocate
============================================================================*/
HRESULT SysAllocStringFromSz
(
CHAR *sz,
DWORD cch,
BSTR *pbstrRet,
UINT lCodePage
)
    {
    BSTR bstrRet;

    Assert(pbstrRet != NULL);

    if (sz == NULL)
        {
        *pbstrRet = NULL;
        return(S_OK);
        }

    // initialize this because callers look at this to see if the routine was
    // successful

    *pbstrRet = NULL;

    // If they passed 0, then determine string length
    if (cch == 0)
        cch = strlen(sz);

    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space
    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
        return(E_OUTOFMEMORY);

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MulitByteToWideChar for DBCS support
    if (cch != 0)
        {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(lCodePage, 0, sz, -1, bstrRet, cch+1) == 0)
        {
            SysFreeString(bstrRet);

            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count,
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr)
        // = 1, not 2.
        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
            {
            BSTR bstrTemp = SysAllocString(bstrRet);
            SysFreeString(bstrRet);
			if (bstrTemp == NULL)
				return(E_OUTOFMEMORY);
            bstrRet = bstrTemp;
            cch = cchTemp;
            }
        }
    bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(S_OK);
    }

/*============================================================================
StringDupA

Duplicate a string.  An empty string will only be duplicated if the fDupEmpty
flag is set, else a NULL is returned.

Parameter
    CHAR *pszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupA
(
CHAR    *pszStrIn,
BOOL    fDupEmpty
)
    {
    CHAR *pszStrOut;
    INT  cch, cBytes;

    if (NULL == pszStrIn)
        return NULL;

    cch = strlen(pszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(CHAR) * (cch+1);
    pszStrOut = (CHAR *)malloc(cBytes);
    if (NULL == pszStrOut)
        return NULL;

    memcpy(pszStrOut, pszStrIn, cBytes);
    return pszStrOut;
    }

/*============================================================================
StringDupW

Same as StrDup but for WCHAR strings

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

WCHAR *StringDupW
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    WCHAR *pwszStrOut;
    INT  cch, cBytes;

    if (NULL == pwszStrIn)
        return NULL;

    cch = wcslen(pwszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(WCHAR) * (cch+1);
    pwszStrOut = (WCHAR *)malloc(cBytes);
    if (NULL == pwszStrOut)
        return NULL;

    memcpy(pwszStrOut, pwszStrIn, cBytes);
    return pwszStrOut;
}


/*============================================================================
StringDupUTF8

Same as StrDup but for WCHAR strings that need to be Dup'd to UTF8

Parameter
    WCHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated UTF8 string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StringDupUTF8
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
{
    CWCharToMBCS convStr;

    if ((pwszStrIn == NULL) || (*pwszStrIn == L'\0')) {

        goto returnEmpty;
    }

    if (FAILED(convStr.Init(pwszStrIn))) {
        goto returnEmpty;
    }
    else {

        CHAR *pRetStr = convStr.GetString(TRUE);

        if (!pRetStr)
            goto returnEmpty;

        return pRetStr;
    }

returnEmpty:

    if (fDupEmpty)
        return StringDupA(NULL, TRUE);
    else
        return NULL;
}
/*===================================================================
CbWStr

Get byte length of WCHAR string (needed to manipulate hash keys)

Parameter
    LPWSTR pwszString   WCHAR string

Returns
    length in bytes
===================================================================*/
DWORD CbWStr
(
WCHAR *pwszString
)
    {
    return (pwszString ? (sizeof(WCHAR) * wcslen(pwszString)) : 0);
    }


/*===================================================================
DotPathToPath

This function offers support for parent path translation. for example
szFileSpec = "../foo/bar.asp"
szParentDirectory = "/scripts/more/stuff"

result = "/scripts/more/foo/bar.asp"

Parameter
    char *szDest                        - destination string
    const char *szFileSpec              - input path mask
    const char *szParentDirectory       - path to map from

Notes
    No more than "MAX_PATH" bytes are written into szDest.
    Returns FALSE when this happens.

Returns
    int TRUE/FALSE
===================================================================*/
BOOL
DotPathToPath
(
TCHAR *szDest,
const TCHAR *szFileSpec,
const TCHAR *szParentDirectory
)
{

    STACK_BUFFER( tempFileSpec, MAX_PATH );

    if (szFileSpec[0] == _T('\0')) {
        if (_tcslen (szParentDirectory) >= MAX_PATH)
            return FALSE;

        _tcscpy(szDest, szParentDirectory);
        return TRUE;
    }

    if (szFileSpec[0] == _T('/') || szFileSpec[0] == _T('\\'))
        return FALSE;

    // Make a copy of the FileSpec to allow for
    //    a. szDest == szFileSpec (inplace) should work
    //    b. Algorithm below works if szFileSpec ends with a '/' (or '\\')
    //

    if (!tempFileSpec.Resize((_tcslen(szFileSpec) + 2)*sizeof(TCHAR))) {
        return FALSE;
    }

    TCHAR *szFileSpecT = (TCHAR *)(tempFileSpec.QueryPtr());
    TCHAR *szT = strcpyEx(szFileSpecT, szFileSpec);
    szT = CharPrev(szFileSpecT, szT);
    if( *szT != _T('/') && *szT != _T('\\')) {
        szT = CharNext(szT);
        *szT++ = _T('/');
        *szT = _T('\0');
    }

    // Initialize "cchDest" - count of characters in destination
    int cchDest = _tcslen(szParentDirectory) + 1;
    if (cchDest > MAX_PATH)
        return FALSE;

    // OK if szParentDirectory is rewritten in place
    TCHAR *pchDestEnd;
    if (szDest == szParentDirectory)
        pchDestEnd = const_cast<TCHAR *>(&szParentDirectory[_tcslen(szParentDirectory)]);
    else
        pchDestEnd = strcpyEx(szDest, szParentDirectory);

    // Loop through each component in "szFileSpec", then do the following:
    //       for ".", do nothing
    //       for "..", delete rightmost dir from szDest
    //       otherwise, append the component.
    //

    const TCHAR *pchBegin = szFileSpecT;
    while (*pchBegin != _T('\0')) {
        // Calculate end of this segment
        const TCHAR *pchEnd = _tcspbrk(pchBegin,_T("\\/"));

        // check for parent path
        if ((_tcsncmp(pchBegin, _T(".."), 2) == 0)
            && ((pchBegin[2] == _T('/')) || (pchBegin[2] == _T('\\')))) {
            // Delete rightmost path in dest
            while ((pchDestEnd > szDest)
                    && (*pchDestEnd != _T('/'))
                    && (*pchDestEnd != _T('\\'))) {
                pchDestEnd = CharPrev(szDest, pchDestEnd);
            }

            if (pchDestEnd == szDest)   // we ".."'ed too many levels
                return FALSE;

            *pchDestEnd = _T('\0');
        }

        // Make sure this is not ".". If it is not, append the path
        else if (! (pchBegin[0] == _T('.') && (pchBegin[1] == _T('/') || pchBegin[1] == _T('\\')))) {
            cchDest += 1 + (int)(pchEnd - pchBegin);
            if (cchDest > MAX_PATH)
                return FALSE;

            *pchDestEnd++ = _T('/');
            _tcsncpy(pchDestEnd, pchBegin, pchEnd - pchBegin);
            pchDestEnd += (pchEnd - pchBegin);
            *pchDestEnd = _T('\0');
        }

        // Prepare for next iteration
        pchBegin = pchEnd + 1;
    }

    // It's possible that if the relative path is something like "..", and parent path is a single path
    // (either "/" or "C:/", then the root directory is indicator is missing - szDest is either the
    // empty string or something like "C:"
    //
#if UNICODE
    if (szDest[0] == '\0'
        || ((szDest[1] == L':') && (szDest[2] == L'\0'))) {
        szDest[2] = L'/';
        szDest[3] = L'\0';
    }
#else
    if (szDest[0] == '\0' ||
        (!IsDBCSLeadByte(szDest[0]) && szDest[1] == ':' && szDest[2] == '\0') ||
        (IsDBCSLeadByte(szDest[0]) && szDest[2] == ':' && szDest[3] == '\0')) {
        strcat(szDest, "/");
    }
#endif
    return TRUE;
}

/*===================================================================
FIsGlobalAsa

Check if the given path points to GLOBAL.ASA

Parameter
    szPath      the path to check

Returns
    TRUE/FALSE
===================================================================*/
BOOL FIsGlobalAsa
(
const TCHAR *szPath,
DWORD cchPath
)
    {
    if (cchPath == 0)
        cchPath = _tcslen(szPath);
    return (cchPath >= CCH_GLOBAL_ASA &&
            !_tcsicmp(szPath+(cchPath-CCH_GLOBAL_ASA), SZ_GLOBAL_ASA));
    }

/*===================================================================
EncodeSessionIdCookie

Convert 3 DWORDs into a SessionID cookie string

Parameters
    dw1, dw2, dw3       DWORDs
    pszCookie           cookie to fill in

Returns
    HRESULT
===================================================================*/
HRESULT EncodeSessionIdCookie
(
DWORD dw1, DWORD dw2, DWORD dw3,
char *pszCookie
)
    {
    DWORD dw = dw1;

    for (int idw = 0; idw < 3; idw++)
        {
        for (int i = 0; i < 8; i++)
            {
            *(pszCookie++) = (char)('A' + (dw & 0xf));
            dw >>= 4;
            }
        dw = (idw == 0) ? dw2 : dw3;
        }

    *pszCookie = '\0';
    return S_OK;
    }

/*===================================================================
DecodeSessionIdCookie

Convert SessionID cookie string into 3 DWORDs

Parameters
    pszCookie           cookie string
    pdw1, pdw2, pdw3    [out] DWORDs

Returns
    HRESULT
===================================================================*/
HRESULT DecodeSessionIdCookie
(
const char *pszCookie,
DWORD *pdw1, DWORD *pdw2, DWORD *pdw3
)
    {
    if (strlen(pszCookie) != SESSIONID_LEN)
        return E_FAIL;

    DWORD *pdw = pdw1;

    for (int idw = 0; idw < 3; idw++)
        {
        *pdw = 0;

        for (int i = 0; i < 8; i++)
            {
            int ch = pszCookie[idw*8+7-i];
            if (ch < 'A' || ch > ('A'+0xf))
                return E_FAIL;

            *pdw <<= 4;
            *pdw |= (ch - 'A');
            }

        pdw = (idw == 0) ? pdw2 : pdw3;
        }

    return S_OK;
    }

/*===================================================================
GetTypelibFilenameFromRegistry

Find a typelib filename (path) from the registry using GUID, version,
and LCID. The algorithm taken from VBA. Does some tricky matching.

Parameters
    szUUID      GUID
    szVersion   Version
    lcid        LCID
    szName      [out] TYPELIB Path
    cbName      buffer length of szName

Returns
    HRESULT
===================================================================*/
HRESULT GetTypelibFilenameFromRegistry
(
const char *szUUID,
const char *szVersion,
LCID lcid,
char *szName,
DWORD cbName
)
    {
    szName[0] = '\0';

    LONG iRet;
    HKEY hkeyTLib = NULL;
    HKEY hkeyGuid = NULL;

    // Open up the typelib section of the registry.

    iRet = RegOpenKeyExA(HKEY_CLASSES_ROOT, "TypeLib", 0, KEY_READ, &hkeyTLib);
    if (iRet != ERROR_SUCCESS)
        return E_FAIL;

    // Now open up the guid, if it is registered.

    iRet = RegOpenKeyExA(hkeyTLib, szUUID, 0, KEY_READ, &hkeyGuid);
    if (iRet != ERROR_SUCCESS)
        {
        RegCloseKey(hkeyTLib);
        return E_FAIL;
        }

    // Iterate through the versions trying to find the exact match
    // or get the latest (max version number)

    char  szMaxVersion[16];
    DWORD dwMaxVersion = 0; // to calculate max version number

    BOOL fLookForExactMatch = (szVersion && *szVersion);

    int iVer = 0;
    szMaxVersion[0] = '\0';

    while (1)
        {
        char szEnumVer[16];

        iRet = RegEnumKeyA(hkeyGuid, iVer++, szEnumVer, sizeof(szEnumVer));
        if (iRet != ERROR_SUCCESS)
            break;

        // check for the exact match first
        if (fLookForExactMatch && strcmp(szEnumVer, szVersion))
            {
            strcpy(szMaxVersion, szEnumVer);
            break;
            }

        // calc the version number
        char *pchDot = strchr(szEnumVer, '.');
        if (!pchDot) // ignore if not #.#
            continue;

        DWORD dwVer = (strtoul(szEnumVer, NULL, 16) << 16) |
                       strtoul(pchDot+1, NULL, 16);

        if (dwVer && szMaxVersion[0] == '\0' || dwVer > dwMaxVersion)
            {
            strcpy(szMaxVersion, szEnumVer);
            dwMaxVersion = dwVer;
            }
        }

    // szMaxVersion (if not empty now has the desired version number)

    if (szMaxVersion[0])
        {
        HKEY hkeyVer = NULL;
        iRet = RegOpenKeyExA(hkeyGuid, szMaxVersion, 0, KEY_READ, &hkeyVer);

        if (iRet == ERROR_SUCCESS)
            {
            HKEY hkeyWin32 = NULL;  // "win32" under LCID is for TYPELIB name
            BOOL fLcidFound = FALSE;

            // Now there's a version key.
            // We need to find the best matching lcid

            for (int iTry = 1; !fLcidFound && iTry <= 3; iTry++)
                {
                char szLcid[10];

                switch (iTry)
                    {
                case 1:
                    // if the passed lcid is not 0, try it
                    if (!lcid)
                        continue;
                    _ultoa(lcid, szLcid, 16);
                    break;

                case 2:
                    // passed lcid stripped to primary language
                    if (!lcid)
                        continue;
                    _ultoa(PRIMARYLANGID(lcid), szLcid, 16);
                    break;

                case 3:
                    // "0"
                    szLcid[0] = '0';
                    szLcid[1] = '\0';
                    break;
                    }

                HKEY hkeyLcid  = NULL;
                iRet = RegOpenKeyExA(hkeyVer, szLcid, 0, KEY_READ, &hkeyLcid);
                if (iRet == ERROR_SUCCESS)
                    {
#ifdef _WIN64
                    iRet = RegOpenKeyExA(hkeyLcid, "win64", 0, KEY_READ, &hkeyWin32);
                    if (iRet != ERROR_SUCCESS)
                        iRet = RegOpenKeyExA(hkeyLcid, "win32", 0, KEY_READ, &hkeyWin32);
#else
                    iRet = RegOpenKeyExA(hkeyLcid, "win32", 0, KEY_READ, &hkeyWin32);
#endif
                    if (iRet == ERROR_SUCCESS)
                        fLcidFound = TRUE;
                    RegCloseKey(hkeyLcid);
                    }
                }

            if (fLcidFound)
                {
                // LCID has been found - get the TYPELIB name
                Assert(hkeyWin32);
                LONG lName = cbName;
                iRet = RegQueryValueA(hkeyWin32, NULL, szName, &lName);

                if (iRet != ERROR_SUCCESS)
                    szName[0] = '\0';

                RegCloseKey(hkeyWin32);
                }

            RegCloseKey(hkeyVer);
            }
        }

    RegCloseKey(hkeyGuid);
    RegCloseKey(hkeyTLib);
    return (szName[0] == '\0') ? E_FAIL : S_OK;
    }

/*============================================================================
GetSecDescriptor

Get a file's Security Descriptor

Parameters:
    LPCSTR                  lpFileName              - file name
    PSECURITY_DESCRIPTOR    &pSecurityDescriptor    - security descriptor
    DWORD                   &nLength                - size of security descriptor

Returns:
    0 = No error
    or this will return the GetLastError results.

    Allocates memory.  Caller must deallocate (pSecurityDescriptor)
============================================================================*/

DWORD   GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength)
    {

    // this should always be NULL
    Assert(*ppSecurityDescriptor == NULL);

    const SECURITY_INFORMATION  RequestedInformation =
                                          OWNER_SECURITY_INFORMATION        // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;

    DWORD                   nLastError  = 0;
    int                     fDidItWork  = TRUE;
    DWORD                   nLengthNeeded = 0;

    *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) malloc( *pnLength );

    if (*ppSecurityDescriptor == NULL) {
        return E_OUTOFMEMORY;
    }

    while(TRUE)
        {
        fDidItWork = GetFileSecurity
            (lpFileName,                // address of string for file name
            RequestedInformation,       // requested information
            *ppSecurityDescriptor,      // address of security descriptor
            *pnLength,                  // size of security descriptor buffer
            &nLengthNeeded              // address of required size of buffer
            );

        if(!fDidItWork)
            {
            nLastError = GetLastError();
            if (ERROR_INSUFFICIENT_BUFFER == nLastError)
              {
                PSECURITY_DESCRIPTOR pPrevSecurityDescriptor = *ppSecurityDescriptor;
                *ppSecurityDescriptor = (PSECURITY_DESCRIPTOR) realloc(*ppSecurityDescriptor, nLengthNeeded );
                if ( *ppSecurityDescriptor == NULL)
                {   // Allocation failed. Free memory and bail out.
                    if (pPrevSecurityDescriptor)
                        free (pPrevSecurityDescriptor);

                    //
                    // Dont need to bother with the length (pnLength) because that is valid only if *ppSecurityDescriptor is not NULL
                    //
                    return E_OUTOFMEMORY;
                }
                *pnLength = nLengthNeeded;
                nLastError = 0;
              }
            else
              {
                break;
              }
            }
        else
            {
            *pnLength = GetSecurityDescriptorLength( *ppSecurityDescriptor );
            break;
            }
        }

    // deal with errors and free the SD if needed
    //
    if (nLastError != 0)
        {
        if(*ppSecurityDescriptor)
            {
            free(*ppSecurityDescriptor);
            *ppSecurityDescriptor = NULL;
            }
        }
    return nLastError;
    }

/*============================================================================
AspGetFileAttributes

Gets FileExistance and FileTime and/or FileSize if requested

Parameters:
    szFileName      - Mandatory Filename for which attributes have been requested.

    hFile           - optional : handle of file to open, which if provided attributes are retrieved based
                        on this parameter rather than filename. (optimization)

    pftLastWriteTime - optional : FILETIME structure if filetime is requested

    pdwFileSize     - optional : ptr to a DWORD in case filesize is requested.

Returns:
    S_OK or HRESULT from LastError generated.
============================================================================*/
HRESULT AspGetFileAttributes
(
LPCTSTR   szFileName,
HANDLE   hFile,
FILETIME* pftLastWriteTime,
DWORD*  pdwFileSize,
DWORD*  pdwFileAttributes
)
{
    BOOL fFileOpened = FALSE;
    BY_HANDLE_FILE_INFORMATION  FileInfo;
    HRESULT hr = S_OK;

    //
    // If the file handle is not sent then we need to open the file and use that handle (hFile is NULL for existence checks, !NULL for efficiency)
    //
    if (hFile == NULL)
    {
        hFile = AspCreateFile(szFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,        // share mode
                         NULL,                   // pointer to security descriptor
                         OPEN_EXISTING,          // how to create
                         FILE_ATTRIBUTE_NORMAL,  // file attributes
                         NULL                    // handle to file with attributes to copy
                        );

        if( hFile == INVALID_HANDLE_VALUE)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
            goto LExit;
        }
        else
            fFileOpened = TRUE;
    }

    //
    // If neither writetime or fileSize or attributes have been asked for then we can return.
    //
    if (!pftLastWriteTime && !pdwFileSize && !pdwFileAttributes)
        goto LExit;

    //
    // Call GetFileInformationByHandle and fill in the remaining parameters if they have been requested.
    //
    if (!GetFileInformationByHandle (hFile, &FileInfo))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto LExit;
    }

    //
    //  LastWriteTime was requested?
    //
    if (pftLastWriteTime)
        *pftLastWriteTime = FileInfo.ftLastWriteTime;

    //
    //  File Size was requested? Write only the lower size as most of ASP ignores the high byte anyways.
    //  Will add the higher byte later if need be
    //
    if (pdwFileSize)
        *pdwFileSize = FileInfo.nFileSizeLow;

    //
    //  File Attributes were requested
    //
    if (pdwFileAttributes)
        *pdwFileAttributes = FileInfo.dwFileAttributes;

LExit:

    //
    // Did we open the file? Then close it.
    //
    if (fFileOpened)
        CloseHandle(hFile);

    return hr;
}

/*============================================================================
IsFileUNC
Tests if the Filename points it to a UNC drive. it could be \\?\ prefixed so we should should take that into account.



Returns:
    TRUE if its a UNC Vdir (prefixed with \\?\ or not)
    FALSE otherwise
============================================================================*/

BOOL IsFileUNC (LPCTSTR str, HRESULT& hr)
{
    STACK_STRU (TempFileName, MAX_PATH);

    hr = MakePathCanonicalizationProof ((LPWSTR) str, &TempFileName);

    if (FAILED(hr))
    {
        SetLastError(WIN32_FROM_HRESULT(hr));

        //
        // Default to TRUE (UNC) because that will cause the Lastmod and AccessCheck logic to kick in.
        //
        return TRUE;
    }

    //
    // MakePathCanonicalizationProof will map \\?\UNC, \\.\UNC and \\ to \\?\UNC
    //
    return (!_tcsnicmp (TempFileName.QueryStr (), _T("\\\\?\\UNC\\"), 8 /* sizeof \\?\UNC\ */));
}

/*============================================================================
AspCreateFile

Prepends a \\?\ or a \\?\UNC\ before the file name. We use this function rather than use SCRIPT_TRANSLATED
because a large portion of the ASP parsing depends on PATH_TRANSLATED.
AspCreateFile takes the same parameters as CreateFile.

Parameters:
    lpFileName      - Mandatory Filename for which needs to be opened/created/checked for existance.

    dwDesiredAccess - Access Flags ACL's on the file

    dwShareMode    - Share Mode

    lpSecurityAttributes- Security Attributes and/or SID's

    dwCreationDisposition -

    dwFlagsAndAttributes

    hTemplateFile   -

Returns:
    HANDLE to the file or and INVALID_HANDLE_VALUE and sets Last Error.
============================================================================*/


HANDLE AspCreateFile
    (
    LPCTSTR lpFileName,
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,
    DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile
    )
{
    HRESULT hr = S_OK;
    STACK_STRU (TempFileName, MAX_PATH);

    hr = MakePathCanonicalizationProof ((LPWSTR) lpFileName, &TempFileName);

    if (FAILED (hr))
    {
        SetLastError (WIN32_FROM_HRESULT(hr));
        return INVALID_HANDLE_VALUE;
    }

    return CreateFile( TempFileName.QueryStr() ,
        dwDesiredAccess,
        dwShareMode,
        lpSecurityAttributes,
        dwCreationDisposition,
        dwFlagsAndAttributes,
        hTemplateFile);
}


/*============================================================================
AspCharNextA

UTF-8 aware CharNext()
============================================================================*/

char *AspCharNextA(WORD wCodePage, const char *sz)
	{
	if (wCodePage != CP_UTF8)
		return CharNextExA(wCodePage, sz, 0);
	else
		{
		// CharNextExA won't work correctly in UTF-8.

		// Add support for UTF-8 encoding for Surrogate pairs
		// 110110wwwwzzzzyyyyyyxxxxxx gets encoded as 11110uuu 10uuzzzz 10yyyyyy 10xxxxxx
		// where uuuuu = wwww + 1 (to account for addition of 10000(b16) )
		// For further information refer : Page A-7 of "The Unicode Standard 2.0" ISBN-0-201-48345-9
		if ((*sz & 0xf8) == 0xF0)
		    return const_cast<char *>(sz + 4);

		//zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
		if ((*sz & 0xF0) == 0xE0)
		    return const_cast<char *>(sz + 3);

        //00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
		else if ((*sz & 0xE0) == 0xC0)
			return const_cast<char *>(sz + 2);

        //000000000xxxxxxx = 0xxxxxxx
		else
			return const_cast<char *>(sz + 1);
		}
	}

/*============================================================================
CWCharToMBCS::~CWCharToMBCS

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CWCharToMBCS::~CWCharToMBCS()
{
    if(m_pszResult && (m_pszResult != m_resMemory))
        free(m_pszResult);
}

/*============================================================================
CWCharToMBCS::Init

Converts the passed in WideChar string to MultiByte in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CWCharToMBCS::Init(LPCWSTR pWSrc, UINT lCodePage /* = CP_ACP */, int cchWSrc /* = -1 */)
{
    INT cbRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pWSrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cbResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.

    cbRequired = WstrToMBstrEx(m_pszResult, sizeof(m_resMemory), pWSrc, cchWSrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and
    // return.

    if (cbRequired <= sizeof(m_resMemory)) {
        m_cbResult = cbRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPSTR)malloc(cbRequired);
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cbRequired = WstrToMBstrEx(m_pszResult, cbRequired, pWSrc, cchWSrc, lCodePage);

    // store the final char count in the object.

    m_cbResult = cbRequired;

    return NO_ERROR;
}

/*============================================================================
CWCharToMBCS::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPSTR CWCharToMBCS::GetString(BOOL fTakeOwnerShip)
{
    LPSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupA(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cbResult = 0;
    }

    return(retSz);
}

/*============================================================================
CMBCSToWChar::~CMBCSToWChar

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CMBCSToWChar::~CMBCSToWChar()
{
    if(m_pszResult && (m_pszResult != m_resMemory))
        free(m_pszResult);
}

/*============================================================================
CMBCSToWChar::Init

Converts the passed in MultiByte string to UNICODE in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CMBCSToWChar::Init(LPCSTR pASrc, UINT lCodePage /* = CP_ACP */, int cchASrc /* = -1 */)
{
    INT cchRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pASrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cchResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.  NOTE - MBstrToWstrEx returns the
    // count of characters, not bytes.

    cchRequired = MBstrToWstrEx(m_pszResult, sizeof(m_resMemory)/sizeof(WCHAR), pASrc, cchASrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and
    // return.

    if (cchRequired <= (sizeof(m_resMemory)/sizeof(WCHAR))) {
        m_cchResult = cchRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPWSTR)malloc(cchRequired*sizeof(WCHAR));
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cchRequired = MBstrToWstrEx(m_pszResult, cchRequired, pASrc, cchASrc, lCodePage);

    // store the final char count in the object.

    m_cchResult = cchRequired;

    return NO_ERROR;
}

/*============================================================================
CMBCSToWChar::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPWSTR CMBCSToWChar::GetString(BOOL fTakeOwnerShip)
{
    LPWSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StringDupW(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cchResult = 0;
    }

    return(retSz);
}

//
// (Un)DoRevertHack
//
// To prevent RPC token cache from growing without limit (and aging), we
// need to revert to self before calling back to inetinfo.exe.
//
// Now there is a new need to do this. As it turns out the performance
// hit we take from RPC caching these tokens is very significant.
// Ultimately we might want to implement a caching scheme ourselves so
// that the token we use is always the same for the same user identity,
// but that is a big change and this (although ugly as hell) works
// and has been tested for months.
//

VOID AspDoRevertHack( HANDLE * phToken )
{
    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          phToken ) )
    {
        RevertToSelf();
    }
    else
    {
/*
        DBGPRINTF((
            DBG_CONTEXT,
            "[DoRevertHack] OpenThreadToken failed.  Error %d.\r\n",
            GetLastError()
            ));
*/
        *phToken = INVALID_HANDLE_VALUE;
    }
}

VOID AspUndoRevertHack( HANDLE * phToken )
{
    if ( !*phToken || ( *phToken == INVALID_HANDLE_VALUE ) )
    {
        return;
    }

    SetThreadToken( NULL,
                    *phToken );

    CloseHandle( *phToken );

    *phToken = INVALID_HANDLE_VALUE;
}

/***************************************************************************++

Routine Description:

    Set EXPLICIT_ACCESS settings for wellknown sid.

Arguments:



Return Value:




--***************************************************************************/
VOID
SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                           DWORD            dwAccessPermissions,
                           ACCESS_MODE      AccessMode,
                           PSID             pSID
    )
{
    pea->grfInheritance= NO_INHERITANCE;
    pea->Trustee.TrusteeForm = TRUSTEE_IS_SID;
    pea->Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;

    pea->grfAccessMode = AccessMode;
    pea->grfAccessPermissions = dwAccessPermissions;
    pea->Trustee.ptstrName  = (LPTSTR) pSID;
}

/***************************************************************************++

Routine Description:

    Figures out how much memory is needed and allocates the memory
    then requests the well known sid to be copied into the memory.  If
    all goes well then the SID is returned, if anything fails the
    SID is not returned.

Arguments:

    WELL_KNOWN_SID_TYPE SidType = Enum value for the SID being requested.
    PSID* ppSid = Ptr to the pSid that is returned.

Return Value:

    DWORD - Win32 Status Code.

--***************************************************************************/
DWORD
AllocateAndCreateWellKnownSid(
    WELL_KNOWN_SID_TYPE SidType,
    PSID* ppSid
    )
{
    DWORD dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( ppSid != NULL && *ppSid == NULL );

    PSID  pSid = NULL;
    DWORD cbSid = 0;

    //
    // Get the size of memory needed for the sid.
    //
    if ( CreateWellKnownSid(SidType, NULL, NULL, &cbSid ) )
    {
        // If CreateWellKnownSid passed then there is a problem
        // because we passed in NULL for the pointer to the sid.

        dwErr = ERROR_NOT_SUPPORTED;

        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating a sid worked with no memory allocated for it. ( This is not good )\n"
            ));

        DBG_ASSERT ( FALSE );
        goto exit;
    }

    //
    // Get the error code and make sure it is
    // not enough space allocated.
    //
    dwErr = GetLastError();
    if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
    {
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Getting the SID length failed, can't create the sid (Type = %d)\n",
            SidType
            ));

        goto exit;
    }

    //
    // If we get here then the error code was expected, so
    // lose it now.
    //
    dwErr = ERROR_SUCCESS;

    DBG_ASSERT ( cbSid > 0 );

    //
    // At this point we know the size of the sid to allocate.
    //
    pSid = (PSID) GlobalAlloc(GMEM_FIXED, cbSid);

    //
    // Ok now we can get the SID
    //
    if ( !CreateWellKnownSid (SidType, NULL, pSid, &cbSid) )
    {
        dwErr = GetLastError();
        DPERROR((
            DBG_CONTEXT,
            HRESULT_FROM_WIN32(dwErr),
            "Creating SID failed ( SidType = %d )\n",
            SidType
            ));

        goto exit;
    }

    DBG_ASSERT ( dwErr == ERROR_SUCCESS );

exit:

    //
    // If we are returning a failure here, we don't
    // want to actually set the ppSid value.  It may
    // not get freed.
    //
    if ( dwErr != ERROR_SUCCESS && pSid != NULL)
    {
        GlobalFree( pSid );
        pSid = NULL;
    }
    else
    {
        //
        // Otherwise we should return the value
        // to the caller.  The caller must
        // use FreeWellKnownSid to free this value.
        //
        *ppSid = pSid;
    }

    return dwErr;
}

/***************************************************************************++

Routine Description:

    Frees memory that was allocated by the
    AllocateAndCreateWellKnownSid function.

Arguments:

    PSID* ppSid = Ptr to the pointer to be freed and set to NULL.

Return Value:

    VOID.

--***************************************************************************/
VOID
FreeWellKnownSid(
    PSID* ppSid
    )
{
    DBG_ASSERT ( ppSid );
    if ( *ppSid != NULL )
    {
        GlobalFree ( *ppSid );
        *ppSid = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\tlbcache.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.cpp

Owner: DmitryR

This is the typelibrary cache source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CTypelibCache g_TypelibCache;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

/*===================================================================
CTypelibCacheEntry::CTypelibCacheEntry

Constructor
===================================================================*/
CTypelibCacheEntry::CTypelibCacheEntry()
    :
    m_fInited(FALSE), m_fIdsCached(FALSE), m_fStrAllocated(FALSE),
    m_wszProgId(NULL), m_clsid(CLSID_NULL), m_cmModel(cmUnknown), 
    m_idOnStartPage(DISPID_UNKNOWN), m_idOnEndPage(DISPID_UNKNOWN),
    m_gipTypelib(NULL_GIP_COOKIE)
    {
    }

/*===================================================================
CTypelibCacheEntry::~CTypelibCacheEntry

Destructor
===================================================================*/
CTypelibCacheEntry::~CTypelibCacheEntry()
    {
    if (m_gipTypelib != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_gipTypelib);
        }
        
    if (m_fStrAllocated)
        {
        Assert(m_wszProgId);
		free(m_wszProgId);
        }
    }

/*===================================================================
CTypelibCacheEntry::StoreProgID

Store ProgID with the structure

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::StoreProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    Assert(wszProgId);
    Assert(*wszProgId != L'\0');
    Assert(cbProgId == (wcslen(wszProgId) * sizeof(WCHAR)));

    // required buffer length
    DWORD cbBuffer = cbProgId + sizeof(WCHAR);
    WCHAR *wszBuffer = (WCHAR *)m_rgbStrBuffer;

    if (cbBuffer > sizeof(m_rgbStrBuffer))
        {
        // the prog id doesn't fit into the member buffer -> allocate
        wszBuffer = (WCHAR *)malloc(cbBuffer);
        if (!wszBuffer)
            return E_OUTOFMEMORY;
        m_fStrAllocated = TRUE;
        }
    
    memcpy(wszBuffer, wszProgId, cbBuffer);
    m_wszProgId = wszBuffer;
    return S_OK;
    }

/*===================================================================
CTypelibCacheEntry::InitByProgID

Real constructor.
Store ProgID. Init CLinkElem portion with ProgID.

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    StoreProgID(wszProgId, cbProgId);
    
    // init link with prog id as key (length excludes null term)
	CLinkElem::Init(m_wszProgId, cbProgId);
	m_fInited = TRUE;
	return S_OK;
    }


/*===================================================================
CTypelibCacheEntry::InitByCLSID

Real constructor.
Store ProgID. Init CLinkElem portion with CLSID.

Parameters
    clsid           CLSID
    wszProgId       ProgId

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByCLSID
(
const CLSID &clsid, 
LPWSTR wszProgid
)
    {
    StoreProgID(wszProgid, CbWStr(wszProgid));
    m_clsid = clsid;
        
    // init link with CLSID id as key
	CLinkElem::Init(&m_clsid, sizeof(m_clsid));
	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

/*===================================================================
CTypelibCache::CTypelibCache

Constructor
===================================================================*/
CTypelibCache::CTypelibCache()
    :
    m_fInited(FALSE)
    {
    }
    
/*===================================================================
CTypelibCache::~CTypelibCache

Destructor
===================================================================*/
CTypelibCache::~CTypelibCache()
    {
    UnInit();
    }

/*===================================================================
CTypelibCache::Init

Init

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::Init()
    {
    HRESULT hr;

    hr = m_htProgIdEntries.Init(199);
    if (FAILED(hr))
        return hr;

    hr = m_htCLSIDEntries.Init(97);
    if (FAILED(hr))
        return hr;

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
        
    m_fInited = TRUE;
    return S_OK;
    }
    
/*===================================================================
CTypelibCache::UnInit

UnInit

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::UnInit()
    {
    CTypelibCacheEntry *pEntry;
    CLinkElem *pLink;

    // ProgID Hash table
    pLink = m_htProgIdEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htProgIdEntries.UnInit();

    // CLSID Hash table
    pLink = m_htCLSIDEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htCLSIDEntries.UnInit();

    // Critical section
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CTypelibCache::CreateComponent

Create the component using the cached info.
Adds cache entry if needed.
To be called from Server.CreateObject

Parameters
    bstrProgID      prog id
    pHitObj         HitObj needed for creation
    ppdisp          [out] IDispatch *
    pclsid          [out] CLSID

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::CreateComponent
(
BSTR         bstrProgID,
CHitObj     *pHitObj,
IDispatch  **ppdisp,
CLSID       *pclsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CComponentObject *pObj;
    COnPageInfo OnPageInfo;
    CompModel cmModel; 

    *pclsid = CLSID_NULL;
    *ppdisp = NULL;

    if (bstrProgID == NULL || *bstrProgID == L'\0')
        return E_FAIL;

    WCHAR *wszProgId = bstrProgID;
    DWORD  cbProgId  = CbWStr(wszProgId);    // do strlen once

    BOOL fFound = FALSE;
    BOOL bDispIdsCached = FALSE;
    
    Lock();
    pElem = m_htProgIdEntries.FindElem(wszProgId, cbProgId);
    if (pElem)
        {
        // remember the elements of the entry while inside lock
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // return clsid
        *pclsid = pEntry->m_clsid;

        // prepate OnPageInfo with DispIds to pass to the creation function
        if (pEntry->m_fIdsCached)
            {
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONSTARTPAGE] = pEntry->m_idOnStartPage;
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONENDPAGE] = pEntry->m_idOnEndPage;
            bDispIdsCached = TRUE;
            }
        // remember the model
        cmModel = pEntry->m_cmModel;

        fFound = TRUE;
        }
    UnLock();

    if (fFound)
        {
        // create the object
        hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
            (
            csPage,
            *pclsid,
            cmModel,
            bDispIdsCached ? &OnPageInfo : NULL,
            &pObj
            );

        // get IDispatch*
        if (SUCCEEDED(hr))
            hr = pObj->GetAddRefdIDispatch(ppdisp);

        // return if succeeded
        if (SUCCEEDED(hr))
            {
            // don't keep the object around unless needed
            if (pObj->FEarlyReleaseAllowed())
                pHitObj->PPageComponentManager()->RemoveComponent(pObj);
            return S_OK;
            }

        // on failure remove from the cache and pretend
        // as if it was never found

        Lock();
        pElem = m_htProgIdEntries.DeleteElem(wszProgId, cbProgId);
        UnLock();

        if (pElem)
            {
            // Element removed from cache - delete the CacheEntry
            pEntry = static_cast<CTypelibCacheEntry *>(pElem);
            delete pEntry;
            }

        // don't return bogus CLSID
        *pclsid = CLSID_NULL;
        }

    // Not found in the cache. Create the object, get the info, and
    // insert the new cache entry.

   	hr = CLSIDFromProgID((LPCOLESTR)wszProgId, pclsid);
   	if (FAILED(hr))
   	    return hr;  // couldn't even get clsid - don't cache

    hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
        (
        csPage,
        *pclsid,
        cmUnknown,
        NULL,
        &pObj
        );
   	if (FAILED(hr))
   	    return hr;  // couldn't create object - don't cache

    // object created - get IDispatch*
    if (SUCCEEDED(hr))
        hr = pObj->GetAddRefdIDispatch(ppdisp);
   	if (FAILED(hr))
   	    return hr;  // couldn't get IDispatch* - don't cache

    // create new CTypelibCacheEntry
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return S_OK; // no harm

    // init link entry
    if (FAILED(pEntry->InitByProgID(wszProgId, cbProgId)))
        {
        delete pEntry;
        return S_OK; // no harm
        }
        
    // remember stuff in pEntry
    pEntry->m_clsid = *pclsid;
    pEntry->m_cmModel = pObj->GetModel();

    const COnPageInfo *pOnPageInfo = pObj->GetCachedOnPageInfo();
    if (pOnPageInfo)
        {
        pEntry->m_fIdsCached = TRUE;
        pEntry->m_idOnStartPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONSTARTPAGE];
        pEntry->m_idOnEndPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONENDPAGE];
        }
    else
        {
        pEntry->m_fIdsCached = FALSE;
        pEntry->m_idOnStartPage = DISPID_UNKNOWN;
        pEntry->m_idOnEndPage = DISPID_UNKNOWN;
        }

    // try to get the typelib
    pEntry->m_gipTypelib = NULL_GIP_COOKIE;
    ITypeInfo *ptinfo;
    if (SUCCEEDED((*ppdisp)->GetTypeInfo(0, 0, &ptinfo)))
    {
        ITypeLib *ptlib;
        UINT idx;
        if (SUCCEEDED(ptinfo->GetContainingTypeLib(&ptlib, &idx)))
        {
            // got it! convert to gip cookie
            DWORD gip;
            if (SUCCEEDED(g_GIPAPI.Register(ptlib, IID_ITypeLib, &gip)))
            {
                // remember the gip cookie with pEntry
                pEntry->m_gipTypelib = gip;
            }
                
            ptlib->Release();
        }
        ptinfo->Release();
    }

        
    // pEntry is ready -- try to insert it into cache
    BOOL fInserted = FALSE;
    Lock();
    // make sure some other thread didn't insert it already
    if (m_htProgIdEntries.FindElem(wszProgId, cbProgId) == NULL)
        {
        if (m_htProgIdEntries.AddElem(pEntry))
            fInserted = TRUE;
        }
    UnLock();

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    // don't keep the object around unless needed
    if (pObj->FEarlyReleaseAllowed())
        pHitObj->PPageComponentManager()->RemoveComponent(pObj);

    return S_OK;
    }

/*===================================================================
CTypelibCache::RememberProgidToCLSIDMapping

Adds an entry to CLSID hashtable.
To be called from template after mapping ProgId to CLSID.

Parameters
    wszProgID      prog id
    clsid          clsid

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::RememberProgidToCLSIDMapping
(
WCHAR *wszProgid, 
const CLSID &clsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;

    // check if already there first
    BOOL fFound = FALSE;
    Lock();
    if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) != NULL)
        fFound = TRUE;
    UnLock();
    if (fFound)
        return S_OK;
    
    // create new entry    
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return E_OUTOFMEMORY;

    BOOL fInserted = FALSE;
    
    // remember prog id and init link entry
    hr = pEntry->InitByCLSID(clsid, wszProgid);
    
    if (SUCCEEDED(hr))
        {
        Lock();
        // make sure some other thread didn't insert it already
        if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) == NULL)
            {
            if (m_htCLSIDEntries.AddElem(pEntry))
                fInserted = TRUE;
            }
        UnLock();
        }

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    return hr;
    }

/*===================================================================
CTypelibCache::UpdateMappedCLSID

Update CLSID since remembered.

To be called from object creation code to update CLSID
if the object creation failed.

Parameters
    *pclsid         [in, out] CLSID

Returns
    HRESULT
        S_FALSE = didn't change
        S_OK    = did change and the new one found
===================================================================*/
HRESULT CTypelibCache::UpdateMappedCLSID
(
CLSID *pclsid
)
    {
    HRESULT hr = S_FALSE; // not found
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CLSID clsidNew;
    
    Lock();
    // Do everything under lock so the ProgID stored in
    // the entry is still valid.
    // Not very perfomant -- but is is an error path anyway
    
    pElem = m_htCLSIDEntries.FindElem(pclsid, sizeof(CLSID));
    if (pElem)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // find new mapping
        if (SUCCEEDED(CLSIDFromProgID(pEntry->m_wszProgId, &clsidNew)))
            {
            // compare with the old one
            if (!IsEqualCLSID(clsidNew, *pclsid))
                {
                // the mapping did change!
                *pclsid = clsidNew;
                hr = S_OK;
                }
            }
        }
        
    UnLock();

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\template.cpp ===
//depot/private/jasbr/inetsrv/iis/svcs/cmp/asp/template.cpp#19 - edit change 3548 (text)
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.cpp
Maintained by:  DaveK
Component:      source file for Denali Compiled Template object
==============================================================================*/
#include "denpre.h"

#pragma hdrstop

const int SNIPPET_SIZE = 20;    // # of characters in the code snippets

#pragma warning( disable : 4509 )   // suppress SEH/destructor warnings
#pragma warning( disable : 4355 )   // ignore: "'this' used in base member init

#include "debugger.h"
#include "dbgutil.h"
#include "tlbcache.h"
#include "ie449.h"

#include "memchk.h"
#include "vecimpl.h"    // Include after memchk to insure that vector uses our mem manager.

#include "Accctrl.h"
#include "aclapi.h"

// Init class statics
CTemplate::CTokenList *CTemplate::gm_pTokenList = NULL;
PTRACE_LOG CTemplate::gm_pTraceLog = NULL;
HANDLE CTemplate::sm_hSmallHeap = NULL;
HANDLE CTemplate::sm_hLargeHeap = NULL;

extern BOOL g_fLazyContentPropDisabled;
extern DWORD g_dwFileMonitoringTimeoutSecs;

// Max # of opener tokens to look for
#define TOKEN_OPENERS_MAX   8

/*===================================================================
    Private non-class support functions
===================================================================*/
static void       ByteRangeFromPb(BYTE* pbSource, CByteRange& brTarget);
static BOOLB      FByteRangesAreEqual(CByteRange& br1, CByteRange& br2);
static unsigned   CharAdvDBCS(WORD wCodePage, char *pchStart, char *pchEnd, unsigned cCharAdv, char **ppchEnd, BOOL fForceDBCS = FALSE);
static void       LineFromByteRangeAdv(CByteRange& br, CByteRange& brLine);
static void       LTrimWhiteSpace(CByteRange& br);
static void       RTrimWhiteSpace(CByteRange& br);
static CByteRange BrNewLine(CByteRange br);
static BOOLB      FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace = TRUE);
static BOOLB      FWhiteSpaceEx(WCHAR wch, BOOLB fSpaceIsWhiteSpace = TRUE);
static BOOLB      FByteRangeIsWhiteSpace(CByteRange br);
static BOOLB      FTagName(BYTE* pb, UINT cb);
static void       ByteAlignOffset(UINT* pcbOffset, UINT cbAlignment);
static void       GetSzFromPatternInserts(char* pszPattern, UINT cInserts, char** ppszInserts, char* szReturned);
static UINT       CchPathFromFilespec(LPCTSTR szFile);
static void       GetPathFromParentAndFilespec(LPCTSTR szParentPath, LPCTSTR szFileSpec, LPTSTR* pszPath);
static void       HandleAccessFailure(CHitObj* pHitObj, TCHAR* szFile);
static void       SendToLog(DWORD dwMask, CHAR *szFileName, CHAR *szLineNum, CHAR *szShortDes, CHAR *szLongDes, CHAR *szEngine, CHitObj *pHitObj);
static HRESULT    GetProgLangId(CByteRange& brEngine, PROGLANG_ID* pProgLangId);

inline
void __cdecl DebugPrintf(LPCSTR fmt, ...)
    {
#if DBG
    char msg[512];
    va_list marker;
    va_start(marker, fmt);
    vsprintf(msg, fmt, marker);
    va_end(marker);
    OutputDebugStringA(msg);
#endif
    }


/*  ============================================================================
    ByteRangeFromPb
    Gets a byte range from a contiguous block of memory

Returns:
    Nothing.

Side effects:
    None.
*/
void
ByteRangeFromPb
(
BYTE*       pbSource,
CByteRange& brTarget
)
    {
    Assert(pbSource != NULL);
    brTarget.m_cb = *(ULONG*)pbSource;
    brTarget.m_pb = pbSource + sizeof(ULONG);
    }

/*  ============================================================================
    FByteRangesAreEqual

    Compares two byte ranges

    Returns:
        BOOLB. True if byte ranges are equal, else false.

    Side effects:
        None.
*/
BOOLB
FByteRangesAreEqual
(
CByteRange& br1,
CByteRange& br2
)
    {
    if(br1.m_cb != br2.m_cb)
        return FALSE;
    return (!_strnicmp((LPCSTR)br1.m_pb, (LPCSTR)br2.m_pb, br1.m_cb));
    }

/*  ============================================================================
    CharAdvDBCS

    Advance "cchCharAdv" characters in a buffer
    SBCS: Degenerates to simple pointer arithmatic

    Arguments:
            wCodePage       - code page
            pchStart        - pointer to beginning of segment
            pchEnd          - pointer to just past end of segment
            cCharAdv        - # of characters to advance
            ppchEnd         - [output], contains pointer "cCharAdv" chars past pchStart
            fForceDBCS      - if TRUE, always use double byte algorithm.
                                (for verifying correct behavior of func in debug mode)

    Returns:
        (int) # of characters that we actually advanced

    Notes:
        By passing INFINITE for "cCharAdv", you can use this function to count characters
        in a block

    Side effects:
        None.
*/
unsigned
CharAdvDBCS
(
WORD wCodePage,
char *pchStart,
char *pchEnd,
unsigned cCharAdv,
char **ppchEnd,
BOOL fForceDBCS
)
    {
    CPINFO CpInfo;
    GetCPInfo(wCodePage, &CpInfo);
    if (!fForceDBCS && CpInfo.MaxCharSize == 1)
        {
        char *pchT = pchStart + min(cCharAdv, unsigned(pchEnd - pchStart));

        if (ppchEnd)
            *ppchEnd = pchT;

        #if DBG
            // Verify DBCS algorithm (not often tested otherwise)
            char *pchTest;
            unsigned cchTest = CharAdvDBCS(wCodePage, pchStart, pchEnd, cCharAdv, &pchTest, TRUE);
            Assert (cchTest == unsigned(pchT - pchStart) && pchTest == pchT);
        #endif

        return DIFF(pchT - pchStart);
        }
    else
        {
        int cch = 0;
        char *pchNext = pchStart;

        // Count DBCS characters. We have to stop before pchEnd because
        // pchEnd may point past file map and CharNextExA AVs when advancing
        // past allocated memory

        while (cCharAdv > 0 && pchNext < pchEnd-2)
            {
            pchNext = *pchNext? AspCharNextA(wCodePage, pchNext) : pchNext + 1;
            --cCharAdv;
            ++cch;
            }

        // We could stop on the last or the before last character
        // depending on the DBCS char sequence
        if (cCharAdv > 0 && pchNext == pchEnd-1)
            {
            // Only one byte - has to be one single byte character
            ++pchNext;
            ++cch;
            }

        else if (cCharAdv > 0 && pchNext == pchEnd-2)
            {
            // 2 bytes left - either 1 2-byte char or 2 1-byte chars
            if (IsDBCSLeadByteEx(wCodePage, *pchNext))
                {
                ++cch;
                pchNext += 2;
                }
            else
                {
                // Two characters left. If cCharAdv > 1, this means that user wants to
                // advance at least two more chars. Otherwise, cCharAdv == 1, and
                // we advance one char
                //
                if (cCharAdv > 1)
                    {
                    cch += 2;
                    pchNext += 2;
                    }
                else
                    {
                    Assert (cCharAdv == 1);
                    ++cch;
                    ++pchNext;
                    }
                }
            }

        if (ppchEnd)
            *ppchEnd = pchNext;

        return cch;
        }
    }

/*  ============================================================================
    LineFromByteRangeAdv
    Gets the first line in a byte range.

    Returns:
        Nothing

    Side effects:
        Advances source byte range to just beyond its first non-white-space line,
        if one is found.

*/
void
LineFromByteRangeAdv
(
CByteRange& brSource,
CByteRange& brLine
)
    {
    CByteRange brTemp;

    if(brSource.IsNull())
        {
        brLine.Nullify();
        return;
        }

    brLine.m_pb = brSource.m_pb;

        brTemp = BrNewLine(brSource);
    if(brTemp.IsNull())
        {
        // We found no newline in a non-empty byte range:
        // set line range to entire source byte range and empty source byte range
        brLine.m_cb = brSource.m_cb;
        brSource.Nullify();
        }
    else
        {
        // We found a newline in a non-empty byte range:
        // set line range to portion of source byte range before new line;
        // set source range to portion of source range after new line
        brLine.m_cb = DIFF(brTemp.m_pb - brSource.m_pb);
        brSource.m_pb = brTemp.m_pb + brTemp.m_cb;
        brSource.m_cb -= (brLine.m_cb + brTemp.m_cb);
        }
    }

/*  ============================================================================
LTrimWhiteSpace

Left-trim white space from byte-range

Returns:
    Nothing

Side effects:
    Advances byte range to just beyond its first non-white-space character.

*/
void
LTrimWhiteSpace
(
CByteRange& br
)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*br.m_pb))
        {
        br.m_pb++;
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    RTrimWhiteSpace
    Right-trim white space from byte-range
*/
void
RTrimWhiteSpace(CByteRange& br)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*(br.m_pb + br.m_cb - 1)))
        {
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    BrNewLine
    Returns ptr to the first newline in a byte range
    NOTE does not change byte range (since it is passed by value)
*/
CByteRange
BrNewLine(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(*br.m_pb == '\r')
                        return CByteRange(br.m_pb, (br.m_cb > 1 && br.m_pb[1] == '\n')? 2 : 1);

        else if (*br.m_pb == '\n')
                return CByteRange(br.m_pb, 1);

        ++br.m_pb;
        --br.m_cb;
        }
    return CByteRange();
    }

/*  ============================================================================
    FWhiteSpace
    Returns:
        TRUE if ch is a white-space character, else returns FALSE
        Certain character(s) (e.g. space) may be treated as
        non-white-space; to do this, caller passes FALSE for
        fSpaceIsWhiteSpace flag.
*/
BOOLB
FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace)
{
    switch (ch)
    {
        case ' ':
            return fSpaceIsWhiteSpace;
        case '\0':
            return TRUE;
        case '\a':
            return TRUE;
        case '\b':
            return TRUE;
        case '\f':
            return TRUE;
        case '\n':
            return TRUE;
        case '\r':
            return TRUE;
        case '\t':
            return TRUE;
        case '\v':
            return TRUE;
        default:
            return FALSE;
    }
}

/*  ============================================================================
    FWhiteSpaceEx
    Returns:
        TRUE if ch is a white-space character, else returns FALSE
        Certain character(s) (e.g. space) may be treated as
        non-white-space; to do this, caller passes FALSE for
        fSpaceIsWhiteSpace flag.
*/
BOOLB
FWhiteSpaceEx(WCHAR wch, BOOLB fSpaceIsWhiteSpace)
{
    switch (wch)
    {
        case L' ':
            return fSpaceIsWhiteSpace;
        case L'\0':
            return TRUE;
        case L'\a':
            return TRUE;
        case L'\b':
            return TRUE;
        case L'\f':
            return TRUE;
        case L'\n':
            return TRUE;
        case L'\r':
            return TRUE;
        case L'\t':
            return TRUE;
        case L'\v':
            return TRUE;
        default:
            return FALSE;
    }
}

/*  ============================================================================
    FByteRangeIsWhiteSpace
    Is the entire input byte range white space?
    NOTE input byte range is byval; caller's copy is not changed
*/
BOOLB
FByteRangeIsWhiteSpace(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(!FWhiteSpace(*(br.m_pb)))
            return FALSE;
        br.Advance(1);
        }

    return TRUE;
    }

/*  ============================================================================
    FTagName
    Does pb point to a valid HTML tag name?
    (i.e., is *pb a valid HTML tag name and not a substring?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
FTagName(BYTE* pb, UINT cb)
    {
    if((pb == NULL) || (cb == 0))
        return FALSE;

    // a valid HTML tag name must be preceded by white space  ...
    if( FWhiteSpace(*(pb - 1)) ||  *(pb - 1) == '@' )
        {
        // ... and followed either by white space or the tag separator
        if(FWhiteSpace(*(pb + cb)))
            return TRUE;
        else if(*(pb + cb) == CH_ATTRIBUTE_SEPARATOR)
            return TRUE;
        }

    return FALSE;
    }

/*===================================================================
    ByteAlignOffset
    Byte-aligns an offset value, based on size of source data
*/
void
ByteAlignOffset
(
UINT*   pcbOffset,      // ptr to offset value
UINT    cbAlignment // Alignment boundary
)
    {
        // comment the below code out so that it works for 64 bit...

    // only byte-align for 2-, or 4-byte data
    // since our base pointer in only aligned to a 4 byte boundary
    //if(cbAlignment == 2 || cbAlignment == 4)
        //{
        // if current offset does not fall on a byte-aligned location for current data type,
        // advance offset to next byte-aligned location
                Assert(cbAlignment > 0);
        --cbAlignment;
                if (*pcbOffset & cbAlignment)
                        *pcbOffset = (*pcbOffset + cbAlignment + 1) & ~cbAlignment;
    }

/*  ============================================================================
    GetSzFromPatternInserts
    Returns a 'resolved' version of a pattern string, i.e. a new string in which
    | characters have been replaced by caller-specified insert strings.
    NOTE this function allocates, but caller must free

    Returns:
        Nothing
    Side effects:
        allocates memory
*/
void
GetSzFromPatternInserts
(
char*   pszPattern,     // 'pattern' string
UINT    cInserts,       // count of insert strings
char**  ppszInserts,    // array of ptrs to insert strings
char*   szReturned      // returned string MUST be allocated by caller
)
    {
    UINT    cchRet = strlen(pszPattern);   // length of return string
    char*   pchStartCopy = pszPattern;      // ptr to start of copy range in pattern
    char*   pchEndCopy = pszPattern;        // ptr to end of copy range in pattern
    UINT    cActualInserts = 0;             // count of actual insert strings

    // init return string to empty so we can concatenate onto it
    szReturned[0] = NULL;

    // zero out length of return string - we now use it to count actual length as we build return string
    cchRet = 0;

    while(TRUE)
        {
        // advance end-of-copy ptr through pattern looking for insertion points or end of string

        while ((*pchEndCopy != NULL) && (IsDBCSLeadByte(*pchEndCopy) || (*pchEndCopy != '|')))
            pchEndCopy = CharNextA(pchEndCopy);

        // cat from start-of-copy to end-of-copy onto return string
        strncat(szReturned, pchStartCopy, DIFF(pchEndCopy - pchStartCopy));

        // update return string length
        cchRet += DIFF(pchEndCopy - pchStartCopy);

        // if we are at end of pattern, exit
        if(*pchEndCopy == NULL)
            goto Exit;

        if(cActualInserts < cInserts)
            {
            // if inserts remain, cat the next one onto return string
            strcat(szReturned, ppszInserts[cActualInserts]);
            // update return string length
            cchRet += strlen(ppszInserts[cActualInserts]);
            cActualInserts++;
            }

        // advance end-of-copy and start-of-copy beyond insertion point
        pchEndCopy++;
        pchStartCopy = pchEndCopy;
        }

Exit:
    // null-terminate return string
    szReturned[cchRet] = NULL;
    }

/*  ============================================================================
    CchPathFromFilespec
    Returns a filespec's path length (exclusive of filespec)
    NOTE path string includes trailing '\' or '/'

    Returns:
        Length of path string
    Side effects:
        None
*/
UINT
CchPathFromFilespec
(
LPCTSTR  szFileSpec  // filespec
)
    {

    TCHAR* p1 = _tcsrchr(szFileSpec, _T('\\'));
    TCHAR* p2 = _tcsrchr(szFileSpec, _T('/'));        // this wont be a DBCS trail byte.

    if (p1 == NULL && p2 == NULL)
        THROW(E_FAIL);

    return (UINT) ((((LPTSTR)max(p1,p2) - szFileSpec)) + 1);
    }

/*  ============================================================================
    GetPathFromParentAndFilespec
    Returns an absolute path which is a 'parent' file's path concatenated with a filespec.

    Returns:
        absolute path (out-parameter)
    Side effects:
        None
*/
void
GetPathFromParentAndFilespec
(
LPCTSTR  szParentPath,   // parent path
LPCTSTR  szFileSpec,     // filespec
LPTSTR*  pszPath         // resolved path (out-parameter)
)
    {
    UINT    cchParentPath = CchPathFromFilespec(szParentPath);

	if ((cchParentPath + _tcslen(szFileSpec)) > MAX_PATH)
		THROW(E_FAIL);
	
    _tcsncpy(*pszPath, szParentPath, cchParentPath);
    _tcscpy(*pszPath + cchParentPath, szFileSpec);
    }

/*  ============================================================================
    HandleAccessFailure
    Handles an access-denied failure

    Returns:
        nothing
    Side effects:
        none
*/
void
HandleAccessFailure
(
CHitObj*    pHitObj,	// browser's hitobj
TCHAR *     szFile		// file path of main template
)
    {
    Assert(pHitObj);

        // debugging diagnostic print
#if DBG

    STACK_BUFFER( authUserBuff, 32 );

    char *szAuthUser;
    DWORD cbAuthUser;

    if (SERVER_GET(pHitObj->PIReq(), "AUTH_USER", &authUserBuff, &cbAuthUser)) {
	    szAuthUser = (char*)authUserBuff.QueryPtr();
    }
    else {
            szAuthUser = "anonymous";
    }

#if UNICODE
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %S\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#else
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %s\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#endif
    DBGPRINTF((DBG_CONTEXT, "  The user account is \"%s\"\n", szAuthUser));
#endif

    CResponse *pResponse = pHitObj->PResponse();
    if (!pResponse)
        return;

    pHitObj->PIReq()->SetDwHttpStatusCode(401);
    HandleSysError(401,3,IDE_401_3_ACCESS_DENIED,IDH_401_3_ACCESS_DENIED,pHitObj->PIReq(),pHitObj);


    return;
    }

/*  ============================================================================
    SendToLog
    Sends Error Info to Log

    Returns:
        Nothing

    Side effects:
        None.
*/
void
SendToLog
(
DWORD   dwMask,
CHAR    *szFileName,
CHAR    *szLineNum,
CHAR    *szEngine,
CHAR    *szErrCode,
CHAR    *szShortDes,
CHAR    *szLongDes,
CHitObj *pHitObj    // browser's hitobj
)
{
    CHAR    *szFileNameT;
    CHAR    *szLineNumT;
    CHAR    *szEngineT;
    CHAR    *szErrCodeT;
    CHAR    *szShortDesT;
    CHAR    *szLongDesT;
    if(pHitObj) {
        // NOTE - szFileName is assumed to be UTF8 when UNICODE is defined
        szFileNameT = StringDupA(szFileName);
        szLineNumT  = StringDupA(szLineNum);
        szEngineT   = StringDupA(szEngine);
        szErrCodeT  = StringDupA(szErrCode);
        szShortDesT = StringDupA(szShortDes);
        szLongDesT  = StringDupA(szLongDes);

        HandleError(szShortDesT, szLongDesT, dwMask, szFileNameT, szLineNumT, szEngineT, szErrCodeT, NULL, pHitObj);
        }
    }

/*  ============================================================================
    FreeNullify
    Frees and nullifies a ptr to memory allocated with malloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
FreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        free(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    SmallTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::SmallMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
SmallTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::SmallFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    LargeTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::LargeMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
LargeTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::LargeFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    GetProgLangId
    Gets the prog lang id for a script engine

    Returns:
        Nothing
    Side effects:
        throws on error
*/
HRESULT
GetProgLangId
(
CByteRange&     brEngine,   // engine name
PROGLANG_ID*    pProgLangId // prog lang id (out-parameter)
)
    {

    STACK_BUFFER( tempEngine, 128 );

    if (!tempEngine.Resize(brEngine.m_cb + 1)) {
        return E_OUTOFMEMORY;
    }

    LPSTR           szProgLang = static_cast<LPSTR> (tempEngine.QueryPtr());

    strncpy(szProgLang, (LPCSTR)brEngine.m_pb, brEngine.m_cb);
    szProgLang[brEngine.m_cb] = '\0';

    return g_ScriptManager.ProgLangIdOfLangName((LPCSTR) szProgLang, pProgLangId);
    }

/*  ****************************************************************************
    CByteRange member functions
*/

/*  ========================================================
    CByteRange::Advance
    Advances a byte range.
*/
void
CByteRange::Advance(UINT i)
    {
    if(i >= m_cb)
        {
        Nullify();
        }
    else
        {
        m_pb += i;
        m_cb -= i;
        }
    }

/*  ========================================================
    CByteRange::FMatchesSz
    Compares a byte range with a string, case-insensitively
*/
BOOLB
CByteRange::FMatchesSz
(
LPCSTR psz
)
    {
    if(IsNull() || (psz == NULL))
        return FALSE;
    if((ULONG)strlen(psz) != m_cb)
        return FALSE;
    return !_strnicmp((const char*)m_pb, psz, m_cb);
    }

/*  ============================================================================
    CByteRange::PbString
    Finds a case-insensitive string within a byte range

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
    Side effects:
        None
*/
BYTE*
CByteRange::PbString
(
LPSTR   psz,
LONG    lCodePage
)
    {
    UINT cch = strlen(psz);
    if(cch == 0)
        return NULL;

    BYTE *pbLocal  = m_pb;
    UINT  cbLocal  = m_cb;
    char  ch0 = psz[0];
    BYTE *pbTemp = NULL;
    UINT cbAdvanced = 0;

    if (IsCharAlpha(ch0))
        {
        // cannot use strchr
        while (cbLocal >= cch)
            {
            if (_strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;

            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }
    else
        {
        // can use strchr
        while (cbLocal >= cch)
            {
            pbTemp = (BYTE *)memchr(pbLocal, ch0, cbLocal);
            if (pbTemp == NULL)
                break;
            UINT cbOffset = DIFF(pbTemp - pbLocal);
            if (cbOffset >= cbLocal)
                break;
            pbLocal = pbTemp;
            cbLocal -= cbOffset;
            if (cch <= cbLocal && _strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;
            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }

    return NULL;
    }

/*  ============================================================================
    CByteRange::PbOneOfAspOpenerStringTokens
    Finds a case-insensitive string within a byte range
        that matches one of the strings passed

!!! WILL ONLY WORK IF THE FOLLOWING IS TRUE:
        1) All the tokens start with the same charater (for example '<')
        2) This character is not alpha (so that strchr() would work)
!!! THE ABOVE ASSUMPTIONS MAKE THE CODE WORK FASTER

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
        *pcindex is set to the index of string found
    Side effects:
        None
*/
BYTE*
CByteRange::PbOneOfAspOpenerStringTokens
(
LPSTR rgszTokens[],
UINT rgcchTokens[],
UINT nTokens,
UINT *pidToken
)
{
    if (nTokens == 0)
        return NULL;

    BYTE *pb  = m_pb;               // pointer to unsearched remainder of the range
    UINT  cbRemainder = m_cb;       // remaining byte range length
    char  ch0 = rgszTokens[0][0];   // first char of every token

    while (cbRemainder > 0) {
        // BUG 82331: avoid strchr() because byte range is not null-terminated
        while (cbRemainder > 0 && *pb != ch0)
            {
            ++pb;
            --cbRemainder;
            }

        if (cbRemainder == 0)
            break;

        for (UINT i = 0; i < nTokens; i++) {

            if ((rgcchTokens[i] <= cbRemainder)
                && (rgszTokens[i] != NULL)
                && (_strnicmp((const char *)pb, rgszTokens[i], rgcchTokens[i]) == 0)) {

                *pidToken = i;
                return pb;
            }
        }
        ++pb;
        --cbRemainder;
    }

    return NULL;
}


/*  ============================================================================
    CByteRange::FEarlierInSourceThan
    Does this byte range occur earlier in source than parameter byte range?

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CByteRange::FEarlierInSourceThan(CByteRange& br)
    {
    if(br.IsNull())
        return TRUE;
    return(m_idSequence < br.m_idSequence);
    }

/*  ****************************************************************************
    CTemplate member functions
*/


/*  ============================================================================
    CTemplate::CTemplate
    Ctor
*/
CTemplate::CTemplate()
: m_pWorkStore(NULL),
  m_fGlobalAsa(FALSE),
  m_fReadyForUse(FALSE),
  m_fDontAttach(FALSE),
  m_hEventReadyForUse(NULL),
  m_fDebuggerDetachCSInited(FALSE),
  m_pbStart(NULL),
  m_cbTemplate(0),
  m_cRefs(1),                           // NOTE ctor AddRefs implicitly
  m_pbErrorLocation(NULL),
  m_idErrMsg(0),
  m_cMsgInserts(0),
  m_ppszMsgInserts(NULL),
  m_cScriptEngines(0),
  m_rgrgSourceInfos(NULL),
  m_rgpDebugScripts(NULL),
  m_rgpFilemaps(NULL),
  m_cFilemaps(0),
  m_rgpSegmentFilemaps(NULL),
  m_cSegmentFilemapSlots(0),
  m_wCodePage(CP_ACP),
  m_lLCID(LOCALE_SYSTEM_DEFAULT),
  m_ttTransacted(ttUndefined),
  m_fSession(TRUE),
  m_fScriptless(FALSE),
  m_fDebuggable(FALSE),
  m_fIsValid(FALSE),
  m_fDontCache(FALSE),
  m_fZombie(FALSE),
  m_fCodePageSet(FALSE),
  m_fLCIDSet(FALSE),
  m_fIsPersisted(FALSE),
  m_fIsUNC(FALSE),
  m_fIsEncrypted(FALSE),
  m_szPersistTempName(NULL),
  m_szApplnVirtPath(NULL),
  m_szApplnURL(NULL),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_pdispTypeLibWrapper(NULL),
  m_dwLastErrorMask(S_OK),
  m_hrOnNoCache(S_OK),
  m_cbTargetOffsetPrevT(0),
  m_pHashTable(NULL),
  m_pServicesConfig(NULL),
  m_cUseCount(1),
  m_pMostRecentImpersonatedTokenUser (NULL),
  m_pMostRecentImpersonatedSID(NULL),
  m_cbTokenUser(0),
  m_fNeedsMonitoring(FALSE),
  m_fInCheck(FALSE),
  m_dwLastMonitored (0),
  m_dwLastAccessCheck(0),
  m_fTemplateLockInited(FALSE),
  m_dwCacheTag(0)
{
    m_wCodePage = GetACP();

     for (UINT i = 0; i < ILE_MAX; i++)
    {
        m_pszLastErrorInfo[i] = NULL;
    }

     IF_DEBUG(TEMPLATE)
     {
        WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
     }
#if PER_TEMPLATE_REFLOG
     m_pTraceLog = CreateRefTraceLog (100,0);
     WriteRefTraceLog (m_pTraceLog,m_cRefs, this);
#endif
  }

/*  ============================================================================
    CTemplate::~CTemplate
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::~CTemplate()
    {
    DBGPRINTF(( DBG_CONTEXT, "Deleting template, m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));

    // first, remove this template from its inc-files' template lists
    // NOTE must do this before freeing template memory
    RemoveFromIncFiles();

    // Remove the template from the debugger's list of documents
    Detach();

    PersistCleanup();

    if(m_rgpFilemaps)
        {
        for(UINT i = 0; i < m_cFilemaps; i++)
            delete m_rgpFilemaps[i];
        SmallTemplateFreeNullify((void**) &m_rgpFilemaps);
        }

    FreeGoodTemplateMemory();

    if (m_pWorkStore)
        delete m_pWorkStore;

    //FileName, LineNum, Engine, ErrorCode, ShortDes, LongDes
    for(UINT iErrInfo = 0; iErrInfo < ILE_MAX; iErrInfo++)
        {
        FreeNullify((void**) &m_pszLastErrorInfo[iErrInfo]);
        }

    if(m_hEventReadyForUse != NULL)
        CloseHandle(m_hEventReadyForUse);

    if (m_LKHashKey.szPathTranslated)
		free((void *)m_LKHashKey.szPathTranslated);

    if (m_szApplnURL)
        delete [] m_szApplnURL;

    if (m_fDebuggerDetachCSInited)
        DeleteCriticalSection(&m_csDebuggerDetach);

    if (m_fTemplateLockInited)
        DeleteCriticalSection(&m_csTemplateLock);

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    if (m_szPersistTempName)
        CTemplate::LargeFree(m_szPersistTempName);

    if (m_pMostRecentImpersonatedTokenUser)
        CTemplate::SmallFree(m_pMostRecentImpersonatedTokenUser);

    if (m_pServicesConfig)
        m_pServicesConfig->Release();

    m_pServicesConfig = NULL;

#if PER_TEMPLATE_REFLOG
    DestroyRefTraceLog (m_pTraceLog);
#endif
}

/*  ============================================================================
    CTemplate::QueryInterface
    Provides QueryInterface implementation for CTemplate

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CTemplate::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CTemplate::AddRef
    Adds a ref to this template, thread-safely
*/
ULONG
CTemplate::AddRef()
    {
    LONG cRefs = InterlockedIncrement(&m_cRefs);

    Assert(FImplies(m_fIsValid,FImplies(cRefs > 1, m_pbStart != NULL)));
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }

#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    return cRefs;
    }

/*  ============================================================================
    CTemplate::Release
    Releases a ref to this template, thread-safely
*/
ULONG
CTemplate::Release()
{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }

#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    if (cRefs == 0)
        delete this;

    return cRefs;
}

/*  ============================================================================
    CTemplate::InitClass
    Initilaizes CTemplate static members

    Returns:
        hresult
    Side effects:
        allocates memory for static members
*/
HRESULT
CTemplate::InitClass
(
)
{
    HRESULT hr = S_OK;

    TRY
        // init heaps
        sm_hSmallHeap = ::HeapCreate(0, 0, 0);
        if (!sm_hSmallHeap)
            return E_OUTOFMEMORY;

        sm_hLargeHeap = ::HeapCreate(0, 0, 0);
        if (!sm_hLargeHeap)
            return E_OUTOFMEMORY;

        // Init token list
        gm_pTokenList = new CTokenList;
                if (gm_pTokenList == NULL)
                        return E_OUTOFMEMORY;

        gm_pTokenList->Init();

    CATCH(hrException)
        hr = hrException;
    END_TRY

    return hr;
}

/*  ============================================================================
    CTemplate::UnInitClass
    Un-initilaizes CTemplate static members

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::UnInitClass()
{
    if (gm_pTokenList)
    {
        delete gm_pTokenList;
        gm_pTokenList = NULL;
    }

    if (sm_hLargeHeap)
        ::HeapDestroy(sm_hLargeHeap);
    
    if (sm_hLargeHeap != sm_hSmallHeap)
    {
        if (sm_hSmallHeap)
            ::HeapDestroy(sm_hSmallHeap);
    }
    
    sm_hLargeHeap = sm_hSmallHeap = NULL;
}


/*  ============================================================================
    CTemplate::Init
    Inits template in preparation for calling Compile
    Does the minimum needed

    Returns:
        Success or failure code
    Side effects:
        Allocates memory
*/
HRESULT
CTemplate::Init
(
CHitObj            *pHitObj,            // ptr to template's hit object
BOOL                fGlobalAsa,         // is this the global.asa file?
const CTemplateKey &rTemplateKey        // hash table key
)
    {
    HRESULT hr;

    // Create debug critical section
    ErrInitCriticalSection(&m_csDebuggerDetach, hr);
    if (SUCCEEDED(hr))
    {
        ErrInitCriticalSection(&m_csTemplateLock,hr);
        if (FAILED(hr))
        {
            DeleteCriticalSection(&m_csDebuggerDetach);
            return hr;
        }
        // note critical section creation success
        m_fDebuggerDetachCSInited = TRUE;
        m_fTemplateLockInited = TRUE;
    }
    else //FAILED(hr)
        return hr;

    // Create event: manual-reset, ready-for-use event; non-signaled
    m_hEventReadyForUse = IIS_CREATE_EVENT(
                              "CTemplate::m_hEventReadyForUse",
                              this,
                              TRUE,     // flag for manual-reset event
                              FALSE     // flag for initial state
                              );
    if (!m_hEventReadyForUse)
        return E_OUTOFMEMORY;

    // cache GlobalAsp flag
    m_fGlobalAsa = BOOLB(fGlobalAsa);

    // CIsapiReqInfo better be present
    if (pHitObj->PIReq() == NULL)
        return E_POINTER;

    // Initialize the template's code page

    m_wCodePage = pHitObj->PAppln()->QueryAppConfig()->uCodePage();
    m_lLCID = pHitObj->PAppln()->QueryAppConfig()->uLCID();

    STACK_BUFFER( serverNameBuff, 32 );
    STACK_BUFFER( serverPortBuff, 10 );
    STACK_BUFFER( portSecureBuff, 8 );

    DWORD cbServerName;
    DWORD cbServerPort;
        DWORD cbServerPortSecure;

    // Construct a URL for the application

    // Get the server name and port
    if (!SERVER_GET(pHitObj->PIReq(), "SERVER_NAME", &serverNameBuff, &cbServerName)
        || !SERVER_GET(pHitObj->PIReq(), "SERVER_PORT", &serverPortBuff, &cbServerPort)) {

        if (GetLastError() == ERROR_OUTOFMEMORY) {
            hr = E_OUTOFMEMORY;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    char *szServerPort = (char *)serverPortBuff.QueryPtr();
    char *szServerName = (char *)serverNameBuff.QueryPtr();

    BOOL fServerPortSecure = FALSE;

	// determine if server port is secure
    if (SERVER_GET(pHitObj->PIReq(), "SERVER_PORT_SECURE", &portSecureBuff, &cbServerPortSecure)) {
	    char *szServerPortSecure = (char *)portSecureBuff.QueryPtr();
        fServerPortSecure = (szServerPortSecure[0] == '1');
    }

    // Get the application virtual path
    TCHAR szApplnVirtPath[256];
    if (FAILED(hr = FindApplicationPath(pHitObj->PIReq(), szApplnVirtPath, sizeof szApplnVirtPath)))
        return hr;

    TCHAR   *szServerNameT;
    TCHAR   *szServerPortT;

#if UNICODE
    CMBCSToWChar convServer;
    if (FAILED(hr = convServer.Init(szServerName))) {
        return hr;
    }
    szServerNameT = convServer.GetString();
#else
    szServerNameT = szServerName;
#endif

#if UNICODE
    CMBCSToWChar convPort;
    if (FAILED(hr = convPort.Init(szServerPort))) {
        return hr;
    }
    szServerPortT = convPort.GetString();
#else
    szServerPortT = szServerPort;
#endif

    // Allocate space for and construct the application URL
    m_szApplnURL = new TCHAR [(9 /* sizeof "https://:" */ + _tcslen(szServerNameT) + _tcslen(szServerPortT) + _tcslen(szApplnVirtPath) + 1)];
    if (m_szApplnURL == NULL)
        return E_OUTOFMEMORY;

    TCHAR *pT;

    // start with the protocol prefix...

    pT = strcpyEx(m_szApplnURL, fServerPortSecure? _T("https://") : _T("http://"));

    // next add the servername

    pT = strcpyEx(pT, szServerNameT);

    // next the colon between the servername and the serverport

    pT = strcpyEx(pT, _T(":"));

    // next the server port

    pT = strcpyEx(pT, szServerPortT);

    // now the applURL is built up to the appln path.  The next step will be to
    // add the virtpath.

    m_szApplnVirtPath = pT;

    _tcscpy(m_szApplnVirtPath, szApplnVirtPath);

    m_LKHashKey.dwInstanceID = rTemplateKey.dwInstanceID;
    if ((m_LKHashKey.szPathTranslated = StringDup((TCHAR *)rTemplateKey.szPathTranslated)) == NULL)
    	return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Compile
    Compiles the template from its source file and include files, if any,
    by calling GetSegmentsFromFile (to populate WorkStore),
    followed by WriteTemplate (to create the template from WorkStore).

    Returns:
        HRESULT indicating success or type of failure
    Side effects:
        Indirectly allocates memory (via WriteTemplate)
        Indirectly frees memory on error (via FreeGoodTemplateMemory)
*/
HRESULT
CTemplate::Compile
(
CHitObj*    pHitObj
)
    {
    HRESULT hr = S_OK;
    HRESULT hRes = S_OK;

    // The following code moved from Init() (to make Init() lighter)

    Assert(pHitObj);

    // Create and Init WorkStore

    if (SUCCEEDED(hr))
        {
        // construct the workstore - bail on fail
        if(NULL == (m_pWorkStore = new CWorkStore))
            hr = E_OUTOFMEMORY;
        }

    if (SUCCEEDED(hr))
        {
        hr = (m_pWorkStore->m_ScriptStore).Init(pHitObj->QueryAppConfig()->szScriptLanguage(),
                                                pHitObj->QueryAppConfig()->pCLSIDDefaultEngine());

        if (hr == TYPE_E_ELEMENTNOTFOUND)
            {
            // default script language in registry is bogus - send error msg to browser
            HandleCTemplateError(
                                NULL,                                   // source file map
                                NULL,                                   // ptr to source location where error occurred
                                IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY,  // error message id
                                0,                                      // count of insert strings for error msg
                                NULL,                                   // array of ptrs to error msg insert strings
                                pHitObj                                 // Browser Request
                                );
            }

        if (FAILED(hr))
            {
            delete m_pWorkStore;
            m_pWorkStore = NULL;
            }
        }

    // Try to init the workstore and map main file - this can fail with oom, etc or user lacks permissions

    if (SUCCEEDED(hr))
        {
        TRY
            m_pWorkStore->Init();
            AppendMapFile(
                        NULL,       // file spec for this file - NULL means get filespec from pHitObj
                        NULL,       // ptr to filemap of parent file
                        FALSE,      // don't care
                        pHitObj,    // ptr to template's hit object
                        m_fGlobalAsa    // is this the global.asa file?
                        );

        CATCH(hrException)
            delete m_pWorkStore;
            m_pWorkStore = NULL;

            hr = hrException;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj,
                                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

            if ((hr != E_COULDNT_OPEN_SOURCE_FILE) && m_rgpFilemaps && m_rgpFilemaps[0])
                {
                // empty file will fail to map but will have a handle, so we check for it here
                if (0 == m_rgpFilemaps[0]->GetSize())
                    hr = E_SOURCE_FILE_IS_EMPTY;

                m_rgpFilemaps[0]->UnmapFile();
                }

            if (SUCCEEDED(hr))
                hr = E_FAIL;    // make sure the error is set
        END_TRY
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_rgpFilemaps[0]);
        Assert(m_rgpFilemaps[0]->m_szPathTranslated);
        Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
        Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));
        Assert(0 < m_rgpFilemaps[0]->GetSize());
        }

    // Record the user who compiled this file (used specifically in UNC). Cannot proceed if there was an error (typically OOM) or Access problem.
    if (FAILED(hr) || FAILED (hRes = GetSIDFromTokenHandle(pHitObj->HImpersonate(),
                                                           m_pMostRecentImpersonatedSID,
                                                           m_pMostRecentImpersonatedTokenUser,
                                                           &m_cbTokenUser)
                            )
      )
        {
        m_fDontCache = TRUE;
        // OK, cache HR if m_fDontCache is true
        // later, another thread might find this template from the cache even if the template
        // has some error and marked as DontCache.
        m_hrOnNoCache = FAILED(hr) ? hr : hRes;
        m_fReadyForUse = TRUE;
        SetEvent(m_hEventReadyForUse);
        return hr;
        }

    // End of Code moved from Init()

    // By default we are not in a transaction
    m_ttTransacted = ttUndefined;
    // By default session is required
    m_fSession = TRUE;
    // By default assume script exists
    m_fScriptless = FALSE;

    // we assert, in effect, that template is already init'ed
    Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
    Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));

    TRY
        // Get source segments from source file
        GetSegmentsFromFile(*(m_rgpFilemaps[0]), *m_pWorkStore, pHitObj);

        /*  get "language equivalents" for primary languagefrom registry
            NOTE we do this here because the user can reset the primary language in the script file,
            so we must wait until after GetSegmentsFromFile()
        */
        GetLanguageEquivalents();

        // Call WriteTemplate, which writes out template components to contiguous memory,
        // resulting in a compiled template
        // CWriteTemplate...class does the processing and is freed when the Compile completes.
        // However, it leaves the compiled template in the heap pointed to by m_pbStart (sideeffect).
        CWriteTemplate writeTempl;

        // Initialize the WriteTemplate object
        writeTempl.Init (m_pWorkStore, this, pHitObj->PAppln()->QueryAppConfig()->fCalcLineNumber());

        // Perform estimation and write template
        writeTempl.WriteTemplate();

        // Record Compilation Cache Tag.
        m_dwCacheTag = g_TemplateCache.GetCacheTag();

        m_dwLastAccessCheck = GetTickCount();

        //
        //  If any of the Include files are on a UNC or are encrypted then reflect that in the template structure
        //
        for (unsigned i = 0; i < m_cFilemaps; ++i)
        {
            m_fIsUNC |= m_rgpFilemaps[i]->m_fIsUNCPath;
            m_fIsEncrypted |= m_rgpFilemaps[i]->m_fIsEncryptedFile;

            m_rgpFilemaps[i]->CountChars((WORD)m_wCodePage);
        }

        // Wrap typelibs into single IDispatch*
        WrapTypeLibs(pHitObj);

        m_fIsValid = TRUE;

    CATCH(hrException)
        // NOTE: we used to free template memory here.  Now we do not because if the
        // error was E_USER_LACKS_PERMISSIONS, and template is in cache, we don't want
        // to sabotage future requests. There's no need to decache the template.
        //
        // The template destructor will free this memory anyway.
        //
        hr = hrException;
    END_TRY

    // check if scriptless
    if (!m_fGlobalAsa)
        {
        // count various stuff to make the determination
        DWORD cScriptEngines         = m_pWorkStore->m_ScriptStore.CountPreliminaryEngines();
        DWORD cPrimaryScriptSegments = (cScriptEngines > 0) ? m_pWorkStore->m_ScriptStore.m_ppbufSegments[0]->Count() : 0;
        DWORD cObjectTags            = m_pWorkStore->m_ObjectInfoStore.Count();
        DWORD cHtmlSegments          = m_pWorkStore->m_bufHTMLSegments.Count();
        DWORD c449Cookies            = m_rgp449.length();
        BOOL  fPageCommandsPresent   = m_pWorkStore->m_fPageCommandsExecuted;

        if (cScriptEngines <= 1         &&
            cPrimaryScriptSegments == 0 &&
            cObjectTags == 0            &&
            cHtmlSegments == 1          &&
            c449Cookies == 0            &&
            !fPageCommandsPresent)
            {
            m_fScriptless = TRUE;
            }
        }

    // free working storage - no longer needed
    delete m_pWorkStore;
    m_pWorkStore = NULL;

    // un-map filemaps - NOTE filemaps stay around for possible post-compile errors (e.g., script failure)
    UnmapFiles();

    // Debugging: print data structure to debugger
        IF_DEBUG(SCRIPT_DEBUGGER)
                {
                if (SUCCEEDED(hr))
                        {
                        DBGPRINTF((DBG_CONTEXT, "Script Compiled\n"));

                        for (UINT i = 0; i < m_cScriptEngines; ++i)
                                {
                                char *szEngineName;
                                PROGLANG_ID *pProgLangID;
                                const wchar_t *wszScriptText;

                                GetScriptBlock(i, &szEngineName, &pProgLangID, &wszScriptText);
                                DBGPRINTF((DBG_CONTEXT, "Engine %d, Language=\"%s\":\n", i, szEngineName));
                DBGINFO((DBG_CONTEXT, (char *) wszScriptText));
                DBGINFO((DBG_CONTEXT, "\n"));
				}
			}
        }

    if (hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE)
    {
        m_fDontCache = TRUE;
        m_hrOnNoCache = hr;
    }

    // Set ready-for-use flag true and event to signaled
    // NOTE we do this whether success or failure, since even a failed-compile template
    // will remain in the cache to allow template cache mgr to satisfy requests on it
    m_fReadyForUse = TRUE;
    SetEvent(m_hEventReadyForUse);

    // Note whether the template currently is debuggable
    // BUG BUG: Template is debuggable or not based on first app. If shared between a debug
    //          & non-debug app, the first application wins.
    m_fDebuggable = (BOOLB)!!pHitObj->PAppln()->FDebuggable();

    return hr;
    }

/*  ============================================================================
    CTemplate::Deliver
    Delivers template to caller once template is ready for use
    NOTE 'compile failure' == template is 'ready for use' but did not compile successfully;
    this allows cache mgr to keep a failed template in cache in case it gets requested again

    Returns
        success or failure
    Side effects
        none
*/
HRESULT
CTemplate::Deliver
(
CHitObj*    pHitObj
)
{
    // NOTE: There was a compiler bug where 'ps' would not be correctly aligned,
    //       EVEN if it was declared to be a DWORD array, if 'ps' was nested in
    //       a block.  Thus declare it here.
    //
    BYTE    ps[SIZE_PRIVILEGE_SET];                     // privilege set
    HRESULT hr = S_OK;

    BOOL    fImpersonatedUser = FALSE;
    HANDLE  hVirtIncImpToken = NULL;
    HANDLE  hCurImpToken = NULL;

    // if ready flag is not yet set block until template is ready for use
    if(!m_fReadyForUse)
    {
        WaitForSingleObject(m_hEventReadyForUse, INFINITE);
        Assert(m_fReadyForUse); // when event unblocks, flag will be set
    }

    if (m_pbStart == NULL)
    {
        if (m_fDontCache && m_dwLastErrorMask == 0)
        {
            DBGPRINTF((DBG_CONTEXT, "template compile failed with %08x\n", m_hrOnNoCache));
            DBG_ASSERT(FAILED(m_hrOnNoCache));

                        // Safety net: always fail, even if "m_hrOnNoCache" did not get set somehow.
            hr = m_hrOnNoCache;
                        if (SUCCEEDED(m_hrOnNoCache))
                                hr = E_FAIL;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj, (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

            return hr;
        }
        // template compile failed  - NOTE null start-of-template ptr == template compile failed
        // use cached error info
        SendToLog(  m_dwLastErrorMask,
                    m_pszLastErrorInfo[ILE_szFileName],
                    m_pszLastErrorInfo[ILE_szLineNum],
                    m_pszLastErrorInfo[ILE_szEngine],
                    m_pszLastErrorInfo[ILE_szErrorCode],
                    m_pszLastErrorInfo[ILE_szShortDes],
                    m_pszLastErrorInfo[ILE_szLongDes],
                    pHitObj);
        hr = E_TEMPLATE_COMPILE_FAILED;
    }
    else if (!pHitObj->FIsBrowserRequest())
    {
        return hr;
    }
    else
    // template compile succeeded  - check user's file permissions
    // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
    {
        HANDLE          hUserAccessToken = pHitObj->HImpersonate(); // current user's access token
        DWORD           dwPS = sizeof(ps);                          // privilege set size
        DWORD           dwGrantedAccess;                            // granted access mask
        BOOL            fAccessGranted;                             // access granted flag
        GENERIC_MAPPING gm = {                                      // generic mapping struct
                                FILE_GENERIC_READ,
                                FILE_GENERIC_WRITE,
                                FILE_GENERIC_EXECUTE,
                                FILE_ALL_ACCESS
                            };

        ((PRIVILEGE_SET*)ps)->PrivilegeCount = 0;                  // set privilege count to 0

        Assert(NULL != hUserAccessToken);

        HRESULT  HRes = E_FAIL;
        BOOL fNeedsUpdate = FALSE;
        PSID pPrevSid = NULL;
        PSID pSid=NULL;
        DWORD  cbTempTokenBuffer = 0;
        LPVOID  pvTempTokenBuffer = NULL;
        DWORD  dwAccessCheckTimeStamp = 0;

        //
        // Obtain a lock on the template so that only one Deliver will update the credentials while the others will just fall through
        // Only one process should write the timestamp/impersonation token.
        // If the File is either UNC or is Encrypted then we need to go through all the access check doors
        //

        if (m_fIsUNC)
        {
            EnterCriticalSection(&m_csTemplateLock);
                pPrevSid = m_pMostRecentImpersonatedSID;
                dwAccessCheckTimeStamp = m_dwLastAccessCheck;
            LeaveCriticalSection(&m_csTemplateLock);

            // GetCurrent Users Impersonation Token
            HRes = GetSIDFromTokenHandle(pHitObj->HImpersonate(), pSid,pvTempTokenBuffer, &cbTempTokenBuffer);
        }

        for(UINT i = 0; i < m_cFilemaps; i++)
        {
            if (!(m_rgpFilemaps[i]->FHasUNCPath()))
            {
                if(NULL == m_rgpFilemaps[i]->m_pSecurityDescriptor) //? Dunno why we should continue. This could be a security Issue?
                    continue;

                if(!AccessCheck(
                            m_rgpFilemaps[i]->m_pSecurityDescriptor,    // pointer to security descriptor
                            hUserAccessToken,       // handle to client access token
                            FILE_GENERIC_READ,      // access mask to request
                            &gm,                    // address of generic-mapping structure
                            (PRIVILEGE_SET*)ps,     // address of privilege-set structure
                            &dwPS,                  // address of size of privilege-set structure
                            &dwGrantedAccess,       // address of granted access mask
                            &fAccessGranted         // address of flag indicating whether access granted
                            ))
                    return E_FAIL;

                if(!fAccessGranted)
                {
                    // if access is denied on any file, handle the failure and return
                    HandleAccessFailure(pHitObj, m_rgpFilemaps[0]->m_szPathTranslated);
                    return E_USER_LACKS_PERMISSIONS;
                }
            }
            else //if it is a UNC
            {
                //
                // Get the SID for current thread and compare with compiled/lastAccessed sid.
                // If the SIDs match and we are within the TTL, skip the test.
                //
                // If either of the conditions are not met, go onto remote UNC box to refresh credentials.
                //
                    if(  !pPrevSid                              // could not store the previous SID
                        || (FAILED (HRes))                      // could not obtain SID
                        || !EqualSid(pPrevSid,  pSid)             // different users
                        || (EqualSid(pPrevSid, pSid ) && CheckTTLTimingWindow(dwAccessCheckTimeStamp, g_dwFileMonitoringTimeoutSecs))
                                                               // same user but outside TTL
                      )
                    {
                        //
                        // Perform impersonation on the target user
                        //
                        fImpersonatedUser = FALSE;
                        hVirtIncImpToken = NULL;
                        hCurImpToken = NULL;

                        // TODO: Could be a PERF bottleneck, if we are going to the same UNC.
                        // TODO: Try to Somehow store the previous Impersonation token and if they are the same then dont get the token again.
                        // TODO: Beware...this could be messy.

                        //
                        // We must Impersonate LoggedOnUser only in the UNC case.
                        // In the Encrypted case the current threads credentials should be able to open the file.
                        //
                        if (SUCCEEDED(pHitObj->PIReq()->GetVirtualPathToken(m_rgpFilemaps[i]->m_szPathInfo, &hVirtIncImpToken)))
                        {
                            // set the impersonation token and note that we did so
                            // NOTE - there is intentionally no error checking.  The
                            // assumption being that we are doing best effort at the
                            // impersonation because throwing an error here could be
                            // tricky for the user to interpret the problem.  However,
                            // if the impersonation fails, and ASP can still open the
                            // file (e.g. passthru authentication), then everyone's
                            // happy.

                            AspDoRevertHack(&hCurImpToken);

                            fImpersonatedUser = ImpersonateLoggedOnUser(hVirtIncImpToken);

                            if (!fImpersonatedUser)
                            {
                                AspUndoRevertHack(&hCurImpToken);
                            }

                        }

                        //
                        // Check existence of file...go thru all doors
                        //
                        hr = AspGetFileAttributes (m_rgpFilemaps[i]->m_szPathTranslated);

                        //
                        // Undo impersonation if any.
                        //
                        if (fImpersonatedUser)
                            AspUndoRevertHack(&hCurImpToken);
                        if (hVirtIncImpToken)
                            CloseHandle(hVirtIncImpToken);

                        if (FAILED(hr))
                        {
                            // Too bad...(actually maybe good) the user does not have access to the share.
                            // if access is denied on any file, handle the failure and return
                            HandleAccessFailure(pHitObj, m_rgpFilemaps[0]->m_szPathTranslated);
                            return E_USER_LACKS_PERMISSIONS;
                        }

                        fNeedsUpdate = TRUE;
                    }

            }
        }

        if (fNeedsUpdate)  // This flag being set also means that there was a UNC path or encrypted file in the main/include files. Thus the first crit sec was entered
        {

            EnterCriticalSection (&m_csTemplateLock);
                m_pMostRecentImpersonatedTokenUser = pvTempTokenBuffer;
                m_pMostRecentImpersonatedSID = pSid;
                m_cbTokenUser = cbTempTokenBuffer;

                m_dwLastAccessCheck = GetTickCount();
            LeaveCriticalSection (&m_csTemplateLock);
        }
    }

    // Reset the Session.CodePage to the script compilation-time codepage
    // only if a code page directive was found during compilation
    if (m_fCodePageSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FCodePageSet()))
    {
        pHitObj->SetCodePage(m_wCodePage);
    }

    // Reset the Session.LCID to the script compilation-time LCID
    // only if an LCID directive was found during compilation
    if (m_fLCIDSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FLCIDSet()))
    {
        pHitObj->SetLCID(m_lLCID);
    }

    return hr;
}


/*  ============================================================================
    CTemplate::GetSIDFromTokenHandle
    Takes a token handle and gets the User SID information corresponding to that token.

    Returns
        HResult
    Side effects
        none
*/

HRESULT CTemplate::GetSIDFromTokenHandle (HANDLE tokenHandle, PSID pSid, LPVOID pBuffer, DWORD *pcbSize)
{
    HRESULT hr = S_OK;
    BOOL    bRet;
    DWORD   cbTokenUserBuffer = 0;
    LPVOID  pvTokenUserBuffer = NULL;

    // Get buffer size
    bRet = GetTokenInformation(tokenHandle,
                             TokenUser,
                             NULL,
                             0,
                             &cbTokenUserBuffer
                             );

    // According to MSDN this call will fail. But we will have a valid value in cbTokenUserBuffer
    // Allocate the space and redo the call
    pvTokenUserBuffer = (BYTE*) CTemplate::SmallMalloc(cbTokenUserBuffer );
    if (!pvTokenUserBuffer)
        return E_OUTOFMEMORY;

    // Get TokenUser
    bRet = GetTokenInformation(tokenHandle,
                             TokenUser,
                             pvTokenUserBuffer,
                             cbTokenUserBuffer,
                             &cbTokenUserBuffer
                             );

    if (!bRet)
    {
        if (pvTokenUserBuffer)
            CTemplate::SmallFree(pvTokenUserBuffer);

        return HRESULT_FROM_WIN32(GetLastError());
    }

    //Free previously allocated TokenUser buffer
    if (pBuffer)
        CTemplate::SmallFree(pBuffer);

    // Write the values to callers buffer
    pBuffer = pvTokenUserBuffer;
    pSid = ((TOKEN_USER *)pvTokenUserBuffer)->User.Sid;
    *pcbSize = cbTokenUserBuffer;

    return hr;
}

/*  ============================================================================
    CTemplate::RemoveIncFile
    Removes (by setting to null) an inc-file ptr from this template's inc-file list.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveIncFile
(
CIncFile*   pIncFile
)
    {

    // If the filemap count is non-zero the pointer to
    // the array of filemaps has better not be null
    DBGPRINTF(( DBG_CONTEXT, "m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));
    Assert((m_cFilemaps <= 0) || (m_rgpFilemaps != NULL));

    // find the inc-file in list
    for(UINT i = 1; (i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile != pIncFile); i++)
        ;

    // assert that we found the inc-file in list
    Assert((i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile == pIncFile));

    // set inc-file ptr null
    m_rgpFilemaps[i]->m_pIncFile = NULL;
    }

/*===================================================================
CTemplate::FTemplateObsolete

Test to see if the files this template depends on have changed since it
was compiled.

We use this in cases where we may have missed a change notification,
for example, when there were too many changes to record in our change
notification buffer. We check the last time the file was written too,
and the security descriptor, since changes to the security descriptor
aren't noted in the file last write time.

Parameters:
    None

Returns:
    TRUE if the template is obsolete, else FALSE
*/
BOOL CTemplate::FTemplateObsolete(VOID)
    {
    BOOL fStatus = FALSE;

    for (UINT i = 0; i < m_cFilemaps; i++)
        {
        if (FFileChangedSinceCached(m_rgpFilemaps[i]->m_szPathTranslated,
                                    m_rgpFilemaps[i]->m_hFile,
                                    m_rgpFilemaps[i]->m_ftLastWriteTime))
            {
            // If the file write time has changed we know enough
            // and can quit here
            fStatus = TRUE;
            break;
            }
        else
            {
            // The file hasn't been writen to, but the security descriptor may
            // have chagned

            // Assert on non-valid security descriptor

            if (NULL != m_rgpFilemaps[i]->m_pSecurityDescriptor)
                {

                PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
                DWORD dwSize = m_rgpFilemaps[i]->m_dwSecDescSize;

                if( 0 == GetSecDescriptor(m_rgpFilemaps[i]->m_szPathTranslated, &pSecurityDescriptor, &dwSize))
                    {
                    if (pSecurityDescriptor)
                        {
                        // if the size is not the same then set fStatus to TRUE no need to compare memory blocks.

                        if(dwSize != GetSecurityDescriptorLength(m_rgpFilemaps[i]->m_pSecurityDescriptor))
                            {
                            fStatus = TRUE;
                            }
                        else
                            {
                            // The size of the security descriptor hasn't changed
                            // but we have to compare the contents to make sure they haven't changed
                            fStatus = !(0 == memcmp(m_rgpFilemaps[i]->m_pSecurityDescriptor, pSecurityDescriptor, dwSize));
                            }

                        // We are done with the descriptor
                        free(pSecurityDescriptor);

                        }
                    else
                        {
                        // Since we failed to get a security descriptor
                        // assume the file has changed.
                        fStatus = TRUE;
                        }
                    }
                }
            }

        // Quit as soon as we find a change
        if (fStatus)
            {
            break;
            }
        }

    return fStatus;
    }


/*  ============================================================================
    CTemplate::GetSourceFileName
    Returns name of source file on which this template is based

    Returns
        source file name
    Side effects
        none
*/
LPTSTR
CTemplate::GetSourceFileName(SOURCEPATHTYPE pathtype)
    {
    if (!m_rgpFilemaps)
        {
        return NULL;
        }

    switch (pathtype)
        {
    case SOURCEPATHTYPE_PHYSICAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathTranslated : NULL));

    case SOURCEPATHTYPE_VIRTUAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathInfo : NULL));

    default:
        return(NULL);
        }
    }

/*  ============================================================================
    CTemplate::Count
    Returns count of components of type tcomp contained in this template

    Returns:
        Count of components of type tcomp
    Side effects:
        None
*/
USHORT
CTemplate::Count
(
TEMPLATE_COMPONENT  tcomp
)
    {
    Assert(NULL != m_pbStart);

    // script engines and script blocks have the same count, stored in same slot
    if(tcomp == tcompScriptEngine)
        tcomp = tcompScriptBlock;

    // counts are stored at start of template in sequential slots, starting with script blocks count
    return * (USHORT*) ((USHORT*)m_pbStart + (tcomp - tcompScriptBlock));
    }

/*  ============================================================================
    CTemplate::GetScriptBlock
    Gets ptrs to script engine name, prog lang id and script text of i-th script block.

    Returns:
        Out-parameters; see below
    Side effects:
        None
*/
void
CTemplate::GetScriptBlock
(
UINT            i,                  // script block id
LPSTR*          pszScriptEngine,    // ptr to script engine name    (out-parameter)
PROGLANG_ID**   ppProgLangId,       // ptr to prog lang id          (out-parameter)
LPCOLESTR*      pwstrScriptText     // ptr to wstr script text      (out-parameter)
)
    {
    CByteRange  brEngine;       // engine name
    CByteRange  brScriptText;   // script text
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned
    BYTE*       pbEngineInfo = GetAddress(tcompScriptEngine, (USHORT)i);    // ptr to engine info

    Assert(pbEngineInfo != NULL);
    Assert(i < CountScriptEngines());

    // Get engine name from start of engine info
    ByteRangeFromPb(pbEngineInfo, brEngine);

    ByteRangeFromPb(GetAddress(tcompScriptBlock, (USHORT)i), brScriptText);

    Assert(!brEngine.IsNull());
    Assert(!brScriptText.IsNull());

    // Advance ptr past name to prog lang id
    //           length of prefix + length of name  + NULL
    pbEngineInfo += (sizeof(UINT) + (*pbEngineInfo) + 1);

    // Get prog lang id - it will be on the next pointer sized boundary
    cbAlignment = (UINT) (((DWORD_PTR) pbEngineInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
       {pbEngineInfo += (sizeof(DWORD) - cbAlignment);}

    *pszScriptEngine = (LPSTR)brEngine.m_pb;
    *ppProgLangId = (PROGLANG_ID*)pbEngineInfo;
    *pwstrScriptText = (LPCOLESTR)brScriptText.m_pb;
    }

/*  ============================================================================
    CTemplate::GetObjectInfo
    Returns i-th object-info in template as object name and
    its clsid, scope, model

    Returns:
        HRESULT
        Out-parameters; see below
    Side effects:
*/
HRESULT
CTemplate::GetObjectInfo
(
UINT        i,              // object index
LPSTR*      ppszObjectName, // address of object name ptr   (out-parameter)
CLSID*      pClsid,         // address of object clsid
CompScope*  pcsScope,       // address of object scope
CompModel*  pcmModel        // address of object threading model
)
    {
    BYTE*       pbObjectInfo = GetAddress(tcompObjectInfo, (USHORT)i);  // ptr to current read location
    CByteRange  brName;         // object name
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned

    Assert(i < Count(tcompObjectInfo));

    // Get name from start of object-info
    ByteRangeFromPb(pbObjectInfo, brName);
    Assert(!brName.IsNull());

    // Advance ptr past name
    //           length of prefix + length of name  + NULL
    pbObjectInfo += (sizeof(UINT) + (*pbObjectInfo) + 1);

    // Get clsid - it will be on the next DWORD boundary
    cbAlignment = (UINT)(((DWORD_PTR) pbObjectInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
        pbObjectInfo += (sizeof(DWORD) - cbAlignment);

    *pClsid = *(CLSID*)pbObjectInfo;
    pbObjectInfo += sizeof(CLSID);

    // Get scope
    *pcsScope = *(CompScope*)pbObjectInfo;
    pbObjectInfo += sizeof(CompScope);

    // Get model
    *pcmModel = *(CompModel*)pbObjectInfo;
    pbObjectInfo += sizeof(CompModel);

    *ppszObjectName = (LPSTR)brName.m_pb;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetHTMLBlock
    Returns i-th HTML block

    Parameters:
        UINT   i             block number
        LPSTR* pszHTML       [out] html text
        ULONG* pcbHTML       [out] html text length
        ULONG* pcbSrcOffs    [out] offset in the source file
        LPSTR* pszSrcIncFile [out] include source file name

    Returns:
        Nothing
    Side effects:
        None
*/
HRESULT
CTemplate::GetHTMLBlock
(
UINT i,
LPSTR* pszHTML,
ULONG* pcbHTML,
ULONG* pcbSrcOffs,
LPSTR* pszSrcIncFile
)
    {
    Assert(i < Count(tcompHTMLBlock));

    // this was added due to user attempt to access the method with an invalid array offset
    //
    if ( i >= Count(tcompHTMLBlock) )
        return E_FAIL;

    // get address of the block start in template memory
    BYTE *pbBlock = GetAddress(tcompHTMLBlock, (USHORT)i);
    Assert(pbBlock);

    // retrieve the byte range of the html code
    CByteRange brHTML;
    ByteRangeFromPb(pbBlock, brHTML);
    *pszHTML = (LPSTR)brHTML.m_pb;
    *pcbHTML = brHTML.m_cb;

    // advance to the source offset
    pbBlock += sizeof(ULONG);   // skip prefix
    pbBlock += brHTML.m_cb+1;   // skip html bytes (incl. '\0')

    // Add byte aligment which is done in ByteAlignOffset()
    if ((reinterpret_cast<ULONG_PTR>(pbBlock)) & 3)
        pbBlock = reinterpret_cast<BYTE *>((reinterpret_cast<ULONG_PTR>(pbBlock) + 4) & ~3);

    *pcbSrcOffs = *((ULONG*)pbBlock);

    // advance to the source name length
    pbBlock += sizeof(ULONG);   // skip source offset prefix
    ULONG cbSrcIncFile = *((ULONG *)pbBlock); // inc file name length
    pbBlock += sizeof(ULONG);   // skip inc file name length
    *pszSrcIncFile = (cbSrcIncFile > 0) ? (LPSTR)pbBlock : NULL;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetScriptSourceInfo
    Returns line number and source file name a given target line in a given script engine.

    Returns
        line number and source file name (as out-parameters)
    Side effects:
        None
*/
void
CTemplate::GetScriptSourceInfo
(
UINT    idEngine,           // script engine id
int     iTargetLine,        // target line number
LPTSTR* pszPathInfo,        // ptr to source file virtual path      (out-parameter)
LPTSTR* pszPathTranslated,  // ptr to source file real path         (out-parameter)
ULONG*  piSourceLine,       // ptr to source line number            (out-parameter)
ULONG*  pichSourceLine,     // ptr to source file offset            (out-parameter)
BOOLB*  pfGuessedLine       // ptr to flag: did we guess the source line?
)
    {
    // Initialize some out parameters
    if (pszPathInfo)
        *pszPathInfo = _T("?"); // In case we don't ever find the path

    if (pszPathTranslated)
        *pszPathTranslated = _T("?"); // In case we don't ever find the path

    if (piSourceLine)
        *piSourceLine = 0;

    if (pichSourceLine)
        *pichSourceLine = 0;

    if (pfGuessedLine)
        *pfGuessedLine = FALSE;

    if (iTargetLine <=0)
        {
        return;
        }

    // CHANGE: The rgSourceInfo array is now ZERO based.  Decrement target line
    //           to convert.
    --iTargetLine;

    // CONSIDER: Make these assertions?
    if(!m_rgrgSourceInfos)
        return;
    if(idEngine > (m_cScriptEngines - 1))   // bug 375: check vs. array bound
        return;
    if(size_t(iTargetLine) >= m_rgrgSourceInfos[idEngine].length()) // bug 375: check vs. array bound
        return;

    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // bug 379: move backwards through target lines, starting with the caller's, until we find one whose
    // fIsHTML flag is false.  this handles the case where vbs flags a manufactured line as in error;
    // we assume the actual error occurred at the most recent authored line
    while (iTargetLine >= 0 && (*prgSourceInfos)[iTargetLine].m_fIsHTML)
        {
        --iTargetLine;
        if (pfGuessedLine)
            *pfGuessedLine = TRUE;
        }


    if (iTargetLine >= 0)
        {
        if (pszPathInfo && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathInfo = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathInfo;

        if (pszPathTranslated && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathTranslated = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathTranslated;

        if (piSourceLine)
            *piSourceLine = (*prgSourceInfos)[iTargetLine].m_idLine;

        if (pichSourceLine)
            *pichSourceLine = (*prgSourceInfos)[iTargetLine].m_cchSourceOffset;
        }
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    Get the character offset of a line of source
    (Debugger API Extended to specify a filemap)
*/
HRESULT
CTemplate::GetPositionOfLine
(
CFileMap *pFilemap,
ULONG cLineNumber,
ULONG *pcCharacterPosition
)
    {
    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    ++cLineNumber;                  // Convert zero-based line # to one-based

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_idLine <= cLineNumber &&
                (pSourceInfoLE == NULL || pSourceInfo->m_idLine > pSourceInfoLE->m_idLine))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all line numbers to offsets, unless they passed a bogus line
    // (in which case we still find an offset)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }
    *pcCharacterPosition = pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

		DBGPRINTF((
				DBG_CONTEXT,
				"Source Line %d corresponds to source offset %d (Text: \"%S\")\n",
				cLineNumber - 1, pSourceInfoLE->m_cchSourceOffset,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    Get the line # & offset in line of an arbitrary character offset in source
    (Debugger API Extended to specify a filemap)
*/
HRESULT CTemplate::GetLineOfPosition
(
CFileMap *pFilemap,
ULONG cCharacterPosition,
ULONG *pcLineNumber,
ULONG *pcCharacterOffsetInLine
)
    {
    // FAIL if source offset totally off-base
    if (cCharacterPosition >= pFilemap->m_cChars)
        return E_FAIL;

    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_cchSourceOffset <= cCharacterPosition &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all offsets to line numbers, unless they passed a bogus offset
    // (in which case we still find a line #, but may go out of range for the offset in line.
    //  That case is handled later)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }

    *pcLineNumber = pSourceInfoLE->m_idLine - 1;    // Convert to zero-based line #
    *pcCharacterOffsetInLine = cCharacterPosition - pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

        DBGPRINTF((
                                DBG_CONTEXT,
                                "Source offset %d corresponds to source line %d (Text: \"%S\")\n",
                                pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
                                wszSourceText
                                ));
                }

		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d corresponds to source line %d (Text: \"%S\")\n",
				pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetSourceOffset
    Convert a character offset relative to the target script to the appropriate
    offset in the source.

    NOTE:   offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

            Also, because of these translations, we return the length of the segment
            calculated during compilation, and throw away the length the scripting
            engine sent to us.
*/
void
CTemplate::GetSourceOffset
(
ULONG idEngine,
ULONG cchTargetOffset,
TCHAR **pszSourceFile,
ULONG *pcchSourceOffset,
ULONG *pcchSourceText
)
    {
    Assert (idEngine < m_cScriptEngines);
    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // Find the closest offset in the source
    // This is the largest target offset N, such that N <= cchTargetOffset
    CSourceInfo *pSourceInfo;
    GetBracketingPair(
            cchTargetOffset,                                    // value to search for
            prgSourceInfos->begin(), prgSourceInfos->end(),     // array to search
            CTargetOffsetOrder(),                               // ordering predicate
            &pSourceInfo, static_cast<CSourceInfo **>(NULL)     // return values
            );

    // Since the first offset is zero, which is less than all other conceivable offsets,
    // the offset must have been found or else there is a bug.
    Assert (pSourceInfo != NULL);
    Assert (cchTargetOffset >= pSourceInfo->m_cchTargetOffset);
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
						cchTargetOffset, idEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Target offset %d (Text: \"%S\") corresponds to source offset %d (Text: \"%S\")  (Length is %d)\n",
				cchTargetOffset, wszTargetText,
				pSourceInfo->m_cchSourceOffset, wszSourceText,
				pSourceInfo->m_cchSourceText
				));
		}
#endif
    *pszSourceFile = pSourceInfo->m_pfilemap->m_szPathTranslated;
    *pcchSourceOffset = pSourceInfo->m_cchSourceOffset;
    *pcchSourceText = pSourceInfo->m_cchSourceText;
    }

/*  ============================================================================
    CTemplate::GetTargetOffset
    Convert a character offset relative to the source script to the appropriate
    offset in the target.

    Returns:
        TRUE  - source offset corresponds to script
        FALSE - source offset corresponds to HTML

    NOTES:
        1.  This function is very slow. consider caching the value of this function
            (The CTemplateDocumentContext class does this.)

        2.  This function returns the source offset in the master include file -
            if the target offset corresponds to an offset in a header file, then
            the offset to the #include line in the source is returned.

        3.  offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because the debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

    CONSIDER:
        Figure out a better way to do this
*/
BOOL CTemplate::GetTargetOffset
(
TCHAR *szSourceFile,
ULONG cchSourceOffset,
/* [out] */ ULONG *pidEngine,
/* [out] */ ULONG *pcchTargetOffset
)
    {
    // NOTE:
    //    The table is not binary-searchable because of two factors:
    //       1. Include files will start a new line ordering
    //       2. For engine 0, tagged scripts will be re-arranged in
    //          the target code to reside after all primary script in
    //          engine 0.
    //
    // Algorithm:
    //
    //   Find the largest source offset N across all engines, such that
    //   N <= cchSourceOffset and the offset corresponds to an offset
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    unsigned idEngineLE = 0;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (_tcscmp(pSourceInfo->m_pfilemap->m_szPathTranslated, szSourceFile) == 0 &&
                pSourceInfo->m_cchSourceOffset <= cchSourceOffset &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                idEngineLE = idEngine;
                }
            }
        }

    // There won't be a valid offset in the case where there is no
    // code corresponding to the first line in the file (this only
    // occurs when the first line is whitespace, because there is no
    // corresponding "Response.WriteBlock" call there)
    //
    // In that case, return FALSE, which will cause the caller to fail
    //
    if (pSourceInfoLE == NULL)
        {
        *pidEngine = 0;
        *pcchTargetOffset = 0;
        return FALSE;
        }

    *pidEngine = idEngineLE;
    *pcchTargetOffset = pSourceInfoLE->m_cchTargetOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						cchSourceOffset, pSourceInfoLE->m_pfilemap,
						*pcchTargetOffset, *pidEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d (Text: \"%S\") corresponds to target offset %d (Text: \"%S\")\n",
				cchSourceOffset, wszSourceText,
				*pcchTargetOffset, wszTargetText
				));
		}
#endif
    return !pSourceInfoLE->m_fIsHTML;
    }

/*  ============================================================================
    CTemplate::GetActiveScript
    Return a cached script from the template - only used in debug mode
*/
CActiveScriptEngine *CTemplate::GetActiveScript(ULONG idEngine)
    {
    if (m_rgpDebugScripts == NULL)
        return NULL;

    else
        {
        Assert (idEngine < m_cScriptEngines);
        CActiveScriptEngine *pEng = m_rgpDebugScripts[idEngine];
        if (pEng)
            pEng->AddRef();

        return pEng;
        }
    }

/*  ============================================================================
    CTemplate::AddScript
    add an active script to the template object
*/
HRESULT CTemplate::AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine)
    {
    if (m_rgpDebugScripts == NULL)
        {
        if (
            (m_rgpDebugScripts = new CActiveScriptEngine *[m_cScriptEngines])
            == NULL
           )
            {
            return E_OUTOFMEMORY;
            }

        memset(m_rgpDebugScripts, 0, m_cScriptEngines * sizeof(CActiveScriptEngine *));
        }

    Assert (idEngine < m_cScriptEngines);
    CActiveScriptEngine **ppScriptElem = &m_rgpDebugScripts[idEngine];

    if (*ppScriptElem != NULL)
        (*ppScriptElem)->Release();

    *ppScriptElem = pScriptEngine;
    pScriptEngine->AddRef();

    // Initialize the script engine now (is currently uninitialized)
    // so that the debugger user can set breakpoints.
    IActiveScript *pActiveScript = pScriptEngine->GetActiveScript();
    HRESULT  hr;

    TRY
        hr = pActiveScript->SetScriptSite(static_cast<IActiveScriptSite *>(pScriptEngine));
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptSite()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        {
        *ppScriptElem = NULL;
        return E_FAIL;
        }

    TRY
        hr = pActiveScript->SetScriptState(SCRIPTSTATE_INITIALIZED);
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptState()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::AppendMapFile
    Appends a filemap to the workstore and memory-maps its file

    Returns:
        Nothing
    Side effects:
        Allocates memory; throws exception on error
*/
void
CTemplate::AppendMapFile
(
LPCTSTR     szFileSpec,         // file spec for this file
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
BOOLB       fVirtual,           // is file spec virtual or relative?
CHitObj*    pHitObj,            // ptr to template's hit object
BOOLB       fGlobalAsa          // is this file the global.asa file?
)
    {
    // alloc or realloc as needed
    if(m_cFilemaps++ == 0)
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallMalloc(sizeof(CFileMap*));
    else
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpFilemaps, m_cFilemaps * sizeof(CFileMap*));

    if(NULL == m_rgpFilemaps)
        THROW(E_OUTOFMEMORY);

    if(NULL == (m_rgpFilemaps[m_cFilemaps - 1] = new CFileMap))
        THROW(E_OUTOFMEMORY);

    // map the file
    m_rgpFilemaps[m_cFilemaps - 1]->MapFile(
                                            szFileSpec,
                                            m_szApplnVirtPath,
                                            pfilemapCurrent,
                                            fVirtual,
                                            pHitObj,
                                            fGlobalAsa
                                            );
    }

/*  ============================================================================
    CTemplate::GetSegmentsFromFile
    Gets source segments from a source file by calling ExtractAndProcessSegment
    until there are no more segments; populates WorkStore with info on source segments.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::GetSegmentsFromFile
(
CFileMap&   filemap,        // this file's file map
CWorkStore& WorkStore,      // working storage for source segments
CHitObj*    pHitObj,        // Browser request object
BOOL        fIsHTML
)
    {
    CByteRange  brSearch;       // byte range to search for source segments
    _TOKEN      rgtknOpeners[TOKEN_OPENERS_MAX]; // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens
    SOURCE_SEGMENT ssegThisFile = ssegHTML; // Either HTML or <SCRIPT> segment
    BOOL        fPrevCodePageSet = FALSE;
    UINT        wPrevCodePage;

    // init search range to all of file - NOTE we ignore high dword of file size
    brSearch.m_pb = filemap.m_pbStartOfFile;
    brSearch.m_cb = filemap.GetSize();

    if (fIsHTML)
        {
                // populate array of permitted open tokens
                ctknOpeners = 4;
                rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;
                rgtknOpeners[1] = CTokenList::tknOpenTaggedScript;
                rgtknOpeners[2] = CTokenList::tknOpenObject;
                rgtknOpeners[3] = CTokenList::tknOpenHTMLComment;
                }
        else
                {
                ctknOpeners = 1;
                rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;
        ssegThisFile = ssegTaggedScript;
                }

    TRY

        if ((brSearch.m_cb >= 2)
            && (((brSearch.m_pb[0] == 0xff) && (brSearch.m_pb[1] == 0xfe))
                || ((brSearch.m_pb[0] == 0xfe) && (brSearch.m_pb[1] == 0xff)))) {
            ThrowError(brSearch.m_pb,IDE_TEMPLATE_UNICODE_NOTSUP);
            return;
        }

        // check for the UTF-8 BOM mark.  If present, then treat this similar to
        // seeing @CODEPAGE=65001.  Note that previous values are retained in the
        // event that there are differing @CODEPAGE settings.  This probably should
        // be an error in itself, but I can imagine that this might break a lot of
        // apps as more and more UTF8 files are put into use.

        if ((brSearch.m_cb >= 3)
            && (brSearch.m_pb[0] == 0xEF)
            && (brSearch.m_pb[1] == 0xBB)
            && (brSearch.m_pb[2] == 0xBF)) {

            pHitObj->SetCodePage(65001);

            fPrevCodePageSet = m_fCodePageSet;
            wPrevCodePage = m_wCodePage;

            m_fCodePageSet = TRUE;
            m_wCodePage = 65001;
            brSearch.Advance(3);
        }


        // Process source segments until we run out of them, i.e. until search segment is empty
        // NOTE we pass current filemap as 'parent file' to ExtractAndProcessSegment
        // NOTE ExtractAndProcessSegment appends source segments to WorkStore, advancing brSearch as it goes
        while(!brSearch.IsNull())
            ExtractAndProcessSegment(
                                        brSearch,
                                        ssegThisFile,
                                        rgtknOpeners,
                                        ctknOpeners,
                                        &filemap,
                                        WorkStore,
                                        pHitObj,
                                        ssegThisFile == ssegTaggedScript,
                                        fIsHTML
                                    );

    CATCH(hrException)
        /*
            NOTE we indicate 'generic error' by m_idErrMsg == 0; this happens as we move
            up the 'include file stack' after processing a specific error (m_idErrMsg != 0).
            Only the specific error is processed; generic error, we simply re-throw exception.
        */
        if(m_idErrMsg != 0)
            {
            // process specific error
            ProcessSpecificError(filemap, pHitObj);

            // reset err message so next msg will be generic as we move up the stack
            m_idErrMsg = 0;
            }

        THROW(hrException);

    END_TRY

    if (fPrevCodePageSet){
        m_wCodePage = wPrevCodePage;
        pHitObj->SetCodePage(wPrevCodePage);
    }
    }


#define SZ_REG_LANGUAGE_ENGINES "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASP\\LanguageEngines\\"
/*  ============================================================================
    CTemplate::GetLanguageEquivalents
    Gets the "Write", "WriteBlock", etc. equivalents from registry for primary scripting language

    Returns
        Nothing
    Side effects
        Throws on error
*/
void
CTemplate::GetLanguageEquivalents
(
)
    {
    CByteRange  brPrimaryEngine;
    m_pWorkStore->m_ScriptStore.m_bufEngineNames.GetItem(0, brPrimaryEngine);   // 0-th engine is primary

    //  if the primary language is one of the big two, return; we don't need to look up equivalents
    if(brPrimaryEngine.FMatchesSz("VBScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JavaScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("LiveScript"))
        return;

    /*  query the registry; language equivalents are stored in:
        HKEY_LOCAL_MACHINE
            key: SYSTEM
                key: CurrentControlSet
                    key: Services
                        key: W3SVC
                            key: ASP
                                key: LanguageEngines
                                    key: <LanguageName>
                                        value: Write        data: <replacement syntax for Response.Write(|)>
                                        value: WriteBlock   data: <replacement syntax for Response.WriteBlock(|)>
    */
    STACK_BUFFER( tempRegKeyPath, 512 );

    UINT    cchRegKeyPath = strlen(SZ_REG_LANGUAGE_ENGINES);

    if (!tempRegKeyPath.Resize(cchRegKeyPath + brPrimaryEngine.m_cb + 1)) {
        SetLastError(E_OUTOFMEMORY);
        return;
    }

    LPSTR   szRegKeyPath = static_cast<LPSTR> (tempRegKeyPath.QueryPtr());

    LPSTR   pch = szRegKeyPath;

    strcpy(pch, SZ_REG_LANGUAGE_ENGINES);
    pch += cchRegKeyPath;
    strncpy(pch, (const char *) brPrimaryEngine.m_pb, brPrimaryEngine.m_cb);
    pch += brPrimaryEngine.m_cb;
    *pch = '\0';

    HANDLE      hKeyScriptLanguage; // handle of script language reg key

    if(ERROR_SUCCESS == RegOpenKeyExA(
                                        HKEY_LOCAL_MACHINE, // handle constant
                          (const char*) szRegKeyPath,       // LPCSTR lpSubKey     subkey to open
                                        0,                  // DWORD ulOptions      reserved; must be zero
                                        KEY_QUERY_VALUE,    // REGSAM samDesired    security access mask
                                        (PHKEY) &hKeyScriptLanguage // PHKEY phkResult      address of handle of open key
                                    ))
        {
        SetLanguageEquivalent(hKeyScriptLanguage, "Write",      &(m_pWorkStore->m_szWriteOpen), &m_pWorkStore->m_cchWriteOpen, &(m_pWorkStore->m_szWriteClose), &m_pWorkStore->m_cchWriteClose);
        SetLanguageEquivalent(hKeyScriptLanguage, "WriteBlock", &(m_pWorkStore->m_szWriteBlockOpen), &m_pWorkStore->m_cchWriteBlockOpen, &(m_pWorkStore->m_szWriteBlockClose), &m_pWorkStore->m_cchWriteBlockClose);

        RegCloseKey((HKEY) hKeyScriptLanguage);
        }

    }

/*  ============================================================================
    CTemplate::SetLanguageEquivalent
    Sets a "language equivalent" from the registry.

    Returns:
        language item opener and closer as out-parameters
        Ex: "Response.Write(" and ")"
    Side effects:
        Throws on error
*/
void
CTemplate::SetLanguageEquivalent
(
HANDLE  hKeyScriptLanguage, // reg key
LPSTR   szLanguageItem,     // reg value name - "Write", "WriteBlock", etc.
LPSTR*  pszOpen,            // ptr to language item opener, e.g. "Response.Write("  (out-parameter)
UINT*   pcchOpen,           // Length for the Open Token
LPSTR*  pszClose,            // ptr to language item closer, e.g. ")"                (out-parameter)
UINT*   pcchClose           // Length for the Close Token
)
    {
    LONG    lError;
    DWORD   cbSyntax;
    LPSTR   szSyntax;
    char*   pchInsert;
    UINT    cchOpen;
    UINT    cchClose;

    // query registry to get buffer size
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                                NULL,               // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    if(ERROR_FILE_NOT_FOUND == lError)
        // if we don't find szLanguageItem in registry, return silently, leaving *pszOpen and *pszClose unchanged
        return;
    else if((ERROR_MORE_DATA != lError) && (ERROR_SUCCESS != lError))
        THROW(lError);

    Assert(cbSyntax > 0);

    // allocate buffer and re-query registry to get syntax string
    // NOTE RegQueryValueEx returns cbSyntax that includes room for '\0' terminator

    STACK_BUFFER(tempSyntax, 64);

    if (!tempSyntax.Resize(cbSyntax)) {
        THROW(E_OUTOFMEMORY);
    }
    szSyntax = static_cast<LPSTR> (tempSyntax.QueryPtr());
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                       (LPBYTE) szSyntax,           // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    /*  NOTE there is the slight possibility of ERROR_FILE_NOT_FOUND or ERROR_MORE_DATA
        if the registry value was deleted or changed between the first and second calls to RegQueryValueEx.
        Since this occurs with vanishingly small probability, we throw (instead of coding the re-try logic).
    */
    if(ERROR_SUCCESS != lError)
        THROW(lError);

    pchInsert = szSyntax;

    while(*pchInsert != '|' && *pchInsert != '\0')
        pchInsert++;

    cchOpen = DIFF(pchInsert - szSyntax);

    cchClose =  *pchInsert == '|'
                ? cbSyntax - cchOpen - 2    // found insert symbol: deduct 2 chars, 1 for insert symbol, 1 for '\0'
                : cbSyntax - cchOpen - 1;   // didn't find insert symbol: deduct 1 char for '\0'

    Assert(FImplies(cchOpen == 0, *szSyntax == '|'));
    Assert(FImplies(*pchInsert == '\0', cchClose == 0));

    if(cchOpen == 0)
        // opener is empty - set caller's opener ptr null
        *pszOpen = NULL;
    else if(cchOpen > 0)
        {
        // opener is non-empty - set caller's opener to opener in registry
        if(NULL == (*pszOpen = (LPSTR) CTemplate::SmallMalloc(cchOpen + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszOpen, szSyntax, cchOpen);
        (*pszOpen)[cchOpen] = '\0';
        }

    if(cchClose == 0)
        // closer is empty - set caller's closer ptr null
        *pszClose = NULL;
    else if(cchClose > 0)
        {
        // closer is non-empty - set caller's closer to closer in registry
        if(NULL == (*pszClose = (LPSTR) CTemplate::SmallMalloc(cchClose + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszClose, (pchInsert + 1), cchClose);
        (*pszClose)[cchClose] = '\0';
        }

    *pcchOpen = cchOpen;
    *pcchClose = cchClose;
    }

/*  ============================================================================
    CTemplate::ThrowError
    Sets up for processing a compile failure.

    Returns:
        Nothing
    Side effects:
        Throws error
*/
void
CTemplate::ThrowError
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg            // error id
)
    {
    m_pbErrorLocation = pbErrorLocation;
    m_idErrMsg = idErrMsg;

    // bug 80745: always throw compile-failed-don't-cache
    THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
    }

/*  ============================================================================
    CTemplate::AppendErrorMessageInsert
    Appends an error message insert to member array.

    Returns:
        Nothing
    Side effects:
        Appends to inserts array
*/
void
CTemplate::AppendErrorMessageInsert
(
BYTE*   pbInsert,   // ptr to insert
UINT    cbInsert    // length of insert
)
    {
    if (m_ppszMsgInserts == NULL)
        {
        m_ppszMsgInserts = new char*;
        m_cMsgInserts = 0;

        if (m_ppszMsgInserts == NULL)
            return;
        }

    m_ppszMsgInserts[m_cMsgInserts] = new char[cbInsert + 1];
    if (m_ppszMsgInserts[m_cMsgInserts] == NULL)
        return;

    strncpy(m_ppszMsgInserts[m_cMsgInserts], (const char*)pbInsert, cbInsert);
    m_ppszMsgInserts[m_cMsgInserts++][cbInsert] = NULL;
    }

/*  ============================================================================
    CTemplate::ThrowErrorSingleInsert
    Appends a single message insert to member array and throws a compile error.

    Returns:
        Nothing
    Side effects:
        Throws error indirectly
*/
void
CTemplate::ThrowErrorSingleInsert
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg,           // error id
BYTE*   pbInsert,           // ptr to insert
UINT    cbInsert            // length of insert
)
    {
    AppendErrorMessageInsert(pbInsert, cbInsert);
    ThrowError(pbErrorLocation, idErrMsg);
    }

/*  ============================================================================
    CTemplate::ProcessSpecificError
    Processes a specific compile failure.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::ProcessSpecificError
(
CFileMap&   filemap,        // source file map
CHitObj*    pHitObj         // Browser request object
)
    {
    // no error msg for generic failures
    if(m_idErrMsg == E_FAIL || m_idErrMsg == E_OUTOFMEMORY)
        return;

    HandleCTemplateError(
                            &filemap,
                            m_pbErrorLocation,
                            m_idErrMsg,
                            m_cMsgInserts,
                            m_ppszMsgInserts,
                            pHitObj
                        );
    }


/*  ============================================================================
    CTemplate::ShowErrorInDebugger
    Display a runtime error by invoking the JIT debugger

    Returns:
        failure if debugger won't start

    Side effects:
        None.
*/
HRESULT
CTemplate::ShowErrorInDebugger
(
CFileMap* pfilemap,
UINT cchErrorLocation,
char* szDescription,
CHitObj *pHitObj,
BOOL fAttachDocument
)
    {
    HRESULT hr = S_OK;
    char szDebugTitle[64];

    if (pfilemap == NULL || szDescription == NULL || pHitObj == NULL)
        return E_POINTER;

    // Create a new document context for this statement
    // CONSIDER: character count that we return is bogus - however our debugging
    //           client (Caesar's) does not use this information anyway.
    //
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, cchErrorLocation, 1);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    // Make sure debug document is attached to debugger
    if (fAttachDocument)
                AttachTo(pHitObj->PAppln());

    // Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP, pDebugContext);
    if (FAILED(hr))
        goto LExit;

    // Load the compiler message string
    CchLoadStringOfId(IDE_TEMPLATE_ERRMSG_TITLE, szDebugTitle, sizeof szDebugTitle);

    // pop up a message box with the error description
    MessageBoxA(NULL, szDescription, szDebugTitle, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
    if (pDebugContext)
        pDebugContext->Release();

    return hr;
    }

/*  ============================================================================
    CTemplate::HandleCTemplateError
    Handles template compilation errors

    Returns:
        Nothing

    Side effects:
        None.
*/
void
CTemplate::HandleCTemplateError
(
CFileMap*   pfilemap,           // ptr to source file map
BYTE*       pbErrorLocation,    // ptr to source location where error occurred
UINT        idErrMsg,           // error message id
UINT        cMsgInserts,        // count of insert strings for error msg
char**      ppszMsgInserts,     // array of ptrs to error msg insert strings
CHitObj*    pHitObj             // Browser Request
)
    {
    char    szErrMsgPattern[MAX_RESSTRINGSIZE]; // error message pattern
    CHAR    szLineNum[12];
    TCHAR   szFileName[512];
    CHAR    szShortDes[256];
    CHAR    szEngine[256];
    CHAR    szErrCode[20];
    CHAR    szLongDes[MAX_RESSTRINGSIZE];
    CHAR    szCombinedDes[sizeof szShortDes + sizeof szLongDes];    // long & short desc
    DWORD   dwMask;
    UINT    cch;


    // if request ptr or ecb ptr is null, bail; we won't be able to write error msg anyway
    if(pHitObj == NULL)
        return;

    /*  if this was a security error, process it specially and bail
        NOTE security error causes exception, rather than true error id
        NOTE template will be destroyed anyway in this case, so no need to maintain m_pszLastErrorMessage
    */
    if(idErrMsg == E_USER_LACKS_PERMISSIONS)
        {
        Assert(cMsgInserts == 1);
        HandleAccessFailure(pHitObj,
                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

        return;
        }

    // get error resource message
    LoadErrResString(idErrMsg, &dwMask, szErrCode, szShortDes, szLongDes);

    // if we have a specific error location, construct msg prefix
    if(pbErrorLocation != NULL) {
        Assert(pfilemap != NULL);
        // get line number of error location as string
        _itoa(SourceLineNumberFromPb(pfilemap, pbErrorLocation), szLineNum, 10);
    }
    else {
        szLineNum[0] = NULL;
    }

    if(pfilemap != NULL) {
        cch = _tcslen(pfilemap->m_szPathInfo);
        _tcsncpy(szFileName, pfilemap->m_szPathInfo, cch);
    }
    else {
        cch = 0;
    }

    szFileName[cch] = '\0';

    //Load Default Engine from resource
    cch = CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);
    szEngine[cch] = '\0';

    // resolve error msg pattern and inserts into actual error msg
    cch = strlen(szLongDes);
    memcpy(szErrMsgPattern, szLongDes, cch);
    szErrMsgPattern[cch] = '\0';

    // get an idea of the possibility of a buffer overrunn
    UINT dwTotalLen=0;
        BOOL fTooBig = FALSE;

    if (cMsgInserts) {
        // allow 32 characters for space, etc.
        dwTotalLen = 32 + strlen(szErrMsgPattern);
		for (UINT i = 0; i < cMsgInserts; i++)
			dwTotalLen += strlen(ppszMsgInserts[i]);

		if (dwTotalLen > sizeof szLongDes) {
			cch = CchLoadStringOfId(IDE_TOOBIG, szLongDes, sizeof szLongDes);
			szLongDes[cch] = '\0';
			fTooBig = TRUE;
        }
    }

    if (!fTooBig)
        GetSzFromPatternInserts(szErrMsgPattern, cMsgInserts, ppszMsgInserts, szLongDes);

    // attempt to bring up debugger to display the error - if we cannot then log the error

    /* Find the character offset closest to cbErrorLocation.  This will be
     * the place where we start looping with CharNext() to get the full
     * character offset.
     *
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     *    Therefore, we don't have the benefit of the rgByte2DBCS table
     *    because it doesn't exist yet.  Therefore we are left with a SLOW
     *    loop starting at BOF.  To make things not so abysmal, we don't
     *    do the loop on SBCS charsets.  We also don't do this conversion
     *    unless debugging is enabled.
     */

    if (FCaesars() && pHitObj->PAppln()->FDebuggable()) {
        unsigned cchErrorLocation = CharAdvDBCS(
                                        (WORD)m_wCodePage,
                                        reinterpret_cast<char *>(pfilemap->m_pbStartOfFile),
                                        reinterpret_cast<char *>(pbErrorLocation),
                                        INFINITE,
                                        NULL);

        // Create the description string
        char *szEnd = strcpyExA(szCombinedDes, szShortDes);
        *szEnd++ = '\n';
        *szEnd++ = '\n';
        strcpy(szEnd, szLongDes);

        ShowErrorInDebugger(pfilemap, cchErrorLocation, szCombinedDes, pHitObj, idErrMsg != IDE_TEMPLATE_CYCLIC_INCLUDE);
    }

    //cache the info in case we need to use later.
    m_dwLastErrorMask = dwMask;
    //delay NULL check to caller who use this info.
#if UNICODE
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupUTF8(szFileName);
#else
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupA(szFileName);
#endif
    m_pszLastErrorInfo[ILE_szLineNum]   = StringDupA(szLineNum);
    m_pszLastErrorInfo[ILE_szEngine]    = StringDupA(szEngine);
    m_pszLastErrorInfo[ILE_szErrorCode] = StringDupA(szErrCode);
    m_pszLastErrorInfo[ILE_szShortDes]  = StringDupA(szShortDes);
    m_pszLastErrorInfo[ILE_szLongDes]   = StringDupA(szLongDes);

    SendToLog(  m_dwLastErrorMask,
                m_pszLastErrorInfo[ILE_szFileName],
                m_pszLastErrorInfo[ILE_szLineNum],
                m_pszLastErrorInfo[ILE_szEngine],
                m_pszLastErrorInfo[ILE_szErrorCode],
                m_pszLastErrorInfo[ILE_szShortDes],
                m_pszLastErrorInfo[ILE_szLongDes],
                pHitObj);
    }

/*  ============================================================================
    CTemplate::FreeGoodTemplateMemory
    Frees memory allocated for a 'good' (successfully compiled) template.
    This includes the template itself, memory to support compile-time errors
    (since the entire concatenated compile-time error message is cached in
    last-err-msg member), and memory to support run-time errors (since if the
    template didn't compile, it can't run).

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::FreeGoodTemplateMemory
(
)
    {
    UINT    i;

        LargeTemplateFreeNullify((void**) &m_pbStart);
    SmallTemplateFreeNullify((void**) &m_rgpSegmentFilemaps);

    delete[] m_rgrgSourceInfos;
    m_rgrgSourceInfos = NULL;

    if(m_ppszMsgInserts)
        {
        for(i = 0; i < m_cMsgInserts; i++)
            delete m_ppszMsgInserts[i];
        delete m_ppszMsgInserts;
        m_ppszMsgInserts = NULL;
        }

    // release the collected type libs
    ReleaseTypeLibs();

    // release any 449-echo-cookie objects
    Release449();
    }

/*  ============================================================================
    CTemplate::UnmapFiles
    Unmaps the template's filemaps.
    NOTE: we keep filemap objects around so that filenames will be available for runtime errors

    Returns
        Nothing
    Side effects
        Unmaps template's filemaps
*/
void
CTemplate::UnmapFiles
(
)
    {
    UINT    i;
    for(i = 0; i < m_cFilemaps; i++)
        m_rgpFilemaps[i]->UnmapFile();
    }

/*===================================================================
    CTemplate::ExtractAndProcessSegment
    Extracts and processes leading source segment and first contained
    source segment from search range.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ExtractAndProcessSegment
(
CByteRange&             brSearch,           // byte range to search for next segment-opening token
const SOURCE_SEGMENT&   ssegLeading,        // type of 'leading', i.e. pre-token, source segment
_TOKEN*                 rgtknOpeners,       // array of permitted open tokens
UINT                    ctknOpeners,        // count of permitted open tokens
CFileMap*               pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&             WorkStore,          // working storage for source segments
CHitObj*                pHitObj,            // Browser request object
BOOL                    fScriptTagProcessed,// has script tag been processed?
BOOL                    fIsHTML             // are we in HTML segment?
)
    {
    CByteRange      brLeadSegment;      // byte range of leading source segment
    SOURCE_SEGMENT  ssegContained;      // type of 'contained', i.e. post-token, source segment
    CByteRange      brContainedSegment; // byte range of contained source segment
    _TOKEN          tknOpen;            // opening token
    BYTE*           pbTokenOpen;        // ptr to opening token
    _TOKEN          tknClose;           // closing token
    BYTE*           pbTokenClose;       // ptr to closing token

    // NOTE: If "fScriptTagProcessed" is TRUE, then "fIsHTML" must be FALSE.  The reason for
    // both flags is that if "fScriptTagProcessed" is FALSE, then "fIsHTML" may be either TRUE
    // or FALSE (indeterminate)
    //
    Assert (FImplies(fScriptTagProcessed, !fIsHTML));

    // If search range is empty, return
    if(brSearch.IsNull())
        return;

    // Set ptr of leading segment to start of search segment
    brLeadSegment.m_pb = brSearch.m_pb;

    // get open token for contained segment
    pbTokenOpen = GetOpenToken(
                                brSearch,
                                ssegLeading,
                                rgtknOpeners,
                                ctknOpeners,
                                &tknOpen
                            );

    // Set count of leading segment to distance between start of search range and token
    brLeadSegment.m_cb = DIFF(pbTokenOpen - brSearch.m_pb);

    // Process leading segment
    ProcessSegment(ssegLeading, brLeadSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);

    // If open token was 'EOF', empty out search range and return
    if(tknOpen == CTokenList::tknEOF)
        {
        brSearch.Nullify();
        return;
        }

    // Set contained segment type and close token based upon the opener we found
    tknClose = GetComplementToken(tknOpen);
    ssegContained = GetSegmentOfOpenToken(tknOpen);

    if(ssegContained == ssegHTMLComment)
        // for html comment segments, advance search range to open token
        // NOTE keep html comment tags in segment because they must be sent to client
        brSearch.Advance(DIFF(pbTokenOpen - brSearch.m_pb));
    else
        // for all but html comment segments, advance search range to just past open token
        gm_pTokenList->MovePastToken(tknOpen, pbTokenOpen, brSearch);

    // Get closing token - if none, throw error
    if(NULL == (pbTokenClose = GetCloseToken(brSearch, tknClose)))
        {
        if(tknOpen == CTokenList::tknOpenPrimaryScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_PSCRIPT);
        else if(tknOpen == CTokenList::tknOpenTaggedScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
        else if(tknOpen == CTokenList::tknOpenObject)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
        else if(tknOpen == CTokenList::tknOpenHTMLComment)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT);
        }

    // calc contained segment
    brContainedSegment.m_pb = brSearch.m_pb;
    brContainedSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

    // advance search range to just past close token
    gm_pTokenList->MovePastToken(tknClose, pbTokenClose, brSearch);

    // if an html comment segment, get actual segment type (e.g. might be a server-side include command)
    // NOTE call may also change contained segment byte range
    if(ssegContained == ssegHTMLComment)
        ssegContained = SsegFromHTMLComment(brContainedSegment);

    // if an html comment segment, add its close tag to contained segment
    // NOTE we keep html comment tags as part of segment so we can process like any other html segment
    if(ssegContained == ssegHTMLComment)
        brContainedSegment.m_cb += CCH_TOKEN(tknClose);

    if(ssegContained == ssegMetadata)
        {
        // METADATA comments are used by DESIGN time controls and we don't send
        // them to the client.

        // We process metadata to get to the typelib info
        UINT idError = 0;
        HRESULT hr = ProcessMetadataSegment(brContainedSegment, &idError, pHitObj);

        if (FAILED(hr))
            ThrowError(brContainedSegment.m_pb, idError);
        }
    else if (ssegContained == ssegFPBot)
        {
        }
    else
        {
        // process contained segment
        ProcessSegment(ssegContained, brContainedSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);
        }
    }

/*  ============================================================================
    CTemplate::SsegFromHTMLComment
    Determines source segment type of HTML comment.

    Returns
        Source segment type
    Side effects
        May advance segment byte range
*/
CTemplate::SOURCE_SEGMENT
CTemplate::SsegFromHTMLComment
(
CByteRange& brSegment   // source segment
)
    {
    SOURCE_SEGMENT  ssegRet = ssegHTMLComment;  // return value
    BYTE*           pbToken;                    // ptr to token

    if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknCommandINCLUDE, pbToken, brSegment);
        ssegRet = ssegInclude;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagMETADATA, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagMETADATA, pbToken, brSegment);
        ssegRet = ssegMetadata;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagFPBot, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagFPBot, pbToken, brSegment);
        ssegRet = ssegFPBot;
        }

    return ssegRet;
    }

/*  ============================================================================
    CTemplate::ProcessSegment
    Processes a source segment based on its type.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessSegment
(
SOURCE_SEGMENT  sseg,                   // segment type
CByteRange&     brSegment,              // segment byte range
CFileMap*       pfilemapCurrent,        // ptr to filemap of parent file
CWorkStore&     WorkStore,              // working storage for source segments
BOOL            fScriptTagProcessed,    // has script tag been processed?
CHitObj*        pHitObj,                // Browser request object
BOOL            fIsHTML                 // Is segment in HTML block or script?
)
    {
    UINT        idSequence; // sequence id for this segment

    // if segment is entirely white space, silently return
    if(FByteRangeIsWhiteSpace(brSegment))
        return;

    // set local sequence id and increment member
    idSequence = WorkStore.m_idCurSequence++;

    // Process segment based on its type
    if(sseg == ssegHTML)
        ProcessHTMLSegment(brSegment, WorkStore.m_bufHTMLSegments, idSequence, pfilemapCurrent);
    else if(sseg == ssegHTMLComment)
        ProcessHTMLCommentSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
    else if(sseg == ssegPrimaryScript || sseg == ssegTaggedScript)
        ProcessScriptSegment(sseg, brSegment, pfilemapCurrent, WorkStore, idSequence, (BOOLB)!!fScriptTagProcessed, pHitObj);
    else if(sseg == ssegObject)
        ProcessObjectSegment(brSegment, pfilemapCurrent, WorkStore, idSequence);
    else if(sseg == ssegInclude)
        {
        if (! fIsHTML)
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SSI_COMMAND);

        ProcessIncludeFile(brSegment, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
        }

    // malloc/realloc array if needed
    if(m_cSegmentFilemapSlots == 0)
        {
        m_cSegmentFilemapSlots = C_SCRIPTSEGMENTSDEFAULT + C_HTMLSEGMENTSDEFAULT;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallMalloc(m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }
    else if(idSequence >= m_cSegmentFilemapSlots)
        {
        // grab twice what we had before
        m_cSegmentFilemapSlots *= 2;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpSegmentFilemaps,
                                                            m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }

    // set filemap ptr for this segment - NOTE 'parent' filemap is also current file map
    m_rgpSegmentFilemaps[idSequence] = pfilemapCurrent;
    }

/*  ========================================================
    CTemplate::ProcessHTMLSegment

    Processes an HTML segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLSegment
(
CByteRange& brHTML,         // html segment
CBuffer&    bufHTMLBlocks,  // working storage for html blocks
UINT        idSequence,     // segment sequence id
CFileMap*   pfilemapCurrent // current filemap
)
    {
    if(!(brHTML.IsNull()))
        // If byte range is non-empty, store it in html buffer (non-local)
        bufHTMLBlocks.Append(brHTML, FALSE, idSequence, pfilemapCurrent);
    }

/*  ========================================================
    CTemplate::ProcessHTMLCommentSegment
    Processes an HTML comment segment: within an HTML comment we
    honor plain text (passed through as HTML comment) and primary script.
    See bug 182 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLCommentSegment
(
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for source segments
CHitObj*        pHitObj             // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    _TOKEN  tknOpeners[1];
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;

    // Process source segments embedded within HTML comment segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,      // byte range to search for next segment-opening token
                                    ssegHTML,       // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,   // array of permitted open tokens
                                    ctknOpeners,    // count of permitted open tokens
                                    pfilemapCurrent,// ptr to filemap of parent file
                                    WorkStore,      // working storage for source segments
                                    pHitObj         // Browser request object
                                );
    }

/*  ============================================================================
    CTemplate::ProcessScriptSegment
    Processes a script segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessScriptSegment
(
SOURCE_SEGMENT  sseg,               // segment type
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for scripts
UINT            idSequence,         // segment sequence id
BOOLB           fScriptTagProcessed,// has script tag been processed?
CHitObj*        pHitObj             // Browser request object
)
    {
    CByteRange  brEngine;       // script engine name - NOTE constructed null

    if(m_fGlobalAsa)
        if(sseg == ssegPrimaryScript)
            // error out on primary script if we are processing global.asa
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT);

    if(sseg == ssegPrimaryScript)
        {
        CByteRange  brTemp = brSegment;

        LTrimWhiteSpace(brTemp);

        if(*brTemp.m_pb == '@') // CONSIDER: tknTagSetPriScriptLang
            {
            // impossible condition: page-level @ commands can't be allowed if they have already been executed
            Assert(!(WorkStore.m_fPageCommandsAllowed && WorkStore.m_fPageCommandsExecuted));

            if(!WorkStore.m_fPageCommandsAllowed)
                {
                if(WorkStore.m_fPageCommandsExecuted)
                    // error out if trying to re-execute page-level @ commands
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_REPEATED);
                else
                    // error out if trying to execute page-level @ commands when not allowed
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST);
                }

            // if we made it here, must be allowed to execute page-level @ commands AND they have not been executed
            Assert((WorkStore.m_fPageCommandsAllowed && !WorkStore.m_fPageCommandsExecuted));

            /*  set primary script language if required
                NOTE we call GetTagName to see if LANGUAGE tag occurs in tags segment; this is somewhat wasteful,
                since BrValueOfTag must simply call GetTagName again.  However, this scheme is easier than changing
                BrValueOfTag to return a BOOL and amending all its other callers, who don't need this info.
            */

            // Flags and counters used to track and validate the @ command directive
            //
            int     nFirstPass = 1;
            int     nOffset     = 0;
            BOOLB   fTagLanguage    = TRUE;
            BOOLB   fTagCodePage    = TRUE;
            BOOLB   fTagLCID        = TRUE;
            BOOLB   fTagTransacted  = TRUE;
            BOOLB   fTagSession     = TRUE;

            while( GetTag( brSegment, nFirstPass) )
                {
                nFirstPass =2;
                nOffset = 0;

                if ( fTagLanguage && CompTagName( brSegment, CTokenList::tknTagLanguage ) )
                    {
                    fTagLanguage = FALSE;
                    brEngine = BrValueOfTag(brSegment, CTokenList::tknTagLanguage);
                    if ( brEngine.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

                    // get prog lang id
                    PROGLANG_ID ProgLangId;
                    HRESULT hr = GetProgLangId(brEngine, &ProgLangId);

                    if(hr == TYPE_E_ELEMENTNOTFOUND)
                        // if prog lang not found, throw error
                        ThrowErrorSingleInsert(
                                            brEngine.m_pb,
                                            IDE_TEMPLATE_BAD_PROGLANG,
                                            brEngine.m_pb,
                                            brEngine.m_cb
                                            );
                    else if(FAILED(hr))
                        // other failure: re-throw exception code
                        THROW(hr);

                    Assert(WorkStore.m_ScriptStore.CountPreliminaryEngines() >= 1);

                    // Set 0-th (primary) script engine to user-specified value
                    WorkStore.m_ScriptStore.m_bufEngineNames.SetItem(
                                                                0,          // index of item to set
                                                                brEngine,   // engine name
                                                                FALSE,      // item is non-local
                                                                0,          // sequence id (don't care)
                                                                NULL        // filemap ptr (don't care)
                                                                );

                    // Set 0-th (primary) prog lang id to engine's
                    WorkStore.m_ScriptStore.m_rgProgLangId[0] = ProgLangId;
                    brSegment.Advance(DIFF(brEngine.m_pb - brSegment.m_pb));

                    }

                /*  set code page if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagCodePage && CompTagName( brSegment, CTokenList::tknTagCodePage ) )
                    {
                    fTagCodePage = FALSE;
                    CByteRange brCodePage = BrValueOfTag( brSegment, CTokenList::tknTagCodePage );
                    if ( brCodePage.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CODEPAGE);

                    if ( brCodePage.m_cb > 10 )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    char    szCodePage[31];
                    strncpy( szCodePage, (char*) brCodePage.m_pb, brCodePage.m_cb );
                    szCodePage[ brCodePage.m_cb ] = '\0';

                    char   *pchEnd;
                    UINT    uCodePage = UINT( strtoul( szCodePage, &pchEnd, 10 ) );

                    // verify that pchEnd is the NULL
                    if (*pchEnd != 0)

                       ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    if ((m_fCodePageSet == TRUE) && (uCodePage != pHitObj->GetCodePage()))
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_MIXED_CODEPAGE_USAGE);

                    if ( FAILED( pHitObj->SetCodePage( uCodePage ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);
                    else
                        {
                        m_wCodePage = uCodePage;
                        m_fCodePageSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brCodePage.m_pb - brSegment.m_pb));
                    }
                /*  set LCID if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagLCID && CompTagName( brSegment, CTokenList::tknTagLCID ) )
                    {
                    fTagLCID = FALSE;
                    CByteRange brLCID = BrValueOfTag( brSegment, CTokenList::tknTagLCID );
                    if ( brLCID.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_LCID);

                    if ( brLCID.m_cb > 10 ) // cannot be greater than 4G 4,000,000,000
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);

                    char    szLCID[31];
                    strncpy( szLCID, (char*) brLCID.m_pb, brLCID.m_cb );
                    szLCID[ brLCID.m_cb ] = '\0';

                    char   *pchEnd;
                    UINT    uLCID = UINT( strtoul( szLCID, &pchEnd, 10 ) );

                    // verify that pchEnd is the NULL
                    if (*pchEnd != 0)
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);

                    if ( FAILED( pHitObj->SetLCID( uLCID ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);
                    else
                        {
                        m_lLCID = uLCID;
                        m_fLCIDSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brLCID.m_pb - brSegment.m_pb));
                    }
                /* Set transacted if requiured
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagTransacted && CompTagName( brSegment, CTokenList::tknTagTransacted ) )
                    {

                    STACK_BUFFER( tempTransValue, 32 );

                    fTagTransacted = FALSE;
                    CByteRange brTransacted = BrValueOfTag( brSegment, CTokenList::tknTagTransacted );
                    if ( brTransacted.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    if (!tempTransValue.Resize(brTransacted.m_cb + 1)) {
                        ThrowError(brSegment.m_pb, IDE_OOM);
                    }

                    LPSTR szTransacted = static_cast<LPSTR> (tempTransValue.QueryPtr());
                    strncpy(szTransacted, (LPCSTR)brTransacted.m_pb, brTransacted.m_cb);
                    szTransacted[brTransacted.m_cb]='\0';
                    if (!strcmpi(szTransacted, "REQUIRED"))
                        m_ttTransacted = ttRequired;
                    else if (!strcmpi(szTransacted, "REQUIRES_NEW"))
                        m_ttTransacted = ttRequiresNew;
                    else if (!strcmpi(szTransacted, "SUPPORTED"))
                        m_ttTransacted = ttSupported;
                    else if (!strcmpi(szTransacted, "NOT_SUPPORTED"))
                        m_ttTransacted = ttNotSupported;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    brSegment.Advance(DIFF(brTransacted.m_pb - brSegment.m_pb));
                    }
                /* Set session flag
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagSession && CompTagName( brSegment, CTokenList::tknTagSession ) )
                    {

                    STACK_BUFFER( tempSession, 16 );

                    fTagSession = FALSE;
                    CByteRange brSession = BrValueOfTag( brSegment, CTokenList::tknTagSession );
                    if ( brSession.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    if (!tempSession.Resize(brSession.m_cb + 1))
                        ThrowError(brSegment.m_pb, IDE_OOM);

                    LPSTR szSession = static_cast<LPSTR> (tempSession.QueryPtr());
                    strncpy(szSession, (LPCSTR)brSession.m_pb, brSession.m_cb);
                    szSession[brSession.m_cb]='\0';
                    if (strcmpi(szSession, "TRUE") == 0)
						{
                        m_fSession = TRUE;
						if (!pHitObj->PAppln()->QueryAppConfig()->fAllowSessionState())
							ThrowError(brSegment.m_pb, IDE_TEMPLATE_CANT_ENABLE_SESSIONS);
						}
                    else if (strcmpi(szSession, "FALSE") == 0)
                        m_fSession = FALSE;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    brSegment.Advance(DIFF(brSession.m_pb - brSegment.m_pb));
                    }
                else
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );
                }

                if (nFirstPass == 1)
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );



            // set flag true and ignore remainder of segment, since we only use this segment for page-level @ commands
            WorkStore.m_fPageCommandsExecuted = TRUE;
            goto LExit;
            }

        }

    if(sseg == ssegTaggedScript)
        {
        if(!fScriptTagProcessed)
            {
            /*  semantics of script-tag-processed flag:
                - if false, we have a 'fresh' tagged script block, so we need to get its engine name
                  (which also advances past the script tag header) and then process the tagged segment
                  via indirect recursive call
                - if true, we have aleady been called recursively, so we bypass further recursion
                  and simply append to store
            */
            CByteRange brIncludeFile;
            GetScriptEngineOfSegment(brSegment, WorkStore.m_brCurEngine, brIncludeFile);
            if (! brIncludeFile.IsNull())
                {

                STACK_BUFFER( tempInclude, 256 );

                if (!tempInclude.Resize(brIncludeFile.m_cb + 1)) {
                    ThrowError(brSegment.m_pb, IDE_OOM);
                }

                                // Create Null-terminated string from brIncludeFile
                                char *szFileSpec = reinterpret_cast<char *>(tempInclude.QueryPtr());
                                memcpy(szFileSpec, brIncludeFile.m_pb, brIncludeFile.m_cb);
                                szFileSpec[brIncludeFile.m_cb] = 0;
                                if (szFileSpec[0] == '\\')      // metabase stuff chokes on initial '\' char
                                    szFileSpec[0] = '/';

                                // read the include file (szFileSpec & brIncludeFile in this case point to same string contents.
                                // however, "brIncludeFile" is used as an error location.
                                //
                TRY
                                    ProcessIncludeFile2(szFileSpec, brIncludeFile, pfilemapCurrent, WorkStore, idSequence, pHitObj, FALSE);
                CATCH(hrException)

                    // The TRY/CATCH below may re-throw a IDE_TEMPLATE_BAD_PROGLANG when the
                    // segment being processed is tagged script with a SRC file.  The reason being
                    // that to properly report the error, the ThrowErrorSingleInsert must be called
                    // from the template which contained the script tag with the bad prog lang.  If
                    // called from the template created containing the included script, then the
                    // brEngine assigned below is not pointing into the included script's filemap
                    // which results in AVs because we can't do the pointer math to determine the
                    // line number.

                    if(hrException == IDE_TEMPLATE_BAD_PROGLANG)
                        // exception code is really an error message id: set err id to it
                        ThrowErrorSingleInsert(
                                                WorkStore.m_brCurEngine.m_pb,
                                                IDE_TEMPLATE_BAD_PROGLANG,
                                                WorkStore.m_brCurEngine.m_pb,
                                                WorkStore.m_brCurEngine.m_cb
                                                );
                    else

                        // other exception: re-throw
                        THROW(hrException);

                END_TRY


                                // done - don't process script text
                                return;
                }
            else
                                ProcessTaggedScriptSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
            }

        brEngine = WorkStore.m_brCurEngine;
        }

    TRY
        // append script segment to store
        WorkStore.m_ScriptStore.AppendScript(brSegment, brEngine, (sseg == ssegPrimaryScript), idSequence, pfilemapCurrent);

    CATCH(hrException)
        // NOTE exception code from AppendScript() is overloaded: it can be an error message id or a true exception

        // if the brEngine does not point to memory within the current filemap, then
        // we must have come into here because of a tagged script statement with a SRC=
        // attrib.  In which case, we won't call ThrowError from here but will re-throw
        // the error to be caught above.

        if((hrException == IDE_TEMPLATE_BAD_PROGLANG)
           && (brEngine.m_pb >= pfilemapCurrent->m_pbStartOfFile)
           && (brEngine.m_pb <  (pfilemapCurrent->m_pbStartOfFile + pfilemapCurrent->GetSize()))) {
            // exception code is really an error message id: set err id to it
            ThrowErrorSingleInsert(
                                    brEngine.m_pb,
                                    IDE_TEMPLATE_BAD_PROGLANG,
                                    brEngine.m_pb,
                                    brEngine.m_cb
                                    );
        }
        else
            // other exception: re-throw
            THROW(hrException);

    END_TRY

LExit:
    // set flag to say we can no longer set primary language (must be in first script segment, if at all)
    WorkStore.m_fPageCommandsAllowed = FALSE;
    }


/*  ========================================================
    CTemplate::ProcessMetadataSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // TYPELIB
    if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueTypeLib))
        {
        return ProcessMetadataTypelibSegment(brSegment, pidError, pHitObj);
        }
        // METADATA INVALID in Global.asa
        else if (m_fGlobalAsa)
                {
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA);
                return E_TEMPLATE_COMPILE_FAILED_DONT_CACHE;   // to keep compiler happy; in reality doesn't return.
                }
    // COOKIE
    else if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueCookie))
        {
        return ProcessMetadataCookieSegment(brSegment, pidError, pHitObj);
        }
    // Ignore everything else
    else
        {
        return S_OK;
        }
    }


/*  ========================================================
    CTemplate::ProcessMetadataTypelibSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataTypelibSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // Ignore ENDSPAN segments
    if (GetTagName(brSegment, CTokenList::tknTagEndspan))
        {
        // ENDSPAN found - ignore
        return S_OK;
        }

    HRESULT hr;
    char  szFile[MAX_PATH+1];
    DWORD cbFile;

    // Try to get the filename
    CByteRange br = BrValueOfTag(brSegment, CTokenList::tknTagFile);
    if (!br.IsNull())
        {
        // filename present
        if (br.m_cb > MAX_PATH)
            {
            // file too long
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }
        memcpy(szFile, br.m_pb, br.m_cb);
        cbFile = br.m_cb;
        szFile[cbFile] = '\0';
        }
    else
        {
        // No filename - use GUID, version, LCID to get file

        char szUUID[44]; // {} + hex chars + dashes
        char szVers[16]; // "1.0", etc
        char szLCID[16]; // locale id - a number

        br = BrValueOfTag(brSegment, CTokenList::tknTagUUID);
        if (br.IsNull() || br.m_cb > sizeof(szUUID)-3)
            {
            // no filename and no uuid -> invalid typelib spec
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }

        if (br.m_pb[0] == '{')
            {
            // already in braces
            memcpy(szUUID, br.m_pb, br.m_cb);
            szUUID[br.m_cb] = '\0';
            }
        else
            {
            // enclose in {}
            szUUID[0] = '{';
            memcpy(szUUID+1, br.m_pb, br.m_cb);
            szUUID[br.m_cb+1] = '}';
            szUUID[br.m_cb+2] = '\0';
            }

        // Optional Version
        szVers[0] = '\0';
        br = BrValueOfTag(brSegment, CTokenList::tknTagVersion);
        if (!br.IsNull() && br.m_cb < sizeof(szVers)-1)
            {
            memcpy(szVers, br.m_pb, br.m_cb);
            szVers[br.m_cb] = '\0';
            }

        // Optional LCID
        LCID lcid;
        br = BrValueOfTag(brSegment, CTokenList::tknTagLCID);
        if (!br.IsNull() && br.m_cb < sizeof(szLCID)-1)
            {
            memcpy(szLCID, br.m_pb, br.m_cb);
            szLCID[br.m_cb] = '\0';
            lcid = strtoul(szLCID, NULL, 16);
            }
        else
            {
            // if the LCID is not defined -> use system's
            lcid = GetSystemDefaultLCID();
            }

        // Get TYPELIB filename from registry
        hr = GetTypelibFilenameFromRegistry
            (
            szUUID,
            szVers,
            lcid,
            szFile,
            MAX_PATH
            );

        if (FAILED(hr))
            {
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC;
            return hr;
            }

        cbFile = strlen(szFile);
        }

    // Convert filename to double-byte to call LoadTypeLib()

    STACK_BUFFER( tempFile, MAX_PATH * sizeof(WCHAR) );

    if (!tempFile.Resize((cbFile+1) * sizeof(WCHAR))) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    LPWSTR wszFile = (LPWSTR)tempFile.QueryPtr();

    if (MultiByteToWideChar(pHitObj->GetCodePage(), MB_ERR_INVALID_CHARS,
                            szFile, cbFile, wszFile, cbFile) == 0)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    wszFile[cbFile] = L'\0';

    // LoadTypeLib() to get ITypeLib*
    ITypeLib *ptlb = NULL;
    hr = LoadTypeLib(wszFile, &ptlb);

    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }

    // Remember ITypeLib* in the array
    Assert(ptlb);
    hr = m_rgpTypeLibs.append(ptlb);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }


    return S_OK;
    }


/*  ========================================================
    CTemplate::ProcessMetadataCookieSegment
    Parses the metadata comment for cookie information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataCookieSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    HRESULT hr;
    CByteRange br;
    char  *pszName;
    char  szFile[MAX_PATH+1];
    TCHAR sztFile[MAX_PATH+1];
    CMBCSToWChar    convStr;

    STACK_BUFFER( tempCookie, 64 );
    STACK_BUFFER( tempFile, 64 );

    // Try to get the cookie name
    br = BrValueOfTag(brSegment, CTokenList::tknTagName);
    if (br.IsNull() || (br.m_cb == 0)) {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME;
        return E_FAIL;
    }

    if (!tempCookie.Resize(br.m_cb + 1)) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pszName = (char *)tempCookie.QueryPtr();
    if (!pszName)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    memcpy(pszName, br.m_pb, br.m_cb);
    pszName[br.m_cb] = '\0';


    // Try to get the path to the script
    br = BrValueOfTag(brSegment, CTokenList::tknTagSrc);
    if (br.IsNull() || (br.m_cb >= MAX_PATH) || (br.m_cb == 0))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    memcpy(szFile, br.m_pb, br.m_cb);
    szFile[br.m_cb] = '\0';

    // Convert file to physical path
    Assert(pHitObj->PServer());

    WCHAR   *pCookieFile;
    // 6.0 can handle UNICODE. Convert using script code page
    if (FAILED (convStr.Init (szFile,pHitObj->GetCodePage()))) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pCookieFile = convStr.GetString();
    if (FAILED(pHitObj->PServer()->MapPathInternal(0, pCookieFile, sztFile)))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    Normalize(sztFile);

    // Construct 449-echo-cookie object
    C449Cookie *p449 = NULL;
    hr = Create449Cookie(pszName, sztFile, &p449);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    // Remember 449 cookie in the array
    Assert(p449);
    hr = m_rgp449.append(p449);
    if (FAILED(hr)) {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    return S_OK;
}


/*  ========================================================
    CTemplate::GetScriptEngineOfSegment
    Returns script engine name for a script segment.

    Returns
        Byte range containing script engine name
    Side effects
        Advances segment byte range past close tag token
*/
void
CTemplate::GetScriptEngineOfSegment
(
CByteRange&                     brSegment,                      // segment byte range
CByteRange&                     brEngine,                       // script engine name
CByteRange&                     brInclude                       // value of SRC tag
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseTaggedScript, &pbCloseTag);

    // if no close found, throw error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);

    Assert(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer));

    // get engine name from tags
    brEngine = BrValueOfTag(brTags, CTokenList::tknTagLanguage);
    if(brEngine.IsNull())
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

    // Get SRC attribute from tags
    brInclude = BrValueOfTag(brTags, CTokenList::tknTagSrc);

    // advance segment past close tag token
    gm_pTokenList->MovePastToken(CTokenList::tknCloseTag, pbCloseTag, brSegment);
    }

/*  ========================================================
    CTemplate::ProcessTaggedScriptSegment
    Processes a tagged script segment: within tagged script we
    honor plain text (passed through as script text) and HTML comments.
    See bug 423 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessTaggedScriptSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
CHitObj*        pHitObj         // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    _TOKEN      tknOpeners[1];
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;

    // Process source segments embedded within tagged script segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,          // byte range to search for next segment-opening token
                                    ssegTaggedScript,   // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,       // array of permitted open tokens
                                    ctknOpeners,        // count of permitted open tokens
                                    pfilemapCurrent,    // ptr to filemap of parent file
                                    WorkStore,          // working storage for source segments
                                    pHitObj,            // Browser request object
                                    TRUE,               // script tag has been processed
                                    FALSE               // NOT in HTML segment
                                );
    }

/*  ============================================================================
    CTemplate::ProcessObjectSegment
    Processes an object segment.

    Returns
        Nothing
    Side effects
        throws on error
*/
void
CTemplate::ProcessObjectSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
UINT            idSequence      // segment sequence id
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseObject, &pbCloseTag);

    // if no close found, bail on error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_OBJECT);

    // if this is a server object (RUNAT=Server), process its tags
    if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
        {
        CLSID   ClsId;  // clsid

        // get name value
        CByteRange brName = BrValueOfTag(brTags, CTokenList::tknTagID);

        // if name is null, error out
        if(brName.IsNull())
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_OBJECT_NAME);

        if(!FValidObjectName(brName))
            ThrowErrorSingleInsert(brName.m_pb, IDE_TEMPLATE_INVALID_OBJECT_NAME, brName.m_pb, brName.m_cb);

        // get values for ClassID and ProgID tags
        CByteRange brClassIDText = BrValueOfTag(brTags, CTokenList::tknTagClassID);
        CByteRange brProgIDText = BrValueOfTag(brTags, CTokenList::tknTagProgID);

        if(!brClassIDText.IsNull())
            // if we find a text class id, set clsid with it
            // NOTE progid tag is ignored if classid tag exists
            GetCLSIDFromBrClassIDText(brClassIDText, &ClsId);
        else if(!brProgIDText.IsNull())
            // else if we find a prog id, resolve it into a class id
            GetCLSIDFromBrProgIDText(brProgIDText, &ClsId);
        else
            // else, throw error; can't create an object without at least one of classid or progid
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_NO_CLASSID_PROGID, brName.m_pb, brName.m_cb);

        // set scope; bail if bogus
        CompScope csScope = csUnknown;
        CByteRange brScope = BrValueOfTag(brTags, CTokenList::tknTagScope);
        if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValuePage)) || brScope.IsNull())
            // non-existent scope tag defaults to page scope
            csScope = csPage;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueApplication)))
            csScope = csAppln;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueSession)))
            csScope = csSession;
        else
            ThrowError(brTags.m_pb, IDE_TEMPLATE_BAD_OBJECT_SCOPE);

        if(!m_fGlobalAsa && csScope != csPage)
            // error out on non-page-level object if we are processing anything but global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE, brName.m_pb, brName.m_cb);
        else if(m_fGlobalAsa && csScope == csPage)
            // error out on page-level object if we are processing global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE, brName.m_pb, brName.m_cb);

        // set threading model
        CompModel cmModel = cmSingle;
        CompModelFromCLSID(ClsId, &cmModel);

        // append object-info to store
        WorkStore.m_ObjectInfoStore.AppendObject(brName, ClsId, csScope, cmModel, idSequence);

        }

    }

/*  ============================================================================
    CTemplate::GetCLSIDFromBrClassIDText
    Sets a clsid from a byte range containing an ANSI text version of a class id

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrClassIDText
(
CByteRange& brClassIDText,
LPCLSID pclsid
)
    {
    // if class id text starts with its standard object tag prefix, advance past it
    if(!_strnicmp((char*)brClassIDText.m_pb, "clsid:", 6))
        brClassIDText.Advance(6);

    // if class id text is bracketed with {}, adjust byte range to strip them
    // NOTE we always add {} below, because normal case is that they are missing from input text
    if(*brClassIDText.m_pb == '{')
        brClassIDText.Advance(1);
    if(*(brClassIDText.m_pb + brClassIDText.m_cb - 1) == '}')
        brClassIDText.m_cb--;

    // Allocate a wide char string for the string version of class id
    // NOTE we add 3 characters to hold {} and null terminator
    OLECHAR* pszWideClassID = new WCHAR[brClassIDText.m_cb + 3];
    if (NULL == pszWideClassID)
        THROW(E_OUTOFMEMORY);

    // start wide string class id with left brace
    pszWideClassID[0] = '{';

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brClassIDText.m_pb, // input ANSI string version of class id
                                    brClassIDText.m_cb,         // length of input string
                                    pszWideClassID + 1,         // location for output wide string class id
                                    brClassIDText.m_cb          // size of output buffer
                                ))
        {
        delete [] pszWideClassID;
        THROW(E_FAIL);
        }

    // append right brace to wide string
    pszWideClassID[brClassIDText.m_cb + 1] = '}';

    // Null terminate the wide string
    pszWideClassID[brClassIDText.m_cb + 2] = NULL;

    // Now get the clsid from wide string class id
    if(FAILED(CLSIDFromString(pszWideClassID, pclsid)))
        {
        delete [] pszWideClassID;
        ThrowErrorSingleInsert(brClassIDText.m_pb, IDE_TEMPLATE_BAD_CLASSID, brClassIDText.m_pb, brClassIDText.m_cb);
        }

    if(NULL != pszWideClassID)
        delete [] pszWideClassID;
    }

/*  ===================================================================
    CTemplate::GetCLSIDFromBrProgIDText
    Gets a clsid from the registry given a ProgID

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrProgIDText
(
CByteRange& brProgIDText,
LPCLSID pclsid
)
    {
    // allocate a wide char string for ProgID plus null terminator
    OLECHAR* pszWideProgID = new WCHAR[brProgIDText.m_cb + 1];
    if (NULL == pszWideProgID)
        THROW(E_OUTOFMEMORY);

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brProgIDText.m_pb,  // input ANSI string version of prog id
                                    brProgIDText.m_cb,          // length of input string
                                    pszWideProgID,              // location for output wide string prog id
                                    brProgIDText.m_cb           // size of output buffer
                                ))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        THROW(E_FAIL);
        }

    // Null terminate the wide string
    pszWideProgID[brProgIDText.m_cb] = NULL;

    // Now get clsid from ProgID
    if(FAILED(CLSIDFromProgID(pszWideProgID, pclsid)))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        ThrowErrorSingleInsert(brProgIDText.m_pb, IDE_TEMPLATE_BAD_PROGID, brProgIDText.m_pb, brProgIDText.m_cb);
        }

    // Cache ProgId to CLSID mapping
    g_TypelibCache.RememberProgidToCLSIDMapping(pszWideProgID, *pclsid);

    if (NULL != pszWideProgID)
        delete [] pszWideProgID;
}

/*  ============================================================================
    CTemplate::FValidObjectName
    Determines whether an object name clashes with a Denali intrinsic object name.

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CTemplate::FValidObjectName
(
CByteRange& brName  // object name
)
    {
    if(brName.FMatchesSz(SZ_OBJ_APPLICATION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_REQUEST))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_RESPONSE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SERVER))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_CERTIFICATE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SESSION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SCRIPTINGNAMESPACE))
        return FALSE;

    return TRUE;
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile

    Processes an include file.

    Returns
        Nothing
*/
void
CTemplate::ProcessIncludeFile
(
CByteRange& brSegment,          // segment byte range
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
    {
    CByteRange  brFileSpec;             // filespec of include file
    BOOLB       fVirtual = FALSE;       // is include filespec virtual?
                                        // filespec of include file (sz)
    CHAR        szFileSpec[MAX_PATH + 1];
    LPSTR       szTemp = szFileSpec;    // temp ptr to filespec

    // get value of FILE tag
    brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagFile);

    if(brFileSpec.IsNull())
        {
        // if we found no FILE tag, get value of VIRTUAL tag
        brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagVirtual);
        fVirtual = TRUE;
        }

    if(brFileSpec.IsNull())
        // if we found neither, error out
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_INCLUDE_NAME);

    if (brFileSpec.m_cb>MAX_PATH)
    {
    	// return the last MAX_PATH chars of the file name.  This is done
        // this way to avoid a Error Too Long message when the include
        // file spec is exceedingly long.

    	char fileNameLast[MAX_PATH+4];
    	strcpy(fileNameLast, "...");
    	strcpy(fileNameLast+3, (LPSTR)(brFileSpec.m_pb+brFileSpec.m_cb-MAX_PATH));
    	
        ThrowErrorSingleInsert(brFileSpec.m_pb,
                               IDE_TEMPLATE_BAD_INCLUDE,
                               brFileSpec.m_pb,
                               brFileSpec.m_cb);

    }

    // NOTE we manipulate temp sz to preserve szFileSpec
    if(fVirtual)
        {
        if(*brFileSpec.m_pb == '\\')
            {
            // if VIRTUAL path starts with backslash, replace it with fwd slash
            *szTemp++ = '/';
            brFileSpec.Advance(1);
            }
        else if(*brFileSpec.m_pb != '/')
            // if VIRTUAL path starts with anything other than fwd slash or backslash, prepend fwd slash
            *szTemp++ = '/';
        }

    // append supplied path to temp sz
    strncpy(szTemp, (LPCSTR) brFileSpec.m_pb, brFileSpec.m_cb);
    szTemp[brFileSpec.m_cb] = NULL;

    if(!fVirtual)
        {
        // if FILE filespec starts with \ or /, hurl
        if(*szFileSpec == '\\' || *szFileSpec == '/')
            ThrowErrorSingleInsert(
                                    brFileSpec.m_pb,
                                    IDE_TEMPLATE_BAD_FILE_TAG,
                                    brFileSpec.m_pb,
                                    brFileSpec.m_cb
                                  );
        }

    // NOTE: szFileSpec is the doctored path (it possibly has "/" prepended.
    //       brFileSpec is used as the error location.
    //
    ProcessIncludeFile2(szFileSpec, brFileSpec, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile2

    adds a #include file to the CTemplate and starts the template to processing
    the file.

    Returns
        Nothing
    Side effects
        Calls GetSegmentsFromFile recursively

    NOTE - kind of an oddball thing here.  The szFileSpec in this case is
    intentionally ANSI as it came from the ASP script content.  It may need
    to be converted to UNICODE.
*/
void
CTemplate::ProcessIncludeFile2
(
CHAR *      szAnsiFileSpec,			// file to include
CByteRange&	brErrorLocation,	// ByteRange in source where errors should be reported
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
{
    HRESULT     hr;
    TCHAR      *szFileSpec;

#if UNICODE
    CMBCSToWChar    convFileSpec;

    if (FAILED(hr = convFileSpec.Init(szAnsiFileSpec, pHitObj->GetCodePage()))) {
        THROW(hr);
    }
    szFileSpec = convFileSpec.GetString();
#else
    szFileSpec = szAnsiFileSpec;
#endif
    // if parent paths are disallowed and filespec contains parent dir reference, hurl
    if (!pHitObj->QueryAppConfig()->fEnableParentPaths() && _tcsstr(szFileSpec, _T("..")))
            ThrowErrorSingleInsert(
                                    brErrorLocation.m_pb,
                                    IDE_TEMPLATE_DISALLOWED_PARENT_PATH,
                                    brErrorLocation.m_pb,
                                    brErrorLocation.m_cb
                                  );

    TRY
        AppendMapFile(
                        szFileSpec,
                        pfilemapCurrent,
                        (szFileSpec[0] == _T('/')) || (szFileSpec[0] == _T('\\')),  // fVirtual
                        pHitObj,        // main file's hit object
                        FALSE           // not the global.asa file
                    );
    CATCH(hrException)

        // MapFile() threw an exception: delete last filemap's memory and decrement filemap counter
        // NOTE this is a bit hokey, but we need to do it here rather than AppendMapFile (where we allocated)
        // because its other caller(s) may not want this behavior
        delete m_rgpFilemaps[m_cFilemaps-- - 1];

        /*  NOTE exception code from MapFile() is overloaded: it can sometimes
            be an error message id, sometimes a true exception
            NOTE security error causes exception E_USER_LACKS_PERMISSIONS, rather than error id,
            but we pass it thru as if it were an error id because the various error-catch routines
            know how to handle E_USER_LACKS_PERMISSIONS specially.
        */
        UINT    idErrMsg;
        if(hrException == IDE_TEMPLATE_CYCLIC_INCLUDE || hrException == E_USER_LACKS_PERMISSIONS)
            // exception code is really an error message id: set err id to it
            idErrMsg = hrException;
        else if(hrException == E_COULDNT_OPEN_SOURCE_FILE)
            // exception is generic couldn't-open-file : set err id to generic bad-file error
            idErrMsg = IDE_TEMPLATE_BAD_INCLUDE;
        else
            // other exception: re-throw
            THROW(hrException);

        ThrowErrorSingleInsert(
                                brErrorLocation.m_pb,
                                idErrMsg,
                                brErrorLocation.m_pb,
                                brErrorLocation.m_cb
                              );
    END_TRY

    // store ptr to current file map in local before recursive call (which may increment m_cFilemaps)
    CFileMap*   pfilemap = m_rgpFilemaps[m_cFilemaps - 1];

    // get inc-file object from cache
    CIncFile*   pIncFile;

    if(FAILED(hr = g_IncFileMap.GetIncFile(pfilemap->m_szPathTranslated, &pIncFile)))
        THROW(hr);

    // add this template to inc-file's template list
    if (FAILED(hr = pIncFile->AddTemplate(this)))
        THROW(hr);

    // set filemap's inc-file ptr
    pfilemap->m_pIncFile = pIncFile;

    // get source segments from include file
    // bugs 1363, 1364: process include file only after we establish dependencies;
    // required for cache flushing to work correctly after compile errors
    GetSegmentsFromFile(*pfilemap, WorkStore, pHitObj, fIsHTML);
}

/*  ===================================================================
    CTemplate::GetOpenToken
    Returns the token index of and a ptr to the first valid open token
    in search range.  For the open token to be valid, we must bypass
    segments we should not process, e.g. scripts or objects not tagged as 'server'

    Returns
        ptr to open token; ptr to open token enum value (out-parameter)
    Side effects
        None
*/
BYTE*
CTemplate::GetOpenToken
(
CByteRange  brSearch,       // (ByVal) byte range to search for next segment-opening token
SOURCE_SEGMENT ssegLeading, // type of 'leading', i.e. pre-token, source segment
                            //  (only used when deciding to ignore non-SSI comments)
_TOKEN*     rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
_TOKEN*     ptknOpen        // ptr to open token enum value (out-parameter)
)
    {
    BYTE*   pbTokenOpen = NULL;     // ptr to opening token

    // keep getting segment-opening tokens until we find one that we need to process
    while(TRUE)
        {
        // Get next open token in search range
        *ptknOpen = gm_pTokenList->NextOpenToken(
                                                    brSearch,
                                                    rgtknOpeners,
                                                    ctknOpeners,
                                                    &pbTokenOpen,
                                                    m_wCodePage
                                                );

        /*  Certain tokens must be followed immediately by white space; others need not.
            NOTE it is pure coincidence that the 'white-space tokens' are also those that
            get special processing below; hence we handle white space issue there.
            If we ever add another 'white-space token' that doesn't require the special processing,
            we will need to handle the white space issue here.
        */

        /*  Similar thing applies to non-include and non-metadata HTML
            comments. We really don't care for them to generate their
            own segments -- we can reduce number of Response.WriteBlock()
            calls by considering them part of the preceding HTML segment.
        */

        if (*ptknOpen == CTokenList::tknOpenHTMLComment)
            {
            if (ssegLeading != ssegHTML)  // if not inside HTML
                break;                    // generate a new segment

            // for HTML comments check if it is an include or metadata
            // and if not, this is not a separate segment - keep on looking
            // for the next opener

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // find end of comment
            BYTE *pbClose = gm_pTokenList->GetToken(CTokenList::tknCloseHTMLComment,
                                                    brSearch, m_wCodePage);
            if (pbClose == NULL)
                {
                // Error -- let other code handle this
                break;
                }

            // construct comment byte range to limit search to it
            CByteRange brComment = brSearch;
            brComment.m_cb = DIFF(pbClose - brSearch.m_pb);

            // look for metadata and include (only inside the comment)

            if (gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE,
                                        brComment, m_wCodePage))
                {
                // SSI inclide -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagMETADATA,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagFPBot,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else
                {
                // Regular comment - ignore it
                goto LKeepLooking;
                }
            }
        else if (*ptknOpen == CTokenList::tknOpenTaggedScript || *ptknOpen == CTokenList::tknOpenObject)
            {
            /*  if token was script or object tag, check to see if:
                a) it is followed immediately by white space; if not keep looking
                b) it opens a well-formed segment, i.e. one with a proper close tag; if not, throw error
                c) it is designated runat-server; if not keep looking
            */

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // bug 760: if token is not followed immediately by white space, keep looking
            if(!brSearch.IsNull())
                if(!FWhiteSpace(*brSearch.m_pb))
                    goto LKeepLooking;

            // ptr to close of start tag
            BYTE*       pbCloseTag;
            // tags contained in start tag
            CByteRange  brTags = BrTagsFromSegment(
                                                    brSearch,
                                                    GetComplementToken(*ptknOpen),
                                                    &pbCloseTag
                                                );

            if(pbCloseTag == NULL)
                {
                // if no close tag, throw error
                if(*ptknOpen == CTokenList::tknOpenObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
                else if(*ptknOpen == CTokenList::tknOpenTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
                }

            // if this is a server object (RUNAT=Server), we will process it; else keep looking
            if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
                break;

            }
        else
            {
            // if token was other than script or object tag, or comment
            // we should process segment;
            // hence we have found our open token, so break
            break;
            }

LKeepLooking: ;
        }

    return pbTokenOpen;
    }

/*  ===================================================================
    CTemplate::GetCloseToken
    Returns a ptr to the next token of type tknClose.

    Returns
        ptr to close token
    Side effects
        Detects and errors out on attempt to nest tagged script or object blocks.
*/
BYTE*
CTemplate::GetCloseToken
(
CByteRange  brSearch,       // (ByVal) byte range to search
_TOKEN      tknClose        // close token
)
    {
    BYTE*   pbTokenClose = gm_pTokenList->GetToken(tknClose, brSearch, m_wCodePage);

    if(pbTokenClose != NULL)
        if(tknClose == CTokenList::tknCloseTaggedScript || tknClose == CTokenList::tknCloseObject)
            {
            CByteRange  brSegment;
            BYTE*       pbTokenOpen;

            brSegment.m_pb = brSearch.m_pb;
            brSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

            if(NULL != (pbTokenOpen = gm_pTokenList->GetToken(GetComplementToken(tknClose), brSegment, m_wCodePage)))
                {
                if(tknClose == CTokenList::tknCloseTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_TSCRIPT);
                else if(tknClose == CTokenList::tknCloseObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_OBJECT);
                }
            }

    return pbTokenClose;
    }

/*===================================================================
    CTemplate::GetComplementToken

    Returns a token's compement token.

    Returns
        Complement token
    Side effects
        None
*/
_TOKEN
CTemplate::GetComplementToken
(
_TOKEN  tkn
)
    {
    switch(tkn)
        {
    // open tokens
    case CTokenList::tknOpenPrimaryScript:
        return CTokenList::tknClosePrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return CTokenList::tknCloseTaggedScript;
    case CTokenList::tknOpenObject:
        return CTokenList::tknCloseObject;
    case CTokenList::tknOpenHTMLComment:
        return CTokenList::tknCloseHTMLComment;

    // close tokens
    case CTokenList::tknClosePrimaryScript:
        return CTokenList::tknOpenPrimaryScript;
    case CTokenList::tknCloseTaggedScript:
        return CTokenList::tknOpenTaggedScript;
    case CTokenList::tknCloseObject:
        return CTokenList::tknOpenObject;
    case CTokenList::tknCloseHTMLComment:
        return CTokenList::tknOpenHTMLComment;
        }

    Assert(FALSE);
    return CTokenList::tknEOF;
    }

/*===================================================================
    CTemplate::GetSegmentOfOpenToken

    Returns the segment type of an open token.

    Returns
        source segment type of open token
    Side effects
        None
*/
CTemplate::SOURCE_SEGMENT
CTemplate::GetSegmentOfOpenToken
(
_TOKEN tknOpen
)
    {
    switch(tknOpen)
        {
    case CTokenList::tknOpenPrimaryScript:
        return ssegPrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return ssegTaggedScript;
    case CTokenList::tknOpenObject:
        return ssegObject;
    case CTokenList::tknOpenHTMLComment:
        return ssegHTMLComment;
        }

    return ssegHTML;
    }

/*  ========================================================
    CTemplate::BrTagsFromSegment

    Returns the tag range from an HTML start tag

    Returns
        tag byte range
    Side effects
        none
*/
CByteRange
CTemplate::BrTagsFromSegment
(
CByteRange  brSegment,  // segment byte range
_TOKEN      tknClose,   // close token
BYTE**      ppbCloseTag // ptr-to-ptr to close tag - returned to caller
)
    {
    CByteRange  brTags; // tags return value - NOTE constructed null
                        // ptr to close token - NOTE null if none within segment byte range
    BYTE*       pbTokenClose = GetCloseToken(brSegment, tknClose);

    // if no close tag found, return null tags
    if(NULL == (*ppbCloseTag = gm_pTokenList->GetToken(CTokenList::tknCloseTag, brSegment, m_wCodePage)))
        goto Exit;

    // if next non-null close token occurs before close tag, close tag is invalid; return nulls
    if((pbTokenClose != NULL) && (*ppbCloseTag > pbTokenClose ))
        {
        *ppbCloseTag = NULL;
        goto Exit;
        }

    // crack tags from header tag
    brTags.m_pb = brSegment.m_pb;
    brTags.m_cb = DIFF(*ppbCloseTag - brSegment.m_pb);

Exit:
    return brTags;
    }

/*  ========================================================
    CTemplate::BrValueOfTag

    Returns a tag's value from a byte range; null if tag is not found
    NOTE value search algorithm per W3 HTML spec - see www.w3.org

    Returns
        byte range of tag's value
        pfTagExists - does the tag exist in tags byte range?    (out-parameter)
            NOTE we default *pfTagExists = TRUE; most callers don't care and omit this parameter
    Side effects
        none
*/
CByteRange
CTemplate::BrValueOfTag
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;        // temp byte range
    CByteRange  brValue;                // byte range of value for the given tag - NOTE constructed null
    char        chDelimiter = NULL;     // value delimiter
                                        // ptr to tag name
    BYTE*       pbTagName = GetTagName(brTags, tknTagName);

    // If we did not find tag, return
    if(pbTagName == NULL)
        return brValue;

    // Move past tag name token and pre-separator white space
    brTemp.Advance(DIFF(pbTagName - brTags.m_pb) + CCH_TOKEN(tknTagName));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If we did not find separator, return
    if(*brTemp.m_pb != CH_ATTRIBUTE_SEPARATOR)
        goto Exit;

    // Move past separator and post-separator white space
    brTemp.Advance(sizeof(CH_ATTRIBUTE_SEPARATOR));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If value begins with a quote mark, cache it as delimiter
    if((*brTemp.m_pb == CH_SINGLE_QUOTE) || (*brTemp.m_pb == CH_DOUBLE_QUOTE))
        chDelimiter = *brTemp.m_pb;

    if(chDelimiter)
        {
        // move past delimiter
        brTemp.Advance(sizeof(chDelimiter));
        if(brTemp.IsNull())
            goto Exit;
        }

    // provisionally set value to temp byte range
    brValue = brTemp;

    // advance temp byte range to end of value range
    while(
            (chDelimiter && (*brTemp.m_pb != chDelimiter))  // if we have a delimiter, find next delimiter
         || (!chDelimiter && (!FWhiteSpace(*brTemp.m_pb)))  // if we have no delimiter, find next white space
         )
        {
        // advance temp byte range
        brTemp.Advance(1);
        if(brTemp.IsNull())
            {
            if(chDelimiter)
                // we found no closing delimiter, so error out
                ThrowErrorSingleInsert(brValue.m_pb, IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER,
                                            pbTagName, CCH_TOKEN(tknTagName));
            else
                // value runs to end of temp byte range, so exit (since we already init'ed to temp)
                goto Exit;
            }
        }

    // set byte count so that value points to delimited range
    brValue.m_cb = DIFF(brTemp.m_pb - brValue.m_pb);

Exit:
    // if tag is empty, raise an error
    if (brValue.IsNull())
        {
        ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_VALUE_REQUIRED, pbTagName, CCH_TOKEN(tknTagName));
        }

    // enforce mandatory tag values if required
    if(tknTagName == CTokenList::tknTagRunat)
        {
        if(!brValue.FMatchesSz(SZ_TOKEN(CTokenList::tknValueServer)))
            ThrowError(brTags.m_pb, IDE_TEMPLATE_RUNAT_NOT_SERVER);
        }

    return brValue;
    }

/*  ============================================================================
    CTemplate::CompTagName

    Compares characters in two buffers (case-insensitive) and returns TRUE or FALSE

    Side effects
        none
*/
BOOL
CTemplate::CompTagName
(
CByteRange  &brTags,        // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

    // search for potential matches on tag name string, case-insensitive
    if(!brTemp.IsNull())
        if( 0 == _memicmp( brTemp.m_pb, pszAttributeName, cbAttributeName ))
            return TRUE;
    return FALSE;
    }


/*  ============================================================================
    CTemplate::GetTagName

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BYTE*
CTemplate::GetTagName
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

        // PREFIX: pszAttributeName could be NULL, though I don't think that can happen.
        Assert (pszAttributeName != NULL);

    while(TRUE)
        {
        // search for potential matches on tag name string, case-insensitive
        while(!brTemp.IsNull())
            {
            if(0 == _strnicmp((char*)brTemp.m_pb, pszAttributeName, cbAttributeName ))
                break;
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTemp.m_pb, cbAttributeName))
            goto Exit;

        // if we found a matching but invalid substring, advance beyond it so we can search again
        brTemp.Advance(cbAttributeName);

        // if we have exhausted search range, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;
        }

Exit:
    return brTemp.m_pb;

NotFound:
    return NULL;
    }

/*  ============================================================================
    CTemplate::GetTag

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BOOL
CTemplate::GetTag
(
CByteRange  &brTags,        // tags byte range
int         nIndex
)
    {
    CByteRange  brTemp      = brTags;                           // local byte range, so we don't change tags byte range
    int         nTIndex     = 0;

    while(TRUE)
        {
        // locate the start of a tag by skipping past the script tag "<%" and any leading white space
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '<' ||
                *brTemp.m_pb == '%' ||
                *brTemp.m_pb == '@' ||
                FWhiteSpace(*brTemp.m_pb))
                {
                brTemp.Advance(1);
                brTags.Advance(1);
                }
            else
                break;
            }



        // search for potential matches on tag name string, case-insensitive
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '=' || FWhiteSpace(*brTemp.m_pb))
                {
                nTIndex++;
                break;
                }
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTags.m_pb, DIFF(brTemp.m_pb - brTags.m_pb)))
            if(nTIndex >= nIndex)
                goto Exit;

        // position past named pair data and reset start and if end of byte range then
        // goto NotFound
        //
        while(!brTemp.IsNull() && !FWhiteSpace(*brTemp.m_pb))
            brTemp.Advance(1);

        if(brTemp.IsNull())
            goto NotFound;
        else
            brTags.Advance(DIFF(brTemp.m_pb - brTags.m_pb));
        }
Exit:
    return TRUE;

NotFound:
    return FALSE;
    }


/*  ============================================================================
    CTemplate::FTagHasValue

    Do tags include tknTag=tknValue?

    Returns
        TRUE if tags include value, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FTagHasValue
(
const CByteRange&   brTags,     // tags byte range to search
_TOKEN              tknTag,     // tag token
_TOKEN              tknValue    // value token
)
    {
    return (BrValueOfTag(brTags, tknTag)    // byte range of value
            .FMatchesSz(SZ_TOKEN(tknValue)));
    }

/*  =========================
    CTemplate::CopySzAdv

    Copies a string to a ptr and advances the ptr just beyond the copied string.

    Returns
        Nothing
    Side effects
        advances ptr beyond copied string
*/
void
CTemplate::CopySzAdv
(
char*   pchWrite,   // write location ptr
LPSTR   psz         // string to copy
)
    {
    strcpy(pchWrite, psz);
    pchWrite += strlen(psz);
    }

/*  ============================================================================
    CTemplate::ValidateSourceFiles

    Returns

    Side effects
        none
*/
BOOL CTemplate::ValidateSourceFiles
(
    CIsapiReqInfo* pIReq
)
{
    FILETIME    ftLastWriteTime;
    HRESULT     hr = S_OK;
    BOOL        fImpersonatedUser = FALSE;
    HANDLE      hVirtIncImpToken = NULL;
    HANDLE      hCurImpToken = NULL;

    for (UINT i=0;i<m_cFilemaps;i++)
    {
        fImpersonatedUser = FALSE;
        hVirtIncImpToken = NULL;
        hCurImpToken = NULL;

        //
        // If it target file is a UNC , then we need to Impersonate LoggedOnUser.
        //

        if (m_rgpFilemaps[i]->FHasUNCPath())
        {
            if (SUCCEEDED(pIReq->GetVirtualPathToken(m_rgpFilemaps[i]->m_szPathInfo, &hVirtIncImpToken)))
            {
                AspDoRevertHack(&hCurImpToken);

                fImpersonatedUser = ImpersonateLoggedOnUser(hVirtIncImpToken);

                if (!fImpersonatedUser)
                    AspUndoRevertHack(&hCurImpToken);
            }
        }

        hr = AspGetFileAttributes (m_rgpFilemaps[i]->m_szPathTranslated,
                                            m_rgpFilemaps[i]->m_hFile,
                                            &ftLastWriteTime);

        //
        // Undo impersonation if any.
        //
        if (fImpersonatedUser)
            AspUndoRevertHack(&hCurImpToken);

        if (hVirtIncImpToken)
            CloseHandle(hVirtIncImpToken);

        //
        // Check if the Files timestamp changed
        //
        if (SUCCEEDED(hr))
        {
		    if (CompareFileTime(&(m_rgpFilemaps[i]->m_ftLastWriteTime), &ftLastWriteTime) != 0)
		    {	
		        DBGPRINTF ((DBG_CONTEXT,"VALIDATE SOUCE FILES : Template is Invalid\n"));
		        return FALSE;
		    }
        }
        else
            return FALSE;
    }

    m_dwLastMonitored = GetTickCount();
    m_dwCacheTag = g_TemplateCache.GetCacheTag();
    m_fInCheck = FALSE;
    return TRUE;
}

/*  ============================================================================
    CTemplate::FNeedsValidation

    Returns

    Side effects
        none
*/

BOOL CTemplate::FNeedsValidation ( )
{
    if (m_fNeedsMonitoring)
	{
	    if (m_fInCheck == FALSE)
	    {
    	    if ( m_dwCacheTag != g_TemplateCache.GetCacheTag() && !g_fLazyContentPropDisabled)
    	    {
    	        m_fInCheck = TRUE;
    	        return TRUE;
    	    }

            BOOL bRet = CheckTTLTimingWindow (m_dwLastMonitored, g_dwFileMonitoringTimeoutSecs);
    	    if (bRet)
    	        m_fInCheck=TRUE;
    	
    	    return bRet;
	    }
	}
    return FALSE;
}

/*  ============================================================================
    CTemplate::CheckTTLTimingWindow
    Checks if the current time is withing Timeout seconds from the dwLastMonitored timestamp.
    If it is within the window it returns false. And if its outside the timeing window then it will return TRUE

    Returns
        TRUE = Current Time is beyond TTL (timeoutsecs) from lastmod time.
        FALSE = Current Time is within TTL (timeoutsecs) of lastmod time.

    Side effects
        none
*/


BOOL CTemplate::CheckTTLTimingWindow(DWORD dwLastMonitored, DWORD timeoutSecs)
{
    BOOL bRet = FALSE;
    DWORD currentTime= GetTickCount();

    if ( currentTime > (dwLastMonitored + (timeoutSecs *1000)) || currentTime < dwLastMonitored)
    {
        // This could also be a false Positive that will last just for a couple of minutes
        // around the 47 day period when getTickCount wraps around.
        if (((dwLastMonitored +(timeoutSecs *1000)) <  dwLastMonitored) &&
                (currentTime > dwLastMonitored))
        {
            // Found that tiny-tiny case where we would get a false positive.
            bRet = FALSE;
        }

        // This file could not have been checked in the last dwTimeoutSecs time period.
        bRet = TRUE;
    }
    return bRet;
}

	
/*  ============================================================================
    CTemplate::FVbsComment
    Determines whether a script line is a VBS comment.
    NOTE caller must ensure that brLine is non-blank and has no leading white space

    Returns
        TRUE if the line is a VBS comment, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FVbsComment(CByteRange& brLine)
    {
    // CONSIDER: SCRIPTLANG generic comment token
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentSQuote), CCH_TOKEN(CTokenList::tknVBSCommentSQuote)))
        return TRUE;
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentRem), CCH_TOKEN(CTokenList::tknVBSCommentRem)))
        return TRUE;

    return FALSE;
    }

/*  ============================================================================
    CTemplate::FExpression

    Determines whether a script line is an expression, and if so returns
    just the expression in brLine.
    NOTE caller must ensure that brLine has no leading white space

    Returns
        TRUE if the line is an expression, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FExpression(CByteRange& brLine)
    {
        // may be whitespace (other languages besides VB & JScript will have whitespace)
        char *pchLine = reinterpret_cast<char *>(brLine.m_pb);
        int cchLine = brLine.m_cb;

        while (cchLine > 0 && FWhiteSpace(*pchLine))
                {
                --cchLine;
                ++pchLine;
                }

    // if line starts with =, it is an expression: bypass =, left-trim whitespace and return true
    if(cchLine > 0 && *pchLine == '=')
        {
        brLine.Advance(1 + DIFF(reinterpret_cast<BYTE *>(pchLine) - brLine.m_pb));  // OK to advance past whitespace now.
        LTrimWhiteSpace(brLine);
        return TRUE;
        }

    // else return false
    return FALSE;
    }

/**
 **     In the following function names:
 **         'Adv' == 'advance offset after writing'
 **/

/*  ============================================================================
    CTemplate::WriteOffsetToOffset

    Writes a offset-to-offset offset (0 if no blocks) into header,
    and advances header offset and offset-to-offset.

    Returns:
        Nothing.
    Side effects:
        Advances offsets.
*/
void
CTemplate::WriteOffsetToOffset
(
USHORT  cBlocks,            // count of blocks
UINT*   pcbHeaderOffset,    // ptr to header offset value
UINT*   pcbOffsetToOffset   // ptr to offset-to-offset value
)
    {
    // if blocks of this type, write offset to first of them into header;
    // if no blocks of this type, write 0 into header
    WriteLongAdv((cBlocks > 0) ? *pcbOffsetToOffset : 0, pcbHeaderOffset);

    // advance offset-to-offset offset
    *pcbOffsetToOffset += cBlocks * sizeof(ULONG);
    }

/*  ============================================================================
    CTemplate::WriteSzAsBytesAdv

    Writes a null-terminated string as bytes, i.e. without its null terminator
    and advances offset

    Returns:
        Nothing.
    Side effects:
        Advances offset.
*/
void
CTemplate::WriteSzAsBytesAdv
(
LPCSTR  szSource,       // source string
UINT*   pcbDataOffset   // ptr to offset value
)
    {
    if((szSource == NULL) || (*szSource == '\0'))
        return;
    MemCpyAdv(pcbDataOffset, (void*) szSource, strlen(szSource));
    }

/*  ============================================================================
    CTemplate::WriteByteRangeAdv

    Writes a byte range to memory at template offset location *pcbDataOffset and, optionally,
    writes a ptr to the written data at template offset location *pcbPtrOffset
    (pass *pcbPtrOffset == 0 to avoid this)

    fWriteAsBsz == FALSE -->    write only byte range's data
    fWriteAsBsz == TRUE  -->    write length, followed by data, followed by NULL
                                NOTE bsz == length-prefixed, null-terminated string

    Returns:
        Nothing.
    Side effects:
        Advances offset(s).
*/
void
CTemplate::WriteByteRangeAdv
(
CByteRange& brSource,       // source data
BOOLB       fWriteAsBsz,    // write as bsz?
UINT*       pcbDataOffset,  // offset where data will be written
UINT*       pcbPtrOffset    // offset where ptr will be written
)
    {
    // bail if source is empty
    if(brSource.IsNull())
        return;

    // If writing as a bsz, write length prefix
    if(fWriteAsBsz)
        WriteLongAdv(brSource.m_cb, pcbDataOffset);

    // Write data
    MemCpyAdv(pcbDataOffset, brSource.m_pb, brSource.m_cb);

    // If writing as a bsz, write null terminator and advance target ptr
    if(fWriteAsBsz)
        MemCpyAdv(pcbDataOffset, SZ_NULL, 1);

    // If caller passed a non-zero ptr offset, write offset to data there
    if(*pcbPtrOffset > 0)
        {
        if(fWriteAsBsz)
            /* if writing as a bsz ...
                offset to start of data == current data offset
                                          - null terminator
                                          - data length
                                          - sizeof length prefix
            */
            WriteLongAdv(*pcbDataOffset - 1 - brSource.m_cb - sizeof(brSource.m_cb), pcbPtrOffset);
        else
            // else, offset to start of data == current data offset - data length
            WriteLongAdv(*pcbDataOffset - brSource.m_cb, pcbPtrOffset);
        }
    }

/*===================================================================
    CTemplate::MemCpyAdv

    Copies from a memory location to a template offset location,
    and advances offset.

    Returns:
        Nothing.
    Side effects:
        Advances offset.
        Re-allocates memory if required.
*/
void
CTemplate::MemCpyAdv
(
UINT*   pcbOffset,  // ptr to offset value
void*   pbSource,   // ptr to source
ULONG   cbSource,   // length of source
UINT    cbByteAlign // align bytes on short/long/dword boundary?
)
    {
    // byte-align offset location before write, if specified by caller
    if(cbByteAlign > 0)
        ByteAlignOffset(pcbOffset, cbByteAlign);

    // calc number of bytes by which to grow allocated template memory:
    // if projected reach exceeds current reach, we need to grow by the difference;
    // else, no need to grow
    if((*pcbOffset + cbSource) > m_cbTemplate)
        {
        // Reallocate space for storing local data - we grab twice what we had before
        // or twice current growth requirement, whichever is more
        m_cbTemplate = 2 * max(m_cbTemplate, (*pcbOffset + cbSource) - m_cbTemplate);
        if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeReAlloc(m_pbStart, m_cbTemplate)))
            THROW(E_OUTOFMEMORY);
        }

    // copy source to template offset location
    memcpy(m_pbStart + *pcbOffset, pbSource, cbSource);
    // advance offset location
    *pcbOffset += cbSource;
    }

/*  ============================================================================
    CTemplate::GetAddress
    Returns a ptr to the i-th object of type tcomp
*/
BYTE*
CTemplate::GetAddress
(
TEMPLATE_COMPONENT  tcomp,
USHORT              i
)
    {
    DWORD*  pdwBase;

    Assert(NULL != m_pbStart);

    // refer to CTemplate::WriteTemplate comments for the structure of what this is dealing with

    pdwBase = (DWORD*)(m_pbStart + (C_COUNTS_IN_HEADER * sizeof(USHORT)));

    // tcomp types are ptr-to-ptrs
    DWORD* pdwTcompBase = (DWORD *) (m_pbStart + pdwBase[tcomp]);

    return m_pbStart + pdwTcompBase[i];
    }




/*  ============================================================================
    CTemplate::AppendSourceInfo
    Appends a source line number for the current target line
    NOTE if caller passes null source ptr, we append prev source line number + 1

    Returns
        Nothing
    Side effects
        allocates memory first time thru; may realloc
*/
void
CTemplate::AppendSourceInfo
(
USHORT      idEngine,            // script engine id
CFileMap*   pfilemap,            // ptr to source file map
BYTE*       pbSource,            // ptr to current location in source file
ULONG       cbSourceOffset,      // byte offset of line in source file
ULONG           cbScriptBlockOffset, // pointer to start of script text
ULONG       cbTargetOffset,      // character offset of line in target file
ULONG       cchSourceText,       // # of characters in source text
BOOL        fIsHTML              // TRUE if manufactured line
)
    {
    UINT                i;                  // loop index
    CSourceInfo         si;                 // temporary CSourceInfo structure
    vector<CSourceInfo> *prgSourceInfos;    // pointer to line mapping table for the engine
    ULONG               cchSourceOffset = 0;// cch corresponding to cbSourceOffset
    HRESULT             hr = S_OK;

    // if arrays are not yet allocated, allocate them
    if (m_rgrgSourceInfos == NULL)
        {
        // transfer count of script engines from workstore to template
        m_cScriptEngines = m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa);

        // one source-info array per engine
        if ((m_rgrgSourceInfos = new vector<CSourceInfo>[m_cScriptEngines]) == NULL)
            THROW (E_OUTOFMEMORY);
        }

    // new script engine must be allocated in IdEngineFromBr (way upstream of this point),
    // so we assert that current engine must already be covered
    Assert(idEngine < m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa));

    /*  set current target line's source line number (SLN):
        a) if caller passed a source ptr, calc SLN from the source ptr;
        b) else if caller passed a filemap ptr, set SLN to prev target line's SLN plus one;
        c) else set SLN to 0

        semantics:
        a) we have a source file location, but must calc a line # for that location
        b) caller tells us (by passing NULL source file location) that this target line
           immediately follows prev target line.  This is an optimization because
           SourceLineNumberFromPb is very slow.

        change:
            caller used to pass NULL filemap ptr that target line is 'manufactured'
            i.e. has no corresponding authored line in source file

            HOWEVER - now filemap ptr must NOT be NULL because 'manufactured' lines
            are also stored in the file map array
    */

    Assert (pfilemap != NULL);

    prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    if (pbSource == NULL)
        {
        if (prgSourceInfos->length() == 0)
            si.m_idLine = 1;
        else
            si.m_idLine = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_idLine + 1;
        }
    else
        si.m_idLine = SourceLineNumberFromPb(pfilemap, pbSource);

    // The EOF line does not have a source offset (caller passes -1 (UINT_MAX)).  For this case, no
    // DBCS calculations etc. should be done.  (set cchSourceOffset to UINT_MAX).
    if (cbSourceOffset == UINT_MAX)
        cchSourceOffset = UINT_MAX;
    else
        {
        // BUG 80901: Source offset needs to point to the beginning of leading white space on the line
        //            Adjust source length by one as we decrement source offset
        // Note: whitepsace is never trailing byte, so loop will work with DBCS encoded character sets
        while (cbSourceOffset > 0 && strchr(" \t\v\a\f", pfilemap->m_pbStartOfFile[cbSourceOffset - 1]))
            {
            --cbSourceOffset;
            ++cchSourceText;
            }

        // BUG 95859
        // If the cursor is on the opening token of a script block (the "<%" part of a line), the
        // BP is set in the previous HTML, not in the script block, as is desired.
        //
        // To correct this, if we are in a script block, scan back two characters, see if it is the open
        // token.  If it is, set the offset back two, and add two to the length.
        //
        if (!fIsHTML)
            {
            // Skip whitespace (including newlines -- the previous step did not skip newlines)
            //
            ULONG cbOpen = cbSourceOffset;
            while (cbOpen > 0 && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbOpen - 1]))
                --cbOpen;

            if (cbOpen >= 2 && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbOpen - 2]), "<%", 2) == 0)
                {
                cbOpen -= 2;
                cchSourceText += cbSourceOffset - cbOpen;
                cbSourceOffset = cbOpen;
                }

            // Look for trailing "%>" in this snippet, and if it exists then include the end delimiter in
            // the length.  NOTE: No DBCS awareness needed here - if we find a lead byte we just get out
            // of the loop.  We are looking for <whitespace>*"%>" which is totally SBCS chars.
            //
            ULONG cbClose = cbSourceOffset + cchSourceText;
            ULONG cbFile = pfilemap->GetSize();
            while (cbClose < cbFile && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbClose]))
                ++cbClose;

            if (cbClose < cbFile && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbClose]), "%>", 2) == 0)
                cchSourceText += cbClose - (cbSourceOffset + cchSourceText) + 2;
            }

        // BUG 82222, 85584
        // Compiler marks HTML segments starting with the newline on the previous line
        // if the line ends with %>.
        //
        // This screws up the debugger, becasue when you press <F9>, the pointer is placed
        // on the line above when it should point to the start of the whitespace on the next line.
        if (fIsHTML)
            {
            UINT cbEOF = pfilemap->GetSize(), cbRover = cbSourceOffset;

            // Skip initial whitespace
            while (cbRover < cbEOF && strchr(" \t\a\f", pfilemap->m_pbStartOfFile[cbRover]))
                ++cbRover;

            // If what's left is a CR/LF pair, then advance cbSourceOffset to next line
            BOOL fCR = FALSE, fLF = FALSE;
            if (cbRover < cbEOF && strchr("\r\n", pfilemap->m_pbStartOfFile[cbRover]))
                {
                fCR = pfilemap->m_pbStartOfFile[cbRover] == '\r';
                fLF = pfilemap->m_pbStartOfFile[cbRover] == '\n';

                ++cbRover;
                Assert (fCR || fLF);
                }

            // we allow either <CR>, <LF>, <CR><LF>, or <LF><CR> to terminate a line,
            // so look for its opposite terminator if one is found (but don't require it)

            if (fCR && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\n')
                ++cbRover;

            if (fLF && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\r')
                ++cbRover;

            // OK, adjust cbSourceOffset now

            if ((fCR || fLF) && cbRover < cbEOF)
                {
                cchSourceText -= cbRover - cbSourceOffset;  // adjust # of chars to select
                cbSourceOffset = cbRover;
                }
            }

        // Now that we have the source offset, calculate its CCH by finding
        // the last time we sampled the value, then add that to the number
        // of DBCS characters from that point to the current offset.
        //
        // For the case of includes, it's possible offset already exists
        // (if the entry was previously generated by another instance of
        //  #include - therefore we have to search)

        COffsetInfo *pOffsetInfoLE, *pOffsetInfoGE;
        GetBracketingPair(
                        cbSourceOffset,                     // value to find
                        pfilemap->m_rgByte2DBCS.begin(),    // beginning of array
                        pfilemap->m_rgByte2DBCS.end(),      // end of array
                        CByteOffsetOrder(),                 // search for byte offset
                        &pOffsetInfoLE, &pOffsetInfoGE      // return values
                        );

        // If we find an equal match, don't insert any duplicates
        if (pOffsetInfoLE == NULL || pOffsetInfoLE->m_cbOffset < cbSourceOffset)
            {
            // if pOffsetInfoLE is NULL, it means that the array is empty -
            // create the mapping of offset 0 to offset 0.
            //
            // In the case of the first line of a file being an include directive,
            // the first executable line from the file may not start at offset zero,
            // so in this case we need to create this entry AND execute the next "if"
            // block.
            //
            if (pOffsetInfoLE == NULL)
                {
                COffsetInfo oiZero;         // ctor will init
                if (FAILED(hr = pfilemap->m_rgByte2DBCS.append(oiZero)))
                    THROW(hr);
                pOffsetInfoLE = pfilemap->m_rgByte2DBCS.begin();
                Assert (pOffsetInfoLE != NULL);
                }

            // If cbSourceOffset is zero, we handled it above
            if (cbSourceOffset != 0)
                {
                cchSourceOffset = pOffsetInfoLE->m_cchOffset +
                                    CharAdvDBCS
                                     (
                                     (WORD)m_wCodePage,
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + cbSourceOffset),
                                     INFINITE,
                                     NULL
                                     );

                // Now add the value to the table
                COffsetInfo oi;

                oi.m_cchOffset = cchSourceOffset;
                oi.m_cbOffset  = cbSourceOffset;

                if (pOffsetInfoGE == NULL)              // No offset greater
                    hr = pfilemap->m_rgByte2DBCS.append(oi);
                else
                    hr = pfilemap->m_rgByte2DBCS.insertAt(DIFF(pOffsetInfoGE - pfilemap->m_rgByte2DBCS.begin()), oi);

                if (FAILED(hr))
                    THROW(hr);
                }
            }
        else
            {
            // If we're not adding anything for the table, Assert it's because there's
            // a duplicate item
            Assert (cbSourceOffset == pOffsetInfoLE->m_cbOffset);
            cchSourceOffset = pOffsetInfoLE->m_cchOffset;
            }
        }

        UINT cchTargetOffset = UINT_MAX;
        if (cbTargetOffset != UINT_MAX)
                {
                // ptr to start of script is:
                //           ptr start of template + offset to script    + size of script length
                LPSTR szScript = (LPSTR) m_pbStart + cbScriptBlockOffset;

                // Calculate cchTargetOffset (have the cb).  The cch is the number of characters since the
                // last cch calculated in the end of the array.
                //
                if (prgSourceInfos->length() > 0)
                        cchTargetOffset = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_cchTargetOffset;
                else
                        cchTargetOffset = 0;

                cchTargetOffset += CharAdvDBCS
                                                         (
                                                         (WORD) m_wCodePage,
                                                         &szScript[m_cbTargetOffsetPrevT],
                                                         &szScript[cbTargetOffset],
                                                         INFINITE,
                                                         NULL
                                                         );

                // Keeps track of offsets during compilation
                //
                m_cbTargetOffsetPrevT = cbTargetOffset;
                }

    // Store this record and move on.
    //
    si.m_pfilemap        = pfilemap;
    si.m_fIsHTML         = fIsHTML;
    si.m_cchSourceOffset = cchSourceOffset;
    si.m_cchTargetOffset = cchTargetOffset;
    si.m_cchSourceText   = cchSourceText;

    if (FAILED(prgSourceInfos->append(si)))
        THROW(hr);
    }

/*  ============================================================================
    CTemplate::SourceLineNumberFromPb
    Returns the starting source line number for the given source file location
*/
UINT
CTemplate::SourceLineNumberFromPb
(
CFileMap*   pfilemap,   // ptr to source file map
BYTE*       pbSource    // ptr to current location in source file
)
    {
    UINT        cSourceLines = 1;   // count of lines into source file
    CByteRange  brScan;             // byte range to scan for newlines
    CByteRange  brSOL;              // start-of-line ptr

    if(pbSource == NULL || pfilemap == NULL)
        return 0;

    // Determine if there was a state stored on this ASP script earlier. If yes, then restore state.
    // If the line being requested is prior to the saved state...Bail out and restart from the begining.
    if(m_pWorkStore->m_cPrevSourceLines &&
        (m_pWorkStore->m_pbPrevSource && (m_pWorkStore->m_pbPrevSource < pbSource)) &&
         (m_pWorkStore->m_hPrevFile && (pfilemap->m_hFile==m_pWorkStore->m_hPrevFile)))
    {
        // The file handles match:with means that we are evaluating the current file. Restore state.
        brScan.m_pb = m_pWorkStore->m_pbPrevSource;
        brScan.m_cb = max(DIFF(pbSource - brScan.m_pb), 0);
        cSourceLines = m_pWorkStore->m_cPrevSourceLines;
    }
    else
    {
        // set scan range to run from start-of-template to caller's ptr
        brScan.m_pb = pfilemap->m_pbStartOfFile;
        brScan.m_cb = max(DIFF(pbSource - brScan.m_pb), 0);
    }

    // get newlines in scan range
    brSOL = BrNewLine(brScan);

    while(!brSOL.IsNull())
    {
        // advance start-of-line ptr and scan byte range
        brScan.Advance(DIFF((brSOL.m_pb + brSOL.m_cb) - brScan.m_pb));

        // increment source line counter
        cSourceLines++;

        // find next newline
        brSOL = BrNewLine(brScan);
    }

    // Store the state for the next call.
    m_pWorkStore->m_pbPrevSource = pbSource;
    m_pWorkStore->m_cPrevSourceLines = cSourceLines;
    m_pWorkStore->m_hPrevFile = pfilemap->m_hFile;

    return cSourceLines;
    }

/*  ============================================================================
    CTemplate::RemoveFromIncFiles
    Removes this template from inc-files on which it depends

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveFromIncFiles
(
)
    {
    // NOTE we loop from 1 to count, since 0-th filemap is for main file
    for(UINT i = 1; i < m_cFilemaps; i++)
        {
        if(NULL != m_rgpFilemaps[i]->m_pIncFile)
            m_rgpFilemaps[i]->m_pIncFile->RemoveTemplate(this);
        }
    }

/*  ****************************************************************************
    IDebugDocumentProvider implementation
*/

/*  ============================================================================
    CTemplate::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CTemplate::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CTemplate::GetName
    Return the various names of a document.
*/

HRESULT CTemplate::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    TCHAR *szPathInfo = m_rgpFilemaps[0]->m_szPathInfo;
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Skip application path portion of the filename
        {
            // Make sure the template remembers the virtual path
            // from the same application (it could be different
            // if template is shared between two applications)
            //
            int cch = _tcslen(m_szApplnVirtPath);
            if (_tcsncicmp(szPathInfo, m_szApplnVirtPath, cch) == 0)
                szPathInfo += cch;

            // Strip leading '/'
            if (*szPathInfo == _T('/'))
                szPathInfo++;
#if UNICODE
            *pbstrName = SysAllocString(szPathInfo);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szPathInfo, 0, pbstrName, m_wCodePage);
#endif
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            STACK_BUFFER( tempName, MAX_PATH );

            int cbURLPrefix = DIFF(m_szApplnVirtPath - m_szApplnURL) * sizeof (TCHAR);
            if (!tempName.Resize(cbURLPrefix + (_tcslen(szPathInfo)*sizeof(TCHAR)) + sizeof(TCHAR))) {
                return E_OUTOFMEMORY;
            }

            TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

            memcpy(szURL, m_szApplnURL, cbURLPrefix);
            _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], szPathInfo);

#if UNICODE
            *pbstrName = SysAllocString(szURL);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szURL, 0, pbstrName, m_wCodePage);
#endif
        }

        default:
            return E_FAIL;
    }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CTemplate::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CTemplate::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, m_cChars will be equal to zero
     * (Since zero length files are not compiled, m_cChars == 0 means "size
     * is unknown", not "size is zero").
     */
    if (m_rgpFilemaps[0]->m_cChars == 0)
        {
        // Likely need to remap the file, then count
        BOOL fRemapTemplate = !m_rgpFilemaps[0]->FIsMapped();
        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->RemapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        m_rgpFilemaps[0]->CountChars((WORD)m_wCodePage);

        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->UnmapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        // let's hope client is not relying on # of lines - expensive to compute

        *pcChars = m_rgpFilemaps[0]->m_cChars;
        *pcLines = ULONG_MAX;
        }
    else
        {
        /* The last line in the line mapping array of each engine is the <<EOF>> line
         * for that engine.  Therefore, the # of lines is the largest <<EOF>> line
         * number - 1.  The EOF line always points into the main file, so there are no
         * include file glitches here.
         */
        ULONG cLinesMax = 0;
        for (UINT i = 0; i < m_cScriptEngines; ++i)
            {
            ULONG cLinesCurrentEngine = m_rgrgSourceInfos[0][m_rgrgSourceInfos[0].length() - 1].m_idLine - 1;
            if (cLinesCurrentEngine > cLinesMax)
                cLinesMax = cLinesCurrentEngine;
            }

        *pcLines = cLinesMax;
        *pcChars = m_rgpFilemaps[0]->m_cChars;
        }

    IF_DEBUG(SCRIPT_DEBUGGER) {
#if UNICODE
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#else
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#endif
    }

    return S_OK;
}

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CTemplate::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    From a line number, return the character offset of the beginning
*/
HRESULT CTemplate::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return GetPositionOfLine(m_rgpFilemaps[0], cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    From a character offset, return the line number and offset within the line
*/
HRESULT CTemplate::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return GetLineOfPosition(m_rgpFilemaps[0], cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CTemplate::GetText
    From a character offset and length, return the document text
*/
HRESULT CTemplate::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return m_rgpFilemaps[0]->GetText((WORD)m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CTemplate::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CTemplate::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CTemplateDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliTemplateDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CTemplate::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CTemplateDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CTemplate::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CTemplate::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CTemplate::AttachTo
    attach this to the debugger UI tree view.
*/
HRESULT CTemplate::AttachTo
(
CAppln *pAppln
)
    {
    if (!m_fDontAttach && pAppln->FDebuggable())
        {
        // If we are already attached to this application, then ignore 2nd request
        CDblLink *pNodeCurr = m_listDocNodes.PNext();
        while (pNodeCurr != &m_listDocNodes)
            {
            if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
                return S_OK;

            pNodeCurr = pNodeCurr->PNext();
            }

        // Create the node and store it in the linked list.
        HRESULT hr;
        IDebugApplicationNode *pDocRoot;
        CDocNodeElem *pDocNodeElem;

        // Create a document tree, showing the include file hierarchy
        if (FAILED(hr = CreateDocumentTree(m_rgpFilemaps[0], &pDocRoot)))
            return hr;

        if (FAILED(hr = pDocRoot->Attach(pAppln->PAppRoot())))
            return hr;

        if ((pDocNodeElem = new CDocNodeElem(pAppln, pDocRoot)) == NULL)
            return E_OUTOFMEMORY;

        pDocNodeElem->AppendTo(m_listDocNodes);
        pDocRoot->Release();
        m_fDebuggable = TRUE;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::DetachFrom
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::DetachFrom
(
CAppln *pAppln
)
    {
    // Enter the CS to prevent Detach() from detaching while we are scanning
    // the list (causes application ptr to be deleted twice if this occurs)
    DBG_ASSERT(m_fDebuggerDetachCSInited);
    EnterCriticalSection(&m_csDebuggerDetach);

    // Look for the node that has this application
    CDblLink *pNodeCurr = m_listDocNodes.PNext();
    while (pNodeCurr != &m_listDocNodes)
        {
        if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
            break;

        pNodeCurr = pNodeCurr->PNext();
        }

    // If not found (pNodeCurr points back to head), then fail
    if (pNodeCurr == &m_listDocNodes)
        {
        LeaveCriticalSection(&m_csDebuggerDetach);
        return E_FAIL;
        }

    // Detach the node by deleting the current element
    delete pNodeCurr;

    // Turn off "Debuggable" flag if last application is detached
    m_fDebuggable = !m_listDocNodes.FIsEmpty();

    // At this point CS not needed
    LeaveCriticalSection(&m_csDebuggerDetach);

    // If we have just removed ourselves from the last application,
    // then we call Detach(), to remove all cached script engines now.
    if (!m_fDebuggable)
         Detach();

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Detach
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::Detach
(
)
    {
    // Enter the CS to prevent DetachFrom() from detaching while we are clearing
    // the list (causes application ptr to be deleted twice if this occurs)
    if (m_fDebuggerDetachCSInited)
                EnterCriticalSection(&m_csDebuggerDetach);

    // Detach all nodes
    while (! m_listDocNodes.FIsEmpty())
        delete m_listDocNodes.PNext();

    // Done with CS
    if (m_fDebuggerDetachCSInited)
                LeaveCriticalSection(&m_csDebuggerDetach);

    // Since we are not debuggable now, remove any script engines we may
    // be holding on to.  If we are detaching from change notification
    // thread, queue engines to be released from debugger thread.
    //
    if (m_rgpDebugScripts)
        {
        Assert (g_dwDebugThreadId != 0);
        BOOL fCalledFromDebugActivity = GetCurrentThreadId() == g_dwDebugThreadId;

        for (UINT i = 0; i < m_cScriptEngines; i++)
            {
            CActiveScriptEngine *pEngine = m_rgpDebugScripts[i];
            if (pEngine)
                {
                if (fCalledFromDebugActivity)
                    {
                    pEngine->FinalRelease();
                    }
                else
                    {
                    g_ApplnMgr.AddEngine(pEngine);
                    pEngine->Release();
                    }
                }
            }
        delete[] m_rgpDebugScripts;
        m_rgpDebugScripts = NULL;
        }

    m_fDebuggable = FALSE;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::CreateDocumentTree
    Traverse the tree that we have embedded in the filemap structures,
    and use it to create the include file structure
*/
HRESULT CTemplate::CreateDocumentTree
(
CFileMap *pfilemapRoot,
IDebugApplicationNode **ppDocRoot
)
    {
    IDebugApplicationNode *pDocNode;
    HRESULT hr = S_OK;

    if (pfilemapRoot == NULL || ppDocRoot == NULL)
        return E_POINTER;

    // Create the root node
    if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocRoot)))
        return hr;

    // From the filemap information, match it up with the correct provider
    //  "This" is the provider for the root document, others come from Inc file cache
    if (pfilemapRoot == m_rgpFilemaps[0])
        {
        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(this)))
            return hr;
        }
    else
        {
        CIncFile *pIncFile;
        if (FAILED(hr = g_IncFileMap.GetIncFile(pfilemapRoot->m_szPathTranslated, &pIncFile)))
            return hr;

        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(pIncFile)))
            return hr;

        // SetDocumentProvider AddRef'ed
        pIncFile->Release();
        }

    // Create a node from all of the children and attach it to this node
    CFileMap *pfilemapChild = pfilemapRoot->m_pfilemapChild;
    while (pfilemapChild != NULL)
        {
        IDebugApplicationNode *pDocChild;
        if (FAILED(hr = CreateDocumentTree(pfilemapChild, &pDocChild)))
            return hr;

        if (FAILED(hr = pDocChild->Attach(*ppDocRoot)))
            return hr;

        pfilemapChild = pfilemapChild->m_fHasSibling? pfilemapChild->m_pfilemapSibling : NULL;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::End

    Place template in non-usable state (after this is called, last ref. should
    be the any currently executing scripts.  The count will naturally vanish
    as the scripts finish.  The template should never be recycled in cache after
    this call.)

    REF COUNTING NOTE:
        Since debugging client has a reference to the template, the template needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
ULONG
CTemplate::End
(
)
    {
    // Flag template as non-usable (for debugging)
    m_fIsValid = FALSE;

    Detach();

    if (!m_CPTextEvents.FIsEmpty() && g_pDebugApp != NULL)
        {
        IEnumConnections *pConnIterator;
        if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
            {
            CONNECTDATA ConnectData;
            while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
                {
                IDebugDocumentTextEvents *pTextEventSink;
                if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                    {
                    InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                    pTextEventSink->Release();
                    }
                ConnectData.pUnk->Release();
                }

            pConnIterator->Release();
            }
        }

    return Release();
    }

/*  ============================================================================
    CTemplate::NotifyDebuggerOnPageEvent
    Let debugger know about page start/end
*/
HRESULT
CTemplate::NotifyDebuggerOnPageEvent
(
BOOL fStart     // TRUE = StartPage, FALSE = EndPage
)
    {
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, 0, 0);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (g_pDebugApp)
        hr = InvokeDebuggerWithThreadSwitch
            (
            g_pDebugApp,
            fStart ? DEBUGGER_EVENT_ON_PAGEBEGIN : DEBUGGER_EVENT_ON_PAGEEND,
            static_cast<IUnknown *>(pDebugContext)
            );

    pDebugContext->Release();
    return hr;
    }

/*  ============================================================================
    CTemplate::ReleaseTypeLibs
    Release all typelibs collected from metadata
*/
void
CTemplate::ReleaseTypeLibs()
    {
    if (m_rgpTypeLibs.length() > 0)
        {
        for (UINT i = 0; i < m_rgpTypeLibs.length(); i++)
            {
            m_rgpTypeLibs[i]->Release();
            }

        m_rgpTypeLibs.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::WrapTypeLibs
    Wrap all typelibs collected from metadata into single IDispatch *
*/
void
CTemplate::WrapTypeLibs(CHitObj *pHitObj)
    {
    HRESULT hr = S_OK;

    Assert(m_pdispTypeLibWrapper == NULL);

    if (m_rgpTypeLibs.length() > 0)
        {
        hr = ::WrapTypeLibs
            (
            m_rgpTypeLibs.begin(),
            m_rgpTypeLibs.length(),
            &m_pdispTypeLibWrapper
            );

        ReleaseTypeLibs();
        }

    if (FAILED(hr))
        {
        m_pbErrorLocation = NULL;
        m_idErrMsg = IDE_TEMPLATE_WRAP_TYPELIB_FAILED;
        ProcessSpecificError(*(m_rgpFilemaps[0]), pHitObj);
        THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
        }
    }

/*  ============================================================================
    CTemplate::Release449
    Release all 449-echo-cookie objects collected from metadata
*/
void
CTemplate::Release449()
    {
    if (m_rgp449.length() > 0)
        {
        for (UINT i = 0; i < m_rgp449.length(); i++)
            {
            m_rgp449[i]->Release();
            }

        m_rgp449.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::Do449Processing
    Generate 449 response in cookie negotiations with IE when needed
*/
HRESULT
CTemplate::Do449Processing
(
CHitObj *pHitObj
)
    {
    if (m_rgp449.length() == 0 || pHitObj->F449Done())
        return S_OK;

    HRESULT hr = ::Do449Processing
        (
        pHitObj,
        m_rgp449.begin(),
        m_rgp449.length()
        );

    pHitObj->Set449Done();
    return hr;
    }
#if 0
/*  ============================================================================
    CTemplate::OutputDebugTables
    print the debugging data structures to the debug window
*/
void
CTemplate::OutputDebugTables()
    {
    unsigned        i, j;
    wchar_t         wszDebugLine[256];
    CWCharToMBCS    convTarget;
    CWCharToMBCS    convSource;

    // print line mapping table

    DBGPRINTF((DBG_CONTEXT, "\nEngine HTML? Line# SourceOffset Length TargetOffset TargetText__________ SourceText__________ File\n"));

    for (i = 0; i < m_cScriptEngines; ++i)
        for (j = 0; j < m_rgrgSourceInfos[i].length(); ++j)
            {
            wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1];
            CSourceInfo *pSourceInfo = &m_rgrgSourceInfos[i][j];

            // DON'T display sample script text on last line of each engine
            if (j == m_rgrgSourceInfos[i].length() - 1)
                {
                wszTargetText[0] = 0;
                wszSourceText[0] = 0;
                }
            else
                {
                // Get source & target text sample
                GetScriptSnippets(
                                pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
                                pSourceInfo->m_cchTargetOffset, i,
                                wszSourceText, wszTargetText
                                 );

                // Actually display each line
#if 0
#ifndef _NO_TRACING_
                convTarget.Init(wszTargetText);
                convSource.Init(wszSourceText);

                DBGINFO((DBG_CONTEXT,
                         "%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                         i,
                         pSourceInfo->m_fIsHTML? "Yes" : "No",
                         pSourceInfo->m_idLine,
                         pSourceInfo->m_cchSourceOffset,
                         pSourceInfo->m_cchSourceText,
                         pSourceInfo->m_cchTargetOffset,
                         convTarget.GetString(),
                         convSource.GetString(),
                         pSourceInfo->m_pfilemap->m_szPathTranslated));
#else
                CMBCSToWChar    convPath;
                convPath.Init(pSourceInfo->m_pfilemap->m_szPathTranslated);
                wsprintfW(
                        wszDebugLine,
                        L"%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                        i,
                        pSourceInfo->m_fIsHTML? L"Yes" : L"No",
                        pSourceInfo->m_idLine,
                        pSourceInfo->m_cchSourceOffset,
                        pSourceInfo->m_cchSourceText,
                        pSourceInfo->m_cchTargetOffset,
                        wszTargetText,
                        wszSourceText,
                        convPath.GetString());

                OutputDebugStringW(wszDebugLine);
#endif
#endif
            }
            }

        OutputDebugStringA("\n\n");

    for (i = 0; i < m_cFilemaps; ++i)
        {
        CFileMap *pFilemap = m_rgpFilemaps[i];

#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %S:\n", pFilemap->m_szPathTranslated));
#else
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %s:\n", pFilemap->m_szPathTranslated));
#endif
        DBGPRINTF((DBG_CONTEXT, "ByteOffset CharOffset\n"));

        for (COffsetInfo *pOffsetInfo = pFilemap->m_rgByte2DBCS.begin();
             pOffsetInfo < pFilemap->m_rgByte2DBCS.end();
             ++pOffsetInfo)
            DebugPrintf("%-10d %-10d\n", pOffsetInfo->m_cbOffset, pOffsetInfo->m_cchOffset);

        DBGPRINTF((DBG_CONTEXT, "\n\n"));
    }

    DBGPRINTF((DBG_CONTEXT, "Include File Hierarchy\n"));
    OutputIncludeHierarchy(m_rgpFilemaps[0], 0);
    DBGPRINTF((DBG_CONTEXT, "\n"));
}

/*  ============================================================================
    CTemplate::OutputIncludeHierarchy
    print the lineage information that we keep around for include files.
    Print all nodes on one level at the current indentation, then descend for
    nested includes.
*/

void
CTemplate::OutputIncludeHierarchy
(
CFileMap*   pfilemap,
int         cchIndent
)
    {
    TCHAR szDebugString[256], *pchEnd;

    for (;;)
        {
        pchEnd = szDebugString;
        for (int i = 0; i < cchIndent; ++i)
            *pchEnd++ = _T(' ');

        pchEnd = strcpyEx(pchEnd, pfilemap->m_szPathTranslated);
        *pchEnd++ = _T('\n');
        *pchEnd = _T('\0');

        DBGPRINTF((DBG_CONTEXT, szDebugString));

        // Print anything that this file includes
        if (pfilemap->m_pfilemapChild)
            OutputIncludeHierarchy(pfilemap->m_pfilemapChild, cchIndent + 3);

        // Stop when there are no more siblings on this level
        if (! pfilemap->m_fHasSibling)
            break;

        // Advance to next sibling
        pfilemap = pfilemap->m_pfilemapSibling;
        }
    }

/*  ============================================================================
    CTemplate::OutputScriptSnippets
    print some script from both the source offset & its corresponding target.
    Good way to visually see if the offset conversions are working.
*/

void
CTemplate::GetScriptSnippets
(
ULONG cchSourceOffset,
CFileMap *pFilemapSource,
ULONG cchTargetOffset,
ULONG idTargetEngine,
wchar_t *wszSourceText,
wchar_t *wszTargetText
)
    {
    // Get target text sample
    if (wszTargetText)
        {
        char *szEngineName;
        PROGLANG_ID *pProgLangID;
        const wchar_t *wszScriptText;

        GetScriptBlock(idTargetEngine, &szEngineName, &pProgLangID, &wszScriptText);
        wszScriptText += cchTargetOffset;
        int cch = wcslen(wszScriptText);
        wcsncpy(wszTargetText, wszScriptText, min(cch, SNIPPET_SIZE) + 1);
        wszTargetText[min(cch, SNIPPET_SIZE)] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszTargetText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }

    // Get source text sample
    if (wszSourceText)
        {
        ULONG cchMax = 0;
        pFilemapSource->GetText((WORD)m_wCodePage, cchSourceOffset, wszSourceText, NULL, &cchMax, SNIPPET_SIZE);
        wszSourceText[cchMax] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszSourceText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }
    }
#endif
/*  ============================================================================
    CTemplate::BuildPersistedDACL

    Builds a DACL based on the SECURITY_DESCRIPTOR already
    associated with the template.  The PersistedDACL is modified to include
    full access for administrators and delete access for everyone.
*/

HRESULT  CTemplate::BuildPersistedDACL(PACL  *ppRetDACL)
{
    HRESULT                     hr = S_OK;
    BOOL                        bDaclPresent;
    BOOL                        bDaclDefaulted;
    PACL                        pSrcDACL = NULL;
    EXPLICIT_ACCESS             ea;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    *ppRetDACL = NULL;

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    ea.grfAccessPermissions = SYNCHRONIZE | DELETE;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;

    if (m_rgpFilemaps[0]->m_pSecurityDescriptor == NULL) {
        return S_OK;
    }

    if (!AllocateAndInitializeSid(&WorldAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0,0,0,0,0,0,0,
                                  (PSID *)(&ea.Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if (!GetSecurityDescriptorDacl(m_rgpFilemaps[0]->m_pSecurityDescriptor,
                                   &bDaclPresent,
                                   &pSrcDACL,
                                   &bDaclDefaulted))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAcl(1,
                                   &ea,
                                   bDaclPresent ? pSrcDACL : NULL,
                                   ppRetDACL)) != ERROR_SUCCESS)

        hr = HRESULT_FROM_WIN32(hr);

    if (ea.Trustee.ptstrName)
        FreeSid(ea.Trustee.ptstrName);

    return hr;
}

/*  ============================================================================
    CTemplate::PersistData
    Attempts to write the contents of the template memory to disk.  Note that
    the memory isn't freed here but later when the template ref count falls to
    1 (indicating that the only reference to the template is the one that the
    cache has on it).
*/

HRESULT  CTemplate::PersistData(char    *pszTempFilePath)
{
    HRESULT                 hr = S_OK;
    DWORD                   winErr = 0;
    HANDLE                  hFile = NULL;
    DWORD                   dwWritten;
    HANDLE                  hImpersonationToken = NULL;
    HANDLE                  hThread;
    PACL                    pPersistDACL = NULL;

#if DBG_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT,
               "CTemplate::PersistData() enterred.\n\tTemplate is %s\n\tPersistTempName is %s\n",
               GetSourceFileName(),
               m_szPersistTempName ? m_szPersistTempName : "<none>"));
#endif

    //
    // if for some reason this template has been marked as invalid, then it is not persistable
    //
    if (m_fIsValid == FALSE)
    {
        hr = E_FAIL;
        goto end;
    }

    // check to see if we already have a persist temp name.  If a template moves
    // from the persisted cache back to the memory cache, then the persisted flag
    // will have been lifted but the cache name will remain as an optimization for
    // future persisting.

    if (m_szPersistTempName == NULL) {

        hThread = GetCurrentThread();

        if (OpenThreadToken( hThread,
                             TOKEN_READ | TOKEN_IMPERSONATE,
                             TRUE,
                             &hImpersonationToken )) {

           RevertToSelf();
        }

        // allocate memory for this temp path

        if (!(m_szPersistTempName = (LPSTR)CTemplate::LargeMalloc(MAX_PATH))) {
            hr = E_OUTOFMEMORY;
        }

        // create the temp file.  The location of the temp directory was passed
        // in as an argument.  The resulting tempfile name in m_szPersistTempName
        // will include this path.

        else if (GetTempFileNameA(pszTempFilePath,
                                 "ASPTemplate",
                                 0,
                                 m_szPersistTempName) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // build a security descriptor to use with this persisted file.  It is
        // comprised of the .asp's security descriptor plus a couple of DACLs
        // to allow administrators full access and everyone delete access.

        else if (FAILED(hr = BuildPersistedDACL(&pPersistDACL)));

        else if (pPersistDACL
                 && (winErr = SetNamedSecurityInfoA((LPSTR)m_szPersistTempName,
                                                    SE_FILE_OBJECT,
                                                    DACL_SECURITY_INFORMATION,
                                                    NULL,
                                                    NULL,
                                                    pPersistDACL,
                                                    NULL)))
            hr = HRESULT_FROM_WIN32(winErr);

        // create the file

        else if ((hFile = CreateFileA(m_szPersistTempName,
                                     GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // slam out the entire contents of the template memory to the file

        else if (WriteFile(hFile,
                           m_pbStart,
                           m_cbTemplate,
                           &dwWritten,
                           NULL) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // close

        else if (CloseHandle(hFile) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else {
            hFile = NULL;
        }
        if (FAILED(hr));

        // make sure that the entire amount was written out

        else if (dwWritten != m_cbTemplate) {
            hr = E_FAIL;
        }

        if (hImpersonationToken) {
            SetThreadToken(&hThread, hImpersonationToken);
            CloseHandle(hImpersonationToken);
        }
    }

    if (FAILED(hr));

    else {

        // if successfull, then note that the template is now persisted.
        // Do an AddRef and Release as a safe way to check to see if the
        // template memory can be freed.

        m_fIsPersisted = TRUE;
        AddRef();
        Release();
    }

    // if errors occurred, clean up any resources.

    if (hr != S_OK) {
        if (hFile)
            CloseHandle(hFile);
        if (m_szPersistTempName)
            CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }

    // free the persisted SECURITY_DESCRIPTOR if allocated

    if (pPersistDACL) {
        LocalFree(pPersistDACL);
    }

end:

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist Successful.  TempName is %s\n",
                   m_szPersistTempName));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::UnPersistData
    Restores the template memory from disk.
*/

HRESULT  CTemplate::UnPersistData()
{
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    DWORD       dwRead;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

#if DEB_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT,
               "CTemplate::UnPersistData() enterred.\n\tTemplate is %s\n\tTempName is %s\n",
               m_rgpFilemaps[0]->m_szPathTranslated,
               m_szPersistTempName));
#endif

    // check to see if the template is already loaded into memory.  If so, then
    // all this routine needs to do is lift the IsPersisted flag.

    if (m_pbStart != NULL) {
        m_fIsPersisted = FALSE;
        goto end;
    }

    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    // open the temp file for read

    if ((hFile = CreateFileA(m_szPersistTempName,
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // allocate the template memory

    else if (!(m_pbStart = (BYTE *)CTemplate::LargeMalloc(m_cbTemplate))) {
        hr = E_OUTOFMEMORY;
    }

    // read in the entire file

    else if (ReadFile(hFile,
                      m_pbStart,
                      m_cbTemplate,
                      &dwRead,
                      NULL) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // we're done with the file

    else if (CloseHandle(hFile) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else {
        hFile = NULL;
    }

    if (FAILED(hr));

    // check to make sure we got everything

    else if (m_cbTemplate != dwRead) {
        hr = E_FAIL;
    }
    else {

        // if not, pretend like this is no longer persisted.  Prevents errors
        // in the future.

        m_fIsPersisted = FALSE;
    }

    if (hr != S_OK) {

        // make sure that the file handle was cleaned up

        if (hFile)
            CloseHandle(hFile);
    }
end:

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist Successful\n"));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::PersistCleanup
    Cleans up the temp file and the memory holding the temp file name.
*/

HRESULT CTemplate::PersistCleanup()
{
    HRESULT     hr = S_OK;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

    if (m_szPersistTempName == NULL) {
        return (S_OK);
    }


    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    if (DeleteFileA(m_szPersistTempName) == 0) {
        hr = GetLastError();
    }
    else {
        m_fIsPersisted = FALSE;
        CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

    return hr;
}


/*  ============================================================================
    CTemplate::CreateTransServiceConfig
    Creates the ServicesConfig object for a transacted page
*/

HRESULT CTemplate::CreateTransServiceConfig(BOOL fEnableTracker)
{
    HRESULT                     hr;
    IServiceInheritanceConfig   *pIInheritConfig = NULL;
    IServiceTransactionConfig   *pITransConfig = NULL;
    IServiceTrackerConfig       *pITracker = NULL;

    // see if there is any reason to create the object...

    if ((fEnableTracker == FALSE) && (m_ttTransacted == ttUndefined)) {
        return S_OK;
    }

	hr = CoCreateInstance(CLSID_CServiceConfig,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IUnknown,
                          (void **)&m_pServicesConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not CCI ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceInheritanceConfig, (void **)&pIInheritConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IServiceInheritanceConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = pIInheritConfig->ContainingContextTreatment(CSC_Inherit);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set Inherit mode, hr = %#08x\n", hr));
		goto LCleanup;
    }

    if (m_ttTransacted != ttUndefined) {

        CSC_TransactionConfig   transConfig;

        switch (m_ttTransacted) {
            case ttNotSupported:
                transConfig = CSC_NoTransaction;
                break;
            case ttSupported:
                transConfig = CSC_IfContainerIsTransactional;
                break;
            case ttRequired:
                transConfig = CSC_CreateTransactionIfNecessary;
                break;
            case ttRequiresNew:
                transConfig = CSC_NewTransaction;
                break;
        }

        hr = m_pServicesConfig->QueryInterface(IID_IServiceTransactionConfig, (void **)&pITransConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IID_IServiceTransactionConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pITransConfig->ConfigureTransaction(transConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set transaction type, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }

    if (fEnableTracker) {
        hr = m_pServicesConfig->QueryInterface(IID_IServiceTrackerConfig, (void **)&pITracker);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IID_IServiceTrackerConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }
        LPWSTR  pwszAppURL;
        LPWSTR  pwszASPName;
#if UNICODE
        pwszAppURL = m_szApplnVirtPath;
        pwszASPName = GetSourceFileName(SOURCEPATHTYPE_VIRTUAL);
#else
        CMBCSToWChar    convAppln;
        CMBCSToWChar    convASPName;

        hr = convAppln.Init(m_szApplnVirtPath);
        if (FAILED(hr)) {
            goto LCleanup;
        }
        hr = convASPName.Init(GetSourceFileName(SOURCEPATHTYPE_VIRTUAL));
        if (FAILED(hr)) {
            goto LCleanup;
        }
        pwszAppURL = convAppln.GetString();
        pwszASPName = convASPName.GetString();
#endif
        pwszASPName += wcslen(pwszAppURL) + 1;

        hr = pITracker->TrackerConfig(CSC_UseTracker, pwszAppURL, pwszASPName);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set Inherit mode, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }
LCleanup:

    if (pIInheritConfig)
        pIInheritConfig->Release();

    if (pITransConfig)
        pITransConfig->Release();

    return hr;
}

/*  ****************************************************************************
    CIncFile member functions
*/

/*  ============================================================================
    CIncFile::CIncFile
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::CIncFile
(
)
: m_szIncFile(NULL),
  m_fCsInited(FALSE),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_cRefs(0)
    {   }

/*  ============================================================================
    CIncFile::Init
    Inits the CIncFile object

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::Init
(
const TCHAR* szIncFile   // file name
)
{
    HRESULT                     hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   fad;                // win32 file attributes data structure

    ErrInitCriticalSection(&m_csUpdate, hr);
    m_fCsInited = TRUE;

    if(NULL == (m_szIncFile = (LPTSTR) CTemplate::SmallMalloc((_tcslen(szIncFile) + 1)*sizeof(TCHAR)))) {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    _tcscpy(m_szIncFile, szIncFile);

    // init hash table element base class
    if(FAILED(hr = CLinkElem::Init(m_szIncFile, _tcslen(m_szIncFile)*sizeof(TCHAR))))
        goto LExit;

LExit:
    return hr;
}

/*  ============================================================================
    CIncFile::~CIncFile
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::~CIncFile
(
)
    {
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %S\n", m_szIncFile));
#else
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %s\n", m_szIncFile));
#endif
    Assert(m_cRefs == 0);
    SmallTemplateFreeNullify((void**) &m_szIncFile);
    if(m_fCsInited)
        DeleteCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::GetTemplate
    Get i'th template user from CIncFile

    Returns:
        NULL if "iTemplate" is out of range, m_rgpTemplates[iTemplate] otherwise

    Side effects:
        None
*/
CTemplate*
CIncFile::GetTemplate
(
int iTemplate
)
    {
    if (iTemplate < 0 || iTemplate >= (signed int) m_rgpTemplates.length())
        return NULL;

    else
        return m_rgpTemplates[iTemplate];
    }

/*  ============================================================================
    CIncFile::QueryInterface
    Provides QueryInterface implementation for CIncFile

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CIncFile::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CIncFile::AddRef
    Adds a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::AddRef()
    {
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
    }

/*  ============================================================================
    CIncFile::Release
    Releases a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::Release()
{
    LONG cRef = InterlockedDecrement(&m_cRefs);

    if (cRef == 0)
    {
        delete this;
    }

    return cRef;
}

/*  ****************************************************************************
    IDebugDocumentProvider implementation for includes
*/

/*  ============================================================================
    CIncFile::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CIncFile::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CIncFile::GetName
    Return the various names of a document.
*/

HRESULT CIncFile::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Use the name of the include file (char after last back-slash) converted to lower case.
        {
            TCHAR *szFilePart = _tcsrchr(m_szIncFile, _T('\\'));
            Assert (szFilePart != NULL);

#if UNICODE
            *pbstrName = SysAllocString(szFilePart + 1);
            if (*pbstrName == NULL) {
                return E_OUTOFMEMORY;
            }
#else
            if (FAILED(SysAllocStringFromSz(szFilePart + 1, 0, pbstrName, CP_ACP)))
                return E_FAIL;
#endif
            if (*pbstrName != NULL)
                _wcslwr(*pbstrName);
            return S_OK;
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            CTemplate::CFileMap *pFilemap = GetFilemap();
            if (pFilemap->FHasVirtPath()) {
                STACK_BUFFER( tempName, MAX_PATH );

                CTemplate *pTemplate = m_rgpTemplates[0];
                int cbURLPrefix = DIFF(pTemplate->m_szApplnVirtPath - pTemplate->m_szApplnURL)*sizeof(TCHAR);

                if (!tempName.Resize(cbURLPrefix + ((_tcslen(pFilemap->m_szPathInfo) + 1)*sizeof(TCHAR)))) {
                    return E_OUTOFMEMORY;
                }

                TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

                memcpy(szURL, pTemplate->m_szApplnURL, cbURLPrefix);
                _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], pFilemap->m_szPathInfo);
#if UNICODE
                *pbstrName = SysAllocString(szURL);
                if (*pbstrName == NULL) {
                    return (E_OUTOFMEMORY);
                }
                return S_OK;
#else
                return SysAllocStringFromSz(szURL, 0, pbstrName, pTemplate->m_wCodePage);
#endif
            }
            else {
                *pbstrName = NULL;
                return E_FAIL;
            }
        }

        default:
            return E_FAIL;
        }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CIncFile::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CIncFile::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    CTemplate::CFileMap *pfilemap = GetFilemap();

    *pcLines = ULONG_MAX;
    *pcChars = pfilemap->m_cChars;
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#else
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CIncFile::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetPositionOfLine
    From a line number, return the character offset of the beginning

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return m_rgpTemplates[0]->GetPositionOfLine(GetFilemap(), cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CIncFile::GetLineOfPosition
    From a character offset, return the line number and offset within the line

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return m_rgpTemplates[0]->GetLineOfPosition(GetFilemap(), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CIncFile::GetText
    From a character offset and length, return the document text
*/
HRESULT CIncFile::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return GetFilemap()->GetText((WORD)m_rgpTemplates[0]->m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CIncFile::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CIncFile::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CIncFileDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliIncFileDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CIncFile::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CIncFileDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CIncFile::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CIncFile::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CIncFile::GetFilemap
    Returns a CFileMap pointer for this include file.  (Note: There are several
    CFileMaps that may be used, corresponding to each template.  This function
    selects one of them.)

    Returns:
        Corresponding CFileMap
    Side effects:
        None
*/
CTemplate::CFileMap *
CIncFile::GetFilemap
(
)
    {
    // Get pointer to first template's filemaps
    CTemplate::CFileMap **ppFilemapInc = &m_rgpTemplates[0]->m_rgpFilemaps[1];
    BOOL fFoundInc = FALSE;

    // Look for the filemap whose name corresponds to this IncFile.  It had better exist
    // in all template filemaps.
    //    NOTE: Start searching at position 1, because position 0 is the template itself.
    //
    for (unsigned i = 1; i < m_rgpTemplates[0]->m_cFilemaps && !fFoundInc; ++i)
        if (_tcscmp(m_szIncFile, (*ppFilemapInc++)->m_szPathTranslated) == 0)
            fFoundInc = TRUE;

    Assert (fFoundInc);
    return ppFilemapInc[-1];
    }

/*  ============================================================================
    CIncFile::AddTemplate
    Adds a template to the list of templates that include this inc-file

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::AddTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // Add the template to the list only if it does not exist
    if (m_rgpTemplates.find(pTemplate) == -1)
        {
        if (FAILED(m_rgpTemplates.append(pTemplate)))
            {
            LeaveCriticalSection(&m_csUpdate);
            return E_OUTOFMEMORY;
            }

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                                DBGPRINTF((DBG_CONTEXT, "AddTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    return S_OK;
    }

/*  ============================================================================
    CIncFile::RemoveTemplate
    Removes a template from the template list

    Returns:
        Nothing
    Side effects:
        Compresses the removed template's ptr out of template ptrs array (see "back-copy", below)
        Decrements template count
*/
void
CIncFile::RemoveTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // find the template in list
    int i = m_rgpTemplates.find(pTemplate);

    // Remove the element (If we found it - possible that this is 2nd instance of #include and was previously removed)
    if (i != -1)
        {
        m_rgpTemplates.removeAt(i);

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                DBGPRINTF((DBG_CONTEXT, "RemoveTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::FlushTemplates
    Flushes all of this inc-file's templates from the global template cache

    Returns:
        TRUE if all templates flushed, FALSE if some left
    Side effects:
        None
*/
BOOL
CIncFile::FlushTemplates
(
)
    {
    /*  NOTE we have a cross-dependency with RemoveTemplate() because the following call chain
        occurs when an inc-file gets flushed:

            CIncFileMap::Flush
                CIncFile::FlushTemplates
                    CTemplateCacheManager::Flush
                        CTemplate::RemoveFromIncFiles
                            CIncFile::RemoveTemplate

        The problem is that RemoveTemplate() updates m_cTemplates and m_rgTemplates, so these members
        will not be stable during the loop within FlushTemplates.

        To get around this, we make a local copy of m_rgTemplates.
    */
    EnterCriticalSection(&m_csUpdate);

    STACK_BUFFER( tempTemplates, 128 );

    STACK_BUFFER( tempFile, MAX_PATH );

    UINT        cTemplates = m_rgpTemplates.length();

    if (!tempTemplates.Resize(cTemplates * sizeof(CTemplate*))) {

        // failed to get memory.  The best we can do is return FALSE to indicate
        // that not all templates where flushed.

        LeaveCriticalSection(&m_csUpdate);

        return FALSE;
    }

    CTemplate** rgpTemplates = static_cast<CTemplate**> (tempTemplates.QueryPtr());
    memcpy(rgpTemplates, m_rgpTemplates.vec(), sizeof(CTemplate *) * cTemplates);
    UINT cTemplatesFlushed = 0;

    for(UINT i = 0; i < cTemplates; i++)
        {
        // If the template is ready now, flush it
        if(rgpTemplates[i]->m_fReadyForUse && !(rgpTemplates[i]->m_fDontCache))
            {
            // bug 917: make a local copy of template file name, since the member gets freed part way through g_TemplateCache.Flush
            TCHAR*   szTemp = NULL;
            szTemp = rgpTemplates[i]->GetSourceFileName();
            if (szTemp)
                {

                if (!tempFile.Resize((_tcslen(szTemp) + 1)*sizeof(TCHAR))) {

                    // failed on this one.  Continue and try to flush as many
                    // as we can.
                    continue;
                }
                TCHAR *szTemplateFile = (TCHAR *)tempFile.QueryPtr();
                _tcscpy(szTemplateFile, szTemp);
                g_TemplateCache.Flush(szTemplateFile, MATCH_ALL_INSTANCE_IDS);
                cTemplatesFlushed++;
                }
            }

         // If the template was not ready, we don't flush. It will probably
         // pick up the current include file anyway
        }

    LeaveCriticalSection(&m_csUpdate);

    return (cTemplates == cTemplatesFlushed);
    }

/*  ============================================================================
    CIncFile::OnIncFileDecache

    Callback which we use to call onDestroy events in the debugger just before
    we are removed from the IncFile cache.

    REF COUNTING NOTE:
        Since debugging client has a reference to the IDebugDocument, the include needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
void
CIncFile::OnIncFileDecache
(
)
    {
    if (m_CPTextEvents.FIsEmpty() || g_pDebugApp == NULL)
        return;

    IEnumConnections *pConnIterator;
    if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
        {
        CONNECTDATA ConnectData;
        while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
            {
            IDebugDocumentTextEvents *pTextEventSink;
            if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                {
                InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                pTextEventSink->Release();
                }
            ConnectData.pUnk->Release();
            }

        pConnIterator->Release();
        }
    }

/*  ****************************************************************************
    CTemplate::CBuffer member functions
*/

/*  ============================================================================
    CTemplate::CBuffer::CBuffer
    Ctor
*/
CTemplate::CBuffer::CBuffer()
:
  m_pItems(NULL),
  m_cSlots(0),
  m_cItems(0),
  m_pbData(NULL),
  m_cbData(0),
  m_cbDataUsed(0)
    {
    }

/*  ============================================================================
    CTemplate::CBuffer::~CBuffer
    Dtor
*/
CTemplate::CBuffer::~CBuffer()
    {
    if(m_pItems)
        CTemplate::SmallFree(m_pItems);
    if(m_pbData)
        CTemplate::LargeFree(m_pbData);
    }

/*  ============================================================================
    CTemplate::CBuffer::Init
    Inits a CBuffer
*/
void
CTemplate::CBuffer::Init
(
USHORT cSlots,
ULONG cbData
)
    {
    m_cSlots = cSlots;
    m_cbData = cbData;

    // Allocate space for storing byte range items
    if(!(m_pItems = (CByteRange*) CTemplate::SmallMalloc(m_cSlots * sizeof(CByteRange))))
        THROW(E_OUTOFMEMORY);

    // Allocate space for storing local data, if there is any
    if(m_cbData > 0)
        {
        if(!(m_pbData = (BYTE*) CTemplate::LargeMalloc(m_cbData)))
            THROW(E_OUTOFMEMORY);
        }

    }

/*  ============================================================================
    CTemplate::CBuffer::Append
    Appends to a CBuffer
*/
void
CTemplate::CBuffer::Append
(
const CByteRange&   br,             // byte range to append
BOOL                fLocal,         // append local?
UINT                idSequence,     // segment sequence id
CFileMap*           pfilemap,
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // calc bytes required to store byte range; allow for length prefix and null if a local string
    ULONG cbRequired = (ULONG)(br.m_cb + (fLocalString ? sizeof(br.m_cb) + 1 : 0));

    // If caller passed a non-local zero-length byte range, no-op and return;
    // allows callers to ignore byte range size
    // NOTE we store empty local byte ranges - required by token list
    if(!fLocal && br.m_cb == 0)
        return;

    if(fLocal)
        {
        if((m_cbData - m_cbDataUsed) < cbRequired)
            {
            // Reallocate space for storing local data - we grab twice what we had before
            // or twice current requirement, whichever is more
            m_cbData = 2 * (m_cbData > cbRequired ? m_cbData : cbRequired);
            if(!(m_pbData = (BYTE*) CTemplate::LargeReAlloc(m_pbData, m_cbData)))
                THROW(E_OUTOFMEMORY);
            }

        // if appending as a local string, copy length-prefix to buffer
        if(fLocalString)
            {
            memcpy(m_pbData + m_cbDataUsed, &(br.m_cb), sizeof(br.m_cb));
            m_cbDataUsed += sizeof(br.m_cb);
            }

        // copy data to buffer
        memcpy(m_pbData + m_cbDataUsed, br.m_pb, br.m_cb);
        m_cbDataUsed += br.m_cb;

        // if appending as a local string, copy null terminator to buffer
        if(fLocalString)
            *(m_pbData + m_cbDataUsed++) = NULL;

        }

    if(m_cItems >= m_cSlots)
        {
        // Reallocate space for storing byte range items - we grab twice what we had before
        m_cSlots *= 2;
        if(!(m_pItems = (CByteRange*) CTemplate::SmallReAlloc(m_pItems, m_cSlots * sizeof(*m_pItems))))
            THROW(E_OUTOFMEMORY);
        }

    // Set the (new) last item to this byte range
    SetItem(m_cItems++, br, fLocal, idSequence, pfilemap, fLocalString);
    }

/*  ============================================================================
    CTemplate::CBuffer::GetItem
    Gets an item from a CBuffer, as a byte range

    Returns:
        Nothing

    Side effects:
        None
*/
void
CTemplate::CBuffer::GetItem
(
UINT        i,  // index of item
CByteRange& br  // byte range containing returned item (out-parameter)
)
    {
    Assert(i < m_cItems);

    // for local data, ptr is offset only; must add it to base ptr
    br.m_pb =  m_pItems[i].m_pb + (m_pItems[i].m_fLocal ? (DWORD_PTR) m_pbData : 0);

    br.m_cb = m_pItems[i].m_cb;
    br.m_fLocal = m_pItems[i].m_fLocal;
    br.m_idSequence = m_pItems[i].m_idSequence;
    br.m_pfilemap = m_pItems[i].m_pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::SetItem
    Sets a CBuffer item to a new value

    Returns
        Nothing
    Side effects
        Throws error on non-existent item index
*/
void
CTemplate::CBuffer::SetItem
(
UINT                i,
const CByteRange&   br,             // byte range to set item to
BOOL                fLocal,         // is item local in buffer?
UINT                idSequence,     // segment sequence id
CFileMap *          pfilemap,       // file where segment came from
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // If buffer item i does not exist, fail
    if(i >= m_cSlots)
        THROW(E_FAIL);

    // for local data, store ptr as offset only - avoids fixup after realloc
    // NOTE offset == data used offset - length of data - null terminator (if local string)
    m_pItems[i].m_pb = (fLocal
                        ? (BYTE*)(m_cbDataUsed - br.m_cb -
                            (fLocalString
                             ? sizeof(BYTE)
                             : 0
                            ))
                        : (BYTE*)br.m_pb);

    m_pItems[i].m_cb = br.m_cb;
    m_pItems[i].m_fLocal = fLocal;
    m_pItems[i].m_idSequence = idSequence;
    m_pItems[i].m_pfilemap = pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::PszLocal
    Gets i-th locally-buffered string within the buffer.

    Returns:
        Ptr to locally-buffered string; NULL if not found
    Side effects:
        None
*/
LPSTR
CTemplate::CBuffer::PszLocal
(
UINT i  // index of item to retrieve
)
    {
    CByteRange  br;

    GetItem(i, br);

    if(!br.m_fLocal)
        return NULL;

    return (LPSTR) br.m_pb;
    }

/*  ****************************************************************************
    CTemplate::CScriptStore member functions
*/

/*  ============================================================================
    CTemplate::CScriptStore::~CScriptStore
    Destructor - frees memory

    Returns:
        nothing
    Side effects:
        none
*/
CTemplate::CScriptStore::~CScriptStore()
    {
    UINT i;

    for(i = 0; i < m_cSegmentBuffers; i++)
        delete m_ppbufSegments[i];

    if(m_ppbufSegments != NULL)
        CTemplate::SmallFree(m_ppbufSegments);
    if(m_rgProgLangId != NULL)
        CTemplate::SmallFree(m_rgProgLangId);
    }

/*  ============================================================================
    CTemplate::CScriptStore::Init
    Inits the script store

    Returns:
        nothing
    Side effects:
        allocates memory
*/
HRESULT
CTemplate::CScriptStore::Init
(
LPCSTR szDefaultScriptLanguage,
CLSID *pCLSIDDefaultEngine
)
    {
    HRESULT hr = S_OK;
    UINT    i;
    CByteRange  brDefaultScriptLanguage;

        // Check for NULL pointers - can happen if Application has invalid default lang
        if (szDefaultScriptLanguage == NULL || pCLSIDDefaultEngine == NULL)
                return TYPE_E_ELEMENTNOTFOUND;

    /*  init segment buffers count based on:
        - two for default engine (one primary, one tagged)
        - one each for other engines (tagged only)
    */
    m_cSegmentBuffers = C_SCRIPTENGINESDEFAULT + 1;

    // init segments buffers
    if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallMalloc(m_cSegmentBuffers * sizeof(CBuffer*))))
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    for(i = 0; i < m_cSegmentBuffers; i++)
        {
        if(NULL == (m_ppbufSegments[i] = new CBuffer))
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        m_ppbufSegments[i]->Init((C_SCRIPTSEGMENTSDEFAULT), 0);
        }

    // Append default engine to script store
    brDefaultScriptLanguage.m_cb = strlen(szDefaultScriptLanguage);
    brDefaultScriptLanguage.m_pb = (unsigned char *)szDefaultScriptLanguage;
    hr = AppendEngine(brDefaultScriptLanguage, pCLSIDDefaultEngine, /* idSequence */ 0);

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendEngine
    Appends a script engine to the script store

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CTemplate::CScriptStore::AppendEngine
(
CByteRange&     brEngine,       // engine name
PROGLANG_ID*    pProgLangId,    // ptr to prog lang id - pass NULL to have this function get proglangid from registry
UINT            idSequence      // segment sequence id
)
    {
    HRESULT     hr = S_OK;
    USHORT      cEngines;   // count of engines

    TRY
        // if no engines yet, init engine names buffer
        if(CountPreliminaryEngines() == 0)
            m_bufEngineNames.Init(C_SCRIPTENGINESDEFAULT, 0);

        // Append engine name to buffer
        m_bufEngineNames.Append(brEngine, FALSE, idSequence, NULL);

    CATCH(hrException)
        hr = hrException;
        goto LExit;
    END_TRY

    Assert(CountPreliminaryEngines() >= 1);

    //  malloc or realloc prog lang ids array
    if((cEngines = CountPreliminaryEngines()) == 1)
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallMalloc(cEngines * sizeof(PROGLANG_ID));
    else
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallReAlloc(m_rgProgLangId, cEngines * sizeof(PROGLANG_ID));

    if(NULL == m_rgProgLangId)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    if(NULL == pProgLangId)
        // caller passed null progid ptr - get prog id from registry
        hr = GetProgLangId(brEngine, &(m_rgProgLangId[cEngines - 1]));
    else
        // caller passed non-null progid ptr - set prog id from it
        m_rgProgLangId[cEngines - 1] = *pProgLangId;

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::IdEngineFromBr
    Determines the id of a script engine from its engine name

    Returns:
        id of script engine whose name is passed in
    Side effects:
        appends a new script engine name to engine names buffer
*/
USHORT
CTemplate::CScriptStore::IdEngineFromBr
(
CByteRange& brEngine,   // engine name
UINT        idSequence  // segment sequence id
)
    {
    Assert(!brEngine.IsNull()); // NOTE we trap/error null engine name earlier

    USHORT cKnownEngines = CountPreliminaryEngines();

    // search existing names for a match; return id if found
    for(USHORT i = 0; i < cKnownEngines; i++)
        {
        Assert(m_bufEngineNames[i]);
        Assert(m_bufEngineNames[i]->m_pb);
        if(FByteRangesAreEqual(*(m_bufEngineNames[i]), brEngine))
            return i;
        }

    // if not found by name try to find by engine id
    // (some engines with different names share the same id, like J[ava]Script)

    if (cKnownEngines > 0)
        {
        PROGLANG_ID ProgLandId;

        // we will get the prog lang id again inside AppendEngine() but
        // because it's cached and this only happens when > 1 engine,  it's alright

        if (SUCCEEDED(GetProgLangId(brEngine, &ProgLandId)))
            {
            for(i = 0; i < cKnownEngines; i++)
                {
                // If matches don't append -- just return the index
                if (m_rgProgLangId[i] == ProgLandId)
                    return i;
                }
            }
        }

    /*  if we did not find engine among those already buffered
        - append engine to script store
        - realloc segment buffers array if necessary
        - return index of last engine (the one we just appended)
    */

    // append engine to script store
    HRESULT hr = AppendEngine(brEngine, NULL, idSequence);

    if(hr == TYPE_E_ELEMENTNOTFOUND)
        // if prog lang not found, throw bad prog lang error id
        THROW(IDE_TEMPLATE_BAD_PROGLANG);
    else if(FAILED(hr))
        // other failure: re-throw hresult
        THROW(hr);

    // realloc segment buffers array if necessary
    if(CountPreliminaryEngines() > (m_cSegmentBuffers - 1))
        {
        // increment count of segment buffers
        m_cSegmentBuffers++;
        Assert(CountPreliminaryEngines() == m_cSegmentBuffers - 1);

        // realloc array of ptrs
        if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallReAlloc(m_ppbufSegments, m_cSegmentBuffers * sizeof(CBuffer*))))
            THROW(E_OUTOFMEMORY);

        // allocate the new buffer
        if(NULL == (m_ppbufSegments[m_cSegmentBuffers - 1] = new CBuffer))
            THROW(E_OUTOFMEMORY);

        // init the new buffer
        m_ppbufSegments[m_cSegmentBuffers - 1]->Init(C_SCRIPTSEGMENTSDEFAULT, 0);
        }

    // return index of last engine (the one we just appended)
    return (CountPreliminaryEngines() - 1);

    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendScript
    Appends a script/engine pair to the store.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CScriptStore::AppendScript
(
CByteRange& brScript,   // script text
CByteRange& brEngine,   // script engine name
BOOLB       fPrimary,   // primary or tagged script?
UINT        idSequence, // segment sequence id
CFileMap*   pfilemapCurrent
)
    {
    USHORT  iBuffer;    // buffer id

    Assert(fPrimary || !brEngine.IsNull()); // NOTE we trap/error null engine name earlier
    Assert(m_bufEngineNames[0]);            // page's primary engine must be known by this point
    Assert(m_bufEngineNames[0]->m_pb);

    if(fPrimary)
        // if primary script (not tagged), buffer id is 0
        iBuffer = 0;
    else if((!fPrimary) && FByteRangesAreEqual(brEngine, /* bug 1008: primary script engine name */ *(m_bufEngineNames[0])))
        // if tagged script and engine is primary, buffer id is 1
        iBuffer = 1;
    else
        // else, buffer id is engine id plus 1
        iBuffer = IdEngineFromBr(brEngine, idSequence) + 1;

    // append script segment to iBuffer-th segments buffer
    m_ppbufSegments[iBuffer]->Append(brScript, FALSE, idSequence, pfilemapCurrent);
    }

/*  ****************************************************************************
    CTemplate::CObjectInfoStore member functions
*/
/*  ============================================================================
    CTemplate::CObjectInfoStore::~CObjectInfoStore
*/
CTemplate::CObjectInfoStore::~CObjectInfoStore
(
)
    {
    if(m_pObjectInfos)
        CTemplate::SmallFree(m_pObjectInfos);
    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::Init
    Inits the object-info store
*/
void
CTemplate::CObjectInfoStore::Init()
    {
    m_bufObjectNames.Init(C_OBJECTINFOS_DEFAULT, 0);

    // init object-infos array
    if(NULL == (m_pObjectInfos = (CObjectInfo*) CTemplate::SmallMalloc(m_bufObjectNames.CountSlots() * sizeof(CObjectInfo))))
        THROW(E_OUTOFMEMORY);

    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::AppendObject
    Appends an object-info to the object-info store
*/
void
CTemplate::CObjectInfoStore::AppendObject
(
CByteRange& brObjectName,
CLSID       clsid,
CompScope   scope,
CompModel   model,
UINT        idSequence
)
    {

    USHORT iObject = m_bufObjectNames.Count();
    if(iObject >= m_bufObjectNames.CountSlots())
        {
        // Reallocate space for storing object-infos - we grab twice what we had before
        // NOTE we keep no object count in CObjectInfoStore, but instead use count in object names buffer
        (m_pObjectInfos = (CObjectInfo*)CTemplate::SmallReAlloc(m_pObjectInfos,
                                                2 * m_bufObjectNames.CountSlots() * sizeof(CObjectInfo)));

                if (m_pObjectInfos == NULL)
                        THROW(E_OUTOFMEMORY);
        }

    m_pObjectInfos[iObject].m_clsid = clsid;
    m_pObjectInfos[iObject].m_scope = scope;
    m_pObjectInfos[iObject].m_model = model;

    m_bufObjectNames.Append(brObjectName, FALSE, idSequence, NULL);
    }

/*  ****************************************************************************
    CTemplate::CWorkStore member functions
*/

/*  ============================================================================
    CTemplate::CWorkStore::CWorkStore
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::CWorkStore
(
)
:
  m_idCurSequence(0),
  m_fPageCommandsExecuted(FALSE),
  m_fPageCommandsAllowed(TRUE),
  m_szWriteBlockOpen(g_szWriteBlockOpen),
  m_szWriteBlockClose(g_szWriteBlockClose),
  m_szWriteOpen(g_szWriteOpen),
  m_szWriteClose(g_szWriteClose),
  m_pbPrevSource(NULL),
  m_cPrevSourceLines(0),
  m_hPrevFile (NULL)
    {
        m_cchWriteBlockOpen = strlen (m_szWriteBlockOpen);
		m_cchWriteBlockClose = strlen(m_szWriteBlockClose);
		m_cchWriteOpen = strlen(m_szWriteOpen);		
		m_cchWriteClose = strlen(m_szWriteClose);
    }

/*  ============================================================================
    CTemplate::CWorkStore::~CWorkStore
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::~CWorkStore
(
)
    {
    /*  if language element ptrs are anything but their constant defaults or null,
        they must have been allocated during compilation - free them now
    */
    if(m_szWriteBlockOpen != g_szWriteBlockOpen  && m_szWriteBlockOpen != NULL)
        CTemplate::SmallFree(m_szWriteBlockOpen);

    if(m_szWriteBlockClose != g_szWriteBlockClose  && m_szWriteBlockClose != NULL)
        CTemplate::SmallFree(m_szWriteBlockClose);

    if(m_szWriteOpen != g_szWriteOpen  && m_szWriteOpen != NULL)
        CTemplate::SmallFree(m_szWriteOpen);

    if(m_szWriteClose != g_szWriteClose  && m_szWriteClose != NULL)
        CTemplate::SmallFree(m_szWriteClose);
    }



/*  ============================================================================
    CTemplate::CWorkStore::Init
    Inits the workstore

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CWorkStore::Init
(
)
    {
/*
        NOTE init we the scriptstore separately from rest of workstore
        because try-catch in CTemplate::Init() apparently doesn't work to detect
        bogus script engine name; we need to get an hr back instead.

    m_ScriptStore.Init(brDefaultEngine);
*/
    m_ObjectInfoStore.Init();
    m_bufHTMLSegments.Init(C_HTMLSEGMENTSDEFAULT, 0);
    }

/*  ============================================================================
    CTemplate::CWorkStore::CRequiredScriptEngines
    Returns the count of script engines in the script store that are required
    to run the template.

    NOTE this function is part of the fix for bug 933

    Returns:
        Count of non-empty script engines
    Side effects:
        None
*/
USHORT
CTemplate::CWorkStore::CRequiredScriptEngines
(
BOOL    fGlobalAsa  // bug 1394: is template global.asa?
)
    {
    USHORT  cPreliminaryEngines = m_ScriptStore.CountPreliminaryEngines();
    USHORT  cRequiredEngines =  0;

    for(USHORT i = 0; i < cPreliminaryEngines; i++)
        {
        if(FScriptEngineRequired(i, fGlobalAsa))
            cRequiredEngines++;
        }

    return cRequiredEngines;
    }

/*  ============================================================================
    CTemplate::CWorkStore::FScriptEngineRequired
    Is a given preliminary script engine required to run the template?

    NOTE this function is part of the fix for bug 933

    Returns:
        TRUE or FALSE
    Side effects:
        None
*/
BOOLB
CTemplate::CWorkStore::FScriptEngineRequired
(
USHORT  idEnginePrelim,
BOOL    fGlobalAsa      // bug 1394: is template global.asa?
)
    {
    if(idEnginePrelim == 0)
        return (                                                        // primary engine (id 0) required if
                    (m_ScriptStore.m_ppbufSegments[0]->Count() > 0)     // ... script buffer 0 has segments
                    || (m_ScriptStore.m_ppbufSegments[1]->Count() > 0)  // ... or script buffer 1 has segments
                    || ((m_bufHTMLSegments.Count() > 0) && !fGlobalAsa) // ... or html buffer has segments and (bug 1394) template is not global.asa
                );

    // non-primary engine required if script buffer id+1 has segments
    return (m_ScriptStore.m_ppbufSegments[idEnginePrelim + 1]->Count() > 0);
    }


/*  ****************************************************************************
    CTemplate::CFileMap member functions
*/

/*  ============================================================================
    CTemplate::CFileMap::CFileMap
    Constructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::CFileMap()
:
  m_szPathInfo(NULL),
  m_szPathTranslated(NULL),
  m_pfilemapSibling(NULL),
  m_pfilemapChild(NULL),
  m_hFile(NULL),
  m_hMap(NULL),
  m_pbStartOfFile(NULL),
  m_pIncFile(NULL),
  m_pSecurityDescriptor(NULL),
  m_dwSecDescSize(0),
  m_fIsUNCPath(FALSE),
  m_fIsEncryptedFile(FALSE),
  m_cChars(0),
  m_pDME(NULL),
  m_dwFileSize(0)
    {
    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;
    }

/*  ============================================================================
    CTemplate::CFileMap::~CFileMap
    Destructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::~CFileMap()
    {
    if (m_pDME)
        {
        m_pDME->Release();
        m_pDME = NULL;
        }
    if(m_szPathInfo != NULL)
        CTemplate::SmallFree(m_szPathInfo);
    if(m_szPathTranslated != NULL)
        CTemplate::SmallFree(m_szPathTranslated);
    if(m_pSecurityDescriptor != NULL)
        CTemplate::SmallFree(m_pSecurityDescriptor);
    if (m_pIncFile != NULL)
        m_pIncFile->Release();
    }

/*  ============================================================================
    CTemplate::CFileMap::MapFile
    Memory-maps a file.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.
*/
void
CTemplate::CFileMap::MapFile
(
LPCTSTR     szFileSpec,     // file spec for this file
LPCTSTR     szApplnPath,    // application path (in case its global.asa)
CFileMap*   pfilemapParent, // ptr to filemap of parent file
BOOL        fVirtual,       // is file spec virtual or relative?
CHitObj*    pHitObj,        // ptr to template's hit object
BOOL        fGlobalAsa      // is this file the global.asa file?
)
    {
    BOOL        fMustNormalize = TRUE;
    BOOL        fImpersonatedUser = FALSE;
    HANDLE      hVirtIncImpToken = NULL;
    HANDLE      hCurImpToken = NULL;

    Assert((pfilemapParent != NULL) || (pHitObj->PIReq() != NULL) || fGlobalAsa);

    /*  three possible cases:
        1) we are processing global.asa file
        2) we are processing the "main" .asp file
        3) we are processing an include file
    */
    if(fGlobalAsa)
    {
        // case 1) we are processing global.asa file
        Assert(pHitObj->GlobalAspPath());

        DWORD cchPathTranslated = _tcslen(pHitObj->GlobalAspPath());
        m_szPathTranslated = (TCHAR *)CTemplate::SmallMalloc((cchPathTranslated+1)*sizeof(TCHAR));
        if (!m_szPathTranslated)
            THROW(E_OUTOFMEMORY);
        _tcscpy(m_szPathTranslated, pHitObj->GlobalAspPath());

        //
        // In case of Global.asa copy ApplnMDPath to pathinfo. This is because when VBScript throws an exception for errors in global.asa to the eventlog.
        // it becomes impossible to determine which global.asa failed. For this reason, we copy the ApplnMDPath to PathInfo so that the nt log will contain
        // a pointer to the locatoin of the faulty global.asa
        //
        DWORD cchPathInfo = _tcslen(pHitObj->PIReq()->QueryPszApplnMDPath()) + 11; // 11 = /global.asa

        m_szPathInfo = (TCHAR *)CTemplate::SmallMalloc((cchPathInfo+1) * sizeof(TCHAR));
        if (!m_szPathInfo)
            THROW(E_OUTOFMEMORY);

        _tcscpy(strcpyEx(m_szPathInfo, pHitObj->PIReq()->QueryPszApplnMDPath()), _T("/global.asa"));

        // no need to normalize in this case, since global.asa path is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
    }
    else if(pfilemapParent == NULL)
    {
        // case 2) we are processing the "main" .asp file: get path-info and path-tran from ecb
        Assert(pHitObj->PIReq());

        TCHAR *szVirtPath = pHitObj->PSzCurrTemplateVirtPath();
        TCHAR *szPhysPath = pHitObj->PSzCurrTemplatePhysPath();

        m_szPathInfo       = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szVirtPath) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szPhysPath) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        _tcscpy(m_szPathInfo,       szVirtPath);
        _tcscpy(m_szPathTranslated, szPhysPath);

        // no need to normalize in this case, since ecb's path-tran is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
    }
    else
    {
        /*  case 3) we are processing an include file: resolve filespec into path-info and path-tran
            based on whether file was included with VIRTUAL tag or FILE tag
        */
        Assert(szFileSpec);

        // in this case, we don't know path lengths up front so we alloc the max and realloc below
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        STACK_BUFFER(tempPathT, (MAX_PATH+1)*sizeof(TCHAR) );

        if (!tempPathT.Resize((_tcslen(szFileSpec) + 1)*sizeof(TCHAR))) {
            THROW(E_OUTOFMEMORY);
        }

        LPTSTR szPathTranslatedT = (TCHAR *)tempPathT.QueryPtr();   // temp path-tran

        if(fVirtual) {
            DWORD   dwSzLength = tempPathT.QuerySize();  // length of path string buffer

			if (_tcslen(szFileSpec) > MAX_PATH)
				THROW(E_FAIL);
			
            // VIRTUAL: path-info is simply virtual filespec
            _tcscpy(m_szPathInfo, szFileSpec);

            // VIRTUAL: path-tran is translation of path-info
            _tcscpy(szPathTranslatedT, m_szPathInfo);

            if (!pHitObj->PIReq()->MapUrlToPath(szPathTranslatedT, &dwSzLength))
                THROW(E_FAIL);

            // Check the translated path for a UNC specified path . Ignore Hr
            HRESULT hr = S_OK;
            if (IsFileUNC (szPathTranslatedT, hr))
                {

                // if UNC, then ask WAM for the impersonation token for
                // this UNC VRoot.  Silently fail.

                if (SUCCEEDED(pHitObj->PIReq()->GetVirtualPathToken(szFileSpec,
                                                                    &hVirtIncImpToken))) {

                    // set the impersonation token and note that we did so
                    // NOTE - there is intentionally no error checking.  The
                    // assumption being that we are doing best effort at the
                    // impersonation because throwing an error here could be
                    // tricky for the user to interpret the problem.  However,
                    // if the impersonation fails, and ASP can still open the
                    // file (e.g. passthru authentication), then everyone's
                    // happy.

                   AspDoRevertHack(&hCurImpToken);

                   fImpersonatedUser = ImpersonateLoggedOnUser(hVirtIncImpToken);

                   if (!fImpersonatedUser)
                   {
                       AspUndoRevertHack(&hCurImpToken);
                   }
                }
            }

            m_fHasVirtPath = TRUE;
        }
        else
        {
            if (_tcslen(pfilemapParent->m_szPathInfo) >= MAX_PATH)
                THROW(E_FAIL);

            TCHAR szParentDir[MAX_PATH], *szT;
            _tcscpy(szParentDir, pfilemapParent->m_szPathInfo);

            //force null termination.
            szParentDir[MAX_PATH-1] = _T('\0');

            DWORD strlen_szParentDir = _tcslen(szParentDir);

            if ((szT = _tcsrchr(szParentDir, _T('/'))) != NULL)
            {
                *szT = _T('\0');
                strlen_szParentDir = (int)(szT - szParentDir);
            }

            // If we don't allow parent paths, we can save lots of time (Always have a valid virtual path)
            if (!pHitObj->QueryAppConfig()->fEnableParentPaths())
            {
                //int strlen_szParentDir = (int)(szT - szParentDir);
                if ((strlen_szParentDir + 1 + _tcslen(szFileSpec)) >= MAX_PATH)
                	THROW(E_FAIL);

                strcpyEx(strcpyEx(strcpyEx(m_szPathInfo, szParentDir), _T("/")), szFileSpec);
                m_fHasVirtPath = TRUE;
            }
            else
            {
                // NOTE: If we must translate ".." paths, there is no need to verify them (by remapping)
                //       because: If the file does not exist, that case will show up when the file is mapped
                //       If we ".." ourselves out of the vroot space, (out of the app or into another app)
                //          DotPathToPath will detect this.
                //
                if (DotPathToPath(m_szPathInfo, szFileSpec, szParentDir))
                    m_fHasVirtPath = TRUE;
                else
                {
                    GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &m_szPathInfo);
                    m_fHasVirtPath = FALSE;
                }

            }

            GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &szPathTranslatedT);
        }

        // bug 1214: get canonical path-tran, without . and ..
        // CONSIDER check for . or .. in name before calling GetFullPathName?  UNCs?  what else?
        GetFullPathName(
                        szPathTranslatedT,  // LPCSTR lpFileName,  // address of name of file to find path for
                        MAX_PATH + 1,       // DWORD nBufferLength, // size, in characters, of path buffer
                        m_szPathTranslated, // LPSTR lpBuffer,     // address of path buffer
                        NULL                // LPSTR *lpFilePart   // address of filename in path
                        );

        // realloc path strings to only use required memory (see note above)
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathInfo, (_tcslen(m_szPathInfo) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathTranslated, (_tcslen(m_szPathTranslated) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated) {

            if (fImpersonatedUser)
                AspUndoRevertHack(&hCurImpToken);
            if (hVirtIncImpToken)
                CloseHandle(hVirtIncImpToken);
            THROW(E_OUTOFMEMORY);
        }
    }

    // if required, normalize path-tran so that
    // a) cyclic include check can ignore case; b) inc-file cache lookups will work
    if(fMustNormalize)
        Normalize(m_szPathTranslated);

    Assert(IsNormalized(m_szPathTranslated));

    // Bug 99071: Attempt to open the file **BEFORE** we add it to the tree of file
    //            dependencies.  Otherwise if it fails to open, we will have
    //            dangling references.  Since FCyclicInclude depends on us adding
    //            to the tree, if it is cyclic, we need to unmap then.  Since that
    //            is a very uncommon error case, the extra overhead is probably OK
    //
    // RemapFile will throw if it fails. If the exception is that the source file is empty
    // and we are trying to process an include file, we will handle the exception here.
    // in all other cases, rethrow the exception. We do this so that an empty include file
    // will be harmless, but an empty primary file will fail.
    TRY

        RemapFile();

    CATCH(hrException)

        if (hrException != E_SOURCE_FILE_IS_EMPTY || pfilemapParent == NULL) {
            if (fImpersonatedUser)
                AspUndoRevertHack(&hCurImpToken);
            if (hVirtIncImpToken)
                CloseHandle(hVirtIncImpToken);
            THROW(hrException);
        }

    END_TRY

    if (fImpersonatedUser)
        AspUndoRevertHack(&hCurImpToken);
    if (hVirtIncImpToken)
        CloseHandle(hVirtIncImpToken);

    // Create the tree structure for this file
    if (pfilemapParent != NULL)
    {
        // See if this file is already included once on this level. (Don't show duplicates in the
        // debugger tree view)
        //
        BOOL fDuplicateExists = FALSE;
        CFileMap *pFilemap = pfilemapParent->m_pfilemapChild;
        while (pFilemap != NULL && !fDuplicateExists)
        {
            if (_tcscmp(pFilemap->m_szPathTranslated, m_szPathTranslated) == 0)
                fDuplicateExists = TRUE;

            pFilemap = pFilemap->m_fHasSibling? pFilemap->m_pfilemapSibling : NULL;
        }

        // If the include file is #include'd more than once, don't add it as a sibling.
        // Rather orphan the pfilemap and just set the parent pointer.
        //
        if (!fDuplicateExists)
        {
            if (pfilemapParent->m_pfilemapChild == NULL)
                pfilemapParent->m_pfilemapChild = this;
            else
                pfilemapParent->m_pfilemapChild->AddSibling(this);
        }
    }

    // in both of the above code paths, we are always added as the LAST child, (or we are an orphan node)
    // so it is safe to set the parent without calling SetParent()
    m_fHasSibling = FALSE; // Paranoia
    m_pfilemapParent = pfilemapParent;

    // hurl if this file is being included by itself (perhaps indirectly)
    if(FCyclicInclude(m_szPathTranslated)) {
        UnmapFile();
        THROW(IDE_TEMPLATE_CYCLIC_INCLUDE);
    }
}

/*  ============================================================================
    CTemplate::CFileMap::RemapFile
    map a file that was previously mapped.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.

    Does not decrypt EASPs on remapping. Caller must decrypt if required.  This
    function is called by the debugger, and the debugger does not allow access
    to decrypted files, so decryption is a waste of time.
*/
void
CTemplate::CFileMap::RemapFile
(
)
    {

    HRESULT hr = S_OK;
    if (FIsMapped())
        return;

    // Limit the size of the file that can be opened by ASP to MAX_PATH until we remove all assumptions ASP
    // makes about MAX_PATH
    if (_tcslen(m_szPathTranslated) >= MAX_PATH)
        THROW (E_COULDNT_OPEN_SOURCE_FILE);

    //
    // Check if the File is on a UNC.
    // IGNORE the HRESULT value as whatever it was will/should also show up in the call to ASPCreateFile (MakePathCanonicalizationProof)
    //
    m_fIsUNCPath = IsFileUNC(m_szPathTranslated, hr);

    if(INVALID_HANDLE_VALUE == (m_hFile =
                                AspCreateFile(
                                            m_szPathTranslated,     // file name
                                            GENERIC_READ,           // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            OPEN_EXISTING,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        DWORD dwLastError = GetLastError();
        if(dwLastError == ERROR_ACCESS_DENIED)
            {
            // typically, we end up here if the user has no permissions on the file
            // bug 1007: however, we also end up here if the user gave us a directory name, instead of a file name

            WIN32_FILE_ATTRIBUTE_DATA fad;
            if(GetFileAttributesEx(m_szPathTranslated, GetFileExInfoStandard, &fad) == 0)
                {
                // bug 1495: file in a secured directory will end up here - we need to re-GetLastError to see if access is denied
                dwLastError = GetLastError();
                if(dwLastError == ERROR_ACCESS_DENIED)
                    {
                    THROW(E_USER_LACKS_PERMISSIONS);
                    }
                // GetFileAttributes call failed; don't know why
                THROW(E_FAIL);
                }
            else if(FILE_ATTRIBUTE_DIRECTORY & fad.dwFileAttributes)
                {
                // bug 1007: the user gave us a directory name
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %S because it is a directory.\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %s because it is a directory.\n", m_szPathTranslated));
#endif
                THROW(E_COULDNT_OPEN_SOURCE_FILE);
                }
            else
                {
                THROW(E_USER_LACKS_PERMISSIONS);
                }
            }
        else
                        {
#if DBG
			char szError[128];
			if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
								NULL,
								dwLastError,
								0L,			// lang ID - defaults to LANG_NEUTRAL
								szError,
								sizeof szError,
								NULL) )
				{
				sprintf(szError, "%d", dwLastError);
				}
#if UNICODE
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %S\n", m_szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %s\n", m_szPathTranslated));
#endif
            DBGPRINTF((DBG_CONTEXT, "  The error returned was: %s\n", szError));
#endif
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
            }
        }

    //
    // Get LastWriteTime, FileSize and its Attributes
    //
    DWORD   dwFileAttributes;
    if (FAILED(AspGetFileAttributes(m_szPathTranslated, m_hFile, &m_ftLastWriteTime, &m_dwFileSize, &dwFileAttributes)))
    {
        DBGPRINTF((DBG_CONTEXT,"ASP could not retrieve file attributes even though it could open the file.\n"));
        // THROW Server 500 Error
        // Quick and dirty way: THROW E_FAIL
        // Correct way: Call Handle500Error/HandleError with all parameters and corresponding string.
        THROW (E_FAIL);
    }

    //
    // Does the File have the Encrypted attribute bit set
    //
    m_fIsEncryptedFile = (dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED ) ? TRUE : FALSE;

    // get file's security descriptor (only if not UNC or encrypted)
    if (!m_fIsUNCPath)
    {
        if (!GetSecurityDescriptor())
         THROW(E_COULDNT_OPEN_SOURCE_FILE);
    }

    // map the file
    if(NULL == (m_hMap =
                CreateFileMapping(
                                    m_hFile,        // handle to file to map
                                    NULL,           // optional security attributes
                                    PAGE_READONLY,  // protection for mapping object
                                    0,              // high-order 32 bits of object size
                                    0,              // low-order 32 bits of object size
                                    NULL            // name of file-mapping object
                                )))
    {
        DWORD nFileSize;
        if (SUCCEEDED(AspGetFileAttributes(m_szPathTranslated, m_hFile, NULL, &nFileSize)))
        {
            if(nFileSize == 0)
            {
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Empty source file %S\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Empty source file %s\n", m_szPathTranslated));
#endif
                THROW(E_SOURCE_FILE_IS_EMPTY);
            }
        }
        else
        {
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
        }
    }

    // set file's start-of-file ptr
    if(NULL == (m_pbStartOfFile =
                (PBYTE) MapViewOfFile(
                                        m_hMap,         // file-mapping object to map into address space
                                        FILE_MAP_READ,  // access mode
                                        0,              // high-order 32 bits of file offset
                                        0,              // low-order 32 bits of file offset
                                        0               // number of bytes to map
                                    )))
        THROW(E_COULDNT_OPEN_SOURCE_FILE);
    }

/*  ============================================================================
    CTemplate::CFileMap::SetParent
    Set the parent for this filemap
*/
void
CTemplate::CFileMap::SetParent
(
CFileMap* pfilemapParent
)
    {
    CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemap->m_pfilemapParent = pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetParent
    Get the parent for this filemap
*/
CTemplate::CFileMap*
CTemplate::CFileMap::GetParent
(
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    return pfilemap->m_pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::AddSibling
    Add a new node as a sibling of this
*/
void
CTemplate::CFileMap::AddSibling
(
register CFileMap* pfilemapSibling
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemapSibling->m_fHasSibling = FALSE;
    pfilemapSibling->m_pfilemapParent = pfilemap->m_pfilemapParent;

    pfilemap->m_fHasSibling = TRUE;
    pfilemap->m_pfilemapSibling = pfilemapSibling;
    }

/*  ============================================================================
    CTemplate::CFileMap::FCyclicInclude
    Is a file among this filemap's ancestors?  (i.e. does it occur anywhere
    in the filemap's parent chain?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOL
CTemplate::CFileMap::FCyclicInclude
(
LPCTSTR  szPathTranslated
)
    {
    CFileMap *pfilemapParent = GetParent();

    if(pfilemapParent == NULL)
        return FALSE;

    // NOTE we ignore case because path-tran was normalized
    if(_tcscmp(szPathTranslated, pfilemapParent->m_szPathTranslated) == 0)
        return TRUE;

    return pfilemapParent->FCyclicInclude(szPathTranslated);
    }

/*  ============================================================================
    CTemplate::CFileMap::GetSecurityDescriptor
    Gets a file's security descriptor

    Returns
        TRUE if we got security descriptor, else FALSE
    Side effects
        allocates memory
*/
BOOL
CTemplate::CFileMap::GetSecurityDescriptor
(
)
    // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
    {
    BOOL                    fRet = TRUE;                            // return value
    BOOL                    fGotSecurityDescriptor;                 // did we get a security descriptor?
    DWORD                   dwSecDescSizeNeeded = 0;                // required size of security descriptor
    DWORD                   dwLastError;                            // last error code
    const SECURITY_INFORMATION  si =    OWNER_SECURITY_INFORMATION      // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;


    // get required buffer size before malloc
    // NOTE this costs us an extra system call, but means the cached template will often use less memory
    // we must do this up front by passing 0 buffer size because when the call succeeds it returns
    // dwSecDescSizeNeeded == 0 (i.e. we can't realloc to shrink after successful call)
    GetKernelObjectSecurity(
                            m_hFile,                // handle of object to query
                            si,                     // requested information
                            NULL,                   // address of security descriptor
                            0,                      // size of buffer for security descriptor
                            &dwSecDescSizeNeeded    // address of required size of buffer
                            );

    if((dwLastError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
        // pretend everything's fine -- just NULL security descriptor
        if(m_pSecurityDescriptor != NULL)
            CTemplate::SmallFree(m_pSecurityDescriptor);
        m_pSecurityDescriptor = NULL;
        m_dwSecDescSize = 0;
        if (dwLastError == ERROR_NOT_SUPPORTED)
            return TRUE;
        else
            return FALSE;
        }

    // set member buffer size to just enough chunks to accommodate security descriptor size needed
    m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                * SECURITY_DESC_GRANULARITY;

    // allocate memory for security descriptor
    //  (Note: security descriptor may already be allocated if this is a remap)
    if (m_pSecurityDescriptor == NULL)
        if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallMalloc(m_dwSecDescSize)))
            THROW(E_OUTOFMEMORY);

    // try to get security descriptor until we succeed, or until we fail for some reason other than buffer-too-small
    while(TRUE)
        {
        // attempt to get security descriptor
        fGotSecurityDescriptor = GetKernelObjectSecurity(
                                    m_hFile,                // handle of object to query
                                    si,                     // requested information
                                    m_pSecurityDescriptor,  // address of security descriptor
                                    m_dwSecDescSize,        // size of buffer for security descriptor
                                    &dwSecDescSizeNeeded    // address of required size of buffer
                                );

        // get last error immediately after call
        dwLastError =   fGotSecurityDescriptor
                        ?   0                       // we got a security descriptor: set last error to 0
                        :   GetLastError();         // we didn't get a security descriptor: get last error

        if(fGotSecurityDescriptor)
            // we got a security descriptor, so break
            // NOTE we can't realloc m_pSecurityDescriptor to free its unused memory
            // because dwSecDescSizeNeeded is 0 after successful call
            break;

        else if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
            // we didn't get a security descriptor because buffer was too small: increase buffer size, realloc and continue.
            Assert(m_dwSecDescSize < dwSecDescSizeNeeded);

            // set member buffer size to just enough chunks to accommodate security descriptor size needed
            m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                    * SECURITY_DESC_GRANULARITY;

            if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallReAlloc(m_pSecurityDescriptor, m_dwSecDescSize)))
                THROW(E_OUTOFMEMORY);
            }

        else
            {
            // we didn't get a security descriptor for some random reason: return failure
            fRet = FALSE;
            break;
            }

        }

    return fRet;
    }


/*  ============================================================================
    CTemplate::CFileMap::UnmapFile
    Unmaps a memory-mapped file
    NOTE this leaves the filemap's path-info and path-tran members intact

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CFileMap::UnmapFile
(
)
    {
    if(m_pbStartOfFile != NULL)
        if(!UnmapViewOfFile(m_pbStartOfFile)) THROW(E_FAIL);

    if(m_hMap!= NULL)
        if(!CloseHandle(m_hMap)) THROW(E_FAIL);

    if(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
        if(!CloseHandle(m_hFile)) THROW(E_FAIL);

    // Null-ify ptr and handles, since MapFile checks for non-null
    m_pbStartOfFile = NULL;
    m_hMap = NULL;
    m_hFile = NULL;
    }

/*  ============================================================================
    CTemplate::CFileMap::CountChars
    Count the number of characters in the (open) filemap

    Returns:
        # of characters in the file
*/
DWORD
CTemplate::CFileMap::CountChars
(
WORD wCodePage
)
    {
    // Bug 84284: Scripts containing object tags only do not have the DBCS table built
    //             (Because there is no line mapping table to base it from)
    //
    CTemplate::COffsetInfo *pOffsetInfoLast, oiZero;
    pOffsetInfoLast = (m_rgByte2DBCS.length() == 0)
                            ? &oiZero
                            : &m_rgByte2DBCS[m_rgByte2DBCS.length() - 1];

    // If GetSize() fails don't count the remaining DBCS characters - otherwise an AV
    DWORD cchFilemap = GetSize();
    if (cchFilemap != 0xFFFFFFFF && cchFilemap != 0)
        {
        // Count DBCS characters
        m_cChars = pOffsetInfoLast->m_cchOffset +
                      CharAdvDBCS(wCodePage,
                                  reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLast->m_cbOffset),
                                  reinterpret_cast<char *>(m_pbStartOfFile + cchFilemap),
                                  INFINITE, NULL);

        }
    else
        {
        m_cChars = 0;
        }

    // Done counting DBCS characters
    return m_cChars;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetText
    From a character offset and length, return the document text

    File must be mapped
*/
HRESULT CTemplate::CFileMap::GetText
(
WORD wCodePage,
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    ULONG cCharsCopied;
    if (pcChars == NULL)
        pcChars = &cCharsCopied;

    // Map the file (temporarily) if not mapped
    BOOL fRemapFile = !FIsMapped();
    TRY
        RemapFile();
    CATCH (dwException)
        return E_FAIL;
    END_TRY

    /* Find the byte offset closest to cchSourceOffset.  This will be
     * the place where we start looping with CharNext() to get the full
     * byte offset.
     */
    COffsetInfo *pOffsetInfoLE = NULL, OffsetInfoT;

    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, the DBCS table does not exist.
     * If there is no DBCS mapping table, then pretend like we found entry with
     * nearest offset == 0.  (unless this is SBCS in which case nearest
     * offset == cchSourceOffset)
     */
    if (m_rgByte2DBCS.length() == 0)
        {
        CPINFO  CpInfo;
        GetCPInfo(wCodePage, &CpInfo);
        OffsetInfoT.m_cbOffset = OffsetInfoT.m_cchOffset = (CpInfo.MaxCharSize == 1)? cchSourceOffset : 0;
        pOffsetInfoLE = &OffsetInfoT;
        }
    else
        GetBracketingPair(
                cchSourceOffset,                        // value to search for
                m_rgByte2DBCS.begin(),                  // beginning of array to search
                m_rgByte2DBCS.end(),                    // end of array
                CCharOffsetOrder(),                     // order by character offsets
                &pOffsetInfoLE,                         // desired offset
                static_cast<COffsetInfo **>(NULL)       // don't care
                );

    /* OK - pOffsetLE->cbOffset contains the closest offset not exceeding
     *      cchSourceOffset.  Iterate over the remainder of the characters
     *      to convert the cch to a cb.  It had better exist!
     */
    Assert (pOffsetInfoLE != NULL);

    // Advance over remaining characters
    char *pchStart;
    CharAdvDBCS(wCodePage,
                reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                cchSourceOffset - pOffsetInfoLE->m_cchOffset,
                &pchStart
                );

    // Compute # of Characters to copy
    Assert (m_cChars >= cchSourceOffset);
    *pcChars = min(cMaxChars, m_cChars - cchSourceOffset);

    // Compute # of Bytes to copy
    char *pchEnd;
    CharAdvDBCS(wCodePage,
                pchStart,
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                *pcChars,
                &pchEnd
                );

    if (pwchText)
        MultiByteToWideChar(
                        (WORD)wCodePage,
                        0,
                        pchStart,
                        DIFF(pchEnd - pchStart),
                        pwchText,
                        cMaxChars
                        );

    // We don't support syntax coloring, so set all the character attributes to
    // default color (black)
    if (pTextAttr)
        memset(pTextAttr, 0, *pcChars);

    // Unmap the file (but only if we previously remapped it)
    if (fRemapFile)
        TRY
            UnmapFile();
        CATCH (dwException)
            return E_FAIL;
        END_TRY

    return S_OK;
    }

/*  ****************************************************************************
    CTemplate::CTokenList member functions
*/

/*  ============================================================================
    CTemplate::CTokenList::Init
    Populates token list with tokens

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CTokenList::Init
(
)
    {
    // Init tokens buffer for local storage
    m_bufTokens.Init(tkncAll, CB_TOKENS_DEFAULT);

    // append tokens to buffer
    // NOTE *** TOKENS MUST BE IN SAME ORDER AS ENUM TYPE VALUES ***
    // NOTE 'superset' token must precede 'subset' token (e.g. <!--#INCLUDE before <!--)
    AppendToken(tknOpenPrimaryScript,   "<%");
    AppendToken(tknOpenTaggedScript,    "<SCRIPT");
    AppendToken(tknOpenObject,          "<OBJECT");
    AppendToken(tknOpenHTMLComment,     "<!--");

    AppendToken(tknNewLine,             SZ_NEWLINE);

    AppendToken(tknClosePrimaryScript,  "%>");
    AppendToken(tknCloseTaggedScript,   "</SCRIPT>");
    AppendToken(tknCloseObject,         "</OBJECT>");
    AppendToken(tknCloseHTMLComment,    "-->");
    AppendToken(tknEscapedClosePrimaryScript,   "%\\>");

    AppendToken(tknCloseTag,            ">");

    AppendToken(tknCommandINCLUDE,      "#INCLUDE");

    AppendToken(tknTagRunat,            "RUNAT");
    AppendToken(tknTagLanguage,         "LANGUAGE");
    AppendToken(tknTagCodePage,         "CODEPAGE");
    AppendToken(tknTagCodePage,         "LCID");
    AppendToken(tknTagTransacted,       "TRANSACTION");
    AppendToken(tknTagSession,          "ENABLESESSIONSTATE");
    AppendToken(tknTagID,               "ID");
    AppendToken(tknTagClassID,          "CLASSID");
    AppendToken(tknTagProgID,           "PROGID");
    AppendToken(tknTagScope,            "SCOPE");
    AppendToken(tknTagVirtual,          "VIRTUAL");
    AppendToken(tknTagFile,             "FILE");
    AppendToken(tknTagMETADATA,         "METADATA");
//  AppendToken(tknTagSetPriScriptLang, "@");
    AppendToken(tknTagName,             "NAME");
    AppendToken(tknValueTypeLib,        "TYPELIB");
    AppendToken(tknTagType,             "TYPE");
    AppendToken(tknTagUUID,             "UUID");
    AppendToken(tknTagVersion,          "VERSION");
    AppendToken(tknTagStartspan,        "STARTSPAN");
    AppendToken(tknTagEndspan,          "ENDSPAN");
    AppendToken(tknValueCookie,         "COOKIE");
    AppendToken(tknTagSrc,              "SRC");

    AppendToken(tknValueServer,         "Server");
    AppendToken(tknValueApplication,    "Application");
    AppendToken(tknValueSession,        "Session");
    AppendToken(tknValuePage,           "Page");

    AppendToken(tknVBSCommentSQuote,    "'");
    AppendToken(tknVBSCommentRem,       "REM ");    // NOTE ends with space character
    AppendToken(tknTagFPBot,            "webbot");

    AppendToken(tknEOF,                 "");

    AppendToken(tkncAll,                "");

    }

/*  ============================================================================
    CTemplate::CTokenList::AppendToken
    Appends a string to tokens buffer
    NOTE we keep the unused tkn parameter because it enforces consistency and
    readability in CTemplate::CTokenList::Init(), e.g.
        AppendToken(tknOpenPrimaryScript,   "<%");
    rather than
        AppendToken("<%");

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CTokenList::AppendToken
(
_TOKEN  tkn,    // token value
char*   sz      // token string
)
    {
    // construct byte range from token string
    CByteRange  br;
    br.m_pb = (BYTE*) sz;
    br.m_cb = strlen(sz);

    // append to tokens buffer as local string
    m_bufTokens.Append(br, TRUE, 0, NULL, TRUE);
    }

/*  ============================================================================
    CTemplate::CTokenList::NextOpenToken
    Returns value of next open token in search range

    Returns
        token value of next open token in search range; ptr to ptr to open token (out-parameter)
    Side effects
        None
*/
_TOKEN
CTemplate::CTokenList::NextOpenToken
(
CByteRange& brSearch,       // search byte range
TOKEN*      rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
BYTE**      ppbToken,       // ptr to ptr to open token (out-parameter)
LONG        lCodePage
)
    {
    BYTE*       pbTemp = NULL;  // temp pointer
    _TOKEN      tkn = tknEOF;   // return value
    USHORT      i;              // loop index

    // Init caller's token ptr to null
    *ppbToken = NULL;

    // If input is empty, return
    if (brSearch.IsNull())
        return tkn;

    // Prepare array of LPSTR pointers to tokens.
    // Do it here once, because to get LPSTR is not free.
    LPSTR rgszTokens[TOKEN_OPENERS_MAX];
    UINT  rgcchTokens[TOKEN_OPENERS_MAX];
    Assert(ctknOpeners <= TOKEN_OPENERS_MAX);

    for (i = 0; i < ctknOpeners; i++)
        {
        LPSTR pszStr = m_bufTokens.PszLocal((UINT)(rgtknOpeners[i]));
        rgszTokens[i]  = pszStr;
        rgcchTokens[i] = (pszStr != NULL) ? strlen(pszStr) : 0;
        }

    // Call a method to find one of the strings in the range
    UINT idToken;
    pbTemp = brSearch.PbOneOfAspOpenerStringTokens(
        rgszTokens, rgcchTokens, ctknOpeners, &idToken);
    if (pbTemp != NULL)
        {
        *ppbToken = pbTemp;
        tkn = rgtknOpeners[idToken];
        }

    // If we found no open token, position token pointer at end of search range
    if (tkn == tknEOF)
        *ppbToken = brSearch.m_pb + brSearch.m_cb;

    return tkn;
    }

/*  ============================================================================
    CTemplate::CTokenList::MovePastToken
    Moves a byte range past a token contained within it
*/
void
CTemplate::CTokenList::MovePastToken
(
_TOKEN      tkn,
BYTE*       pbToken,
CByteRange& brSearch
)
    {
    Assert(pbToken >= brSearch.m_pb);
    Assert(brSearch.m_cb >= (DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn)));
    brSearch.Advance(DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn));
    }

/*  ============================================================================
    CTemplate::CTokenList::GetToken
    Gets the next occurrence of a token within a byte range.

    Returns:
        ptr to token
    Side effects
        none
*/
BYTE*
CTemplate::CTokenList::GetToken
(
TOKEN       tkn,
CByteRange& brSearch,
LONG        lCodePage
)
    {
    return brSearch.PbString(m_bufTokens.PszLocal((UINT)tkn), lCodePage);
    }

/*  ============================================================================
    The Big Three for CTemplateConnPt

    NOTES:
        Since this interface is embedded in CTemplate,
        AddRef() and Release() delegate to the container object (because that
        is the CTemplate pointer)
*/
HRESULT
CTemplateConnPt::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IConnectionPoint)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG
CTemplateConnPt::AddRef()
    {
    return m_pUnkContainer->AddRef();
    }

ULONG
CTemplateConnPt::Release()
    {
    return m_pUnkContainer->Release();
    }

/*  ============================================================================
    Constructor for CDocNode
*/
CTemplate::CDocNodeElem::CDocNodeElem(CAppln *pAppln, IDebugApplicationNode *pDocRoot)
    {
    Assert (pAppln != NULL);
    Assert (pDocRoot != NULL);

    (m_pAppln = pAppln)->AddRef();
    (m_pDocRoot = pDocRoot)->AddRef();
    }

/*  ============================================================================
    Destructor for CDocNode
*/
CTemplate::CDocNodeElem::~CDocNodeElem()
    {
    m_pAppln->Release();
    DestroyDocumentTree(m_pDocRoot);
    }

/*  ============================================================================
    CTemplate::fIsLangVBScriptOrJScript(USHORT idEngine)

    This function returns T/F to determine if the requested script engine
    is VBScript or JScript. This function is used as an indicator to determin
    if spaces need to be preserved for non MS Scripting languages

    There is an assumption here that the GUIDs for VBScript and JScript will not change

    Inputs
        Index to a script engine

    Returns
        BOOL
*/
BOOLB CTemplate::FIsLangVBScriptOrJScript(USHORT idEngine)
    {
    // {b54f3741-5b07-11cf-a4b0-00aa004a55e8} VBScript
    static const GUID uid_VBScript  = {0xb54f3741, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

    // {f414c260-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript
    static const GUID uid_JScript   = {0xf414c260, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        // {b54f3743-5b07-11cf-a4b0-00aa004a55e8} VBScript.Encode
        static const GUID uid_VBScriptEncode = {0xb54f3743, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

        // {f414c262-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript.Encode
        static const GUID uid_JScriptEncode = {0xf414c262, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        GUID &uidLang = m_pWorkStore->m_ScriptStore.m_rgProgLangId[idEngine];
        return
                uidLang == uid_VBScript || uidLang == uid_VBScriptEncode ||
                uidLang == uid_JScript  || uidLang == uid_JScriptEncode;
    }


SIZE_T
_RoundUp(
    SIZE_T dwBytes)
{
#if 1
    // 16KB <= dwBytes? Round up to next multiple of 4KB
    if (16*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<12) - 1) >> 12) << 12;

    // 4KB <= dwBytes < 16KB? Round up to next multiple of 1KB
    else if (4*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<10) - 1) >> 10) << 10;

    // 1KB <= dwBytes < 4KB? Round up to next multiple of 256 bytes
    else if (1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<8) - 1) >> 8) << 8;

    // dwBytes < 1KB? Round up to next multiple of 32 bytes
    else
        dwBytes = ((dwBytes + (1<<5) - 1) >> 5) << 5;
#endif

    return dwBytes;
}

void*
CTemplate::SmallMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hSmallHeap, 0, dwBytes);
}


void*
CTemplate::SmallReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hSmallHeap, 0, pvMem, dwBytes);
}


void
CTemplate::SmallFree(void* pvMem)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    ::HeapFree(sm_hSmallHeap, 0, pvMem);
}

void*
CTemplate::LargeMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hLargeHeap, 0, dwBytes);
}


void*
CTemplate::LargeReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hLargeHeap, 0, pvMem, dwBytes);
}


void
CTemplate::LargeFree(void* pvMem)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    ::HeapFree(sm_hLargeHeap, 0, pvMem);
}


// WriteTemplate Class.

/*  ============================================================================
    CTemplate::CWriteTemplate::CWriteTemplate
    Constructor for WriteTemplate

    Side effects
        none
*/
CTemplate::CWriteTemplate::CWriteTemplate () :
    m_pworkStore(NULL),
    m_cbMemRequired (0L),
    m_pTemplate(NULL),
    m_fWriteScript(FALSE),
    m_fCalcLineNumber(TRUE),
    m_pbHeader(NULL)
{
}

/*  ============================================================================
    CTemplate::CWriteTemplate::~CWriteTemplate
    Destructor for WriteTemplate.

    Side effects
        none
*/

CTemplate::CWriteTemplate::~CWriteTemplate ()
{
    if (m_pbHeader)
    {
        // Dont free up m_pbHeader..Rather let CTemplate free it up during its cleanup.
        // As m_pbStart = m_pbHeader and memory has been alocated from heap.

        m_pbHeader = NULL;
    }
}

/*  ============================================================================
    CTemplate::CWriteTemplate::Init
    Initializes the write Template by copying the workstore object and the pointer to the template.

    Returns:
        HRESULT
    Side effects
        none
*/

void CTemplate::CWriteTemplate::Init
    (
    CWorkStore* pworkStore,
    CTemplate* pTemplate,
    BOOL     fCalcLineNumber
    )
{
    //Store pointers to the workstore and template and metabase flag for line number calculation.
    m_pworkStore = pworkStore;
    m_pTemplate = pTemplate;
    m_fCalcLineNumber = fCalcLineNumber;

    // Get CodePage Information
    if (!GetCPInfo(pTemplate->m_wCodePage, &m_codePageInfo))
    {
        // Cant GetCPInfo? Set the codePage such that the call to MultiByteToWideChar is forced.
        m_codePageInfo.MaxCharSize = 0; // This will fail (MaxCharSize == 1)
    }
}


/*  ============================================================================
    CTemplate::CWriteTemplate::WriteTemplate
    Control routine that calls EstimateMemory and then write script/HTML/object blocks to template memory.

    Returns:
        HRESULT
    Side effects
        none
*/
void CTemplate::CWriteTemplate::WriteTemplate ()
{
    m_fWriteScript  =   FALSE;      // Set state to ESTIMATE
    WriteTemplateComponents();

    // Write the blocks into template memory
    m_fWriteScript  =   TRUE;       // Set state to WRITE
    WriteTemplateComponents();

    // This assert is no longer holds as the trailing comment could send this for a spin while it is valid.
    // Assert (m_cbMemRequired == m_pTemplate->m_cbTemplate);
    Assert (m_cbMemRequired >= m_pTemplate->m_cbTemplate);
}

/*  ============================================================================
    CTemplate::CWriteTemplate::WriteTemplateComponents
    Runs thru the workstore object the second time.. this time telling routines to write to the template
    memory and not just calculate the memory required.
    Writes the template out to a contiguous block of memory.

    Returns:
        nothing
    Side effects:
        Allocates memory. Its CTemplate's responsibility to free it when it done with it.

    HERE IS HOW IT WORKS
    --------------------
    - an 'offset' is the count of bytes from start-of-template to a location
      within template memory
    - at the start of the template are 3 USHORTs, the counts of script blocks,
      object-infos and HTML blocks, respectively
    - next are 4 ULONGs, each an offset to a block of offsets; in order, these are:
        offset-to-offset to first script engine name
        offset-to-offset to first script block (the script text itself)
        offset-to-offset to first object-info
        offset-to-offset to first HTML block
    - next are a variable number of ULONGs, each an offset to a particular
      template component.  In order these ULONGs are:
        Offsets to                  Count of offsets
        ----------                  ----------------
        script engine names         cScriptBlocks
        script blocks               cScriptBlocks
        object-infos                cObjectInfos
        HTML blocks                 cHTMLBlocks
    - next are the template components themselves, stored sequentially
      in the following order:
        script engine names
        script blocks
        object-infos
        HTML blocks

    HERE IS HOW IT LOOKS
    --------------------
    |--|--|--|                      3 template component counts (USHORTs)

    |-- --|-- --|                   4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |

    or, mnemonically:

     cS cO cH                       3 template component counts (USHORTs)

     offSE offSB offOb offHT        4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |
*/
void CTemplate::CWriteTemplate::WriteTemplateComponents
    (
    )
{
    USHORT        i;
    CByteRange  brWrite;

    // SourceFilename :: Only if include file.
    BYTE*   pbIncFilename;
    ULONG   cbIncFilename;
    ULONG   cbSourceOffset; // Offset in the Source file (FOR HTML BLOCKS)

    // Block counts
    USHORT cScriptBlocks   = m_pworkStore->CRequiredScriptEngines (m_pTemplate->m_fGlobalAsa);
    USHORT cObjectInfos    = m_pworkStore->m_ObjectInfoStore.Count();
    USHORT cHTMLBlocks    = m_pworkStore->m_bufHTMLSegments.Count();

    // Count the total blocks in the ASP file that will be written to a template.
    USHORT cBlockPtrs       = (2 * cScriptBlocks) + cObjectInfos + cHTMLBlocks;

    // Total number of memory required for header = required header + memory for blocks in ASP file.
    UINT    cbRequiredHeader = (C_COUNTS_IN_HEADER * sizeof(USHORT)) + (C_OFFOFFS_IN_HEADER * sizeof(DWORD));
    UINT    cbRequiredBlockPtrs = cBlockPtrs * sizeof (DWORD);

    // Adjust offsets.
    UINT    cbHeaderOffset  = 0;
    UINT    cbOffsetToOffset = 0;
    UINT    cbDataOffset    = cbRequiredHeader + cbRequiredBlockPtrs;

    UINT    *pcbDataOffset; // Pointer to the counter = Points to m_cbMemRequired during Estimation phase and cbDataOffset during write phase.


    if (m_fWriteScript)
    {
        // Allocate space for the template (resize the header field.)
        if(NULL == (m_pbHeader = (BYTE*) CTemplate::LargeMalloc(m_cbMemRequired)))
            THROW(E_OUTOFMEMORY);

        /* AppendSourceInfo Uses m_pbStart...So updating m_pbStart to use the same memory.
           Care should be taken to allow CTemplate::~CTemplate to do the clean up. So no cleanup is
           performed when the CTemplate::CWriteTemplate object is distroyed.
        */
        m_pTemplate->m_pbStart = m_pbHeader;

        // The following 3 DWORDs are the number of script, object and HTML blocks respectively.

        // Write out basic headers
        MemCopyAlign (&cbHeaderOffset, &cScriptBlocks, sizeof(USHORT), sizeof(USHORT));
        MemCopyAlign (&cbHeaderOffset, &cObjectInfos, sizeof(USHORT), sizeof(USHORT));
        MemCopyAlign (&cbHeaderOffset, &cHTMLBlocks, sizeof(USHORT), sizeof(USHORT));

        /* The next 4 ULONGs are offsets to within the template memory to the start of script engine names block,
           the start of script block, the start of object block and the start of the HTML block.
           At each of these memory locations where these offsets point there will be offsets to individual
           blocks (script,object,HTML).
        */

        // Write out Offset pointers
        UINT    fillerVar = 0;       // Dummy variable.. used to write 0 to memory.
        cbOffsetToOffset = cbRequiredHeader;

        fillerVar = cScriptBlocks ? cbOffsetToOffset : 0;
        MemCopyAlign (&cbHeaderOffset, &fillerVar, sizeof(ULONG), sizeof(ULONG));
        cbOffsetToOffset += cScriptBlocks * sizeof(ULONG);

        fillerVar = cScriptBlocks ? cbOffsetToOffset : 0;
        MemCopyAlign (&cbHeaderOffset, &fillerVar, sizeof(ULONG), sizeof(ULONG));
        cbOffsetToOffset += cScriptBlocks * sizeof(ULONG);

        fillerVar = cObjectInfos ? cbOffsetToOffset : 0;
        MemCopyAlign (&cbHeaderOffset, &fillerVar, sizeof(ULONG), sizeof(ULONG));
        cbOffsetToOffset += cObjectInfos * sizeof(ULONG);

        fillerVar = cHTMLBlocks ? cbOffsetToOffset : 0;
        MemCopyAlign (&cbHeaderOffset, &fillerVar, sizeof(ULONG), sizeof(ULONG));

        // Start calculating the memory taken for the template while writing out the header.
        // At this point cbRequiredHeader == cbHeaderOffset
        // Reset cbOffsetToOffset. It will not be used after this as start of cbOffsetToOffset == cbHeaderOffset
        Assert (cbHeaderOffset == cbRequiredHeader);

        pcbDataOffset = &cbDataOffset;
    }
    else
    {
        m_cbMemRequired = cbRequiredHeader + cbRequiredBlockPtrs;
        pcbDataOffset = &m_cbMemRequired;
    }

    // Write the Script Engine names.
    for (i = 0;i<m_pworkStore->m_ScriptStore.CountPreliminaryEngines(); i++)
    {
        if (m_pworkStore->FScriptEngineRequired (i, m_pTemplate->m_fGlobalAsa))
        {
            m_pworkStore->m_ScriptStore.m_bufEngineNames.GetItem(i, brWrite);

            if (m_fWriteScript)                // Write out current pointer to the Header (OffsetOfOffsets)
                MemCopyAlign (&cbHeaderOffset, pcbDataOffset, sizeof(ULONG), sizeof(ULONG));

            WriteBSTRToMem (brWrite, pcbDataOffset);

            // Write out the ProgLangID
            MemCopyAlign (pcbDataOffset, &(m_pworkStore->m_ScriptStore.m_rgProgLangId[i]),sizeof(PROGLANG_ID),sizeof(DWORD));
        }
    }

    // Write Scripts
    USHORT idEngine = 0;        // Think abt storing this in CWriteTemplate
    for (i = 0;i<m_pworkStore->m_ScriptStore.CountPreliminaryEngines(); i++)
    {
        if (m_pworkStore->FScriptEngineRequired (i, m_pTemplate->m_fGlobalAsa))
        {
            // Calc memory of the script block.
            WriteScriptBlocks (i, idEngine, pcbDataOffset, &cbHeaderOffset, m_pTemplate->m_fGlobalAsa);
            idEngine ++;
        }

    }

    // Write ObjectInfos
    for (i=0;i<cObjectInfos;i++)
    {
        // Get object from workstore
        m_pworkStore->m_ObjectInfoStore.m_bufObjectNames.GetItem(i, brWrite);

        if (m_fWriteScript)
        {
            // Align cbDataOffset to the place where we will write out the Object blocks
            // Alignment is required before writing the offset to header.
            ByteAlignOffset (pcbDataOffset, sizeof(ULONG));
            MemCopyAlign (&cbHeaderOffset, pcbDataOffset, sizeof(ULONG), sizeof(ULONG));
        }

        WriteBSTRToMem (brWrite, pcbDataOffset);

        // Write CLSID, scope and model
        MemCopyAlign(pcbDataOffset, &(m_pworkStore->m_ObjectInfoStore.m_pObjectInfos[i].m_clsid) , sizeof(CLSID), sizeof(DWORD));
        MemCopyAlign(pcbDataOffset, &(m_pworkStore->m_ObjectInfoStore.m_pObjectInfos[i].m_scope) , sizeof(CompScope), sizeof(CompScope));
        MemCopyAlign(pcbDataOffset, &(m_pworkStore->m_ObjectInfoStore.m_pObjectInfos[i].m_model) , sizeof(CompModel), sizeof(CompModel));
    }

    // Write out the  the HTML BLocks
    if (!m_pTemplate->m_fGlobalAsa)
        for (i=0;i<cHTMLBlocks;i++)
        {
            m_pworkStore->m_bufHTMLSegments.GetItem(i, brWrite);

            if (m_fWriteScript)
            {
                // Align cbDataOffset to the place where we will write out the HTML blocks
                // Alignment is required before writing the offset to header.
                ByteAlignOffset (pcbDataOffset, sizeof(ULONG));
                MemCopyAlign (&cbHeaderOffset, pcbDataOffset, sizeof(ULONG), sizeof(ULONG));
            }

            WriteBSTRToMem (brWrite, pcbDataOffset);

            //Source offset and include file:
            cbSourceOffset = 0;
            pbIncFilename = NULL;
            cbIncFilename = 0;

            if (brWrite.m_pfilemap)
            {
                // Calculate offset from filemap
                CFileMap *pFileMap = (CFileMap *) brWrite.m_pfilemap;
                if (pFileMap->m_pbStartOfFile) // mapped?
                {
                    cbSourceOffset = DIFF (brWrite.m_pb - pFileMap->m_pbStartOfFile) + 1;
                    if (pFileMap->GetParent() != NULL && // is Include file ?
                            pFileMap->m_szPathInfo ) // path exists
                    {
                        pbIncFilename = (BYTE *) pFileMap->m_szPathInfo ;
                        cbIncFilename = _tcslen(pFileMap->m_szPathInfo) * sizeof(TCHAR);
                    }
                }
            }

            // Calculate memory required to write them.
            MemCopyAlign (pcbDataOffset, &cbSourceOffset ,sizeof(ULONG), 0);
            MemCopyAlign (pcbDataOffset, &cbIncFilename,sizeof(ULONG), 0);
            if (cbIncFilename > 0)
            {
                MemCopyAlign(pcbDataOffset, pbIncFilename, cbIncFilename+sizeof(TCHAR), 0);
            }

        }

    // If this is Write Mode then update the template size counter.
    if (m_fWriteScript)
        m_pTemplate->m_cbTemplate = cbDataOffset;
}


/*  ============================================================================
    CTemplate::CWriteTemplate::WriteScriptBlocks
    Writes out script block for idEngine-th script engine.
    NOTE segment buffer [0] contains primary script segments
         segment buffer [1] contains tagged script segments of default engine
         segment buffer [i] contains tagged script segments of (i-1)th engine, for i >= 2

    During the ESTIMATE phase this routine just skims over the blocks calculating memory required. In most
    cases the estimate phase will follow the exact same code path that the WRITE phase and will stop short of
    actually writing to memory.

    Returns:
        HRESULT
    Side effects
        none
*/

void CTemplate::CWriteTemplate::WriteScriptBlocks
    (
    USHORT  idEnginePrelim,
    USHORT  idEngine,
    UINT *pcbDataOffset,
    UINT    *pcbOffsetToOffset,
    BOOLB  m_fGlobalAsa
    )
{
    UINT        i = 0;
    CByteRange  brSegment;              // current Script Segment
    UINT        cbScriptBlockOffset;       // Offset to script Block write location.
    UINT        scriptStartBlockOffset;

    USHORT      iTSegBuffer = idEnginePrelim + 1;   // Index of tagged segment buffer.

    // Number of tagged script segements
    UINT        cTaggedSegments    =    m_pworkStore->m_ScriptStore.m_ppbufSegments[iTSegBuffer]->Count();

    //Align Offset For script Block and update header. (align on ULONG)
    ByteAlignOffset ((UINT*)pcbDataOffset,sizeof(ULONG));
    cbScriptBlockOffset = *pcbDataOffset;

    if (!m_fWriteScript)
        // Calculate memory for the size of this script segment Right now assume 0 is written. Part of the design.
        // 'i' used here as a filler, The code will just add sizeof (ULONG) to pcbDataOffset after aligning it if necessary
        MemCopyAlign (pcbDataOffset, &i, sizeof(ULONG), sizeof(ULONG));
    else
    {
        //Update the header to write the start of the script block.
        MemCopyAlign (pcbOffsetToOffset, &cbScriptBlockOffset, sizeof(ULONG), sizeof(ULONG));
        // Save the offset to where the size of the script has to be written later.
        scriptStartBlockOffset = *pcbDataOffset;
        // Advance Offset pointer by ULONG to make space for writing Lenght in the end.
        *pcbDataOffset += sizeof(ULONG);
    }

    // 0 out the m_cbTargetOffsetPrevT variable which append source info uses.
    m_pTemplate->m_cbTargetOffsetPrevT = 0;

    // Now begin calculating the amount of memory the script segments will take. This has two parts..
    // The primary script segment and the tagged script segments.
    if (!m_fGlobalAsa)  // This is not Global.asa
        if (idEnginePrelim == 0)    // This is the primary script
            WritePrimaryScript(0, pcbDataOffset, cbScriptBlockOffset + sizeof(ULONG));

    // Calculate memory for the tagged segments.
    for (i=0;i<cTaggedSegments;i++)
    {
        m_pworkStore->m_ScriptStore.m_ppbufSegments[iTSegBuffer]->GetItem(i,brSegment);
        WriteTaggedScript(
            idEngine,
            m_pTemplate->m_rgpSegmentFilemaps[brSegment.m_idSequence],
            brSegment,
            pcbDataOffset,
            cbScriptBlockOffset + sizeof(ULONG),
            FALSE
            );
    }

    // check if the last few characters were --> and take appropriate action.
    // Do this only during the write phase as this code will write to script memory.
    if (m_fWriteScript)
         RemoveHTMLCommentSuffix(scriptStartBlockOffset, pcbDataOffset);

    // We need to write the null terminator
    MemCopyAlign (pcbDataOffset, WSTR_NULL, sizeof(WCHAR), 0);

    if (m_fWriteScript)
    {
        // Calculate size of script = difference in offsets - size of the length pointer - size of null terminator
        UINT cbScript = *pcbDataOffset - scriptStartBlockOffset - sizeof (ULONG) - sizeof (WCHAR);
        MemCopyAlign (&scriptStartBlockOffset, &cbScript, sizeof(ULONG), 0);

        /*  We need to append one extra "pseudo-line" to the end of source info's array to cover
            the case where the script engine reports back an error line number which falls after the
            end of the script. We always want the "pseudo-line" to point to the main file, so the
            debugger displays something reasonable. We pass it m_rgpFilemaps[0] which is the main file.
            We need to call this function only during the write phase and not the estimation phase.
            We need to call AppendSourceInfo before the script engine executes the script.
        */
        m_pTemplate->AppendSourceInfo (idEngine,
                                    m_pTemplate->m_rgpFilemaps[0],
                                    NULL,
                                    UINT_MAX,
                                    UINT_MAX,
                                    UINT_MAX,
                                    0, TRUE);
    }
}

/*  ============================================================================
    CTemplate::CWriteTemplate::WritePrimaryScript
    Writes (if fWriteScript is TRUE, calculates memory requirement otherwise) out default-engine primary script procedure.
    If VBScript is default-engine, the primary script procedure contains
    interleaved script commands and HTML block-writes, like this:
        Sub Main
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
        End Sub

    NOTE segment buffer [0] == primary script segments

    This routine is called for the main script.

    Returns:
        nothing
    Side effects
        none
*/

void CTemplate::CWriteTemplate::WritePrimaryScript
    (
    USHORT idEngine,
    UINT *  pcbDataOffset,
    UINT    cbScriptBlockOffset
    )
{
    USHORT  cScriptSegmentsProcessed = 0;
    USHORT  cHTMLBlocksProcessed = 0;
    CByteRange  brScriptNext;
    CByteRange  brHTMLNext;
    char        szHTMLBlockID[6];

    USHORT  cPrimaryScriptSegments = m_pworkStore->m_ScriptStore.m_ppbufSegments[0]->Count();
    USHORT  cHTMLBlocks = m_pworkStore->m_bufHTMLSegments.Count();

    CFileMap *  pfilemap;

    // Get Initial script and HTML segments.
    if (cPrimaryScriptSegments)
        m_pworkStore->m_ScriptStore.m_ppbufSegments[0]->GetItem(0,brScriptNext);
    if (cHTMLBlocks)
        m_pworkStore->m_bufHTMLSegments.GetItem(0,brHTMLNext);

    //While there are HTML or primary scripts present...
    while ((cHTMLBlocksProcessed < cHTMLBlocks) || (cScriptSegmentsProcessed < cPrimaryScriptSegments))
    {
        //If HTML block(s) remain to be processed
        if (cHTMLBlocksProcessed < cHTMLBlocks)
            while (TRUE)
            {
                if (brHTMLNext.FEarlierInSourceThan(brScriptNext) || (cScriptSegmentsProcessed >= cPrimaryScriptSegments))
                {
                    //append source-info for the target script line we just manufactured.
                    pfilemap = m_pTemplate->m_rgpSegmentFilemaps[brHTMLNext.m_idSequence];

                    // We can call Append Source info here as it does not write any information to the template
                    // rather it reads information from the workstore/scriptstore and appends the source info to
                    // the workstore. Provided this function is called just once. we call it during the WRITE phase

                   if (m_fWriteScript)
                   {
                        m_pTemplate->AppendSourceInfo (   idEngine,
                                        pfilemap,    // Filemap
                                        NULL,       // Dont do linenumber calculation
                                        DIFF(brHTMLNext.m_pb - pfilemap->m_pbStartOfFile),  // offset of line in source
                                        cbScriptBlockOffset,        // ptr to start of scripts
                                        (*pcbDataOffset - cbScriptBlockOffset)/sizeof(WCHAR),  // line in target file
                                        CharAdvDBCS ((WORD) m_pTemplate->m_wCodePage,
                                                        reinterpret_cast <char *> (brHTMLNext.m_pb),
                                                        reinterpret_cast <char *> (brHTMLNext.m_pb + brHTMLNext.m_cb),
                                                        INFINITE,
                                                        NULL),  // Exact number of characters in source file
                                        TRUE);      // It is HTML
                    }

                    // Proceed to calculate the blocknumber and tags in the template.

                    // Convert blockID to string.
                    _itoa (cHTMLBlocksProcessed, szHTMLBlockID,10);

                    // Write out block opener, the block number and the block closer followed by a newline.
                    MemCopyWithWideChar (pcbDataOffset, m_pworkStore->m_szWriteBlockOpen, m_pworkStore->m_cchWriteBlockOpen, 0);
                    MemCopyWithWideChar (pcbDataOffset, szHTMLBlockID, strlen(szHTMLBlockID), 0);
                    MemCopyWithWideChar (pcbDataOffset, m_pworkStore->m_szWriteBlockClose, m_pworkStore->m_cchWriteBlockClose, 0);
                    MemCopyWithWideChar (pcbDataOffset, SZ_NEWLINE, CB_NEWLINE, 0);

                    if (++cHTMLBlocksProcessed >= cHTMLBlocks)
                        break;

                    //get next HTMLBlock.
                    m_pworkStore->m_bufHTMLSegments.GetItem (cHTMLBlocksProcessed,brHTMLNext);
                }
                else
                    break;
            }

        //if primary Script Segment remains to be processed;
        if (cScriptSegmentsProcessed < cPrimaryScriptSegments)
            while (TRUE)
            {
                // Write out each primary script segment earlier in the source file than the next HTML block
                if (brScriptNext.FEarlierInSourceThan(brHTMLNext) || (cHTMLBlocksProcessed >= cHTMLBlocks))
                {
                    WriteTaggedScript ( idEngine,
                                                    m_pTemplate->m_rgpSegmentFilemaps[brScriptNext.m_idSequence],
                                                    brScriptNext,
                                                    pcbDataOffset,
                                                    cbScriptBlockOffset,
                                                    TRUE);

                    if (++cScriptSegmentsProcessed >= cPrimaryScriptSegments)
                        break;

                    // Get next script Segment
                    m_pworkStore->m_ScriptStore.m_ppbufSegments[0]->GetItem(cScriptSegmentsProcessed, brScriptNext);
                }
                else
                    break;
            }
    }
}

/*  ============================================================================
    CTemplate::CTemplate::WriteTaggedScript
    Writes a script segment to template memory line-by-line if fWriteScript is TRUE else just calculates memory
    its memory requirement.

    This routine could be called for both <SCRIPT> </SCRIPT> blocks and <% and %> blocks

    Returns:
        nothing
    Side effects
        none
*/
void CTemplate::CWriteTemplate::WriteTaggedScript
    (
    USHORT  idEngine,
    CFileMap* pfilemap,
    CByteRange brScript,
    UINT*   pcbDataOffset,
    UINT    cbScriptBlockOffset,
    BOOL    fAllowExprWrite
    )
{
    CByteRange  brLine;
    UINT        cbPtrOffset = 0;
    BOOL       fExpression = FALSE;
    BOOL        fFirstLine = TRUE;

    // Metabase setting (m_fCalcLineNumber) will override if it is set to FALSE else it will have no effect.
    BOOL        fCalcLineNumber = m_fCalcLineNumber;      // should line number be calculated.

    if (FByteRangeIsWhiteSpace(brScript))
        return;

    // Trim white space from begining of script segment
    if (m_pTemplate->FIsLangVBScriptOrJScript (idEngine))
        LTrimWhiteSpace (brScript);

    while (!(brScript.IsNull()))
    {
        //fetch next line from byte range until brScript is NULL
        LineFromByteRangeAdv (brScript, brLine);

        if (FByteRangeIsWhiteSpace (brLine))
        {
            fCalcLineNumber = m_fCalcLineNumber ;    // if m_fCalcLineNumber is set to true then fCalcLineNumber is true else
                                                   // just m_fCalcLineNumber will just mask of fCalcLineNumber to FALSE
            continue;
        }

        // If the line is not blank..trim the white spaces.
        if (m_pTemplate->FIsLangVBScriptOrJScript (idEngine))
            LTrimWhiteSpace (brLine);
        RTrimWhiteSpace (brLine);



        /* We need to call AppendSourceInfo so that the script engine has a corelation
           with the line number..and other source information such as which file the script belongs to.
           If the line number flag is not NULL then AppendSourceInfo will force recalculation of the
           line numbers. If however it is NULL then AppendSourceInfo just appends 1 to the current line number
           without calling into the Line number calculation routine.
           All AppendSourceInfo calls are made only during the WRITE phase.
           NOTE: AppendSourceInfo will always take the NULL as a parameter if m_fCalcLineNumber is set to FALSE
        */
        if (m_fWriteScript)
        {
            m_pTemplate->AppendSourceInfo (    idEngine,
                                        pfilemap,
                                        fCalcLineNumber ? brLine.m_pb : NULL,
                                        DIFF (brLine.m_pb - pfilemap->m_pbStartOfFile),
                                        cbScriptBlockOffset,
                                        (*pcbDataOffset - cbScriptBlockOffset)/sizeof(WCHAR),
                                        CharAdvDBCS ((WORD) m_pTemplate->m_wCodePage,
                                            reinterpret_cast <char *> (brLine.m_pb),
                                            reinterpret_cast <char *> (brLine.m_pb + brLine.m_cb),
                                            INFINITE, NULL),
                                        FALSE);
        }

        /* fCalcLineNumber is set to TRUE if the parser hits a blank line or an close token.
           It instructs the Append source info to begin line number calculation from the start.
           Setting it to FALSE will just tell it to ignore recalculation of the line number and it
           just appends 1 to previous line number to get the current count.
           On return from AppendSourceInfo..we just reset the line number calculation flag.
        */
        fCalcLineNumber = FALSE;


        if (fAllowExprWrite && fFirstLine)
        {
            // Test for remainder of script segment null on temp copy of script byte range, not on actual
            CByteRange  brTemp = brScript;
            LTrimWhiteSpace (brTemp);

            if (brTemp.IsNull())
            {
                /* if (a) expr-write is allowed AND (b) this is only script line in this segment (first and remainder
                is NULL. then test this line to see if it is an expression.

                if  this like is an expression, create a script command that reads
                Response.Write([line contents])
                */
                if (fExpression = m_pTemplate->FExpression (brLine))
                {
                    MemCopyWithWideChar (pcbDataOffset, m_pworkStore->m_szWriteOpen,
                                                    m_pworkStore->m_cchWriteOpen, 0);
                }
                brScript = brTemp;
            }
        }

        // write out line contents
        ScriptMemoryMinusEscapeChars(brLine, pcbDataOffset, cbPtrOffset);

        // If this line is an expression, close script command.
        if (fExpression)
            MemCopyWithWideChar (pcbDataOffset, m_pworkStore->m_szWriteClose,
                                                m_pworkStore->m_cchWriteClose, 0);

        // Write NEW_LINE and set first line flag to false.
        MemCopyWithWideChar (pcbDataOffset, SZ_NEWLINE, CB_NEWLINE, 0);

        fFirstLine = FALSE;
    }
}

/*  ============================================================================
    CTemplate::CWriteTemplate::ScriptMemoryMinusEscapeChars
    if fWriteWideCharStr is FALSE it calculates a script byte range to memory requirement, minus its escape characters, if any.
    if fWriteWideCharStr is TRUE it Writes a script byte range to memory, minus its escape characters, if any.

    Returns:
        nothing
    Side effects
        none
*/

void CTemplate::CWriteTemplate::ScriptMemoryMinusEscapeChars
    (
    CByteRange brScript,
    UINT *pcbDataOffset,
    UINT  cbPtrOffset
    )
{
    BYTE * pbToken;

    while (NULL != (pbToken = gm_pTokenList->GetToken (CTokenList::tknEscapedClosePrimaryScript, brScript,
        m_pTemplate->m_wCodePage)))
    {
        CByteRange brTemp = brScript;

        // Set temp range to source range up to escaped-token
        brTemp.m_cb = DIFF (pbToken - brTemp.m_pb);

        // WriteByteRangeAdv with no BSTR  = MemCopyWithWideChar
        // Write out temp range and actual-token - this replaces escaped-token with actual-token.
        MemCopyWithWideChar (pcbDataOffset, brTemp.m_pb, brTemp.m_cb, 0);
        MemCopyWithWideChar (pcbDataOffset, SZ_TOKEN(CTokenList::tknClosePrimaryScript), CCH_TOKEN(CTokenList::tknClosePrimaryScript), 0);

        //Advance source range past escaped token
        brScript.Advance (DIFF(pbToken - brScript.m_pb) + CCH_TOKEN(CTokenList::tknEscapedClosePrimaryScript));
    }

    // write remainder of source range.
    MemCopyWithWideChar (pcbDataOffset, brScript.m_pb, brScript.m_cb, 0);
}


/*  ============================================================================
    CTemplate::CWriteTemplate::CalcMemoryAndUpdateHeader
    Calculate the memory required to write a BSTR into template memory

    Returns:
        nothing
    Side effects
        none
*/

void CTemplate::CWriteTemplate::WriteBSTRToMem
    (
    CByteRange & brWrite,
    UINT *pcbOffset
    )
{
    MemCopyAlign (pcbOffset, &brWrite.m_cb, sizeof(ULONG), sizeof(ULONG));     // Length of BSTR

    MemCopyAlign (pcbOffset, brWrite.m_pb, brWrite.m_cb, 0);                // the BSTR itself.

    MemCopyAlign (pcbOffset, SZ_NULL, 1, 0);                                // Teminating NULL
}


/*  ============================================================================
    CTemplate::CWriteTemplate::MemCopyAlign
    Writes to target/calculates memory required after adjusting byte alignment if necessary.

    Returns:
        nothing
    Side effects
        none
*/

void CTemplate::CWriteTemplate::MemCopyAlign
    (
    UINT *pcbOffset,
    void *pbSource,
    ULONG cbSource,
    UINT cbByteAlign
    )
{
    // If byte alignment is necessary then align.
    if (cbByteAlign > 0)
        ByteAlignOffset (pcbOffset, cbByteAlign);

    // Copy memory if in WRITE phase and adjust offset else just adjust offset.
    if (m_fWriteScript)
        memcpy(m_pbHeader + *pcbOffset,pbSource,cbSource);
    *pcbOffset += cbSource;
}

/*  ============================================================================
    CTemplate::CWriteTemplate::MemCopyEstimateWithWideChar
    If the m_fWriteScript flag is FALSE then this routine calculates the memory that will be required when
    the source in converted into WideChar and stored. If the m_fWriteScript flag is TRUE then the routine
    copies the wide string into Template memory.

    Parameters:
        pcbOffset : pointer to offset where data will be written
        pbSource : pointer to the source string
        cbSource : count of bytes in source.
        cbByteAlign : what boundry should pcbOffset be aligned on 0, 1, 2, 4

    Returns:
        nothing
    Side effects
        none
*/

void CTemplate::CWriteTemplate::MemCopyWithWideChar
    (
    UINT *pcbOffset,
    void   *pbSource,
    ULONG cbSource,
    UINT cbByteAlign
    )
{
    ULONG cchWstr;

    // If byte alignment is necessary then align.
    Assert(cbSource);
    if (cbByteAlign > 0)
        ByteAlignOffset ((UINT *)pcbOffset, cbByteAlign);

    /*  If this is the estimation phase and the code page MaxCharSize is 1 (ASCII) then we just make the
        calculate cbWstr to be cbSource (WideChars). This is to reduce the overhead of calling into
        MultiByteToWideChar. If this is the write phase then it calls MultiByteToWideChar.
     */
    if (!m_fWriteScript)
    {
        if (m_codePageInfo.MaxCharSize == 1)
            cchWstr = cbSource;     // cbWstr is in wide chars.
        else
            cchWstr = MultiByteToWideChar (m_pTemplate->m_wCodePage, 0, (LPCSTR)pbSource, cbSource, NULL, 0);
    }
    else
    {
        cchWstr = MultiByteToWideChar (m_pTemplate->m_wCodePage, 0, (LPCSTR)pbSource, cbSource,(LPWSTR) (m_pbHeader + *pcbOffset), m_cbMemRequired - *pcbOffset);
        Assert(FImplies ((m_codePageInfo.MaxCharSize == 1), (cchWstr == cbSource)));
    }

    // Adjust offset.
    if (cchWstr)
        *pcbOffset += cchWstr *2;
}

/*  ============================================================================
    CTemplate::CWriteTemplate::RemoveHTMLCommentSuffix
    Strip of a HTML comment within script blocks

    Parameters:

    Returns:
        nothing
    Side effects
        strips trailing HTML comments from the Script.

    IMPORTANT:
    This function is similar to the one in VBSCRIPT scripting engine. The only difference is that
    the scripting team places a \0 at the end of the script because they parse the scripts independently.
    By doing the same thing we will inadvertently be terminating the script at the first point we
    notice a --> followed by a %> or a </SCRIPT>. We have two alternatives
    (a) Overwrite the entire comment with a space.
        Effects: Error Reporting will miss information
    (b) Modify the pointer in the template to place the pbCurrentOffset to the start of the Comment block.
        Effects: Yet to learn. Probarbly affect Line Number calculation

    Another Side Effect = We will be allocating more memory than we need (memory pertaining to the comment).
*/

void CTemplate::CWriteTemplate::RemoveHTMLCommentSuffix
    (
    UINT cbStartOffset,
    UINT *pcbCurrentOffset
    )
{
    UINT cbTempDataOffset = *pcbCurrentOffset;
    UINT len = (*pcbCurrentOffset -cbStartOffset)/sizeof(WCHAR);
    WCHAR * pwszSrc = (WCHAR*) (m_pTemplate->m_pbStart + cbStartOffset);

    while (len > 3 && FWhiteSpaceEx(pwszSrc[len]))
    {
        len --;
        cbTempDataOffset -= sizeof (WCHAR);
    }

    if (len < 3 || (WCHAR) L'>' != (WCHAR) pwszSrc[len--]
        || (WCHAR) L'-' != pwszSrc[len--]|| (WCHAR) L'-' != pwszSrc[len--])
        return ;

    // Saw a -->delimiter
    // Now run back until there is an EOL , a // or a <!--

    // Also there were 3 decrements of len which went unnoticed. Take them into account.
    cbTempDataOffset -= (3 * sizeof(WCHAR));

    while (len > 0)
    {
        if ((WCHAR) L'\n' == pwszSrc[len] || (WCHAR) L'\r' == pwszSrc[len])
        {
            len ++; // arrange for the character following the EOL to be overwritten with a 0
            cbTempDataOffset += sizeof (WCHAR);
            break;
        }

        if (len >= 1 && (WCHAR) L'/' == pwszSrc[len-1] && (WCHAR)L'/' == pwszSrc[len])
        {
            len --; // arrange for the first // to be overwritten with a 0
            cbTempDataOffset -= sizeof (WCHAR);
            break;
        }

        if (len >= 3 && (WCHAR) L'<' == pwszSrc[len -3] && (WCHAR) L'!' == pwszSrc[len -2]
                  &&(WCHAR) L'-' == pwszSrc[len -1] && (WCHAR) L'-' == pwszSrc[len])
         {
            len -=3; // arrange for the first < to be over written by the 0
            cbTempDataOffset -= (3* sizeof (WCHAR));
            break;
        }

        len --;
        cbTempDataOffset -= sizeof(WCHAR);
    }

    // We should add a \r\n to keep the line number calculation truthful.
    MemCopyAlign(&cbTempDataOffset, WSZ_NEWLINE, CB_NEWLINE * sizeof(WCHAR));

    //Set start of comment as currentDataOffset
    *pcbCurrentOffset = cbTempDataOffset;

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\util.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.h

Owner: AndrewS

This file contains random useful utility macros.
===================================================================*/

#ifndef _UTIL_H
#define _UTIL_H

#include <Aclapi.h>
#include <dbgutil.h>

// Generally useful
#define PPVOID VOID **
#define BOOLB BYTE

/* S E R V E R _ G E T
 *
 * Get a server variable from ISAPI.  Automatically queries for the buffer
 * size and increases the BUFFER object.
 *
 * Usage:
 *		DWORD dwLen;
 *		char *szValue = SERVER_GET(<ecb>, <szKey>, bufferObj, &dwLen)
 *
 * bufferObj is a STACK_BUFFER object than can be dynamically resized as necessary
 *
 * On return,
 *       bufferObj.QueryPtr() points to data.  dwLen is the real length of the variable.
 */
class CIsapiReqInfo;
BOOL Server_FindKey(CIsapiReqInfo *pIReq, char *szBuffer, DWORD *dwBufLen, const char *szKey);

inline BOOL SERVER_GET(CIsapiReqInfo *pIReq, const char *szKey, BUFFER *pBuffer, DWORD *pdwBufLen) {

    DWORD   dwBufLen = pBuffer->QuerySize();

    if (Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), &dwBufLen, szKey)) {
        *pdwBufLen = dwBufLen;
        return TRUE;
    }

    if (!pBuffer->Resize(dwBufLen)) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    *pdwBufLen = dwBufLen;

    return Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), pdwBufLen, szKey);
}

/* V a r i a n t R e s o l v e D i s p a t c h
 *
 * Convert an IDispatch pointer to a Variant by calling IDispatch::Invoke
 * on dispid(0) repeatedly until a non-IDispatch Variant is returned
 */

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjId);

/* V a r i a n t G e t B S T R
 *
 * Get BSTR from a variant when available
 */

BSTR VariantGetBSTR(const VARIANT *pvar);

/* F i n d A p p l i c a t i o n P a t h
 *
 *  Find the application path for this request.
 */

HRESULT FindApplicationPath(CIsapiReqInfo *pIReq, TCHAR *szPath, int cbPath);

/* N o r m a l i z e
 *
 * Convert filenames to a uniform format
 */
int Normalize(TCHAR *szSrc);
#ifdef DBG
BOOLB IsNormalized(const TCHAR* sz);
#endif	// DBG

/* H T M L E n c o d e L e n
 *
 * Returns the storage requirements to HTML encode a string.
 */
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* H T M L E n c o d e
 *
 * HTML encoeds a string.
 */
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* U R L E n c o d e L e n
 *
 * Returns the storage requirements to URL encode a string
 */
int URLEncodeLen(const char *szSrc);


/* U R L E n c o d e
 *
 * Hex escape non alphanumeric characters and change spaces to '+'.
 */
char *URLEncode(char *szDest, const char *szSrc);


/* D B C S E n c o d e L e n
 *
 * Returns the storage requirements to DBCS encode a string
 */

int DBCSEncodeLen(const char *szSrc);

/* D B C S E n c o d e
 *
 * Hex escape characters with the upper bit set - this will encode DBCS.
 */
char *DBCSEncode(char *szDest, const char *szSrc);


/* U R L P a t h E n c o d e L e n
 *
 * Returns the storage requirements to URL path encode a string
 */
int URLPathEncodeLen(const char *szSrc);


/* U R L P a t h E n c o d e
 *
 * Hex escape non alphanumeric or syntax characters until a ? is reached.
 */
char *URLPathEncode(char *szDest, const char *szSrc);


/* s t r c p y E x
 *
 * Like strcpy() but returns a pointer to the NUL character on return
 */
char *strcpyExA(char *szDest, const char *szSrc);


/* w c s c p y E x
 *
 * strcpyEx for wide strings
 */
wchar_t *strcpyExW(wchar_t *szDest, const wchar_t *szSrc);

#if UNICODE
#define strcpyEx    strcpyExW
#else
#define strcpyEx    strcpyExA
#endif

/* G e t B r a c k e t i n g P a i r
 *
 * searches an ordered array and returns the bracketing pair of 'n', i.e.
 * the largest value <= 'n', and the smallest value >= 'n', or points
 * to end() if no bracketing pair exists.
 *
 * Note: STL is not supported with NT build - when such support is added,
 *       replace this function with either 'lower_bound' or 'upper_bound'.
 */
template<class EleType, class ValType, class Ordering>
void GetBracketingPair(const ValType &value, EleType *pBegin, EleType *pEnd, Ordering FIsLess, EleType **ppLB, EleType **ppUB)
	{
	EleType *pT1, *pT2;
	if (ppLB == NULL) ppLB = &pT1;
	if (ppUB == NULL) ppUB = &pT2;

	*ppLB = pBegin;					// Temporary use to see if we've moved pBegin
	*ppUB = pEnd;					// Temporary use to see if we've moved pEnd

	while (pBegin < pEnd)
		{
		EleType *pMidpt = &pBegin[(pEnd - pBegin) >> 1];
		if (FIsLess(*pMidpt, value))
			pBegin = pMidpt + 1;

		else if (FIsLess(value, *pMidpt))
			pEnd = pMidpt;

		else
			{
			*ppLB = *ppUB = pMidpt;
			return;
			}
		}

	if (pBegin == *ppUB)		// at end, no upper bound
		{
		if (pBegin == *ppLB)	// low bound was initially equal to upper bound
			*ppLB = NULL;		// lower bound does not exits
		else
			*ppLB = pEnd - 1;	// lower bound is pEnd - 1

		*ppUB = NULL;
		}

	else if (pBegin != *ppLB)	// pBegin was moved; pBegin-1 is the lower bound
		{
		*ppLB = pBegin - 1;
		*ppUB = pBegin;
		}

	else						// pBegin was not moved - no lower bound exists
		{
		*ppLB = NULL;
		*ppUB = pBegin;
		}
	}


/* V a r i a n t D a t e T o C T i m e
 *
 * Converts a timestamp stored as a Variant date to the format C && C++ use.
 */
HRESULT VariantDateToCTime(DATE dt, time_t *ptResult);


/* C T i m e T o V a r i a n t D a t e
 *
 * Converts a timestamp stored as a time_t to a Variant Date
 */
HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult);


/* C T i m e T o S t r i n g G M T
 *
 * Converts a C language time_t value to a string using the format required for
 * the internet
 */
const DATE_STRING_SIZE = 30;	// date strings will not be larger than this size
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat = FALSE);


//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
			{\
			if (NULL!=p)\
				{\
				delete p;\
				p=NULL;\
				}\
			}

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
			{\
			if (NULL!=p)\
				{\
				p->Release();\
				p=NULL;\
				}\
			}

/*
 * String handling stuff
 */
HRESULT SysAllocStringFromSz(CHAR *sz, DWORD cch, BSTR *pbstrRet, UINT lCodePage = CP_ACP);

/*
 * A simple class to convert WideChar to Multibyte.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CWCharToMBCS
{
private:

    LPSTR    m_pszResult;
    char     m_resMemory[256];
    INT      m_cbResult;

public:

    CWCharToMBCS() { m_pszResult = m_resMemory; m_cbResult = 0; }
    ~CWCharToMBCS();

    // Init(): converts the widechar string at pWSrc to an MBCS string in memory
    // managed by CWCharToMBCS

    HRESULT Init(LPCWSTR  pWSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cbResult ? m_cbResult - 1 : 0); }
};

/*
 * A simple class to convert Multibyte to Widechar.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CMBCSToWChar
{
private:

    LPWSTR   m_pszResult;
    WCHAR    m_resMemory[256];
    INT      m_cchResult;

public:

    CMBCSToWChar() { m_pszResult = m_resMemory; m_cchResult = 0; }
    ~CMBCSToWChar();

    // Init(): converts the MBCS string at pSrc to a Wide string in memory
    // managed by CMBCSToWChar

    HRESULT Init(LPCSTR  pSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPWSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of WideChars in the converted string, not bytes.

    INT   GetStringLen() { return (m_cchResult ? m_cchResult - 1 : 0); }
};

/*
 * Output Debug String should occur in Debug only
 */

inline void DebugOutputDebugString(LPCSTR x)
    {
    DBGPRINTF((DBG_CONTEXT, x));
    }

inline void __cdecl DebugFilePrintf(LPCSTR fname, LPCSTR fmt, ...)
    {
#ifdef DBG
    FILE *f = fopen(fname, "a");
    if (f)
        {
        va_list marker;
        va_start(marker, fmt);
        vfprintf(f, fmt, marker);
        va_end(marker);
        fclose(f);
        }
#endif
    }

/*
 * Duplicate CHAR String using proper malloc (moved from error.h)
 */

CHAR *StringDupA(CHAR *pszStrIn, BOOL fDupEmpty = FALSE);


/*
 * Duplicate WCHAR String using proper malloc
 */

WCHAR *StringDupW(WCHAR *pwszStrIn, BOOL fDupEmpty = FALSE);

#if UNICODE
#define StringDup   StringDupW
#else
#define StringDup   StringDupA
#endif

/*
 * Duplicate WCHAR String into a UTF-8 string
 */
CHAR *StringDupUTF8(WCHAR  *pwszStrIn, BOOL fDupEmpty = FALSE);

/*
 * The same using macro to allocate memory from stack:

WSTR_STACK_DUP
(
wsz     -- string to copy
buf     -- user supplied buffer (to use before trying alloca())
pwszDup -- [out] the pointer to copy (could be buffer or alloca())
)

 *
 */

inline HRESULT WSTR_STACK_DUP(WCHAR *wsz, BUFFER *buf, WCHAR **ppwszDup) {

    HRESULT     hr = S_OK;
    DWORD cbwsz = wsz && *wsz ? (wcslen(wsz)+1)*sizeof(WCHAR) : 0;

    *ppwszDup = NULL;

    if (cbwsz == 0);

    else if (!buf->Resize(cbwsz)) {

        hr = E_OUTOFMEMORY;
    }
    else {
        *ppwszDup = (WCHAR *)buf->QueryPtr();
        memcpy(*ppwszDup, wsz, cbwsz);
    }

    return hr;
}

/*
 * String length (in bytes) of a WCHAR String
 */

DWORD CbWStr(WCHAR *pwszStrIn);

/*
 * Parent path support function
 */

BOOL DotPathToPath(TCHAR *szDest, const TCHAR *szFileSpec, const TCHAR *szParentDirectory);

/*
 * Check if is global.asa
 */

BOOL FIsGlobalAsa(const TCHAR *szPath, DWORD cchPath = 0);

/*
 * Encode/decode cookie
 */

HRESULT EncodeSessionIdCookie(DWORD dw1, DWORD dw2, DWORD dw3, char *pszCookie);
HRESULT DecodeSessionIdCookie(const char *pszCookie, DWORD *pdw1, DWORD *pdw2, DWORD *pdw3);

/*
 * Typelibrary name from the registry
 */

HRESULT GetTypelibFilenameFromRegistry(const char *szUUID, const char *szVersion,
                                       LCID lcid, char *szName, DWORD cbName);

/*
 * Get security descriptor for file
 */
DWORD GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength);


/*
 * Get File Attributes (Ex)
 */
HRESULT AspGetFileAttributes (LPCTSTR szFileName, HANDLE hFile = NULL, FILETIME *pftLastWriteTime = NULL, DWORD *pdwFileSize = NULL,
                                            DWORD* pdwFileAttributes = NULL);


/*
 * Is the file a UNC file (it has a \\ or a \\?\UNC\ prefix to it)
 */
BOOL IsFileUNC (LPCTSTR str, HRESULT& hr);

/*
 * Appends \\?\ and \\?\UNC\ to the filename so that no canonicalization takes place.
 */
HANDLE AspCreateFile (LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes,
    HANDLE hTemplateFile);

/*
 * Fix for UTF8 CharNext
 */
char *AspCharNextA(WORD wCodePage, const char *pchNext);

VOID AspDoRevertHack( HANDLE * phToken );
VOID AspUndoRevertHack( HANDLE * phToken );

VOID SetExplicitAccessSettings( EXPLICIT_ACCESS* pea,
                                DWORD            dwAccessPermissions,
                                ACCESS_MODE      AccessMode,
                                PSID             pSID);

DWORD AllocateAndCreateWellKnownSid( WELL_KNOWN_SID_TYPE SidType,
                                     PSID* ppSid);

VOID FreeWellKnownSid( PSID* ppSid );


/*
 * Surrogate pair encoding
 */

inline BOOL IsSurrogateHigh(WORD ch) {
    return (ch >= 0xd800 && ch <= 0xdbff);
}

inline BOOL IsSurrogateLow(WORD ch) {
    return (ch >= 0xdc00 && ch <= 0xdfff);
}

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\vecimpl.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*/

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECIMPL_H
#define VECIMPL_H


#define VEC_GROW_SIZE 64		// grow in chunks of this many items
#define __vec_rounded_size(s) \
			(((s) + (VEC_GROW_SIZE - 1)) & ~(VEC_GROW_SIZE - 1))


template <class TYPE>
vector<TYPE>::vector() : m_rgData(NULL), m_cItems(0), m_cCells(0)
{
}


template <class TYPE>
HRESULT vector<TYPE>::Init(const TYPE *anArray, size_t theSize)
{
	m_cCells = __vec_rounded_size(theSize);

	register size_t      n     = m_cItems = theSize;
	register TYPE *      pDest = m_rgData = new TYPE[m_cCells];
	register const TYPE *pSrc  = anArray;

	if (pDest == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	while (n--)
		*pDest++ = *pSrc++;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::Init(size_t n)
{
	m_rgData = new TYPE[m_cCells = __vec_rounded_size(m_cItems = n)];
	if (m_rgData == NULL)
		{
		m_cItems = m_cCells = 0;
		return E_OUTOFMEMORY;
		}

	return S_OK;
}


template <class TYPE>
vector<TYPE>::~vector()
{
	delete[] m_rgData;
}


template <class TYPE>
HRESULT vector<TYPE>::resize(size_t cNewCells)
{
	cNewCells = __vec_rounded_size(cNewCells);
	if (m_cCells == cNewCells)
		return S_OK;

	TYPE *rgData = new TYPE[cNewCells];
	if (rgData == NULL)
		return E_OUTOFMEMORY;

	register size_t      n     = (m_cItems < cNewCells)? m_cItems : cNewCells;
	register TYPE *      pDest = rgData;
	register const TYPE *pSrc  = m_rgData;

	m_cItems = n;
	m_cCells = cNewCells;

	while (n--)
		*pDest++ = *pSrc++;

	delete[] m_rgData;
	m_rgData = rgData;

	return S_OK;
}


template <class TYPE>
HRESULT vector<TYPE>::reshape(size_t cNewItems)
{
	HRESULT hrRet = S_OK;
	if (cNewItems > m_cCells)
		hrRet = resize(cNewItems);

	if (SUCCEEDED(hrRet))
		m_cItems = cNewItems;

	return hrRet;
}


template <class TYPE>
HRESULT vector<TYPE>::insertAt(size_t pos, const TYPE &item)
{
	Assert (pos <= m_cItems);

	HRESULT hrRet = S_OK;
	if ((m_cItems + 1) > m_cCells)
		hrRet = resize(m_cCells + VEC_GROW_SIZE);

	if (SUCCEEDED(hrRet))
		{
		TYPE *pDest = &m_rgData[pos];
		for (register TYPE *ptr = &m_rgData[m_cItems];
			 ptr > pDest;
			 --ptr)
			*ptr = *(ptr - 1);

		*pDest = item;
		++m_cItems;
		}

	return hrRet;
}


template <class TYPE>
TYPE vector<TYPE>::removeAt(size_t pos)
{
	Assert (pos < m_cItems);

	TYPE *         end = &m_rgData[--m_cItems];
	register TYPE *ptr = &m_rgData[pos];
	TYPE           val = *ptr;

	for (; ptr < end; ++ptr)
		*ptr = *(ptr + 1);

	return val;
}


template <class TYPE>
int vector<TYPE>::find(const TYPE &item) const
{
	for (register unsigned i = 0; i < m_cItems; ++i)
		if (item == m_rgData[i])
			return i;

	return -1;
}

#endif /* VECIMPL */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\addesc.cpp ===
// AdDesc.cpp: implementation of the CAdDescriptor class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "AdRot.h"
#include "AdDesc.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAdDescriptor::CAdDescriptor(
	ULONG	lWeight,
	String	strLink,
	String	strGif,
	String	strAlt )
	:	m_lWeight( lWeight ),
		m_strLink( strLink ),
		m_strGif( strGif ),
		m_strAlt( strAlt )
{

}

CAdDescriptor::~CAdDescriptor()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\viperint.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.cpp

Owner: DmitryR

This file contains the implementation of viper integration classes
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "Context.h"
#include "package.h"
#include "memchk.h"
#include "denali.h"
#include "perfdata.h"
#include "etwtrace.hxx"

extern HDESK ghDesktop;

//
// COM holds the last reference to a CViperAsyncRequest
// we need to track these objects to ensure that we don't
// exit before the activity threads have released them.
//

volatile LONG g_nViperRequests = 0;

LONG    g_nThreadsExecuting = 0;

CViperReqManager    g_ViperReqMgr;
DWORD   g_ReqDisconnected = 0;

BOOL g_fFirstMTAHit = TRUE;
BOOL g_fFirstSTAHit = TRUE;

extern CRITICAL_SECTION g_csFirstMTAHitLock;
extern CRITICAL_SECTION g_csFirstSTAHitLock;

#if REFTRACE_VIPER_REQUESTS
PTRACE_LOG CViperAsyncRequest::gm_pTraceLog=NULL;
#endif


/*===================================================================
  C  V i p e r  A s y n c R e q u e s t
===================================================================*/

/*===================================================================
CViperAsyncRequest::CViperAsyncRequest

CViperAsyncRequest constructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::CViperAsyncRequest()
    : m_cRefs(1),
      m_pHitObj(NULL),
      m_hrOnError(S_OK),
      m_pActivity(NULL),
      m_fTestingConnection(0),
      m_dwRepostAttempts(0),
      m_fAsyncCallPosted(0)
{
#if DEBUG_REQ_SCAVENGER
    DBGPRINTF((DBG_CONTEXT, "CViperAsyncRequest::CViperAsyncRequest (%p)\n", this));
#endif

#if REFTRACE_VIPER_REQUESTS
    WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
#endif

    InterlockedIncrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::~CViperAsyncRequest

CViperAsyncRequest destructor

Parameters:

Returns:
===================================================================*/	
CViperAsyncRequest::~CViperAsyncRequest()
{
#if DEBUG_REQ_SCAVENGER
    DBGPRINTF((DBG_CONTEXT, "CViperAsyncRequest::~CViperAsyncRequest (%p)\n", this));
#endif
    InterlockedDecrement( (LONG *)&g_nViperRequests );
}

/*===================================================================
CViperAsyncRequest::Init

Initialize CViperAsyncRequest with CHitObj object

Parameters:
    CHitObj       *pHitObj       Denali HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperAsyncRequest::Init
(
CHitObj           *pHitObj,
IServiceActivity  *pActivity
)
    {
    Assert(m_pHitObj == NULL);

    m_pHitObj = pHitObj;
    m_pActivity = pActivity;
    m_fBrowserRequest = pHitObj->FIsBrowserRequest();
    m_dwLastTestTimeStamp = GetTickCount();

    // establish the timeout value for this request.  It will be a factor
    // of the configured QueueConnectionTestTime.  In proc, it will be
    // this value times 2, and out of proc it will be multiplied by 4.
    // NOTE if the QueueConnectionTestTime is zero, we'll use hard
    // constants 12 and 6 for oop and inproc, respectively.

    DWORD   dwQueueConnectionTestTime = pHitObj->PAppln()->QueryAppConfig()->dwQueueConnectionTestTime();
    m_dwTimeout = dwQueueConnectionTestTime
        ? dwQueueConnectionTestTime * (g_fOOP ? 4 : 2)
        : g_fOOP ? 12 : 6;

    return S_OK;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperAsyncRequest::AssertValid() const
    {
    Assert(m_pHitObj);
    Assert(m_cRefs > 0);
    }
#endif

/*===================================================================
CViperAsyncRequest::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::QueryInterface
(
REFIID iid,
void **ppv
)
{
	if (iid == IID_IUnknown || iid == IID_IServiceCall) {
		*ppv = this;
	    AddRef();
		return S_OK;
    }
    else if (iid == IID_IAsyncErrorNotify) {
        *ppv =  static_cast<IAsyncErrorNotify *>(this);
        AddRef();
        return S_OK;
    }

	return E_NOINTERFACE;
}

/*===================================================================
CViperAsyncRequest::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::AddRef()
    {

    LONG    refs = InterlockedIncrement(&m_cRefs);
#if REFTRACE_VIPER_REQUESTS
    WriteRefTraceLog(gm_pTraceLog, refs, this);
#endif

	return refs;
    }

/*===================================================================
CViperAsyncRequest::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperAsyncRequest::Release()
    {
    LONG  refs = InterlockedDecrement(&m_cRefs);

#if REFTRACE_VIPER_REQUESTS
    WriteRefTraceLog(gm_pTraceLog, refs, this);
#endif

	if (refs != 0)
		return refs;

	delete this;
	return 0;
    }

/*===================================================================
CViperAsyncRequest::OnCall

IMTSCall method implementation. This method is called by Viper
from the right thread when it's time to process a request

Parameters:

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::OnCall()
    {
    Assert(m_pHitObj);
    CIsapiReqInfo *pIReq;
    HCONN   ConnId = 0;

    InterlockedIncrement(&g_nThreadsExecuting);

    // check to see if the request has been removed from the queue
    // already.  If so, get out of here quick.

    if (g_ViperReqMgr.RemoveReqObj(this) == FALSE) {
        Release();
        InterlockedDecrement(&g_nThreadsExecuting);
        return S_OK;
    }

    pIReq = m_pHitObj->PIReq();

    BOOL fRequestReposted = FALSE;

    // add an extra addref here to prevent the deletion of the
    // hitobj deleting the CIsapiReqInfo for this request.

    if (pIReq) {
        pIReq->AddRef();

        //
        // Add an ETW trace event when the request is getting processed.
        //
        if (ETW_IS_TRACE_ON(ETW_LEVEL_CP) && g_pEtwTracer ) {

            ConnId = pIReq->ECB()->ConnID;

            g_pEtwTracer->EtwTraceEvent(&AspEventGuid,
                                      EVENT_TRACE_TYPE_START,
                                      &ConnId, sizeof(HCONN),
                                      NULL, 0);
        }
    }

    m_pHitObj->ViperAsyncCallback(&fRequestReposted);

    // Make sure there always is DONE_WITH_SESSION
    if (m_pHitObj->FIsBrowserRequest() && !fRequestReposted)
    {
        if (!m_pHitObj->FDoneWithSession())
            m_pHitObj->ReportServerError(IDE_UNEXPECTED);
    }

    if (!fRequestReposted)
        delete m_pHitObj;   // don't delete if reposted


    m_pHitObj = NULL;       // set to NULL even if not deleted
    Release();              // release this, Viper holds another ref

    //
    // Add an ETW event when we are done with the request
    //

    if (pIReq)  {
        if ( ETW_IS_TRACE_ON(ETW_LEVEL_CP) && g_pEtwTracer) {

            g_pEtwTracer->EtwTraceEvent(&AspEventGuid,
                                      ETW_TYPE_END,
                                      &ConnId, sizeof(HCONN),
                                      NULL, 0);
        }
        pIReq->Release();
    }

    InterlockedDecrement(&g_nThreadsExecuting);

    return S_OK;
    }

/*===================================================================
CViperAsyncRequest::OnError

Called by COM+ when it is unable to dispatch the request properly
on the configured thread

Parameters:

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperAsyncRequest::OnError(HRESULT hrViperError)
{
    Assert(m_pHitObj);
    CIsapiReqInfo *pIReq;
    HRESULT     hr = S_OK;

    // check to see if the request has been removed from the queue
    // already.  If so, get out of here quick.

    if (g_ViperReqMgr.RemoveReqObj(this) == FALSE) {
        Release();
        return S_OK;
    }

    pIReq = m_pHitObj->PIReq();

    if (pIReq)
        pIReq->AddRef();

    m_dwRepostAttempts++;

    // attempt to repost the request if it hasn't errored out three
    // times yet.

    if (m_dwRepostAttempts <= 3) {

        hr = m_pActivity->AsynchronousCall(this);

        Assert(SUCCEEDED(hr));
    }

    // if it has errored out three times or the repost failed,
    // pitch the request

    if (FAILED(hr) || (m_dwRepostAttempts > 3)) {

        // DONE_WITH_SESSION -- ServerSupportFunction
        // does not need bracketing
        if (m_pHitObj->FIsBrowserRequest())
            m_pHitObj->ReportServerError(IDE_UNEXPECTED);

        // We never called to process request, there should
        // be no state and it's probably save to delete it
        // outside of bracketing

        delete m_pHitObj;

        m_pHitObj = NULL;       // set to NULL even if not deleted
        Release();              // release this, Viper holds another ref
    }

    if (pIReq)
        pIReq->Release();

    return S_OK;
}

DWORD CViperAsyncRequest::SecsSinceLastTest()
{
    DWORD dwt = GetTickCount();
    if (dwt >= m_dwLastTestTimeStamp)
        return ((dwt - m_dwLastTestTimeStamp)/1000);
    else
        return (((0xffffffff - m_dwLastTestTimeStamp) + dwt)/1000);
}

/*===================================================================
  C  V i p e r  A c t i v i t y
===================================================================*/

/*===================================================================
CViperActivity::CViperActivity

CViperActivity constructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::CViperActivity()
    : m_pActivity(NULL), m_cBind(0)
    {
    }

/*===================================================================
CViperActivity::~CViperActivity

CViperActivity destructor

Parameters:

Returns:
===================================================================*/	
CViperActivity::~CViperActivity()
    {
    UnInit();
    }

/*===================================================================
CViperActivity::Init

Create actual Viper activity using MTSCreateActivity()

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::Init(IUnknown  *pServicesConfig)
    {
    Assert(!FInited());

    HRESULT hr = S_OK;

    hr = CoCreateActivity(pServicesConfig, IID_IServiceActivity,  (void **)&m_pActivity);

    if (FAILED(hr))
        return hr;

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::InitClone

Clone Viper activity (AddRef() it)

Parameters:
    CViperActivity *pActivity   activity to clone from

Returns:
    HRESULT
===================================================================*/
HRESULT CViperActivity::InitClone
(
CViperActivity *pActivity
)
    {
    Assert(!FInited());
    Assert(pActivity);
    pActivity->AssertValid();

    m_pActivity = pActivity->m_pActivity;
    m_pActivity->AddRef();

    m_cBind = 1;
    return S_OK;
    }

/*===================================================================
CViperActivity::UnInit

Release Viper activity

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnInit()
    {
    if (m_pActivity)
        {
        while (m_cBind > 1)  // 1 is for inited flag
            {
            m_pActivity->UnbindFromThread();
            m_cBind--;
            }

        m_pActivity->Release();
        m_pActivity = NULL;
        }

    m_cBind = 0;
    return S_OK;
    }

/*===================================================================
CViperActivity::BindToThread

Bind Activity to current thread using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::BindToThread()
    {
    Assert(FInited());

    m_pActivity->BindToCurrentThread();
    m_cBind++;

    return S_OK;
    }

/*===================================================================
CViperActivity::UnBindFromThread

UnBind Activity from using IMTSActivity method

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::UnBindFromThread()
    {
    Assert(FInited());
    Assert(m_cBind > 1);

    m_pActivity->UnbindFromThread();
    m_cBind--;

    return S_OK;
    }

/*===================================================================
CViperActivity::PostAsyncRequest

Call HitObj Async.
Creates IMTSCCall object to do it.

Parameters:
    CHitObj      *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostAsyncRequest
(
CHitObj *pHitObj
)
    {
    AssertValid();

    HRESULT hr = S_OK;

    CViperAsyncRequest *pViperCall = new CViperAsyncRequest;
    if (!pViperCall)
         hr = E_OUTOFMEMORY;
    else
         hr = pViperCall->Init(pHitObj, m_pActivity);


    // Revert to Self before exiting so that it will be in a consistent (impersonated) state
    // when it leaves this function.
	RevertToSelf();
	
    // hr here can be either S_OK or E_OUTOFMEMORY both cases are handled in the last IF.
    // if (FAILED(hr) && pViperCall). However, if Init ever returns an HR other than S_OK we
    // will need to place a return right here.
    if (FAILED(hr))
    {
        if (pViperCall)
            pViperCall->Release();

        return hr;
    }

    //
    // Make the locking of the light weight queue and the subsequent queuing to COM atomic
    //
    g_ViperReqMgr.LockQueue();

    hr = g_ViperReqMgr.AddReqObj(pViperCall);

    //
    // Assume that the ViperAsyncCall will succeed and set it the POSTed flag,
    // if it fails then cleanup. This avoids a race condition where the object is touched after we
    // have posted to request to Viper and it has deleted the object.
    //
    if (SUCCEEDED(hr))
    {
        pViperCall->SetAsyncCallPosted();
        hr = m_pActivity->AsynchronousCall(pViperCall);
    }

    //
    // We can release the lock as the request has now been queued to COM
    //
    g_ViperReqMgr.UnlockQueue();

    //
    // If we added it to the queue and the async call failed we have to be sure
    // that the watch thread did not remove the object off the light weight queue.
    // If RemoveReqObj returns false the watch thread has done the needful.
    //
    if (FAILED(hr) && g_ViperReqMgr.RemoveReqObj(pViperCall))
    {  // cleanup if AsyncCall failed
        pViperCall->ClearAsyncCallPosted();
        pViperCall->Release();
    }

    return hr;
}

/*===================================================================
CViperActivity::PostGlobalAsyncRequest

Static method.
Post async request without an activity.
Creates temporary activity

Parameters:
    CHitObj *pHitObj    Denali's HitObj

Returns:
    HRESULT
===================================================================*/	
HRESULT CViperActivity::PostGlobalAsyncRequest
(
CHitObj *pHitObj
)
    {
    HRESULT hr = S_OK;

    CViperActivity *pTmpActivity = new CViperActivity;
    if (!pTmpActivity)
         hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = pTmpActivity->Init(pHitObj->PAppln()->PServicesConfig());

    if (SUCCEEDED(hr))
        {
        // remember this activity as HitObj's activity
        // HitObj will get rid of it on its destructor
        pHitObj->SetActivity(pTmpActivity);

        hr = pTmpActivity->PostAsyncRequest(pHitObj);

        pTmpActivity = NULL; // don't delete, HitObj will
        }

    if (pTmpActivity)
        delete pTmpActivity;

    return hr;
    }

#ifdef DBG
/*===================================================================
CViperAsyncRequest::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperActivity::AssertValid() const
	{
    Assert(FInited());
	Assert(m_pActivity);
	}
#endif

#ifdef UNUSED
/*===================================================================
  C  V i p e r  T h r e a d E v e n t s
===================================================================*/

/*===================================================================
CViperThreadEvents::CViperThreadEvents

CViperThreadEvents constructor

Parameters:

Returns:
===================================================================*/	
CViperThreadEvents::CViperThreadEvents()
    : m_cRefs(1)
    {
    }

#ifdef DBG
/*===================================================================
CViperThreadEvents::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CViperThreadEvents::AssertValid() const
    {
    Assert(m_cRefs > 0);
    Assert(ghDesktop != NULL);
    }
#endif

/*===================================================================
CViperThreadEvents::QueryInterface

Standard IUnknown method

Parameters:
    REFIID iid
    void **ppv

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::QueryInterface
(
REFIID iid,
void **ppv
)
    {
	if (iid == IID_IUnknown || iid == IID_IThreadEvents)
	    {
		*ppv = this;
	    AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
    }

/*===================================================================
CViperThreadEvents::AddRef

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);
    return cRefs;
    }

/*===================================================================
CViperThreadEvents::Release

Standard IUnknown method

Parameters:

Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CViperThreadEvents::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

	delete this;
	return 0;
    }

/*===================================================================
CViperThreadEvents::OnStartup

IThreadEvents method implementation. This method is called by Viper
whenever they start up a thread.

Parameters:
	None

Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnStartup()
    {
    HRESULT hr;

    AssertValid();

	// Set the desktop for this thread
	hr = SetDesktop();
	
    return hr;
    }

/*===================================================================
CViperThreadEvents::OnShutdown

IThreadEvents method implementation. This method is called by Viper
whenever they shut down a thread.

Parameters:
	None
	
Returns:
    HRESULT
===================================================================*/
STDMETHODIMP CViperThreadEvents::OnShutdown()
    {
    AssertValid();

    return S_OK;
    }
#endif //UNUSED

/*===================================================================
  C  V i p e r  A c t i v i t y
===================================================================*/

/*===================================================================
CViperReqManager::CViperReqManager

Parameters:
	
Returns:
    VOID

===================================================================*/
CViperReqManager::CViperReqManager()
{
    m_dwReqObjs = 0;
    m_fCsInited = FALSE;
    m_fCsQueueInited = FALSE;
    m_fShutdown = FALSE;
    m_fDisabled = FALSE;
    m_hThreadAlive = NULL;
    m_hWakeUpEvent = NULL;
}

/*===================================================================
CViperReqManager::Init

Parameters:
	
Returns:
    HRESULT

===================================================================*/
HRESULT CViperReqManager::Init()
{
    HRESULT hr = S_OK;
    DWORD   dwRegValue;

    if (m_fDisabled == TRUE)
        return S_OK;

    m_dwQueueMin = Glob(dwRequestQueueMax) / (g_fOOP ? 5 : 10);
    m_dwLastAwakened = GetTickCount()/1000;
    m_dwQueueAlwaysWakeupMin = (Glob(dwRequestQueueMax)*80)/100;

#if REFTRACE_VIPER_REQUESTS
    CViperAsyncRequest::gm_pTraceLog = CreateRefTraceLog(10000, 0);
#endif

    ErrInitCriticalSection(&m_csLock, hr);

    if (SUCCEEDED(hr)) {
        m_fCsInited = TRUE;

        ErrInitCriticalSection(&m_csQueueLock, hr);
        if (SUCCEEDED(hr))
        {
            m_fCsQueueInited = TRUE;

            m_hWakeUpEvent = IIS_CREATE_EVENT("CViperReqManager::m_hWakeUpEvent",
                                          this,
                                          TRUE,      // flag for manual-reset event
                                          FALSE);    // flag for initial state
            if (!m_hWakeUpEvent)
                hr = E_OUTOFMEMORY;
        }
    }

    if (SUCCEEDED(hr)) {

        m_hThreadAlive = CreateThread(NULL, 0, CViperReqManager::WatchThread, 0, 0, NULL);

        if (!m_hThreadAlive) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
    }

    if (FAILED(hr) && m_hWakeUpEvent)
        CloseHandle(m_hWakeUpEvent);

    if (SUCCEEDED(g_AspRegistryParams.GetF5AttackValue(&dwRegValue)))
        m_fDisabled = !dwRegValue;

    return hr;
}

/*===================================================================
CViperReqManager::UnInit

Parameters:
	
Returns:
    HRESULT

===================================================================*/
HRESULT CViperReqManager::UnInit()
{
    HRESULT hr = S_OK;

    if (m_fDisabled == TRUE)
        return S_OK;

    // mark that we're in shutdown

    m_fShutdown = TRUE;

#if REFTRACE_VIPER_REQUESTS
    DestroyRefTraceLog(CViperAsyncRequest::gm_pTraceLog);
#endif

    // if the watch thread is still alive, wake it up and wait for
    // it to die off

    if (m_hThreadAlive)
    {
        WakeUp(TRUE);

        if (WaitForSingleObject (m_hThreadAlive, INFINITE) == WAIT_FAILED)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        CloseHandle (m_hThreadAlive);

        m_hThreadAlive = NULL;
    }

    if (m_fCsInited)
    {
        DeleteCriticalSection(&m_csLock);
    }

    if (m_fCsQueueInited)
    {
        DeleteCriticalSection(&m_csQueueLock);
    }

    if (m_hWakeUpEvent)
        CloseHandle(m_hWakeUpEvent);

    m_hWakeUpEvent = NULL;

    return hr;
}

/*===================================================================
CViperReqManager::WatchThread

Parameters:
	
Returns:
    DWORD

This thread is awakened to search for queued requests that should
be tested to see if they still have connected clients on the other
end.

::GetNext() is the key routine called to access a queued request.
::GetNext() will determine if there are requests that should be
tested and return only those.

===================================================================*/
DWORD __stdcall CViperReqManager::WatchThread(VOID  *pArg)
{
    DWORD dwReqsToTest              = Glob(dwRequestQueueMax)/10;
    DWORD dwF5AttackThreshold       = (Glob(dwRequestQueueMax)*90)/100;

    // live in a do-while loop

    do {

        CViperAsyncRequest *pViperReq = NULL;
        CViperAsyncRequest *pNextViperReq = NULL;

        BOOL    fTestForF5Attack   = FALSE;
        DWORD   dwReqsDiscToCont   = 0;
        DWORD   dwReqsDisconnected = 0;
        DWORD   dwReqsTested       = 0;

        // wait for single object

        ResetEvent(g_ViperReqMgr.m_hWakeUpEvent);

        // check for shutdown

        if (g_ViperReqMgr.m_fShutdown)
            goto LExit;

        WaitForSingleObject(g_ViperReqMgr.m_hWakeUpEvent, INFINITE);

        g_ViperReqMgr.m_dwLastAwakened = GetTickCount()/1000;

        // check for shutdown

        if (g_ViperReqMgr.m_fShutdown)
            goto LExit;

        // determine the type of cleanup we're going to perform

        if (g_ViperReqMgr.m_dwReqObjs >= dwF5AttackThreshold) {

            // testing for a possible F5Attack.  This will cause this loop
            // to test the most recently received requests to check for a large
            // number of disconnected requests.  We'll test each 10% of the queue
            // to see if at least 75% of the requests are disconnected.  If 75% or
            // more are disconnected, then we'll test the next 10%.  If less than
            // 75%, then we aren't under an F5Attack and will stop testing for an
            // F5Attack.

#if DEBUG_REQ_SCAVENGER
            DBGPRINTF((DBG_CONTEXT, "CViperReqManager::WatchThread - testing for F5Attack\r\n"));
#endif
            fTestForF5Attack    = TRUE;
            dwReqsDiscToCont    = (dwReqsToTest * 75)/100;
            dwReqsDisconnected  = 0;
            dwReqsTested        = 0;
        }
        else {

            // not testing for F5Attack.  We will test all requests that have
            // been on the queue for the minimum amount of time - 5 seconds if
            // inproc, else 10 seconds.

#if DEBUG_REQ_SCAVENGER
            DBGPRINTF((DBG_CONTEXT, "CViperReqManager::WatchThread - NOT testing for F5Attack\r\n"));
#endif
            fTestForF5Attack    = FALSE;
        }

        // get the first request that is a candidate for testing

        pNextViperReq = g_ViperReqMgr.GetNext(NULL, fTestForF5Attack);

        // process all the available

        while (pViperReq = pNextViperReq) {

            // AddRef here to make sure the ViperReq object doesn't go away
            // on the STA thread underneath of us.

            pViperReq->AddRef();

            // check again for shutdown.  GetNext() sets the testing
            // connection flag

            if (g_ViperReqMgr.m_fShutdown) {
                pViperReq->ClearTestingConnection();
                pViperReq->Release();
                goto LExit;
            }

            // if testing for F5Attack, check to see if we've tested the first
            // 10% of the requests on the list.  If so, see if we've found that
            // 75% of them were disconnected.  If not, then break.  We're not under
            // attack.  Otherwise, continue testing.

            if (fTestForF5Attack && (dwReqsTested == dwReqsToTest)) {

                if (dwReqsDisconnected < dwReqsDiscToCont) {

#if DEBUG_REQ_SCAVENGER
                    DBGPRINTF((DBG_CONTEXT, "CViperReqManager::WatchThread - 75% of requests NOT disconnected.  Stopping.\r\n"));
#endif
                    // didn't see 75%, bail
                    pViperReq->ClearTestingConnection();
                    pViperReq->Release();
                    break;
                }

#if DEBUG_REQ_SCAVENGER
                DBGPRINTF((DBG_CONTEXT, "CViperReqManager::WatchThread - 75% of requests disconnected.  Continuing.\r\n"));
#endif
                // at least 75% were disconnected.  Reset running counters
                // and continue

                dwReqsDisconnected  = 0;
                dwReqsTested        = 0;
            }

            dwReqsTested++;

            BOOL    fConnected = TRUE;

            //
            // test the connection but do so only after we are sure it has been queued to COM
            //
            g_ViperReqMgr.LockQueue();

            if (!pViperReq->PHitObj()->PIReq()->TestConnection(&fConnected))
                fConnected = TRUE;

            g_ViperReqMgr.UnlockQueue();

#if DEBUG_REQ_SCAVENGER
            DBGPRINTF((DBG_CONTEXT, "CViperReqManager::WatchThread. Tested - %S (%s) (%p,%p)\n",
                                    pViperReq->PHitObj()->PSzCurrTemplateVirtPath(),
                                    fConnected ? "TRUE" : "FALSE",
                                    pViperReq,
                                    pViperReq->PHitObj()));
#endif
            // get the next request.  This will leave two requests locked for
            // testing.  We have to get the next request here because we may
            // remove it below.

            pNextViperReq = g_ViperReqMgr.GetNext(pViperReq,fTestForF5Attack);

            // now check fConnected

            if (!fConnected) {

                g_ReqDisconnected++;
                dwReqsDisconnected++;

                // not connected.  Forceably remove the request from the queue.
                // Passing TRUE ignores the fTestingConnection test.

                DBG_REQUIRE(g_ViperReqMgr.RemoveReqObj(pViperReq,TRUE) == TRUE);

                // do the stuff we do in CHitObj::RejectBrowserRequestWhenNeeded().

                pViperReq->PHitObj()->SetFExecuting(FALSE);
                pViperReq->PHitObj()->ReportServerError(IDE_500_SERVER_ERROR);
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQCOMFAILED();
                g_PerfData.Decr_REQCURRENT();
#endif
                delete pViperReq->PHitObj();
            }
            else {
                // still connected.  Update the test stamp and release the testing
                // bit

                pViperReq->UpdateTestTimeStamp();
                pViperReq->ClearTestingConnection();
            }
            pViperReq->Release();
        }
    // we'll exit the loop here as well if shutdown becomes true.
    } while(g_ViperReqMgr.m_fShutdown == FALSE);

LExit:

    //
    // the thread is going away.
    //
    return 0;
}

/*===================================================================
CViperReqManager::AddReqObj

Parameters:
    CViperAsyncRequest  *pReqObj - request to add to queue
	
Returns:
    HRESULT - always returns S_OK

===================================================================*/
HRESULT CViperReqManager::AddReqObj(CViperAsyncRequest   *pReqObj)
{
    HRESULT hr = S_OK;
#if DEBUG_REQ_SCAVENGER
    DWORD   curObjs;
#endif

    if (m_fDisabled == TRUE)
        return S_OK;

    // don't track non-browser requests

    if (pReqObj->FBrowserRequest() == FALSE)
        return S_OK;

    // lock the queue and add the object

    Lock();
    pReqObj->AppendTo(m_ReqObjList);
    m_dwReqObjs++;
#if DEBUG_REQ_SCAVENGER
    curObjs = m_dwReqObjs;
#endif
    Unlock();

#if DEBUG_REQ_SCAVENGER
    DBGPRINTF((DBG_CONTEXT, "CViperReqManager::AddReqObj (%p). Total = %d\r\n", pReqObj, curObjs));
#endif
    // for now, wake up the watch thread everytime.

    WakeUp();

    return hr;
}

/*===================================================================
CViperReqManager::RemoveReqObj

Parameters:
    CViperAsyncRequest  *pReqObj - request to remove from the queue
    BOOL                fForce - remove regardless of testing state
	
Returns:
    BOOL    - TRUE if req was on list, else FALSE

===================================================================*/
BOOL CViperReqManager::RemoveReqObj(CViperAsyncRequest   *pReqObj, BOOL fForce)
{
    BOOL    fOnList = FALSE;
#if DEBUG_REQ_SCAVENGER
    DWORD   curObjs;
#endif

    if (m_fDisabled == TRUE)
        return TRUE;

    // if not a browser request, then this queue isn't tracking it.
    // It's safe to return TRUE

    if (pReqObj->FBrowserRequest() == FALSE)
        return TRUE;

    // can't remove the object from the queue if it is currently
    // being tested.  The exception being if fForce is passed.  This
    // is passed only by the WatchThread.

sleepAgain:
    while((fForce != TRUE) && pReqObj->FTestingConnection())
        Sleep(100);

    // lock and remove the request

    Lock();

    // check to see if after we got the lock, the request is now
    // being tested.  If so, unlock and return to sleeping.

    if ((fForce != TRUE) && pReqObj->FTestingConnection()) {
        Unlock();
        goto sleepAgain;
    }

    // now see if it's on the queue.  If FIsEmpty(), then it's not
    // on the list.
    if (pReqObj->FIsEmpty()) {
        fOnList = FALSE;
    }
    else {
        // if it is, Unlink it.  Call ClearTestingConnection to release
        // any other calls to RemoveReqObj that may be waiting.  Of course
        // they all will see that the item is no longer on the list.

        fOnList = TRUE;
        pReqObj->UnLink();
        pReqObj->ClearTestingConnection();
        m_dwReqObjs--;
    }
#if DEBUG_REQ_SCAVENGER
    curObjs = m_dwReqObjs;
#endif
    Unlock();

#if DEBUG_REQ_SCAVENGER
    DBGPRINTF((DBG_CONTEXT, "CViperReqManager::RemoveReqObj (%p). fOnList = %d; Total = %d\r\n", pReqObj, fOnList, curObjs));
#endif

    // wakeup everytime for now...

    WakeUp();

    return fOnList;
}

/*===================================================================
CViperReqManager::GetNext

Parameters:
    CViperAsyncRequest  *pLastReq - position in queue.
	
Returns:
    CViperAsyncRequest* - non-NULL if request to test, else end of list

===================================================================*/
CViperAsyncRequest   *CViperReqManager::GetNext(CDblLink  *pLastReq, BOOL fTestForF5Attack)
{
    CViperAsyncRequest  *pViperReq = NULL;

    // if NULL was passed in, then start from the head of the queue.

    if (pLastReq == NULL)
        pLastReq = &m_ReqObjList;

    // lock the queue while we find the next candidate

    Lock();

    if (fTestForF5Attack == TRUE) {

        // get the next request on the list

        pViperReq = static_cast<CViperAsyncRequest*>(pLastReq->PPrev());

        // enter a while loop until we either get to the end of the list or we find
        // a request has been posted to the viper queue

        while((pViperReq != &m_ReqObjList)
               && (pViperReq->FAsyncCallPosted() == FALSE))
            pViperReq = static_cast<CViperAsyncRequest*>(pViperReq->PPrev());

    }
    else {

        // get the next request on the list

        pViperReq = static_cast<CViperAsyncRequest*>(pLastReq->PNext());

        // enter a while loop until we either get to the end of the list or we find
        // a request that hasn't been tested in dwTimeout() and has been posted
        // to the viper queue

        while((pViperReq != &m_ReqObjList)
              && ((pViperReq->SecsSinceLastTest() < pViperReq->dwTimeout())
                   || (pViperReq->FAsyncCallPosted() == FALSE)))
            pViperReq = static_cast<CViperAsyncRequest*>(pViperReq->PNext());
    }

    // if we found a candidate, set the TestingConnection flag

    if (pViperReq != &m_ReqObjList) {
        pViperReq->SetTestingConnection();
    }
    else {
        // ended up at the queue head.  Return NULL.
        pViperReq = NULL;
    }

    Unlock();

    return pViperReq;
}

/*===================================================================
  G l o b a l  F u n c t i o n s
===================================================================*/

/*===================================================================
ViperSetContextProperty

Static utility function.

Set Viper context property by BSTR and IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    IContextProperties *pContextProperties       Context
    BSTR                bstrPropertyName         Name
    IDispatch          *pdispPropertyValue       Value

Returns:
    HRESULT
===================================================================*/
static HRESULT ViperSetContextProperty
(
IContextProperties *pContextProperties,
BSTR                bstrPropertyName,
IDispatch          *pdispPropertyValue
)
    {
    // Make VARIANT from IDispatch*

    pdispPropertyValue->AddRef();

    VARIANT Variant;
    VariantInit(&Variant);
    V_VT(&Variant) = VT_DISPATCH;
    V_DISPATCH(&Variant) = pdispPropertyValue;

    // Call Viper to set the property

    HRESULT hr = pContextProperties->SetProperty
        (
        bstrPropertyName,
        Variant
        );

    // Cleanup

    VariantClear(&Variant);

    return hr;
    }

/*===================================================================
ViperAttachIntrinsicsToContext

Attach ASP intrinsic objects as Viper context properties

Parameters - Intrinsics as interface pointers
    IApplicationObject *pAppln      Application   (required)
    ISessionObject     *pSession    Session       (optional)
    IRequest           *pRequest    Request       (optional)
    IResponse          *pResponse   Response      (optional)
    IServer            *pServer     Server        (optional)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperAttachIntrinsicsToContext
(
IApplicationObject *pAppln,
ISessionObject     *pSession,
IRequest           *pRequest,
IResponse          *pResponse,
IServer            *pServer
)
    {
    Assert(pAppln);

    HRESULT hr = S_OK;

    // Get Viper Context

    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties,
   		    (void **)&pContextProperties
   		    );

    // Set properties

    if (SUCCEEDED(hr))
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_APPLICATION,
            pAppln
            );

    if (SUCCEEDED(hr) && pSession)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SESSION,
            pSession
            );

    if (SUCCEEDED(hr) && pRequest)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_REQUEST,
            pRequest
            );

    if (SUCCEEDED(hr) && pResponse)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_RESPONSE,
            pResponse
            );

    if (SUCCEEDED(hr) && pServer)
        hr = ViperSetContextProperty
            (
            pContextProperties,
            BSTR_OBJ_SERVER,
            pServer
            );

    // Cleanup

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    return hr;
    }

/*===================================================================
ViperGetObjectFromContext

Get Viper context property by LPWSTR and
return it as IDispatch*.
The real interface takes BSTR and VARIANT.

Parameters
    BSTR       bstrName      Property Name
    IDispatch  **ppdisp       [out] Object (Property Value)

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetObjectFromContext
(
BSTR bstrName,
IDispatch **ppdisp
)
    {
    Assert(ppdisp);

    HRESULT hr = S_OK;

    // Get Viper Context

    IObjectContext *pViperContext = NULL;
    hr = GetObjectContext(&pViperContext);

    // Get IContextPoperties interface

    IContextProperties *pContextProperties = NULL;
    if (SUCCEEDED(hr))
   		hr = pViperContext->QueryInterface
   		    (
   		    IID_IContextProperties,
   		    (void **)&pContextProperties
   		    );

    // Get property Value as variant

    VARIANT Variant;
    VariantInit(&Variant);

    if (SUCCEEDED(hr))
        hr = pContextProperties->GetProperty(bstrName, &Variant);

    // Convert Variant to IDispatch*

    if (SUCCEEDED(hr))
        {
        IDispatch *pDisp = NULL;
        if (V_VT(&Variant) == VT_DISPATCH)
            pDisp = V_DISPATCH(&Variant);

        if (pDisp)
            {
            pDisp->AddRef();
            *ppdisp = pDisp;
            }
        else
            hr = E_FAIL;
        }

    // Cleanup

    VariantClear(&Variant);

    if (pContextProperties)
        pContextProperties->Release();

    if (pViperContext)
        pViperContext->Release();

    if (FAILED(hr))
        *ppdisp = NULL;

    return hr;
    }

/*===================================================================
ViperGetHitObjFromContext

Get Server from Viper context property and get
it's current HitObj

Parameters
    CHitObj **ppHitObj  [out]

Returns:
    HRESULT
===================================================================*/
HRESULT ViperGetHitObjFromContext
(
CHitObj **ppHitObj
)
    {
    *ppHitObj = NULL;

    IDispatch *pdispServer = NULL;
    HRESULT hr = ViperGetObjectFromContext(BSTR_OBJ_SERVER, &pdispServer);
    if (FAILED(hr))
        return hr;

    if (pdispServer)
        {
        CServer *pServer = static_cast<CServer *>(pdispServer);
        *ppHitObj = pServer->PHitObj();
        pdispServer->Release();
        }

    return *ppHitObj ? S_OK : S_FALSE;
    }

/*===================================================================
ViperCreateInstance

Viper's implementation of CoCreateInstance

Parameters
    REFCLSID rclsid         class id
    REFIID   riid           interface
    void   **ppv            [out] pointer to interface

Returns:
    HRESULT
===================================================================*/
HRESULT ViperCreateInstance
(
REFCLSID rclsid,
REFIID   riid,
void   **ppv
)
{
    /*
    DWORD dwClsContext = (Glob(fAllowOutOfProcCmpnts)) ?
            CLSCTX_INPROC_SERVER | CLSCTX_SERVER :
            CLSCTX_INPROC_SERVER;
    */

    // The reasons for supporting ASPAllowOutOfProcComponents seem to have
    // vanished. Because this only partially worked in II4 and we changed
    // the default in IIS5 this was causing problems with upgrades. So
    // we're going to ignore the fAllowOutOfProcCmpnts setting.

    DWORD dwClsContext = CLSCTX_INPROC_SERVER | CLSCTX_SERVER;
	return CoCreateInstance(rclsid, NULL, dwClsContext, riid, ppv);
}

/*===================================================================
ViperConfigure

Viper settings:  # of threads, queue len,
                 in-proc failfast,
                 allow oop components

Parameters
	
Returns:
    HRESULT
===================================================================*/
HRESULT ViperConfigure()
    {
    HRESULT hr = S_OK;
    IMTSPackage *pPackage = NULL;

    //
    // Get hold of the package
    //

    hr = CoCreateInstance(CLSID_MTSPackage,
			  NULL,
			  CLSCTX_INPROC_SERVER,
			  IID_IMTSPackage,
			  (void **)&pPackage);
    if (SUCCEEDED(hr) && !pPackage)
    	hr = E_FAIL;

    //
    // Bug 111008: Tell Viper that we do impersonations
    //

    if (SUCCEEDED(hr))
        {
    	IImpersonationControl *pImpControl = NULL;
        hr = pPackage->QueryInterface(IID_IImpersonationControl, (void **)&pImpControl);

    	if (SUCCEEDED(hr) && pImpControl)
    	    {
            hr = pImpControl->ClientsImpersonate(TRUE);
    	    pImpControl->Release();
	        }
        }

    //
    // Disable FAILFAST for in-proc case
    //

    if (SUCCEEDED(hr) && !g_fOOP)
        {
    	IFailfastControl *pFFControl = NULL;
    	hr = pPackage->QueryInterface(IID_IFailfastControl, (void **)&pFFControl);

    	if (SUCCEEDED(hr) && pFFControl)
    	    {
    	    pFFControl->SetApplFailfast(FALSE);
	        pFFControl->Release();
	        }
    	}

/*
    //
    // Set Allow OOP Components
    //
    if (SUCCEEDED(hr))
        {
	    INonMTSActivation *pNonMTSActivation = NULL;
    	hr = pPackage->QueryInterface(IID_INonMTSActivation, (void **)&pNonMTSActivation);
    	
    	if (SUCCEEDED(hr) && pNonMTSActivation)
    	    {
        	pNonMTSActivation->OutOfProcActivationAllowed(fAllowOopComponents);
    		pNonMTSActivation->Release();
    	    }
   	    }
*/

    //
    // Clean-up
    //

    if (pPackage)
    	pPackage->Release();

    return hr;
    }

HRESULT ViperConfigureMTA()
{

    HRESULT     hr = S_OK;
    IMTSPackage *pPackage = NULL;

    if (g_fFirstMTAHit) {

        EnterCriticalSection(&g_csFirstMTAHitLock);

        if (g_fFirstMTAHit) {

            //
            // Get hold of the package
            //

            hr = CoCreateInstance(CLSID_MTSPackage,
			          NULL,
			          CLSCTX_INPROC_SERVER,
			          IID_IMTSPackage,
			          (void **)&pPackage);

            if (SUCCEEDED(hr) && !pPackage)
    	        hr = E_FAIL;

            if (SUCCEEDED(hr)) {
    	        IComMtaThreadPoolKnobs *pMTAKnobs = NULL;
                hr = pPackage->QueryInterface(IID_IComMtaThreadPoolKnobs, (void **)&pMTAKnobs);

    	        if (SUCCEEDED(hr) && pMTAKnobs) {
    		        SYSTEM_INFO si;
	    	        GetSystemInfo(&si);

                    DWORD dwThreadCount;

                    if (FAILED(g_AspRegistryParams.GetTotalThreadMax(&dwThreadCount))) {
                        dwThreadCount = DEFAULT_MAX_THREAD;
                    }

                    if (dwThreadCount > Glob(dwProcessorThreadMax)*si.dwNumberOfProcessors) {
                        dwThreadCount = Glob(dwProcessorThreadMax)*si.dwNumberOfProcessors;
                    }

                    hr = pMTAKnobs->MTASetMaxThreadCount(dwThreadCount);

                    if (SUCCEEDED(hr))
                        hr = pMTAKnobs->MTASetThrottleValue(8);

    	            pMTAKnobs->Release();
	            }
            }

            g_fFirstMTAHit = FALSE;

        }

        LeaveCriticalSection(&g_csFirstMTAHitLock);
    }

    return hr;
}

HRESULT ViperConfigureSTA()
{

    HRESULT     hr = S_OK;
    IMTSPackage *pPackage = NULL;

    if (g_fFirstSTAHit) {

        EnterCriticalSection(&g_csFirstSTAHitLock);

        if (g_fFirstSTAHit) {

            //
            // Get hold of the package
            //

            hr = CoCreateInstance(CLSID_MTSPackage,
			          NULL,
			          CLSCTX_INPROC_SERVER,
			          IID_IMTSPackage,
			          (void **)&pPackage);

            if (SUCCEEDED(hr) && !pPackage)
    	        hr = E_FAIL;


            //
            // Set knobs
            //

            if (SUCCEEDED(hr))
                {
    	        IComStaThreadPoolKnobs *pKnobs = NULL;
	            hr = pPackage->QueryInterface(IID_IComStaThreadPoolKnobs, (void **)&pKnobs);

    	        if (SUCCEEDED(hr) && pKnobs)
    	            {
    	            // number of threads
    		        SYSTEM_INFO si;
	    	        GetSystemInfo(&si);

                    DWORD dwThreadCount;
                    DWORD dwMinThreads;

                    if (FAILED(g_AspRegistryParams.GetTotalThreadMax(&dwThreadCount))) {
                        dwThreadCount = DEFAULT_MAX_THREAD;
                    }

                    if (dwThreadCount > Glob(dwProcessorThreadMax)*si.dwNumberOfProcessors) {
                        dwThreadCount = Glob(dwProcessorThreadMax)*si.dwNumberOfProcessors;
                    }

                    dwMinThreads = (si.dwNumberOfProcessors > 4) ? si.dwNumberOfProcessors : 4;

                    if (dwThreadCount < dwMinThreads) {
                        dwThreadCount = dwMinThreads;
                    }

    		        pKnobs->SetMaxThreadCount(dwThreadCount);
    		        pKnobs->SetMinThreadCount(dwMinThreads);

    		        // queue length
    		        pKnobs->SetQueueDepth(30000);

    		        pKnobs->SetActivityPerThread(1);
    		
    	            pKnobs->Release();
    	            }
                }

            // set Knobs2

            if (SUCCEEDED(hr))
            {
    	        IComStaThreadPoolKnobs2 *pKnobs2 = NULL;
	            hr = pPackage->QueryInterface(IID_IComStaThreadPoolKnobs2, (void **)&pKnobs2);

    	        if (SUCCEEDED(hr) && pKnobs2)
    	        {
                    DWORD   dwMaxCSR;
                    DWORD   dwMaxCPU;
                    DWORD   dwDisableCpuMetric;

                    if (SUCCEEDED(g_AspRegistryParams.GetMaxCPU(&dwMaxCPU))) {
                        pKnobs2->SetMaxCPULoad(dwMaxCPU);
                    }
                    else {
                        pKnobs2->SetMaxCPULoad(100);
                    }

                    if (SUCCEEDED(g_AspRegistryParams.GetMaxCSR(&dwMaxCSR))) {
                        pKnobs2->SetMaxCSR(dwMaxCSR);
                    }

                    if (SUCCEEDED(g_AspRegistryParams.GetDisableComPlusCpuMetric(&dwDisableCpuMetric))) {
                        pKnobs2->SetCPUMetricEnabled(!dwDisableCpuMetric);
                    }

                    pKnobs2->Release();
                }
            }

            g_fFirstSTAHit = FALSE;

        }

        LeaveCriticalSection(&g_csFirstSTAHitLock);
    }

    return hr;
}


/*===================================================================
  C O M  H e l p e r  A P I
===================================================================*/

/*===================================================================
ViperCoObjectIsaProxy

Checks if the given IUnknown* points to a proxy

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Proxy)
===================================================================*/
BOOL ViperCoObjectIsaProxy
(
IUnknown* pUnk
)
    {
	HRESULT hr;
	IUnknown *pUnk2;

	hr = pUnk->QueryInterface(IID_IProxyManager, (void**)&pUnk2);
	if (FAILED(hr))
		return FALSE;

	pUnk2->Release();
	return TRUE;
    }

/*===================================================================
ViperCoObjectAggregatesFTM

Checks if the given object agregates free threaded marshaller
(is agile)

Parameters
    IUnknown* pUnk      pointer to check

Returns:
    BOOL    (TRUE if Agile)
===================================================================*/
BOOL ViperCoObjectAggregatesFTM
(
IUnknown *pUnk
)
    {
	HRESULT hr;
	IMarshal *pMarshal;
	GUID guidClsid;

	hr = pUnk->QueryInterface(IID_IMarshal, (void**)&pMarshal);
	if (FAILED(hr))
		return FALSE;

	hr = pMarshal->GetUnmarshalClass(IID_IUnknown, pUnk, MSHCTX_INPROC,
	                                 NULL, MSHLFLAGS_NORMAL, &guidClsid);
	pMarshal->Release();

	if (FAILED(hr))
		return FALSE;

	return (guidClsid == CLSID_InProcFreeMarshaler);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\vector.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: vector.h

Owner: DGottner

This file contains a dynamic array
===================================================================*

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright 1994, David Gottner
 *
 *                    All Rights Reserved
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose and without fee is hereby granted,
 * provided that the above copyright notice, this permission notice and
 * the following disclaimer notice appear unmodified in all copies.
 *
 * I DISCLAIM ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.  IN NO EVENT SHALL I
 * BE LIABLE FOR ANY SPECIAL, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY
 * DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA, OR PROFITS, WHETHER
 * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
 * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 */

#ifndef VECTOR_H
#define VECTOR_H

 /*---------------------------------------------------------------------------*
 ** The vector class is a thin encapsulation of a C style array, which
 ** allows dynamic sizing of the array and bounds checking; you can also use
 ** this array as a stack.  This is a value-based collection.
 */

template <class TYPE>
class vector {
	TYPE *	m_rgData;
	size_t	m_cItems;
	size_t	m_cCells;

public:
	vector<TYPE>();
	~vector();

	HRESULT Init(const TYPE *, size_t);
	HRESULT Init(size_t n);

	vector<TYPE> &operator= (const vector<TYPE> &);

	size_t length() const	 { return m_cItems; }
	const TYPE *vec() const	 { return m_rgData; }

	// STL iterators (const)
	const TYPE *begin() const { return &m_rgData[0]; }
	const TYPE *end() const   { return &m_rgData[m_cItems]; }

	// STL iterators (non-const)
	TYPE *begin()             { return &m_rgData[0]; }
	TYPE *end()               { return &m_rgData[m_cItems]; }

	TYPE operator[](unsigned i) const
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	TYPE &operator[](unsigned i)
	{
		Assert (i < m_cItems);
		return m_rgData[i];
	}

	HRESULT resize(size_t);
	HRESULT reshape(size_t);

	HRESULT append(const TYPE &a)   { return insertAt(m_cItems, a); }
	HRESULT prepend(const TYPE &a)  { return insertAt(0, a);         }

	HRESULT insertAt(size_t, const TYPE &);
	TYPE removeAt(size_t);

	HRESULT push(const TYPE &a)	{ return append(a); }
	TYPE pop()					{ return m_rgData[--m_cItems]; }

	int find(const TYPE &) const;
};

#endif /* VECTOR */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\addesc.h ===
// AdDesc.h: interface for the CAdDescriptor class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"

class CAdDescriptor : public CRefCounter  
{
public:
	CAdDescriptor( ULONG lWeight, String strLink, String strGif, String strAlt );

	const ULONG		m_lWeight;
	const String	m_strLink;
	const String	m_strGif;
	const String	m_strAlt;

private:
	virtual ~CAdDescriptor();
};

typedef TRefPtr< CAdDescriptor > CAdDescPtr;

#endif // !defined(AFX_ADDESC_H__78FFAFF3_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\viperint.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Viper Integration Objects

File: viperint.h

Owner: DmitryR

This file contains the definiton of viper integration classes
===================================================================*/

#ifndef VIPERINT_H
#define VIPERINT_H

#include "comsvcs.h"
#include "mtxpriv.h"
#include "glob.h"
#include "asptlb.h"     // needed to define interface pointers
#include "reftrace.h"

#include "memcls.h"

#define REFTRACE_VIPER_REQUESTS DBG

class CHitObj;  // forward decl

/*===================================================================
  Transaction Support Types
===================================================================*/
#define TransType       DWORD

#define ttUndefined     0x00000000
#define ttNotSupported  0x00000001
#define ttSupported     0x00000002
#define ttRequired      0x00000004
#define ttRequiresNew   0x00000008

/*===================================================================
CViperAsyncRequest class implements IMTSCall interface.
Its OnCall() method does HitObj processing.
This is a private class used in CViperActivity class
===================================================================*/

class CViperAsyncRequest : public IServiceCall, public IAsyncErrorNotify, public CDblLink
	{
private: 
	LONG              m_cRefs;	          // reference count
	CHitObj          *m_pHitObj;         // request
    IServiceActivity *m_pActivity;
    HRESULT           m_hrOnError;
    DWORD             m_dwTimeout:16;
    DWORD             m_dwRepostAttempts:8;
    DWORD             m_fBrowserRequest:1;
    DWORD             m_fTestingConnection:1;
    DWORD             m_fAsyncCallPosted:1;
    DWORD             m_dwLastTestTimeStamp;
	
private:
	CViperAsyncRequest();
	~CViperAsyncRequest();

	HRESULT Init(CHitObj *pHitObj, IServiceActivity  *pActivity);

public:
    BOOL    FBrowserRequest()   { return m_fBrowserRequest; }
    CHitObj *PHitObj()          { return m_pHitObj; }

    DWORD   SecsSinceLastTest();
    void    UpdateTestTimeStamp() { m_dwLastTestTimeStamp = GetTickCount(); }

    DWORD   dwTimeout()         { return m_dwTimeout; };

#if REFTRACE_VIPER_REQUESTS
	static PTRACE_LOG gm_pTraceLog;
#endif

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

public:
	// IUnknown Methods
	STDMETHODIMP		 QueryInterface(REFIID iid, void **ppv);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// IServiceCall Method
	STDMETHODIMP OnCall();

    // IAsyncErrorNotify
    STDMETHODIMP OnError(HRESULT hr);

    BOOL    FTestingConnection()        { return m_fTestingConnection; }
    void    SetTestingConnection()      { m_fTestingConnection = TRUE; }
    void    ClearTestingConnection()    { m_fTestingConnection = FALSE; }

    BOOL    FAsyncCallPosted()          { return m_fAsyncCallPosted; }
    void    SetAsyncCallPosted()        { m_fAsyncCallPosted = TRUE; }
    void    ClearAsyncCallPosted()        { m_fAsyncCallPosted = FALSE; }

friend class CViperActivity;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

extern volatile LONG g_nViperRequests;

/*===================================================================
CViperActivity corresponds to a Session.
It creates MTS activity, and launches async requests
===================================================================*/

class CViperActivity
    {
private:
    IServiceActivity *m_pActivity;
    DWORD m_cBind;    // inited-flag + bind-to-thread count

    inline BOOL FInited() const { return (m_cBind > 0); }

public:
    CViperActivity();
    ~CViperActivity();

    // Create Viper activity
    HRESULT Init(IUnknown  *pConfig);
    
    // Clone Viper activity
    HRESULT InitClone(CViperActivity *pActivity);

    // Bind/Unbind
    HRESULT BindToThread();
    HRESULT UnBindFromThread();

    // Release Viper activity
    HRESULT UnInit(); 

    // Check if thread-bound
    inline BOOL FThreadBound() const { return (m_cBind > 1); }

    // Post async request within this activity
    HRESULT PostAsyncRequest(CHitObj *pHitObj);

    // post async request without an activity
    static HRESULT PostGlobalAsyncRequest(CHitObj *pHitObj);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

    };

/*===================================================================
Misc. Functions
===================================================================*/

HRESULT ViperAttachIntrinsicsToContext
    (
    IApplicationObject *pAppln,
    ISessionObject     *pSession  = NULL,
    IRequest           *pRequest  = NULL,
    IResponse          *pResponse = NULL,
    IServer            *pServer   = NULL
    );

HRESULT ViperGetObjectFromContext
    (
    BSTR bstrName,
    IDispatch **ppdisp
    );

HRESULT ViperGetHitObjFromContext
    (
    CHitObj **ppHitObj
    );

HRESULT ViperCreateInstance
    (
    REFCLSID rclsid,
    REFIID   riid,
    void   **ppv
    );

HRESULT ViperConfigure();
HRESULT ViperConfigureMTA();
HRESULT ViperConfigureSTA();


/*===================================================================
CViperReqManager

  This class manages the outstanding CViperAsyncRequest objects.  
  With this class, we can periodically cleanup disconnected requests
  on the queue.
===================================================================*/

class CViperReqManager
{
public:
    CViperReqManager(); 
    ~CViperReqManager() {};

    HRESULT Init();
    HRESULT UnInit();

    HRESULT AddReqObj(CViperAsyncRequest   *pReqObj);
    BOOL    RemoveReqObj(CViperAsyncRequest *pReqObj, BOOL fForce = FALSE);

    void        LockQueue();
    void        UnlockQueue();

private:

    CDblLink            m_ReqObjList;
    DWORD               m_dwReqObjs;
    DWORD               m_fCsInited:1;
    DWORD               m_fCsQueueInited:1;
    DWORD               m_fShutdown:1;
    DWORD               m_fDisabled : 1;
    CRITICAL_SECTION    m_csLock;
    CRITICAL_SECTION    m_csQueueLock;
    DWORD               m_dwQueueMin;
    HANDLE              m_hWakeUpEvent;
    HANDLE              m_hThreadAlive;
    DWORD               m_dwLastAwakened;
    DWORD               m_dwQueueAlwaysWakeupMin;

    void                Lock();
    void                Unlock();
    CViperAsyncRequest  *GetNext(CDblLink *pViperReq, BOOL fTestForF5Attack);

    void    WakeUp(BOOL fForce = FALSE);

    static  DWORD __stdcall WatchThread(VOID  *pArg);

};

extern CViperReqManager g_ViperReqMgr;

/*===================================================================
CViperReqManager - Inlines

===================================================================*/

inline void CViperReqManager::Lock()
{
    Assert(m_fCsInited);
    EnterCriticalSection(&m_csLock);
}

inline void CViperReqManager::Unlock()
{
    LeaveCriticalSection(&m_csLock);
}


inline void CViperReqManager::LockQueue()
{
    Assert(m_fCsQueueInited);
    EnterCriticalSection(&m_csQueueLock);
}

inline void CViperReqManager::UnlockQueue()
{
    LeaveCriticalSection(&m_csQueueLock);
}

inline void CViperReqManager::WakeUp(BOOL  fForce /* = FALSE */)
{
    // set the wakeup event under any of the three conditions:
    // 1) fForce is true (set when shutting down)
    // 2) requests queued exceed level that will always force wakeup
    // 3) not at the force level of requests, but have some queueing and
    //    haven't awakened for at least one second
    if (fForce 
        || (m_dwReqObjs >= m_dwQueueAlwaysWakeupMin)
        || ((m_dwReqObjs >= m_dwQueueMin) && (GetTickCount()/1000 > m_dwLastAwakened)))
        SetEvent(m_hWakeUpEvent);
}
    

/*===================================================================
COM Helper API
===================================================================*/

BOOL ViperCoObjectIsaProxy
    (
    IUnknown *pUnk
    );

BOOL ViperCoObjectAggregatesFTM
    (
    IUnknown *pUnk
    );

#endif // VIPERINT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asp\wraptlib.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.00.44 */
/* at Thu Jul 24 14:01:48 1997
 */
/* Compiler settings for D:\VBScript\src\idl\wraptlib.idl, all.acf:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __wraptlib_h__
#define __wraptlib_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IWrapTypeLibs_FWD_DEFINED__
#define __IWrapTypeLibs_FWD_DEFINED__
typedef interface IWrapTypeLibs IWrapTypeLibs;
#endif 	/* __IWrapTypeLibs_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL__intf_0000
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// WrapTLib.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=
//
//
// Declarations for ActiveX Script Type Library Wrapping.
//

#ifndef __WrapTLib_h
#define __WrapTLib_h

/* GUIDs
 ********/

// {62238910-C1C9-11d0-ABF7-00A0C911E8B2}
DEFINE_GUID(IID_IWrapTypeLibs, 0x62238910, 0xc1c9, 0x11d0, 0xab, 0xf7, 0x00, 0xa0, 0xc9, 0x11, 0xe8, 0xb2);

/* Interfaces
 *************/






extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0000_v0_0_s_ifspec;

#ifndef __IWrapTypeLibs_INTERFACE_DEFINED__
#define __IWrapTypeLibs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWrapTypeLibs
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [object][unique][uuid] */ 



EXTERN_C const IID IID_IWrapTypeLibs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IWrapTypeLibs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE WrapTypeLib( 
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWrapTypeLibsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWrapTypeLibs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WrapTypeLib )( 
            IWrapTypeLibs __RPC_FAR * This,
            /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
            /* [in] */ UINT ctlibs,
            /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);
        
        END_INTERFACE
    } IWrapTypeLibsVtbl;

    interface IWrapTypeLibs
    {
        CONST_VTBL struct IWrapTypeLibsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWrapTypeLibs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWrapTypeLibs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWrapTypeLibs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWrapTypeLibs_WrapTypeLib(This,prgptlib,ctlibs,ppdisp)	\
    (This)->lpVtbl -> WrapTypeLib(This,prgptlib,ctlibs,ppdisp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IWrapTypeLibs_WrapTypeLib_Proxy( 
    IWrapTypeLibs __RPC_FAR * This,
    /* [in] */ ITypeLib __RPC_FAR *__RPC_FAR *prgptlib,
    /* [in] */ UINT ctlibs,
    /* [out] */ IDispatch __RPC_FAR *__RPC_FAR *ppdisp);


void __RPC_STUB IWrapTypeLibs_WrapTypeLib_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWrapTypeLibs_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL__intf_0137
 * at Thu Jul 24 14:01:48 1997
 * using MIDL 3.00.44
 ****************************************/
/* [local] */ 



#endif  // __WrapTLib_h



extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL__intf_0137_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adfile.cpp ===
// AdFile.cpp: implementation of the CAdFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#undef max
#include "AdRot.h"
#include "AdFile.h"
#include "RotObj.h"
#include "sinstrm.h"

extern CMonitor* g_pMonitor;

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//--------------------------------------------------------------------
//  CAdFileNotify
//--------------------------------------------------------------------
CAdFileNotify::CAdFileNotify()
    :   m_isNotified(0)
{
}

void
CAdFileNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CAdFileNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}


//--------------------------------------------------------------------
//  CAdFile
//--------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CAdFile::CAdFile()
    :   m_nBorder(defaultBorder),
        m_nHeight(defaultHeight),
        m_nWidth(defaultWidth),
        m_nVSpace(defaultVSpace),
        m_nHSpace(defaultHSpace),
        m_strRedirector( _T("")),
        m_fUTF8(false)
{
    m_pNotify = new CAdFileNotify;
}

CAdFile::~CAdFile()
{
    if ( g_pMonitor )
    {
        g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
    }
}

//---------------------------------------------------------------------------
//
//  ProcessAdFile will check the given filename, if it matches the one it
//  knows it currently has in memory, it will do nothing.  If the filename
//  differs, the old ad information will be dumped, and the new information
//  parsed and stored.
//
//---------------------------------------------------------------------------
bool
CAdFile::ProcessAdFile(
    String  strAdFile )
{
    USES_CONVERSION;

    bool rc = false;
    UINT    weightSum = 0;
        
    // block all other readers and writers
    CWriter wtr( *this );
    m_ads.erase( m_ads.begin(), m_ads.end() );
    
    
    // parse the file
    FileInStream fs;
    HRESULT hr = fs.Init( T2CA(strAdFile.c_str()) );
    if ( SUCCEEDED(hr) && fs.is_open())
    {       
        if ( ReadHeader( fs ) )
        {
            while ( !fs.eof() )
            {
                // read one "ad record"
                String strGif;
                String strLink;
                String strAlt;
                String strWeight;
                ULONG lWeight = 0;
                
                fs >> strGif >> strLink;
                // this just gets us past the new line
                fs.readLine( strAlt );
                fs >> strWeight;
                               
                
                // check for a negative impression value.  RaiseException if
                // negative

                if (strWeight[0] == '-') {
                    CAdRotator::RaiseException( IDS_ERROR_BAD_WEIGHT_VALUE );
                    goto err;
                }
                lWeight = strWeight.toUInt32();

                weightSum += lWeight;

                if (weightSum > 10000) {
                    CAdRotator::RaiseException( IDS_ERROR_WEIGHT_SUM_TOO_LARGE );
                    goto err;
                }
                
                if ( lWeight != 0 )
                {
                    CAdDescPtr pAd = new CAdDescriptor( lWeight, strLink, strGif, strAlt );
                    if ( pAd.IsValid() )
                    {
                        // add one reference to the ad for each weight
                        for( int i = 0; i < lWeight; i++ )
                        {
                            m_ads.push_back( pAd );
                        }
                    }
                }
            }
            if ( m_ads.size() > 0 )
            {
                if ( m_strFile != strAdFile )
                {
                    g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
                    m_strFile = strAdFile;
                    g_pMonitor->MonitorFile( m_strFile.c_str(), m_pNotify );
                }
                rc = true;
            }
        }
        else
        {
            CAdRotator::RaiseException( IDS_ERROR_CANNOT_READ_ROTATION_SCHEDULE_FILE );
        }
    }
    else
    {
        CAdRotator::RaiseException( IDS_ERROR_CANNOT_LOAD_ROTATION_SCHEDULE_FILE );
    }
err:
    
    return rc;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date, if so
//  it will re-read the file
//
//---------------------------------------------------------------------------
bool
CAdFile::Refresh()
{
    bool rc = false;
    if ( m_pNotify->IsNotified() )
    {
        rc = ProcessAdFile( m_strFile );
    }
    return rc;
}


//---------------------------------------------------------------------------
//
//  ReadHeader will parse the header portion of the file.  The header includes
//  some or all of the following fields: HEIGHT, WIDTH, BORDER, REDIRECT,
//  HSPACE, VSPACE.  The fields are separated by newlines and the header is
//  terminated by an asterix.
//
//---------------------------------------------------------------------------
bool
CAdFile::ReadHeader(
    FileInStream&   fs )
{
    bool rc = false;

    // set defaults
    m_nHeight = defaultHeight;
    m_nWidth = defaultWidth;
    m_nHSpace = defaultHSpace;
    m_nVSpace = defaultVSpace;

    m_fUTF8 = fs.is_UTF8();

    bool done = false;
    while ( !fs.eof() && !done )
    {
        String strLine;
        String strName;
        fs.readLine( strLine );
        StringInStream sis( strLine );
        sis >> strName;
        HRESULT hr = S_OK;
        if ( _tcsicmp( strName.c_str(), _T("HEIGHT") ) == 0 )
        {
            hr = sis.readInt( m_nHeight );
        }
        else if ( _tcsicmp( strName.c_str(), _T("WIDTH") ) == 0 )
        {
            hr = sis.readInt( m_nWidth );
        }
        else if ( _tcsicmp( strName.c_str(), _T("VSPACE") ) == 0 )
        {
            hr = sis.readInt( m_nVSpace );
        }
        else if ( _tcsicmp( strName.c_str(), _T("HSPACE") ) == 0 )
        {
            hr = sis.readInt( m_nHSpace );
        }
        else if ( _tcsicmp( strName.c_str(), _T("REDIRECT") ) == 0 )
        {
            hr = sis.readString( m_strRedirector );
        }
        else if ( _tcsicmp( strName.c_str(), _T("BORDER" ) ) == 0 )
        {
            hr = sis.readInt16( m_nBorder );
        }
        else if ( _tcsicmp( strName.c_str(), _T("*") ) == 0 )
        {
            rc = true;
            done = true;
        }
        else
        {
            CAdRotator::RaiseException( IDS_ERROR_UNKNOWN_HEADER_NAME );
        }
/*
        if ( hr != S_OK )
        {
            CAdRotator::RaiseException( IDS_ERROR_HEADER_HAS_NO_ASSOCIATED_VALUE );
        }
*/      
    }
    return rc;
}

//---------------------------------------------------------------------------
//
//  RandomAd chooses and ad at random from the list of ads.  Since there
//  are multiple references to ads based on the weight, we need only produce
//  a random number between 0 and one less than the size of the list.
//
//---------------------------------------------------------------------------
CAdDescPtr
CAdFile::RandomAd() const
{
    if (m_ads.size() > 0)
        return m_ads[ rand() % m_ads.size() ];
    else
        return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adrot.cpp ===
// AdRot.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f AdRotps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "AdRot.h"
#include <time.h>

#include "AdRot_i.c"
#include <initguid.h>
#include "RotObj.h"
#include "Monitor.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CAdRotModule _Module;
CMonitor* g_pMonitor = NULL;
extern HINSTANCE g_hModuleInstance;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_AdRotator, CAdRotator)
END_OBJECT_MAP()

LONG
CAdRotModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CAdRotModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);
	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
		// final unlock
		_ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
        CAdRotator::ClearAdFiles();
	}
	return lc;
}
		
/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		g_hModuleInstance = hInstance;
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
    	srand( static_cast<unsigned int>( time( NULL ) ) );

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

		CAdRotator::ClearAdFiles();
		_Module.Term();
		_ASSERT( g_pMonitor == NULL );
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\adfile.h ===
// AdFile.h: interface for the CAdFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_)
#define AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "AdDesc.h"
#include "Monitor.h"
#include "rdwrt.h"

class CAdFileNotify : public CMonitorNotify
{
public:
                    CAdFileNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CAdFileNotify,CMonitorNotify )

class CAdFile : public CRefCounter, public CReadWrite
{
public:
	enum
	{
		defaultHeight	= 60,
		defaultWidth	= 440,
		defaultHSpace	= 0,
		defaultVSpace	= 0,
		defaultBorder	= 1
	};

	CAdFile();
	CAdDescPtr	RandomAd() const;
    bool        Refresh();
	bool		ProcessAdFile( String strAdFile );
	short		Border() const { return m_nBorder; }
	int			Height() const { return m_nHeight; }
	int			Width() const { return m_nWidth; }
	int			VSpace() const { return m_nVSpace; }
	int			HSpace() const { return m_nHSpace; }
	const String&	Redirector() const { return m_strRedirector; }
    bool        fUTF8() const { return m_fUTF8; }

private:
	typedef TVector< CAdDescPtr > AdListT;

	bool	ReadHeader( FileInStream& fs );

	virtual ~CAdFile();

    String             m_strFile;
	short		        m_nBorder;
	int			        m_nHeight;
	int			        m_nWidth;
	int			        m_nVSpace;
	int			        m_nHSpace;
	String		        m_strRedirector;
	AdListT		        m_ads;
    CAdFileNotifyPtr    m_pNotify;
    bool                m_fUTF8;
};

typedef TRefPtr<CAdFile> CAdFilePtr;

#endif // !defined(AFX_ADFILE_H__4792C231_E8B3_11D0_8A87_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\finstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\FInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\instrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\InStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\outstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\OutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\soutstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SOutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\sinstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by adrot.rc
//
#define DLL_VER                         0
#define IDS_PROJNAME                    100
#define IDR_ADROTATOR                   101
#define IDS_ADROT                       102
#define IDS_ERROR_NOSVR                 103
#define IDS_ERROR_UNKNOWN_HEADER_NAME   104
#define IDS_ERROR_HEADER_HAS_NO_ASSOCIATED_VALUE 105
#define IDS_ERROR_CANNOT_LOAD_ROTATION_SCHEDULE_FILE 106
#define IDS_ERROR_CANNOT_READ_ROTATION_SCHEDULE_FILE 107
#define IDS_ERROR_SOURCE                108
#define IDS_ERROR_BAD_WEIGHT_VALUE      109
#define IDS_ERROR_WEIGHT_SUM_TOO_LARGE  110

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CAdRotModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CAdRotModule _Module;
#include <atlcom.h>
#include <comdef.h>

#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"
#include "MyDebug.h"
#include "MyString.h"
#include "SOutStrm.h"
#include "FInStrm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78FFAFE8_E0E1_11D0_8A81_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rotobj.h ===
// RotObj.h : Declaration of the CAdRotator

#ifndef __ADROTATOR_H_
#define __ADROTATOR_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "AdDesc.h"
#include "AdFile.h"
#include "lock.h"
#include "eh.h"

/////////////////////////////////////////////////////////////////////////////
// CAdRotator
class ATL_NO_VTABLE CAdRotator : 
	public CComObjectRoot,
	public CComCoClass<CAdRotator, &CLSID_AdRotator>,
	public ISupportErrorInfo,
	public IDispatchImpl<IAdRotator, &IID_IAdRotator, &LIBID_AdRotator>
{
public:
	CAdRotator();
    ~CAdRotator() { if (m_strTargetFrame) ::SysFreeString(m_strTargetFrame); }

public:

DECLARE_REGISTRY_RESOURCEID(IDR_ADROTATOR)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CAdRotator)
	COM_INTERFACE_ENTRY(IAdRotator)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IAdRotator
public:
	STDMETHOD(get_GetAdvertisement)(BSTR, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_TargetFrame)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TargetFrame)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Border)(/*[out, retval]*/ short *pVal);
	STDMETHOD(put_Border)(/*[in]*/ short newVal);
	STDMETHOD(get_Clickable)(/*[out, retval]*/ BOOL *pVal);
	STDMETHOD(put_Clickable)(/*[in]*/ BOOL newVal);

	static void	ClearAdFiles();

	static void RaiseException( LPOLESTR );
	static void RaiseException( UINT );
private:

	typedef TSafeStringMap< CAdFilePtr > AdFileMapT;

	CAdFilePtr      AdFile( const String& strFile );

    CComAutoCriticalSection m_cs;
	bool	            	m_bClickable;
	short		            m_nBorder;
    bool                    m_bBorderSet;
	BSTR		            m_strTargetFrame;
	String		            m_strAdFile;
	CComPtr<IUnknown>		m_pUnkMarshaler;
	static AdFileMapT	    s_adFiles;

};

#endif //__ADROTATOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\adrot\rotobj.cpp ===
// RotObj.cpp : Implementation of CAdRotator
#include "stdafx.h"
#include "AdRot.h"
#include "RotObj.h"
#include "RdWrt.h"
#include "context.h"
#include "dbgutil.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_RESSTRINGSIZE 512

/////////////////////////////////////////////////////////////////////////////
// CAdRotator

CAdRotator::AdFileMapT	CAdRotator::s_adFiles;

CAdRotator::CAdRotator()
	:	m_bClickable( true ),
		m_nBorder(-1),
		m_strAdFile( _T("") ),
		m_strTargetFrame( NULL ),
        m_bBorderSet( false )
{
}


STDMETHODIMP CAdRotator::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IAdRotator,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP CAdRotator::get_Clickable(BOOL * pVal)
{
    CLock l(m_cs);
	*pVal = m_bClickable?TRUE:FALSE;
	return S_OK;
}

STDMETHODIMP CAdRotator::put_Clickable(BOOL newVal)
{
    CLock l(m_cs);
	m_bClickable = newVal?true:false;
	return S_OK;
}

STDMETHODIMP CAdRotator::get_Border(short * pVal)
{
	*pVal = m_nBorder;
	return S_OK;
}

STDMETHODIMP CAdRotator::put_Border(short newVal)
{
    CLock l(m_cs);
	m_nBorder = newVal;
    m_bBorderSet = true;
	return S_OK;
}

STDMETHODIMP CAdRotator::get_TargetFrame(BSTR * pVal)
{
	HRESULT rc = E_FAIL;
	USES_CONVERSION;

	try
	{
		if ( pVal )
		{
			CLock l(m_cs);
			if ( *pVal )
			{
				::SysFreeString( *pVal );
			}
            *pVal = ::SysAllocString(m_strTargetFrame);
			THROW_IF_NULL( *pVal );

			rc = S_OK;
		}
		else
		{
			rc = E_POINTER;
		}
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP CAdRotator::put_TargetFrame(BSTR newVal)
{
	HRESULT rc = E_FAIL;

	try
	{
		CLock l(m_cs);
        m_strTargetFrame = ::SysAllocString(newVal);
		rc = S_OK;
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP CAdRotator::get_GetAdvertisement(BSTR bstrVirtualPath, BSTR * pVal)
{
	SCODE rc = E_FAIL;
    
    USES_CONVERSION;
    
    _se_translator_function prevCaptureFn;
    prevCaptureFn = _set_se_translator (poi_Capture);

	try
	{
		CContext cxt;
		rc = cxt.Init( CContext::get_Server );
		if ( !FAILED(rc) )
		{
			CComBSTR bstrPhysicalPath;
			// determine the physical path
			if ( ( rc = cxt.Server()->MapPath( bstrVirtualPath, &bstrPhysicalPath ) ) == S_OK )
			{
				_TCHAR* szPath = OLE2T( bstrPhysicalPath );

				CAdFilePtr pAdFile = AdFile( szPath );
				
				if ( pAdFile.IsValid() )
				{
					// refresh the ad file (make sure it's up to date)
					pAdFile->Refresh();

					// block all writers
					CReader rdr( *pAdFile );

					// if the border hasn't been set, use the default from the ad file
					short nBorder;
					if ( m_bBorderSet == false )
					{
						nBorder = pAdFile->Border();
					}
					else
					{
						nBorder = m_nBorder;
					}

					CAdDescPtr pAd = pAdFile->RandomAd();
					if ( pAd.IsValid() )
					{
						// write out the HTML line for this ad
						StringOutStream ss;

                        // only write in HREF format if bClickable was set and
                        // there is a link URL that is not "-"

						if ( m_bClickable 
                             && ( pAd->m_strLink.size() > 0 )
                             && ( pAd->m_strLink != "-") )
						{
							// use the href format
							ss	<< _T("<A HREF=\"") << pAdFile->Redirector()
								<< _T("?url=") << pAd->m_strLink
								<< _T("&image=") << pAd->m_strGif 
                                << _T("\" ");
                                
                            if (m_strTargetFrame) {

                                CWCharToMBCS  convStr;

                                if (rc = convStr.Init(m_strTargetFrame, pAdFile->fUTF8() ? 65001 : CP_ACP)) {
                                    throw _com_error(rc);
                                }
                                ss << _T("TARGET=\"") << convStr.GetString() << _T("\"");
                            }
                            
                            ss << _T(">");
						}
						
						// now fill in the rest
						ss	<< _T("<IMG SRC=\"") << pAd->m_strGif
							<< _T("\" ALT=\"") << pAd->m_strAlt
							<< _T("\" WIDTH=") << pAdFile->Width()
							<< _T(" HEIGHT=") << pAdFile->Height();

						if ( pAdFile->HSpace() != CAdFile::defaultHSpace )
						{
							ss << _T(" HSPACE=") << pAdFile->HSpace();
						}
						if ( pAdFile->VSpace() != CAdFile::defaultVSpace )
						{
							ss << _T(" VSPACE=") << pAdFile->VSpace();
						}

						ss << _T(" BORDER=") << nBorder << _T(">");

						if ( m_bClickable 
                             && ( pAd->m_strLink.size() > 0 )
                             && ( pAd->m_strLink != "-") )
						{
							// put the trailing tag on
							ss << _T("</A>");
						}

						String str = ss.toString();
						
						if ( pVal )
						{
                            CMBCSToWChar    convStr;
                            HRESULT         hr;
							if ( *pVal )
							{
								::SysFreeString( *pVal );
							}

                            if (hr = convStr.Init(str.c_str(), pAdFile->fUTF8() ? 65001 : CP_ACP)) {
                                throw _com_error(hr);
                            }
							*pVal = ::SysAllocString( convStr.GetString() );
							THROW_IF_NULL( *pVal );
							rc = S_OK;
						}
						else
						{
							rc = E_POINTER;
						}
					}
				}
			}
		}
		else
		{
			_ASSERT(0);
			RaiseException( IDS_ERROR_NOSVR );
		}   // end if got server
	}
	catch ( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch ( ... )
	{
		rc = E_FAIL;
	}
	
    // restore default translator
	_set_se_translator (prevCaptureFn);
	return rc;
}


CAdFilePtr
CAdRotator::AdFile(
	const String& strFile )
{
	CAdFilePtr pAdFile;
	CLock l( s_adFiles );
	CAdFilePtr& rpAdFile = s_adFiles[ strFile ];
	if ( !rpAdFile.IsValid() )
	{
		pAdFile = new CAdFile;
		bool rc = pAdFile->ProcessAdFile( strFile );

		if ( rc )
		{
			rpAdFile = pAdFile;
		}
    }
	else
	{
		pAdFile = rpAdFile;
	}
	return pAdFile;
}



/////////////////////////////////////////////////////////////////////////////
//	ClearAdFiles
//
//	Release all of the ad files from the map
/////////////////////////////////////////////////////////////////////////////
void
CAdRotator::ClearAdFiles()
{
	CLock l( s_adFiles );
	s_adFiles.clear();
}

//---------------------------------------------------------------------------
//	RaiseException
//
//	Raises an exception using the given source and description
//---------------------------------------------------------------------------
void
CAdRotator::RaiseException (
	LPOLESTR strDescr
)
{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	_TCHAR tstrSource[MAX_RESSTRINGSIZE];
	if ( ::LoadString(
		_Module.GetResourceInstance(),
		IDS_ERROR_SOURCE,
		tstrSource,
		MAX_RESSTRINGSIZE ) > 0 )
	{
		USES_CONVERSION;

		LPOLESTR strSource = T2OLE( tstrSource );

		//Not much we can do if this fails.
		if (!FAILED(CreateErrorInfo(&pICreateErr)))
		{
			pICreateErr->SetGUID(CLSID_AdRotator);
			pICreateErr->SetHelpFile(L"");
			pICreateErr->SetHelpContext(0L);
			pICreateErr->SetSource(strSource);
			pICreateErr->SetDescription(strDescr);

			hr = pICreateErr->QueryInterface(IID_IErrorInfo, (void**)&pIErr);

			if (SUCCEEDED(hr))
			{
				if(SUCCEEDED(SetErrorInfo(0L, pIErr)))
				{
					pIErr->Release();
				}
			}
			pICreateErr->Release();
		}
	}

	::RaiseException(E_FAIL, 0, 0, NULL);
}

void 
CAdRotator::RaiseException(
	UINT DescrID
)
{
	_TCHAR tstrDescr[MAX_RESSTRINGSIZE];

	if ( ::LoadString(
		_Module.GetResourceInstance(),
		DescrID,
		tstrDescr,
		MAX_RESSTRINGSIZE) > 0 )
	{
		USES_CONVERSION;
		LPOLESTR strDescr = T2OLE( tstrDescr );
		RaiseException( strDescr );
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\browcap.cpp ===
// BrowCap.cpp : Implementation of CBrowserCap
#include "stdafx.h"
#include "BrwCap.h"
#include "BrowCap.h"
#include "CapMap.h"
#include "context.h"

static const DISPID FIRST_DYNAMIC_DISPID = 10000;

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#define MAX_RESSTRINGSIZE 512

/////////////////////////////////////////////////////////////////////////////
// CBrowserFactory

HRESULT CBrowserFactory::QueryInterface(const IID &riid, void **ppvObj)
{
	if (riid == IID_IUnknown || riid == IID_IClassFactory)
	{
		*ppvObj = this;
		AddRef();
		return S_OK;
	}
	else
	{
		*ppvObj = NULL;
		return E_NOINTERFACE;
	}
}

ULONG CBrowserFactory::AddRef()
{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
}

ULONG CBrowserFactory::Release()
{
	if (InterlockedDecrement(&m_cRefs) == 0)
	{
		delete this;
		return 0;
	}
	else
		return m_cRefs;
}

HRESULT CBrowserFactory::CreateInstance(IUnknown *pUnkOuter, const IID &riid, void **ppvObj)
{
	USES_CONVERSION;
	HRESULT hr;
	CContext cxt;
	IRequestDictionary *pDictCookies = NULL;

	if (FAILED(hr = cxt.Init(CContext::get_Request)))
		return hr;

	String				strBrowser;
	CComPtr<IDispatch>	piDispUserAgent;
	CComVariant			varUserAgent;

	if (FAILED(hr = cxt.Request()->get_Item(L"HTTP_USER_AGENT", &piDispUserAgent)))
		return hr;

	varUserAgent = piDispUserAgent;
	varUserAgent.ChangeType(VT_BSTR);
	strBrowser = OLE2T(V_BSTR(&varUserAgent));

	_Module.Lock();
	CBrowserCap *pBrowserCapObj = _Module.CapMap()->LookUp(strBrowser.c_str());
	_Module.Unlock();

	if (pBrowserCapObj == NULL)
		return E_FAIL;

	// IF there is a cookie, then clone the browscap object we got and add cookie properties
	// Otherwise, when there is no cookie, QueryInterface for "riid".
	//
	CComVariant varBrowscapCookie;
	if (SUCCEEDED(cxt.Request()->get_Cookies(&pDictCookies)))
	{
		IReadCookie *pReadCookie = NULL;		// Intermediate dictionary ptr
		CComVariant varCookieName;				// current key
		CComVariant varCookieValue;				// value of "varCookieName"
		IEnumVARIANT *pEnumKeys;


		// Get the BROWSCAP cookie
		if (FAILED(pDictCookies->get_Item(CComVariant(L"BROWSCAP"), &varBrowscapCookie)))
			goto LReleaseDict;

		// If the cookie exists, it will be an IDispatch. Otherwise it will be VT_EMPTY
		if (V_VT(&varBrowscapCookie) == VT_DISPATCH)
		{
			// Clone the cookie.  Since LookUp DID NOT AddRef(), we don't need to Release()
			// the pBrowserCapObj.  Thus cloning to the same pointer is OK here.
			// the clone will have a refcount of zero, so the QueryInterface call at the
			// end is also correct.
			//
			if (FAILED(hr = pBrowserCapObj->Clone(&pBrowserCapObj)))
				goto LReleaseDict;

			hr = V_DISPATCH(&varBrowscapCookie)->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&pReadCookie));
			_ASSERT (SUCCEEDED(hr));

			// Iterate over all cookie values
			if (FAILED(hr = pReadCookie->get__NewEnum(reinterpret_cast<IUnknown **>(&pEnumKeys))))
				goto LReleaseDict;

			while (pEnumKeys->Next(1, &varCookieName, NULL) == S_OK)
			{
				// Expecting a string
				_ASSERT (V_VT(&varCookieName) == VT_BSTR);

				// read the cookie value -- better succeed
				hr = pReadCookie->get_Item(varCookieName, &varCookieValue);
				_ASSERT (SUCCEEDED(hr) && V_VT(&varCookieValue) == VT_BSTR);

				// Store key & value in dictionary (over-rides previous settings)
				pBrowserCapObj->AddProperty(OLE2T(V_BSTR(&varCookieName)), OLE2T(V_BSTR(&varCookieValue)), TRUE);

				// Clear "varCookieName" to prevent leak. Since we pass address to Next(), C++ cleanup won't happen on its own
				varCookieName.Clear();
			}

			pEnumKeys->Release();
		}

LReleaseDict:
		pDictCookies->Release();
		if (pReadCookie)
			pReadCookie->Release();

		if (FAILED(hr))
			return hr;
	}

	return pBrowserCapObj->QueryInterface(riid, ppvObj);
}


/////////////////////////////////////////////////////////////////////////////
// CBrowserCap

CBrowserCap::CBrowserCap()
{
}

CBrowserCap::~CBrowserCap()
{
}

STDMETHODIMP CBrowserCap::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IBrowserCap,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

STDMETHODIMP
CBrowserCap::Invoke(
    DISPID      dispidMember,
    REFIID      riid,
    LCID        lcid,
    WORD        wFlags,
    DISPPARAMS* pdispparams,
    VARIANT*    pvarResult,
    EXCEPINFO*  pexcepinfo,
    UINT*       puArgErr )
{
	HRESULT rc;
	try
	{
		USES_CONVERSION;

		if ( dispidMember >= FIRST_DYNAMIC_DISPID )
		{
			if (wFlags & (DISPATCH_PROPERTYPUT | DISPATCH_PROPERTYPUTREF))
			{
				char szClass[25], szDescription[80];
				LoadString(IDS_ERROR_SOURCE, szClass);
				LoadString(IDS_ERROR_PROP_RO, szDescription);

				pexcepinfo->scode = E_FAIL;
				pexcepinfo->bstrSource = SysAllocString(T2OLE(szClass));
				pexcepinfo->bstrDescription = SysAllocString(T2OLE(szDescription));
				pexcepinfo->wCode = WORD(dispidMember);

				return DISP_E_EXCEPTION;
			}

			UINT i = dispidMember - FIRST_DYNAMIC_DISPID;
			CLock csT(m_strmapProperties);

			if (i < m_strmapProperties.size())		// dynamic property -- get value
				{
				rc = VariantCopy(pvarResult, &m_strmapProperties[i]);
				}
			else									// property does not exist, return empty
				{
				V_VT(pvarResult) = VT_BSTR;
				V_BSTR(pvarResult) = SysAllocString(L"unknown");
				rc = S_OK;
				}
		}
		else
		{
			rc = IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>::Invoke(
					dispidMember,
					riid,
					lcid,
					wFlags,
					pdispparams,
					pvarResult,
					pexcepinfo,
					puArgErr);
		}
	}
	catch( _com_error& ce )
	{
		rc = ce.Error();
	}
	catch( ... )
	{
		rc = E_FAIL;
	}
	return rc;
}

STDMETHODIMP
CBrowserCap::GetIDsOfNames(
    REFIID      riid,
    LPOLESTR*   rgszNames,
    UINT        cNames,
    LCID        lcid,
    DISPID*     rgdispid )
{
	HRESULT rc = E_FAIL;
	try
	{
		// first get the disp IDs of the known methods
		rc = IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>::GetIDsOfNames(
				riid,
				rgszNames,
				cNames,
				lcid,
				rgdispid);

		if (rc == DISP_E_UNKNOWNNAME)
		{
			// IDs for other methods are based on property list ID offset after last known method ID
			// this allows a client to say browsercap.Cookies instead of browsercap( "Cookies" ).
			// A property that does not exist is set to a value beyond the end of the strmap.
			// (this tells Invoke not to bother with "get_Value")  This trick only works because
			// properties are all set at creation time and cannot be added later.
			//
			rc = S_OK;
			for (UINT i = 0; i < cNames; i++)
				if (rgdispid[i] == DISPID_UNKNOWN &&
					(rgdispid[i] = DispatchID(rgszNames[i])) == DISPID_UNKNOWN)
						rc = DISP_E_UNKNOWNNAME;
		}
	}
	catch (_com_error& ce)
	{
		rc = ce.Error();
	}
	catch (...)
	{
		rc = E_FAIL;
	}
    return rc;
}

void CBrowserCap::AddProperty(TCHAR *szKey, TCHAR *szValue, BOOL fOverwriteProperty)
{
	USES_CONVERSION;
	CComVariant varT;

	// See if the key already exists, since the first key written into the
	// dictionary wins.  (This is to make sure that the  parent UA string property
	// never overwrites the child.)
	//
	_tcslwr(szKey);
	if (!fOverwriteProperty && m_strmapProperties.find(szKey) != m_strmapProperties.end())
		return;

	if (szValue[0] == _T('#'))
		varT = _ttol(szValue+1);

    else if (_tcsncicmp(szValue, _T("TRUE"), 5) == 0)
        varT = true;

    else if (_tcsncicmp(szValue, _T("FALSE"), 6) == 0)
        varT = false;

	else
		varT = T2CW(szValue);

	m_strmapProperties[szKey] = varT;
}

STDMETHODIMP CBrowserCap::get_Value(BSTR bstrName, VARIANT * pVal)
{
	USES_CONVERSION;
	CLock csT(m_strmapProperties);

	TSafeStringMap<CComVariant>::iterator itProp = m_strmapProperties.find(_tcslwr(OLE2T(bstrName)));
	if (itProp == m_strmapProperties.end())
		{
		V_VT(pVal) = VT_BSTR;
		V_BSTR(pVal) = SysAllocString(L"unknown");
		return V_BSTR(pVal) != NULL? S_OK : E_OUTOFMEMORY;
		}
	else
		return VariantCopy(pVal, &(*itProp).second);
}

DISPID
CBrowserCap::DispatchID(
    LPOLESTR szName )
{
    USES_CONVERSION;

    static const TCHAR *szOnStartPage = _T("onstartpage");
    static const TCHAR *szOnEndPage = _T("onendpage");

    TCHAR *szT = _tcslwr(OLE2T(szName));
    if ((szT == NULL)
        || (_tcscmp(szT, szOnStartPage) == 0) 
        || (_tcscmp(szT, szOnEndPage) == 0))
		return DISPID_UNKNOWN;

	CLock csT(m_strmapProperties);
	String strName = szT;
	TSafeStringMap<CComVariant>::iterator iter = m_strmapProperties.find(strName);
	if (iter == m_strmapProperties.end())
		return m_strmapProperties.size() + FIRST_DYNAMIC_DISPID;

	else
		return (iter - m_strmapProperties.begin()) + FIRST_DYNAMIC_DISPID;
}

HRESULT CBrowserCap::Clone(CBrowserCap **ppBrowserCapCopy)
{
	if ((*ppBrowserCapCopy = new CComObject<CBrowserCap>) == NULL)
		return E_OUTOFMEMORY;

	(*ppBrowserCapCopy)->FinalConstruct();		// Create FTM

	CLock csT(m_strmapProperties);
	TSafeStringMap<CComVariant>::iterator iter;

	for (iter = m_strmapProperties.begin(); iter < m_strmapProperties.end(); ++iter)
		(*ppBrowserCapCopy)->m_strmapProperties[(*iter).first] = (*iter).second;

	return S_OK;
}

void 
CBrowserCap::LoadString(
	UINT nID,
	TCHAR *szText
)
{
	if (::LoadString(_Module.GetResourceInstance(), nID, szText, MAX_RESSTRINGSIZE) == 0)
	{
		_tcscpy(szText, _T("?? Unknown (Can't find resource)"));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\browcap.h ===
// BrowCap.h : Declaration of the CBrowserCap

#ifndef __BROWSERCAP_H_
#define __BROWSERCAP_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "Lock.h"

/////////////////////////////////////////////////////////////////////////////
// CBrowserFactory
//         --- Create BrowsCap objects from cache.
class CBrowserFactory : public CComClassFactory
	{
	LONG m_cRefs;

public:
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID &, void **);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

	HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown *, const IID &, void **);
	};



/////////////////////////////////////////////////////////////////////////////
// CBrowserCap
class ATL_NO_VTABLE CBrowserCap : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CBrowserCap, &CLSID_BrowserCap>,
	public ISupportErrorInfo,
	public IDispatchImpl<IBrowserCap, &IID_IBrowserCap, &LIBID_BrowserType>
{
public:
	CBrowserCap();
    ~CBrowserCap();

public:

DECLARE_REGISTRY_RESOURCEID(IDR_BROWSERCAP)
DECLARE_GET_CONTROLLING_UNKNOWN()
DECLARE_CLASSFACTORY_EX(CBrowserFactory)

BEGIN_COM_MAP(CBrowserCap)
	COM_INTERFACE_ENTRY(IBrowserCap)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// methods to build property DB
	void AddProperty(TCHAR *szName, TCHAR *szValue, BOOL fOverwriteProperty = FALSE);

// Clone the object
	HRESULT Clone(CBrowserCap **ppBrowserCapCopy);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// Load string resource
	void LoadString(UINT, TCHAR *szText);

public:
// IUnknown methods
	HRESULT STDMETHODCALLTYPE QueryInterface(const IID &, void **);
	ULONG STDMETHODCALLTYPE AddRef();
	ULONG STDMETHODCALLTYPE Release();

// IDispatch Methods
    STDMETHOD(Invoke)(DISPID,REFIID,LCID,WORD,DISPPARAMS*,VARIANT*,EXCEPINFO*,UINT*);
    STDMETHOD(GetIDsOfNames)( REFIID, LPOLESTR*, UINT, LCID, DISPID* );

//Active Server Pages Methods
	STDMETHOD(get_Value)(BSTR, /*[out, retval]*/ VARIANT *pVal);

private:
	DISPID                  		DispatchID( LPOLESTR );
	CComPtr< IUnknown >				m_pUnkMarshaler;
	TSafeStringMap< CComVariant >	m_strmapProperties;
};

#endif //__BROWSERCAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\brwcap.cpp ===
// BrwCap.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f BrwCapps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "BrwCap.h"

#include "BrwCap_i.c"
#include <initguid.h>
#include "BrowCap.h"
#include "CapMap.h"
#include "Monitor.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

CBrwCapModule _Module;
extern HINSTANCE g_hModuleInstance;

/////////////////////////////////////////////////////////////////////////////
//  CPgCntModule methods
//
CBrwCapModule::CBrwCapModule()
    :   m_pMonitor(NULL),
        m_pCapMap(NULL)
{
}


void
CBrwCapModule::Init(
    _ATL_OBJMAP_ENTRY*  p,
    HINSTANCE           h )
{
    CComModule::Init(p,h);

    _ASSERT( m_pMonitor == NULL);
    m_pMonitor = new CMonitor();
    
    _ASSERT( m_pCapMap == NULL);
    m_pCapMap = new CCapMap();
}

void
CBrwCapModule::Term()
{
    _ASSERT( m_pMonitor != NULL);
    delete m_pMonitor;
    m_pMonitor = NULL;

    _ASSERT( m_pCapMap != NULL);
    delete m_pCapMap;
    m_pCapMap = NULL;

    CComModule::Term();
}

LONG
CBrwCapModule::Lock()
{
    _ASSERT( m_pMonitor != NULL );
    _ASSERT( m_pCapMap != NULL );

	CLock l(m_cs);
	LONG lc = CComModule::Lock();
    ATLTRACE("CBrwCapModule::Lock(%d)\n", lc);

    if (lc == 1)
    {
        m_pCapMap->StartMonitor();
    }

    return lc;
}

LONG
CBrwCapModule::Unlock()
{
	CLock l(m_cs);
	LONG lc = CComModule::Unlock();
    ATLTRACE("CBrwCapModule::Unlock(%d)\n", lc);

	if ( lc == 0 )
	{
        _ASSERT( m_pMonitor != NULL);
        m_pCapMap->StopMonitor();
        m_pMonitor->StopAllMonitoring();
        
        _ASSERT( m_pCapMap != NULL);
	}

	return lc;
}

CMonitor*
CBrwCapModule::Monitor()
{
    _ASSERT( m_pMonitor != NULL);
    return m_pMonitor;
}

CCapMap*
CBrwCapModule::CapMap()
{
    _ASSERT( m_pCapMap != NULL);
    return m_pCapMap;
}


BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_BrowserCap, CBrowserCap)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		g_hModuleInstance = hInstance;
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        ATLTRACE( _T("BrowsCap.dll unloading\n") );
		_Module.Term();
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\makefile.inc ===
#
# Supplemental rules for generating Type library.
#

# CDROOT=$(_NTTREE)\inetsrv
CDROOT=$(_NTTREE)

#CopyFiles
#copy .ini files
CopyFiles:
	#if not exist "$(CDROOT)" mkdir $(CDROOT)
	perl -S xcopy2binplace.pl /d /i browscap.ini $(CDROOT)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\capmap.h ===
// CapMap.h: interface for the CCapMap class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "Monitor.h"
#include "RdWrt.h"
#include "StrMap.h"
#include "BrowCap.h"


class CCapNotify : public CMonitorNotify
{
public:
                    CCapNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CCapNotify,CMonitorNotify )


// The capabilites map is a singleton object (only one instance will exist).
// It provides each BrowserCap object with access to the stored capabilites
// while storing it in a central location (increasing the benifit of caching
// and decreasing memory requirements)

typedef TVector< String >		StringVecT;

class CCapMap
{
public:
            	CCapMap();

	CBrowserCap *			LookUp(const String& szBrowser);

    void        			StartMonitor();
    void        			StopMonitor();

private:
	enum {
		DWSectionBufSize = 16384		// max size of an entire BrowsCap.INI section that we allow
	};

    bool    Refresh();

	String					m_strIniFile;
    CCapNotifyPtr           m_pSink;
};

#endif // !defined(AFX_CAPMAP_H__2AE59261_E295_11D0_8A81_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by BrwCap.rc
//
#define IDS_PROJNAME                    100
#define IDR_BROWSERCAP                  101
#define IDS_ERROR_NOSVR					102
#define IDS_ERROR_SOURCE				103
#define IDS_ERROR_PROP_RO				104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\capmap.cpp ===
// CapMap.cpp: implementation of the CCapMap class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "asptlb.h"
#include "context.h"
#include "BrwCap.h"
#include "CapMap.h"

#define MAX_RESSTRINGSIZE 512

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

// Global Browser Capabilities Cache.
//
// This is a doubly indexed list --
//    the outer level contains the HTTP_USER_AGENT string.  The sub-array is the property in question
// 
// Example: g_strmapBrowsCapINI["Mozilla 3.0"]["VBScript"] retrieves VBScript property of browser
//          "Mozilla 3.0".  (of course, in practice HTTP_USER_AGENT strings are quite long.)
//
// 
// A note about the data structure choice:
//
//  Many of the keys in BrowsCap.INI are very similiar to each other.  Examples:
//
//       [Mozilla/2.0 (compatible; MSIE 3.0B3; Windows 95)]
//       [Mozilla/2.0 (compatible; MSIE 3.0B3; Windows NT)]
//
// or
//
//       [Mozilla/1.22 (compatible; MSIE 2.0; Windows 95)]
//       [Mozilla/1.22 (compatible; MSIE 2.0c; Windows 95)]
//
// It's likely that excessive hash collisions could occur (these are hardly random keys!), especially
// with small hash modulus (and the table size would be relatively small.)  Therefore, the binary search
// array of the pre-existing TStringMap class seems best.
//
// The subkeys that store the properties could probably be hash tables, but there are so few of them,
// it probably does not matter.  We also use the TStringMap class purely for convenience (it happens to
// exist.)
//
// UNDONE: Cleanup must Release() the pointers (since they are not "smart" CComPtr's)
//
typedef TSafeStringMap<CBrowserCap *>	CacheMapT;

static CacheMapT  		g_strmapBrowsCapINI;	// cache of BrowsCap objects
static TVector<String>	g_rgstrWildcard;		// list of wildcards in BrowsCap.INI
static CReadWrite       g_rwWildcardLock;		// lock for wildcard array


//---------------------------------------------------------------------
// read in wildcards from browscap.ini into g_rgstrWildcard
//---------------------------------------------------------------------
void ReadWildcards(const String &strIniFile)
{
	// PERF NOTE: caller should check if rgstrWildcard[] is empty before
	// calling this function.  However, here we do one extra check
	// when we have the lock because caller should not bother to
	// secure a write lock when checking rgstrWildcard[].
	//
	g_rwWildcardLock.EnterWriter();
	if (g_rgstrWildcard.size() != 0)
	{
		g_rwWildcardLock.ExitWriter();
		return;
	}

	// first get all of the profiles sections into a buffer
	DWORD  dwAllocSize = 16384;
	TCHAR *szBuffer = new TCHAR[dwAllocSize];
	*szBuffer = _T('\0');
    DWORD dwSize;

    // ATLTRACE("ReadWildcards(%s)\n", strIniFile.c_str());

	while ((dwSize = GetPrivateProfileSectionNames(szBuffer, dwAllocSize, strIniFile.c_str())) == dwAllocSize-2  &&  dwSize > 0)
	{
		// reallocate the buffer and try again
		delete[] szBuffer;
		szBuffer = new TCHAR[dwAllocSize *= 2];
        *szBuffer = _T('\0');
	}

    if (dwSize == 0)
        ATLTRACE("ReadWildcards(%s) failed, err=%d\n", 
                 strIniFile.c_str(), GetLastError());

	TCHAR *szSave = szBuffer;

	// now put all wild-card containing entries into the list 
	while( *szBuffer != _T('\0') )
	{
		if (_tcspbrk(szBuffer, "[*?") != NULL)
			g_rgstrWildcard.push_back(szBuffer);

		// advance to the beginning of the next string
		while (*szBuffer != _T('\0'))
			szBuffer = CharNext(szBuffer);

		// now advance once more to get to the next string
		++szBuffer;
	}

	delete[] szSave;
	g_rwWildcardLock.ExitWriter();
}

//---------------------------------------------------------------------
// compare names to templates, *, ?, [, ], not legal filename characters
//
// Also compute # of matching wildcard characters.
//     FOR THIS TO WORK: caller must pass in an initialized counter!
//---------------------------------------------------------------------
bool
match(
    LPCTSTR szPattern,
    LPCTSTR szSubject,
    int *pcchWildcardMatched)
{
    LPTSTR rp;
    _TCHAR tc;

    if (*szPattern == '*')
    {
        ++szPattern;

        do
        {
            int cchWildcardSubMatch = 0;
            if (match(szPattern, szSubject, &cchWildcardSubMatch) == true)
            {
            	*pcchWildcardMatched += cchWildcardSubMatch;
                return true;
            }
        } while (++*pcchWildcardMatched, *szSubject++ != '\0');
    }

    else if (*szSubject == '\0')
        return *szPattern == '\0';

    else if (*szPattern == '[' && (rp = _tcschr(szPattern, ']')) != NULL)
    {
        while (*++szPattern != ']')
            if ((tc = *szPattern) == *szSubject
                    || (szPattern[1] == '-'
                    && (*(szPattern += 2) >= *szSubject && tc <= *szSubject)))
            {
                ++*pcchWildcardMatched;
                return match(rp + 1, ++szSubject, pcchWildcardMatched);
            }

        return false;
    }

    else if (*szPattern == '?')
    {
        ++*pcchWildcardMatched;
        return match(++szPattern, ++szSubject, pcchWildcardMatched);
    }

    else if (tolower(*szPattern) == tolower(*szSubject))
        return match(++szPattern, ++szSubject, pcchWildcardMatched);

    return false;
}

//---------------------------------------------------------------------
//  FindBrowser
//
// match the User Agent against all the wildcards in browscap.ini and
// return the best match. "Best Match" is defined here to mean the match
// requiring the fewest amount of wildcard substitutions.
//---------------------------------------------------------------------

#define INT_MAX int(unsigned(~0) >> 1)
String FindBrowser(const String &strUserAgent, const String &strIniFile)
{
	TVector<String>::iterator iter;
	String strT;

	if (g_rgstrWildcard.size() == 0)
		ReadWildcards(strIniFile);

	g_rwWildcardLock.EnterReader();

	int cchWildMatchMin = INT_MAX;
	for (iter = g_rgstrWildcard.begin(); iter < g_rgstrWildcard.end(); ++iter)
	{
		int cchWildMatchCurrent = 0;
		if (match((*iter).c_str(), strUserAgent.c_str(), &cchWildMatchCurrent) &&
			cchWildMatchCurrent < cchWildMatchMin)
		{
			cchWildMatchMin = cchWildMatchCurrent;
			strT = *iter;
		}
	}

	g_rwWildcardLock.ExitReader();

	// Backward compatibility: If nothing matches, then use
	// "Default Browser Capability Settings".  In the new
	// model, the catch all rule, "*" can also be used.
	//
	if (strT.length() == 0)
		strT = "Default Browser Capability Settings";

	return strT;
}

//---------------------------------------------------------------------
//  CCapNotify
//---------------------------------------------------------------------
CCapNotify::CCapNotify()
    :   m_isNotified(0)
{
}

void
CCapNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CCapNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}

//---------------------------------------------------------------------
//  CCapMap
//---------------------------------------------------------------------
//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CCapMap::CCapMap()
{
	static const String cszIniFile = _T("Browscap.ini");

	// get the path to the inifile containing the browser cap info
	_TCHAR szModule[ _MAX_PATH ];
	::GetModuleFileName(_Module.GetModuleInstance(), szModule, sizeof(szModule));
    ATLTRACE("CapMap: Module(%s)\n", szModule);
    
	// remove the filename and tack on the ini file name
	_TCHAR* pch = _tcsrchr(szModule, '\\');
	if (pch == NULL)
	{
		// the path should have at least one backslash
		_ASSERT(0);
		pch = szModule;
	}
	*(pch+1) = _T('\0');

	m_strIniFile = szModule + cszIniFile;
    ATLTRACE("CCapMap::CCapMap(%s)\n", m_strIniFile.c_str());

    // start monitoring the file
    m_pSink = new CCapNotify();
}

void
CCapMap::StartMonitor()
{
    if ( _Module.Monitor() )
    {
        _Module.Monitor()->MonitorFile( m_strIniFile.c_str(), m_pSink );
        ATLTRACE("CCapMap::StartMonitor(%s)\n", m_strIniFile.c_str());
    }
    else
        ATLTRACE("CCapMap::StartMonitor -- no monitor\n");
}

void
CCapMap::StopMonitor()
{
    if ( _Module.Monitor() )
    {
        _Module.Monitor()->StopMonitoringFile( m_strIniFile.c_str() );
        ATLTRACE("CCapMap::StopMonitor(%s)\n", m_strIniFile.c_str());
    }
    else
        ATLTRACE("CCapMap::StopMonitor -- no monitor\n");
}

CBrowserCap *
CCapMap::LookUp(
	const String& szBrowser)
{
	Refresh();

	CLock csT(g_strmapBrowsCapINI);
	CacheMapT::referent_type &rpBCobj = g_strmapBrowsCapINI[szBrowser];

	if (rpBCobj == NULL)
	{
		rpBCobj = new CComObject<CBrowserCap>;

		// Complete construction and AddRef copy we keep in cache.
		// NOTE: Since caller (class factory) does implicit AddRef via QueryInterface,
		//       the convention of this function is slightly different from COM std.
		//       CALLER IS RESPONSIBLE TO ADDREF RETURNED OBJECT
		//
		rpBCobj->FinalConstruct();
		rpBCobj->AddRef();

        // ATLTRACE("LookUp(%s)\n", szBrowser.c_str());

		// Get Browser Properties
		_TCHAR szSection[DWSectionBufSize];
		if (GetPrivateProfileSection
				(
				szBrowser.c_str(),		// section
				szSection,				// return buffer
				DWSectionBufSize,		// size of return buffer
				m_strIniFile.c_str()	// .INI name
				) == 0)
		{
			// If this call fails, that means the default browser does not exist either, so
			// everything is "unknown".
			//
			String szT = FindBrowser(szBrowser, m_strIniFile);
			if (GetPrivateProfileSection
					(
					szT.c_str(),			// section
					szSection,				// return buffer
					DWSectionBufSize,		// size of return buffer
					m_strIniFile.c_str()	// .INI name
					) == 0)
            {
                ATLTRACE("GPPS(%s) failed, err=%d\n", 
                         szT.c_str(), GetLastError());
                return rpBCobj;
            }
		}

		// Loop through szSection, which contains all the key=value pairs and add them
		// to the browser instance property list.  If we find a "Parent=" Key, save the
		// value to add the parent's properties later.
		//
		TCHAR *szParent;
		do
		{
			szParent = NULL;
			TCHAR *szKeyAndValue = szSection;
			while (*szKeyAndValue)
			{
				TCHAR *szKey = szKeyAndValue;					// save the key
				TCHAR *szValue = _tcschr(szKey, '=');			// find address of value part (-1)
				szKeyAndValue += _tcslen(szKeyAndValue) + 1;	// advance KeyAndValue to the next pair

				if (szValue == NULL)
					continue;

				*szValue++ = '\0';								// separate key and value with NUL; advance

				if (_tcsicmp(szKey, _T("Parent")) == 0)
					szParent = szValue;
				else
					rpBCobj->AddProperty(szKey, szValue);
			}

			// We stored all the attributes on this level.  Ascend to parent level (if it exists)
			if (szParent)
			{
				if (GetPrivateProfileSection
						(
						szParent,				// section
						szSection,				// return buffer
						DWSectionBufSize,		// size of return buffer
						m_strIniFile.c_str()	// .INI name
						) == 0)
				{
					// If this call fails, quit now.
					//
					String szT = FindBrowser(szParent, m_strIniFile);
					if (GetPrivateProfileSection
							(
							szT.c_str(),			// section
							szSection,				// return buffer
							DWSectionBufSize,		// size of return buffer
							m_strIniFile.c_str()	// .INI name
							) == 0)
                    {
                        ATLTRACE("GPPS(%s) failed, err=%d\n", 
                                 szT.c_str(), GetLastError());
                        return rpBCobj;
                    }
				}
			}
		} while (szParent);
	}

	return rpBCobj;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date with
//  the ini file.  If so, the cached will be purged
//
//---------------------------------------------------------------------------
bool
CCapMap::Refresh()
{
    bool rc = false;
    if ( m_pSink->IsNotified() )
    {
        // Clear the cache

        CLock csT(g_strmapBrowsCapINI);
        g_strmapBrowsCapINI.clear();
        rc = true;

        // clear the list of wildcards.
        // NOTE: each browser request creates new CCapMap object.
        //       the constructor will see the size is zero and reconstruct

        g_rwWildcardLock.EnterWriter();
        g_rgstrWildcard.clear();
        g_rwWildcardLock.ExitWriter();
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\browser\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED

#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
#include <comdef.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CMonitor;
class CCapMap;
class CBrwCapModule : public CComModule
{
public:
                CBrwCapModule();

    // CComModule methods
    void        Init( _ATL_OBJMAP_ENTRY*, HINSTANCE );
    void        Term();
	LONG		Lock();
	LONG		Unlock();

    // CPgCntModule methods
    CMonitor*   Monitor();
    CCapMap*    CapMap();

private:
	CComAutoCriticalSection	m_cs;
    CMonitor*               m_pMonitor;
    CCapMap*                m_pCapMap;
};

extern CBrwCapModule _Module;

#include <atlcom.h>

//#include <list>
//#include <vector>
#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"


#include "MyDebug.h"
#include "MyString.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__78FFB015_E0E1_11D0_8A81_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\controt.cpp ===
// ContRot.cpp : Implementation of DLL Exports.

// You will need the NT SUR Beta 2 SDK or VC 4.2 in order to build this 
// project.  This is because you will need MIDL 3.00.15 or higher and new
// headers and libs.  If you have VC 4.2 installed, then everything should
// already be configured correctly.

// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f ContRotps.mak in the project directory.

#include "stdafx.h"
#include <new>
#include "resource.h"
#include "initguid.h"
#include "ContRot.h"
#include "RotObj.h"
#include "debug.h"
#include "Monitor.h"
#include "lock.h"

#define IID_DEFINED
#include "ContRot_i.c"

CMonitor*   g_pMonitor = NULL;
extern HINSTANCE g_hModuleInstance;

CContRotModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_ContentRotator, CContentRotator)
END_OBJECT_MAP()

LONG
CContRotModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CContRotModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);

	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
        // final unlock
        _ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
	}
	return lc;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
        DEBUG_START;
        g_hModuleInstance = hInstance;
        
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
        DEBUG_INIT();

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

        DEBUG_TERM();
		_Module.Term();
        DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !DBG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   NOP_FUNCTION
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !DBG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\mystring.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\context.cpp ===
#include "stdafx.h"
#include "..\shared\src\context.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


#define ACTIVE_SERVER_PAGES 1


#if DBG

// taken from <crtdbg.h> -- it's too much trouble to include this file
// (lots of errors due to their use of _DEBUG vs. DBG macro, multiple inclusions & dependencies & such)
//
#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //DBG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\instrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\InStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\finstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\FInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ContRot.rc
//
#define IDS_CONTENTROTATOR_DESC	1



// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\rotobj.cpp ===
// RotObj.cpp : Implementation of CContentRotator class, which does all the
// interesting work

// George V. Reilly  a-georgr@microsoft.com georger@microcrafts.com  Nov/Dec 96

// Shortcomings: this works fine for small-to-medium sized tip files
// (under 2000 lines), but it's not very efficient for large ones.


#include "stdafx.h"
#include <new>
#include "ContRot.h"
#include "RotObj.h"

#include "debug.h"
#include <time.h>
#include "Monitor.h"

#define MAX_WEIGHT      10000
#define INVALID_WEIGHT  0xFFFFFFFF


extern CMonitor* g_pMonitor;

//
// forward declaration of some utility functions
//

LPTSTR  TcsDup(LPCTSTR ptsz);
LPTSTR  GetLine(LPTSTR& rptsz);
BOOL    IsBlankString(LPCTSTR ptsz);
UINT    GetWeight(LPTSTR& rptsz);
LPTSTR  GetTipText(LPTSTR& rptsz);
HRESULT ReportError(DWORD dwErr);
HRESULT ReportError(HRESULT hr);


#if DBG
 #define ASSERT_VALID(pObj)  \
    do {ASSERT(pObj != NULL); pObj->AssertValid();} while (0)
#else
 #define ASSERT_VALID(pObj)  ((void)0)
#endif


class CTipNotify : public CMonitorNotify
{
public:
                    CTipNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CTipNotify,CMonitorNotify )

CTipNotify::CTipNotify()
    :   m_isNotified(0)
{
}

void
CTipNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CTipNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}


//
// "Tip", as in tip of the day
//

class CTip
{
public:
    CTip(
        LPCTSTR ptszTip,
        UINT    uWeight)
        : m_ptsz(ptszTip),
          m_uWeight(uWeight),
          m_cServingsLeft(uWeight),
          m_pPrev(NULL),
          m_pNext(NULL)
    {
        ASSERT_VALID(this);
    }
    
    ~CTip()
    {
        ASSERT_VALID(this);
        if (m_pPrev != NULL)
            m_pPrev->m_pNext = NULL;
        if (m_pNext != NULL)
            m_pNext->m_pPrev = NULL;
    }

#if DBG
    void
    AssertValid() const;
#endif

    LPCTSTR m_ptsz;         // data string
    UINT    m_uWeight;      // weight of this tip, 1 <= m_uWeight <= MAX_WEIGHT
    UINT    m_cServingsLeft;// how many servings left: no more than m_uWeight
    CTip*   m_pPrev;        // Previous in tips list
    CTip*   m_pNext;        // Next in tips list
};


//
// A list of CTips, which are read from a datafile
//

class CTipList
{
public:
    CTipList()
        : m_ptszFilename(NULL),
          m_ptszData(NULL),
          m_cTips(0),
          m_uTotalWeight(0),
          m_pTipsListHead(NULL),
          m_pTipsListTail(NULL),
          m_fUTF8(false)
    {
        m_pNotify = new CTipNotify;
        ASSERT_VALID(this);
    }

    ~CTipList()
    {
        ASSERT_VALID(this);

        // check for both a valid Filename ptr as well as a valid Monitor ptr.
        // If the ContRotModule::Unlock is called prior to this destructor,then
        // the Monitor object has already been cleaned up and deleted.

        DeleteTips();
        ASSERT_VALID(this);
    }

    HRESULT
    ReadDataFile(
        LPCTSTR ptszFilename);

    HRESULT
    SameAsCachedFile(
        LPCTSTR ptszFilename,
        BOOL&   rfIsSame);

    UINT
    Rand() const;

    void
    AppendTip(
        CTip* pTip);

    void
    RemoveTip(
        CTip* pTip);

    HRESULT
    DeleteTips();

#if DBG
    void
    AssertValid() const;
#endif

    LPTSTR          m_ptszFilename;     // Name of tips file
    LPTSTR          m_ptszData;         // Buffer containing contents of file
    UINT            m_cTips;            // # tips
    UINT            m_uTotalWeight;     // sum of all weights
    CTip*           m_pTipsListHead;    // Head of list of tips
    CTip*           m_pTipsListTail;    // Tail of list of tips
    CTipNotifyPtr   m_pNotify;
    bool            m_fUTF8;
};



//
// A class that allows you to enter a critical section and automatically
// leave when the object of this class goes out of scope.  Also provides
// the means to leave and re-enter as needed while protecting against
// entering or leaving out of sync.
//

class CAutoLeaveCritSec
{
public:
    CAutoLeaveCritSec(
        CRITICAL_SECTION* pCS)
        : m_pCS(pCS), m_fInCritSec(FALSE)
    {Enter();}
    
    ~CAutoLeaveCritSec()
    {Leave();}
    
    // Use this function to re-enter the critical section.
    void Enter()
    {if (!m_fInCritSec) {EnterCriticalSection(m_pCS); m_fInCritSec = TRUE;}}

    // Use this function to leave the critical section before going out
    // of scope.
    void Leave()
    {if (m_fInCritSec)  {LeaveCriticalSection(m_pCS); m_fInCritSec = FALSE;}}

protected:    
    CRITICAL_SECTION*   m_pCS;
    BOOL                m_fInCritSec;
};



//
// Wrapper class for handles to files opened for reading
//

class CHFile
{
public:
    CHFile(LPCTSTR ptszFilename)
    {
        m_hFile = ::CreateFile(ptszFilename, GENERIC_READ, FILE_SHARE_READ,
                               NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                               NULL);
    }

    ~CHFile()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
            ::CloseHandle(m_hFile);
    }

    operator HANDLE() const
    {return m_hFile;}

    BOOL
    operator!() const
    {return (m_hFile == INVALID_HANDLE_VALUE);}

private:
    // private, unimplemented default ctor, copy ctor, and op= to prevent
    // compiler synthesizing them
    CHFile();
    CHFile(const CHFile&);
    CHFile& operator=(const CHFile&);

    HANDLE m_hFile;
};



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Public Methods

//
// ctor
//

CContentRotator::CContentRotator()
    : m_ptl(NULL),
      m_ptlUsed(NULL)
{
    TRACE0("CContentRotator::CContentRotator\n");

    InitializeCriticalSection(&m_CS);
#if (_WIN32_WINNT >= 0x0403)
    SetCriticalSectionSpinCount(&m_CS, 1000);
#endif

    // Seed the random-number generator with the current time so that
    // the numbers will be different each time that we run
    ::srand((unsigned) time(NULL));

    ATLTRY(m_ptl = new CTipList);
    ATLTRY(m_ptlUsed = new CTipList);
}



//
// dtor
//

CContentRotator::~CContentRotator()
{
    TRACE0("CContentRotator::~CContentRotator\n");

    DeleteCriticalSection(&m_CS);
    delete m_ptl;
    delete m_ptlUsed;
}



//
// ATL Wizard generates this
//

STDMETHODIMP CContentRotator::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IContentRotator,
    };

    for (int i=0; i<sizeof(arr)/sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



//
// Read in the tips in bstrDataFile (a logical name), and return a random
// tip in pbstrRetVal
//

STDMETHODIMP
CContentRotator::ChooseContent(
    BSTR  bstrDataFile,
    BSTR* pbstrRetVal)
{
    HRESULT  hr = E_FAIL;

    try
    {
    //    TRACE1("ChooseContent(%ls)\n", bstrDataFile);

        if (bstrDataFile == NULL  ||  pbstrRetVal == NULL)
            return ::ReportError(E_POINTER);
        else
            *pbstrRetVal = NULL;

        CContext cxt;
        hr = cxt.Init( CContext::get_Server );
        if ( !FAILED(hr) )
        {
            // Do we have valid CTipLists?
            if ((m_ptl != NULL) && (m_ptlUsed != NULL))
            {
                // Map bstrDataFile (a logical name such as /controt/tips.txt) to
                // a physical filesystem name such as d:\inetpub\controt\tips.txt.
                CComBSTR bstrPhysicalDataFile;
                hr = cxt.Server()->MapPath(bstrDataFile, &bstrPhysicalDataFile);

                if (SUCCEEDED(hr))
                    hr = _ChooseContent(bstrPhysicalDataFile, pbstrRetVal);
            }
            else
            {
                hr = ::ReportError(E_OUTOFMEMORY);
            }
        }
        else
        {
            hr = ::ReportError(E_NOINTERFACE);
        }
    }
    catch ( std::bad_alloc& )
    {
        hr = ::ReportError(E_OUTOFMEMORY);
    }
    catch ( ... )
    {
        hr = E_FAIL;
    }
    return hr;
}



//
// Writes all of the entries in the tip file, each separated by an <hr>, back
// to the user's browser.  This can be used to proofread all of the entries.
//

STDMETHODIMP
CContentRotator::GetAllContent(
    BSTR bstrDataFile)
{
    HRESULT hr = E_FAIL;
    try
    {
        if (bstrDataFile == NULL)
            return ::ReportError(E_POINTER);

        CContext cxt;
        hr = cxt.Init( CContext::get_Server | CContext::get_Response );
        // Do we have valid Server and Response objects?
        if ( !FAILED( hr ) )
        {
            // Do we have valid CTipLists?
            if ( (m_ptl != NULL)  &&  (m_ptlUsed != NULL))
            {
                // Map bstrDataFile (a logical name such as /IISSamples/tips.txt) to
                // a physical filesystem name such as d:\inetpub\IISSamples\tips.txt.
                CComBSTR bstrPhysicalDataFile;
                hr = cxt.Server()->MapPath(bstrDataFile, &bstrPhysicalDataFile);

                // See note below about critical sections
                CAutoLeaveCritSec alcs(&m_CS);

                if (SUCCEEDED(hr))
                    hr = _ReadDataFile(bstrPhysicalDataFile, TRUE);

                if (SUCCEEDED(hr))
                {
                    const CComVariant cvHR(OLESTR("\n<hr>\n\n"));
                    BOOL  bFirstTip = TRUE;

                    for (CTip* pTip = m_ptl->m_pTipsListHead;
                         pTip != NULL;
                         pTip = pTip->m_pNext)
                    {
                        // Write the leading HR only on the first pass

                        if (bFirstTip == TRUE) {
                            cxt.Response()->Write(cvHR);
                            bFirstTip = FALSE;
                        }

                        // Write back to the user's browser, one tip at a time.
                        // This is more efficient than concatenating all of the
                        // tips into a potentially huge string and returning that.

                        CMBCSToWChar    convStr;
                        BSTR            pbstrTip;

                        // need to convert the string to Wide based on the UTF8 flag

                        if (hr = convStr.Init(pTip->m_ptsz, m_ptl->m_fUTF8 ? 65001 : CP_ACP)) {
                            break;
                        }

                        // make a proper BSTR out of the wide version

                        if (!(pbstrTip = ::SysAllocString(convStr.GetString()))) {
                            hr = ::ReportError( E_OUTOFMEMORY );
                            break;
                        }

                        cxt.Response()->Write(CComVariant(pbstrTip)); 
                        cxt.Response()->Write(cvHR);

                        ::SysFreeString(pbstrTip);
                    }
                }
            }
            else
            {
                hr = ::ReportError(E_OUTOFMEMORY);
            }

        }
        else
        {
            hr = ::ReportError(E_NOINTERFACE);
        }
    }
    catch ( std::bad_alloc& )
    {
        hr = ::ReportError( E_OUTOFMEMORY );
    }
    catch ( ... )
    {
        hr = E_FAIL;
    }
    return hr;
}



/////////////////////////////////////////////////////////////////////////////
// CContentRotator Private Methods

//
// Do the work of ChooseContent, but with a real filename, not with a
// virtual filename
//

HRESULT
CContentRotator::_ChooseContent(
    BSTR  bstrPhysicalDataFile,
    BSTR* pbstrRetVal)
{
    ASSERT(bstrPhysicalDataFile != NULL  &&  pbstrRetVal != NULL);
    
    // The critical section ensures that the remaining code in this
    // function is executing on only one thread at a time.  This ensures
    // that the cached contents of the tip list are consistent for the
    // duration of a call.

    // Actually, the critical section is not needed at all.  Because we
    // need to call Server.MapPath to map the virtual path of
    // bstrDataFile to a physical filesystem path, the OnStartPage method
    // must be called, as this is the only way that we can get access to
    // the ScriptingContext object and thereby the Server object.
    // However, the OnStartPage method is only called for page-level
    // objects (object is created and destroyed in a single page) and for
    // session-level objects.  Page-level objects don't have to worry
    // about protecting their data from multiple access (unless it's
    // global data shared between several objects) and neither do
    // session-level objects.  Only application-level objects need worry
    // about protecting their private data, but application-level objects
    // don't give us any way to map the virtual path.

    // The Content Rotator might be more useful it it were an
    // application-level object.  We would get better distribution of the
    // tips (see below) and do a lot less rereading of the data file.  The
    // trivial changes necessary to accept a filesystem path, such as
    // "D:\ContRot\tips.txt", instead of a virtual path, such as
    // "/IISSamples/tips.txt",are left as an exercise for the reader.

    CAutoLeaveCritSec alcs(&m_CS);

    HRESULT hr = _ReadDataFile(bstrPhysicalDataFile, FALSE);

    if (SUCCEEDED(hr))
    {
        const UINT uRand = m_ptl->Rand();
        UINT       uCumulativeWeight = 0;
        CTip*      pTip = m_ptl->m_pTipsListHead;
        LPCTSTR    ptszTip = NULL;
        
        for ( ; ; )
        {
            ASSERT_VALID(pTip);
            
            ptszTip = pTip->m_ptsz;
            uCumulativeWeight += pTip->m_uWeight;

            if (uCumulativeWeight <= uRand)
                pTip = pTip->m_pNext;
            else
            {
                // Found the tip.  Now we go through a bit of work to make
                // sure that each tip is served up with the correct
                // probability.  If the tip has already been served up as
                // many times as it's allowed (i.e., m_uWeight times), then
                // it's moved to the Used List.  Otherwise, it's (probably)
                // moved to the end of the Tips List, to reduce the
                // likelihood of it turning up too soon again and to
                // randomize the order of the tips in the list.  When all
                // tips have been moved to the Used List, we start afresh.

                // If the object is created, used, and destroyed in a
                // single page (i.e., it's not a session-level object),
                // then none of this does us any good.  The list is in
                // exactly the same order as it is in the data file and
                // we just have to hope that Rand() does give us
                // well-distributed random numbers.

                // If you expect a single user to see more than one tip,
                // you should use a session-level object, to benefit from
                // the better distribution of tips.  This would be the case
                // if you're serving up tips from the same file on multiple
                // pages, or if you have a page that automatically
                // refreshes itself, such as the one included in the
                // Samples directory.

                if (--pTip->m_cServingsLeft > 0)
                {
                    // Move it to the end of the list some of the time.
                    // If we move it there all of the time, then a heavily
                    // weighted tip is more likely to turn up a lot
                    // as the main list nears exhaustion.
                    if (rand() % 3 == 0)
                    {
                        // TRACE1("Move to End\n%s\n", ptszTip);
                        m_ptl->RemoveTip(pTip);
                        m_ptl->AppendTip(pTip);
                    }
                }
                else
                {
                    // TRACE1("Move to Used\n%s\n", ptszTip);
                    pTip->m_cServingsLeft = pTip->m_uWeight;  // reset
                    m_ptl->RemoveTip(pTip);
                    m_ptlUsed->AppendTip(pTip);

                    if (m_ptl->m_cTips == 0)
                    {
                        TRACE0("List exhausted; swapping\n");
                        
                        CTipList* const ptlTemp = m_ptl;
                        m_ptl = m_ptlUsed;
                        m_ptlUsed = ptlTemp;
                    }
                }

                break;
            }
        }

        //  TRACE2("total weight = %u, rand = %u\n",
        //         m_ptl->m_uTotalWeight, uRand);
        //  TRACE1("tip = `%s'\n", ptszTip);
        
        CMBCSToWChar    convStr;

        if (hr = convStr.Init(ptszTip, m_ptl->m_fUTF8 ? 65001 : CP_ACP));

        else {
            *pbstrRetVal = ::SysAllocString(convStr.GetString());
        }
    }

    return hr;
}




HRESULT
CContentRotator::_ReadDataFile(
    BSTR bstrPhysicalDataFile,
    BOOL fForceReread)
{
    USES_CONVERSION;    // needed for OLE2T
    LPCTSTR ptszFilename = OLE2T(bstrPhysicalDataFile);
    HRESULT hr = S_OK;

    if (ptszFilename == NULL) {
        return E_OUTOFMEMORY;
    }

    // Have we cached this tips file already?
    if (!fForceReread)
    {
        BOOL    fIsSame;
        HRESULT hr = m_ptl->SameAsCachedFile(ptszFilename, fIsSame);

        TRACE(_T("%same file\n"), fIsSame ? _T("S") : _T("Not s"));

        if (FAILED(hr)  ||  fIsSame)
            return hr;
    }
    
    // destroy any old tips
    m_ptl->DeleteTips();
    m_ptlUsed->DeleteTips();

    hr = m_ptl->ReadDataFile(ptszFilename);

    if (FAILED(hr)) {
        m_ptl->DeleteTips();
        m_ptlUsed->DeleteTips();
    }

    return hr;
}


/////////////////////////////////////////////////////////////////////////////
// CTipList Public Methods

//
// Read a collection of tips from ptszDataFile
//
// The file format is zero or more copies of the following:
//  One or more lines starting with "%%"
//  Each %% line contains zero or more directives:
//      #<weight>   (positive integer, 1 <= weight <= MAX_WEIGHT)
//      //<comment> (a comment that runs to the end of the line)
//  The tip text follows, spread out over several lines
//

HRESULT
CTipList::ReadDataFile(
    LPCTSTR ptszFilename)
{
    TRACE1("ReadDataFile(%s)\n", ptszFilename);

    UINT    weightSum = 0;

    if ( m_ptszFilename != NULL )
    {
        g_pMonitor->StopMonitoringFile( m_ptszFilename );
        delete [] m_ptszFilename;
    }

    m_ptszFilename = TcsDup(ptszFilename);

    if (m_ptszFilename == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Open the file
    CHFile hFile(m_ptszFilename);

    if (!hFile)
        return ::ReportError(::GetLastError());

    // Get the last-write-time and the filesize
    BY_HANDLE_FILE_INFORMATION bhfi;

    if (!::GetFileInformationByHandle(hFile, &bhfi))
        return ::ReportError(::GetLastError());

    // If it's more than 4GB, let's not even think about it!
    if (bhfi.nFileSizeHigh != 0)
        return ::ReportError(E_OUTOFMEMORY);

    // Calculate the number of TCHARs in the file
    const DWORD cbFile = bhfi.nFileSizeLow;
    const DWORD ctc    = cbFile / sizeof(TCHAR);

    // Allocate a buffer for the file's contents
    m_ptszData = NULL;
    ATLTRY(m_ptszData = new TCHAR [ctc + 2]);
    if (m_ptszData == NULL)
        return ::ReportError(E_OUTOFMEMORY);

    // Read the file into the memory buffer.  Let's be paranoid and
    // not assume that ReadFile gives us the whole file in one chunk.
    DWORD cbSeen = 0;

    do
    {
        DWORD cbToRead = cbFile - cbSeen;
        DWORD cbRead   = 0;

        if (!::ReadFile(hFile, ((LPBYTE) m_ptszData) + cbSeen,
                        cbToRead, &cbRead, NULL))
            return ::ReportError(::GetLastError());

        cbSeen += cbRead;
    } while (cbSeen < cbFile);

    m_ptszData[ctc] = _T('\0');   // Nul-terminate the string

    LPTSTR ptsz = m_ptszData;

#ifdef _UNICODE

#error "This file should NOT be compiled with _UNICODE defined!!!

    // Check for byte-order mark
    if (*ptsz == 0xFFFE)
    {
        // Byte-reversed Unicode file.  Swap the hi- and lo-bytes in each wchar
        for ( ;  ptsz < m_ptszData + ctc;  ++ptsz)
        {
            BYTE* pb = (BYTE*) ptsz;
            const BYTE bHi = pb[1];
            pb[1] = pb[0];
            pb[0] = bHi;
        }
        ptsz = m_ptszData;
    }

    if (*ptsz == 0xFEFF)
        ++ptsz; // skip the byte-order mark
#endif

    // check for the UTF-8 BOM
    if ((ctc > 3) 
        && (ptsz[0] == (TCHAR)0xef) 
        && (ptsz[1] == (TCHAR)0xbb) 
        && (ptsz[2] == (TCHAR)0xbf)) {

        // note its presence and advance the file pointer past it.

        m_fUTF8 = true;
        ptsz += 3;
    }

    // Finally, parse the file
    while (ptsz < m_ptszData + ctc)
    {
        UINT   uWeight     = GetWeight(ptsz);

        // a value of INVALID_WEIGHT for weight indicates that no weight was found,
        // i.e. an invalid data file, or the value was not valid.

        if (uWeight == INVALID_WEIGHT) {
            return ::ReportError((DWORD)ERROR_INVALID_DATA);
        }

        weightSum += uWeight;

        if (weightSum > MAX_WEIGHT) {
            return ::ReportError((DWORD)ERROR_INVALID_DATA);
        }

        LPTSTR ptszTipText = GetTipText(ptsz);

        if (!IsBlankString(ptszTipText)  &&  uWeight > 0)
        {
            CTip* pTip = NULL;
            ATLTRY(pTip = new CTip(ptszTipText, uWeight));
            if (pTip == NULL)
                return ::ReportError(E_OUTOFMEMORY);
            AppendTip(pTip);
        }
        else if (ptsz < m_ptszData + ctc)
        {
            // not at a terminating "%%" line at the end of the data file
            TRACE2("bad tip: tip = `%s', weight = %u\n", ptszTipText, uWeight);
        }
    }

    g_pMonitor->MonitorFile( m_ptszFilename, m_pNotify );

    if (m_uTotalWeight == 0  ||  m_cTips == 0)
        return ::ReportError((DWORD)ERROR_INVALID_DATA);

    return S_OK;
}



//
// Is ptszFilename the same file as m_ptszFilename in both its name
// and timestamp?
//

HRESULT
CTipList::SameAsCachedFile(
    LPCTSTR ptszFilename,
    BOOL&   rfIsSame)
{
    rfIsSame = FALSE;
    
    // Have we cached a file at all?
    if (m_ptszFilename == NULL)
        return S_OK;
    
    // Are the names the same?
    if (_tcsicmp(ptszFilename, m_ptszFilename) != 0)
        return S_OK;

#if 1
//    FILETIME ftLastWriteTime;
//    CHFile   hFile(ptszFilename);
//
//    if (!hFile)
//        return ::ReportError(::GetLastError());
//
//    if (!::GetFileTime(hFile, NULL, NULL, &ftLastWriteTime))
//        return ::ReportError(::GetLastError());
//
//    rfIsSame = (::CompareFileTime(&ftLastWriteTime, &m_ftLastWriteTime) == 0);
    if ( !m_pNotify->IsNotified() )
    {
        rfIsSame = TRUE;
    }
#else
    // The following is more efficient, but it won't work on Win95 with
    // Personal Web Server because GetFileAttributesEx is new to NT 4.0.

    WIN32_FILE_ATTRIBUTE_DATA wfad;

    if (!::GetFileAttributesEx(ptszFilename, GetFileExInfoStandard,
                              (LPVOID) &wfad))
        return ::ReportError(::GetLastError());

    rfIsSame = (::CompareFileTime(&wfad.ftLastWriteTime,
                                  &m_ftLastWriteTime) == 0);
#endif

    return S_OK;
}



//
// Generate a random number in the range 0..m_uTotalWeight-1
//

UINT
CTipList::Rand() const
{
    UINT u;
    
    ASSERT(m_uTotalWeight > 0);
    
    if (m_uTotalWeight == 1)
        return 0;
    else if (m_uTotalWeight <= RAND_MAX + 1)
        u = rand() % m_uTotalWeight;
    else
    {
        // RAND_MAX is only 32,767.  This gives us a bigger range
        // of random numbers if the weights are large.
        u = ((rand() << 15) | rand()) % m_uTotalWeight;
    }
    
    ASSERT(0 <= u  &&  u < m_uTotalWeight);
    
    return u;
}



//
// Append a tip to the list
//

void
CTipList::AppendTip(
    CTip* pTip)
{
    ASSERT_VALID(this);

    pTip->m_pPrev = pTip->m_pNext = NULL;
    ASSERT_VALID(pTip);

    pTip->m_pPrev = m_pTipsListTail;

    if (m_pTipsListTail == NULL)
        m_pTipsListHead = pTip;
    else
        m_pTipsListTail->m_pNext = pTip;

    m_pTipsListTail = pTip;
    ++m_cTips;
    m_uTotalWeight += pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Remove a tip from somewhere in the list
// 

void
CTipList::RemoveTip(
    CTip* pTip)
{
    ASSERT_VALID(this);
    ASSERT_VALID(pTip);

    ASSERT(m_cTips > 0);

    if (m_cTips == 1)
    {
        ASSERT(m_pTipsListHead == pTip  &&  pTip == m_pTipsListTail);
        m_pTipsListHead = m_pTipsListTail = NULL;
    }
    else if (pTip == m_pTipsListHead)
    {
        ASSERT(m_pTipsListHead->m_pNext != NULL);
        m_pTipsListHead = m_pTipsListHead->m_pNext;
        m_pTipsListHead->m_pPrev = NULL;
    }
    else if (pTip == m_pTipsListTail)
    {
        ASSERT(m_pTipsListTail->m_pPrev != NULL);
        m_pTipsListTail = m_pTipsListTail->m_pPrev;
        m_pTipsListTail->m_pNext = NULL;
    }
    else
    {
        ASSERT(m_cTips >= 3);
        pTip->m_pPrev->m_pNext = pTip->m_pNext;
        pTip->m_pNext->m_pPrev = pTip->m_pPrev;
    }

    pTip->m_pPrev = pTip->m_pNext = NULL;
    --m_cTips;
    m_uTotalWeight -= pTip->m_uWeight;

    ASSERT_VALID(this);
}



//
// Destroy the list of tips and reset all member variables
//

HRESULT
CTipList::DeleteTips()
{
    ASSERT_VALID(this);

    CTip* pTip = m_pTipsListHead;
    
    for (UINT i = 0;  i < m_cTips;  ++i)
    {
        pTip = pTip->m_pNext;
        delete m_pTipsListHead;
        m_pTipsListHead = pTip;
    }

    ASSERT(pTip == NULL  &&  m_pTipsListHead == NULL);

    // check for both a valid Filename ptr as well as a valid Monitor ptr.
    // If the ContRotModule::Unlock is called prior to this destructor,then
    // the Monitor object has already been cleaned up and deleted.

    if ( (m_ptszFilename != NULL) && (g_pMonitor != NULL) )
    {
        g_pMonitor->StopMonitoringFile( m_ptszFilename );
    }
    delete [] m_ptszFilename;
    delete [] m_ptszData;

    m_ptszFilename = m_ptszData = NULL;
//    m_ftLastWriteTime.dwLowDateTime = m_ftLastWriteTime.dwHighDateTime = 0;
    m_cTips = m_uTotalWeight = 0;
    m_pTipsListHead = m_pTipsListTail = NULL;

    ASSERT_VALID(this);

    return S_OK;
}



#if DBG

// Paranoia: check that Tips and TipLists are internally consistent.
// Very useful in catching bugs.

void
CTip::AssertValid() const
{
    ASSERT(m_ptsz != NULL  &&  m_uWeight > 0);
    ASSERT(0 < m_cServingsLeft  &&  m_cServingsLeft <= m_uWeight);
    ASSERT(m_pPrev == NULL  ||  m_pPrev->m_pNext == this);
    ASSERT(m_pNext == NULL  ||  m_pNext->m_pPrev == this);
}



void
CTipList::AssertValid() const
{
    if (m_cTips == 0)
    {
        ASSERT(m_pTipsListHead == NULL  &&  m_pTipsListTail == NULL);
        ASSERT(m_uTotalWeight == 0);
    }
    else
    {
        ASSERT(m_pTipsListHead != NULL  &&  m_pTipsListTail != NULL);
        ASSERT(m_pTipsListHead->m_pPrev == NULL);
        ASSERT(m_pTipsListTail->m_pNext == NULL);
        ASSERT(m_uTotalWeight > 0);

        if (m_cTips == 1)
            ASSERT(m_pTipsListHead == m_pTipsListTail);
        else
            ASSERT(m_pTipsListHead != m_pTipsListTail);
    }

    UINT  uWeight = 0;
    CTip* pTip = m_pTipsListHead;
    UINT  i;
    
    for (i = 0;  i < m_cTips;  ++i)
    {
        ASSERT_VALID(pTip);
        uWeight += pTip->m_uWeight;

        if (i < m_cTips - 1)
            pTip = pTip->m_pNext;
    }

    ASSERT(uWeight == m_uTotalWeight);
    ASSERT(pTip == m_pTipsListTail);
}

#endif

/////////////////////////////////////////////////////////////////////////////
// Utility functions

//
// Make a copy of a TSTR that can be deleted with operator delete[]
//

static LPTSTR
TcsDup(
    LPCTSTR ptsz)
{
    LPTSTR ptszNew = NULL;
    ATLTRY(ptszNew = new TCHAR [_tcslen(ptsz) + 1]);
    if (ptszNew != NULL)
        _tcscpy(ptszNew, ptsz);
    return ptszNew;
}



//
// reads a \n-terminated string from rptsz and modifies rptsz to
// point after the end of that string
//

static LPTSTR
GetLine(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcspbrk(rptsz, _T("\n"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > ptszOrig  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no newline, so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetLine: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Is the string blank?
//

static BOOL
IsBlankString(
    LPCTSTR ptsz)
{
    if (ptsz == NULL)
        return TRUE;

    while (*ptsz != _T('\0'))
        if (!_istspace(*ptsz))
            return FALSE;
        else
            ptsz++;

    return TRUE;
}



//
// Read a weight line from rptsz and update rptsz to point after the
// end of any %% lines.
//

static UINT
GetWeight(
    LPTSTR& rptsz)
{
    UINT u = INVALID_WEIGHT; // default to invalid weight
    
    while (*rptsz == _T('%'))
    {
        LPTSTR ptsz = GetLine(rptsz);

        if (ptsz[1] == _T('%'))
        {
            u = 1;          // now that the format is correct, default to 1

            ptsz +=2;   // Skip "%%"

            while (*ptsz != _T('\0'))
            {
                while (_istspace(*ptsz))
                    ptsz++;

                if (*ptsz == _T('/')  &&  ptsz[1] == _T('/'))
                {
                    // TRACE1("// `%s'\n", ptsz+2);
                    break;  // a comment: ignore the rest of the line
                }
                else if (*ptsz == _T('#'))
                {
                    ptsz++;

                    if (_T('0') <= *ptsz  &&  *ptsz <= _T('9'))
                    {
                        LPTSTR ptsz2;
                        u = _tcstoul(ptsz, &ptsz2, 10);
                        ptsz = ptsz2;
                        // TRACE1("#%u\n", u);

                        if (u > MAX_WEIGHT)
                            u = MAX_WEIGHT; // clamp
                    }
                    else    // ignore word
                    {
                        while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                            ptsz++;
                    }
                }
                else    // ignore word
                {
                    while (*ptsz != _T('\0')  &&  !_istspace(*ptsz))
                        ptsz++;
                }
            }
        }
    }

    return u;
}



//
// Read the multiline tip text.  Updates rptsz to point past the end of it.
//

static LPTSTR
GetTipText(
    LPTSTR& rptsz)
{
    LPTSTR ptszOrig = rptsz;
    LPTSTR ptszEol = _tcsstr(rptsz, _T("\n%%"));

    if (ptszEol != NULL)
    {
        // is it "\r\n"?
        if (ptszEol > rptsz  &&  ptszEol[-1] == _T('\r'))
            ptszEol[-1] = _T('\0');
        else
            ptszEol[0] = _T('\0');

        rptsz = ptszEol + 1;
    }   
    else
    {
        // no "\n%%", so point past the end of the string
        rptsz += _tcslen(rptsz);
    }

    // TRACE1("GetTipText: `%s'\n", ptszOrig);
    return ptszOrig;
}



//
// Set the Error Info.  It's up to the calling application to
// decide what to do with it.  By default, Denali/VBScript will
// print the error number (and message, if there is one) and
// abort the page.
//

static HRESULT
ReportError(
    HRESULT hr,
    DWORD   dwErr)
{
    HLOCAL pMsgBuf = NULL;

    // If there's a message associated with this error, report that
    if (::FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, dwErr,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
            (LPTSTR) &pMsgBuf, 0, NULL)
        > 0)
    {
        AtlReportError(CLSID_ContentRotator, (LPCTSTR) pMsgBuf,
                       IID_IContentRotator, hr);
    }

    // TODO: add some error messages to the string resources and
    // return those, if FormatMessage doesn't return anything (not
    // all system errors have associated error messages).
    
    // Free the buffer, which was allocated by FormatMessage
    if (pMsgBuf != NULL)
        ::LocalFree(pMsgBuf);

    return hr;
}



//
// Report a Win32 error code
//

static HRESULT
ReportError(
    DWORD dwErr)
{
    return ::ReportError(HRESULT_FROM_WIN32(dwErr), dwErr);
}



//
// Report an HRESULT error
//

static HRESULT
ReportError(
    HRESULT hr)
{
    return ::ReportError(hr, (DWORD) hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\rotobj.h ===
// RotObj.h : Declaration of the CContentRotator


#include "resource.h"       // main symbols
#include <asptlb.h>
#include "context.h"

class CTipList;  // forward declaration

/////////////////////////////////////////////////////////////////////////////
// ContRot

class CContentRotator : 
    public CComDualImpl<IContentRotator, &IID_IContentRotator, &LIBID_ContentRotator>,
    public ISupportErrorInfo,
    public CComObjectRoot,
    public CComCoClass<CContentRotator,&CLSID_ContentRotator>
{
public:
    CContentRotator();
    ~CContentRotator();

BEGIN_COM_MAP(CContentRotator)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IContentRotator)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

//DECLARE_NOT_AGGREGATABLE(CContentRotator) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation.  The default is to support it

DECLARE_REGISTRY(CContentRotator,
                 _T("MSWC.ContentRotator.1"),
                 _T("MSWC.ContentRotator"),
                 IDS_CONTENTROTATOR_DESC,
                 THREADFLAGS_BOTH)

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IContentRotator
public:
	// for free-threaded marshalling
DECLARE_GET_CONTROLLING_UNKNOWN()
	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}
	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}


    STDMETHOD(ChooseContent)(
        BSTR bstrDataFile,
        BSTR* pbstrRetVal);

    STDMETHOD(GetAllContent)(
        BSTR bstrDataFile);
    
private:
    CTipList*           m_ptl;
    CTipList*           m_ptlUsed;              // List of tips already sent
    CRITICAL_SECTION    m_CS;

    HRESULT
    _ChooseContent(
        BSTR bstrPhysicalDataFile,
        BSTR* pbstrRetVal);

    HRESULT
    _ReadDataFile(
        BSTR bstrPhysicalDataFile,
        BOOL fForceReread);

	CComPtr<IUnknown>		m_pUnkMarshaler;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\mem.cpp ===
#include "stdafx.h"
#include "..\shared\src\mem.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\mystring.cpp ===
#include "stdafx.h"
#include "..\shared\src\MyString.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\controt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#pragma once
#ifndef _STDAFX_H_
#define _STDAFX_H_

#define STRICT

#include <atlbase.h>
#include <mtx.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CContRotModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CContRotModule _Module;

#include <algorithm>
using namespace std;

#include <atlcom.h>
#include "mystring.h"
#include "strmap.h"
#include "myvector.h"
#include "mydebug.h"

#define ARRAYSIZE(a)	(sizeof(a)/sizeof(*(a)))

#endif	// !_STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\linkfile.cpp ===
// LinkFile.cpp: implementation of the CLinkFile class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NxtLnk.h"
#include "LinkFile.h"
#include "NextLink.h"

extern CMonitor* g_pMonitor;

//--------------------------------------------------------------------
//  IsTab
//
//  Function object to read a stream until a tab is encounterd
//
//--------------------------------------------------------------------
struct IsTab : public CharCheck
{
    virtual bool    operator()(_TCHAR);
};

bool
IsTab::operator()(
    _TCHAR  c )
{
    return ( c == _T('\t') );
}

//--------------------------------------------------------------------
//  CLinkNotify
//--------------------------------------------------------------------
CLinkNotify::CLinkNotify()
    :   m_isNotified(0)
{
}

void
CLinkNotify::Notify()
{
    ::InterlockedExchange( &m_isNotified, 1 );
}

bool
CLinkNotify::IsNotified()
{
    return ( ::InterlockedExchange( &m_isNotified, 0 ) ? true : false );
}

//---------------------------------------------------------------------
//  CLinkFile
//---------------------------------------------------------------------

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLinkFile::CLinkFile(
    const String&   strFile )
    :   m_bIsOkay( false ),
        m_strFile( strFile ),
        m_fUTF8(false)
{
    m_pNotify = new CLinkNotify;

    bool loadStatus  =  LoadFile ();

    if ( loadStatus )
    {
        g_pMonitor->MonitorFile( m_strFile.c_str(), m_pNotify );
    }
}

CLinkFile::~CLinkFile()
{
    if ( g_pMonitor )
    {
        g_pMonitor->StopMonitoringFile( m_strFile.c_str() );
    }
}

int
CLinkFile::LinkIndex(
    const String&   strPage )
{
    int rc = 0;
    for ( int i = 0; i < m_links.size(); i++ )
    {
        if ( m_links[i]->IsEqual( strPage ) )
        {
            rc = i+1;
            i = m_links.size();
        }
    }
    return rc;
}

CLinkPtr
CLinkFile::Link(
    int nIndex )
{
    CLinkPtr pLink = NULL;

    if ( m_links.size() > 0 )
    {
        if ( nIndex > m_links.size() )
        {
            pLink = m_links.front();
        }
        else if ( nIndex < 1 )
        {
            pLink = m_links.back();
        }
        else
        {
            pLink = m_links[nIndex-1];
        }
    }
    return pLink;
}

CLinkPtr
CLinkFile::NextLink(
    const String&   strPage )
{
    CLinkPtr pLink;
    int nIndex = LinkIndex( strPage );
    if ( nIndex > 0 )
    {
        pLink = Link( nIndex + 1 );
    }
    else if ( m_links.size() > 0 )
    {
        pLink = m_links.back();
    }

    return pLink;
}

CLinkPtr
CLinkFile::PreviousLink(
    const String&   strPage )
{
    CLinkPtr pLink;
    int nIndex = LinkIndex( strPage );
    if (nIndex > 0)
    {
        pLink = Link( nIndex - 1 );
    }
    else if ( m_links.size() > 0 )
    {
        pLink = m_links.front();
    }
    return pLink;
}

//---------------------------------------------------------------------------
//
//  Refresh will check to see if the cached information is out of date with
//  the ini file.  If so, the cached will be purged
//
//---------------------------------------------------------------------------
bool
CLinkFile::Refresh()
{
    bool rc = false;

    if ( m_pNotify->IsNotified() )
    {
        rc = LoadFile();
    }

    return rc;
}

bool
ValidateURL(String &url)
{
    if (!url.compare(0, 2, "//")
        || !url.compare(0, 2, "\\\\")
        || !url.compare(0, 5, "http:")
        || !url.compare(0, 6, "https:"))

        return false;
    else
        return true;
}

bool
CLinkFile::LoadFile()
{
    USES_CONVERSION;

    bool rc = false;

    CWriter wtr( *this );
    m_links.clear();

    // parse the file for the links
    FileInStream fs;
    HRESULT hr = fs.Init ( m_strFile.c_str() );
    if ( SUCCEEDED (hr) && fs.is_open())
    {
        m_fUTF8 = fs.is_UTF8();

        while ( !fs.eof() )
        {
            String strLine;
            fs.readLine( strLine );
                       
            if ( strLine != _T("") )
            {
                StringInStream ss( strLine );
                String strURL = _T(""), strDesc = _T("");
                ss.read( IsTab(), strURL );
                ss.read( IsTab(), strDesc );
                // anything following description is just a comment which is discarded

                if (ValidateURL(strURL)) {
                    CLinkPtr pLink = new CLink( strURL, strDesc );
                    m_links.push_back( pLink );
                }
            }
        }
        if (m_links.size()) 
        {
            rc = true;
        }
        else
        {
            rc = false;
            CNextLink::RaiseException( IDS_ERROR_INVALID_LINKFILE );
        }
    }
    else
    {
        CNextLink::RaiseException( IDS_ERROR_CANNOT_OPEN_FILE );
    }
    m_bIsOkay = rc;
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\link.h ===
// Link.h: interface for the CLink class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"

class CLink : public CRefCounter  
{
public:
	enum {
		urlType_Absolute,
		urlType_LocalAbsolute,
		urlType_Relative
	};

	CLink( const String& strLink, const String& strDesc );
	int				UrlType() const { return m_urlType; }
	const String&	Link() const { return m_strLink; }
	const String&	Desc() const { return m_strDesc; }
	bool			IsEqual( const String& strLink ) const;

	static int UrlType( const String& strUrl );

private:
	virtual ~CLink();

	int				m_urlType;
	const String	m_strLink;
	const String	m_strDesc;
};

typedef TRefPtr<CLink> CLinkPtr;

#endif // !defined(AFX_LINK_H__253413CF_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\outstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\OutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\linkfile.h ===
// LinkFile.h: interface for the CLinkFile class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "RefCount.h"
#include "RefPtr.h"
#include "Link.h"
#include "Monitor.h"
#include "RdWrt.h"

class CLinkNotify : public CMonitorNotify
{
public:
                    CLinkNotify();
    virtual void    Notify();
            bool    IsNotified();
private:
    long            m_isNotified;
};

DECLARE_REFPTR( CLinkNotify,CMonitorNotify )

class CLinkFile : public CRefCounter, public CReadWrite
{
public:
	CLinkFile( const String& strFile );

	int			LinkIndex( const String& strPage );
	CLinkPtr	Link( int nIndex );
	CLinkPtr	NextLink( const String& strPage );
	CLinkPtr	PreviousLink( const String& strPage );
	int			NumLinks(){ return m_links.size(); }
    bool        Refresh();
	bool		IsOkay() const { return m_bIsOkay; }
    bool        fUTF8() const { return m_fUTF8; }

private:
    bool        LoadFile();
	virtual     ~CLinkFile();

	TVector< CLinkPtr >		m_links;
    String                  m_strFile;
    CLinkNotifyPtr          m_pNotify;
	bool					m_bIsOkay;
    bool                    m_fUTF8;
};

typedef TRefPtr< CLinkFile > CLinkFilePtr;

#endif // !defined(AFX_LINKFILE_H__253413CE_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\monitor.cpp ===
#include "stdafx.h"
#include "..\shared\src\Monitor.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nextlink.h ===
// NextLink.h : Declaration of the CNextLink

#ifndef __NEXTLINK_H_
#define __NEXTLINK_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "LinkFile.h"
#include "lock.h"
#include "context.h"

/////////////////////////////////////////////////////////////////////////////
// CNextLink
class ATL_NO_VTABLE CNextLink : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CNextLink, &CLSID_NextLink>,
	public ISupportErrorInfo,
	public IDispatchImpl<INextLink, &IID_INextLink, &LIBID_NextLink>
{
public:
	CNextLink()
	{ 
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_NEXTLINK)
DECLARE_GET_CONTROLLING_UNKNOWN()

BEGIN_COM_MAP(CNextLink)
	COM_INTERFACE_ENTRY(INextLink)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p );
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// INextLink
public:
	STDMETHOD(get_About)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetListIndex)(BSTR bstrLinkFile, /*[out, retval]*/ int *pVal);
	STDMETHOD(get_GetListCount)(BSTR bstrLinkFile, /*[out, retval]*/ int *pVal);
	STDMETHOD(get_GetNthDescription)(BSTR bstrLinkFile, int nIndex, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNthURL)(BSTR bstrLinkFile, int nIndex, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPreviousDescription)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetPreviousURL)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNextDescription)(BSTR bstrLinkFile, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_GetNextURL)(BSTR, /*[out, retval]*/ BSTR *pVal);

	static	void	ClearLinkFiles();
	static	void	RaiseException( LPOLESTR );
	static	void	RaiseException( UINT );

private:
    CLinkFilePtr            LinkFile( UINT, BSTR );
	CLinkFilePtr            LinkFile( CContext&, UINT, BSTR );
    bool                    GetPage( CContext&, String& );
    bool                    GetFileAndPage( UINT, BSTR, CLinkFilePtr&, String& );

	typedef TSafeStringMap<CLinkFilePtr>	LinkFileMapT;

	CComPtr<IUnknown>		m_pUnkMarshaler;
	static LinkFileMapT		s_linkFileMap;

};

#endif //__NEXTLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\link.cpp ===
// Link.cpp: implementation of the CLink class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NxtLnk.h"
#include "Link.h"
#include "NextLink.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CLink::CLink(
	const String&	strLink,
	const String&	strDesc )
	:	m_strLink( strLink, false ),    // set case sensitive to false
		m_strDesc( strDesc, false )     // set case sensitive to false
{
	m_urlType = UrlType( m_strLink );
}

CLink::~CLink()
{
}

bool
CLink::IsEqual(
	const String&	strLink ) const
{
	bool rc = false;

	switch ( m_urlType )
	{
		case urlType_LocalAbsolute:
		{
			rc = ( strLink == m_strLink );
		} break;

		case urlType_Relative:
		{
			String strRel(strLink,false); // set case sensitive to false
			String::size_type p = strLink.find_last_of( _T('/') );
			if ( p != String::npos )
			{
				strRel = strLink.substr( p + 1, strLink.length() );
			}
			else
			{
				p = strLink.find_last_of( _T('\\') );
				if ( p != String::npos )
				{
					strRel = strLink.substr( p + 1, strLink.length() );
				}
			}
			if ( strRel == m_strLink )
			{
				rc = true;
			}
		} break;

		case urlType_Absolute:
		{
			CNextLink::RaiseException( IDS_ERROR_CANT_MATCH_ABSOLUTE_URLS );
		} break;

		default:
		{
		} break;
	}
	return rc;
}

int
CLink::UrlType(
	const String&	strUrl )
{
	int urlType;

	const String slashSlash = _T("//");
	const String bslashBslash = _T("\\\\");

	if ( ( strUrl.compare( 0, 2, slashSlash ) == 0 ) ||
		( strUrl.compare( 0, 2, bslashBslash ) == 0 ) )
	{
		urlType = urlType_Absolute;
	}
	else if ( ( strUrl[0] == _T('\\') ) || ( strUrl[0] == _T('/') ) )
	{
		urlType = urlType_LocalAbsolute;
	}
	else
	{
		if ( strUrl.find( _T(':') ) != String::npos )
		{
			urlType = urlType_Absolute;
		}
		else
		{
			urlType = urlType_Relative;
		}
	}

	return urlType;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\rdwrt.cpp ===
#include "stdafx.h"
#include "..\shared\src\RdWrt.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\sinstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SInStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\soutstrm.cpp ===
#include "stdafx.h"
#include "..\shared\src\SOutStrm.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nxtlnk.cpp ===
// NxtLnk.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f NxtLnkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "NxtLnk.h"

#include "NxtLnk_i.c"
#include <initguid.h>
#include "NextLink.h"
#include "Monitor.h"

CNextLinkModule _Module;
CMonitor*   g_pMonitor = NULL;
extern HINSTANCE g_hModuleInstance;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_NextLink, CNextLink)
END_OBJECT_MAP()

LONG
CNextLinkModule::Lock()
{
    _ASSERT( g_pMonitor != NULL );
    return CComModule::Lock();
}

LONG
CNextLinkModule::Unlock()
{
	LONG lc;
	CLock l(m_cs);
	if ( ( lc = CComModule::Unlock() ) == 0 )
	{
		// final unlock
		_ASSERT( g_pMonitor != NULL );
        g_pMonitor->StopAllMonitoring();
        CNextLink::ClearLinkFiles();
	}
	return lc;
}

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		DEBUG_START;
		g_hModuleInstance = hInstance;
		
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);

        _ASSERT( g_pMonitor == NULL );
		try
		{
            g_pMonitor = new CMonitor();
		}
		catch ( std::bad_alloc& )
		{
			// nothing we can do about it here
		}
	}
	else if (dwReason == DLL_PROCESS_DETACH)
    {
        _ASSERT( g_pMonitor != NULL );
        delete g_pMonitor;
        g_pMonitor = NULL;

		_Module.Term();
		DEBUG_STOP;
    }
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\nextlink.cpp ===
// NextLink.cpp : Implementation of CNextLink
#include "stdafx.h"
#include "NxtLnk.h"
#include "NextLink.h"

#define MAX_RESSTRINGSIZE 512

CNextLink::LinkFileMapT CNextLink::s_linkFileMap;

/////////////////////////////////////////////////////////////////////////////
// CNextLink

STDMETHODIMP CNextLink::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_INextLink,
    };
    for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CNextLink::get_GetNextURL(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->NextLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Link().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL(*pVal);
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetNextDescription(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->NextLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Desc().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL(*pVal);
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetPreviousURL(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->PreviousLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Link().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL( *pVal );
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetPreviousDescription(BSTR bstrLinkFile, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                CLinkPtr pLink = pLinkFile->PreviousLink( strPage );
                if ( pLink.IsValid() )
                {
                    if ( pVal )
                    {
                        if ( *pVal )
                        {
                            ::SysFreeString( *pVal );
                        }
                        HRESULT hr;
                        CMBCSToWChar    convStr;
                        if (hr = convStr.Init(pLink->Desc().c_str(), 
                                              pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                            throw _com_error(hr);
                        }
                        *pVal = ::SysAllocString(convStr.GetString());
                        THROW_IF_NULL( *pVal );
                        rc = S_OK;
                    }
                    else
                    {
                        rc = E_POINTER;
                    }
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_GetNthURL(BSTR bstrLinkFile, int nIndex, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHURL, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);

            if ( (nIndex <= 0) || (nIndex > pLinkFile->NumLinks()) ) {
                RaiseException( IDS_ERROR_INVALID_NTH_INDEX );
                goto err;
            }   
            CLinkPtr pLink = pLinkFile->Link( nIndex );
            if ( pLink.IsValid() )
            {
                if ( pVal )
                {
                    if (*pVal)
                    {
                        ::SysFreeString(*pVal);
                    }
                    HRESULT hr;
                    CMBCSToWChar    convStr;
                    if (hr = convStr.Init(pLink->Link().c_str(), 
                                          pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                        throw _com_error(hr);
                    }
                    *pVal = ::SysAllocString(convStr.GetString());
                    THROW_IF_NULL(*pVal);
                    rc = S_OK;
                }
                else
                {
                    rc = E_POINTER;
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
err:
    return rc;
}

STDMETHODIMP CNextLink::get_GetNthDescription(BSTR bstrLinkFile, int nIndex, BSTR * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);
            if ( (nIndex <= 0) || (nIndex > pLinkFile->NumLinks()) ) {
                RaiseException( IDS_ERROR_INVALID_NTH_INDEX );
                goto err;
            }   
            CLinkPtr pLink = pLinkFile->Link( nIndex );
            if ( pLink.IsValid() )
            {
                if ( pVal )
                {
                    if ( *pVal )
                    {
                        ::SysFreeString( *pVal );
                    }
                    HRESULT hr;
                    CMBCSToWChar    convStr;
                    if (hr = convStr.Init(pLink->Desc().c_str(), 
                                          pLinkFile->fUTF8() ? 65001 : CP_ACP)) {
                        throw _com_error(hr);
                    }
                    *pVal = ::SysAllocString(convStr.GetString());
                    THROW_IF_NULL( *pVal );
                    rc = S_OK;
                }
                else
                {
                    rc = E_POINTER;
                }
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
err:
    return rc;
}

STDMETHODIMP CNextLink::get_GetListCount(BSTR bstrLinkFile, int * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr pLinkFile = LinkFile( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT, bstrLinkFile );
        if ( pLinkFile.IsValid() )
        {
            CReader rdr(*pLinkFile);
            *pVal = pLinkFile->NumLinks();
            rc = S_OK;
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}


STDMETHODIMP CNextLink::get_GetListIndex(BSTR bstrLinkFile, int * pVal)
{
    SCODE rc = E_FAIL;

    try
    {
        CLinkFilePtr    pLinkFile;
        String         strPage;
        if ( GetFileAndPage( IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX, bstrLinkFile, pLinkFile, strPage ) )
        {
            if ( pLinkFile.IsValid() )
            {
                CReader rdr(*pLinkFile);
                *pVal = pLinkFile->LinkIndex( strPage );
                rc = S_OK;
            }
        }
    }
    catch ( _com_error& ce )
    {
        rc = ce.Error();
    }
    catch ( ... )
    {
        rc = E_FAIL;
    }
    return rc;
}

STDMETHODIMP CNextLink::get_About(BSTR * pVal)
{
    USES_CONVERSION;

#ifdef _DEBUG
    LPCTSTR szVersion = _T("Debug");
#else
    LPCTSTR szVersion = _T("Release");
#endif
    const int kAboutSize = 1024;
    _TCHAR  szAboutFmt[kAboutSize];
    _TCHAR  szBuffer[ kAboutSize + sizeof(__DATE__) + sizeof(__TIME__) + sizeof(szVersion) ];
    
    ::LoadString( _Module.GetResourceInstance(), IDS_ABOUT_FMT, szAboutFmt, kAboutSize );
    _stprintf(szBuffer, szAboutFmt, szVersion, __DATE__, __TIME__);

    if ( pVal )
    {
        if ( *pVal )
        {
            ::SysFreeString( *pVal );
        }
        *pVal = T2BSTR( szBuffer );
        if ( *pVal == NULL )
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        return E_POINTER;
    }

    return S_OK;
}

bool
CNextLink::GetPage(
    CContext&   cxt,
    String&     strPage )
{
    USES_CONVERSION;

    bool rc = false;
    if ( cxt.Request() != NULL )
    {
        CComPtr<IDispatch> piPathInfo;
        HRESULT hr = cxt.Request()->get_Item( L"PATH_INFO", &piPathInfo );
        if ( !FAILED(hr) )
        {
            CComVariant vt = piPathInfo;
            hr = vt.ChangeType( VT_BSTR );
            if ( !FAILED( hr ) )
            {
                strPage = OLE2T(vt.bstrVal);
                rc = true;
            }
        }
    }
    return rc;
}

CLinkFilePtr
CNextLink::LinkFile(
    CContext&           cxt,
    UINT                errorID,
    BSTR                bstrFile )
{
    USES_CONVERSION;
    
    CLinkFilePtr pLinkFile;

    if ( cxt.Server() != NULL )
    {
        CComBSTR bstrPath;
        HRESULT hr = cxt.Server()->MapPath( bstrFile, &bstrPath );
        if ( !FAILED( hr ) )
        {
            String strFile = OLE2T(bstrPath);
            CLock l( s_linkFileMap );
            CLinkFilePtr& rpLinkFile = s_linkFileMap[strFile];
            if ( !rpLinkFile.IsValid() )
            {
                rpLinkFile = new CLinkFile( strFile );
            }
            else
            {
                // make sure the file is up to date
                rpLinkFile->Refresh();
            }
            if ( rpLinkFile->IsOkay() )
            {
            }
            else
            {
                rpLinkFile = NULL;
            }
            pLinkFile = rpLinkFile;
        }
        else
        {
            RaiseException( errorID );
        }
    }
    return pLinkFile;
}

CLinkFilePtr
CNextLink::LinkFile(
    UINT    errorID,
    BSTR    bstrFile )
{
    CLinkFilePtr pLinkFile;

    CContext cxt;
    HRESULT hr = cxt.Init( CContext::get_Server );
    if ( !FAILED(hr) )
    {
        pLinkFile = LinkFile( cxt, errorID, bstrFile );
    }
    else
    {
        RaiseException( IDS_ERROR_NOSVR );
    }

    return pLinkFile;
}

bool
CNextLink::GetFileAndPage(
    UINT            errorID,
    BSTR            bstrFile,
    CLinkFilePtr&   pLinkFile,
    String&         strPage )
{
    bool rc = false;

    CContext cxt;
    HRESULT hr = cxt.Init( CContext::get_Server | CContext::get_Request );
    if ( !FAILED( hr ) )
    {
        pLinkFile = LinkFile( cxt, errorID, bstrFile );

        if ( pLinkFile.IsValid() )
        {
            rc = GetPage( cxt, strPage );
        }
    }
    else
    {
        RaiseException( IDS_ERROR_NOSVR );
    }

    return rc;
}

void
CNextLink::ClearLinkFiles()
{
    CLock l(s_linkFileMap);
    s_linkFileMap.clear();
}

//---------------------------------------------------------------------------
//  RaiseException
//
//  Raises an exception using the given source and description
//---------------------------------------------------------------------------
void
CNextLink::RaiseException (
    LPOLESTR strDescr
)
{
    HRESULT hr;
    ICreateErrorInfo *pICreateErr;
    IErrorInfo *pIErr;
    LANGID langID = LANG_NEUTRAL;

    /*
     * Thread-safe exception handling means that we call
     * CreateErrorInfo which gives us an ICreateErrorInfo pointer
     * that we then use to set the error information (basically
     * to set the fields of an EXCEPINFO structure. We then
     * call SetErrorInfo to attach this error to the current
     * thread.  ITypeInfo::Invoke will look for this when it
     * returns from whatever function was invokes by calling
     * GetErrorInfo.
     */

    _TCHAR tstrSource[MAX_RESSTRINGSIZE];
    if ( ::LoadString(
        _Module.GetResourceInstance(),
        IDS_ERROR_SOURCE,
        tstrSource,
        MAX_RESSTRINGSIZE ) > 0 )
    {
        USES_CONVERSION;
        LPOLESTR strSource = T2OLE(tstrSource);
        //Not much we can do if this fails.
        if (!FAILED(CreateErrorInfo(&pICreateErr)))
        {
            pICreateErr->SetGUID(CLSID_NextLink);
            pICreateErr->SetHelpFile(L"");
            pICreateErr->SetHelpContext(0L);
            pICreateErr->SetSource(strSource);
            pICreateErr->SetDescription(strDescr);

            hr = pICreateErr->QueryInterface(IID_IErrorInfo, (void**)&pIErr);

            if (SUCCEEDED(hr))
            {
                if(SUCCEEDED(SetErrorInfo(0L, pIErr)))
                {
                    pIErr->Release();
                }
            }
            pICreateErr->Release();
        }
    }
}

void 
CNextLink::RaiseException(
    UINT DescrID
)
{
    _TCHAR tstrDescr[MAX_RESSTRINGSIZE];

    if ( ::LoadString(
        _Module.GetResourceInstance(),
        DescrID,
        tstrDescr,
        MAX_RESSTRINGSIZE) > 0 )
    {
        USES_CONVERSION;
        LPOLESTR strDescr = T2OLE(tstrDescr);
        RaiseException( strDescr );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\lock.h ===
// lock.h : locking classes for BrowserCap

#pragma once

#ifndef _LOCK_H_
#define _LOCK_H_

// a lockable map template
template< class T >
class TSafeStringMap : public TStringMap<T>, public CComAutoCriticalSection
{
};

template< class T >
class TSafeVector : public TVector<T>, public CComAutoCriticalSection
{
};

// a stack-based auto-lock template
template< class T >
class TLock
{
public:

	TLock( T& t )
		:	m_t( t )
	{
		m_t.Lock();
	}
	~TLock()
	{
		m_t.Unlock();
	}
private:
	T&	m_t;
};

typedef TLock<CComAutoCriticalSection>	CLock;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by nxtlnk.rc
//
#define DLL_VER                         0
#define IDS_PROJNAME                    100
#define IDR_NEXTLINK                    101
#define IDS_ABOUT_FMT                   101
#define IDS_ERROR_SOURCE                102
#define IDS_ERROR_NOSVR                 103
#define IDS_ERROR_CANT_MATCH_ABSOLUTE_URLS 104
#define IDS_ERROR_CANNOT_OPEN_FILE      105
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTCOUNT 106
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETLISTINDEX 107
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTDESCRIPTION 108
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNEXTURL 109
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHDESCRIPTION 110
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETNTHURL 111
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSDDESCRIPTION 112
#define IDS_ERROR_CANNOT_XLATE_VIRT_ROOT_GETPREVIOUSURL 113
#define IDS_ERROR_INVALID_LINKFILE      114
#define IDS_ERROR_INVALID_NTH_INDEX     115

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\nextlink\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED_)
#define AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


//#define _ATL_APARTMENT_THREADED


#pragma warning( disable : 4786 )
#include <atlbase.h>
#include <mtx.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CNextLinkModule : public CComModule
{
public:
	LONG	Lock();
	LONG	Unlock();

private:
	CComAutoCriticalSection	m_cs;
};

extern CNextLinkModule _Module;
#include <atlcom.h>
#include <comdef.h>
#include <algorithm>

using namespace std;

#include "myvector.h"
#include "strmap.h"
#include "MyDebug.h"
#include "MyString.h"
#include "FInStrm.h"
#include "SInStrm.h"
#include "SOutStrm.h"

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__253413C2_E71F_11D0_8A84_00C0F00910F9__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\instrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       InStrm.h

   Abstract:
		A lightweight implementation of input streams.  This class provides
		the interface, as well as a basic skeleton for input streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "MyString.h"

struct CharCheck
{
	virtual	bool	operator()( _TCHAR )=0;
};

struct IsWhiteSpace : public CharCheck
{
	virtual	bool	operator()( _TCHAR );
};

struct IsNewLine : public CharCheck
{
	virtual	bool	operator()( _TCHAR );
};

class InStream
{
public:
	enum{
		EndOfFile = E_FAIL
	};

						InStream();
							
			bool		eof() const { return m_bEof; }
			HRESULT		lastError() const { return m_lastError; }
	virtual	HRESULT		skip( CharCheck& )=0;
	virtual HRESULT		back( size_t )=0;
	virtual HRESULT		read( CharCheck&, String& )=0;
	virtual	HRESULT		readChar( _TCHAR& )=0;
	virtual	HRESULT		readInt16( SHORT& );
	virtual	HRESULT		readInt( int& );
	virtual	HRESULT		readInt32( LONG& );
	virtual	HRESULT		readUInt32( ULONG& );
	virtual	HRESULT		readFloat( float& );
	virtual	HRESULT		readDouble( double& );
	virtual	HRESULT		readString( String& );
	virtual	HRESULT		readLine( String& );
	virtual	HRESULT		skipWhiteSpace();
			
			InStream&	operator>>( _TCHAR& );
			InStream&	operator>>( SHORT& );
			InStream&	operator>>( int& );
			InStream&	operator>>( LONG& );
			InStream&	operator>>( ULONG& );
			InStream&	operator>>( float& );
			InStream&	operator>>( double& );
			InStream&	operator>>( String& );
	
protected:
			void		setLastError( HRESULT );
private:
	bool	m_bEof;
	HRESULT	m_lastError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\context.h ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module  Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics

	Author:

		Neil Allain	  ( a-neilal )	   August-1997 

	Revision History:

--*/
#pragma once
#ifndef _CONTEXT_H_
#define _CONTEXT_H_

class CContext
{
public:
	enum {
		get_Server		= 0x0001,
		get_Response	= 0x0002,
		get_Request		= 0x0004,
		get_Session		= 0x0008,
		get_Application	= 0x0010
	};
	
	HRESULT	            Init( DWORD );

	IRequest*			Request(){ _ASSERT(m_piRequest!=NULL); return m_piRequest; }
	IResponse*			Response(){ _ASSERT(m_piResponse!=NULL); return m_piResponse; }
	ISessionObject*		Session(){ _ASSERT(m_piSession!=NULL); return m_piSession; }
	IServer*			Server(){ _ASSERT(m_piServer!=NULL); return m_piServer; }
	IApplicationObject*	Application(){ _ASSERT(m_piApplication!=NULL); return m_piApplication; }

	static HRESULT		GetServerObject( IGetContextProperties*, BSTR, const IID&, void** );

private:
	CComPtr<IRequest>			m_piRequest;			//Request Object
	CComPtr<IResponse>			m_piResponse;			//Response Object
	CComPtr<ISessionObject>		m_piSession;			//Session Object
	CComPtr<IServer>			m_piServer;				//Server Object
	CComPtr<IApplicationObject> m_piApplication;		//Application Object
};


#endif	// !_CONTEXT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\finstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       FInStrm.h

   Abstract:
		A lightweight implementation of input streams using files

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#include "InStrm.h"
#include "except.h"
#include "eh.h"

class FileInStream : public InStream
{
public:
						FileInStream();
			HRESULT			Init( LPCTSTR );
						~FileInStream();
			HRESULT	    CreateFileMapping ();
			void		UnMapFile();
	virtual	HRESULT		readChar( _TCHAR& );
	virtual	HRESULT		read( CharCheck&, String& );
	virtual	HRESULT		skip( CharCheck& );
	virtual HRESULT		back( size_t );
			bool		is_open() const { return m_bIsOpen; }
			HANDLE		handle() const { return m_hFile; }
            bool        is_UTF8() const { return m_bIsUTF8; }
			bool        ReadMappedFile(LPVOID buff, DWORD countOfBytes, LPDWORD BytesRead);
          	void         SetCurrFilePointer(LONG DistToMove, PLONG DistToMoveH, DWORD refPoint);
private:
	HANDLE	m_hFile;
	HANDLE  m_hMap;
	bool	m_bIsOpen;
    bool    m_bIsUTF8;
    bool	m_fInited;
    BYTE*  m_pbStartOfFile;
    LONG 	m_cbCurrOffset;
    LONG	m_cbFileSize;
};

class IPIOException 
{
	private : 
		unsigned int nSE;
	public  :
		IPIOException () : nSE(0) {}
		IPIOException (unsigned int n) : nSE(n) {}
		~IPIOException () {}
		unsigned int getSeNumber () {return nSE;}
		
};

void __cdecl poi_Capture(unsigned int u, _EXCEPTION_POINTERS* pExp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\mydebug.h ===
#pragma once
#ifndef _MYDEBUG_H_
#define _MYDEBUG_H_
#include <malloc.h>

class _com_error;

#define THROW_IF_NULL(x) if ( x ) {} else throw _com_error(E_OUTOFMEMORY)

#ifdef DBG

#include <crtdbg.h>

#define THIS_FILE __FILE__
#define DEBUG_NEW	new(THIS_FILE, __LINE__)
#define DEBUG_START		DebugStart()
#define DEBUG_STOP		DebugStop()

void* __cdecl operator new( size_t s, const char* file, long line ) _THROW1(_com_error);

#if _MSC_VER >= 1200
void __cdecl operator delete(void *p, const char* file, long line) _THROW0();
#endif

void	DebugStart();
void	DebugStop();

#else	// !DBG

#define DEBUG_NEW	new
#define	DEBUG_START
#define	DEBUG_STOP

#endif	// #ifdef DBG


#endif	// #ifndef _MYDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\monitor.h ===
#pragma once

#ifndef _MONITOR_H_
#define _MONITOR_H_

#include "RefCount.h"
#include "RefPtr.h"
#include "MyString.h"


#undef STRING_TRACE_LOG

#ifdef STRING_TRACE_LOG
# include <strlog.hxx>
# define STL_PRINTF      m_stl.Printf
# define STL_PUTS(s)     m_stl.Puts(s)
#else
# define STL_PRINTF
# define STL_PUTS(s)
#endif

// a client supplies it's own derviation of CMonitorNotify to the monitor.
// the notify method is called when the monitored object has changed
class CMonitorNotify : public CRefCounter
{
public:
    virtual void    Notify() = 0;
};

typedef TRefPtr<CMonitorNotify> CMonitorNotifyPtr;

// the base object of anything that can be monitored
class CMonitorNode : public CRefCounter
{
public:
    virtual void    Notify() = 0;
    virtual HANDLE  NotificationHandle() const = 0;
};

typedef TRefPtr<CMonitorNode> CMonitorNodePtr;

// since we can only monitor directories, the file class,
// preserves information about each file in a particular
// directory
class CMonitorFile : public CRefCounter
{
public:
                            CMonitorFile( const String&, const CMonitorNotifyPtr& );
            bool            CheckNotify();
            const String&  FileName() const;

private:
    virtual                 ~CMonitorFile();
            bool            GetFileTime( FILETIME& );


    FILETIME            m_ft;
    const String       m_strFile;
    CMonitorNotifyPtr   m_pNotify;
};

typedef TRefPtr<CMonitorFile> CMonitorFilePtr;

// an implementaiton of CMonitorNode's interface for montioring directories
class CMonitorDir : public CMonitorNode
{
public:
                            CMonitorDir( const String& );

        // CMonitorNode interface
    virtual void            Notify();
    virtual HANDLE          NotificationHandle() const;

            void            AddFile( const String&, const CMonitorNotifyPtr& );
            void            RemoveFile( const String& );
            const String&  Dir() const;
            ULONG           NumFiles() const;
private:
    virtual                 ~CMonitorDir();

    const String				m_strDir;
    TVector<CMonitorFilePtr>	m_files;
    HANDLE						m_hNotification;

};

DECLARE_REFPTR(CMonitorDir,CMonitorNode);


// an implementation of CMonitorNode's interface for monitoring a registry key
class CMonitorRegKey : public CMonitorNode
{
public:
                            CMonitorRegKey( HKEY, const String&, const CMonitorNotifyPtr& );

        // CMonitorNode interface
    virtual void            Notify();
    virtual HANDLE          NotificationHandle() const;

        // CMonitorRegKey interface
    const String&          m_strKey;
    const HKEY              m_hBaseKey;

private:
    virtual                 ~CMonitorRegKey();

    HKEY                    m_hKey;
    HANDLE                  m_hEvt;
    CMonitorNotifyPtr       m_pNotify;
};

DECLARE_REFPTR(CMonitorRegKey, CMonitorNode);

// the main monitoring object
class CMonitor
{
public:
                        CMonitor();
                        ~CMonitor();
            void        MonitorFile( LPCTSTR, const CMonitorNotifyPtr& );
            void        StopMonitoringFile( LPCTSTR );
            void        MonitorRegKey( HKEY, LPCTSTR, const CMonitorNotifyPtr& );
            void        StopMonitoringRegKey( HKEY, LPCTSTR );
            void        StopAllMonitoring();

private:
    static  unsigned __stdcall ThreadFunc( void* );
            bool        StartUp();
            DWORD       DoMonitoring();

    TVector<CMonitorDirPtr>		m_dirs;
    TVector<CMonitorRegKeyPtr>	m_regKeys;

    CComAutoCriticalSection     m_cs;
    HANDLE                      m_hevtBreak;
    HANDLE                      m_hevtShutdown;
    HANDLE                      m_hThread;
    volatile bool               m_bRunning;
    volatile bool               m_bStopping;

#ifdef STRING_TRACE_LOG
public:
    CStringTraceLog             m_stl;
#endif
};

#endif // ! _MONITOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\refcount.h ===
#ifndef _REFCOUNTER_H_
#define _REFCOUNTER_H_

//----------------------------------------------------------------------------
//
//	CRefCounter
//
//	This class is supplementary to the TRefPtr template.  It provides an
//	easy way to mix in reference counting properties with other classes
//
//	Note that the destructor is protected.  It must be protected so derivatives
//	can use it, but derivatives should not have a public destructor (since
//	this violates the reference counting pattern)
//
//---------------------------------------------------------------------------
class CRefCounter
{
public:
	CRefCounter();

	void AddRef();
	void Release();

protected:
	virtual ~CRefCounter();

private:
	long m_lRefCount;
};

inline
CRefCounter::CRefCounter()
	:	m_lRefCount(0)
{}

inline
CRefCounter::~CRefCounter()
{
	_ASSERT( m_lRefCount == 0 );
}

inline void
CRefCounter::AddRef()
{
	::InterlockedIncrement( &m_lRefCount );
}

inline void
CRefCounter::Release()
{
	if ( ::InterlockedDecrement( &m_lRefCount ) == 0 )
	{
		delete this;
	}
}
#endif	// !_REFCOUNTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\outstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       OutStrm.h

   Abstract:
		A lightweight interface of output streams.  This class provides
		the interface, as well as a basic skeleton for output streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "MyString.h"

struct OutToken
{
	LONG	val;
};

struct EndLineToken : public OutToken
{
};

extern EndLineToken	endl;

class OutStream
{
public:
						OutStream();
	virtual				~OutStream();
			HRESULT		lastError() const { return m_lastError; }
	virtual	HRESULT		writeChar( _TCHAR )=0;
	virtual	HRESULT		writeString( LPCTSTR, size_t )=0;
	virtual	HRESULT		writeString( LPCTSTR );
	virtual	HRESULT		writeString( const String& );
	virtual HRESULT		writeLine( LPCTSTR, ... );
	virtual	HRESULT		writeInt16( SHORT );
	virtual HRESULT		writeInt( int );
	virtual	HRESULT		writeInt32( LONG );
	virtual	HRESULT		writeFloat( float );
	virtual	HRESULT		writeDouble( double );
	virtual HRESULT		writeToken( const OutToken& );
	virtual HRESULT		writeEolToken( const EndLineToken& );
	virtual	HRESULT		flush();
	
			OutStream&	operator<<( _TCHAR );
			OutStream&	operator<<( SHORT );
			OutStream&	operator<<( int );
			OutStream&	operator<<( LONG );
			OutStream&	operator<<( float );
			OutStream&	operator<<( double );
			OutStream&	operator<<( const String& );
			OutStream&	operator<<( LPCTSTR );
			OutStream&	operator<<( const OutToken& );
			OutStream&	operator<<( const EndLineToken& );
			
protected:
			void		setLastError( HRESULT );
private:
	HRESULT	m_lastError;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\rdwrt.h ===
// RdWrt.h
#pragma once

#ifndef _READWRITE_H_
#define _READWRITE_H_

// this class handles a single-writer, multi-reader threading model

class CReadWrite
{
public:
            CReadWrite();
            ~CReadWrite();

    void    EnterReader();
    void    ExitReader();
    void    EnterWriter();
    void    ExitWriter();

private:
    HANDLE              m_hevtNoReaders;
    HANDLE              m_hmtxWriter;
    HANDLE              m_handles[2];
    LONG                m_cReaders;
};

class CReader
{
public:
    CReader( CReadWrite& rw )
        :   m_rrw( rw )
    {
        m_rrw.EnterReader();
    }
    ~CReader()
    {
        m_rrw.ExitReader();
    }
private:
    CReadWrite& m_rrw;
};

class CWriter
{
public:
    CWriter( CReadWrite& rw )
        :   m_rrw( rw )
    {
        m_rrw.EnterWriter();
    }
    ~CWriter()
    {
        m_rrw.ExitWriter();
    }
private:
    CReadWrite& m_rrw;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\sinstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SInStrm.h

   Abstract:
		A lightweight implementation of input streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#include "InStrm.h"

class StringInStream : public InStream, public BaseStringBuffer
{
public:
					StringInStream( const String& );
	virtual	HRESULT	readChar( _TCHAR& );
	virtual	HRESULT	read( CharCheck&, String& );
	virtual	HRESULT	skip( CharCheck& );
	virtual	HRESULT	back( size_t );
	
private:
	LPTSTR	m_pos;
	LPTSTR	m_end;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\mystring.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       MyString.h

   Abstract:
		A lightweight string class which supports UNICODE/MCBS.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once
#ifndef _MYSTRING_H_
#define _MYSTRING_H_

//==========================================================================================
//	Dependencies
//==========================================================================================
#include <string.h>
#include "RefPtr.h"
#include "RefCount.h"

//==========================================================================================
//	Classes
//==========================================================================================

class BaseStringBuffer
{
// interface
public:
	typedef size_t size_type;
	enum {
		npos = -1
	};

	BaseStringBuffer( LPCTSTR	inString );
	BaseStringBuffer( LPCTSTR s1, LPCTSTR s2 );
	BaseStringBuffer( size_t	bufferSize );
	~BaseStringBuffer();
	
	LPTSTR		c_str()
		{ _ASSERT( m_pString ); return m_pString; }
	LPCTSTR		c_str() const
		{ _ASSERT( m_pString ); return m_pString; }
	size_t		length() const
		{ return m_length; }
	size_t		bufferSize() const
		{ return m_bufferSize; }
	HRESULT		copy( LPCTSTR );
	HRESULT		concatenate( LPCTSTR );
	HRESULT		concatenate( _TCHAR );

	size_type	find_last_of(_TCHAR c) const;
	size_type	find_first_of(_TCHAR c) const;
	LPTSTR		substr( size_type b, size_type e ) const;

// implementation
protected:
	
	HRESULT	growBuffer( size_t inMinSize );
	size_t	m_bufferSize;
	size_t	m_length;
	LPTSTR	m_pString;
};

class StringBuffer : public BaseStringBuffer, public CRefCounter
{
public:
	StringBuffer( LPCTSTR inString ) : BaseStringBuffer( inString ){};
	StringBuffer( size_t bufferSize ) : BaseStringBuffer( bufferSize ){};
	StringBuffer( LPCTSTR s1, LPCTSTR s2 ) : BaseStringBuffer( s1, s2 ){};
	~StringBuffer(){};
};

class String : public TRefPtr< StringBuffer >
{
public:

	typedef BaseStringBuffer::size_type size_type;
	enum {
		npos = BaseStringBuffer::npos
	};

							String(bool fCaseSensitive = true);
							String( const String&, bool fCaseSensitive = true );
							String( LPCTSTR, bool fCaseSensitive = true );
							String( StringBuffer* pT, bool fCaseSensitive = true )
                            {   m_fCaseSensitive = fCaseSensitive;
                                Set( pT ); 
                            }
				String&		operator=( StringBuffer* );
				String&		operator=( const String& );
				String&		operator=( LPCTSTR );
				String&		operator+=( const String& );
				String&		operator+=( LPCTSTR );
				String		operator+( const String& ) const;
				String		operator+( LPCTSTR ) const;
				String		operator+( _TCHAR ) const;
				bool		operator==( const String& ) const;
				bool		operator==( LPCTSTR ) const;
				bool		operator!=( const String& s ) const { return !( *this == s ); }
				bool		operator!=( LPCTSTR s ) const { return !( *this == s ); }
				bool		operator<( const String& ) const;
				bool		operator<( LPCTSTR ) const;
				int			compare( const String& s) const { return _tcscmp( c_str(), s.c_str() ); }
				int			compare( LPCTSTR s ) const { return _tcscmp( c_str(), s ); }
				int			compare( size_t, size_t, const String& ) const;
				size_t		find( _TCHAR ) const;
				LPCTSTR		c_str() const { return m_pT->c_str(); };
				LPTSTR		c_str(){ return m_pT->c_str(); }
				size_t		length() const { return m_pT->length(); }
				size_t		size() const { return length(); }
				size_t		bufferSize() const { return m_pT->bufferSize(); }
				_TCHAR		operator[](size_t s) const { return c_str()[s]; }
				_TCHAR		charAt( size_t s ) const { return c_str()[ s ]; }
				SHORT		toInt16() const { return (SHORT)_ttoi(c_str()); }
				LONG		toInt32() const { return _ttol(c_str()); }
				ULONG		toUInt32() const { return (ULONG)_ttol(c_str()); }
				float		toFloat() const { USES_CONVERSION; return (float)atof(T2CA(c_str())); }
				double		toDouble() const { USES_CONVERSION; return atof(T2CA(c_str())); }
				
				size_type	find_last_of(_TCHAR c) const
				{
					return m_pT->find_last_of(c);
				}
				size_type	find_first_of(_TCHAR c) const
				{
					return m_pT->find_first_of(c);
				}
				String		substr( size_type b, size_type e ) const
				{
					LPTSTR pStr = m_pT->substr(b,e);
					String s( pStr );
					delete[] pStr;
					return s;
				}

	static		String		fromInt16( SHORT );
	static		String		fromInt32( LONG );
	static		String		fromFloat( float );
	static		String		fromDouble( double );
			
private:
			StringBuffer&	operator*(){ return *m_pT; }
			StringBuffer*	operator->(){ return m_pT; }
    bool    m_fCaseSensitive;
};

String operator+( LPCTSTR lhs, const String& rhs );

/*
 * A simple class to convert Multibyte to Widechar.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CMBCSToWChar
{
private:

    LPWSTR   m_pszResult;
    WCHAR    m_resMemory[1024];
    INT      m_cchResult;

public:

    CMBCSToWChar() { m_pszResult = m_resMemory; m_cchResult = 0; }
    ~CMBCSToWChar();
    
    // Init(): converts the MBCS string at pSrc to a Wide string in memory 
    // managed by CMBCSToWChar

    HRESULT Init(LPCSTR  pSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPWSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cchResult ? m_cchResult - 1 : 0); }
};

/*
 * A simple class to convert WideChar to Multibyte.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CWCharToMBCS
{
private:

    LPSTR    m_pszResult;
    char     m_resMemory[1024];
    INT      m_cbResult;

public:

    CWCharToMBCS() { m_pszResult = m_resMemory; m_cbResult = 0; }
    ~CWCharToMBCS();
    
    // Init(): converts the widechar string at pWSrc to an MBCS string in memory 
    // managed by CWCharToMBCS

    HRESULT Init(LPCWSTR  pWSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cbResult ? m_cbResult - 1 : 0); }
};

#endif // !_MYSTRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\myvector.h ===
#pragma once
#ifndef _MYVECTOR_H_
#define _MYVECTOR_H_

#include <new>

template< class T >
class TVector
{
public:	
	typedef T&			reference;
	typedef const T&	const_reference;

// iterators
	typedef T*			iterator;
	typedef const T*	const_iterator;
	class const_reverse_iterator;

	class reverse_iterator
	{
	public:
							reverse_iterator() : m_iter(NULL) {}
		explicit			reverse_iterator( iterator iter ) : m_iter( iter ) {}

		reverse_iterator&	operator++() { --m_iter; return *this;}
		reverse_iterator	operator++(int) { return reverse_iterator(m_iter--); }
		reverse_iterator&	operator--() { ++m_iter; return *this;}
		reverse_iterator	operator--(int) { return reverse_iterator(m_iter++); }
		reverse_iterator	operator+(size_t s) const { return reverse_iterator(m_iter - s); }
		reverse_iterator	operator-(size_t s) const { return reverse_iterator(m_iter + s); }
		reverse_iterator&	operator+=(size_t s) { m_iter -= s; return *this; }
		reverse_iterator&	operator-=(size_t s) { m_iter += s; return *this; }
		bool				operator==( iterator iter ) const { return ( m_iter == iter ); }
		bool				operator!=( iterator iter ) const { return ( m_iter != iter ); }
		reference			operator*() const { return *m_iter; }
	private:
		iterator			m_iter;
		friend				const_reverse_iterator;
	};					

	class const_reverse_iterator
	{
	public:
								const_reverse_iterator() : m_iter(NULL) {}
								const_reverse_iterator( const reverse_iterator& riter ) : m_iter( riter.m_iter ) {}
		explicit				const_reverse_iterator( const_iterator iter ) : m_iter( iter ) {}

		const_reverse_iterator&	operator++() { --m_iter; return *this;}
		const_reverse_iterator	operator++(int) { return const_reverse_iterator(m_iter--); }
		const_reverse_iterator&	operator--() { ++m_iter; return *this;}
		const_reverse_iterator	operator--(int) { return const_reverse_iterator(m_iter++); }
		const_reverse_iterator	operator+(size_t s) const { return const_reverse_iterator(m_iter - s); }
		const_reverse_iterator	operator-(size_t s) const { return const_reverse_iterator(m_iter + s); }
		const_reverse_iterator&	operator+=(size_t s) { m_iter -= s; return *this; }
		const_reverse_iterator&	operator-=(size_t s) { m_iter += s; return *this; }
		bool					operator==( iterator iter ) const { return ( m_iter == iter ); }
		bool					operator!=( iterator iter ) const { return ( m_iter != iter ); }
		const_reference			operator*() const { return *m_iter; }

	private:
		const_iterator			m_iter;
	};					

// constructor / destructor
	TVector();
	~TVector();

// iteration
	iterator				begin(){ return m_pFirst; }
	const_iterator			begin() const { return m_pFirst; }
	iterator				end() { return m_pAfterLast; }
	const_iterator			end() const { return m_pAfterLast; }
	reverse_iterator		rbegin() { return reverse_iterator(m_pAfterLast-1); }
	const_reverse_iterator	rbegin() const { return const_reverse_iterator(m_pAfterLast-1); }
	reverse_iterator		rend() { return reverse_iterator(m_pFirst-1); }
	const_reverse_iterator	rend() const { return const_reverse_iterator(m_pFirst-1); }

// insertion / deletion
	void					push_back( const T& );
	void					pop_back();
	iterator				insert( iterator, const T& );
	void					insert( iterator, size_t, const T& );
	void					insert( iterator, const_iterator, const_iterator );
	iterator				erase( iterator );
	iterator				erase( iterator, iterator );
	void					clear(){ erase( begin(), end() ); }

// element access
	reference 				operator[]( size_t s){ return *(m_pFirst+s); }
	const_reference			operator[]( size_t s) const { return *(m_pFirst+s); };
	reference				front() { return *m_pFirst; }
	const_reference			front() const { return *m_pFirst; }
	reference				back() { return *(m_pAfterLast-1); }
	const_reference			back() const { return *(m_pAfterLast-1); }

// size
	size_t				 	size() const{ return ( m_pAfterLast - m_pFirst ); }
	bool					empty() const{ return ( m_pAfterLast == m_pFirst ); }

private:
	enum {
		defaultSpace = 64
	};

	void					growSpace(size_t s);
	void					growSpace(iterator&,size_t);
	void					checkSpace(size_t s=1){if((size()+s)>=m_space) growSpace(s); }
	void					checkSpace(iterator& iter, size_t s=1){if((size()+s)>=m_space) growSpace(iter,s); }
	size_t					bytes(size_t s) const { return (s * sizeof(T)); }
	
	size_t	m_space;
	T*		m_pFirst;
	T*		m_pAfterLast;
};

template< class T >
inline
TVector<T>::TVector()
{
	m_space = 0;
	m_pFirst = m_pAfterLast = NULL;
}

template< class T >
inline
TVector<T>::~TVector()
{
	for( T* p = m_pFirst; p != m_pAfterLast; ++p )
	{
		p->~T();
	}
	operator delete( m_pFirst );
}

template< class T >
inline
void
TVector<T>::push_back(
	const T&	x
)
{
	checkSpace();
	new(m_pAfterLast) T(x);
	++m_pAfterLast;
}

template< class T >
inline
void
TVector<T>::pop_back()
{
	m_pAfterLast -= 1;
	m_pAfterLast->~T();
}

template< class T >
inline
__TYPENAME TVector<T>::iterator
TVector<T>::insert(
	__TYPENAME TVector<T>::iterator	iter,
	const T&				x
)
{
	checkSpace(iter);
	if ( iter != m_pAfterLast )
	{
		::memmove( iter+1, iter, bytes( m_pAfterLast - iter ) );
	}
	new(iter) T(x);
	++m_pAfterLast;
	return iter;
}

template< class T >
inline
void
TVector<T>::insert(
	__TYPENAME  TVector<T>::iterator	iter,
	size_t					n,
	const T&				x
)
{
	checkSpace(iter,n);
	if ( iter != m_pAfterLast )
	{
		::memmove( iter+n, iter, bytes( m_pAfterLast - iter ) );
	}
	for ( int i = 0; i < n; i++ )
	{
		new(iter+i) T(x);
	}
	m_pAfterLast += n;
}

template< class T >
inline
void
TVector<T>::insert(
	__TYPENAME  TVector<T>::iterator		insIter,
	__TYPENAME  TVector<T>::const_iterator	begIter,
	__TYPENAME  TVector<T>::const_iterator	endIter
)
{
	size_t n = endIter - begIter;
	checkSpace( insIter,n );
	if ( insIter != m_pAfterLast )
	{
		::memmove( insIter+n, insIter, bytes(m_pAfterLast-insIter) );
	}
	for( int i = 0; i < n; i++ )
	{
		new(insIter+i) T(*(begIter+i));
	}
	m_pAfterLast += n;
}

template< class T >
inline
__TYPENAME TVector<T>::iterator
TVector<T>::erase(
	__TYPENAME  TVector<T>::iterator	iter
)
{
	iter->~T();
	::memmove( iter, iter+1, bytes(m_pAfterLast-(iter+1)) );
	m_pAfterLast -= 1;
	return iter;
}

template< class T >
inline
__TYPENAME TVector<T>::iterator
TVector<T>::erase(
	__TYPENAME  TVector<T>::iterator	begIter,
	__TYPENAME  TVector<T>::iterator	endIter
)
{
	size_t n = endIter - begIter;
	for ( int i = 0; i < n; i++ )
	{
		(begIter+i)->~T();
	}
	::memmove( begIter, endIter, bytes(m_pAfterLast-(endIter)) );
	m_pAfterLast -= n;
	return begIter;
}

template< class T >
void
TVector<T>::growSpace(
	size_t	n
)
{
	size_t s = size();
	size_t newSpace = (m_space == 0)? defaultSpace : m_space * 2;
	while ( newSpace < (n + m_space) )
		newSpace *= 2;

	T *pBuffer = static_cast<T *>( operator new( bytes( newSpace ) ) );
	::memmove( pBuffer, m_pFirst, bytes(m_pAfterLast-m_pFirst) );
	operator delete( m_pFirst );
	m_space = newSpace;
	m_pFirst = pBuffer;
	m_pAfterLast = m_pFirst + s;
}

// this will grow the space as well as fixup the given iterator (since memory is moving)
template< class T >
void
TVector<T>::growSpace(
	__TYPENAME TVector<T>::iterator&	iter,	// fix up this iterator
	size_t					n
)
{
	size_t iterOff = iter - m_pFirst;
	growSpace(n);
	iter = m_pFirst + iterOff;
}

#endif	// !_MYVECTOR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\refptr.h ===
#ifndef _REFPTR_H_
#define _REFPTR_H_

/////////////////////////////////////////////////////////////////////////////
//
//	TRefPtr
//
//	This ref pointer template is useful for any objects that are referenced
//	multiple times.
//
//	The ref pointer depends on AddRef and Release being defined in the class
//	type T. ( AddRef should increment a reference counter, release should
//	decrement it and delete itself if the count is 0).  AddRef is called
//	upon construction and Release is called upon destruction.  Much care should
//	go into defining AddRef and Release if the smart pointer is used across
//	thread boundaries, since smart pointer don't force thread-safety.  In
//	particular, an object could get deleted twice if smart pointers in
//	seperate threads release it at the same time.
//
/////////////////////////////////////////////////////////////////////////////
template< class T >
class TRefPtr
{
public:
	TRefPtr();
	TRefPtr( T* pT );
	TRefPtr( const TRefPtr<T>& sp );
	~TRefPtr();

	T&			operator*();
	const T&	operator*() const;
	T*			operator->();
	const T*	operator->() const;

	TRefPtr<T>& operator=(const TRefPtr<T>&);
	bool	IsValid();
	T*		Get(){ return m_pT; }
	const T* Get() const { return m_pT; }
	void	Set( T* );
 	bool	operator==( const TRefPtr<T>& sp ) const;
 	bool	operator!=( const TRefPtr<T>& sp ) const;
	bool	operator<( const TRefPtr<T>& sp ) const;
	bool	operator>( const TRefPtr<T>& sp ) const;

//    template<class newType>
//    operator TRefPtr<newType>()
//    {
//        return TRefPtr<newType>(m_pT);
//    }

protected:
	T*		m_pT;
};

template< class T >
TRefPtr<T>::TRefPtr<T>()
	:	m_pT( NULL )
{
}

template< class T >
TRefPtr<T>::TRefPtr<T>(
	T*	pT )
	:	m_pT( pT )
{
	if ( m_pT )
	{
		m_pT->AddRef();
	}
}

template< class T >
TRefPtr<T>::TRefPtr<T>(
	const TRefPtr<T>&	sp )
	: m_pT( sp.m_pT )
{
	if ( m_pT )
	{
		m_pT->AddRef();
	}
}

template< class T >
TRefPtr<T>::~TRefPtr<T>()
{
	if ( m_pT )
	{
		m_pT->Release();
	}
}

template< class T >
void
TRefPtr<T>::Set(
	T*	pT )
{
	if ( m_pT )
	{
		m_pT->Release();
	}

	m_pT = pT;

	if ( m_pT )
	{
		m_pT ->AddRef();
	}
}

template< class T >
T&
TRefPtr<T>::operator*()
{
	return *m_pT;
}

template< class T >
const T&
TRefPtr<T>::operator*() const
{
	return *m_pT;
}

template< class T >
T*
TRefPtr<T>::operator->()
{
	return m_pT;
}

template< class T >
const T*
TRefPtr<T>::operator->() const
{
	return m_pT;
}

template< class T >          
bool                         
TRefPtr<T>::operator==(    
	const TRefPtr<T>& sp ) const
{                            
	return ( m_pT == sp.m_pT ); 
}                            

template< class T >          
bool                         
TRefPtr<T>::operator!=(    
	const TRefPtr<T>& sp ) const
{                            
	return ( m_pT != sp.m_pT ); 
}                            

template< class T >
bool
TRefPtr<T>::operator<(
	const TRefPtr<T>& sp ) const
{
	return ( (long)m_pT < (long)sp.m_pT );
}
                             
template< class T >
bool
TRefPtr<T>::operator>(
	const TRefPtr<T>& sp ) const
{
	return ( (long)m_pT > (long)sp.m_pT );
}
                             

template< class T >
TRefPtr<T>&
TRefPtr<T>::operator=(const TRefPtr<T>& rhs)
{
	if ( m_pT )
	{
		m_pT->Release();
	}

	m_pT = rhs.m_pT;

	if ( m_pT )
	{
		m_pT->AddRef();
	}

	return *this;
}

template< class T >
bool
TRefPtr<T>::IsValid()
{
	return ( m_pT != NULL );
}

// This macro helps solve the up-casting problems associated with smart pointers
// If you have class B inheriting from class A.  Then you can do the following
// typedef TRefPtr<A> APtr;
// DECLARE_REFPTR( B, A )
// Now you have can safe cast a BPtr to an APtr (BPtr is derived from APtr)

#define DECLARE_REFPTR( iclass, bclass ) \
class iclass##Ptr : public bclass##Ptr                                      \
{                                                                           \
public:                                                                     \
	                        iclass##Ptr()                                   \
                            : bclass##Ptr(){};                              \
                      	    iclass##Ptr( iclass * pT )                      \
                            : bclass##Ptr(pT){};                            \
                    	    iclass##Ptr( const iclass##Ptr & sp )           \
                            : bclass##Ptr(sp){};                            \
                                                                            \
	iclass &                operator*()                                     \
                            { return *((iclass *)m_pT); };                  \
  	const iclass &          operator*() const                               \
                            { return *((const iclass *)m_pT); };            \
	iclass *  	            operator->()                                    \
                            { return (iclass *)m_pT; };                     \
	const iclass *          operator->() const                              \
                            { return (const iclass *)m_pT; };               \
	iclass *                Get()                                           \
                            { return (iclass *)m_pT; };                     \
};

#endif	// !_SMARTPTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\soutstrm.h ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SOutStrm.h

   Abstract:
		A lightweight implementation of output streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#pragma once

#include "OutStrm.h"

class StringOutStream : public OutStream, public BaseStringBuffer
{
public:
						StringOutStream();
	virtual				~StringOutStream();
						
	virtual	HRESULT		writeChar( _TCHAR );
	virtual	HRESULT		writeString( LPCTSTR, size_t );
	
			String		toString() const;
private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\context.cpp ===
/*++

	Copyright	(c)    1997    Microsoft Corporation

	Module	Name :

		context.h

	Abstract:
		A class to retrieve and release ASP intrinsics

	Author:

		Neil Allain   ( a-neilal )	   August-1997 

	Revision History:

--*/
#include "stdafx.h"
#include <asptlb.h>
#include "context.h"


//---------------------------------------------------------------------------
//	GetServerObject
//
//	Get an instrinic object from the current Object context
//---------------------------------------------------------------------------
HRESULT
CContext::GetServerObject(
	IGetContextProperties*	pProps,
	BSTR					bstrObjName,
	const IID&				iid,
	void**					ppObj
)
{
	HRESULT rc = E_FAIL;
	_ASSERT( pProps );
	_ASSERT( bstrObjName );
	_ASSERT( ppObj );
	if ( pProps && bstrObjName && ppObj )
	{
		*ppObj = NULL;
		CComVariant vt;
		if ( !FAILED( pProps->GetProperty( bstrObjName, &vt ) ) )
		{
			if ( V_VT(&vt) == VT_DISPATCH )
			{
				IDispatch* pDispatch = V_DISPATCH(&vt);
				if ( pDispatch )
				{
					rc = pDispatch->QueryInterface( iid, ppObj );
				}
			}
		}
	}
	return rc;
}


HRESULT
CContext::Init(
	DWORD	dwFlags // which instrinsics to initialize
)
{
	HRESULT rc = E_FAIL;
	CComPtr<IObjectContext> pObjContext;

	rc = GetObjectContext( &pObjContext );
	if ( !FAILED( rc ) )
	{
		CComPtr<IGetContextProperties> pProps;
		rc = pObjContext->QueryInterface( IID_IGetContextProperties, (void**)&pProps );
		if ( !FAILED( rc ) )
		{
			CComBSTR bstrObj;
			if ( dwFlags & get_Request )
			{
				bstrObj = L"Request";
				rc = GetServerObject( pProps, bstrObj, IID_IRequest, (void**)&m_piRequest );
			}
			if ( !FAILED(rc) && ( dwFlags & get_Response ) )
			{
				bstrObj = L"Response";
				rc = GetServerObject( pProps, bstrObj, IID_IResponse, (void**)&m_piResponse );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Session ) )
			{
				bstrObj = L"Session";
				rc = GetServerObject( pProps, bstrObj, IID_ISessionObject, (void**)&m_piSession );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Server ) )
			{
				bstrObj = L"Server";
				rc = GetServerObject( pProps, bstrObj, IID_IServer, (void**)&m_piServer );
			}

			if ( !FAILED(rc) && ( dwFlags & get_Application ) )
			{
				bstrObj = L"Application";
				rc = GetServerObject( pProps, bstrObj, IID_IApplicationObject, (void**)&m_piApplication );
			}
		}
	}
	return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\finstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       FInStrm.cpp

   Abstract:
		A lightweight implementation of input streams using files

   Author:

       Neil Allain    ( a-neilal )     August-1997
       
   Revision History:
       Rayner D'Souza (raynerd)     October-2001 
            Rewrite parts of FileInStream object to memory-map a file rather than read a character
            at a time. This provides higher efficiency while attempting to read a file over a UNC share.

--*/
#include "stdafx.h"
#include "FInStrm.h"

FileInStream::FileInStream()
	:	m_hFile(NULL),
		m_hMap(NULL),
        m_cbFileSize(0L),
        m_cbCurrOffset (0L),
		m_bIsOpen( false ),
        m_bIsUTF8( false ),
        m_fInited(false)
{    
}


HRESULT FileInStream::Init(
	LPCTSTR			path
)
{
    HRESULT hr = S_OK;
    
	m_hFile = ::CreateFile(
		path,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL );
	if ( ( m_hFile != NULL ) && ( m_hFile != INVALID_HANDLE_VALUE ) )
	{
		m_bIsOpen = true;
		// As we will use readfile for verifying the signature of the file we need to perform the mapping
		// as soon as file creation succeeds
		hr = CreateFileMapping();
		if (FAILED(hr))
		    return hr;

        // check for the UTF8 signature

        _TCHAR   c;
        size_t  numRead = 0;
        _TCHAR   UTF8Sig[3] = { (_TCHAR)0xef, (_TCHAR)0xbb, (_TCHAR)0xbf };
        int     i;

        m_bIsUTF8 = true;

        // this loop will attempt to disprove that the file is saved as a
        // UTF8 file

        for (i=0; (i < 3) && (m_bIsUTF8 == true); i++) {
            if (readChar(c) != S_OK) {
                m_bIsUTF8 = false;
            }
            else {
                numRead++;
                if (c != UTF8Sig[i]) {
                    m_bIsUTF8 = false;
                }
            }
        }

        // if not a UTF8 file, move the file pointer back to the start of the file.
        // if it is a UTF8 file, then leave the pointer alone.

        if (m_bIsUTF8 == false)
            back(numRead);
        
	}
	else
	{
		ATLTRACE( _T("Couldn't open file: %s\n"), path );
		m_hFile = NULL;
		setLastError( E_FAIL );
		hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
		return hr;
	}
	m_fInited = true;
	return hr;
}

FileInStream::~FileInStream()
{
    if (m_fInited)
    {
        UnMapFile();
    
        if(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
            if(!CloseHandle(m_hFile)) 
                THROW(E_FAIL);
    }
    

    m_pbStartOfFile = NULL;
    m_cbCurrOffset = NULL;
    m_hMap = NULL;
    m_hFile = NULL;
    m_cbFileSize = 0L;    
}

    // now that the basic operation of determining if the file is UTF-8 or not has been accomplished
    // we now will attempt to set up a memory mapping of the file so that we will avoid char
    // by char read of the file (especially slow when the file is accross a UNC)
    // We have to take care of inpage-I/O errors though.
    
HRESULT FileInStream::CreateFileMapping ()
{
    if (m_bIsOpen)
        if(NULL == (m_hMap = ::CreateFileMapping(
                                    m_hFile,        // handle to file to map
                                    NULL,           // optional security attributes
                                    PAGE_READONLY,  // protection for mapping object
                                    0,              // high-order 32 bits of object size
                                    0,              // low-order 32 bits of object size
                                    NULL            // name of file-mapping object
                                )))    
            return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);    
        else 
        {
            // now actually create the map view.
            if(NULL == (m_pbStartOfFile =
                (PBYTE) ::MapViewOfFile(    m_hMap,         // file-mapping object to map into address space
                                        FILE_MAP_READ,  // access mode
                                        0,              // high-order 32 bits of file offset
                                        0,              // low-order 32 bits of file offset
                                        0               // number of bytes to map
                                    )))
                return HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
            else
            {
                m_cbCurrOffset = 0;
                m_cbFileSize = GetFileSize(m_hFile, NULL);                
         
            }
        }
    // This is the only exit path though it looks like more. (as long as no new code is added)
    // m_bIsOpen is set to true just before the call the CreateFileMapping() this the switch will take place and 
    // return either of the E_XXX or reach this point if it switches thru both the else's.
    return S_OK;
}

void FileInStream::UnMapFile ()
{
    if(m_pbStartOfFile != NULL)
        if(!UnmapViewOfFile(m_pbStartOfFile)) 
            THROW(E_FAIL);

    if(m_hMap!= NULL)
        if(!CloseHandle(m_hMap)) 
            THROW(E_FAIL);
}

// Try to maintain functionality as close to ReadFile as possible.

bool FileInStream::ReadMappedFile(LPVOID buff, DWORD countOfBytes, LPDWORD BytesRead)
{
    LONG    nTries = 0;
    // If either the file pointer of the buffer to be written to is wrong return INVALID_PARAMETER
    if (m_hFile == NULL || buff == NULL )
    {
        setLastError (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER));
        return FALSE;
    }

    // If the request is to read 0 bytes..thats valid so set the bytes read to 0 and return true.
    if (countOfBytes == 0)
    {
        *BytesRead=0;
        return TRUE;
    }

    // Calculate the number of bytes to read so that we dont overrun the memory allocated to us.
    DWORD bytesToRead = countOfBytes;
    if (m_cbCurrOffset+countOfBytes > m_cbFileSize)
         bytesToRead = m_cbFileSize - m_cbCurrOffset;

Retry:
    // Copy the appropriate number of bytes to the buffer.
    __try {
    memcpy (buff,m_pbStartOfFile+m_cbCurrOffset,bytesToRead);
    } 
    __except (TRUE, EXCEPTION_EXECUTE_HANDLER) {
        if (nTries++ < 2)
            goto Retry;
        else
        {
            *BytesRead = 0;
            return false;
        }
    }
    
    *BytesRead=bytesToRead;
    m_cbCurrOffset += bytesToRead;

    if (m_cbCurrOffset >= m_cbFileSize)
        setLastError(EndOfFile);    // This will basically set the eof flag too.
    
    return true;
}

// Equivalent to SetFilePointer .. 
// any value other than NULL in DistToMoveH is currently not handled.

void FileInStream::SetCurrFilePointer(LONG DistToMove, PLONG DistToMoveH, DWORD refPoint)
{
    switch (refPoint)
    {
        case FILE_BEGIN:
            if (DistToMove >= 0 && DistToMove <= m_cbFileSize)
                m_cbCurrOffset = DistToMove;
            break;
        case FILE_CURRENT:
            if (m_cbCurrOffset + DistToMove >= 0 && m_cbCurrOffset + DistToMove <= m_cbFileSize)
                m_cbCurrOffset += DistToMove;
            break;
        case FILE_END: // which in all cases should be -ve
            if (m_cbFileSize + DistToMove >= 0 && m_cbFileSize + DistToMove <= m_cbFileSize)
            {
                m_cbCurrOffset = m_cbFileSize + DistToMove;                
            }
            
            break;
        default:
            break;
    // Verify if we are crossing the file boundry..this would typically be done by the library 
    // but in this case we have taken on that responsibility.
        if (m_cbCurrOffset >= m_cbFileSize)
            setLastError(EndOfFile);
    }
}


HRESULT
FileInStream::readChar(
	_TCHAR&	c
)
{
	HRESULT rc = E_FAIL;
	DWORD readSize;

   	if ( ReadMappedFile(
	    	(void*)(&c),
    		sizeof( _TCHAR ),
    		&readSize ))
    {
	    if ( readSize == sizeof( _TCHAR ) )
   		{
	   		rc = S_OK;
	    }
   		else if ( readSize < sizeof( _TCHAR ) )
	   	{
	    	rc = EndOfFile;
   		}
	}
   	else
	{
   	    rc = E_FAIL;
	}

    setLastError( rc );

	return rc;
}


HRESULT
FileInStream::read(
	CharCheck&	cc,
	String&		str
)
{
	HRESULT rc = E_FAIL;
	if ( skipWhiteSpace() == S_OK )
	{
#if defined(_M_IX86) && _MSC_FULL_VER <= 13008806
        volatile
#endif
		size_t length = 0;
		_TCHAR c;
		bool done = false;
		while ( !done )
		{
			HRESULT stat = readChar(c);
			if ( ( stat == S_OK ) || ( stat == EndOfFile ) )
			{
				if ( !cc(c) && ( stat != EndOfFile ) )
				{
					length++;
				}
				else
				{
					done = true;
					if ( stat != EndOfFile )
					{
						SetCurrFilePointer(-(length+1), NULL, FILE_CURRENT );
					}
					else
					{
						SetCurrFilePointer(-length, NULL, FILE_CURRENT );
					}
					_ASSERT( length > 0 );

					// old code
					// if ( length > 0 )
					
					// new code, work around for compiler bug, should be fixed in future.
					if ( length >= 1 )
					{
						LPTSTR pBuffer = reinterpret_cast<LPTSTR>(_alloca( length + 1 ));
						if ( pBuffer )
						{
							DWORD dwReadSize;

   							ReadMappedFile(
    								(void*)(pBuffer),
    								length,
    								&dwReadSize);
   							pBuffer[ length ] = '\0';
   							str = pBuffer;    							
   							rc = stat;
						}
						else
						{
							rc = E_OUTOFMEMORY;
						}
					}
				}
			}
		}
	}
	setLastError( rc );
	return rc;
}


HRESULT
FileInStream::skip(
	CharCheck&	cc
)
{
	HRESULT rc = E_FAIL;
	_TCHAR c;

   	DWORD readSize;
   	BOOL b = ReadMappedFile((void*)(&c), sizeof(_TCHAR), &readSize);
   	while ( ( readSize == sizeof( _TCHAR ) ) && ( b == TRUE ) )
   	{
   		if ( !cc( c ) )
   		{
   			rc = S_OK;
   			b = FALSE;
   			SetCurrFilePointer(-1, NULL, FILE_CURRENT );
   		}
   		else
   		{
   			b = ReadMappedFile((void*)(&c), sizeof(_TCHAR), &readSize);
   		}
   	}
   	if ( readSize < sizeof( _TCHAR ) )
   	{
   		rc = EndOfFile;
   	}

	setLastError( rc );
	return rc;
}

HRESULT
FileInStream::back(
	size_t	s
)
{
	SetCurrFilePointer(-s, NULL, FILE_CURRENT );
	return S_OK;
}

/*==========================================================
poi_Capture

This is a C type function that is called when an exception is encountered.
It encapsulates the unsigned int u thrown by the __try block into a C++ exception
which is then caught with the appropriate try catch block.

Parameters:
unsigned int - exception number
_EXCEPTION_POINTERS - EXCEPTION POINTER structure

Return:
nothing

Throws : 
IPIOException 

==========================================================*/

void __cdecl poi_Capture(unsigned int u, _EXCEPTION_POINTERS* pExp)
{
    throw IPIOException(u);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\mem.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       mem.cpp

   Abstract:
		A new and delete operator that will throw excecptions

   Author:

       Neil Allain    ( a-neilal )     August-1997

   Revision History:

--*/

#include "stdafx.h"
#include <comdef.h>
#include "mydebug.h"

#ifdef DBG	// debug memory managment

void
DebugStart()
{
	// Enable debug heap allocations & check for memory leaks at program exit
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
				   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
}

void
DebugStop()
{
	_CrtCheckMemory();
}


void* __cdecl operator new( size_t s, const char* file, long line ) _THROW1(_com_error)
{
	void* p = _malloc_dbg( s, _NORMAL_BLOCK, file, line );
	THROW_IF_NULL(p);
	return p;
}

void *__cdecl operator new(size_t s) _THROW1(_com_error)
{
	void* p = malloc( s );
	THROW_IF_NULL(p);
	return p;
}

void __cdecl operator delete(void *p) _THROW0()
{
	if ( p )
	{
		free(p);
	}
}

#if _MSC_VER >= 1200
void __cdecl operator delete(void *p, const char* file, long line) _THROW0()
{
	if ( p )
	{
		_free_dbg(p, _NORMAL_BLOCK);
	}
}
#endif

#else

// release memory management
void __cdecl operator delete(void *p) _THROW0()
{
	if ( p )
	{
		free( p );
	}
}

void *__cdecl operator new(size_t s) _THROW1(_com_error)
{
	void* p = malloc( s );
	THROW_IF_NULL(p);
	return p;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\inc\strmap.h ===
//---------------------------------------------------------------------------
//	StrMap.h
//
//	Template class for a map of strings to something
//---------------------------------------------------------------------------
#pragma once
#ifndef _STRMAP_H_
#define _STRMAP_H_

#include "MyString.h"
#include <utility>
#include <algorithm>
#include "myvector.h"

template< class T >
struct StringPairEqual
{
	StringPairEqual( const String& str)
		:	m_rstr( str ) {}
	bool	operator()(
		const pair<String, T>& rhs )
	{
		return ( m_rstr == rhs.first );
	}
private:
	const String&	m_rstr;
};

template< class T >
struct StringPairCompare
{
	int operator()(
		const pair<String, T>&	lhs,
		const pair<String, T>&	rhs )
	{
		return lhs.first.compare( rhs.first );
	}
};

// template function--finds the first element n for which cmp(val,vec[n]) is true and
// cmp(val,vec[n-1]) is false
template< class T, class Compare >
__TYPENAME TVector<T>::iterator
binary_find(
	TVector<T>&	vec,
	const T&	val,
	Compare&	cmp )
{
	TVector<T>::iterator iter = vec.begin();

	if ( vec.size() > 0 )
	{
		size_t top = vec.size() - 1;
		size_t bot = 0;
		size_t mid = top >> 1;

		while ( top != bot )
		{
			int c = cmp( val, vec[mid] );
			if ( c > 0 )
			{
				// val > vec[mid]
				bot = mid + 1;
				mid = ( top + bot ) >> 1;
			}
			else if ( c < 0 )
			{
				// val < vec[mid]
				top = mid;
				mid = ( top + bot ) >> 1;
			}
			else
			{
				// val == vec[mid]
				top = bot = mid;
			}
		}
		iter = vec.begin() + mid;
		if ( cmp( val, vec[mid] ) > 0 )
		{
			iter++;
		}
	}
	
	return iter;
}

template< class T >
class TStringMap
{
public:
	typedef String								key_type;
	typedef	T									referent_type;
	typedef pair<key_type,referent_type>	value_type;
	typedef TVector<value_type>					vector_type;
	typedef typename vector_type::reference				reference;
	typedef typename vector_type::iterator				iterator;
	typedef typename vector_type::const_iterator			const_iterator;

	TStringMap(){};
	~TStringMap(){};

	iterator				begin() { return m_vec.begin(); }
	const_iterator			begin() const { return m_vec.begin(); }
	iterator				end() {return m_vec.end();}
	const_iterator			end() const {return m_vec.end();}
	iterator				find( const String& );
	pair<iterator, bool>	insert(const value_type& x);

	referent_type& 			operator[]( const String& );
	referent_type& 			operator[]( size_t n ) { return m_vec[n].second; }

	const referent_type& 	operator[]( const String& ) const ;
	const referent_type& 	operator[]( size_t n ) const { return m_vec[n].second; }

	void					clear(){ m_vec.clear(); }
	size_t					size() const { return m_vec.size(); }
private:
	vector_type				m_vec;
};

#if 0
template<class T>
inline
TStringMap<T>::iterator
TStringMap<T>::begin()
{
	return m_vec.begin();
}

template<class T>
inline
TStringMap<T>::const_iterator
TStringMap<T>::begin()
const
{
	return m_vec.begin();
}

template<class T>
inline
TStringMap<T>::iterator
TStringMap<T>::end()
{
	return m_vec.end();
}

template<class T>
inline
TStringMap<T>::const_iterator
TStringMap<T>::end()
const
{
	return m_vec.end();
}

#endif

template<class T>
inline
__TYPENAME TStringMap<T>::iterator
TStringMap<T>::find(
	const String& str )
{
	value_type vt(str,T());
	iterator iter = binary_find( m_vec, vt, StringPairCompare<T>() );
	StringPairEqual<T> spe(str);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		iter = m_vec.end();
	}
	return iter;
}

template<class T>
inline
pair< __TYPENAME TStringMap<T>::iterator, bool >
TStringMap<T>::insert(
	const __TYPENAME TStringMap<T>::value_type&	val )
{
	bool inserted = false;
	iterator iter = binary_find( m_vec, val, StringPairCompare<T>() );
	StringPairEqual<T> spe(val.first);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		inserted = true;
		iter = m_vec.insert( iter, val );
	}
	return pair<TStringMap<T>::iterator, bool>( iter, inserted );
}

template<class T>
inline
T&
TStringMap<T>::operator[](
	const String&	s )
{
	value_type vt(s,T());
	iterator iter = binary_find( m_vec, vt, StringPairCompare<T>() );
	StringPairEqual<T> spe(s);
	if ( ( iter != m_vec.end() ) && spe(*iter) )
	{
	}
	else
	{
		iter = m_vec.insert( iter, vt );
	}
	return (*iter).second;
}

		
#endif	// !_STRMAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\instrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       InStrm.cpp

   Abstract:
		A lightweight implementation of input streams.  This class provides
		the interface, as well as a basic skeleton for input streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "InStrm.h"

static void throwIOException( HRESULT s );

void
throwIOException(
	HRESULT	s
)
{
	if ( s != InStream::EndOfFile )
	{
		ATLTRACE( _T("InStream error: %d\n"), s );
	}
}

bool
IsWhiteSpace::operator()(
	_TCHAR	c
)
{
	bool rc = false;
	switch ( c )
	{
		case _T('\r'):
		case _T(' '):
		case _T('\t'):
		case _T('\n'):
		{
			rc = true;
		} break;
	}
	return rc;
}

bool
IsNewLine::operator()(
	_TCHAR	c
)
{
	bool rc = false;
	if ( ( c != _T('\n') ) && ( c != _T('\r') ) )
	{
	}
	else
	{
		rc = true;
	}
	return rc;
}

InStream::InStream()
	:	m_bEof(false),
		m_lastError( S_OK )
{
}

HRESULT
InStream::readInt16(
	SHORT&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt16();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readInt(
	int&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readInt32(
	LONG&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readUInt32(
	ULONG&	i
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		i = str.toUInt32();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readFloat(
	float&	f
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		f = str.toFloat();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readDouble(
	double&	f
)
{
	String str;
	HRESULT rc = readString( str );
	if ( ( rc == S_OK ) || rc == EndOfFile )
	{
		f = str.toDouble();
	}
	setLastError( rc );
	return rc;
}

HRESULT
InStream::readString(
	String&	str
)
{
	return read( IsWhiteSpace(), str );
}

HRESULT
InStream::readLine(
	String&	str
)
{
	return read( IsNewLine(), str );
}

HRESULT
InStream::skipWhiteSpace()
{
	return skip( IsWhiteSpace() );
}

InStream&
InStream::operator>>(
	_TCHAR&	c
)
{
	HRESULT s = readChar(c);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	SHORT&	i
)
{
	HRESULT s = readInt16(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	int&	i
)
{
	HRESULT s = readInt(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	LONG&	i
)
{
	HRESULT s = readInt32(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	ULONG&	i
)
{
	HRESULT s = readUInt32(i);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}


InStream&
InStream::operator>>(
	float&	f
)
{
	HRESULT s = readFloat(f);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	double&	f
)
{
	HRESULT s = readDouble(f);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

InStream&
InStream::operator>>(
	String&	str
)
{
	HRESULT s = readString(str);
	if ( s == S_OK )
	{
	}
	else
	{
		throwIOException(s);
	}
	return *this;
}

void
InStream::setLastError(
	HRESULT	hr )
{
	if ( hr == S_OK )
	{
	}
	else
	{
		if ( hr == EndOfFile )
		{
			m_bEof = true;
		}
		m_lastError = hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\outstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       OutStrm.cpp

   Abstract:
		A lightweight interface of output streams.  This class provides
		the interface, as well as a basic skeleton for output streams.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "OutStrm.h"

EndLineToken	endl;


OutStream::OutStream()
	:	m_lastError( S_OK )
{
}

OutStream::~OutStream()
{
}

HRESULT
OutStream::writeToken(
	const OutToken&
)
{
	return S_OK;
}

HRESULT
OutStream::writeEolToken(
	const EndLineToken&
)
{
	HRESULT rc = writeChar( '\n' );
	if ( rc == S_OK )
	{
		rc = flush();
	}
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::flush()
{
	return S_OK;
}

HRESULT
OutStream::writeString(
	const String&	str )
{
	HRESULT rc = writeString( str.c_str(), str.length() );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeString(
	LPCTSTR	str )
{
	HRESULT rc = writeString( str, _tcsclen(str) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeLine(
	LPCTSTR	format,
	... )
{
	va_list args;
	va_start( args, format );
	_TCHAR buf[ 1024 ];
	_vstprintf( buf, format, args );
	HRESULT rc = writeString( buf );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeInt16(
	SHORT	i
)
{
	HRESULT rc = writeString( String::fromInt16(i) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeInt(
	int	i
)
{
	HRESULT rc = writeString( String::fromInt32(i) );
	setLastError( rc );
	return rc;
}


HRESULT
OutStream::writeInt32(
	LONG	i
)
{
	HRESULT rc = writeString( String::fromInt32(i) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeFloat(
	float	f
)
{
	HRESULT rc = writeString( String::fromFloat(f) );
	setLastError( rc );
	return rc;
}

HRESULT
OutStream::writeDouble(
	double	d
)
{
	HRESULT rc = writeString( String::fromDouble(d) );
	setLastError( rc );
	return rc;
}

OutStream&
OutStream::operator<<(
	_TCHAR	c
) 
{
	setLastError( writeChar( c ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	SHORT	i
)
{
	setLastError( writeInt16( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	int	i
)
{
	setLastError( writeInt( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	LONG	i
) 
{
	setLastError( writeInt32( i ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	float	f
) 
{
	setLastError( writeFloat( f ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	double	d
) 
{
	setLastError( writeDouble( d ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const String&	str
) 
{
	setLastError( writeString( str ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	LPCTSTR		str
) 
{
	setLastError( writeString( str ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const OutToken&	ot
) 
{
	setLastError( writeToken( ot ) );
	return *this;
}

OutStream&
OutStream::operator<<(
	const EndLineToken&	elt
) 
{
	setLastError( writeEolToken( elt ) );
	return *this;
}

void
OutStream::setLastError(
	HRESULT	hr )
{
	if ( hr == S_OK )
	{
	}
	else
	{
		m_lastError = hr;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\mystring.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       MyString.h

   Abstract:
		A lightweight string class which supports UNICODE/MCBS.

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/

#include "stdafx.h"
#include "MyString.h"
#include <comdef.h>
#include "MyDebug.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif


BaseStringBuffer::BaseStringBuffer(
	LPCTSTR	inString )
{
	if ( inString )
	{
		m_length = _tcsclen( inString );
	}
	else
	{
		m_length = 0;
	}
	m_bufferSize = m_length + 1;
	m_pString = new _TCHAR[ m_bufferSize ];
	if ( inString )
	{
		_tcscpy( m_pString, inString );
	}
	else
	{
		m_pString[0] = _T('\0');
	}
}

BaseStringBuffer::BaseStringBuffer(
	size_t	bufferSize )
{
	if ( bufferSize <= 0 )
	{
		bufferSize = 1;
	}
	
	m_length=0;
	m_bufferSize = bufferSize;
	m_pString = new _TCHAR[ m_bufferSize ];
	_ASSERT( m_pString );
	m_pString[0] = '\0';
}
	
BaseStringBuffer::BaseStringBuffer(
	LPCTSTR	s1,
	LPCTSTR	s2
)
{
	m_length = _tcsclen( s1 ) + _tcsclen( s2 );
	m_bufferSize = m_length + 1;
	m_pString = new _TCHAR[ m_bufferSize ];
	_ASSERT( m_pString );
	_tcscpy( m_pString, s1 );
	_tcscat( m_pString, s2 );
}

BaseStringBuffer::~BaseStringBuffer()
{
	delete[] m_pString;
}

HRESULT
BaseStringBuffer::copy(
	LPCTSTR	str
)
{
	HRESULT rc;
	size_t len = _tcsclen( str );
	rc = growBuffer( len + 1 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscpy( m_pString, str );
	    m_length = len;
    }
	return rc;
}

HRESULT
BaseStringBuffer::concatenate(
	LPCTSTR	str
)
{
	HRESULT rc;
	size_t len = _tcsclen( str );
	rc = growBuffer( m_length + len + 1 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscat( m_pString, str );
	    m_length = m_length + len;
    }
    return rc;
}

HRESULT
BaseStringBuffer::concatenate(
	_TCHAR	c
)
{
	HRESULT rc;
	_TCHAR sz[2];
	sz[0] = c;
	sz[1] = _T('\0');
	rc = growBuffer( m_length + 2 );
	_ASSERT( m_pString );
    if (SUCCEEDED(rc)) {
	    _tcscat( m_pString, sz );
	    m_length += 1;
    }
	return rc;
}

HRESULT
BaseStringBuffer::growBuffer(
	size_t	inMinSize )
{
	HRESULT rc = E_OUTOFMEMORY;
	if ( m_bufferSize < inMinSize )
	{
        try {

		    LPTSTR newStringP = new _TCHAR[ inMinSize ];
		    _ASSERT( newStringP );
		    if ( newStringP )
		    {
			    if ( m_pString )
			    {
				    _tcscpy( newStringP, m_pString );
				    delete[] m_pString;
			    }
			    m_pString = newStringP;
			    m_bufferSize = inMinSize;
			    rc = S_OK;
		    }
		    else
		    {
			    delete m_pString;
			    m_pString = NULL;
			    m_bufferSize = 0;
			    m_length = 0;
		    }
        }
	    catch ( _com_error& ce ) {
		    rc = ce.Error();
	    }
	    catch ( ... ) {
		    rc = E_FAIL;
	    }        
	}
	return rc;
}

BaseStringBuffer::size_type
BaseStringBuffer::find_last_of(
	_TCHAR c) const
{
	size_type pos = npos;
	LPTSTR p = _tcsrchr(m_pString,c);
	if ( p != NULL )
	{
		pos = p - m_pString;
	}
	return pos;
}

BaseStringBuffer::size_type
BaseStringBuffer::find_first_of(
	_TCHAR c) const
{
	size_type pos = npos;
	_ASSERT( m_pString );
	LPTSTR p = _tcschr(m_pString,c);
	if ( p != NULL )
	{
		pos = p - m_pString;
	}
	return pos;
}

LPTSTR
BaseStringBuffer::substr(
	size_type b,
	size_type e ) const
{
	LPTSTR pStr = NULL;
	_ASSERT( m_pString );
	if ( m_pString )
	{
		LPCTSTR pB = m_pString + b;
		pStr = new _TCHAR[e-b+1];
		_ASSERT( pStr );
		if ( pStr )
		{
			_tcsnccpy( pStr, pB, e-b );
			pStr[e-b] = _T('\0');
		}
	}
	return pStr;
}

String::String(bool fCaseSensitive /* = true */)
{
    m_fCaseSensitive = fCaseSensitive;
	Set( new StringBuffer(_T("") ) );
}

String::String(
	const String&	str,
          bool      fCaseSensitive /* = true */
)	:	m_fCaseSensitive(fCaseSensitive),
        TRefPtr< StringBuffer >( str )
{
}

String::String(
	LPCTSTR		str,
    bool        fCaseSensitive /* = true */
)	:	m_fCaseSensitive(fCaseSensitive),
        TRefPtr< StringBuffer >( new StringBuffer( str ) )
{
}

String&
String::operator=(
	const String&	str
)
{
	Set( const_cast< StringBuffer* >(str.Get()) );
	return *this;
}

String&
String::operator=(
	LPCTSTR		str
)
{
	Set( new StringBuffer( str ) );
	return *this;
}

String&
String::operator=(
	StringBuffer*	pBuf
)
{
	Set( pBuf );
	return *this;
}

String&
String::operator+=(
	const String&	str
)
{
	StringBuffer* pb = new StringBuffer( c_str(), str.c_str() );
	Set( pb );
	return *this;
}

String&
String::operator+=(
	LPCTSTR		str
)
{
	StringBuffer* pb = new StringBuffer( c_str(), str );
	Set( pb );
	return *this;
}

String
String::operator+(
	const String&	str
) const
{
	StringBuffer* pb = new StringBuffer( c_str(), str.c_str() );
	String s;
	s.Set( pb );
	return s;
}

String
String::operator+(
	LPCTSTR		str
) const
{
	StringBuffer* pb = new StringBuffer( c_str(), str );
	String s;
	s.Set( pb );
	return s;
}

String
String::operator+(
	_TCHAR	c
) const
{
	StringBuffer* pb = new StringBuffer( c_str() );
	if ( pb )
	{
        HRESULT  rc;
        rc = pb->concatenate( c );
        if (FAILED(rc)) {
            delete pb;
            throw _com_error(rc);
        }
	}
	String s( pb );
	return s;
}

bool
String::operator==(
	const String&	str
) const
{
    if (m_fCaseSensitive)
	    return ( _tcscmp( c_str(), str.c_str() ) != 0 ) ? false : true;
    else
	    return ( _tcsicmp( c_str(), str.c_str() ) != 0 ) ? false : true;
}

bool
String::operator==(
	LPCTSTR		str
) const
{
    if (m_fCaseSensitive)
    	return ( _tcscmp( c_str(), str ) != 0 ) ? false : true;
    else
    	return ( _tcsicmp( c_str(), str ) != 0 ) ? false : true;

}

bool
String::operator<(
	const String&	str
) const
{
    if (m_fCaseSensitive)
	    return ( _tcscmp( c_str(), str.c_str() ) < 0 ) ? true : false;
    else
	    return ( _tcsicmp( c_str(), str.c_str() ) < 0 ) ? true : false;

}

bool
String::operator<(
	LPCTSTR		str
) const
{
    if (m_fCaseSensitive)
    	return ( _tcscmp( c_str(), str ) < 0 ) ? true : false;
    else
    	return ( _tcsicmp( c_str(), str ) < 0 ) ? true : false;

}

int
String::compare(
	size_t			b,
	size_t			e,
	const String&	str
) const
{
	return _tcsncmp( c_str() + b, str.c_str(), e - b );
}

size_t
String::find(
	_TCHAR	c
) const
{
	size_t pos = npos;
	LPCTSTR p = _tcschr( c_str(), c );
	if ( p != NULL )
	{
		pos = p - c_str();
	}
	return pos;
}

String
String::fromInt16(
	SHORT	i
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%d"), (LONG)i);
	return String(buf);
}

String
String::fromInt32(
	LONG	i
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%d"), i);
	return String(buf);
}

String
String::fromFloat(
	float	f
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%g"), f );
	return String(buf);
}

String
String::fromDouble(
	double	d
)
{
	_TCHAR buf[256];
	_stprintf( buf, _T("%g"), d );
	return String(buf);
}

String
operator+(
LPCTSTR			lhs,
const String&	rhs )
{
	return String( new StringBuffer(lhs,rhs.c_str()) );
}

/*============================================================================
StrDup

Duplicate a string.  An empty string will only be duplicated if the fDupEmpty
flag is set, else a NULL is returned.

Parameter
    CHAR *pszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

CHAR *StrDup
(
CHAR    *pszStrIn,
BOOL    fDupEmpty
)
    {
    CHAR *pszStrOut;
    INT  cch, cBytes;

    if (NULL == pszStrIn)
        return NULL;

    cch = strlen(pszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(CHAR) * (cch+1);
    pszStrOut = (CHAR *)malloc(cBytes);
    if (NULL == pszStrOut)
        return NULL;

    memcpy(pszStrOut, pszStrIn, cBytes);
    return pszStrOut;
    }

/*============================================================================
WStrDup

Same as StrDup but for WCHAR strings

Parameter
    CHAR *pwszStrIn      string to duplicate

Returns:
    NULL if failed.
    Otherwise, the duplicated string.

Side Effects:
    ***ALLOCATES MEMORY -- CALLER MUST FREE***
============================================================================*/

WCHAR *WStrDup
(
WCHAR *pwszStrIn,
BOOL  fDupEmpty
)
    {
    WCHAR *pwszStrOut;
    INT  cch, cBytes;

    if (NULL == pwszStrIn)
        return NULL;

    cch = wcslen(pwszStrIn);
    if ((0 == cch) && !fDupEmpty)
        return NULL;

    cBytes = sizeof(WCHAR) * (cch+1);
    pwszStrOut = (WCHAR *)malloc(cBytes);
    if (NULL == pwszStrOut)
        return NULL;

    memcpy(pwszStrOut, pwszStrIn, cBytes);
    return pwszStrOut;
    }
/*============================================================================
WstrToMBstrEx

Copies a wide character string into an ansi string.

Parameters:
    LPSTR dest      - The string to copy  into
    LPWSTR src      - the input BSTR
    cchBuffer      - the number of CHARs allocated for the destination string.
    lCodePage       - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT WstrToMBstrEx(LPSTR dest, INT cchDest, LPCWSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, cchDest, NULL, NULL);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = WideCharToMultiByte(lCodePage, 0, src, cchSrc, dest, 0, NULL, NULL);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    return cch;
    }

/*============================================================================
MBstrToWstrEx

Copies a ansi string into an wide character string.

Parameters:
    LPWSTR dest    - The string to copy  into
    LPSTR src      - the input ANSI string
    cchDest        - the number of Wide CHARs allocated for the destination string.
    cchSrc         - the length of the source ANSI string
    lCodePage      - the codepage used in conversion, default to CP_ACP

============================================================================*/
UINT MBstrToWstrEx(LPWSTR dest, INT cchDest, LPCSTR src, int cchSrc, UINT lCodePage)
    {
    UINT cch;

    // if the src length was specified, then reserve room for the NULL terminator.
    // This is necessary because WideCharToMultiByte doesn't add or account for
    // the NULL terminator if a source is specified.

    if (cchSrc != -1)
        cchDest--;

    cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, cchDest);
    if (cch == 0)
        {
        dest[0] = '\0';
        if(ERROR_INSUFFICIENT_BUFFER == GetLastError())
            {
            cch = MultiByteToWideChar(lCodePage, 0, src, cchSrc, dest, 0);

            // if a src length was specified, then WideCharToMultiByte does not include
            // it in it's resulting length.  Bump the count so that the caller does
            // account for the NULL.

            if (cchSrc != -1)
                cch++;         
            }
        else
            {
            cch = 1;
            }
        }
    else if (cchSrc != -1)
        {

        // if a src length was specified, then WideCharToMultiByte does not include
        // it in it's resulting length nor does it add the NULL terminator.  So add 
        // it and bump the count.

        dest[cch++] = '\0';
        }

    return cch;
    }

/*============================================================================
CMBCSToWChar::~CMBCSToWChar

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CMBCSToWChar::~CMBCSToWChar() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CMBCSToWChar::Init

Converts the passed in MultiByte string to UNICODE in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CMBCSToWChar::Init(LPCSTR pASrc, UINT lCodePage /* = CP_ACP */, int cchASrc /* = -1 */)
{
    INT cchRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pASrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cchResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.  NOTE - MBstrToWstrEx returns the
    // count of characters, not bytes.

    cchRequired = MBstrToWstrEx(m_pszResult, sizeof(m_resMemory), pASrc, cchASrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cchRequired <= (sizeof(m_resMemory)/sizeof(WCHAR))) {
        m_cchResult = cchRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPWSTR)malloc(cchRequired*sizeof(WCHAR));
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cchRequired = MBstrToWstrEx(m_pszResult, cchRequired, pASrc, cchASrc, lCodePage);

    // store the final char count in the object.

    m_cchResult = cchRequired;

    return NO_ERROR;
}

/*============================================================================
CMBCSToWChar::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPWSTR CMBCSToWChar::GetString(BOOL fTakeOwnerShip)
{
    LPWSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = WStrDup(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cchResult = 0;
    }

    return(retSz);
}

/*============================================================================
CWCharToMBCS::~CWCharToMBCS

The destructor has to be in the source file to ensure that it gets the right
memory allocation routines defined.
============================================================================*/
CWCharToMBCS::~CWCharToMBCS() 
{
    if(m_pszResult && (m_pszResult != m_resMemory)) 
        free(m_pszResult); 
}

/*============================================================================
CWCharToMBCS::Init

Converts the passed in WideChar string to MultiByte in the code page
specified.  Uses memory declared in the object if it can, else allocates
from the heap.
============================================================================*/
HRESULT CWCharToMBCS::Init(LPCWSTR pWSrc, UINT lCodePage /* = CP_ACP */, int cchWSrc /* = -1 */)
{
    INT cbRequired;

    // don't even try to convert if we get a NULL pointer to the source.  This
    // condition could be handled by setting by just initing an empty string.

    if (pWSrc == NULL) {
        return HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
    }

    // The init method can be called multiple times on the same object.  Check
    // to see if memory was allocated the last time it was called.  If so,
    // free it and restore the result pointer to the object memory.  Note that
    // an allocation failure could have occurred in a previous call.  The result
    // would be a NULL m_pszResult.

    if (m_pszResult != m_resMemory) {
        if (m_pszResult)
            free(m_pszResult);
        m_pszResult = m_resMemory;
        m_cbResult = 0;
    }

    // set the first byte of the result string to NULL char.  This should help
    // to ensure that nothing wacky happens if this function fails.

    *m_pszResult = '\0';

    // attempt translation into object memory.

    cbRequired = WstrToMBstrEx(m_pszResult, sizeof(m_resMemory), pWSrc, cchWSrc, lCodePage);

    // if the conversion fit, then we're done.  Note the final result size and 
    // return.

    if (cbRequired <= sizeof(m_resMemory)) {
        m_cbResult = cbRequired;
        return NO_ERROR;
    }

    // if it didn't fit, allocate memory.  Return E_OUTOFMEMORY if it fails.

    m_pszResult = (LPSTR)malloc(cbRequired);
    if (m_pszResult == NULL) {
        return E_OUTOFMEMORY;
    }

    // try the convert again.  It should work.

    cbRequired = WstrToMBstrEx(m_pszResult, cbRequired, pWSrc, cchWSrc, lCodePage);

    // store the final char count in the object.

    m_cbResult = cbRequired;

    return NO_ERROR;
}

/*============================================================================
CWCharToMBCS::GetString

Returns a pointer to the converted string.

If the fTakeOwnerShip parameter is FALSE, then the pointer in the object is
simply returned to the caller.

If the fTakeOwnerShip parameter is TRUE, then the caller is expecting to be
returned a pointer to heap memory that they have to manage.  If the converted
string is in the object's memory, then the string is duplicated into the heap.
If it's already heap memory, then the pointer is handed off to the caller.

NOTE - Taking ownership essentially destroys the current contents of the 
object.  GetString cannot be called on the object again to get the same value.
The result will be a pointer to a empty string.

============================================================================*/
LPSTR CWCharToMBCS::GetString(BOOL fTakeOwnerShip)
{
    LPSTR retSz;

    // return the pointer stored in m_psz_Result if not being
    // requested to give up ownership on the memory or the
    // current value is NULL.

    if ((fTakeOwnerShip == FALSE) || (m_pszResult == NULL)) {
        retSz = m_pszResult;
    }

    // ownership is being requested and the pointer is non-NULL.

    // if the pointer is pointing to the object's memory, dup
    // the string and return that.

    else if (m_pszResult == m_resMemory) {

        retSz = StrDup(m_pszResult, TRUE);
    }

    // if not pointing to the object's memory, then this is allocated
    // memory and we can relinquish it to the caller.  However, re-establish
    // the object's memory as the value for m_pszResult.

    else {
        retSz = m_pszResult;
        m_pszResult = m_resMemory;
        *m_pszResult = '\0';
        m_cbResult = 0;
    }

    return(retSz);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\monitor.cpp ===
#include "stdafx.h"
#include "Monitor.h"
#include "Lock.h"
#include "MyDebug.h"
#include "pudebug.h"
#include <process.h>

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

HINSTANCE g_hModuleInstance = NULL;

static String FileToDir( const String& );

// function objects for comparisons
struct DirCompare
{
    DirCompare( const String& strDir )
        :   m_strDir( strDir ) {}
    bool operator()( CMonitorDirPtr& pDir )
    {
        return ( m_strDir == pDir->Dir() );
    }
    String m_strDir;
};

struct FileCompare
{
    FileCompare( const String& strFile )
        :   m_strFile( strFile ) {}
    bool operator()( const CMonitorFilePtr& pFile )
    {
        return ( m_strFile == pFile->FileName() );
    }
    String m_strFile;
};

struct RegKeyCompare
{
    RegKeyCompare( HKEY hKey, const String strSubKey )
        :   m_hKey(hKey), m_strSubKey( strSubKey ) {}
    bool operator()( const CMonitorRegKeyPtr& pRegKey )
    {
        bool rc = false;
        if ( m_hKey == pRegKey->m_hBaseKey )
        {
            rc = ( m_strSubKey == pRegKey->m_strKey );
        }
        return rc;
    }
    const HKEY      m_hKey;
    const String   m_strSubKey;
};


String
FileToDir(
    const String&  strFile )
{
    String strDir;
    String::size_type pos = strFile.find_last_of( _T('\\') );
    if ( pos != String::npos )
    {
    }
    else
    {
        pos = strFile.find_first_of( _T(':') );
        if ( pos != String::npos )
        {
            pos++;
        }
    }

    if ( pos != String::npos )
    {
        strDir = strFile.substr( 0, pos );
    }
    return strDir;
}

//---------------------------------------------------------------------------
//  CMonitorFile
//---------------------------------------------------------------------------
CMonitorFile::CMonitorFile(
    const String&              strFile,
    const CMonitorNotifyPtr&    pNotify )
    :   m_strFile( strFile ),
        m_pNotify( pNotify )
{
    GetFileTime( m_ft );
}

CMonitorFile::~CMonitorFile()
{
}

const String&
CMonitorFile::FileName() const
{
    return m_strFile;
}

bool
CMonitorFile::GetFileTime(
    FILETIME&   ft )
{
    bool                        rc = false;
    WIN32_FILE_ATTRIBUTE_DATA   fileInfo;

    if (GetFileAttributesEx(m_strFile.c_str(),
                            GetFileExInfoStandard,
                            (LPVOID)&fileInfo)) {
        ft = fileInfo.ftLastWriteTime;
        rc = true;
    }

    return rc;
}

bool
CMonitorFile::CheckNotify()
{
    bool rc = false;

    FILETIME ft;

    if ( (GetFileTime( ft) == false) || (::CompareFileTime( &ft, &m_ft ) != 0) )
    {
        ATLTRACE( _T("File %s has changed...notifying\n"), m_strFile.c_str() );
        if ( m_pNotify.IsValid() )
        {
            m_pNotify->Notify();
        }
        rc = true;
    }
    m_ft = ft;
    return rc;
}


//---------------------------------------------------------------------------
//  CMonitorDir
//---------------------------------------------------------------------------
CMonitorDir::CMonitorDir(
    const String&  strDir )
    :   m_strDir( strDir )
{
    m_hNotification = ::FindFirstChangeNotification(
        m_strDir.c_str(),
        FALSE,
        FILE_NOTIFY_CHANGE_LAST_WRITE );
}

CMonitorDir::~CMonitorDir()
{
    m_files.clear();
    ::FindCloseChangeNotification( m_hNotification );
}

void
CMonitorDir::AddFile(
    const String&              strFile,
    const CMonitorNotifyPtr&    pNotify )
{
//    ATLTRACE( _T("Monitoring file %s\n"), strFile.c_str() );
    m_files.push_back( new CMonitorFile( strFile, pNotify ) );
}

void
CMonitorDir::RemoveFile(
    const String&   strFile )
{
    TVector<CMonitorFilePtr>::iterator iter = find_if(
        m_files.begin(),
        m_files.end(),
        FileCompare( strFile ) );
    if ( iter != m_files.end() )
    {
//        ATLTRACE( _T("Stopped monitoring file %s\n"), strFile.c_str() );
        m_files.erase( iter );
    }
    else
    {
//        ATLTRACE( _T("Not monitoring file %s\n"), strFile.c_str() );
    }
}

void
CMonitorDir::Notify()
{
    for ( UINT i = 0; i < m_files.size(); i++ )
    {
        m_files[i]->CheckNotify();
    }
    ::FindNextChangeNotification( m_hNotification );
}

ULONG
CMonitorDir::NumFiles() const
{
    return m_files.size();
}

HANDLE
CMonitorDir::NotificationHandle() const
{
    return m_hNotification;
}

const String&
CMonitorDir::Dir() const
{
    return m_strDir;
}

//---------------------------------------------------------------------------
//  CMonitorRegKey
//---------------------------------------------------------------------------
CMonitorRegKey::CMonitorRegKey(
    HKEY                        hBaseKey,
    const String&              strKey,
    const CMonitorNotifyPtr&    pNotify )
    :   m_hEvt(NULL),
        m_hKey(NULL),
        m_pNotify( pNotify ),
        m_strKey( strKey ),
        m_hBaseKey( hBaseKey )
{
    LONG l = ::RegOpenKeyEx(
        hBaseKey,
        strKey.c_str(),
        0,
        KEY_NOTIFY,
        &m_hKey );
    if ( l == ERROR_SUCCESS )
    {
        m_hEvt = IIS_CREATE_EVENT(
                     "CMonitorRegKey::m_hEvt",
                     this,
                     TRUE,
                     FALSE
                     );
        if ( m_hEvt != NULL )
        {
#if 0   // not available in Win95
            // ask for notification when the key changes
            l = ::RegNotifyChangeKeyValue(
                m_hKey,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                m_hEvt,
                TRUE );
            if ( l == ERROR_SUCCESS )
            {
                // okay
            }
            else
            {
                ATLTRACE( _T("Couldn't get reg key notification\n") );
            }
#endif // if 0
        }
        else
        {
            ATLTRACE( _T("Couldn't create event\n") );
        }
    }
    else
    {
        ATLTRACE( _T("Couldn't open subkey: %s\n"), strKey.c_str() );
    }
}

CMonitorRegKey::~CMonitorRegKey()
{
    ::RegCloseKey( m_hKey );
    ::CloseHandle( m_hEvt );
}

void
CMonitorRegKey::Notify()
{
    if ( m_pNotify.IsValid() )
    {
        m_pNotify->Notify();
    }
    ::ResetEvent( m_hEvt );
#if 0 // not available in Win95
    ::RegNotifyChangeKeyValue(
        m_hKey,
        FALSE,
        REG_NOTIFY_CHANGE_LAST_SET,
        m_hEvt,
        TRUE );
#endif
}

HANDLE
CMonitorRegKey::NotificationHandle() const
{
    return m_hEvt;
}

//---------------------------------------------------------------------------
//  CMonitor
//---------------------------------------------------------------------------

#include <irtldbg.h>

CMonitor::CMonitor()
    :   m_hevtBreak( NULL ),
        m_hevtShutdown( NULL ),
        m_hThread( NULL ),
        m_bRunning( false ),
        m_bStopping( false )
#ifdef STRING_TRACE_LOG
        , m_stl(100, 1000)
#endif
{
    SET_CRITICAL_SECTION_SPIN_COUNT(&m_cs.m_sec, IIS_DEFAULT_CS_SPIN_COUNT);
    STL_PRINTF("Created monitor, %p", this);
#ifdef STRING_TRACE_LOG
    IrtlTrace("Monitor::m_stl = %p\n", &m_stl);
#endif
}

CMonitor::~CMonitor()
{
    StopAllMonitoring();
    if ( m_hevtBreak != NULL )
    {
        ::CloseHandle( m_hevtBreak );
    }
    if ( m_hevtShutdown != NULL )
    {
        ::CloseHandle( m_hevtShutdown );
    }
    if ( m_hThread != NULL )
    {
        ::CloseHandle( m_hThread );
    }
    STL_PRINTF("Destroying monitor, %p", this);
}

void
CMonitor::MonitorFile(
    LPCTSTR                     szFile,
    const CMonitorNotifyPtr&    pMonNotify )
{
    CLock l(m_cs);

    if (m_bStopping)
        return;

    STL_PRINTF("MonitorFile(%s), Run=%d, Stop=%d, Thread=%p",
               szFile, (int) m_bRunning, (int) m_bStopping, m_hThread);

    String strFile( szFile );
    String strDir = FileToDir( strFile );

    CMonitorDirPtr pDir;
    TVector<CMonitorDirPtr>::iterator iter = find_if(
        m_dirs.begin(),
        m_dirs.end(),
        DirCompare( strDir ) );
    if ( iter == m_dirs.end() )
    {
//        ATLTRACE( _T("Request to monitor new directory: %s\n"), strDir.c_str() );
        pDir = new CMonitorDir( strDir );
        m_dirs.push_back( pDir );
    }
    else
    {
        pDir = (*iter);
    }

    if ( pDir.IsValid() )
    {
        pDir->AddFile( strFile, pMonNotify );
        if ( !m_bRunning )
        {
            StartUp();
        }
        else
        {
            ::SetEvent( m_hevtBreak );
        }
    }
}

void
CMonitor::StopMonitoringFile(
    LPCTSTR szFile )
{
    String strFile( szFile );
    String strDir = FileToDir( strFile );

    CLock l(m_cs);

    if (m_bStopping)
        return;

    STL_PRINTF("StopMonitoringFile(%s), Run=%d, Stop=%d, Thread=%p",
               szFile, (int) m_bRunning, (int) m_bStopping, m_hThread);

    TVector<CMonitorDirPtr>::iterator iter = find_if(
        m_dirs.begin(),
        m_dirs.end(),
        DirCompare( strDir ) );
    if ( iter != m_dirs.end() )
    {
        if ( (*iter).IsValid() )
        {
            (*iter)->RemoveFile( strFile );
            if ( (*iter)->NumFiles() == 0 )
            {
                // no more files to monitor in this directory, remove it
                m_dirs.erase(iter);
                ::SetEvent( m_hevtBreak );
            }
        }
    }
    else
    {
//        ATLTRACE( _T("Not monitorying file %s\n"), szFile );
    }
}

void
CMonitor::MonitorRegKey(
    HKEY                        hBaseKey,
    LPCTSTR                     szSubKey,
    const CMonitorNotifyPtr&    pNotify )
{
    String strSubKey = szSubKey;

//    ATLTRACE( _T( "Request to monitor new key: %s\n"), szSubKey );

    CLock l(m_cs);

    if (m_bStopping)
        return;

    if ( find_if(
            m_regKeys.begin(),
            m_regKeys.end(),
            RegKeyCompare( hBaseKey, szSubKey ) )
        == m_regKeys.end() )
    {
        // not already begin monitored, add a new one
        CMonitorRegKeyPtr pRegKey = new CMonitorRegKey( hBaseKey, szSubKey, pNotify );
        m_regKeys.push_back(pRegKey);

        // either start the monitoring thread or, inform it of a new key to monitor
        if ( !m_bRunning )
        {
            StartUp();
        }
        else
        {
            ::SetEvent( m_hevtBreak );
        }
    }
}

void
CMonitor::StopMonitoringRegKey(
    HKEY    hBaseKey,
    LPCTSTR szSubKey )
{
    String strSubKey = szSubKey;

    CLock l(m_cs);

    if (m_bStopping)
        return;

    TVector<CMonitorRegKeyPtr>::iterator iter = find_if(
        m_regKeys.begin(),
        m_regKeys.end(),
        RegKeyCompare( hBaseKey, szSubKey ) );
    if ( iter != m_regKeys.end() )
    {
//        ATLTRACE( _T( "Stopping monitoring of key: %s\n"), szSubKey );
        m_regKeys.erase( iter );
        ::SetEvent( m_hevtBreak );
    }
    else
    {
//        ATLTRACE( _T("Not monitoring key: %s\n"), szSubKey );
    }
}

void
CMonitor::StopAllMonitoring()
{
    m_cs.Lock();

    STL_PRINTF("StopAllMonitoring, Run=%d, Stop=%d, Thread=%p",
               (int) m_bRunning, (int) m_bStopping, m_hThread);

    if ( m_bRunning )
    {
// clear all types of nodes here
        m_bStopping = true;
        m_regKeys.clear();
        m_dirs.clear();
        m_cs.Unlock(); // must unlock or DoMonitoring will deadlock

        ::SetEvent( m_hevtShutdown );
        // Wait for 10 seconds rather than eternity for other threads to exit.
        ::WaitForSingleObject( m_hThread, (10 * 1000) );

        m_cs.Lock();
        ::CloseHandle( m_hThread );
        m_hThread = NULL;
        m_bRunning = false;
        m_bStopping = false;
    }
    m_cs.Unlock();
}


bool
CMonitor::StartUp()
{
    CLock l(m_cs);

    bool rc = false;

    STL_PRINTF("Startup, Run=%d, Stop=%d, Thread=%p",
               (int) m_bRunning, (int) m_bStopping, m_hThread);

    if (m_bStopping)
        return false;

    // Have we already started the thread?
    if (m_bRunning)
    {
        _ASSERT(m_hevtBreak != NULL);
        _ASSERT(m_hevtShutdown != NULL);
        _ASSERT(m_hThread != NULL);

        // Notify the thread that something has changed
        ::SetEvent( m_hevtBreak );
        return true;
    }

    _ASSERT(m_hThread == NULL);

    if ( m_hevtBreak == NULL )
    {
        m_hevtBreak = IIS_CREATE_EVENT(
                          "CMonitor::m_hevtBreak",
                          this,
                          FALSE,    // auto event
                          FALSE
                          );
    }

    if ( m_hevtShutdown == NULL )
    {
        m_hevtShutdown = IIS_CREATE_EVENT(
                          "CMonitor::m_hevtShutdown",
                          this,
                          FALSE,    // auto event
                          FALSE
                          );
    }

    if ( m_hevtBreak != NULL )
    {
        DWORD iThreadID;

#if DBG
        if( m_hThread != NULL || m_bRunning)
        {
            DebugBreak();
        }
#endif

        m_hThread = (HANDLE) CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)CMonitor::ThreadFunc,
            this,
            0,
            (LPDWORD) &iThreadID );

        STL_PRINTF("Startup, Thread=%p, Break=%p, Shutdown=%p",
                   m_hThread, m_hevtBreak, m_hevtShutdown);

        if ( m_hThread != NULL )
        {
            ATLTRACE( _T("Started monitor (%p) thread %p\n"),
                      this, m_hThread );
            m_bRunning = true;
            rc = true;
        }
    }
    return rc;
}

DWORD
CMonitor::DoMonitoring()
{
    HANDLE* phEvt = NULL;
    TVector<CMonitorNodePtr> nodes;

    while ( 1 )
    {
        DWORD dwTimeOut = INFINITE;

        if ( phEvt == NULL )
        {
            CLock l(m_cs);

            // build the complete list of monitored nodes
            nodes.clear();
            nodes.insert( nodes.end(), m_dirs.begin(), m_dirs.end() );
            nodes.insert( nodes.end(), m_regKeys.begin(), m_regKeys.end() );
// insert other types of nodes to monitor here

            // Lazily shut down if there are no nodes to monitor
            if ( nodes.size() == 0 )
            {
                // Since thread creation and destruction is a fairly
                // expensive operation, wait for 5 minutes before killing
                // thread
                dwTimeOut = 5 * 60 * 1000;
            }

            // now create the array of event handles
            phEvt = new HANDLE[ nodes.size() + 2 ];
            phEvt[ 0 ] = m_hevtBreak;
            phEvt[ 1 ] = m_hevtShutdown;
            for ( UINT i = 0; i < nodes.size(); i++ )
            {
                phEvt[i+2] = nodes[i]->NotificationHandle();
            }
        }
        else
            STL_PUTS("phEvt != NULL");

        DWORD dw = ::WaitForMultipleObjects(
            nodes.size() + 2,
            phEvt,
            FALSE, // any event will do
            dwTimeOut );

        if ( dw == WAIT_TIMEOUT)
        {
            STL_PUTS("WAIT_TIMEOUT");
            if ( nodes.size() == 0 )
            {
                STL_PRINTF("Nothing to watch: Shutting down, Stopping=%d",
                           (int) m_bStopping);
                ATLTRACE( _T("Nothing to watch... ")
                          _T("stopping monitoring (%p) thread %p\n"),
                          this, m_hThread);
                m_bRunning = false;
                ::CloseHandle( m_hThread );
                m_hThread = NULL;
                return 0;
            }
        }
        // Was one of the events in phEvt signalled?
        C_ASSERT( WAIT_OBJECT_0 == 0 );
        if ( dw < ( WAIT_OBJECT_0 + nodes.size() + 2 ) )
        {
            CLock l(m_cs);

            if ( dw >= WAIT_OBJECT_0 + 2)
            {
                // a monitored item has changed
                nodes[ dw - ( WAIT_OBJECT_0 + 2 ) ]->Notify();
                STL_PRINTF("Notifying object %d", dw - (WAIT_OBJECT_0 + 2));
            }
            else
            {
                // m_hevtBreak or m_hevtShutdown were signalled.  If
                // m_hevtBreak, then there was a manual break, and a node
                // was probably added or removed, so the vector of nodes
                // needs to be regenerated
                nodes.clear();
                delete[] phEvt;
                phEvt = NULL;

                // m_hevtShutdown was signalled
                if ( dw == WAIT_OBJECT_0 + 1)
                {
                    _ASSERT(m_bStopping);
                    STL_PRINTF("Shutting down, Stopping=%d",
                               (int) m_bStopping);

                    ATLTRACE(_T("Shutting down monitoring (%p) thread %p\n"),
                              this, m_hThread);
                    m_bRunning = false;
                    // Must NOT CloseHandle(m_hThread) because
                    // StopAllMonitoring is waiting on it
                    return 0;
                }
                else
                    STL_PUTS("m_hevtBreak");
            }
        }
        else if ( dw == WAIT_FAILED )
        {
            CLock l(m_cs);

            // something's wrong, we'll just clean up and exit
            DWORD err = ::GetLastError();
            ATLTRACE( _T("CMonitor: WaitForMultipleObjects error: 0x%x\n"),
                      err );
            ATLTRACE( _T( "CMonitor: abandoning wait thread\n") );
            nodes.clear();
            delete[] phEvt;
            phEvt = NULL;

            m_dirs.clear();
            m_regKeys.clear();
            m_bRunning = false;
            ::CloseHandle( m_hThread );
            m_hThread = NULL;

            return err;
        }
    }   // end infinite while
}


unsigned
__stdcall
CMonitor::ThreadFunc(
    void* pv)
{
    CMonitor* pMon = (CMonitor*) pv;
    DWORD rc = -1;

    /* BUGBUG: We start up a thread to do monitoring. If in the meantime the main module containing DLL
     * exits (shutsdown), we have only a 10 second grace window because we are holding onto a loader lock.
     * When the DLL refcount goes down to zero on return from DLLMain, the module is unloaded, irrespective
     * that this monitoring thread is still happily going about its business. In normal circumstances, this thread
     * will exit soon enough. But not always, under high system load, this memory may get paged out and
     * will result in an Inpage I/O error, which is thrown to the owning (parent) module. As parent module
     * as it is already unloaded will cause an AV.
     * SOLUTION:
     * Perform a Load Library, so as to increment the references to the corresponding library and free library
     * when we exit the DoMonitoring loop.
     */

    HMODULE hModule = NULL;
    LPTSTR  pModuleFileName = new _TCHAR[MAX_PATH+1];

    DWORD len = GetModuleFileName ( g_hModuleInstance, // current module,
                                        pModuleFileName, // Name of the module
                                        MAX_PATH ); //

    pModuleFileName[MAX_PATH] = _T('\0');        // Force a NULL termination in case of truncation.

    if (len)
        hModule = LoadLibrary (pModuleFileName);


    try
    {
        if ( pMon )
        {
            rc = pMon->DoMonitoring();
        }
    }
    catch( ... )
    {
    }

    delete[] pModuleFileName;

    if (hModule)
        FreeLibraryAndExitThread (hModule, rc);
    else
        ExitThread(rc);
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\rdwrt.cpp ===
// RdWrt.cpp

#include "stdafx.h"
#include "RdWrt.h"
#include "pudebug.h"

CReadWrite::CReadWrite()
    :   m_cReaders(0)
{
    // set up reader and writer events
    m_hevtNoReaders = IIS_CREATE_EVENT(
                          "CReadWrite::m_hevtNoReaders",
                          this,
                          TRUE,
                          TRUE
                          );

    m_hmtxWriter = IIS_CREATE_MUTEX(
                       "CReadWrite::m_hmtxWriter",
                       this,
                       FALSE
                       );

    m_handles[0] = m_hevtNoReaders;
    m_handles[1] = m_hmtxWriter;
}

CReadWrite::~CReadWrite()
{
    ::CloseHandle( m_hmtxWriter );
    ::CloseHandle( m_hevtNoReaders );
}


void
CReadWrite::EnterReader()
{
    ::WaitForSingleObject( m_hmtxWriter, INFINITE );

    if ( ++m_cReaders == 1 )
    {
        ::ResetEvent( m_hevtNoReaders );
    }
//    ATLTRACE( _T("Reader entered: %d\n"), m_cReaders );
    ::ReleaseMutex( m_hmtxWriter );
}

void
CReadWrite::ExitReader()
{
    ::WaitForSingleObject( m_hmtxWriter, INFINITE );

    if ( --m_cReaders == 0 )
    {
        ::SetEvent( m_hevtNoReaders );
    }
//    ATLTRACE( _T("Reader exited: %d\n"), m_cReaders );
    ::ReleaseMutex( m_hmtxWriter );
}

void
CReadWrite::EnterWriter()
{
    // this implementation could possibly starve writers
    ::WaitForMultipleObjects(
        2,
        m_handles,
        TRUE,
        INFINITE );

//    ATLTRACE( _T("Writer entered\n") );
    _ASSERT( m_cReaders == 0 );
}

void
CReadWrite::ExitWriter()
{
    _ASSERT( m_cReaders == 0 );
//    ATLTRACE( _T("Writer exited\n") );
    ::ReleaseMutex( m_hmtxWriter );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\sinstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SInStrm.cpp

   Abstract:
        A lightweight implementation of input streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "SInStrm.h"
#include "MyDebug.h"

#ifdef DBG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

StringInStream::StringInStream(
    const String&   str
)   :   BaseStringBuffer( str.c_str() )
{
    m_pos = m_pString;
    if ( m_pos != NULL )
    {
        m_end = c_str() + length();
    }
    else
    {
        m_end = NULL;
        setLastError( EndOfFile );
    }
}

HRESULT
StringInStream::readChar(
    _TCHAR& c
)
{
    HRESULT rc = EndOfFile;
    
    if ( m_pos != m_end )
    {
        c = *m_pos++;
        rc = S_OK;
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::read(
    CharCheck&  cc,
    String&     str
)
{
    HRESULT rc = E_FAIL;
    if ( skipWhiteSpace() == S_OK )
    {
        size_t length = 0;
        _TCHAR c;
        bool done = false;
        while ( !done )
        {
            HRESULT stat = readChar(c);
            if ( ( stat == S_OK ) || ( stat == EndOfFile ) )
            {
                if ( !cc(c) && ( stat != EndOfFile ) )
                {
                    length++;
                }
                else
                {
                    done = true;
                    LPTSTR pCpy;
                    if ( stat != EndOfFile )
                    {
                        pCpy = m_pos - (length+1);
                    }
                    else
                    {
                        pCpy = m_pos - length;
                    }
                    _ASSERT( length > 0 );
                    if ( length > 0 )
                    {
                        LPTSTR pBuffer = new _TCHAR[ length + 1 ];
                        if ( pBuffer )
                        {
                            _tcsncpy( pBuffer,  pCpy, length );
                            pBuffer[ length ] = _T('\0');
                            str = pBuffer;
                            rc = stat;
                            delete[] pBuffer;
                        }
                        else
                        {
                            rc = E_OUTOFMEMORY;
                        }
                    }
                }
            }
        }
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::skip(
    CharCheck&  cc
)
{
    HRESULT rc = E_FAIL;
    _TCHAR c;
    bool done = false;
    while ( ( m_pos != m_end ) && ( !done ) )
    {
        c = *m_pos;
        if ( !cc( c ) )
        {
            rc = S_OK;
            done = true;
        }
        else
        {
            m_pos++;
        }
    }
    setLastError( rc );
    return rc;
}

HRESULT
StringInStream::back(
    size_t s
)
{
    m_pos -= s;
    if ( (ULONG_PTR)m_pos < (ULONG_PTR)m_pString )
    {
        m_pos = m_pString;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\aspcmp\shared\src\soutstrm.cpp ===
/*++

   Copyright    (c)    1997    Microsoft Corporation

   Module  Name :

       SOutStrm.cpp

   Abstract:
		A lightweight implementation of output streams using strings

   Author:

       Neil Allain    ( a-neilal )     August-1997 

   Revision History:

--*/
#include "stdafx.h"
#include "SOutStrm.h"

StringOutStream::StringOutStream()
	:	BaseStringBuffer( _T("") )
{
}

StringOutStream::~StringOutStream()
{
}

HRESULT
StringOutStream::writeChar(
	_TCHAR	c
)
{
	HRESULT rc = concatenate( c );
	return rc;
}

HRESULT
StringOutStream::writeString(
	LPCTSTR	str,
	size_t	/* length */
)
{
	HRESULT rc = concatenate( str );
	return rc;
}

String
StringOutStream::toString() const
{
	String s( c_str() );
	return s;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
#define AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__E9642BCE_0968_11D3_A7F6_0000F8085B95__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\svcs\cmp\asptxn\asptxn.cpp ===
// asptxn.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for asptxn.idl by adding the following
//      files to the Outputs.
//          asptxn_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f asptxnps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "txnscrpt.h"
#include "dlldatax.h"

#include "txnscrpt_i.c"
#include "txnobj.h"

#include <dbgutil.h>
#include <comadmin.h>

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxRequired,      CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxRequiresNew,   CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxSupported,     CASPObjectContext)
    OBJECT_ENTRY(CLSID_ASPObjectContextTxNotSupported,  CASPObjectContext)
END_OBJECT_MAP()

LPCSTR  g_szModuleName = "ASPTXN";

DECLARE_DEBUG_VARIABLE();

DECLARE_DEBUG_PRINTS_OBJECT();

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CREATE_DEBUG_PRINT_OBJECT( g_szModuleName );
        if( !VALID_DEBUG_PRINT_OBJECT() )
        {
            return FALSE;
        }

        LOAD_DEBUG_FLAGS_FROM_REG_STR("System\\CurrentControlSet\\Services\\W3Svc\\ASP", 0);

        _Module.Init(ObjectMap, hInstance /*, ATL21 &LIBID_ASPTXNLib */);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        DELETE_DEBUG_PRINT_OBJECT();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

// Forward references
HRESULT ViperizeContextObject();
HRESULT AddViperUtilPackage();
HRESULT RemoveViperUtilPackage(ICatalogCollection* pPkgCollectionT);
HRESULT AddContextObjectToViperPackage();


STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif

    HRESULT hr = NOERROR;

    // registers object, typelib and all interfaces in typelib
    hr = _Module.RegisterServer(TRUE);

    // create the iis utilities package
    if( SUCCEEDED(hr) )
    {
        HRESULT hrCoInit = CoInitialize( NULL );

        // This is kinda dopey, but remove the package if it exists
        // so we don't get bogus errors when we add. Ignore the return.
        RemoveViperUtilPackage(NULL);

        hr = ViperizeContextObject();

        if( SUCCEEDED(hrCoInit) )
        {
            CoUninitialize();
        }
    }
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif

    HRESULT hr = NOERROR;

    HRESULT hrCoInit = CoInitialize( NULL );

    // Remove the iis utilities package before unregistering the objects
    hr = RemoveViperUtilPackage(NULL);

    if( SUCCEEDED(hrCoInit) )
    {
        CoUninitialize();
    }

    // We don't really care about failures...
    hr = _Module.UnregisterServer(/* ATL21 TRUE */);

    // NOTE: ATL doesn't unregister the typelibrary. Since
    // the interfaces we are exposing are internal to asp we should
    // consider removing the typelibrary registry entries.

    return hr;
}


// Registration code to be pulled from asp.dll

#define RELEASE(p) if ( p ) { p->Release(); p = NULL; }
#define FREEBSTR(p) SysFreeString( p ); p = NULL;

const WCHAR wszCLSID_ASPObjectContextTxRequired[]     = L"{14D0916D-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxRequiresNew[]  = L"{14D0916E-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxSupported[]    = L"{14D0916F-9CDC-11D1-8C4A-00C04FC324A4}";
const WCHAR wszCLSID_ASPObjectContextTxNotSupported[] = L"{14D09170-9CDC-11D1-8C4A-00C04FC324A4}";

const WCHAR wszASPUtilitiesPackageID[] = L"{ADA44581-02C1-11D1-804A-0000F8036614}";

/*===================================================================
GetSafeArrayOfCLSIDs

Get a SafeArray contains one ComponentCLSID

Parameter:
szComponentCLSID    the CLSID need to be put in the safe array
paCLSIDs            pointer to a pointer of safe array(safe array pro