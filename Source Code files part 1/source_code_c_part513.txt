********/

class NEW_PAGE_LIST : public FIND_LIST
    {
		//
		//   Private data.
		//
 		LIST						  NewPageList;

   public:
		//
		//   Public inline functions.
		//
		//   All page descriptions contain three linked lists.
		//   These lists are all derived from a common base
		//   class.  However, this class is unable to support
		//   multiple instances in a single class a wrapper
		//   has been created for each list to make it work
		//   as required.
		//
        NEW_PAGE_LIST( VOID )
			{ /* void */ };

		INLINE VOID DeleteFromNewPageList( LIST *HeadOfList )
			{ NewPageList.Delete( HeadOfList ); }

		INLINE BOOLEAN EndOfNewPageList( VOID )
			{ return (this == NULL); }

		STATIC INLINE PAGE *FirstInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> First()) ); }

		INLINE VOID InsertInNewPageList( LIST *HeadOfList )
			{ NewPageList.Insert( HeadOfList ); }

		STATIC INLINE PAGE *LastInNewPageList( LIST *HeadOfList )
			{ return ComputePageAddress( ((CHAR*) HeadOfList -> Last()) ); }

		INLINE PAGE *NextInNewPageList( VOID )
			{ return ComputePageAddress( ((CHAR*) NewPageList.Next()) ); }

        ~NEW_PAGE_LIST( VOID )
			{ /* void */ };

	private:
		//
		//   Private functions.
		//
		//   Compute the actual start address of the page
		//   and return it to allow the linked list to
		//   be correctly walked.
		//
		STATIC INLINE PAGE *ComputePageAddress( CHAR *Address )
			{
			if ( Address != NULL )
				{ return ((PAGE*) (Address - sizeof(FIND_LIST))); }
			else
				{ return ((PAGE*) NULL); }
			}

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE_LIST( CONST NEW_PAGE_LIST & Copy );

        VOID operator=( CONST NEW_PAGE_LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\newpage.hpp ===
#ifndef _NEW_PAGE_HPP_
#define _NEW_PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Page.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here relate to various failure          */
    /*   conditions or situations where information is unknown.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 NoSizeKey				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Create and delete pages.                                       */
    /*                                                                  */
    /*   We would normally expect a class to manage its own memory.     */
    /*   However, this is quite difficult for the 'PAGE' class as it    */
    /*   is also responsible for managing the memory for the memory     */
    /*   allocator.  So here we remove a potentially nasty chore        */
    /*   and isolate it in a class of its own.                          */
    /*                                                                  */
    /********************************************************************/

class NEW_PAGE : public ENVIRONMENT, public COMMON
    {
		//
		//   Private structures.
		//
		//   All the pages descriptions created by this
		//   class and managed by the memory allocator
		//   are linked in three list.  One of these lists
		//   is managed by this class and is called the
		//   'NewPageList'.  All pages are linked into 
		//   of three sub-lists.  The 'ExternalList' is
		//   a list of pages externally allocated pages.
		//   The 'FullList' is a list of sub-allocated
		//   space from the 'ExternalList' which is 
		//   partially or completely filled with alocations.
		//   Finally, the 'FreeList' is a collection of
		//   empty page descriptions all of the same size.
		//   
		//
		typedef struct
			{
			SBIT32                    Elements;
			LIST					  ExternalList;
			LIST					  FreeList;
			LIST					  FullList;
			SBIT32                    Size;
			}
		NEW_PAGES;
		
		//
		//   Private data.
		//
		//   We manage a collection of data structures in
		//   this class.  The fundamental data structure
		//   is a stack of externally allocated pages that
		//   typically contain page descriptions that are
		//   linked together into linked lists.  The maximum
		//   size of this stack is given by 'MaxStack'. 
		//   A few additional pages are consumed to allocate
		//   stacks for caches in other classes.
		//
		SBIT32						  MaxCacheStack;
		SBIT32						  MaxNewPages;
		SBIT32						  MaxStack;

		//
		//   We keep track of various values to save having
		//   to recompute them.  The 'NaturalSize' is the 
		//   natural allocation size of our host (i.e. the OS).
		//   The 'RootSize' is some multiple of the 
		//   'NaturalSize' that this class uses to consume 
		//   memory.  The 'ThreadSafe' flag indicates whether
		//   we need to use locks.  The "TopOfStack' is the
		//   stack which contains pointers to the externally
		//   allocated space.  The 'Version' is the global
		//   version number that is used to stamp each page
		//   whenever it is allocated or deallocated.  The
		//   version number allows the code to ensure that
		//   a page description has not been changed while
		//   it was not holding the associated lock.
		//   
		SBIT32						  NaturalSize;
		SBIT32						  RootCoreSize;
		SBIT32						  RootStackSize;
		BOOLEAN						  ThreadSafe;
		SBIT32						  TopOfStack;
		SBIT32						  Version;

		//
		//   We keep pointers to all the interesting data
		//   structures we may need to update.  The
		//   'CacheStack' points to block of memory that
		//   is being sliced into small stacks for caches
		//   in other classes.  The 'NewPages' points to
		//   an array of linked lists of page descriptions.
		//   Each collection of page descriptions is 
		//   identical except for the size of the assocated
		//   bit vector.
		//
		CHAR						  *CacheStack;
 		NEW_PAGES					  *NewPages;
		VOID                          **Stack;

		//
		//   We sometimes need to interact with some of
		//   the other class.  The 'Find" class is a hash
		//   table of all the currently allocated pages.
		//   The 'Rockall' class contains the external
		//   API which includes the external memory memory
		//   allocation functions.  The 'TopCache' is the
		//   largest cache we support and contains details
		//   about top level allocations sizes.
		//
		FIND						  *Find;
		ROCKALL						  *Rockall;
		CACHE						  *TopCache;

		SPINLOCK                      Spinlock;

   public:
		//
		//   Public functions.
		//
		//   The public functions provide support for creating
		//   new page descriptions and caches for other 
		//   classes.  Although a lot of the fuinctionality
		//   of the heap is masked from this class various
		//   features such as deleting the entire heap
		//   (i.e. 'DeleteAll') are still visable.
		//
        NEW_PAGE
			(
			FIND					  *NewFind,
			SBIT32					  NewPageSizes[],
			ROCKALL					  *NewRockall,
			SBIT32					  Size,
			BOOLEAN					  NewThreadSafe 
			);

		PAGE *CreatePage( CACHE *Cache,SBIT32 NewSize = NoSize );

		VOID DeleteAll( BOOLEAN Recycle );

		VOID DeletePage( PAGE *Page );

		SBIT16 FindSizeKey( SBIT16 NumberOfElements );

		VOID *NewCacheStack( SBIT32 Size  );

		VOID ResizeStack( VOID );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~NEW_PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The public inline functions are typically either
		//   small or highly performance sensitive.  The
		//   functions here mainly relate to locking and
		//   updating various data structures.
		//
		INLINE VOID ClaimNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ClaimLock(); } 
			}

		INLINE VOID ReleaseNewPageLock( VOID )
			{
			if ( (ThreadSafe) && (Find -> GetLockCount() == 0) )
				{ Spinlock.ReleaseLock(); } 
			}

		INLINE VOID UpdateNewPage( CACHE *NewTopCache )
			{ TopCache = NewTopCache; }

	private:
		//
		//   Private functions.
		//
		//   We support the overloading of the external
		//   memory allocation routines.  This is somewhat
		//   unusual and means that we need to verify
		//   that these functions do not supply us with
		//   total rubbish.
		//
		VOID *VerifyNewArea( SBIT32 AlignMask,SBIT32 Size );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        NEW_PAGE( CONST NEW_PAGE & Copy );

        VOID operator=( CONST NEW_PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\page.hpp ===
#ifndef _PAGE_HPP_
#define _PAGE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "NewPageList.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control the number of bits in      */
    /*   a page descriptions bit vector and its minimum size.           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxBitsPerWord			  = (sizeof(BIT32) * 8);
CONST SBIT32 MinVectorSize			  = 1;
CONST SBIT32 OverheadBits			  = 2;
CONST SBIT32 OverheadBitsPerWord	  = (MaxBitsPerWord / OverheadBits);

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   The page descriptions supported by this class are at the       */
    /*   heart of the memory allocator.  These pages are linked in      */
    /*   various ways so they can be quickly found.  The following      */
    /*   structure contains the results of a search for a specific      */
    /*   memory address and its related page information.               */
    /*                                                                  */
    /********************************************************************/

typedef struct
	{
	VOID							  *Address;
	CACHE							  *Cache;
	BOOLEAN							  Found;
	PAGE							  *Page;

	BIT32							  AllocationMask;
	BIT32							  SubDivisionMask;
	BIT32							  *VectorWord;

	SBIT32							  ArrayOffset;
	SBIT32							  VectorOffset;
	SBIT32							  WordShift;
	}
SEARCH_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   The page allocation mechanism.                                 */
    /*                                                                  */
    /*   The memory manager allocates storage in large chunks from      */
    /*   the external memory allocator.  It then sub-divides these      */
    /*   chunks into various sized pages and keeps track of these       */
    /*   allocations using a bit vector in each page description.       */
    /*                                                                  */
    /********************************************************************/

class PAGE : public NEW_PAGE_LIST
    {
		//
		//   Private data.
		//
		//   The page description contains various details
		//   about the page.  The 'Address' is the starting 
		//   address of the allocation page.  The 'PageSize'
		//   is typically empty but contains a value is the 
		//   page size is weird and not realted to the
		//   assocated bucket.  The 'Version' is a unique
		//   version number and is changed everytime a new
		//   page description is created or deleted.  This
		//   version number allows a thread to see if anyone
		//   has been significantly playing with a page  
		//   description since it last held the associated lock.
		//
		CHAR                          *Address;
		SBIT32						  PageSize;
		SBIT32						  Version;

		//
		//   We keep track of the number of elements that
		//   are currently 'Allocated' and 'Available' on
		//   the page.  Additionally, 'FirstFree' is the
		//   index of the first word in the bit vector that
		//   has at least one available slot.
		//
		SBIT16                        Allocated;
		SBIT16                        Available;
		SBIT16						  FirstFree;

		//
		//   We sometimes need to interact with other classes.
		//   The 'Cache' class typically owns a number of pages
		//   and keeps all the information about this size of
		//   allocation.  The 'ParentPage' is a pointer to 
		//   another cache from where this page was sub-allocated
		//   and where the space will need to be returned when
		//   it becomes free.
		//
		CACHE						  *Cache;
		CACHE						  *ParentPage;

		//
		//   The 'Vector' is the variable sized bit vector that
		//   contains allocation information.  Each allocation
		//   is recorded using 2 bits.  The first bit indicates
		//   whether the allocation is in use and the second bit
		//   indicates whether an active allocation has been 
		//   sub-divided into smaller chunks.  Any unused bits
		//   at the end of the final word are set to zero, assumed
		//   to be zero and should never be non-zero.
		//
		BIT32                         Vector[MinVectorSize];

   public:
		//
		//   Public functions.
		//
		//   The page description contains all the information
		//   relating to an allocation.  There is no information
		//   stored with the allocation itself.  A significant
		//   portion of the external API can find its way to
		//   this class if the many layers of caches fail to
		//   deal with the request first.
		//
        PAGE
			( 
			VOID					  *NewAddress,
			CACHE					  *NewCache,
			SBIT32					  NewPageSize,
			CACHE					  *NewParentPage,
			SBIT32					  NewVersion 
			);

		SBIT32 ActualSize( VOID );

		BOOLEAN Delete( SEARCH_PAGE *Details );

		VOID DeleteAll( VOID );

		PAGE *FindPage
			( 
			VOID					  *Address,
			SEARCH_PAGE				  *Details,
			BOOLEAN					  Recursive 
			);

		BOOLEAN MultipleNew
			( 
			SBIT32					  *Available, 
			VOID					  *Array[],
			SBIT32					  Requested
			);

		VOID *New( BOOLEAN SubDivided );

		BOOLEAN Walk( SEARCH_PAGE *Details );

        ~PAGE( VOID );

		//
		//   Public inline functions.
		//
		//   The page class is so central to the entire memory
		//   allocator that a number of other classes need to
		//   get at certain data from time to time.  Thus, it 
		//   is necessary for both brevity and performance to
		//   provide inline function for certain critical 
		//   information relating to a page.
		//
		INLINE BOOLEAN Empty( VOID )
			{ return (Allocated <= 0); }

		INLINE BOOLEAN Full( VOID )
			{ return (Available <= 0); }

		INLINE VOID *GetAddress( VOID )
			{ return ((VOID*) Address); }

		INLINE CACHE *GetCache( VOID )
			{ return Cache; }

		INLINE SBIT32 GetPageSize( VOID )
			{ return PageSize; }

		INLINE CACHE *GetParentPage( VOID )
			{ return ParentPage; }

		INLINE SBIT32 GetVersion( VOID )
			{ return Version; }

		INLINE BOOLEAN ValidPage( VOID )
			{ return ((BOOLEAN) ~(Version & 0x1)); }

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        PAGE( CONST PAGE & Copy );

        VOID operator=( CONST PAGE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\heap\page.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "HeapPCH.hpp"

#include "Cache.hpp"
#include "Heap.hpp"
#include "NewPage.hpp"
#include "Page.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here allow the allocation bit vector    */
    /*   to be rapidly searched for free storage.                       */
    /*                                                                  */
    /********************************************************************/

CONST BIT32 AllocatedMask			  = 0x2;
CONST BIT32 FullSearchMask			  = 0xaaaaaaaa;
CONST BIT32 FullWordShift			  = (MaxBitsPerWord - OverheadBits);
CONST BIT32 SubDividedMask			  = 0x1;
CONST BIT32 WordSearchMask			  = (AllocatedMask << FullWordShift);

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*                                                                  */
    /*   All page descriptions are actually created and deleted by      */
    /*   a separate class called 'NEW_PAGE'.  Nonetheless, as a         */
    /*   step the appropriate constructors and destructors are          */
    /*   invoked to support the standard C++ programming methodology.   */
    /*                                                                  */
    /********************************************************************/

PAGE::PAGE
		( 
		VOID						  *NewAddress,
		CACHE						  *NewCache,
		SBIT32						  NewPageSize, 
		CACHE						  *NewParentPage,
		SBIT32						  NewVersion 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER SBIT16 NumberOfElements = (NewCache -> GetNumberOfElements());
	REGISTER SBIT16 SizeOfElements = (NewCache -> GetSizeOfElements());

	//
	//   Create a page description.
	//
	Address = (CHAR*) NewAddress;
	PageSize = NewPageSize;
	Version = NewVersion;

	Allocated = 0;
	Available = NumberOfElements;
	FirstFree = 0;

	//
	//   Set up the pointers to related classes.
	//
	Cache = NewCache;
	ParentPage = NewParentPage;

	//
	//   Zero the bit vector.
	//
	for ( Count=0;Count < SizeOfElements;Count ++ )
		{ Vector[ Count ] = 0; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the actual size.                                       */
    /*                                                                  */
    /*   Almost all allocation sizes are derived from the associated    */
    /*   caches.  However, there are a few special pages that contain   */
    /*   a single allocation of some weird size.                        */
    /*                                                                  */
    /********************************************************************/

SBIT32 PAGE::ActualSize( VOID )
	{
	return
		(
		(ParentPage == ((CACHE*) GlobalRoot))
			? PageSize
			: (Cache -> GetAllocationSize())
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete an allocation.                                          */
    /*                                                                  */
    /*   We need to delete the memory allocation described by the       */
    /*   parameters.  However, as we are of an untrusting nature        */
    /*   we carefully check the request to ensure it is valid.          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Delete( SEARCH_PAGE *Details )
    {
	//
	//   We know that no one would deallocate memory
	//   they had not previously allocated (yea - right).
	//   So here we check for this case.
	//
	if ( (*Details -> VectorWord) & Details -> AllocationMask )
		{
		//
		//   Nasty: it is possible for the user to give us an
		//   address that points to the middle of the element
		//   to be freed instead of the beginning.  This is no
		//   problem for us but we have to ponder whether the
		//   caller knew what they were doing.  If this is the 
		//   case we fail the request.
		//
		if ( Details -> Found )
			{
			//
			//   We have found that the element is allocated
			//   (as one might expect) so lets deallocate it 
			//   and update the various counters.
			//
			(*Details -> VectorWord) &= 
				~(Details -> AllocationMask | Details ->SubDivisionMask);

			//
			//   We may need to push back the pointer to the 
			//   first free element.  This will ensure that
			//   we can quickly locate the freed element for  
			//   later so we can reuse it.
			//
			if ( FirstFree > Details -> VectorOffset )
				{ FirstFree = ((SBIT16) Details -> VectorOffset); }

			//
			//   If the page was full and now has an empty
			//   slot then add it to the bucket list so that
			//   the free space can be found.
			//
			if ( Full() )
				{ Cache -> InsertInBucketList( this ); }

			//
			//   Update the allocation information.
			//
			Allocated --;
			Available ++;

			//
			//   If the page is now empty then delete 
			//   the page to conserve space.
			//
			if ( Empty() ) 
				{
				//
				//   We immediately delete empty pages
				//   except at the top level where it is
				//   under user control.
				//
				if ( ! Cache -> TopCache() )
					{ Cache -> DeletePage( this ); }
				else
					{
					REGISTER SBIT32 MaxFreePages = 
						(Cache -> GetHeap() -> GetMaxFreePages());

					((BUCKET*) Cache) -> ReleaseSpace( MaxFreePages );
					}
				}

			return True;
			}
		}

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete all simple allocations.                                 */
    /*                                                                  */
    /*   Although this routine may seem insignificant its effects are   */
    /*   dramatic.  When called this function deletes all the none      */
    /*   sub-allocated elements and updates the control values.         */
    /*                                                                  */
    /********************************************************************/

VOID PAGE::DeleteAll( VOID )
    {
	REGISTER BOOLEAN PageFull = Full();

	//
	//   Simply reset the allocation counts.
	//
	Allocated = 0;
	Available = (Cache -> GetNumberOfElements());
	FirstFree = 0;

	//
	//   We know that if this cache does not have any
	//   child allocations that it is safe to simply
	//   zero the bit vector.  If not we have to do it
	//   the long way.
	//
	if ( Cache -> GetNumberOfChildren() > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   We examine each word of the bit vector 
		//   and delete all the elements that are
		//   not sub-divided into smaller sizes.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{
			REGISTER BIT32 *Word = & Vector[ Count ];
			REGISTER BIT32 AllAllocations = ((*Word) & FullSearchMask);
			REGISTER BIT32 AllSubDivided = ((*Word) & (AllAllocations >> 1));
			REGISTER BIT32 FinalMask = (AllSubDivided | (AllSubDivided << 1));

			//
			//   Delete all normal allocations.
			//
			(*Word) &= FinalMask;

			//
			//   If the final mask is not zero then
			//   we still have some allocations active.
			//   We need to count these and update the
			//   control information.
			//
			if ( FinalMask != 0 )
				{
				REGISTER SBIT32 Total = 0;

				//
				//   Count the allocations.
				//
				for ( /* void */;FinalMask != 0;FinalMask >>= OverheadBits )
					{ Total += (FinalMask & 1); }

				//
				//   Update the control information.
				//
				Allocated = ((SBIT16) (Allocated + Total));
				Available = ((SBIT16) (Available - Total));
				}
			}
		}
	else
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Zero the bit vector.
		//
		for ( Count=0;Count < SizeOfElements;Count ++ )
			{ Vector[ Count ] = 0; }
		}

	//
	//   If the page was full and now has empty
	//   slots then add it to the bucket list so 
	//   that the free space can be found.
	//
	if ( (PageFull) && (! Full()) )
		{ Cache -> InsertInBucketList( this ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find an allocation page.                                       */
    /*                                                                  */
    /*   When we receive a request to delete an allocation we don't     */
    /*   have a clue about where to find it.  All we have is a hash     */
    /*   table (see 'FIND') of allocated pages.  So we mask off the     */
    /*   low order bits of the address and try to find the top level    */
    /*   external allocation.  If this works we see if the area we      */
    /*   are looking at has been sub-divided and if so we try the       */
    /*   same trick again until we get the the origibal allocation      */
    /*   page.                                                          */
    /*                                                                  */
    /********************************************************************/

PAGE *PAGE::FindPage( VOID *Memory,SEARCH_PAGE *Details,BOOLEAN Recursive )
    {
	//
	//   We navigate through the pages trying to find
	//   the allocation page associated with the address.
	//   If we find a page that has no children then 
	//   we can assume we have arrived and exit early 
	//   unless the caller has requested all the realated 
	//   details.
	//
	if ( (Cache -> GetNumberOfChildren() > 0) || (Details != NULL) )
		{
		AUTO BOOLEAN Found;
		REGISTER SBIT32 Displacement = 
			((SBIT32) (((CHAR*) Memory) - Address));
		REGISTER SBIT32 ArrayOffset = 
			(Cache -> ComputeOffset( Displacement,& Found ));
		REGISTER SBIT32 VectorOffset = 
			(ArrayOffset / OverheadBitsPerWord);
		REGISTER SBIT32 WordOffset = 
			(ArrayOffset - (VectorOffset * OverheadBitsPerWord));
		REGISTER SBIT32 WordShift = 
			(((OverheadBitsPerWord-1) - WordOffset) * OverheadBits);
		REGISTER BIT32 AllocationMask = 
			(AllocatedMask << WordShift);
		REGISTER BIT32 SubDivisionMask = 
			(SubDividedMask << WordShift);
		REGISTER BIT32 *VectorWord = 
			& Vector[ VectorOffset ];

		//
		//  We will recursively search and find the target 
		//  address if requested otherwise we will just 
		//  return the details of the next level in the tree.
		//
		if 
				(
				(Recursive)
					&&
				((*VectorWord) & AllocationMask)
					&&
				((*VectorWord) & SubDivisionMask)
				)
			{
			REGISTER PAGE *Page = (Cache -> FindChildPage( Memory ));

			//
			//   We have found the element and checked it. 
			//   So lets pass this request on to the
			//   child page.  However, there is a slight
			//   chance of a race condition here.  It
			//   might be that the original page was
			//   deleted and a new page is currently
			//   being created.  If this is the case
			//   then we will not find the page in the 
			//   hash table so we just exit and fail the 
			//   call.
			//
			if ( Page != ((PAGE*) NULL) )
				{ return (Page -> FindPage( Memory,Details,Recursive )); }
			else
				{ return NULL; }
			}

		//
		//   We see if the caller is interested in the
		//   details relating to this address at the
		//   current level in the tree.
		//
		if ( Details != NULL )
			{
			//
			//   We have computed the details relating
			//   to this address at the current level
			//   in the tree so load them into the
			//   caller supplied structure.
			//
			Details -> Address = Memory;
			Details -> Cache = Cache;
			Details -> Found = Found;
			Details -> Page = this;

			Details -> AllocationMask = AllocationMask;
			Details -> SubDivisionMask = SubDivisionMask;
			Details -> VectorWord = VectorWord;

			Details -> ArrayOffset = ArrayOffset;
			Details -> VectorOffset = VectorOffset;
			Details -> WordShift = WordShift;
			}
		}

	return this;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate available memeory elements from a page.  This is      */
    /*   done by scanning the bit vector looking for unallocated        */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::MultipleNew( SBIT32 *Actual,VOID *Array[],SBIT32 Requested )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate and that we need to
	//   allocated at least one element.
	//
	if ( (! Full()) && ((*Actual) < Requested) )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slots.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER SBIT32 ArrayOffset = (FirstFree * OverheadBitsPerWord);
			REGISTER BIT32 AvailableMask = WordSearchMask;
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];
			REGISTER SBIT32 WordOffset = 0;

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			while ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 Value = (*VectorWord);

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = (ArrayOffset + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bits indicating that this
						//   element is in use.
						//
						(*VectorWord) |= AvailableMask;

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Add the element to the allocation array
						//   so it can be returned to the caller.
						//
						Array[ (Requested - ((*Actual) ++) - 1) ] =
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);

						//
						//   When we have got what we need we exit.
						//
						if ( ((*Actual) >= Requested) )
							{ return True; }
						}
					else
						{ break; }
					}
				else
					{ Failure( "Bit vector is corrupt in MultipleNew" ); }
				}
			}
		}

	return ((*Actual) >= Requested);
    }

    /********************************************************************/
    /*                                                                  */
    /*   A single memory allocation.                                    */
    /*                                                                  */
    /*   Allocate an available memeory element from the page.  This     */
    /*   is done by scanning the bit vector looking for unallocated     */
    /*   slots.                                                         */
    /*                                                                  */
    /********************************************************************/

VOID *PAGE::New( BOOLEAN SubDivided )
    {
	//
	//   We begin by making sure that there is at least
	//   one element to allocate.
	//
	if ( ! Full() )
		{
		REGISTER SBIT16 SizeOfElements = (Cache -> GetSizeOfElements());

		//
		//   Search the bit vector from low addresses to 
		//   high addresses looking for a free slot.
		//   We keep a pointer to the first word with
		//   a free element in 'FirstFree'.  Sometimes
		//   the current word may be fully allocated so 
		//   we might need to scan.  However, there can
		//   never be any free memory before this point 
		//   in the bit vector.
		//
		for ( /* void */;FirstFree < SizeOfElements;FirstFree ++ )
			{
			REGISTER BIT32 *VectorWord = & Vector[ FirstFree ];

			//
			//   We scan the bit vector word at a time 
			//   looking for any free allocation slots.
			//
			if ( ((*VectorWord) & FullSearchMask) != FullSearchMask )
				{
				REGISTER BIT32 AvailableMask = WordSearchMask;
				REGISTER BIT32 Value = (*VectorWord);
				REGISTER SBIT32 WordOffset = 0;

				//
				//   We know there is an at least one empty  
				//   slot availabale in the current word but  
				//   don't know which one We search for the
				//   slot with the lowest address and stop
				//   when we find it.
				//
				for 
					(
					/* void */;
					(AvailableMask & Value) != 0; 
					AvailableMask >>= OverheadBits, WordOffset ++   
					);

				//
				//   We should never fail to find a free 
				//   allocation slot so if we do then the 
				//   heap must be corrupt.
				//
				if ( WordOffset < OverheadBitsPerWord )
					{
					REGISTER SBIT32 VectorOffset = 
						((FirstFree * OverheadBitsPerWord) + WordOffset);

					//
					//   We need to ensure that the element 
					//   we have chosen if not outside the 
					//   valid range for this page.
					//
					if ( VectorOffset < (Cache -> GetNumberOfElements()) )
						{
						//
						//   Update the allocation information.
						//
						Allocated ++;
						Available --;

						//
						//   Turn on the bit indicating that this
						//   element is in use.  If the allocation 
						//   is to be sub-divided then trun on this
						//   bit as well.
						//
						(*VectorWord) |=
							(
							AvailableMask
								|
							(SubDivided ? (AvailableMask >> 1) : 0)
							);

						//
						//   If the page is full we remove it
						//   from the bucket list so we will no
						//   longer look at it when we are 
						//   trying to find free space.
						//
						if ( Full() )
							{ Cache -> DeleteFromBucketList( this ); }

						//
						//   Return the address of the allocated 
						//   memory to the caller.
						//
						return
							(
							Cache -> ComputeAddress
								( 
								Address,
								VectorOffset
								)
							);
						}
					}
				else
					{ Failure( "Bit vector is corrupt in New" ); }
				}
			}
#ifdef DEBUGGING

		if ( ! Full() )
			{ Failure( "Available count corrupt in New" ); }
#endif
		}

	return ((VOID*) AllocationFailure);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

BOOLEAN PAGE::Walk( SEARCH_PAGE *Details )
    {
	REGISTER BOOLEAN FreshPage = False;

	//
	//   We have been handed the details of an allocation.
	//   We need to walk along this allocation and find
	//   the next non-subdivided allocation.
	do
		{
		//
		//   We need to setup the heap walk if the address
		//   is null so we skip the heap walk code.
		//
		if ( Details -> Address != NULL )
			{
			REGISTER SBIT32 Count;
			REGISTER SBIT32 End = Details -> Cache -> GetNumberOfElements();
			REGISTER SBIT32 Start = Details -> ArrayOffset;
			REGISTER PAGE *Page = Details -> Page;

			//
			//   Walk the current page looking for a suitable
			//   memory allocation to report to the user.  When
			//   we reach the end of the page we need to get
			//   another page to walk.
			//
			for 
					(
					Count = ((FreshPage) ? 0 : 1);
					(Start + Count) < End;
					Count ++
					)
				{
				//
				//   Compute the new address.
				//
				Details -> Address = 
					(
					Page -> Cache -> ComputeAddress
						( 
						Page -> Address,
						(Start + Count)
						)
					);

				//
				//   Compute the new allocation details.
				//
				Page -> FindPage
					( 
					Details -> Address,
					Details,
					False 
					);

				//
				//   We skip all sub-divided allocations as they 
				//   will get reported elsewhere.
				//
				if (! ((*Details -> VectorWord) & Details -> SubDivisionMask) )
					{ return True; }
				}
			}

		//
		//   Update the flag to show that we have
		//   had to go and get a new page.
		//
		FreshPage = True;
		}
	while ( Details -> Cache -> Walk( Details ) );

	return False;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current page structure.                            */
    /*                                                                  */
    /********************************************************************/

PAGE::~PAGE( VOID )
	{
#ifdef DEBUGGING
	//
	//   Destroy the page structure.
	//
	Address = NULL;
	PageSize = 0;
	ParentPage = NULL;

	Allocated = 0;
	Available = 0;
	FirstFree = 0;

#endif
	//
	//   We update the version number whenever a page is created
	//   or destroyed.  We use the version number to ensure that
	//   a page has not been deleteed and/or recreated between
	//   releasing one lock and claiming a another other lock.
	//
	Version ++;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\defaultheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   Create a single static instance of the default heap so         */
    /*   that is available as soon as the DLL has finished loading.     */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
DEFAULT_HEAP DefaultHeap( 4194304,true,true,true );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\defaultheap.hpp ===
#ifndef _DEFAULT_HEAP_HPP_
#define _DEFAULT_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#ifdef _DEBUG
#include "DebugHeap.hpp"
typedef DEBUG_HEAP DEFAULT_HEAP;
#else
#include "FastHeap.hpp"
typedef FAST_HEAP DEFAULT_HEAP;
#endif
#ifndef NO_DEFAULT_HEAP

    /********************************************************************/
    /*                                                                  */
    /*   Default heap.                                                  */
    /*                                                                  */
    /*   The default heap is available for everyone as soon as the      */
    /*   memory allocator DLL has loaded.                               */
    /*                                                                  */
    /********************************************************************/

extern ROCKALL_DLL_LINKAGE DEFAULT_HEAP DefaultHeap;
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\blendedheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "BlendedHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 4096;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 2048;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,       64,       32,      512 },
		{        8,       32,       32,      512 },
		{       12,       32,       64,      512 },
		{       16,       16,       64,      512 },
		{       20,       16,       64,      512 },
		{       24,       12,       96,      512 },

		{       32,       12,      128,      512 },
		{       40,        8,      128,      512 },
		{       48,        8,      256,      512 },

		{       64,        8,      256,      512 },
		{       80,        4,      512,      512 },
		{       96,        4,      512,      512 },

		{      128,        4,     4096,     4096 },
		{      160,        4,     4096,     4096 },
		{      192,        4,     4096,     4096 },
		{      224,        4,     4096,     4096 },

		{      256,        4,     4096,     4096 },
		{      320,        2,     4096,     4096 },
		{      384,        2,     4096,     4096 },
		{      448,        2,     4096,     4096 },
		{      512,        2,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        2,     4096,     4096 },
		{     2048,        2,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,    65536,    65536 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::BLENDED_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

BLENDED_HEAP::~BLENDED_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\debugheap.hpp ===
#ifndef _DEBUG_HEAP_HPP_
#define _DEBUG_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The debug memory allocator.                                    */
    /*                                                                  */
    /*   The debug memory allocator checks all the memory allocation    */
    /*   calls to make sure they are reasonable.  If not then it        */
    /*   raises an execption at the point it detects a problem.         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE DEBUG_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		//   A debug heap places a collection of guard words
		//   before and after each allocation.  It checks
		//   these guard words everytime the allocation is
		//   examined or modified.
		//
		typedef struct
			{
			int						  Size;
			int						  StartGuard;
			}
		DEBUG_HEADER;

		typedef struct
			{
			char					  MidGuard[ sizeof(int) ];
			int						  EndGuard[1];
			}
		DEBUG_TRAILER;

		typedef struct
			{
			DEBUG_HEADER			  DebugHeader;
			DEBUG_TRAILER			  DebugTrailer;
			}
		DEBUG_GUARD;

    public:
        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
        DEBUG_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = 1,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void HeapLeaks( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~DEBUG_HEAP( void );

	private:
		//
		//   Private functions.
		//
		//   A debug heap verifies each allocation using a 
		//   collection of private functions.
		//
		DEBUG_HEADER *ComputeHeaderAddress( void *Address )
			{
			register int HeaderSize = sizeof(DEBUG_HEADER);

			return ((DEBUG_HEADER*) (((char*) Address) - HeaderSize)); 
			}

		void *ComputeDataAddress( DEBUG_HEADER *Header )
			{ return ((void*) & Header[1]); }

		void ResetGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

		void TestGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize );

		void UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize );

        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        DEBUG_HEAP( const DEBUG_HEAP & Copy );

        void operator=( const DEBUG_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\fastheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "FastHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 8192;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,      256,       32,     4096 },
		{        8,      128,       32,     4096 },
		{       12,      128,       64,     4096 },
		{       16,      128,       64,     4096 },
		{       20,       64,       64,     4096 },
		{       24,       64,       96,     4096 },

		{       32,       64,      128,     4096 },
		{       40,       64,      128,     4096 },
		{       48,       64,      256,     4096 },

		{       64,       64,      256,     4096 },
		{       80,       64,      512,     4096 },
		{       96,       64,      512,     4096 },

		{      128,       32,     4096,     4096 },
		{      160,       16,     4096,     4096 },
		{      192,       16,     4096,     4096 },
		{      224,       16,     4096,     4096 },

		{      256,       16,     4096,     4096 },
		{      320,        8,     4096,     4096 },
		{      384,        8,     4096,     4096 },
		{      448,        8,     4096,     4096 },
		{      512,        4,     4096,     4096 },
		{      576,        4,     4096,     4096 },
		{      640,        4,     8192,     8192 },
		{      704,        4,     4096,     4096 },
		{      768,        4,     4096,     4096 },
		{      832,        4,     8192,     8192 },
		{      896,        4,     8192,     8192 },
		{      960,        4,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::FAST_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

FAST_HEAP::~FAST_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\blendedheap.hpp ===
#ifndef _BLENDED_HEAP_HPP_
#define _BLENDED_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A blended heap.                                                */
    /*                                                                  */
    /*   A blended heap tries to provide good performance and           */
    /*   thoughtfull memory layout for a modest cost in terms of        */
    /*   additional memory usage.                                       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE BLENDED_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        BLENDED_HEAP
			( 
			int						  MaxFreeSpace = 1048576,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~BLENDED_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
		//
        BLENDED_HEAP( const BLENDED_HEAP & Copy );

        void operator=( const BLENDED_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\debugheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DebugHeap.hpp"
#include "Heap.hpp"

void Failure( char* a);

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.  Additionally,     */
    /*   there are also various guard related constants.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

CONST int GuardMask					  = (sizeof(int)-1);
CONST int GuardSize					  = sizeof(int);

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::DEBUG_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	//
	//   We make much use of the guard value in the
	//   debug heap so here we try to claim the 
	//   address but not commit it so we will cause
	//   an access violation if the program ever
	//   tries to access it.
	//
	VirtualAlloc
		( 
		((void*) GuardValue),
		GuardSize,
		MEM_RESERVE,
		PAGE_NOACCESS 
		);

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap initialization failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   We make sure the memory is allocated and that the guard        */
    /*   words have not been damanged.  If so we reset the contents     */
    /*   of the allocation and delete the allocation.                   */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Delete( void *Address,int Size )
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to delete
	//   a null pointer.  This is really a very poor  
	//   style but we support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
			{
			REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Delete the allocation.  This really ought 
			//   to work given we have already checked that 
			//   the allocation is valid unless there is a  
			//   race condition.
			//
			if ( ! ROCKALL::Delete( ((void*) Header),NewSize ) )
				{ Failure( "Delete requested failed due to race" ); }

			//
			//   We ensure that the heap has not become corrupt
			//   during the deletion process.
			//
			if ( ROCKALL::Corrupt() ) 
				{ Failure( "Delete failed to complete" ); }
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::DeleteAll( bool Recycle )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   Delete the heap and force all the allocated
	//   memory to be returned to the operating system
	//   regardless of what the user requested.  Any
	//   attempt to access the deallocated memory will 
	//   be trapped by the operating system.
	//
	ROCKALL::DeleteAll( (Recycle && false) );

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "DeleteAll failed to complete" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Details( void *Address,int *Space )
	{ return Verify( Address,Space ); }

    /********************************************************************/
    /*                                                                  */
    /*   Print a list of heap leaks.                                    */
    /*                                                                  */
    /*   We walk the heap and output a list of active heap              */
    /*   allocations to the debug window,                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::HeapLeaks( void )
    {
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and find all the active and
	//   available spece.  We would normally expect
	//   this to be proportional to the size of the
	//   heap.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		CONST INT DebugBufferSize = 8192;
#ifndef OUTPUT_FREE_SPACE

		//
		//   We report all active heap allocations
		//   just so the user knows there are leaks.
		//
		if ( Active )
			{
#endif
			AUTO CHAR Buffer[ DebugBufferSize ];

			//
			//   Format the string to be printed.
			//
			(void) sprintf
				(
				Buffer,
				"Memory leak \t%d \t0x%x \t%d\n",
				Active,
				(((SBIT32) Address) + sizeof(DEBUG_HEADER)),
				Space
				);

			//
			//   Force null termination.
			//
			Buffer[ (DebugBufferSize-1) ] = '\0';

			//
			//   Write the string to the debug window.
			//
			OutputDebugString( Buffer );
#ifndef OUTPUT_FREE_SPACE
			}
#endif
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   We make sure all the memory is allocated and that the guard    */
    /*   words have not been damaged.  If so we reset the contents      */
    /*   of the allocations and then delete all the allocations.        */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	REGISTER int Count;
	REGISTER int NewSize = (Size + sizeof(DEBUG_GUARD));

	//
	//   Examine each memory allocation and delete it
	//   after carefully checking it.
	//
	for ( Count=0;Count < Actual;Count ++ )
		{
		AUTO int TotalSize;
		AUTO VOID *Address = Array[ Count ];
		AUTO DEBUG_HEADER *Header =
			(
			(Address == ((void*) AllocationFailure))
				? ((DEBUG_HEADER*) Address)
				: ComputeHeaderAddress( Address )
			);

		//
		//   Ask for the details of the allocation.  This 
		//   will fail if the memory is not allocated.
		//
		if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Delete the user information by writing 
			//   guard words over the allocation.  This
			//   should cause the application to crash
			//   if the area is read and also allows us 
			//   to check to see if it is written later.
			//
			ResetGuardWords( Header,TotalSize );

			//
			//   Update the address in the array to the
			//   address originally allocated.
			//
			Array[ Count ] = ((VOID*) Header);
			}
		else
			{ Failure( "Delete requested on unallocated memory" ); }
		}

	//
	//   Delete the allocation.  This really ought 
	//   to work given we have already checked that 
	//   the allocations are valid unless there is a  
	//   race condition.
	//
	if ( ! ROCKALL::MultipleDelete( Actual,Array,NewSize ) )
		{ Failure( "Delete requested failed due to race" ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the deletion process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "MultipleDelete failed to complete" ); }

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Allocate a collection of memory elements and setup the         */
    /*   guard information so we can check they have not been           */
    /*   damaged later.                                                 */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	REGISTER bool Result = false;

	//
	//   The requested number of elements and the size  
	//   must be greater than zero.  We require the 
	//   caller to allocate a positive amount of memory.
	//
	if ( (Requested > 0) && (Size >= 0) )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Result = 
			(
			ROCKALL::MultipleNew
				( 
				Actual,
				Array,
				Requested,
				NewSize,
				& TotalSize 
				)
			);

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( (*Actual) > 0 )
			{
			REGISTER int Count;

			//
			//   If the real size is requested then return 
			//   it to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			for ( Count=0;Count < (*Actual);Count ++ )
				{ 
				REGISTER void **Current = & Array[ Count ];

				//
				//   Set up the guard words and ensure
				//   the allocation has not been written
				//   since being freed.
				//
				SetGuardWords
					( 
					((DEBUG_HEADER*) (*Current)),
					((Space == NULL) ? Size : (*Space)), 
					TotalSize
					);

				//
				//   Compute the external address and place
				//   it back in the array.
				//
				(*Current) = ComputeDataAddress( ((DEBUG_HEADER*) (*Current)) );

				//
				//   Zero the memory if the needed.
				//
				if ( Zero )
					{ 
					ZeroMemory
						( 
						(*Current),
						((Space == NULL) ? Size : (*Space)) 
						); 
					}
				}
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "Multiple new failed to complete" ); }
		}
	else
		{ Failure( "Allocation size must greater than zero" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We add some space on to the original allocation size for       */
    /*   various information and then call the allocator.  We then      */
    /*   set the guard words so we can check for overruns.              */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::New( int Size,int *Space,bool Zero )
    {
	REGISTER void *Address = ((void*) AllocationFailure);

	//
	//   The size must be greater than or equal to zero.  
	//   We do not know how to allocate a negative amount
	//   of memory.
	//
	if ( Size >= 0 )
		{
		AUTO int TotalSize;
		REGISTER int NewSize = 
			(((Size + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

		//
		//   Allocate the memory plus some additional 
		//   memory for the guard words.
		//
		Address = ROCKALL::New( NewSize,& TotalSize,false );

		//
		//   If we were able to allocate some memory then
		//   set the guard words so we can detect any
		//   corruption later.
		//
		if ( Address != ((void*) AllocationFailure) ) 
			{
			//
			//   If the real size is requested then return it
			//   to the caller.
			//
			if ( Space != NULL )
				{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

			//
			//   Set the guard words so we can see if 
			//   someone damages any allocation.  If the 
			//   caller requested the size information 
			//   then we must assume that it could be  
			//   used so we need to adjust the number 
			//   of guard words.
			//
			SetGuardWords
				( 
				((DEBUG_HEADER*) Address),
				((Space == NULL) ? Size : (*Space)), 
				TotalSize
				); 

			//
			//   Compute the external address and place
			//   it back in the variable.
			//
			Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

			//
			//   Zero the allocation if needed.
			//
			if ( Zero )
				{ 
				ZeroMemory
					( 
					Address,
					((Space == NULL) ? Size : (*Space)) 
					); 
				} 
			}

		//
		//   We ensure that the heap has not become corrupt
		//   during the allocation process.
		//
		if ( ROCKALL::Corrupt() ) 
			{ Failure( "New failed to complete" ); }
		}
	else
		{ Failure( "Allocation size can not be negative" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory area allocation.                                        */
    /*                                                                  */
    /*   We need to allocate some new memory from the operating         */
    /*   system and prepare it for use in the debugging heap.           */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::NewArea( int AlignMask,int Size,bool User )
    {
	REGISTER void *Memory = ROCKALL::NewArea( AlignMask,Size,User );

	//
	//   If we managed to get a new page then write
	//   the guard value over it to allow us to
	//   verify it has not been overwritten later.
	//
	if ( Memory != ((void*) AllocationFailure) )
		{
		REGISTER int Count;

		//
		//   Write the guard value into all of the new
		//   heap page to allow it to be checked for
		//   corruption.
		//
		for ( Count=0;Count < Size;Count += GuardSize )
			{ (((int*) Memory)[ (Count / GuardSize) ]) = GuardValue; }
		}
	
	return Memory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   We need to resize an allocation.  We ensure the original       */
    /*   allocation was undamaged and then expand it.  We also          */
    /*   update the guard words to reflect the changes.                 */
    /*                                                                  */
    /********************************************************************/

void *DEBUG_HEAP::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   A well known practice is to try to resize a null
	//   pointer.  This is really a very poor style but we 
	//   support it in any case.
	//   
	if ( Header != ((void*) AllocationFailure) )
		{
		AUTO int TotalSize;

		//
		//   The new size must be greater than or equal to  
		//   zero.  We do not know how to allocate a negative 
		//   amount of memory.
		//
		if ( NewSize >= 0 )
			{
			REGISTER int Size = 
				(((NewSize + sizeof(DEBUG_GUARD)) + GuardMask) & ~GuardMask);

			//
			//   Ask for the details of the allocation.  This 
			//   will fail if the memory is not allocated.
			//
			if ( ROCKALL::Verify( ((void*) Header),& TotalSize ) )
				{
				REGISTER void *OriginalAddress = ((void*) Header);
				REGISTER int OriginalSize = TotalSize;

				//
				//   Test the guard words to make sure they have
				//   not been damaged.
				//
				TestGuardWords( Header,TotalSize );

				//
				//   Reallocate the memory plus some additional 
				//   memory for the guard words.
				//
				Address =
					(
					ROCKALL::Resize
						( 
						OriginalAddress,
						Size,
						Move,
						& TotalSize,
						true,
						false
						)
					);

				//
				//   If we were able to allocate some memory 
				//   then set the guard words so we can detect 
				//   any corruption later.
				//
				if ( Address != ((void*) AllocationFailure) )
					{
					REGISTER SBIT32 SpaceUsed = Header -> Size;

					//
					//   Delete the user information by writing 
					//   guard words over the allocation.  This
					//   should cause the application to crash
					//   if the area is read and allows us to
					//   check to see if it is written later.
					//
					if ( (! NoDelete) && (Address != OriginalAddress) )
						{
						ResetGuardWords( Header,OriginalSize );

						if ( ! ROCKALL::Delete( OriginalAddress ) )
							{ Failure( "Delete failed due to race" ); }
						}

					//
					//   If the real size is requested then 
					//   return it to the caller.
					//
					if ( Space != NULL )
						{ (*Space) = (TotalSize - sizeof(DEBUG_GUARD)); }

					//
					//   Update the guard words so we can see 
					//   if someone damages the allocation.  If
					//   the caller requested the size information 
					//   then we must assume that it could be 
					//   used so we need to adjust the guard words.
					//
					UpdateGuardWords
						( 
						((DEBUG_HEADER*) Address),
						((Space == NULL) ? NewSize : (*Space)), 
						TotalSize
						); 

					//
					//   Compute the external address and place
					//   it back in the variable.
					//
					Address = ComputeDataAddress( ((DEBUG_HEADER*) Address) );

					//
					//   Zero the memory if the needed.
					//
					if ( Zero )
						{
						REGISTER SBIT32 ActualSize = 
							((Space == NULL) ? Size : (*Space));
						REGISTER SBIT32 Difference = 
							(ActualSize - SpaceUsed);

						//
						//   If the new size is larger than 
						//   old size then zero the end of the
						//   new allocation.
						//
						if ( Difference > 0 )
							{ 
							REGISTER CHAR *Array = ((CHAR*) Address);

							ZeroMemory( & Array[ SpaceUsed ],Difference ); 
							} 
						}	
					}
				}
			else
				{ Failure( "Resize requested on unallocated memory" ); }
			}
		else
			{ Failure( "Allocation size must be positive" ); }
		}
	else
		{ Address = New( NewSize,Space,Zero ); }

	//
	//   We ensure that the heap has not become corrupt
	//   during the reallocation process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Resize failed to complete" ); }

	return Address;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the guard words.                                         */
    /*                                                                  */
    /*   We need to reset the guard words just before we delete a       */
    /*   memory allocation.                                             */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::ResetGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   Write guard words over the allocated space as
	//   the allocation is about to be freed.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ (((int*) Header)[ (Count / GuardSize) ]) = GuardValue; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Set the guard words.                                           */
    /*                                                                  */
    /*   We need to set the guard words just after an allocation so     */
    /*   we can check them later.                                       */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::SetGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize) 
				&& 
			(Size >= 0) 
			)
		{
		REGISTER int Count;

		//
		//   We know that the entire allocation should be
		//   set to the guard value so check that it has
		//   not been overwritten.
		//
		for ( Count=0;Count < TotalSize;Count += GuardSize )
			{ 
			if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
				{ Failure( "Guard words have been damaged" ); }
			}

		//
		//   Write the header information.
		//
		Header -> Size = Size;
		}
	else
		{ Failure( "Guard word area is too small or unaligned" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Test the guard words.                                          */
    /*                                                                  */
    /*   We need to test the guard words a various times to ensure      */
    /*   are still valid.                                               */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::TestGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before testing the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Header -> Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Header -> Size >= 0) 
			)
		{
		REGISTER int Count;
		REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
		REGISTER int EndIndex = ((Header -> Size + GuardMask) & ~GuardMask);
		REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
		REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
		REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

		//
		//   Test the guard word just before the allocation
		//   to see if it has been overwritten.
		//
		if ( Header -> StartGuard != GuardValue )
			{ Failure( "Leading guard word has been damaged" ); }

		//
		//   Test the guard bytes just after the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=Header -> Size;(Count & GuardMask) != 0;Count ++ )
			{
			REGISTER int ByteIndex = (Count & GuardMask);

			//
			//   Test each byte up to the next word boundary.
			//
			if 
					( 
					Trailer -> MidGuard[ ByteIndex ] 
						!= 
					((char*) & GuardValue)[ ByteIndex ]
					)
				{ Failure( "Trailing guard byte has been damaged" ); }
			}

		//
		//   Test the guard words following the allocation
		//   to see if they have been overwritten.
		//
		for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
			{ 
			if ( Trailer -> EndGuard[ (Count / GuardSize) ] != GuardValue )
				{ Failure( "Trailing guard word has been damaged" ); }
			}
		}
	else
		{ Failure( "Guard information has been damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory Trunction.                                              */
    /*                                                                  */
    /*   We truncate the heap and make sure that this does not          */
    /*   corrupt the heap in some way.                                  */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Truncate( int MaxFreeSpace )
	{
	REGISTER bool Result;

	//
	//   We truncate the heap and release all available
	//   memory regardless of what the caller requested.
	//
	Result = ROCKALL::Truncate( 0 );

	//
	//   We verify various values and ensure the heap
	//   is not corrupt.
	//
	if 
			( 
			(MaxFreeSpace < 0) 
				|| 
			(ROCKALL::Corrupt()) 
			)
		{ Failure( "Heap truncation failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unmodified guard words.                                        */
    /*                                                                  */
    /*   We need to inspect the guard words to ensure they have not     */
    /*   changed after being freed.                                     */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UnmodifiedGuardWords( DEBUG_HEADER *Header,int TotalSize )
	{
	REGISTER int Count;

	//
	//   We know that the entire allocation should be
	//   set to the guard value so check that it has
	//   not been overwritten.
	//
	for ( Count=0;Count < TotalSize;Count += GuardSize )
		{ 
		if ( (((int*) Header)[ (Count / GuardSize) ]) != GuardValue )
			{ Failure( "Guard words on unallocated memory have been damaged" ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the guard words.                                        */
    /*                                                                  */
    /*   We need to update the guard words after a resize so we can     */
    /*   check them later.                                              */
    /*                                                                  */
    /********************************************************************/

void DEBUG_HEAP::UpdateGuardWords( DEBUG_HEADER *Header,int Size,int TotalSize )
	{
	//
	//   We check that the information supplied seems
	//   to make sense before setting up the guard words.
	//
	if 
			(
			((((int) Header) & GuardMask) == 0)
				&&
			((TotalSize & GuardMask) == 0)
				&&
			((Size + ((int) sizeof(DEBUG_GUARD))) <= TotalSize)
				&&
			(Size >= 0) 
			)
		{
		//
		//   We only copy the smaller of the new size 
		//   and the old size.  So check just the
		//   correct number of guard words.
		//
		if ( Header -> Size > Size )
			{
			REGISTER int Count;
			REGISTER char *DataArea = ((char*) ComputeDataAddress( Header ));
			REGISTER int EndIndex = ((Size + GuardMask) & ~GuardMask);
			REGISTER int EndSize = (TotalSize - sizeof(DEBUG_HEADER) - GuardSize);
			REGISTER char *MidGuard = & DataArea[ (EndIndex - GuardSize) ];
			REGISTER DEBUG_TRAILER *Trailer = ((DEBUG_TRAILER*) MidGuard);

			//
			//   Update the guard bytes just after the 
			//   allocation.
			//
			for ( Count=Size;(Count & GuardMask) != 0;Count ++ )
				{
				REGISTER int ByteIndex = (Count & GuardMask);

				Trailer -> MidGuard[ ByteIndex ] =
					((char*) & GuardValue)[ ByteIndex ];
				}

			//
			//   Write guard words over part of the space 
			//   as the allocation is being shrunk.
			//
			for ( Count=(EndSize - Count);Count >= 0;Count -= GuardSize )
				{ Trailer -> EndGuard[ (Count / GuardSize) ] = GuardValue; }

			//
			//   Update the header information.
			//
			Header -> Size = Size; 

			//
			//   We know that the entire allocation should 
			//   be set to the guard value so check that it 
			//   has not been overwritten.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{
			//
			//   We know that the entire allocation should be
			//   set to the guard value so check that it has
			//   not been overwritten.
			//
			TestGuardWords( Header,TotalSize );

			//
			//   Update the header information.
			//
			Header -> Size = Size; 
			}
		}
	else
		{ Failure( "Guard word information area is damaged" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Verify( void *Address,int *Space )
    {
	AUTO bool Result;
	AUTO int TotalSize;
	AUTO DEBUG_HEADER *Header =
		(
		(Address == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) Address)
			: ComputeHeaderAddress( Address )
		);

	//
	//   Extract information about the memory allocation.
	//
	Result = 
		(
		ROCKALL::Verify
			( 
			((void*) Header),
			& TotalSize 
			)
		);

	//
	//   If we managed to extract the information then
	//   check the guard words for good measure.
	//
	if ( Result )
		{
		//
		//   If we are about to return the actual 
		//   amount of spce available then we must 
		//   update the size of the guard area.
		//
		if ( Space == NULL )
			{
			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			TestGuardWords( Header,TotalSize );
			}
		else
			{ 
			//
			//   Compute the amount of available space.
			//   
			(*Space) = (TotalSize - sizeof(DEBUG_GUARD));

			//
			//   Test the guard words to make sure they have
			//   not been damaged.
			//
			UpdateGuardWords( Header,(*Space),TotalSize );
			}
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the verification process.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Heap verify failed to complete" ); }

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool DEBUG_HEAP::Walk( bool *Active,void **Address,int *Space )
    {
	AUTO DEBUG_HEADER *Header =
		(
		((*Address) == ((void*) AllocationFailure))
			? ((DEBUG_HEADER*) (*Address))
			: ComputeHeaderAddress( (*Address) )
		);

	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Active,((VOID**) & Header),Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( (*Active) )
			{ TestGuardWords( Header,(*Space) ); }
		else
			{ UnmodifiedGuardWords( Header,(*Space) ); }

		//
		//   Compute the new heap address.
		//
		(*Address) = ComputeDataAddress( Header );

		//
		//   Compute the amount of available space.
		//   
		(*Space) -= sizeof(DEBUG_GUARD);

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current instance of the class.                     */
    /*                                                                  */
    /********************************************************************/

DEBUG_HEAP::~DEBUG_HEAP( void )
	{
	AUTO bool Active;
	AUTO void *Address = NULL;
	AUTO int Space;

	//
	//   Walk the heap and check all the allocations
	//   to make sure the guard words have not been
	//   overwritten.
	//
	while ( ROCKALL::Walk( & Active,& Address,& Space ) )
		{
		//
		//   We inspect the guard words to make sure
		//   they have not been overwritten.
		//
		if ( Active )
			{ TestGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		else
			{ UnmodifiedGuardWords( ((DEBUG_HEADER*) Address),Space ); }
		}

	//
	//   We ensure that the heap has not become corrupt
	//   during the its lifetime.
	//
	if ( ROCKALL::Corrupt() ) 
		{ Failure( "Destructor failed to complete" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\fastheap.hpp ===
#ifndef _FAST_HEAP_HPP_
#define _FAST_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A fast heap.                                                   */
    /*                                                                  */
    /*   A fast heap tries to provide very good performance even        */
    /*   if that comes at a significant cost in terms of additional     */
    /*   memory usage.                                                  */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE FAST_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        FAST_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~FAST_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        FAST_HEAP( const FAST_HEAP & Copy );

        void operator=( const FAST_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\interfacepch.hpp ===
#ifndef _ROCKALL_PCH_HPP_
#define _ROCKALL_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "HeapPCH.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\smallheap.hpp ===
#ifndef _SMALL_HEAP_HPP_
#define _SMALL_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A small heap.                                                  */
    /*                                                                  */
    /*   A small heap tries to significantly reduce memory usage        */
    /*   even if that comes at a significant cost in terms of           */
    /*   performance.                                                   */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMALL_HEAP : public ROCKALL
    {
   public:
        //
        //   Public functions.
        //
        SMALL_HEAP
			( 
			int						  MaxFreeSpace = 0,
			bool					  Recycle = false,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

        ~SMALL_HEAP( void );

	private:
        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMALL_HEAP( const SMALL_HEAP & Copy );

        void operator=( const SMALL_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\rockall.hpp ===
#ifndef _ROCKALL_HPP_
#define _ROCKALL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include <stddef.h>

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation constants.                                   */
    /*                                                                  */
    /*   The memory allocation constants are denote special situations  */
    /*   where optimizations are possible or failures have cccured.     */
    /*                                                                  */
    /********************************************************************/

const int AllocationFailure			  = 0;
const int GuardValue				  = 0xDeadBeef;
const int NoSize					  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class CACHE;
class FIND;
class HEAP;
class NEW_PAGE;

    /********************************************************************/
    /*                                                                  */
    /*   Linkage to the DLL.                                            */
    /*                                                                  */
    /*   We need to compile the class specification slightly            */
    /*   differently if we are creating the heap DLL.                   */
    /*                                                                  */
    /********************************************************************/

#ifdef COMPILING_ROCKALL_DLL
#define ROCKALL_DLL_LINKAGE __declspec(dllexport)
#else
#ifdef COMPILING_ROCKALL_LIBRARY
#define ROCKALL_DLL_LINKAGE
#else
#define ROCKALL_DLL_LINKAGE __declspec(dllimport)
#endif
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation interface.                               */
    /*                                                                  */
    /*   The memory allocator can be configured in a wide variety       */
    /*   of ways to closely match the needs of specific programs.       */
    /*   The interface outlined here can be overloaded to support       */
    /*   whatever customization is necessary.                           */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ROCKALL
    {
    public:
		//
		//   Public types.
		//
		//   A heap is constructed of a collection of 
		//   fixed sized buckets each with an associated
		//   cache.  The details of these buckets are
		//   supplied to the heap using the following
		//   structure.
		//
		typedef struct
			{
			int						  AllocationSize;
			int						  CacheSize;
			int						  ChunkSize;
			int						  PageSize;
			}
		CACHE_DETAILS;

		//
		//   Public data.
		//
		//   The internals linkages in a heap are built
		//   dynamically during the execution of a heaps
		//   constructor.  The member that follow relate
		//   to key internal classes.
		//
		CACHE						  **Array;
		CACHE						  *Caches;
		FIND						  *Find;
		HEAP						  *Heap;
		NEW_PAGE					  *NewPage;

		//
		//   A heap constructor is required to preserve 
		//   a small amount of information for the heap
		//   destructor.
		//
		bool						  GlobalDelete;
		int							  GuardWord;
		int							  NumberOfCaches;
		int							  TotalSize;

        //
        //   Public functions.
		//
		//   A heaps public interface consists of a number
		//   of groups of related APIs.
        //
		ROCKALL( void );

        ROCKALL
			(
			CACHE_DETAILS			  *Caches1,
			CACHE_DETAILS			  *Caches2,
			int						  FindCacheSize,
			int						  FindCacheThreshold,
			int						  FindSize,
			int						  MaxFreeSpace,
			int						  *NewPageSizes,
			bool					  Recycle,
			bool					  SingleImage,
			int						  Stride1,
			int						  Stride2,
			bool					  ThreadSafe 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual bool Details
			( 
			void					  *Address,
			int						  *Space = NULL 
			);

		virtual bool KnownArea( void *Address );

		virtual bool MultipleDelete
			( 
			int						  Actual,
			void					  *Array[],
			int						  Size = NoSize
			);

		virtual bool MultipleNew
			( 
			int						  *Actual,
			void					  *Array[],
			int						  Requested,
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual void *Resize
			( 
			void					  *Address,
			int						  NewSize,
			int						  Move = -64,
			int						  *Space = NULL,
			bool					  NoDelete = false,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual void LockAll( void );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual void UnlockAll( void );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

		//
		//   Low level heap interface.
		//
		//   The third group of functions are called by the
		//   heap to aquire or release large blocks of memory.
		//   These functions can be overloaded to enable the
		//   heap work in constrained environments.
		//
		virtual void DeleteArea( void *Memory,int Size,bool User );

		virtual int NaturalSize( void );

		virtual void *NewArea( int AlignMask,int Size,bool User );

        virtual ~ROCKALL( void );

		//
		//   Public inline functions.
		//
		inline bool Available( void )
			{ return (GuardWord == GuardValue); }

		inline bool Corrupt( void )
			{ return (GuardWord != GuardValue); }

	protected:
		//
		//   Protected inline functions.
		//
		//   A heap needs to compute the size of certain
		//   user supplied structures.  This task is 
		//   performed by the following function.
		//
		int ComputeSize( char *Array,int Stride );

		//
		//   We would like to allow access to the internal
		//   heap allocation function from classes that 
		//   inherit from the heap.  The memory supplied by
		//   this function survies all heap operations and
		//   is cleaned up as poart of heap deletion.
		//
		virtual void *SpecialNew( int Size );

	private:
        //
        //   Disabled operations.
		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ROCKALL( const ROCKALL & Copy );

        void operator=( const ROCKALL & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\interfacepch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\smpheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Common.hpp"
#include "List.hpp"
#include "New.hpp"
#include "Prefetch.hpp"
#include "Sharelock.hpp"
#include "SmpHeap.hpp"
#include "Tls.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 8192;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 4096;
CONST SBIT32 MinThreadStack			  = 4;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Structures local to the class.                                 */
    /*                                                                  */
    /*   The structures supplied here describe the layout of the        */
    /*   per thread caches.                                             */
    /*                                                                  */
    /********************************************************************/

typedef struct CACHE_STACK
	{
	BOOLEAN							  Active;

	SBIT32							  MaxSize;
	SBIT32							  FillSize;
	SBIT32							  Space;
	SBIT32							  Top;

	VOID							  **Stack;
	}
CACHE_STACK;

typedef struct THREAD_CACHE : public LIST
	{
	BOOLEAN							  Flush;

	CACHE_STACK						  *Caches;
	CACHE_STACK						  **SizeToCache1;
	CACHE_STACK						  **SizeToCache2;
	}
THREAD_CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,      256,       32,     4096 },
		{        8,      128,       32,     4096 },
		{       12,      128,       64,     4096 },
		{       16,      128,       64,     4096 },
		{       20,       64,       64,     4096 },
		{       24,       64,       96,     4096 },

		{       32,       64,      128,     4096 },
		{       40,       64,      128,     4096 },
		{       48,       64,      256,     4096 },

		{       64,       64,      256,     4096 },
		{       80,       64,      512,     4096 },
		{       96,       64,      512,     4096 },

		{      128,       32,     4096,     4096 },
		{      160,       32,     4096,     4096 },
		{      192,       32,     4096,     4096 },
		{      224,       32,     4096,     4096 },

		{      256,       32,     4096,     4096 },
		{      320,       16,     4096,     4096 },
		{      384,       16,     4096,     4096 },
		{      448,       16,     4096,     4096 },
		{      512,       16,     4096,     4096 },
		{      576,        8,     4096,     4096 },
		{      640,        8,     8192,     8192 },
		{      704,        8,     4096,     4096 },
		{      768,        8,     4096,     4096 },
		{      832,        8,     8192,     8192 },
		{      896,        8,     8192,     8192 },
		{      960,        8,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,       16,     4096,     4096 },
		{     2048,       16,     4096,     4096 },
		{     3072,        4,    65536,    65536 },
		{     4096,        8,    65536,    65536 },
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,16,64,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC PREFETCH Prefetch;
STATIC SHARELOCK Sharelock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::SMP_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			False,			// Recycle forced off.
			SingleImage,
			Stride1,
			Stride2,
			True			// Locking forced on.
			)
	{
	//
	//   Compute the number of cache descriptions
	//   and the largest allocation size for each
	//   cache description table.
	//
	MaxCaches1 = (ComputeSize( ((CHAR*) Caches1),sizeof(CACHE_DETAILS) ));
	MaxCaches2 = (ComputeSize( ((CHAR*) Caches2),sizeof(CACHE_DETAILS) ));

	MaxSize1 = Caches1[ (MaxCaches1-1) ].AllocationSize;
	MaxSize2 = Caches2[ (MaxCaches2-1) ].AllocationSize;

	//
	//   Create the linked list headers and a thread 
	//   local store variable to point at each threads
	//   private cache.
	//
	ActiveList = ((LIST*) SpecialNew( sizeof(LIST) ));
	FreeList = ((LIST*) SpecialNew( sizeof(LIST) ));
	Tls = ((THREAD_LOCAL_STORE*) SpecialNew( sizeof(THREAD_LOCAL_STORE) ));

	//
	//   We may only activate the the heap if we manage
	//   to allocate space we requested and the stride
	//   size of the cache descriptions is a power of two. 
	//
	if
			(
			(ActiveList != NULL) 
				&&
			(COMMON::ConvertDivideToShift( Stride1,((SBIT32*) & ShiftSize1) ))
				&&
			(COMMON::ConvertDivideToShift( Stride2,((SBIT32*) & ShiftSize2) ))
				&& 
			(FreeList != NULL) 
				&& 
			(Tls != NULL)
			)
		{
		//
		//   Activate the heap.
		//
		Active = True;

		//
		//   Execute the constructors for each linked list
		//   and for the thread local store.
		//
		PLACEMENT_NEW( ActiveList,LIST );
		PLACEMENT_NEW( FreeList,LIST );
		PLACEMENT_NEW( Tls,THREAD_LOCAL_STORE );
		}
	else
		{ Active = False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create new thread cache.                                       */
    /*                                                                  */
    /*   Create a new thread cache to store all the cache stacks.       */
    /*   Each thread cache is private to a thread and is accessed       */
    /*   without taking locks.                                          */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::CreateThreadCache( void )
	{
	REGISTER THREAD_CACHE *ThreadCache = NULL;

	//
	//   We need to have a look in the free list
	//   in the vain hope we will find a prebuilt
	//   thread cache ready for use.
	//
	Sharelock.ClaimExclusiveLock();

	if ( ! FreeList -> EndOfList() )
		{
		//
		//   We have found a free one.
		//
		ThreadCache = ((THREAD_CACHE*) FreeList -> First());

		//
		//   Unlink it from the free list and put
		//   it back in the active list.
		//
		ThreadCache -> Delete( FreeList );
		ThreadCache -> Insert( ActiveList );
		}

	Sharelock.ReleaseExclusiveLock();

	//
	//   If we could not find a free thread cache
	//   then we have allocate the space and build
	//   a new one.  This requires quite a bit of
	//   effort so we try to avoid this as far as
	//   we are able.
	//
	if ( ThreadCache == NULL )
		{
		REGISTER SBIT32 MaxCaches = (MaxCaches1 + MaxCaches2);
		REGISTER SBIT32 MaxSizeToCache1 = (MaxSize1 / Stride1);
		REGISTER SBIT32 MaxSizeToCache2 = (MaxSize2 / Stride2);

		//
		//   Create the space for a new thread 
		//   cache from the heaps special memory
		//   area.
		//
		ThreadCache = 
			(
			(THREAD_CACHE*) SpecialNew
				( 
				sizeof(THREAD_CACHE)
					+
				(MaxCaches * sizeof(CACHE_STACK))
					+
				(MaxSizeToCache1 * sizeof(CACHE_STACK*))
					+
				(MaxSizeToCache2 * sizeof(CACHE_STACK*))
				)
			);

		//
		//   Clearly, if we are unable to allocate the 
		//   required space we have big problems.  All
		//   we can do is exit and continue without a
		//   cache.
		//
		if ( ThreadCache != NULL )
			{
			REGISTER SBIT32 Count1;
			REGISTER SBIT32 Count2;

			//
			//   Setup the thread cache flags.
			//
			ThreadCache -> Flush = False;

			//
			//   Setup the thread cache tables.
			//
			ThreadCache -> SizeToCache1 = 
				((CACHE_STACK**) & ThreadCache[1]);
			ThreadCache -> SizeToCache2 = 
				((CACHE_STACK**) & ThreadCache -> SizeToCache1[ MaxSizeToCache1 ]);
			ThreadCache -> Caches = 
				((CACHE_STACK*) & ThreadCache -> SizeToCache2[ MaxSizeToCache2 ]);

			//
			//   Create a mapping from each allocation size 
			//   to the associated cache stack for the first
			//   cache description table.
			//
			for ( Count1=0,Count2=0;Count1 < MaxSizeToCache1;Count1 ++ )
				{
				//
				//   We make sure that the current cache size
				//   is large enough to hold an element of the
				//   given size.  If not we move on to the next
				//   cache.
				//
				if 
						( 
						((Count1 + 1) * Stride1)
							> 
						(Caches1[ Count2 ].AllocationSize) 
						)
					{ Count2 ++; }

				//
				//   Store a pointer so that a request for
				//   this size of allocation goes directly
				//   to the correct cache.
				//
				ThreadCache -> SizeToCache1[ Count1 ] = 
					& ThreadCache -> Caches[ Count2 ];
				}

			//
			//   Create a mapping from each allocation size 
			//   to the associated cache stack for the second
			//   cache description table.
			//
			for ( Count1=0,Count2=0;Count1 < MaxSizeToCache2;Count1 ++ )
				{
				//
				//   We make sure that the current cache size
				//   is large enough to hold an element of the
				//   given size.  If not we move on to the next
				//   cache.
				//
				if 
						( 
						((Count1 + 1) * Stride2)
							> 
						(Caches2[ Count2 ].AllocationSize) 
						)
					{ Count2 ++; }

				//
				//   Store a pointer so that a request for
				//   this size of allocation goes directly
				//   to the correct cache.
				//
				ThreadCache -> SizeToCache2[ Count1 ] = 
					& ThreadCache -> Caches[ (MaxCaches1 + Count2) ];
				}

			//
			//   When we setup each cache stack it is
			//   not active but will load in details
			//   about is maximum size, the size of
			//   the elements it will hold and the
			//   initial fill size.
			//
			for ( Count1=0;Count1 < MaxCaches1;Count1 ++ )
				{ 
				REGISTER CACHE_STACK *CacheStack =
					& ThreadCache -> Caches[ Count1 ];
				REGISTER CACHE_DETAILS *Details = 
					& Caches1[ Count1 ];

				//
				//   Setup the inital values from
				//   the cache descriptions.
				//
				CacheStack -> Active = False;
				CacheStack -> MaxSize = Details -> CacheSize;
				CacheStack -> FillSize = 1;
				CacheStack -> Space = Details -> AllocationSize;
				CacheStack -> Top = 0;
				CacheStack -> Stack = NULL;
				}

			//
			//   When we setup each cache stack it is
			//   not active but will load in details
			//   about is maximum size, the size of
			//   the elements it will hold and the
			//   initial fill size.
			//
			for ( Count1=0;Count1 < MaxCaches2;Count1 ++ )
				{ 
				REGISTER CACHE_STACK *CacheStack =
					& ThreadCache -> Caches[ MaxCaches1 + Count1 ];
				REGISTER CACHE_DETAILS *Details = 
					& Caches2[ Count1 ];

				//
				//   Setup the inital values from
				//   the cache descriptions.
				//
				CacheStack -> Active = False;
				CacheStack -> MaxSize = Details -> CacheSize;
				CacheStack -> FillSize = 1;
				CacheStack -> Space = Details -> AllocationSize;
				CacheStack -> Top = 0;
				CacheStack -> Stack = NULL;
				}

			//
			//   Now we have completed creating the 
			//   thread cache we have to insert it
			//   into the active list.
			//
			Sharelock.ClaimExclusiveLock();

			ThreadCache -> Insert( ActiveList );

			Sharelock.ReleaseExclusiveLock();
			}
		}

	//
	//   Create a cache for the current thread and
	//   update the TLS pointer.
	//
	Tls -> SetPointer( ((VOID*) ThreadCache) ); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Activate a cache stack.                                        */
    /*                                                                  */
    /*   Activate a cache stack and prepare it for use.                 */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::ActivateCacheStack( CACHE_STACK *CacheStack )
	{
	//
	//   We verify that we have not already created a 
	//   stack for the current cache.  If so we create
	//   one if there is available memory.
	//
	if ( ! CacheStack -> Active )
		{
		//
		//   If the cache size is smaller than the
		//   minimum size it is not worth building
		//   a cache.
		//
		if ( CacheStack -> MaxSize >= MinThreadStack )
			{
			//
			//   Create a new cache stack.
			//
			CacheStack -> Stack = 
				(
				(VOID**) SpecialNew
					( 
					(CacheStack -> MaxSize * sizeof(VOID*))
					)
				);

			//
			//   The key step in this function is the  
			//   allocation of space for the cache.  
			//   If this step fails we will be unable  
			//   to do anything and will silently exit.
			//
			if ( CacheStack -> Stack != NULL )
				{
				//
				//   Setup the cache sizes.
				//
				CacheStack -> Active = True;
				CacheStack -> Top = 0;
				}
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   When we delete an allocation we try to put it in the per       */
    /*   thread cache so it can be reallocated later.                   */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Delete( void *Address,int Size )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER THREAD_CACHE *ThreadCache = 
			((THREAD_CACHE*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a cache for the current thread.  
		//   If not we build one for next time.
		//
		if ( ThreadCache != NULL )
			{
			AUTO int Space;

			//
			//   When the heap is deleted or truncated 
			//   we have to flush the per thread caches
			//   the next time we are called to clean
			//   out any stale contents.
			//
			if ( ThreadCache -> Flush )
				{ FlushThreadCache( ThreadCache ); }

			//
			//   We would like to put the deleted 
			//   allocation back in the cache.
			//   However, we don't have any information
			//   about it so we need to get its size
			//   and verify it will fit in the cache.
			//
			if
					(
					ROCKALL::Details( Address,& Space )
						&&
					((Space > 0) && (Space < MaxSize2))
					)
				{
				REGISTER CACHE_STACK *CacheStack = 
					(FindCache( Space,ThreadCache ));

				//
				//   We try to put the deleted element  
				//   back into the per thread cache.  If
				//   the cache is not active then we 
				//   activate it for next time.
				//
				if ( CacheStack -> Active )
					{
					//
					//   Just to be sure lets just check
					//   to make sure this is the size
					//   that we expect.
					//
					if ( CacheStack -> Space == Space )
						{
						//
						//   Flush the cache if it is full.
						//
						if ( CacheStack -> Top >= CacheStack -> MaxSize )
							{
							//
							//   Flush the top half of the 
							//   cache.
							//
							CacheStack -> Top /= 2;

							ROCKALL::MultipleDelete
								( 
								(CacheStack -> MaxSize - CacheStack -> Top),
								& CacheStack -> Stack[ CacheStack -> Top ],
								CacheStack -> Space
								);
							}

						//
						//   Push the item back onto the new 
						//   stack so it can be reallocated.
						//
						CacheStack -> Stack[ (CacheStack -> Top ++) ] = Address;

						return True;
						}
					}
				else
					{
					//
					//   Activate the cache stack for next 
					//   time.
					//
					ActivateCacheStack( CacheStack ); 
					}
				}
			}
		else
			{
			//
			//   Create a thread cache for next time.
			//
			CreateThreadCache(); 
			}
		}

	//
	//   If all else fails call the heap directly and
	//   return the result.
	//
	return (ROCKALL::Delete( Address,Size ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   We check to make sure the heap is not corrupt and force        */
    /*   the return of all heap space back to the operating system.     */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::DeleteAll( bool Recycle )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Flush all the local caches.
		//
		FlushAllThreadCaches();

		//
		//   Delete the current cache.
		//
		DeleteThreadCache();
		}

	//
	//   Delete all outstanding allocations.
	//
	ROCKALL::DeleteAll( Recycle );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a local cache.                                            */
    /*                                                                  */
    /*   Find the local cache that allocates elements of the supplied   */
    /*   size for this thread.                                          */
    /*                                                                  */
    /********************************************************************/

CACHE_STACK *SMP_HEAP::FindCache( int Size,THREAD_CACHE *ThreadCache )
	{
	if ( Size <= MaxSize1 )
		{ return (ThreadCache -> SizeToCache1[ ((Size-1) >> ShiftSize1) ]); }
	else
		{ return (ThreadCache -> SizeToCache2[ ((Size-1) >> ShiftSize2) ]); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush all local caches.		                                */
    /*                                                                  */
    /*   Flush the local per thread caches by setting each caches       */
    /*   flush flag (the actual flush occurs sometime later).           */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushAllThreadCaches( void )
	{
	REGISTER THREAD_CACHE *Current;

	//
	//   Claim a process wide lock.
	//
	Sharelock.ClaimShareLock();

	//
	//   Walk the list of active caches and set
	//   the flush flag.
	//
	for 
			( 
			Current = ((THREAD_CACHE*) ActiveList -> First());
			(Current != NULL);
			Current = ((THREAD_CACHE*) Current -> Next())
			)
		{ Current -> Flush = True; }

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush a local cache.                                           */
    /*                                                                  */
    /*   Flush a local per thread cache and return all the outstanding  */
    /*   allocations to the main heap.                                  */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushThreadCache( THREAD_CACHE *ThreadCache )
	{
	//
	//   We would hope that there is a cache to flush
	//   but just to be sure we verify it.
	//
	if ( ThreadCache != NULL )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 MaxCaches = (MaxCaches1 + MaxCaches2);

		//
		//   Reset the flags.
		//
		ThreadCache -> Flush = False;

		//
		//   Flush all the caches.
		//
		for ( Count=0;Count < MaxCaches;Count ++ )
			{ FlushCacheStack( & ThreadCache -> Caches[ Count ] ); }
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Flush a cache stack.                                           */
    /*                                                                  */
    /*   Flush a cache stack back to the main memory manager to         */
    /*   release the cached space.                                      */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::FlushCacheStack( CACHE_STACK *CacheStack )
    {
	//
	//   There is a chance that this cache is not active. 
	//   If so we skip the cache flush.
	//
	if ( CacheStack -> Active )
		{
		REGISTER SBIT32 Top = CacheStack -> Top;

		//
		//   We flush the cache if it has any allocated 
		//   space.  If not we just exit.
		//
		if ( Top != 0 )
			{
			//
			//   Zero the top of stack.
			//
			CacheStack -> FillSize = 1;
			CacheStack -> Top = 0;

			//
			//   We simply flush any allocated memory
			//   back to the heap.  This looks easy 
			//   doesn't it.  However, if the 'DeleteAll()'
			//   function was called then this memory
			//   might exist.  However, if 'Truncate()'
			//   was called it should.  Moreover, some of
			//   the allocations might not even be from
			//   this heap.  What a mess.  We avoid all
			//   this by disabling 'Recycle' and skiping
			//   any complaints about unallocated memory.
			//
			ROCKALL::MultipleDelete
				( 
				Top,
				CacheStack -> Stack,
				CacheStack -> Space
				);
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate space for the current thread from the local        */
    /*   per thread cache.  If we run out of space we bulk load         */
    /*   additional elements from a central shared heap.                */
    /*                                                                  */
    /********************************************************************/

void *SMP_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		REGISTER THREAD_CACHE *ThreadCache = 
			((THREAD_CACHE*) Tls -> GetPointer());

		//
		//   We need to examine the TLS pointer to make 
		//   sure we have a cache for the current thread.
		//   If not we build one for next time.
		//
		if ( ThreadCache != NULL )
			{
			//
			//   When the heap is deleted or truncated 
			//   we have to flush the per thread caches
			//   the next time we are called to clean
			//   out any stale contents.
			//
			if ( ThreadCache -> Flush )
				{ FlushThreadCache( ThreadCache ); }

			//
			//   The per thread cache can only slave 
			//   certain allocation sizes.  If the size 
			//   is out of range then pass it along to 
			//   the allocator.
			//
			if ( (Size > 0) && (Size < MaxSize2) )
				{
				REGISTER CACHE_STACK *CacheStack = 
					(FindCache( Size,ThreadCache ));

				//
				//   Although we have created a cache  
				//   description it may not be active. 
				//
				if ( CacheStack -> Active )
					{
					//
					//   We see if we need to refill the
					//   current cache.  If so we increase
					//   the fill size slowly ensure good
					//   overall utilization.
					//
					if ( CacheStack -> Top <= 0 )
						{
						REGISTER SBIT32 MaxFillSize = 
							(CacheStack -> MaxSize / 2);

						//
						//   We slowly increse the fill size
						//   of the cache to make sure we don't
						//   waste too much space.
						//
						if ( CacheStack -> FillSize < MaxFillSize )
							{
							if ( (CacheStack -> FillSize *= 2) > MaxFillSize )
								{ CacheStack -> FillSize = MaxFillSize; }
							}

						//
						//   Refill the current cache stack.
						//
						ROCKALL::MultipleNew
							( 
							((int*) & CacheStack -> Top),
							((void**) CacheStack -> Stack),
							((int) CacheStack -> FillSize),
							((int) CacheStack -> Space)
							);
						}

					//
					//   If there is some space in the 
					//   current cache stack we allocate it.
					//
					if ( CacheStack -> Top > 0 )
						{
						REGISTER VOID *Address = 
							(CacheStack -> Stack[ (-- CacheStack -> Top) ]);

						//
						//   Prefetch the first cache line of  
						//   the allocation if we are running
						//   a Pentium III or better.
						//
						Prefetch.L1( ((CHAR*) Address),1 );

						//
						//   If the caller want to know the
						//   real size them we supply it.
						//
						if ( Space != NULL )
							{ (*Space) = CacheStack -> Space; }

						//
						//   If we need to zero the allocation
						//   we do it here.
						//
						if ( Zero )
							{ ZeroMemory( Address,CacheStack -> Space ); }

						return Address;
						}
					}
				else
					{
					//
					//   Activate the cache stack for next 
					//   time.
					//
					ActivateCacheStack( CacheStack ); 
					}
				}
			}
		else
			{
			//
			//   Create a thread cache for next time.
			//
			CreateThreadCache(); 
			}
		}

	//
	//   If all else fails call the heap directly and
	//   return the result.
	//
	return (ROCKALL::New( Size,Space,Zero ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search all local caches.		                                */
    /*                                                                  */
    /*   Search the local per thread caches by for an address so we     */
    /*   know whether it is available.                                  */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchAllThreadCaches( void *Address,int Size )
	{
	REGISTER LIST *Current;
	REGISTER bool Result = False;

	//
	//   Claim a process wide lock.
	//
	Sharelock.ClaimShareLock();

	//
	//   Walk the list of active caches.
	//
	for 
			( 
			Current = ActiveList -> First();
			((Current != NULL) && (! Result));
			Current = Current -> Next()
			)
		{
		//
		//   Search each per thread cache.
		//
		Result =
			(
			SearchThreadCache
				( 
				Address,
				Size,
				((THREAD_CACHE*) Current)
				)
			); 
		}

	//
	//   Release the lock.
	//
	Sharelock.ReleaseShareLock();

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search a local cache.                                          */
    /*                                                                  */
    /*   Search a local per thread cache for a memory allocation.       */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchThreadCache
		( 
		void						  *Address,
		int							  Size,
		THREAD_CACHE				  *ThreadCache 
		)
	{
	//
	//   We would hope that there is a cache to search
	//   but just to be sure we verify it.
	//
	if ( ThreadCache != NULL )
		{
		//
		//   The per thread cache can only slave 
		//   certain allocation sizes.  If the size 
		//   is out of range then skip the search. 
		//
		if ( (Size > 0) && (Size < MaxSize2) )
			{
			REGISTER CACHE_STACK *CacheStack = 
				(FindCache( Size,ThreadCache ));

			return (SearchCacheStack( Address,CacheStack ));
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Search a cache stack.                                          */
    /*                                                                  */
    /*   Search a cache stack for an allocation address.                */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::SearchCacheStack( void *Address,CACHE_STACK *CacheStack )
    {
	//
	//   There is a chance that this cache is not active. 
	//   If so we skip the cache flush.
	//
	if ( CacheStack -> Active )
		{
		REGISTER SBIT32 Count;

		//
		//   Search for the address.
		//
		for ( Count=(CacheStack -> Top-1);Count >= 0;Count -- )
			{
			//
			//   If the address matches exit.
			//
			if ( Address == CacheStack -> Stack[ Count ] )
				{ return True; }
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Truncate( int MaxFreeSpace )
    {
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Flush all the local caches.
		//
		FlushAllThreadCaches();

		//
		//   Delete the current cache.
		//
		DeleteThreadCache();
		}

	//
	//   Truncate the heap.
	//
	return (ROCKALL::Truncate( MaxFreeSpace ));
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify memory allocation details.                              */
    /*                                                                  */
    /*   Extract information about a memory allocation and just for     */
    /*   good measure check the guard words at the same time.           */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Verify( void *Address,int *Space )
    {
	AUTO int Size;

	//
	//   Extract information about the memory 
	//   allocation.
	//
	if ( ROCKALL::Verify( Address,& Size ) )
		{
		//
		//   If the caller requested the allocation
		//   size then return it.
		//
		if ( Space != NULL )
			{ (*Space) = Size; }

		//
		//   Although it is very rare there is a 
		//   chance that we failed to build the 
		//   basic heap structures.
		//
		if ( Active )
			{
			//
			//   Search for the allocation in the
			//   local per thread caches.
			//
			return (! SearchAllThreadCaches( Address,Size ));
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool SMP_HEAP::Walk( bool *Activity,void **Address,int *Space )
    {
	//
	//   Walk the heap.
	//
	if ( ROCKALL::Walk( Activity,Address,Space ) )
		{
		//
		//   Although it is very rare there is a 
		//   chance that we failed to build the 
		//   basic heap structures.
		//
		if ( Active )
			{
			//
			//   Search for the allocation in the
			//   local per thread caches.
			//
			(*Activity) = (! SearchAllThreadCaches( Address,(*Space) ));
			}

		return true;
		}
	else
		{ return false; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a local cache.                                          */
    /*                                                                  */
    /*   Delete a local per thread cache and return all the outstanding */
    /*   allocations to the main heap.                                  */
    /*                                                                  */
    /********************************************************************/

void SMP_HEAP::DeleteThreadCache( void )
	{
	REGISTER THREAD_CACHE *ThreadCache = 
		((THREAD_CACHE*) Tls -> GetPointer());

	//
	//   We would certainly expect to have a cache
	//   to delete but we check just to be sure.
	//
	if ( ThreadCache != NULL )
		{
		//
		//   Flush the cache.
		//
		FlushThreadCache( ThreadCache );

		//
		//   We have finished with the cache so
		//   add it to the list of free caches
		//   so we can find it again later.
		//
		Sharelock.ClaimExclusiveLock();

		ThreadCache -> Delete( ActiveList );
		ThreadCache -> Insert( FreeList );

		Sharelock.ReleaseExclusiveLock();

		//
		//   Delete the threads private cache
		//   pointer so it can no longer find
		//   the cache.
		//
		Tls -> SetPointer( NULL ); 
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMP_HEAP::~SMP_HEAP( void )
	{
	//
	//   Although it is very rare there is a chance
	//   that we failed to build the basic heap structures.
	//
	if ( Active )
		{
		//
		//   Deactivate the cache.
		//
		Active = False;

		FlushAllThreadCaches();

		//
		//   Call the list and TLS destructors.
		//
		PLACEMENT_DELETE( Tls,THREAD_LOCAL_STORE );
		PLACEMENT_DELETE( FreeList,LIST );
		PLACEMENT_DELETE( ActiveList,LIST );
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\smallheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "SmallHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 4;
CONST SBIT32 Stride2				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{        4,        0,       32,       32 },
		{        8,        0,       32,       32 },
		{       12,        0,       64,       64 },
		{       16,        0,       64,       64 },
		{       20,        0,       64,       64 },
		{       24,        0,      128,      128 },

		{       32,        0,       64,       64 },
		{       40,        0,      128,      128 },
		{       48,        0,      256,      256 },

		{       64,        0,      128,      128 },
		{       80,        0,      512,      512 },
		{       96,        0,      512,      512 },

		{      128,        0,      256,      256 },
		{      160,        0,      512,      512 },
		{      192,        0,     1024,     1024 },
		{      224,        0,      512,      512 },

		{      256,        0,      512,      512 },
		{      320,        0,     1024,     1024 },
		{      384,        0,     2048,     2048 },
		{      448,        0,     4096,     4096 },
		{      512,        0,     1024,     1024 },
		{      576,        0,     4096,     4096 },
		{      640,        0,     8192,     8192 },
		{      704,        0,     4096,     4096 },
		{      768,        0,     4096,     4096 },
		{      832,        0,     8192,     8192 },
		{      896,        0,     8192,     8192 },
		{      960,        0,     4096,     4096 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     1024,        0,     2048,     2048 },
		{     2048,        0,     4096,     4096 },
		{     3072,        0,    65536,    65536 },
		{     4096,        0,     8192,     8192 },
		{     5120,        0,    65536,    65536 },
		{     6144,        0,    65536,    65536 },
		{     7168,        0,    65536,    65536 },
		{     8192,        0,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        0,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 1,4,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::SMALL_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{ /* void */ }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

SMALL_HEAP::~SMALL_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\posixheap.hpp ===
#ifndef _POSIX_HEAP_HPP_
#define _POSIX_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "DefaultHeap.hpp"
 
    /********************************************************************/
    /*                                                                  */
    /*   The standard posix interface.                                  */
    /*                                                                  */
    /*   The Posix interface allows Rockall to be linked into Unix      */
    /*   applications with a minimal amount of fuss.  Although the      */
    /*   function names are not identical to the posix names (so as     */
    /*   to avoid name clashes) functionally they are close enough      */
    /*    to be simple replacements.                                    */
    /*                                                                  */
    /********************************************************************/

inline void *Calloc( int Size )
	{ return DefaultHeap.New( Size,NULL,true ); }

inline bool Free( void *Address,int Size = NoSize )
	{ return DefaultHeap.Delete( Address,Size ); }

inline void *Malloc( int Size )
	{ return DefaultHeap.New( Size ); }

inline void *Realloc( void *Address,int NewSize )
	{ return DefaultHeap.Resize( Address,NewSize ); }
#ifdef POSIX_EXTENSIONS

    /********************************************************************/
    /*                                                                  */
    /*   Extensions to the posix interface.                             */
    /*                                                                  */
    /*   The Posix interface is fairly restricted and only gives        */
    /*   access to a small portion of Rockall.  The functions that      */
    /*   follow expose additional Rockall functionality.                */
    /*                                                                  */
    /********************************************************************/

inline void DeleteAll( bool Recycle = true )
	{ DefaultHeap.DeleteAll( Recycle ); }

inline bool MultipleFree
		( 
		int				Actual,
		void			*Array[],
		int				Size = NoSize
		)
	{ return DefaultHeap.MultipleDelete( Actual,Array,Size ); }

inline bool MultipleMalloc
		( 
		int				*Actual,
		void			*Array[],
		int				Requested,
		int				Size
		)
	{ return DefaultHeap.MultipleNew( Actual,Array,Requested,Size ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\rockall.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Cache.hpp"
#include "Common.hpp"
#include "Find.hpp"
#include "Heap.hpp"
#include "New.hpp"
#include "NewPage.hpp"
#include "Rockall.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 EnableLookAside		  = 0;
CONST SBIT32 GlobalMask				  = (sizeof(SBIT64) - 1);
CONST SBIT32 GlobalPaddedSize		  = (sizeof(FIND) + GlobalMask);
CONST SBIT32 GlobalByteSize			  = (GlobalPaddedSize & ~GlobalMask);
CONST SBIT32 GlobalWordSize			  = (GlobalByteSize / sizeof(SBIT64));

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

STATIC SBIT64 GlobalFind[ GlobalWordSize ];
STATIC SBIT32 ReferenceCount = 0;
STATIC SPINLOCK Spinlock;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The interface default constructor creates a null heap for      */
    /*   internal use by selected classes.                              */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL( void )
	{
	//
	//   A heap constructed by this constructor should
	//   never be used.  Hence, we zero key pointers to
	//   ensure grave disorder will result if anyone tries.
	//
	Array = NULL;
	Caches = NULL;
	Find = NULL;
	Heap = NULL;
	NewPage = NULL;

	GlobalDelete = True;
	GuardWord = GuardValue;
	NumberOfCaches = 0;
	TotalSize = 0;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility within heaps      */
    /*   leading to potentially dramatically different properties.      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::ROCKALL
		(
		CACHE_DETAILS				  *Caches1,
		CACHE_DETAILS				  *Caches2,
		int							  FindCacheSize,
		int							  FindCacheThreshold,
		int							  FindSize,
		int							  MaxFreeSpace,
		int							  *NewPageSizes,
		bool						  Recycle,
		bool						  SingleImage,
		int							  Stride1,
		int							  Stride2,
		bool						  ThreadSafe 
		)
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	TRY
#endif
		{
		REGISTER int AlignMask = ((int) (NaturalSize()-1));
		REGISTER int Stride = (sizeof(CACHE_DETAILS));
		REGISTER int Size1 = (ComputeSize( ((char*) Caches1),Stride ));
		REGISTER int Size2 = (ComputeSize( ((char*) Caches2),Stride ));
		REGISTER int Size3 = (ComputeSize( ((char*) NewPageSizes),sizeof(int) ));

		//
		//   The interface pointer members are zeroed to
		//   ensure they do not end up containing random 
		//   rubbish whatever happens.
		//
		Array = NULL;
		Caches = NULL;
		Find = NULL;
		Heap = NULL;
		NewPage = NULL;

		//
		//   Set key flags and compute information about
		//   the number of caches and the total amount of
		//   space required for the low level heap structures.
		//
		GlobalDelete = SingleImage;
		GuardWord = GuardValue;
		NumberOfCaches = (Size1 + Size2);

		TotalSize = 
			( 
			(NumberOfCaches * sizeof(CACHE*)) 
				+ 
			(NumberOfCaches * sizeof(CACHE))
				+
			((GlobalDelete) ? 0 : sizeof(FIND))
				+ 
			(sizeof(NEW_PAGE))
				+
			(sizeof(HEAP))
			);

		//
		//   Ensure the alignment mask is valid and we have
		//   at least four caches.  If not the heap will be
		//   worthless.
		//
		if 
				( 
				(COMMON::PowerOfTwo( ((SBIT32) (AlignMask+1)) )) 
					&& 
				((Size1 >= 1) && (Size2 >= 3))
					&&
				((Stride1 > 0) && (COMMON::PowerOfTwo( Stride1 )))
					&&
				((Stride2 >= Stride1) && (COMMON::PowerOfTwo( Stride2 )))
				)
			{
			REGISTER CHAR *NewMemory = 
				((CHAR*) NewArea( ((SBIT32) AlignMask),TotalSize,False ));

			//
			//   We check to make sure that we can allocate space
			//   to store the low level heap control information.
			//   If not we exit.
			//
			if ( NewMemory != NULL )
				{
				REGISTER SBIT32 Count;

				//
				//   Build the caches.
				//
				//   The first step in creating a heap is to
				//   create all the caches and related buckets 
				//   requested by the user.  
				//
				Caches = ((CACHE*) NewMemory);
				NewMemory += (NumberOfCaches * sizeof(CACHE));

				for ( Count=0;Count < Size1;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches1[ Count ];

					PLACEMENT_NEW( & Caches[ Count ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize), 
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),
						((BOOLEAN) Recycle),
						((BOOLEAN) ThreadSafe)
						);
					}

				for ( Count=0;Count < Size2;Count ++ )
					{
					REGISTER CACHE_DETAILS *Current = & Caches2[ Count ];

					PLACEMENT_NEW( & Caches[ (Count + Size1) ],CACHE )
						(  
						((SBIT32) Current -> AllocationSize),    
						((SBIT32) Current -> CacheSize),    
						((SBIT32) Current -> ChunkSize),    
						((SBIT32) Current -> PageSize),    
						((BOOLEAN) Recycle),  
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Build the cache array.
				//
				//   After we have constructed all of the caches 
				//   we take the address of each cache and load 
				//   it into an array.  This indirection allows 
				//   caches to be shared between heaps.
				//
				Array = (CACHE**) NewMemory;
				NewMemory += (NumberOfCaches * sizeof(CACHE*));

				for ( Count=0;Count < NumberOfCaches;Count ++ )
					{ Array[ Count ] = & Caches[ Count ]; }

				//
				//   Configuration of the find hash table.
				//
				//   The find hash table maps addresses to page 
				//   descriptions and is a key part of the memory  
				//   deallocation mechanism.  Here we specify 
				//   the size of the hash table.  It is important 
				//   to size it based on the expected number of 
				//   memory allocations.  Nonetheless, it will
				//   automatically grow if the correct option is 
				//   set and it is clearly too small.
				//
				if ( GlobalDelete )
					{
					//
					//   We claim a lock just in case there
					//   are multiple threads.
					//
					Spinlock.ClaimLock();

					//
					//   We create the global find hash table
					//   if we are the first thread to create
					//   a heap.
					//
					if ( (ReferenceCount ++) == 0 )
						{
						STATIC ROCKALL Rockall;

						//
						//   Select the global find table 
						//   and call the constructor.
						//
						Find = ((FIND*) GlobalFind);

						PLACEMENT_NEW( Find,FIND ) 
							( 
							((SBIT32) FindSize),
							((SBIT32) FindCacheSize),
							((SBIT32) EnableLookAside),
							((ROCKALL*) & Rockall),
							((BOOLEAN) True),
							((BOOLEAN) (GlobalDelete || ThreadSafe))
							);
						}
					else
						{
						//
						//   A global find has table already
						//   exists so just use it.
						//
						Find = ((FIND*) GlobalFind); 
						}

					//
					//   Release the lock now.
					//
					Spinlock.ReleaseLock();
					}
				else
					{
					Find = (FIND*) NewMemory;
					NewMemory += sizeof(FIND);

					//
					//   We create a local find hash table
					//   if we are do not need to provide
					//   a single heap image.
					//
					PLACEMENT_NEW( Find,FIND ) 
						( 
						((SBIT32) FindSize),
						((SBIT32) FindCacheSize),
						((SBIT32) FindCacheThreshold),
						((ROCKALL*) this),
						((BOOLEAN) True),
						((BOOLEAN) ThreadSafe)
						);
					}

				//
				//   Configuration of the allocation overhead.
				//
				//   The allocation overhead is controlled by 
				//   the size of the bit vectors used to keep 
				//   track of the allocations.  There is a built 
				//   in limit of ((2^15)-1) elements in a single 
				//   bit vector.
				//
				NewPage = (NEW_PAGE*) NewMemory;
				NewMemory += sizeof(NEW_PAGE);

				PLACEMENT_NEW( NewPage,NEW_PAGE ) 
					(
					((FIND*) Find),
					((SBIT32*) NewPageSizes),
					((ROCKALL*) this),
					((SBIT32) Size3),
					((BOOLEAN) ThreadSafe)
					);

				//
				//   Create the heap.
				//
				//   We can now create the heap.  We do this
				//   by passing pointers to all the parts of  
				//   the heap that we have just created.
				//   
				//
				Heap = (HEAP*) NewMemory;

				PLACEMENT_NEW( Heap,HEAP )
					( 
					((CACHE**) & Array[0]),
					((CACHE**) & Array[ Size1 ]),
					((SBIT32) MaxFreeSpace),
					((FIND*) Find),
					((NEW_PAGE*) NewPage),
					((ROCKALL*) this),
					((SBIT32) Size1),
					((SBIT32) Size2),
					((SBIT32) Stride1),
					((SBIT32) Stride2),
					ThreadSafe
					);
				}
			else
				{ Failure( "Heap constructor failed in ROCKALL" ); }
			}
		else
			{ Failure( "Cache size in constructor for ROCKALL" ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the size of the caches.                                */
    /*                                                                  */
    /*   Compute the size of various data structures for internal       */
    /*   sizing purposes.                                               */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::ComputeSize( char *Array,int Stride )
	{
	register int Count;

	for 
		( 
		Count=0;
		((*((int*) & Array[ Count ])) != 0);
		Count += Stride 
		);

	return (Count / Stride);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory deallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Delete( void *Address,int Size )
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocation.
		//
		if ( Available() )
			{ return (Heap -> Delete( ((VOID*) Address),((SBIT32) Size) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   At certain places in am application we sometimes need to       */
    /*   delete a significant number of allocations.  If all of         */
    /*   these allocations are placed into a single heap we can         */
    /*   delete them all using this call.                               */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteAll( bool Recycle )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> DeleteAll( (BOOLEAN) Recycle ); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete allocation area.                                        */
    /*                                                                  */
    /*   All memory requests are eventually sent back to the external   */
    /*   deallocator.  This function can be overloaded so that memory   */
    /*   can be provided from any source.  The default is to send       */
    /*   the area back to the operating system.                         */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::DeleteArea( void *Memory,int Size,bool User )
	{
	REGISTER DWORD NewSize = ((Size == 0) ? Size : 0);

#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
	//
	//  When we are debugging print out trace information.
	//  
	DebugPrint( "Delete\t 0x%08x %d bytes\n",Memory,Size );

#endif
#endif
	//
	//   The NT 'VirtualFree' call requires the 'Size'
	//   to be zero.  This may not be true of all 
	//   deallocators so we pass the value and then
	//   replace it with zero above.
	//
	if ( VirtualFree( Memory,NewSize,MEM_RELEASE ) == NULL )
		{ Failure( "Delete fails in DeleteArea" ); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation details.                                     */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Details( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Details( ((VOID*) Address),((SBIT32*) Space) )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   A known area.                                                  */
    /*                                                                  */
    /*   We have an address and don't have a clue which heap            */
    /*   owns the space.  Here we take a look at the address            */
    /*   and figure out it it belongs to the current heap.              */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::KnownArea( void *Address )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return ( Heap -> KnownArea( ((VOID*) Address) ) );
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Claim all the heap locks.                                      */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::LockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> LockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory deallocations.                                 */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleDelete
		( 
		int							  Actual,
		void						  *Array[],
		int							  Size
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to delete the supplied 
		//   allocations.
		//
		if ( (Actual > 0) && (Array != NULL) && (Available()) )
			{
			return
				(
				Heap -> MultipleDelete
					( 
					((SBIT32) Actual),
					((VOID**) Array),
					((SBIT32) Size) 
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if 
				(
				((Array != NULL) && (Available()))
					&& 
				((Requested > 0) && (Size >= 0))
				)
			{
			return
				(
				Heap -> MultipleNew
					( 
					((SBIT32*) Actual),
					((VOID**) Array),
					((SBIT32) Requested),
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	
	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   The natural allocation size.                                   */
    /*                                                                  */
    /*   We would like to know a good default size for allocations.     */
    /*   The default is to ask the operating system for the             */
    /*   allocation granularity.                                        */
    /*                                                                  */
    /********************************************************************/

int ROCKALL::NaturalSize( void )
    {
	STATIC SBIT32 AllocationSize = 0;

	//
	//   Ask the operation system for the allocation
	//   granularity.
	//
	if ( AllocationSize <= 0 )
		{
		AUTO SYSTEM_INFO SystemInformation;

		GetSystemInfo( & SystemInformation );

		AllocationSize = (SBIT32) SystemInformation.dwAllocationGranularity;
		}

	return ((int) AllocationSize);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::New( int Size,int *Space,bool Zero )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size >= 0) )
			{
			return 
				(
				Heap -> New
					( 
					((SBIT32) ((Size > 0) ? Size : 1)),
					((SBIT32*) Space),
					((BOOLEAN) Zero)
					)
				);
			}
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   New allocation area.                                           */
    /*                                                                  */
    /*   All memory requests are eventually sent to the new external    */
    /*   allocator.  This function can be overloaded so that memory     */
    /*   can be provided from any source.  The default is to get        */
    /*   new memory from the operating system.                          */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::NewArea( int AlignMask,int Size,bool User )
    {
	//
	//   When there is an alignment requirement greater
	//   than the natural alignment provided by the
	//   operating system we have to play various tricks
	//   to allocate a suitable block.  If not then we
	//   just do a normal allocation call.
	//
	if ( AlignMask > NaturalSize() )
		{
		REGISTER SBIT32 NewSize = (AlignMask + Size);

		//
		//   We need to allocate a block with an 
		//   alignment requirement greater than 
		//   the operating system default.  So we
		//   allocate a much larger block and
		//   release the parts we don't need.
		//
		while ( True )
			{
			REGISTER VOID *Reserved =
				(
				VirtualAlloc
					( 
					NULL,
					((DWORD) NewSize),
					MEM_RESERVE,
					PAGE_READWRITE 
					)
				);

			//
			//   Lets ensure we were able to find a suitable
			//   memory block.  If not then we exit.
			//
			if ( Reserved != NULL )
				{
				//
				//   We just want to return the parts of
				//   the block we don't need but 'NT' is  
				//   not smart enough.  So we free the  
				//   entire block.
				//
				if ( VirtualFree( Reserved,0,MEM_RELEASE ) )
					{
					REGISTER LONG Address = ((LONG) Reserved);
					REGISTER VOID *NewMemory;

					//
					//   Compute the base address of the part 
					//   of the block we really want to allocate.
					//
					Address = ((Address + AlignMask) & ~AlignMask);

					//
					//   Finally, lets reallocate the part of  
					//   the block we wanted but just released   
					//   and hope that nobody else got it before
					//   us.
					//
					NewMemory =
						(
						VirtualAlloc
							( 
							((LPVOID) Address),
							((DWORD) Size),
							(MEM_RESERVE | MEM_COMMIT),
							PAGE_READWRITE 
							)
						);

					//
					//   If it all worked we can exit.
					//
					if ( NewMemory != NULL )
						{ 
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS
						//
						//  When we are debugging output 
						//  out trace information.
						//  
						DebugPrint
							( 
							"New\t\t 0x%08x %d bytes\n",
							NewMemory,
							Size 
							);

#endif
#endif
						return ((void*) NewMemory); 
						}
					}
				else
					{ return ((void*) AllocationFailure); }

				}
			else
				{ return ((void*) AllocationFailure); }
			}
		}
	else
		{
		REGISTER VOID *NewMemory;

		//
		//   We can allocate directly from the operating 
		//   system as the default alignment requirement 
		//   is enough for this case.
		//
		NewMemory =
			(
			VirtualAlloc
				( 
				NULL,
				((DWORD) Size),
				MEM_COMMIT,
				PAGE_READWRITE
				)
			);
#ifdef DEBUGGING
#ifdef ENABLE_ALLOCATION_STATISTICS

		if ( NewMemory != NULL )
			{
			//
			//  When we are debugging output out trace
			//  information.
			//  
			DebugPrint( "New\t\t 0x%08x %d bytes\n",NewMemory,Size );
			}
#endif
#endif

		return ((void*) NewMemory);
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory reallocation.                                           */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::Resize
		( 
		void						  *Address,
		int							  NewSize,
		int							  Move,
		int							  *Space,
		bool						  NoDelete,
		bool						  Zero
		)
    {
	TRY
		{
		//
		//   A well known practice is to try to
		//   resize a null pointer.  This is really
		//   a very poor style but we support it
		//   in any case.
		//   
		if ( Address != ((void*) AllocationFailure) )
			{
			//
			//   We verify that the parameters look
			//   reasonable and the heap is not corrupt
			//   and then try to resize the supplied 
			//   allocation.
			//
			if ( (Available()) && (NewSize >= 0) )
				{
				return 
					(
					Heap -> Resize
						( 
						((VOID*) Address),
						((SBIT32) ((NewSize > 0) ? NewSize : 1)),
						((SBIT32) Move),
						((SBIT32*) Space),
						((BOOLEAN) NoDelete),
						((BOOLEAN) Zero)
						)
					);
				}
			}
		else
			{ return (New( NewSize,Space,Zero )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Special memory allocation.                                     */
    /*                                                                  */
    /*   We sometimes need to allocate some memory from the internal    */
    /*   memory allocator which lives for the lifetime of the heap.     */
    /*                                                                  */
    /********************************************************************/

void *ROCKALL::SpecialNew( int Size )
    {
	TRY
		{ 
		//
		//   We verify that the parameters look
		//   reasonable and the heap is not corrupt
		//   and then try to create the requested 
		//   allocation.
		//
		if ( (Available()) && (Size > 0) )
			{ return (Heap -> SpecialNew( ((SBIT32) Size) )); }
		} 
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return ((void*) AllocationFailure); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Truncate the heap.                                             */
    /*                                                                  */
    /*   We need to truncate the heap.  This is pretty much a null      */
    /*   call as we do this as we go along anyway.  The only thing we   */
    /*   can do is free any space the user suggested keeping earlier.   */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Truncate( int MaxFreeSpace )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ return (Heap -> Truncate( (SBIT32) MaxFreeSpace )); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Release all the heap locks.                                    */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail and exit.                        */
    /*                                                                  */
    /********************************************************************/

void ROCKALL::UnlockAll( VOID )
	{
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{ Heap -> UnlockAll(); }
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Verify a memory allocation details.                            */
    /*                                                                  */
    /*   Lets start with some basic tests.  If the address we have      */
    /*   been given is special, clearly wrong or the heap has not       */
    /*   been initialized then we fail the call appropriately.          */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Verify( void *Address,int *Space )
    {
	TRY
		{
		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			return
				(
				(Address == ((void*) AllocationFailure)) 
					||
				(Heap -> Verify( ((VOID*) Address),((SBIT32*) Space) ))
				);
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   We have been asked to walk the heap.  It is hard to know       */
    /*   why anybody might want to do this given the rest of the        */
    /*   functionality available.  Nonetheless, we just do what is      */
    /*   required to keep everyone happy.                               */
    /*                                                                  */
    /********************************************************************/

bool ROCKALL::Walk( bool *Active,void **Address,int *Space )
    {
	TRY
		{

		//
		//   The call appears to be valid so if the
		//   heap is not corrupt then pass it along
		//   for processing.
		//
		if ( Available() )
			{
			AUTO BOOLEAN NewActive;

			//
			//   Walk the active heap.
			//
			if
					(
					Heap -> Walk
						( 
						((BOOLEAN*) & NewActive),
						((VOID**) Address),
						((SBIT32*) Space) 
						)
					)
				{
				(*Active) = (NewActive != False);

				return true;
				}
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif

	return false;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the current heap.                                      */
    /*                                                                  */
    /********************************************************************/

ROCKALL::~ROCKALL( void )
	{
	TRY
		{
		//
		//   We are about to destroy a heap but before we
		//   start we make sure that the heap is not corrupt
		//   and seems to be in reasonable shape.  If not we 
		//   leave it alone to avoid possible trouble.
		//
		if ( (Available()) && (NumberOfCaches > 0) && (TotalSize > 0) )
			{
			REGISTER SBIT32 Count;

			//
			//   Execute the heap destructor.
			//
			PLACEMENT_DELETE( Heap,HEAP );

			//
			//   Execute the new page destructor.
			//
			PLACEMENT_DELETE( NewPage,NEW_PAGE );

			//
			//   Execute the find hash table destructor.
			//
			if ( GlobalDelete )
				{
				//
				//   We only delete the global find hash 
				//   table if the reference count is zero.
				//
				Spinlock.ClaimLock();

				if ( (-- ReferenceCount) == 0 )
					{ PLACEMENT_DELETE( Find,FIND ); }

				Spinlock.ReleaseLock();
				}
			else
				{ PLACEMENT_DELETE( Find,FIND ); }


			//
			//   Execute the cache destructors.
			//
			for ( Count=0;Count < NumberOfCaches;Count ++ )
				{ PLACEMENT_DELETE( & Caches[ Count ],CACHE ); }

			//
			//   Deallocate the heap structures.
			//
			DeleteArea( ((VOID*) Caches),TotalSize,False );

			//
			//   Finally, zero any remaining members.
			//   We really do not need to do this but
			//   just want to be sure that any following 
			//   calls will clearly fail.
			//
			TotalSize = 0;
			NumberOfCaches = 0;
			GuardWord = 0;
			GlobalDelete = False;

			NewPage = NULL;
			Heap = NULL;
			Find = NULL;
			Caches = NULL;
			Array = NULL;
			}
		}
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#ifdef DEBUGGING 
	catch ( FAULT Message )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable, print a
		//   suitable message and exit.
		//
		GuardWord = AllocationFailure;

		DebugPrint( "Exception caught: %s\n",(char*) Message );
		}
#endif
	catch ( ... )
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#else
	__except ( EXCEPTION_EXECUTE_HANDLER ) 
		{
		//
		//   It looks like the heap is corrupt.  So
		//   lets just mark it as unusable and exit.
		//
		GuardWord = AllocationFailure;
		}
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\windowsheap.hpp ===
#ifndef WINDOWS_HEAP_HPP 
#define WINDOWS_HEAP_HPP 1                         
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Windows.h"

#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The shadow interface.                                          */
    /*                                                                  */
    /*   The shadow interface closely resembles the NT heap interface   */
    /*   and so enables the easy porting of applications.               */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
	( 
	DWORD						  Flags,
	DWORD						  InitialSize,
	DWORD						  MaximumSize 
	);

extern "C" LPVOID WindowsHeapAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	DWORD						  Size 
	);

extern "C" UINT WindowsHeapCompact
	( 
	HANDLE						  Heap,
	DWORD						  Flags 
	);

extern "C" BOOL WindowsHeapFree
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapLock
	( 
	HANDLE						  Heap 
	);

extern "C" LPVOID WindowsHeapReAlloc
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory,
	DWORD						  Size 
	);

extern "C" VOID WindowsHeapReset
	(
	HANDLE						  Heap 
	);

extern "C" DWORD WindowsHeapSize
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapUnlock
	(
	HANDLE						  Heap 
	);

extern "C" BOOL WindowsHeapValidate
	( 
	HANDLE						  Heap,
	DWORD						  Flags,
	LPVOID						  Memory 
	);

extern "C" BOOL WindowsHeapWalk
	( 
	HANDLE						  Heap,
	LPPROCESS_HEAP_ENTRY		  Walk 
	);

extern "C" BOOL WindowsHeapDestroy
	(
	HANDLE						  Heap 
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\smpheap.hpp ===
#ifndef _SMP_HEAP_HPP_
#define _SMP_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

class LIST;
class THREAD_LOCAL_STORE;

struct CACHE_STACK;
struct THREAD_CACHE;

    /********************************************************************/
    /*                                                                  */
    /*   A SMP heap.                                                    */
    /*                                                                  */
    /*   A SMP heap is optimized for SMP performance.  Each thread      */
    /*   is given its own private cache of memory allocations which     */
    /*   it can access without claiming a lock.                         */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE SMP_HEAP : public ROCKALL
    {
		//
		//   Private data.
		//
		bool						  Active;

		int							  MaxCaches1;
		int							  MaxCaches2;
		int							  MaxSize1;
		int							  MaxSize2;
		int							  ShiftSize1;
		int							  ShiftSize2;

		LIST						  *ActiveList;
		LIST						  *FreeList;
		THREAD_LOCAL_STORE			  *Tls;

   public:
        //
        //   Public functions.
        //
        SMP_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
			( 
			void					  *Address,
			int						  Size = NoSize 
			);

		virtual void *New
			( 
			int						  Size,
			int						  *Space = NULL,
			bool					  Zero = false
			);

		virtual bool Verify
			( 
			void					  *Address = NULL,
			int						  *Space = NULL 
			);

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Truncate( int MaxFreeSpace = 0 );

		virtual bool Walk
			(
			bool					  *Active,
			void					  **Address,
			int						  *Space
			);

        ~SMP_HEAP( void );

   private:
		//
		//   Private functions.
		//
		void CreateThreadCache( void );

		void ActivateCacheStack( CACHE_STACK *CacheStack );

		CACHE_STACK *FindCache
			( 
			int						  Size,
			THREAD_CACHE			  *ThreadCache 
			);

		void FlushAllThreadCaches( void );

		void FlushThreadCache( THREAD_CACHE *ThreadCache );

		void FlushCacheStack( CACHE_STACK *CacheStack );

		bool SearchAllThreadCaches
			( 
			void					  *Address,
			int						  Size 
			);

		bool SearchThreadCache
			( 
			void					  *Address,
			int						  Size,
			THREAD_CACHE			  *ThreadCache 
			);

		bool SearchCacheStack
			( 
			void					  *Address,
			CACHE_STACK				  *CacheStack 
			);

		void DeleteThreadCache( void );

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        SMP_HEAP( const SMP_HEAP & Copy );

        void operator=( const SMP_HEAP & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\zoneheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "Assembly.hpp"
#include "Prefetch.hpp"
#include "Spinlock.hpp"
#include "ZoneHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here try to make the layout of the      */
    /*   the caches easier to understand and update.                    */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 AlignmentMask			  = (sizeof(double)-1);
CONST SBIT32 FindCacheSize			  = 2048;
CONST SBIT32 FindCacheThreshold		  = 0;
CONST SBIT32 FindSize				  = 1024;
CONST SBIT32 Stride1				  = 1024;
CONST SBIT32 Stride2				  = 1024;
CONST SBIT32 ZonePageSize			  = 4096;

    /********************************************************************/
    /*                                                                  */
    /*   The description of the heap.                                   */
    /*                                                                  */
    /*   A heap is a collection of fixed sized allocation caches.       */
    /*   An allocation cache consists of an allocation size, the        */
    /*   number of pre-built allocations to cache, a chunk size and     */
    /*   a parent page size which is sub-divided to create elements     */
    /*   for this cache.  A heap consists of two arrays of caches.      */
    /*   Each of these arrays has a stride (i.e. 'Stride1' and          */
    /*   'Stride2') which is typically the smallest common factor of    */
    /*   all the allocation sizes in the array.                         */
    /*                                                                  */
    /********************************************************************/

STATIC ROCKALL::CACHE_DETAILS Caches1[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     4096,        8,    65536,    65536 },
		{ 0,0,0,0 }
	};

STATIC ROCKALL::CACHE_DETAILS Caches2[] =
	{
	    //
	    //   Bucket   Size Of   Bucket   Parent
	    //    Size     Cache    Chunks  Page Size
		//
		{     5120,        4,    65536,    65536 },
		{     6144,        4,    65536,    65536 },
		{     7168,        4,    65536,    65536 },
		{     8192,        8,    65536,    65536 },
		{     9216,        0,    65536,    65536 },
		{    10240,        0,    65536,    65536 },
		{    12288,        0,    65536,    65536 },
		{    16384,        2,    65536,    65536 },
		{    21504,        0,    65536,    65536 },
		{    32768,        0,    65536,    65536 },

		{    65536,        0,    65536,    65536 },
		{    65536,        0,    65536,    65536 },
		{ 0,0,0,0 }
	};

    /********************************************************************/
    /*                                                                  */
    /*   The description bit vectors.                                   */
    /*                                                                  */
    /*   All heaps keep track of allocations using bit vectors.  An     */
    /*   allocation requires 2 bits to keep track of its state.  The    */
    /*   following array supplies the size of the available bit         */
    /*   vectors measured in 32 bit words.                              */
    /*                                                                  */
    /********************************************************************/

STATIC int NewPageSizes[] = { 2,0 };

    /********************************************************************/
    /*                                                                  */
    /*   Static data structures.                                        */
    /*                                                                  */
    /*   The static data structures are initialized and prepared for    */
    /*   use here.                                                      */
    /*                                                                  */
    /********************************************************************/

STATIC PREFETCH Prefetch;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   The overall structure and layout of the heap is controlled     */
    /*   by the various constants and calls made in this function.      */
    /*   There is a significant amount of flexibility available to      */
    /*   a heap which can lead to them having dramatically different    */
    /*   properties.                                                    */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::ZONE_HEAP
		( 
		int							  MaxFreeSpace,
		bool						  Recycle,
		bool						  SingleImage,
		bool						  ThreadSafe 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		ROCKALL
			(
			Caches1,
			Caches2,
			FindCacheSize,
			FindCacheThreshold,
			FindSize,
			MaxFreeSpace,
			NewPageSizes,
			Recycle,
			SingleImage,
			Stride1,
			Stride2,
			ThreadSafe
			)
	{
	AUTO ZONE NewZone = { NULL,NULL };

	//
	//   Setup the heap structures.
	//
	MaxSize = ZonePageSize;
	ThreadLocks = ThreadSafe;
	Zone = NewZone;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete all allocations.                                        */
    /*                                                                  */
    /*   Delete all the heap allocations and return all the space       */
    /*   back to the operating system.                                  */
    /*                                                                  */
    /********************************************************************/

void ZONE_HEAP::DeleteAll( bool Recycle )
    {
	AUTO ZONE Update = { NULL,NULL };

	//
	//   Delete all outstanding allocations.
	//
	ROCKALL::DeleteAll( Recycle );

	//
	//   Delete the stale zone pointers.
	//
	WriteZone( & Update );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Multiple memory allocations.                                   */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::MultipleNew
		( 
		int							  *Actual,
		void						  *Array[],
		int							  Requested,
		int							  Size,
		int							  *Space,
		bool						  Zero
		)
    {
	//
	//   We simply call 'New' to create each element
	//   for a zone heap.
	//
	for ( (*Actual)=0;(*Actual) < Requested;(*Actual) ++ )
		{
		REGISTER VOID **Current = & Array[ (*Actual) ];

		//
		//   Create an allocation.
		//
		(*Current) = (ZONE_HEAP::New( Size,Space,Zero ));

		//
		//   Exit if there is no more space.
		//
		if ( (*Current) == NULL )
			{ return false; }
		}

	return true;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Memory allocation.                                             */
    /*                                                                  */
    /*   We allocate by advancing a pinter down an array.  This         */
    /*   is very fast but means that it can not be deleted except       */
    /*   by destroying the entire heap.                                 */
    /*                                                                  */
    /********************************************************************/

void *ZONE_HEAP::New( int Size,int *Space,bool Zero )
    {
	//
	//   We would really hope that nobody would ask
	//   for a negative amount of memory but just to
	//   be sure we verify that this is not the case.
	//
	if ( Size >= 0 )
		{
		AUTO SBIT32 NewSize = ((Size + AlignmentMask) & ~AlignmentMask);
		AUTO ZONE Original;
		AUTO ZONE Update;

		//
		//   We would hope to create the allocation on the
		//   first try but there is a possibility that it
		//   may take serveral tries.
		do
			{
			//
			//   Extract a copy of the current zone pointers
			//   into local variables.
			//
			Original = Zone;
			Update = Original;

			//
			//   We need to ensure that there is enough space 
			//   in the zone for the current allocation.
			//
			if 
					( 
					(Update.Start == NULL)
						||
					((Update.Start += NewSize) > Update.End)
					)
				{
				//
				//   We do not have enough space.  If the size
				//   seems reasonable then get a new block from
				//   Rockall.  If not just pass the request along 
				//   to Rockall.
				//
				if ( NewSize <= (MaxSize / 2) )
					{
					STATIC SPINLOCK Spinlock;

					//
					//   We need to create a new zone page
					//   so claim a lock.
					//
					Spinlock.ClaimLock();

					//
					//   We may find that the zone has
					//   already been updated.  If so
					//   just exit.
					//
					if ( Update.End == Zone.End )
						{
						//
						//   Try to allocate a new zone
						//   block.
						//
						Update.Start = ((CHAR*) ROCKALL::New( MaxSize ));

						//
						//   Verify we were able to create
						//   a new zone page.
						//
						if ( Update.Start != NULL )
							{ Update.End = (Update.Start + MaxSize); }
						else
							{ Update.End = NULL; }

						//
						//   Update the zone.
						//
						WriteZone( & Update );
						}

					//
					//   Release the lock.
					//
					Spinlock.ReleaseLock();

					//
					//   If we were unable to get more
					//   space then exit.
					//
					if ( Update.Start == NULL )
						{ return NULL; }
					}
				else
					{ return (ROCKALL::New( Size,Space,Zero )); }
				}
			}
		while ( ! UpdateZone( & Original,& Update ) );

		//
		//   Prefetch the first cache line of  
		//   the allocation if we are running
		//   a Pentium III or better.
		//
		Prefetch.L1( ((CHAR*) Original.Start),1 );

		//
		//   If the caller wants to know the real 
		//   size them we supply it.
		//
		if ( Space != NULL )
			{ (*Space) = NewSize; }

		//
		//   If we need to zero the allocation
		//   we do it here.
		//
		if ( Zero )
			{ ZeroMemory( Original.Start,NewSize ); }

		//
		//   Exit and return the address.
		//
		return (Original.Start);
		}
	else
		{ return NULL; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the zone.                                               */
    /*                                                                  */
    /*   Ww update the zone when we do an allocation.  We do this       */
    /*   atomically if there are multiple threads.                      */
    /*                                                                  */
    /********************************************************************/

bool ZONE_HEAP::UpdateZone( ZONE *Original,ZONE *Update )
    {
	//
	//   Do we need to allow for multiple threads.  If 
	//   so we need to do the update atomically.  If 
	//   not then a simple assignment is fine.
	//
	if ( ThreadLocks )
		{
		REGISTER SBIT64 FinalValue =
			(
			ASSEMBLY::AtomicCompareExchange64
				(
				((SBIT64*) & Zone),
				(*((SBIT64*) Update)),
				(*((SBIT64*) Original))
				) 
			);

		return (FinalValue == (*((SBIT64*) Original)));
		}
	else
		{
		Zone = (*Update);

		return True;
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the heap.                                              */
    /*                                                                  */
    /********************************************************************/

ZONE_HEAP::~ZONE_HEAP( VOID )
	{ /* void */ }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\windowsheap.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "InterfacePCH.hpp"

#include "DefaultHeap.hpp"
#include "Global.hpp"
#include "New.hpp"
#include "WindowsHeap.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The constants supplied here are for common values.             */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoHeapSize				  = -1;
CONST SBIT32 ResizeDown				  = -64;
CONST SBIT32 StandardSize			  = (1024 * 1024);

    /********************************************************************/
    /*                                                                  */
    /*   Data structures local to the class.                            */
    /*                                                                  */
    /*   We need to keep various information along with the heap        */
    /*   so here we supply a structure to hold it all.                  */
    /*                                                                  */
    /********************************************************************/

typedef struct
    {
	DWORD							  Flags;
	DEFAULT_HEAP					  Rockall;
    }
WINDOWS_HEAP;

    /********************************************************************/
    /*                                                                  */
    /*   Create a new heap.                                             */
    /*                                                                  */
    /*   Create a new heap and prepare it for use.  If any problems     */
    /*   are encountered the request is rejected.                       */
    /*                                                                  */
    /********************************************************************/

extern "C" HANDLE WindowsHeapCreate
		( 
		DWORD					  Flags,
		DWORD					  InitialSize,
		DWORD					  MaximumSize 
		)
	{
	//
	//   We do not support all the functionality with
	//   this interface so just reject any calls that
	//   require the unsupported features.
	//
	if ( MaximumSize <= 0 ) 
		{
		REGISTER WINDOWS_HEAP *WindowsHeap = 
#ifdef NO_DEFAULT_HEAP
			((WINDOWS_HEAP*) malloc( sizeof(WINDOWS_HEAP) ));
#else
			((WINDOWS_HEAP*) DefaultHeap.New( sizeof(WINDOWS_HEAP) ));
#endif

		//
		//   If we were unable to allocate space for  
		//   the root of the heap then we exit.
		//
		if ( WindowsHeap != NULL )
			{
			//
			//   Save the flags for later calls.
			//
			WindowsHeap -> Flags = Flags;

			//
			//   Call the heap constructor. 
			//
			PLACEMENT_NEW( & WindowsHeap -> Rockall,DEFAULT_HEAP ) 
				( 
				((SBIT32) (InitialSize + StandardSize)),
				True,
				False,
				((BOOLEAN) ((Flags & HEAP_NO_SERIALIZE) == 0))
				);

			//
			//   Ensure the heap is initialized correctly.
			//
			if ( ! WindowsHeap -> Rockall.Corrupt() )
				{ return ((HANDLE) WindowsHeap); }
			else
				{ free( WindowsHeap ); }
			}
		}

	return NULL;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocate memory. .                                             */
    /*                                                                  */
    /*   Create a new memory allocation and verify it works.  if        */
    /*   not then throw an exception or return a status.                */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapAlloc( HANDLE Heap,DWORD Flags,DWORD Size )
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.New
			( 
			Size,
			NULL,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compact the heap.                                              */
    /*                                                                  */
    /*   Compact the heap by returning any unallocated space to the     */
    /*   operating system.  This can prove to be very expensive if      */
    /*   the space is later reclaimed.                                  */
    /*                                                                  */
    /********************************************************************/

extern "C" UINT WindowsHeapCompact( HANDLE Heap,DWORD Flags )
	{
	//
	//   We instruct the heap to return any available
	//   space to the operating system.  If we later
	//   choose to regain this space it is very expensive
	//   so lets hope the user knew what he was doing.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.Truncate();

	return 1;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Free memory.                                                   */
    /*                                                                  */
    /*   Free a memory allocation so that the space may be recycled     */
    /*   for subsequent memory allocation requests.                     */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapFree( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	//
	//   We release the memory allocation if it belongs to us.
	//   If not then we simply fail the request.  Regardless,
	//   we are not negatively effected either way.
	//
	return ((BOOL) ((WINDOWS_HEAP*) Heap) -> Rockall.Delete( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Lock the heap.                                                 */
    /*                                                                  */
    /*   Lock the heap by claiming all of the associated heap locks.    */
    /*   All the locks associated with a heap help make the heap        */
    /*   scale well but are a big performance hit for this type of      */
    /*   request.                                                       */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapLock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.LockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reallocate memory.                                             */
    /*                                                                  */
    /*   Reallocate a portion of memory and possibly copy the data      */
    /*   to the enlarged memory area.                                   */
    /*                                                                  */
    /********************************************************************/

extern "C" LPVOID WindowsHeapReAlloc
		( 
		HANDLE					  Heap,
		DWORD					  Flags,
		LPVOID					  Memory,
		DWORD					  Size 
		)
	{
	REGISTER DWORD AllFlags = 
		(Flags | (((WINDOWS_HEAP*) Heap) -> Flags));
	REGISTER void *NewMemory = 
		(
		((WINDOWS_HEAP*) Heap) -> Rockall.Resize
			( 
			Memory,
			Size,
			((AllFlags & HEAP_REALLOC_IN_PLACE_ONLY) ? 0 : ResizeDown),
			false,
			(AllFlags & HEAP_ZERO_MEMORY)
			)
		); 

	//
	//   If the caller has requested an exception when
	//   an error occurs.  We will generate this instead 
	//   of returning a status.
	//
	if ( (NewMemory == NULL) && (AllFlags & HEAP_GENERATE_EXCEPTIONS) )
		{ 
		SetLastError( ERROR_INVALID_PARAMETER );
		
		RaiseException( STATUS_NO_MEMORY,0,0,NULL );
		}

	return NewMemory;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset the heap.                                                */
    /*                                                                  */
    /*   Delete all outstanding memory allocations while leaving        */
    /*   the structure of the heap in place ready for new memory        */
    /*   allocation requests.                                           */
    /*                                                                  */
    /********************************************************************/

extern "C" VOID WindowsHeapReset( HANDLE Heap )
	{
	//
	//   We have been asked to delete all the outstanding 
	//   memory allocations.  This is significant and costly
	//   process.  Nonetheless, the overhead is the same as
	//   around 20-30 delete requested so it can be worthwhile
	//   in a number of cases.
	//
	((WINDOWS_HEAP*) Heap) -> Rockall.DeleteAll(); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Allocation size.                                               */
    /*                                                                  */
    /*   Although Rockall optionally supplies the allocation size       */
    /*   when a new allocation is requested.  Nonetheless, this has     */
    /*   to be done the hard way with other interfaces.                 */
    /*                                                                  */
    /********************************************************************/

extern "C" DWORD WindowsHeapSize( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{
	AUTO INT Size;

	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	if ( ((WINDOWS_HEAP*) Heap) -> Rockall.Details( Memory,& Size ) )
		{ return Size; }
	else
		{ return ((DWORD) NoHeapSize); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Unlock the heap.                                               */
    /*                                                                  */
    /*   Unlock the heap and release all the associated heap locks.     */
    /*   The multiple locks that need to be released make this quite    */
    /*   an expensive request.                                          */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapUnlock( HANDLE Heap )
	{
	//
	//   We have a whole fleet of locks assocaited with a heap.
	//   Asking to claim all of them is not smart in most cases.
	//   Nonetheless, this is part of the existing functionality
	//   so we support it.
	//
	(((WINDOWS_HEAP*) Heap) -> Rockall.UnlockAll());

	return TRUE; 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Validate the heap.                                             */
    /*                                                                  */
    /*   Validate the heap or a specific heap allocation to ensure      */
    /*   all is well.  We have to go to quite a bit of trouble to       */
    /*   figure this out so this call can be quite expensive.           */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapValidate( HANDLE Heap,DWORD Flags,LPVOID Memory )
	{ 
	//
	//   We have to go to quite a bit of trouble to figure
	//   out the allocation size.  Unlike many other allocators
	//   we only keep track of each allocations using 2 bits.  
	//   This combined with trying to establish that the allocation
	//   is not unallocated and sitting in the cache somewhere 
	//   combine to make this quite expensive.
	//
	return (((WINDOWS_HEAP*) Heap) -> Rockall.Verify( Memory )); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Walk the heap.                                                 */
    /*                                                                  */
    /*   Walk the heap and provide information about every allocated    */
    /*   and unallocated portion of memory.  Needless to say this is    */
    /*   typically a long process and the request is not cheap.         */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapWalk( HANDLE Heap,LPPROCESS_HEAP_ENTRY Walk )
	{
	AUTO bool Active;
	REGISTER BOOL Result =
		( 
		((WINDOWS_HEAP*) Heap) -> Rockall.Walk
			( 
			& Active,
			((void**) & Walk -> lpData),
			((int*) & Walk -> cbData)
			) 
		);

	//
	//   If we managed to find the next element we
	//   fill in all the other fields as needed.
	//
	if ( Result )
		{
		//
		//   Fill in all the addition fields just 
		//   to be compatible with the existing 
		//   functionality.
		//
		Walk -> cbOverhead = 0;
		Walk -> iRegionIndex = 0;
		Walk -> wFlags = 
			(
			(Active) 
				? ((WORD) PROCESS_HEAP_ENTRY_BUSY)
				: ((WORD) PROCESS_HEAP_UNCOMMITTED_RANGE)
			);
		}

	return Result;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a heap.                                                 */
    /*                                                                  */
    /*   Delete a heap and release all the associated space.            */
    /*                                                                  */
    /********************************************************************/

extern "C" BOOL WindowsHeapDestroy( HANDLE Heap )
	{
	if ( ! ((WINDOWS_HEAP*) Heap) -> Rockall.Corrupt() )
		{
		//
		//   We do not appear to have damaged the heap
		//   so it should be safe to delete it.
		//
		PLACEMENT_DELETE( & ((WINDOWS_HEAP*) Heap) -> Rockall,DEFAULT_HEAP );

#ifdef NO_DEFAULT_HEAP
		free( ((WINDOWS_HEAP*) Heap) );
#else
		DefaultHeap.Delete( ((WINDOWS_HEAP*) Heap) );
#endif

		return TRUE;
		}
	else
		{ return FALSE; }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\interface\zoneheap.hpp ===
#ifndef _ZONE_HEAP_HPP_
#define _ZONE_HEAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Rockall.hpp"

#pragma warning( disable : 4100 )

    /********************************************************************/
    /*                                                                  */
    /*   A zone heap.                                                   */
    /*                                                                  */
    /*   A zone heap simply allocates a large amount of space and       */
    /*   allocates space by advancing a pointer down an array.          */
    /*   There is no way to free space except by deleting it all.       */
    /*                                                                  */
    /********************************************************************/

class ROCKALL_DLL_LINKAGE ZONE_HEAP : public ROCKALL
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			char					  *Start;
			char					  *End;
			}
		ZONE;

		//
		//   Private data.
		//
		int 						  MaxSize;
		bool						  ThreadLocks;
		ZONE						  Zone;

   public:
        //
        //   Public functions.
        //
        ZONE_HEAP
			( 
			int						  MaxFreeSpace = 4194304,
			bool					  Recycle = true,
			bool					  SingleImage = false,
			bool					  ThreadSafe = true 
			);

		//
		//   Manipulate allocations.
		//
		//   The first group of functions manipulate 
		//   single or small arrays of allocations. 
		//
		virtual bool Delete
				( 
				void				  *Address,
				int					  Size = NoSize 
				)
			{ return false; }

		virtual bool Details
				( 
				void				  *Address,
				int					  *Space = NULL 
				)
			{ return false; }

		virtual bool MultipleDelete
				( 
				int					  Actual,
				void				  *Array[],
				int					  Size = NoSize
				)
			{ return false; }

		virtual bool MultipleNew
				( 
				int					  *Actual,
				void				  *Array[],
				int					  Requested,
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *New
				( 
				int					  Size,
				int					  *Space = NULL,
				bool				  Zero = false
				);

		virtual void *Resize
				( 
				void				  *Address,
				int					  NewSize,
				int					  Move = -64,
				int					  *Space = NULL,
				bool				  NoDelete = false,
				bool				  Zero = false
				)
			{ return NULL; }

		virtual bool Verify
				( 
				void				  *Address = NULL,
				int					  *Space = NULL 
				)
			{ return false; }

		//
		//   Manipulate the heap.
		//
		//   The second group of functions act upon a heap
		//   as a whole.
		//
		virtual void DeleteAll( bool Recycle = true );

		virtual bool Walk
				(
				bool				  *Active,
				void				  **Address,
				int					  *Space
				)
			{ return false; }

        ~ZONE_HEAP( void );

	private:
		//
		//   Private functions.
		//
		bool UpdateZone( ZONE *Original,ZONE *Update );

		//
		//   Private inline functions.
		//
		void WriteZone( ZONE *Update )
			{
			auto ZONE Original = Zone;

			while ( ! UpdateZone( & Original,Update ) ) 
				{ Original = Zone; }
			}

        //
        //   Disabled operations.
 		//
		//   All copy constructors and class assignment 
		//   operations are disabled.
        //
        ZONE_HEAP( const ZONE_HEAP & Copy );

        void operator=( const ZONE_HEAP & Copy );
    };

#pragma warning( default : 4100 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\assembly.hpp ===
#ifndef _ASSEMBLY_HPP_
#define _ASSEMBLY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The assembly constants indicate the location of the thread     */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

#define PcTeb                         0x18
#define IDTeb                         0x24

#ifdef WINDOWS_95
CONST SBIT32 TebSlot				  = 0x88;
#else
CONST SBIT32 TebSlot				  = 0xE10;
#endif

#ifndef ASSEMBLY_PREFETCH_SUPPORT
#define prefetcht0					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x08
#define prefetcht1					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x10
#define prefetcht2					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x18
#define prefetchnta					  __asm _emit 0x0f __asm _emit 0x18 __asm _emit 0x00
#endif

#pragma warning( disable : 4035 )

    /********************************************************************/
    /*                                                                  */
    /*   Assembly language for ultra high performance.                  */
    /*                                                                  */
    /*   We have coded a few functions in assembly language for         */
    /*   ultra high performance.                                        */
    /*                                                                  */
    /********************************************************************/

class ASSEMBLY
    {
    public:
        //
        //   Public inline functions.
        //
		ASSEMBLY( VOID )
			{ /* void */ }

		STATIC INLINE SBIT32 AtomicAdd
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		eax,Value					// Load the value.
				lock	xadd dword ptr[ecx],eax		// Increment the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchangeAdd
					( 
					((LPLONG) Address),
					((LONG) Value) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicCompareExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue,
				SBIT32				  Value 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the address.
				mov		edx,NewValue				// Load the new value.
				mov		eax,Value					// Load the value.
				lock	cmpxchg	dword ptr[ecx],edx	// Update the value.
				}
#else
			return 
				(
				(SBIT32) InterlockedCompareExchange
					( 
					((VOID**) Address),
					((VOID*) NewValue),
					((VOID*) Value)
					)
				);
#endif
			}
#ifdef ASSEMBLY_X86

		STATIC INLINE SBIT64 AtomicCompareExchange64
				( 
				VOLATILE SBIT64		  *Address,
				SBIT64				  NewValue,
				SBIT64				  Value 
				)
			{
			__asm
				{
				mov		esi, Address				// Load the adrress.
				mov		ebx, dword ptr NewValue[0]	// Load the new value.
				mov		ecx, dword ptr NewValue[4]	// Load the new value.
				mov		eax, dword ptr Value[0]		// Load the value.
				mov		edx, dword ptr Value[4]		// Load the value.
				lock	cmpxchg8b [esi]				// Update the value.
				}
			}
#endif

		STATIC INLINE SBIT32 AtomicDecrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,-1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Decrement value.
				dec		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedDecrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 AtomicExchange
				( 
				VOLATILE SBIT32		  *Address,
				SBIT32				  NewValue 
				)
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,NewValue				// Load the value.
				lock	xchg dword ptr[ecx],eax		// Exchange new value.
				}
#else
			return 
				(
				(SBIT32) InterlockedExchange
					( 
					((LONG*) Address),
					((LONG) NewValue) 
					)
				);
#endif
			}

		STATIC INLINE SBIT32 AtomicIncrement( VOLATILE SBIT32 *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov		ecx,Address					// Load the Address.
				mov		eax,1						// Load constant.
				lock	xadd dword ptr[ecx],eax		// Increment value.
				inc		eax							// Correct result.
				}
#else
			return ((SBIT32) InterlockedIncrement( ((LONG*) Address) ));
#endif
			}

		STATIC INLINE SBIT32 GetThreadId( VOID )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,fs:[PcTeb]				// Load TEB base address.
				mov		eax,dword ptr[eax+IDTeb]	// Load thread ID.
				}
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
#else
			return ((SBIT32) GetCurrentThreadId());
#endif
			}

		STATIC INLINE VOID PrefetchL1( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht0	[eax]					// Prefetch into the L1.
#else
				prefetcht0							// Prefetch into the L1.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL2( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht1	[eax]					// Prefetch into the L2.
#else
				prefetcht1							// Prefetch into the L2.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchL3( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetcht2	[eax]					// Prefetch into the L3.
#else
				prefetcht2							// Prefetch into the L3.
#endif
				}
#endif
			}

		STATIC INLINE VOID PrefetchNta( VOID *Address )
			{
#ifdef ASSEMBLY_X86
			__asm
				{
				mov			eax,Address				// Load Address.
#ifdef ASSEMBLY_PREFETCH_SUPPORT
				prefetchnta	[eax]					// Prefetch into the L1.
#else
				prefetchnta							// Prefetch into the L1.
#endif
				}
#endif
			}

#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
		STATIC INLINE VOID *GetTlsAddress( SBIT32 TlsOffset )
			{
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				}
			}
#endif
#endif

		STATIC INLINE VOID *GetTlsValue( SBIT32 TlsIndex,SBIT32 TlsOffset )
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		eax,[eax]					// Load TLS value.
				}
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
#else
			return (TlsGetValue( ((DWORD) TlsIndex) ));
#endif
			}

		STATIC INLINE VOID SetTlsValue
				( 
				SBIT32				  TlsIndex,
				SBIT32				  TlsOffset,
				VOID				  *NewPointer 
				)
			{
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY
			__asm
				{
				mov		eax,TlsOffset				// Load TLS offset.
				add		eax,fs:[PcTeb]				// Add TEB base address.
				mov		edx,NewPointer				// Load new TLS value.
				mov		[eax],edx					// Store new TLS value.
				}
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
#else
			(VOID) TlsSetValue( ((DWORD) TlsIndex),NewPointer );
#endif
			}

		~ASSEMBLY( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        ASSEMBLY( CONST ASSEMBLY & Copy );

        VOID operator=( CONST ASSEMBLY & Copy );
    };

#pragma warning( default : 4035 )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\align.hpp ===
#ifndef _ALIGN_HPP_
#define _ALIGN_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Alignment of structures to cache line boundaries.              */
    /*                                                                  */
    /*   This class aligns data structures to cache line boundaries.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class ALIGN
    {
        //
        //   Private data.
        //
        TYPE                          *Aligned;
        CHAR                          *Allocated;

    public:
        //
        //   Public functions.
        //
        ALIGN( VOID );

        ~ALIGN( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE *operator&( VOID )
			{ return Aligned; }

	private:
        //
        //   Disabled operations.
        //
        ALIGN( CONST ALIGN & Copy );

        VOID operator=( CONST ALIGN & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */        
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::ALIGN( VOID )
    {
    REGISTER CHAR *Address;

	//
	//   Allocate space for the data structure.
	//
	Allocated = new CHAR[ (CacheLineSize + sizeof(TYPE)) ];

	//
	//   Call the constructor to initialize the structure.
	//
    Address = ((CHAR*) ((((LONG) Allocated) + CacheLineMask) & ~CacheLineMask));

    Aligned = PLACEMENT_NEW( Address,TYPE );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the memory allocation.  This call is not thread safe   */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> ALIGN<TYPE>::~ALIGN( VOID )
    { 
	//
	//   Call the destructor for the allocated type.
	//
    PLACEMENT_DELETE( Aligned,TYPE );

	//
	//   Delete the data structure.
	//
	delete [] Allocated; 
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\autolock.hpp ===
#ifndef _AUTOLOCK_HPP_
#define _AUTOLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Automatic sharelock control.                                   */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a share lock for the duration of a block     */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_EXCLUSIVE_LOCK
    {
		//
		//   Private data.
		//
		SHARELOCK					  *Sharelock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_EXCLUSIVE_LOCK( SHARELOCK *NewSharelock,SBIT32 Sleep = INFINITE )
			{ (Sharelock = NewSharelock) -> ClaimExclusiveLock( Sleep ); }

        ~AUTO_EXCLUSIVE_LOCK( VOID )
			{ Sharelock -> ReleaseExclusiveLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_EXCLUSIVE_LOCK( CONST AUTO_EXCLUSIVE_LOCK & Copy );

        VOID operator=( CONST AUTO_EXCLUSIVE_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Automatic sharelock control.                                   */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a share lock for the duration of a block     */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_SHARE_LOCK
    {
		//
		//   Private data.
		//
		SHARELOCK					  *Sharelock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_SHARE_LOCK( SHARELOCK *NewSharelock,SBIT32 Sleep = INFINITE )
			{ (Sharelock = NewSharelock) -> ClaimShareLock( Sleep ); }

        ~AUTO_SHARE_LOCK( VOID )
			{ Sharelock -> ReleaseShareLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_SHARE_LOCK( CONST AUTO_SHARE_LOCK & Copy );

        VOID operator=( CONST AUTO_SHARE_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Automatic spinlock control.                                    */
    /*                                                                  */
    /*   We can simplify quite a bit of code using this class when we   */
    /*   only need to hold a spin lock for the duration of a block      */
    /*   or a function.                                                 */
    /*                                                                  */
    /********************************************************************/

class AUTO_SPIN_LOCK
    {
		//
		//   Private data.
		//
		SPINLOCK					  *Spinlock;

    public:
        //
        //   Public inline functions.
        //
        AUTO_SPIN_LOCK( SPINLOCK *NewSpinlock,SBIT32 Sleep = INFINITE )
			{ (Spinlock = NewSpinlock) -> ClaimLock( Sleep ); }

        ~AUTO_SPIN_LOCK( VOID )
			{ Spinlock -> ReleaseLock(); }

	private:
        //
        //   Disabled operations.
        //
        AUTO_SPIN_LOCK( CONST AUTO_SPIN_LOCK & Copy );

        VOID operator=( CONST AUTO_SPIN_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\barrier.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Barrier.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new barrier and initialize it.  This call is not      */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

BARRIER::BARRIER( VOID )
    {
    Waiting = 0;

    if ( (Semaphore = CreateSemaphore( NULL,0,MaxCpus,NULL )) == NULL)
        { Failure( "Create semaphore in constructor for BARRIER" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Synchronize Threads.                                           */
    /*                                                                  */
    /*   Synchronize a collection of threads.                           */
    /*                                                                  */
    /********************************************************************/

VOID BARRIER::Synchronize( SBIT32 Expecting )
    {
	//
	//   We make sure we are expecting at least two threads.
	//   If not then do nothing.
	//
	if ( Expecting > 1 )
		{
		//
		//   Cliam the lock.
		//
		Spinlock.ClaimLock();

		//
		//   We see if the required number of threads has
		//   arrived.
		//
		if ( Expecting > (++ Waiting) )
			{
			//
			//   We are about to sleep so drop the lock.
			//
			Spinlock.ReleaseLock();

			//
			//   The threads sleep here waiting for everyone 
			//   else to arrive.
			//
			if 
					( 
					WaitForSingleObject( Semaphore,INFINITE ) 
						!= 
					WAIT_OBJECT_0 
					)
				{ Failure( "Sleep failed in Synchronize()" ); }
			}
		else
			{
			REGISTER SBIT32 Wakeup = (Expecting-1);

			//
			//   The count of threads that have arrived is
			//   updated and the number of threads that are
			//   about to leave is updated.
			//
			Waiting -= Expecting;

			//
			//   We are about to wake up all the sleepers so 
			//   drop the lock.
			//
			Spinlock.ReleaseLock();

			//
			//   Wakeup any sleeping threads and exit.
			//
			if ( Wakeup > 0 )
				{
				if ( ! ReleaseSemaphore( Semaphore,Wakeup,NULL ) )
					{ Failure( "Wakeup failed in Synchronize()" ); }
				}
			}
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a barrier.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

BARRIER::~BARRIER( VOID )
    {
    if ( ! CloseHandle( Semaphore ) )
        { Failure( "Close semaphore in destructor for BARRIER" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\barrier.hpp ===
#ifndef _BARRIER_HPP_
#define _BARRIER_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A control barrier.                                             */
    /*                                                                  */
    /*   This class synchronizs a collection of threads.                */
    /*                                                                  */
    /********************************************************************/

class BARRIER
    {
        //
        //   Private data.
        //
        HANDLE                        Semaphore;
	    SPINLOCK					  Spinlock;
        VOLATILE LONG                 Waiting;

    public:
        //
        //   Public functions.
        //
        BARRIER( VOID );

        VOID Synchronize( SBIT32 Expecting );

        ~BARRIER( VOID );

	private:
        //
        //   Disabled operations.
        //
        BARRIER( CONST BARRIER & Copy );

        VOID operator=( CONST BARRIER & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\common.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Common.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Convert a divisor to a shift.                                  */
    /*                                                                  */
    /*   We know that we can convert any divide operation into a        */
    /*   shift when the divisor is a power of two.  This function       */
    /*   figures out whether we can do this and what the how far        */
    /*   we would need to shift.                               .        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift )
	{
	if ( Divisor > 0 )
		{
		REGISTER SBIT32 Count;

		for ( Count=0;(Divisor & 1) == 0;Count ++ )
			{ Divisor >>= 1; }

		if (Divisor == 1)
			{
			(*Shift) = Count;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Force to the next power of two.                                */
    /*                                                                  */
    /*   We know that we can do certain optimizations if certain        */
    /*   values are a power of two.  Here we force the issue by         */
    /*   rounding up the value to the next power of two.                */
    /*                                                                  */
    /********************************************************************/

SBIT32 COMMON::ForceToPowerOfTwo( SBIT32 Value )
	{
	//
	//   We ensure the value is positive if not we 
	//   simply return the identity value.
	//
	if ( Value > 1 )
		{
		//
		//   We only have to compute the next power of
		//   two if the value is not already a power
		//   of two.
		//
		if ( ! PowerOfTwo( Value ) )
			{
			REGISTER SBIT32 Count;

			for ( Count=0;Value > 0;Count ++ )
				{ Value >>= 1; }

			return (1 << Count);
			}
		else
			{ return Value; }
		}
	else
		{ return 1; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert all characters to lower case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to lower case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to lower case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::LowerCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( isupper( (*Current) ) )
			{ (*Current) = ((CHAR) tolower( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Ensure value is a power of two.                                */
    /*                                                                  */
    /*   We need to ensure that certain values are an exact power       */
    /*   of two.  If this is true then the value will be positive       */
    /*   and only 1 bit will be set.  So we shift right until we        */
    /*   find the first bit on and then the value should be one.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN COMMON::PowerOfTwo( SBIT32 Value )
	{ return ((Value & (Value-1)) == 0); }
#ifndef DISABLE_ATOMIC_FLAGS

    /********************************************************************/
    /*                                                                  */
    /*   Atomically set flags.                                          */
    /*                                                                  */
    /*   We need to atomically set some flags to prevent them being     */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags |= NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Atomically unset flags.                                        */
    /*                                                                  */
    /*   We need to atomically unset some flags to prevent them being   */
    /*   corrupted by concurrent updates.                               */
    /*                                                                  */
    /********************************************************************/

VOID COMMON::UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags )
	{
	REGISTER SBIT32 StartFlags;
	REGISTER SBIT32 ResultFlags;

	do
		{ 
		StartFlags = (*CurrentFlags);
		
		ResultFlags =
			(
			AtomicCompareExchange
				(
				CurrentFlags,
				(StartFlags &= ~NewFlags), 
				StartFlags
				)
			);
		}
	while ( StartFlags != ResultFlags );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert all characters to upper case until we find the         */
    /*   end of the string.                                             */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;(*Current) != '\0';Current ++ )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Convert to upper case.                                         */
    /*                                                                  */
    /*   Convert a fixed number of characters to upper case.            */
    /*                                                                  */
    /********************************************************************/

CHAR *COMMON::UpperCase( CHAR *Text,SBIT32 Size )
	{
	REGISTER CHAR *Current = Text;

	for ( /* void */;Size > 0;Current ++, Size -- )
		{
		if ( islower( (*Current) ) )
			{ (*Current) = ((CHAR) toupper( (*Current) )); }
		}

	return Text;
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\delay.hpp ===
#ifndef _DELAY_HPP_
#define _DELAY_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The delay constants specify the initial size of the array      */
    /*   containing the list of allocations to be deleted.              */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 BlockSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Delayed memory deletion.                                       */
    /*                                                                  */
    /*   This class provides general purpose memory delayed memory      */
    /*   deletion mechanism.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class DELAY : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Used;

        TYPE                          **Block;

    public:
        //
        //   Public functions.
        //
        DELAY( SBIT32 NewMaxSize = BlockSize );

        VOID DeferedDelete( TYPE *Memory );

        ~DELAY( VOID );

		//
		//   Public inline functions.
		//
        INLINE CONST TYPE **AllocationList( VOID )
			{ return ((CONST TYPE**) Block); };

        INLINE SBIT32 SizeOfBlock( VOID ) 
			{ return Used; }

    private:
        //
        //   Disabled operations.
        //
        DELAY( CONST DELAY & Copy );

        VOID operator=( CONST DELAY & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new block and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::DELAY( SBIT32 NewMaxSize ) 
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Used = 0;

        Block = new TYPE* [ NewMaxSize ];
#ifdef DEBUGGING
        }
    else
        { Failure( "Max size in constructor for DELAY" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Defered delete for an allocated memory block.                  */
    /*                                                                  */
    /*   An allocated memory block is registered for deletion by        */
    /*   the class destructor.                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID DELAY<TYPE,LOCK>::DeferedDelete
		( 
		TYPE						  *Memory 
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Make sure we have enough space to register this memory 
	//   block for later deletion.  If not allocate more space 
	//   and copy the existing data into the enlarged space.
	//
    if ( Used >= MaxSize )
        {
        REGISTER SBIT32 Count;
        REGISTER TYPE **NewBlock = new TYPE* [ (MaxSize *= ExpandStore) ];

        for ( Count=0;Count < Used;Count ++ )
            { NewBlock[ Count ] = Block[ Count ]; }

        delete [] Block;

        Block = NewBlock;
        }

	//
	//   Register the allocated memory block.
	//
    Block[ Used ++ ] = Memory;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an allocation.  This call is not thread safe and       */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> DELAY<TYPE,LOCK>::~DELAY( VOID )
    {
    REGISTER SBIT32 Count;

	//
	//   Delete the allocated memory blocks.
	//
    for ( Count = (Used - 1);Count >= 0;Count -- )
        { delete Block[ Count ]; }

    delete [] Block;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\environment.hpp ===
#ifndef _ENVIRONMENT_HPP_
#define _ENVIRONMENT_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Environment configuration values.                              */
    /*                                                                  */
    /*   This class provides a information about the environment.       */
    /*   The information can be accessed repeatedly with very little    */
    /*   cost as the data is slaved in static memory.                   */
    /*                                                                  */
    /********************************************************************/

class ENVIRONMENT : public ASSEMBLY
    {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		//
		//   Private structures.
		//
		typedef struct
			{
			CHAR					  *Name;
			SBIT32                    SizeOfName;
			CHAR                      *Value;
			SBIT32                    SizeOfValue;
			} 
		VARIABLE;

#endif
        //
        //   Private data.
        //
        STATIC SBIT32		          Activations;

		STATIC SBIT32                 AllocationGranularity;
        STATIC SBIT16                 NumberOfProcessors;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		STATIC CHAR                   *ProgramName;
		STATIC CHAR                   *ProgramPath;
#endif
		STATIC SBIT32                 SizeOfMemory;
		STATIC SBIT32                 SizeOfPage;
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC SBIT32                 MaxVariables;
		STATIC SBIT32                 VariablesUsed;
		STATIC VARIABLE               *Variables;
#endif

    public:
        //
        //   Public functions.
        //
        ENVIRONMENT( VOID );
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC CONST CHAR *ReadEnvironmentVariable( CONST CHAR *Name );
#endif

        ~ENVIRONMENT( VOID );

		//
		//   Public inline functions.
		//
		STATIC INLINE  SBIT32 AllocationSize(VOID ) 
			{ return AllocationGranularity; };
	
		STATIC INLINE SBIT32 CacheAlignSize( SBIT32 Size )
			{ return ((Size + CacheLineMask) & ~CacheLineMask); }

		STATIC INLINE CONST CHAR *DirectorySeperator( VOID ) 
			{ return "\\"; };

        STATIC INLINE SBIT16 NumberOfCpus( VOID ) 
			{ return NumberOfProcessors; }

		STATIC INLINE SBIT32 MemorySize( VOID ) 
			{ return SizeOfMemory; };

		STATIC INLINE SBIT32 PageSize( VOID ) 
			{ return SizeOfPage; };
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		STATIC INLINE CONST CHAR *ProgramFileName( VOID ) 
			{ return ((CONST CHAR*) ProgramName); };

		STATIC INLINE CONST CHAR *ProgramFilePath( VOID ) 
			{ return ((CONST CHAR*) ProgramPath); };
#endif

	private:
        //
        //   Disabled operations.
        //
        ENVIRONMENT( CONST ENVIRONMENT & Copy );

        VOID operator=( CONST ENVIRONMENT & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\environment.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The enviroment class slaves various information to speed       */
    /*   up access to it.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 EnvironmentCacheSize	  = 16;
CONST SBIT32 SizeOfName				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
SBIT32 ENVIRONMENT::Activations = 0;
SBIT32 ENVIRONMENT::AllocationGranularity = 0;
SBIT16 ENVIRONMENT::NumberOfProcessors = 0;
SBIT32 ENVIRONMENT::SizeOfMemory = 0;
SBIT32 ENVIRONMENT::SizeOfPage = 0;
#ifndef DISABLE_ENVIRONMENT_VARIABLES
CHAR *ENVIRONMENT::ProgramName = NULL;
CHAR *ENVIRONMENT::ProgramPath = NULL;
SBIT32 ENVIRONMENT::MaxVariables = 0;
SBIT32 ENVIRONMENT::VariablesUsed = 0;
ENVIRONMENT::VARIABLE *ENVIRONMENT::Variables = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new environment and initialize it if needed.  This    */
    /*   call is not thread safe and should only be made in a single    */
    /*   thread environment.                                            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::ENVIRONMENT( VOID )
    {
    if ( AtomicIncrement( & Activations ) == 1 )
        {
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		AUTO CHAR ProgramFullName[ SizeOfName ];
#endif
		AUTO MEMORYSTATUS MemoryStatus;
		AUTO SYSTEM_INFO SystemInformation;

		//
		//   Initialize the class members to reasonable default values.
		//
		GetSystemInfo( & SystemInformation );

		GlobalMemoryStatus( & MemoryStatus );

		AllocationGranularity = 
			((SBIT32) SystemInformation.dwAllocationGranularity);
		NumberOfProcessors = 
			((SBIT16) SystemInformation.dwNumberOfProcessors);
		SizeOfMemory = 
			((SBIT32) MemoryStatus.dwTotalPhys);
		SizeOfPage = 
			((SBIT32) SystemInformation.dwPageSize);
#ifndef DISABLE_ENVIRONMENT_VARIABLES

		//
		//   Slave interesting values like the program name and path variable.
		//
		ProgramName = NULL;
		ProgramPath = NULL;

		MaxVariables = 0;
		VariablesUsed = 0;
		Variables = NULL;

		//
		//   Get the complete file name for the current program.
		//
		if ( GetModuleFileName( NULL,ProgramFullName,SizeOfName ) > 0 )
			{
			REGISTER SBIT16 Count = (SBIT16) strlen( (char*) ProgramFullName );
			REGISTER CHAR *Characters = & ProgramFullName[ Count ];

			//
			//   Scan backwards looking for the first directory seperator.  
			//   There is guaranteed to be at least one.
			//
			for 
				( 
				/* void */;
				((Count > 0) && ((*Characters) != (*DirectorySeperator())));
				Count --, Characters -- 
				);

			(*(Characters ++)) = '\0';

			//
			//   Allocate space for the directory path and copy the  
			//   path into the newly allocated area.
			//
			ProgramPath = new CHAR [ (strlen( ((char*) ProgramFullName) )+1) ];

			if ( ProgramPath != NULL )
				{
				(VOID) strcpy
					( 
					((char*) ProgramPath),
					((char*) ProgramFullName)
					); 
				}

			//
			//   Scan the program name backwards looking for a '.'.
			//
			for 
				( 
				Count = (SBIT16) strlen( (char*) Characters );
				((Count > 0) && (Characters[ Count ] != '.'));
				Count -- 
				);

			//
			//   Remove any trailing suffix from the program name 
			//   (i.e. '*.EXE').
			//
			if ( Count > 0 )
				{ Characters[ Count ] = '\0'; }

			//
			//   Allocate space for the program name and copy the name 
			//   into the newly allocated area.
			//
			ProgramName = new CHAR [ (strlen( ((char*) Characters) )+1) ];

			if ( ProgramName != NULL )
				{
				(void) strcpy
					( 
					((char*) ProgramName),
					((char*) Characters) 
					);
				}
			}
#endif
		}
	}
#ifndef DISABLE_ENVIRONMENT_VARIABLES

    /********************************************************************/
    /*                                                                  */
    /*   Read an environment variable.                                  */
    /*                                                                  */
    /*   When we read an environment value we want to make sure that    */
    /*   it never changes and gets slaved in memory.  This routine      */
    /*   implements this functionality.                                 */
    /*                                                                  */
    /********************************************************************/

CONST CHAR *ENVIRONMENT::ReadEnvironmentVariable( CONST CHAR *Name )
	{
	if ( Activations > 0 )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 SizeOfName = (SBIT32) strlen( (char*) Name );
		REGISTER VARIABLE *Variable;
		STATIC SPINLOCK Spinlock;

		//
		//   The environment variables can only be scanned by one CPU at 
		//   a time because a second CPU might reallocate the storage 
		//   and cause the first CPU to fail.
		//
		Spinlock.ClaimLock();

		//
		//   Examine all existing environment variables looking for a 
		//   match. If a match is found return it to the caller.
		//
		for 
				( 
				Count = VariablesUsed, Variable = Variables;
				Count > 0; 
				Count --, Variable ++ 
				)
			{
			if 
					( 
					(SizeOfName == Variable -> SizeOfName) 
						&& 
					(strcmp( (char*) Name,(char*) Variable -> Name ) == 0) 
					)
				{
				Spinlock.ReleaseLock();

				return (Variable -> Value);
				}
			}

		//
		//  If we have filled up our array so we need to make it bigger.
		//  So lets check for this now.
		//
		if ( VariablesUsed >= MaxVariables )
			{
			REGISTER VARIABLE *PreviousAllocation = Variables;

			if ( MaxVariables > 0 )
				{
				Variables = 
					(
					(VARIABLE*) realloc
						( 
						(VOID*) Variables,
						((MaxVariables *= ExpandStore) * sizeof(VARIABLE)) 
						)
					);
				}
			else
				{ Variables = new VARIABLE [ EnvironmentCacheSize ]; }

			//
			//   Lets make sure we were successful.  If not we restore 
			//   the previous pointer as it is still valid.
			//
			if ( Variables == NULL )
				{
				Variables = PreviousAllocation;

				Failure( "Expand memory in ReadEnvironmentVariable" );
				}
			}

		//
		//  We know that we have enough memory to allocate another element and 
		//  that we are the only CPU in this section of code so just add the 
		//  new variable.
		//
		Variable = & Variables[ VariablesUsed ++ ];

		Variable -> SizeOfName = 
			(SBIT32) strlen( (char*) Name );
		Variable -> SizeOfValue = 
			(SBIT32) GetEnvironmentVariable( (char*) Name,"",0 );

		Variable -> Name = new CHAR [ (Variable -> SizeOfName + 1) ];
		(VOID) strcpy( (char*) Variable -> Name,(char*) Name );

		if ( Variable -> SizeOfValue > 0 )
			{
			Variable -> Value = new CHAR [ (Variable -> SizeOfValue + 1) ];

			(VOID) GetEnvironmentVariable
				( 
				(char*) Name,
				(char*) Variable -> Value,
				(int) (Variable -> SizeOfValue + 1)
				);
			}
		else
			{ Variable -> Value = NULL; }

		Spinlock.ReleaseLock();

		return (Variable -> Value);
		}
	else
		{ return NULL; }
	}
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory an environment.  This call is not thread safe and      */
    /*   should only be made in a single thread environment.            */
    /*                                                                  */
    /********************************************************************/

ENVIRONMENT::~ENVIRONMENT( VOID )
	{
    if ( AtomicDecrement( & Activations ) == 0 )
		{
#ifndef DISABLE_ENVIRONMENT_VARIABLES
		REGISTER SBIT32 Count;

		//
		//   Delete all of the environment variable names
		//   and values.
		//
		for ( Count = 0;Count < VariablesUsed;Count ++ )
			{
			REGISTER VARIABLE *Variable = & Variables[ Count ];

			delete [] Variable -> Name;

			if ( Variable -> Value != NULL )
				{ delete [] Variable -> Value; }
			}


		//
		//   Delete the environment array.
		//
		delete [] Variables;
		Variables = NULL;

		//
		//   Delete the program name and path.
		//
		if ( ProgramPath != NULL )
			{
			delete [] ProgramPath;
			ProgramPath = NULL;
			}

		if ( ProgramName != NULL )
			{
			delete [] ProgramName;
			ProgramName = NULL;
			}
#endif
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\common.hpp ===
#ifndef _COMMON_HPP_
#define _COMMON_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A collection of common functions.                              */
    /*                                                                  */
    /*   This class contains common functions that are needed           */
    /*   throughout the application.                                    */
    /*                                                                  */
    /********************************************************************/

class COMMON : public ASSEMBLY
    {
    public:
        //
        //   Public functions.
        //
		COMMON( VOID )
			{ /* void */ }

		STATIC BOOLEAN ConvertDivideToShift( SBIT32 Divisor,SBIT32 *Shift );

		STATIC SBIT32 ForceToPowerOfTwo( SBIT32 Value );

		STATIC CHAR *LowerCase( CHAR *Text );

		STATIC CHAR *LowerCase( CHAR *Text,SBIT32 Size );

		STATIC BOOLEAN PowerOfTwo( SBIT32 Value );
#ifndef DISABLE_ATOMIC_FLAGS

		STATIC VOID SetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC VOID UnsetFlags( SBIT32 *CurrentFlags,SBIT32 NewFlags );

		STATIC CHAR *UpperCase( CHAR *Text );

		STATIC CHAR *UpperCase( CHAR *Text,SBIT32 Size );
#endif

		~COMMON( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        COMMON( CONST COMMON & Copy );

        VOID operator=( CONST COMMON & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\librarypch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\hash.hpp ===
#ifndef _HASH_HPP_
#define _HASH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Include files for inherited classes.                           */
    /*                                                                  */
    /*   The include files for inherited classes are required in the    */
    /*   specification of this class.                                   */
    /*                                                                  */
    /********************************************************************/

#include "Common.hpp"
#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Macros exported from this class.                               */
    /*                                                                  */
    /*   This class has three template parameters so to make it more    */
    /*   readable a macro is specified here to simplify the code.       */
    /*                                                                  */
    /********************************************************************/

#define HASH_TEMPLATE				  class KEY,class TYPE,class LOCK 

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the map.       */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 HashSize				  = 1024;
CONST SBIT32 MinHashFree			  = (100/25);
CONST SBIT32 ValueSize				  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Hash table.                                                    */
    /*                                                                  */
    /*   This class provides general purpose hash table functions to    */
    /*   safely map sparse integer keys into some pointer or value.     */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE=NO_LOCK> class HASH : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            KEY                       Key;
            SBIT32                    Next;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxHash;
        SBIT32                        MaxValues;
        SBIT32                        ValuesUsed;

		SBIT32						  Active;
        VECTOR<SBIT32>                Hash;
		SBIT32						  HashMask;
		SBIT32						  HashShift;
        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Values;

    public:
        //
        //   Public functions.
        //
        HASH
			( 
			SBIT32                    NewMaxHash = HashSize, 
			SBIT32                    NewMaxValues = ValueSize, 
			SBIT32                    Alignment = 1 
			);

        VOID AddToHash( CONST KEY & Key, CONST TYPE & Value );

        VIRTUAL SBIT32 ComputeHashKey( CONST KEY & Key );

		BOOLEAN FindInHash( CONST KEY & Key, TYPE *Value );

		VIRTUAL BOOLEAN MatchingKeys( CONST KEY & Key1, CONST KEY & Key2 );

        VOID RemoveFromHash( CONST KEY & Key );

        ~HASH( VOID );

	private:
        //
        //   Private functions.
        //
		BOOLEAN FindHashKeyValue( CONST KEY & Key, SBIT32 **HashIndex );

		VOID Resize( VOID );

        //
        //   Disabled operations.
        //
        HASH( CONST HASH & Copy );

        VOID operator=( CONST HASH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new hash and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::HASH
		( 
		SBIT32						  NewMaxHash,
		SBIT32                        NewMaxValues,
		SBIT32                        Alignment
		) :
		//
		//   Call the constructors for the contained classes.
		//
		Hash( (COMMON::ForceToPowerOfTwo( NewMaxHash )),1,CacheLineSize ),
		FreeStack( (NewMaxValues / 2) ),
		Values( NewMaxValues,Alignment,CacheLineSize )
    {
    if 
			( 
			(NewMaxHash > 0) 
				&& 
			(
			COMMON::ConvertDivideToShift
				( 
				(COMMON::ForceToPowerOfTwo( NewMaxHash )),
				& HashMask 
				)
			)
				&&
			(NewMaxValues > 0) 
			)
        {
		REGISTER SBIT32 Count;

		//
		//   Setup the hash table size information.
		//
        MaxHash = (COMMON::ForceToPowerOfTwo( NewMaxHash ));
        MaxValues = NewMaxValues;
        ValuesUsed = 0;

		//
		//   Zero the control values compute the
		//   hash table shift values.
		//
		Active = 0;
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		for( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
        }
    else
        { Failure( "Max sizes in constructor for HASH" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add to the hash table.                                         */
    /*                                                                  */
    /*   We add an key to the hash table if it does not already exist.  */
    /*   Then we add (or update) the current value.  If the is not      */
    /*   space we expand the size of the 'Values' table.                */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::AddToHash
        (
		CONST KEY					  & Key,
        CONST TYPE					  & Value 
        )
    {
	AUTO SBIT32 *HashIndex;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	if ( ! FindHashKeyValue( Key, & HashIndex ) )
		{
		AUTO SBIT32 NewIndex;
		REGISTER VALUE *NewValue;

		//
		//   Extract a free element from the stack.
		//   If the stack is empty then allocated one
		//   from the array.
		//
		if ( ! FreeStack.PopStack( & NewIndex ) )
			{
			//
			//   If the array is full then resize it.
			//   We need to be careful here as a resize
			//   can change the address of the 'Values'
			//   array.
			//
			if ( (NewIndex = ValuesUsed ++) >= MaxValues  )
				{ Values.Resize( (MaxValues *= ExpandStore) ); }
			}

		//
		//   Add the new element into the hash table
		//   and link it into any overflow chains.
		//
		NewValue = & Values[ NewIndex ];

		Active ++;

		//
		//   Link in the new element.
		//
		NewValue -> Key = Key;
		NewValue -> Next = (*HashIndex);
		(*HashIndex) = NewIndex;
		NewValue -> Value = Value;
		}
	else
		{ Values[ (*HashIndex) ].Value = Value; }

	//
	//   If the hash table has grown too big we
	//   resize it.
	//
	if ( (Active + (MaxHash / MinHashFree)) > MaxHash )
		{ Resize(); }

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Compute the hash key.       .                                  */
    /*                                                                  */
    /*   Compute a hash value from the supplied key.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> SBIT32 HASH<KEY,TYPE,LOCK>::ComputeHashKey
        (
		CONST KEY					  & Key
        )
	{
	//
	//   When the key is larger than an integer the we need 
	//   to do a bit more work.
	//
	if ( sizeof(KEY) > sizeof(SBIT32) )
		{
		REGISTER SBIT32 HighWord = ((SBIT32) (Key >> 32));
		REGISTER SBIT32 LowWord = ((SBIT32) Key);

		//
		//   We compute the hash key using both the high
		//   and low order words.
		//
		return
			(
			(HighWord * 2964557531)
				+
			(LowWord * 2964557531)
				+
			(HighWord + LowWord)
			);
		}
	else
		{ return ((((SBIT32) Key) * 2964557531) + ((SBIT32) Key)); }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a key in the hash table.                                  */
    /*                                                                  */
    /*   Find a key in the hash table and return the associated value.  */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindInHash
        (
		CONST KEY					  & Key,
        TYPE						  *Value 
        )
    {
	AUTO SBIT32 *Index;
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the key in the hash table.
	//
	if ( (Result = FindHashKeyValue( Key,& Index )) )
		{ (*Value) = Values[ (*Index) ].Value; }

	//
	//   Release any lock we got earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the hash key value.                                       */
    /*                                                                  */
    /*   Find the value associated with the supplied hash key.          */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::FindHashKeyValue
        (
		CONST KEY					  & Key,
		SBIT32                        **Index
        )
	{
	REGISTER SBIT32 *Current;
	REGISTER VALUE *List;

	//
	//   Find the bucket in the hash table that should
	//   contain this key.
	//
	(*Index) = & Hash[ ((ComputeHashKey( Key ) >> HashShift) & HashMask) ];

	//
	//   Walk the overflow chain and look for the key.
	//
	for ( Current = (*Index);(*Current) != EndOfList;Current = & List -> Next )
		{
		List = & Values[ (*Current) ];

		//
		//   If the keys match we are out of here.
		//
		if ( MatchingKeys( Key,List -> Key ) )
			{
			(*Index) = Current;

			return True;
			}
		}

	return False;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hask keys.       .                                 */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> BOOLEAN HASH<KEY,TYPE,LOCK>::MatchingKeys
        (
		CONST KEY					  & Key1,
		CONST KEY					  & Key2
        )
	{ return (Key1 == Key2); }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a key from the hash table.                              */
    /*                                                                  */
    /*   The supplied key is removed from the hash table (if it exists) */
    /*   and the associated value is deleted.                           */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::RemoveFromHash
        (
		CONST KEY					  & Key
        )
    {
	AUTO SBIT32 *Index;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Find the key in the hash table..  If it 
	//   exists then delete it.
	//
	if ( FindHashKeyValue( Key,& Index ) )
		{
		Active --;

		FreeStack.PushStack( (*Index) );

		(*Index) = Values[ (*Index) ].Next;
		}

	//
	//   Release any lock we got earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize the hash table.                                         */
    /*                                                                  */
    /*   The hash table is resized if it becomes more than 75% full     */
    /*   and all the keys are rehashed.                                 */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> VOID HASH<KEY,TYPE,LOCK>::Resize( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 List = EndOfList;

	//
	//   Walk the hash table and link all the active
	//   values into a single linked list.
	//
	for ( Count=0;Count < MaxHash;Count ++ )
		{
		REGISTER SBIT32 Start = Hash[ Count ];

		//
		//   We know that some of the hash buckets may
		//   be empty so we skip these.
		//
		if ( Start != EndOfList )
			{
			REGISTER SBIT32 Last = Start;

			//
			//   Walk along the overflow chain until
			//   we find the end.
			//
			while ( Values[ Last ].Next != EndOfList )
				{ Last = Values[ Last ].Next; }
			
			//
			//   Add the list on the front of the new
			//   global list.
			//   
			Values[ Last ].Next = List;
			List = Start;
			}
		}

	//
	//   Resize the hash table.
	//
	Hash.Resize( (MaxHash *= ExpandStore) );

    if ( COMMON::ConvertDivideToShift( MaxHash,& HashMask ) )
        {
		REGISTER SBIT32 Count;

		//
		//   Update the shift values.
		//
		HashShift = (32-HashMask);
		HashMask = ((1 << HashMask)-1);

		//
		//   Zero the resized table.
		//  
		for ( Count=0;Count < MaxHash;Count ++ )
			{ Hash[ Count ] = EndOfList; }
		}
	else
		{ Failure( "Hash size in Resize" ); }

	//
	//   Rehash all the existing values.
	//
	while ( List != EndOfList )
		{
		AUTO SBIT32 *Index;
		REGISTER VALUE *Current = & Values[ List ];
		REGISTER SBIT32 Next = Current -> Next;

		if ( ! FindHashKeyValue( Current -> Key,& Index ) )
			{
			Current -> Next = (*Index);
			(*Index) = List;
			List = Next;
			}
		else
			{ Failure( "Duplicate hash key in Risize" ); }
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the hash.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <HASH_TEMPLATE> HASH<KEY,TYPE,LOCK>::~HASH( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\features.hpp ===
#ifndef _FEATURES_HPP_
#define _FEATURES_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Active project list.	 							            */
    /*                                                                  */
    /*   The active project list contains all of the projects that      */
    /*   are currently selected.                                        */
    /*                                                                  */
    /********************************************************************/

#define ROCKALL_II					  1

    /********************************************************************/
    /*                                                                  */
    /*   Active fetaure lists.	 							            */
    /*                                                                  */
    /*   The active features list contain all of the features that      */
    /*   are currently selected for each project.                       */
    /*                                                                  */
    /********************************************************************/

#ifdef PIPELINE_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

#ifdef ROCKALL_II
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_HEAP_STATISTICS        1
#endif
#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_GLOBAL_NEW			  1
#endif

#ifdef WEB_SERVER
#ifdef DEBUGGING
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define PRINT_ACTIVE_PACKETS		  1
#endif
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The complete feature list.							            */
    /*                                                                  */
    /*   The code supports a significant number of optional features    */
    /*   which are listed in this file.  Any feature can be activated   */
    /*   by copying the approriate setting.  Please be sure to keep     */
    /*   all the flags up to date and leave at list one copy of each    */
    /*   flag below.                                                    */
    /*                                                                  */
    /********************************************************************/

#ifdef ACTIVATE_ALL_OPTIONS
	//
	//   Standard options for all code.
	//
#define ASSEMBLY_X86				  1
#define DEBUGGING                     1

#define DISABLE_GLOBAL_NEW			  1
#define DISABLE_PRECOMPILED_HEADERS	  1
#define DISABLE_STRUCTURED_EXCEPTIONS 1

	//
	//   Standard options for the library code.
	//
#define ENABLE_DEBUG_FILE             1
#define ENABLE_LOCK_STATISTICS		  1
#define ENABLE_NON_STANDARD_ASSEMBLY  1
#define ENABLE_RECURSIVE_LOCKS		  1

#define DISABLE_ATOMIC_FLAGS		  1
#define DISABLE_ENVIRONMENT_VARIABLES 1
#define DISABLE_STRING_LOCKS		  1

	//
	//   Rockall specific options.
	//
#define COMPILING_ROCKALL_DLL		  1
#define COMPILING_ROCKALL_LIBRARY	  1
#define ENABLE_ALLOCATION_STATISTICS  1
#define ENABLE_HEAP_STATISTICS        1
#define NO_DEFAULT_HEAP				  1

	//
	//   Pipeline Server specific options.
	//
#define ENABLE_BUFFER_LOCK			  1
#define ENABLE_ZERO_WRITE_BUFFER	  1

#define PRINT_ACTIVE_PACKETS		  1

	//
	//   Pipeline Server demo specific options.
	//
#define ENABLE_DATABASE				  1
#define ENABLE_READING				  1
#define ENABLE_TRANSACTIONS			  1
#define ENABLE_WRITING				  1

	//
	//   Web Server specific options.
	//
#define DISABLE_ASYNC_IO			  1
#define DISABLE_BUFFER_COPY			  1
#define DISABLE_WEB_LOCKS			  1
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\librarypch.hpp ===
#ifndef _LIBRARY_PCH_HPP_
#define _LIBRARY_PCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#ifndef DISABLE_PRECOMPILED_HEADERS
#include "Align.hpp"
#include "Assembly.hpp"
#include "Autolock.hpp"
#include "Barrier.hpp"
#include "Common.hpp"
#include "Delay.hpp"
#include "Environment.hpp"
#include "Global.hpp"
#include "Hash.hpp"
#include "List.hpp"
#include "Lock.hpp"
#include "Map.hpp"
#include "New.hpp"
#include "Pool.hpp"
#include "Prefetch.hpp"
#include "Queue.hpp"
#include "Sharelock.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Standard.hpp"
#include "String.hpp"
#include "System.hpp"
#include "Thread.hpp"
#include "Tls.hpp"
#include "Unique.hpp"
#include "Vector.hpp"
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\list.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "List.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new linked list element.                              */
    /*                                                                  */
    /********************************************************************/

LIST::LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete an element.                                             */
    /*                                                                  */
    /*   Delete the current element.                                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Delete( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == HeadOfList )
		{
#endif
		//
		//   Relink the forward chain.
		//
		if ( Forward != NULL )
			{ Forward -> Backward = Backward; }
		else
			{ HeadOfList -> Backward = Backward; }

		//
		//   Relink the backward chain.
		//
		if ( Backward != NULL )
			{ Backward -> Forward = Forward; }
		else
			{ HeadOfList -> Forward = Forward; }

		//
		//   Reset the list elements.
		//
		Forward = NULL;
		Backward = NULL;
#ifdef DEBUGGING
		Head = NULL;
		}
	else
		{ Failure( "No active linked list element in Delete" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a list element at the head of the list.                 */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Insert( LIST *HeadOfList )
	{
#ifdef DEBUGGING
	if ( Head == NULL )
		{
#endif
		//
		//   Insert the new element at the front of the list.
		//
		if ( (Forward = HeadOfList -> Forward) == NULL )
			{ 
			HeadOfList -> Forward = this;
			HeadOfList -> Backward = this; 
			}
		else
			{ 
			HeadOfList -> Forward -> Backward = this; 
			HeadOfList -> Forward = this;
			}

		//
		//   Set the other pointers as needed.
		//
		Backward = NULL;
#ifdef DEBUGGING
		Head = HeadOfList;
		}
	else
		{ Failure( "List element already in use in Insert" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert a list element.                                         */
    /*                                                                  */
    /*   Insert a new list element before the current element.          */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertBefore( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a previous element we must
				//   make it point at the new element.  If
				//   not we are the first element in the 
				//   list so update the head.
				//
				if ( Backward != NULL )
					{ Backward -> Forward = NewList; }
				else
					{ HeadOfList -> Forward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Backward = Backward;
				NewList -> Forward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Backward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertBefore" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertBefore" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Insert an element.                                             */
    /*                                                                  */
    /*   Insert a new list element after the current element.           */
    /*                                                                  */
    /********************************************************************/

VOID LIST::InsertAfter( LIST *HeadOfList,LIST *NewList )
	{
#ifdef DEBUGGING
	if ( NewList -> Head == NULL )
		{
#endif
		if ( HeadOfList -> Forward == NULL )
			{
			//
			//   When the list is empty then add the 
			//   new element at the start of the list.
			//
			HeadOfList -> Forward = NewList;
			HeadOfList -> Backward = NewList;

			NewList -> Forward = NULL;
			NewList -> Backward = NULL;
#ifdef DEBUGGING
			NewList -> Head = HeadOfList;
#endif
			}
		else
			{
#ifdef DEBUGGING
			//
			//   We want to be sure that we consistently 
			//   get the same list head otherwise the list 
			//   may become corrupted.
			//
			if ( Head == HeadOfList )
				{
#endif
				//
				//   If there is a next element we must
				//   make it point at the new element.  If
				//   not we are the last element in the 
				//   list so update the head.
				//
				if ( Forward != NULL )
					{ Forward -> Backward = NewList; }
				else
					{ HeadOfList -> Backward = NewList; }

				//
				//   Link the new element into the list and
				//   update the current element to point to
				//   it.
				//
				NewList -> Forward = Forward;
				NewList -> Backward = this;
#ifdef DEBUGGING
				NewList -> Head = HeadOfList;
#endif

				Forward = NewList;
				}
#ifdef DEBUGGING
			else
				{ Failure( "No active linked list element in InsertAfter" ); }
			}
		}
	else
		{ Failure( "List element already in use in InsertAfter" ); }
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Reset a list element.                                          */
    /*                                                                  */
    /*   Reset a list element without any questions.                    */
    /*                                                                  */
    /********************************************************************/

VOID LIST::Reset( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a linked list element.                                 */
    /*                                                                  */
    /********************************************************************/

LIST::~LIST( VOID )
    {
	Forward = NULL;
	Backward = NULL;
#ifdef DEBUGGING
	Head = NULL;
#endif
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\global.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Debug printing.                                                */
    /*                                                                  */
    /*   We sometimes need to print message during debugging. We        */
    /*   do this using the following 'printf' like function.            */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... )
	{
	AUTO CHAR Buffer[ DebugBufferSize ];
#ifdef ENABLE_DEBUG_FILE
	STATIC FILE *DebugFile = NULL;
#endif


	//
	//   Start of variable arguments.
	//
	va_list Arguments;

	va_start(Arguments, Format);

	//
	//   Format the string to be printed.
	//
	(VOID) _vsnprintf( Buffer,(DebugBufferSize-1),Format,Arguments );

	//
	//   Force null termination.
	//
	Buffer[ (DebugBufferSize-1) ] = '\0';

#ifdef ENABLE_DEBUG_FILE
	//
	//   Write to the debug file.
	//
	if ( DebugFile == NULL )
		{
		if ( (DebugFile = fopen( "C:\\DebugFile.TXT","a" )) == NULL )
			{ Failure( "Debug file could not be opened" ); }
		}

	fputs( Buffer,DebugFile );

	fflush( DebugFile );
#else
	//
	//   Write the string to the debug file.
	//
	OutputDebugString( Buffer );
#endif

	//
	//   End of variable arguments.
	//
	va_end( Arguments );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Software failure.                                              */
    /*                                                                  */
    /*   We know that when this function is called the application      */
    /*   has failed so we simply try to cleanly exit in the vain        */
    /*   hope that the failure can be caught and corrected.             */
    /*                                                                  */
    /********************************************************************/

VOID Failure( char *Message )
	{
#ifdef DISABLE_STRUCTURED_EXCEPTIONS
	throw ((FAULT) Message);
#else
	RaiseException( 1,0,1,((CONST DWORD*) Message) );
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\global.hpp ===
#ifndef _GLOBAL_HPP_
#define _GLOBAL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Features.hpp"
#include "Standard.hpp"
#include "System.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The standard macros.                                           */
    /*                                                                  */
    /*   The following are standard macros used by various              */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

#define FIELDOFFSET( Type,Field )	  ((SBIT16) & (((Type *)0) -> Field))
#define TO_DO( Message ) message ( "---- To do ---->>>> " Message )

#ifdef DISABLE_STRUCTURED_EXCEPTIONS
#define TRY							  try
#else
#define TRY							  __try
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The standard constants.                                        */
    /*                                                                  */
    /*   The following are standard constants used by various           */
    /*   classes in this program.                                       */
    /*                                                                  */
    /********************************************************************/

	//
	//   The hardware cache line size.
	//
CONST SBIT32 CacheLineSize			  = 32;
CONST SBIT32 CacheLineMask			  = (CacheLineSize - 1);
CONST SBIT32 NoAlignment			  = 1;

	//
	//   The end of a linked list.
	//
CONST INT EndOfList					  = -1;

	//
	//   The boolean constants.
	//
CONST BOOLEAN False					  = 0;
CONST BOOLEAN True					  = 1;

	//
	//   Various misc constants.
	//
CONST INT DebugBufferSize			  = 8192;
CONST INT ExpandStore				  = 2;
CONST INT MaxCpus					  = 32;
CONST INT NoFlags					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   The standard functions.                                        */
    /*                                                                  */
    /*   The following are standard functions used by various           */
    /*   classes in multiple applications.                              */
    /*                                                                  */
    /********************************************************************/

VOID DebugPrint( CONST CHAR *Format,... );

VOID Failure( char *Message );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\list.hpp ===
#ifndef _LIST_HPP_
#define _LIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A generic linked list.                                         */
    /*                                                                  */
    /*   There are a significant number of situations where objects     */
    /*   need to be linked together.  The objects may be of the same    */
    /*   or diffrent types so the class specified here is intended      */
    /*   to be used as base class so as to make supporting this easy.   */
    /*                                                                  */
    /********************************************************************/

class LIST
    {
		//
		//   Private data.
		//
 		LIST						  *Backward;
 		LIST						  *Forward;
#ifdef DEBUGGING
		LIST						  *Head;
#endif

   public:
        //
        //   Public functions.
        //
        LIST( VOID );

		VOID Delete( LIST *HeadOfList );

		VOID Insert( LIST *HeadOfList );

		VOID InsertBefore( LIST *HeadOfList,LIST *NewList );

		VOID InsertAfter( LIST *HeadOfList,LIST *NewList );

		VOID Reset( VOID );

        ~LIST( VOID );

		//
		//   Public line functions.
		//
		INLINE BOOLEAN StartOfList( VOID )
			{ return (Backward == NULL); }

		INLINE LIST *First( VOID )
			{ return Forward; }

		INLINE LIST *Last( VOID )
			{ return Backward; }

		INLINE LIST *Next( VOID )
			{ return Forward; }

		INLINE LIST *Previous( VOID )
			{ return Backward; }

		INLINE BOOLEAN EndOfList( VOID )
			{ return (Forward == NULL); }

	private:
        //
        //   Disabled operations.
        //
        LIST( CONST LIST & Copy );

        VOID operator=( CONST LIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\lock.hpp ===
#ifndef _LOCKS_HPP_
#define _LOCKS_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Sharelock.hpp"
#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Full lock structure.                                           */
    /*                                                                  */
    /*   This class provides an full locking mechanism for a            */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class FULL_LOCK
    {
        //
        //   Private data.
        //
		SHARELOCK                     ShareLock;

    public:
        //
        //   Public inline functions.
        //
        FULL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) ShareLock.ClaimExclusiveLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) ShareLock.ClaimShareLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) ShareLock.ReleaseExclusiveLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) ShareLock.ReleaseShareLock(); }

        ~FULL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        FULL_LOCK( CONST FULL_LOCK & Copy );

        VOID operator=( CONST FULL_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   No lock structure.                                             */
    /*                                                                  */
    /*   This class provides a default locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class NO_LOCK
    {
    public:
        //
        //   Public inline functions.
        //
        NO_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ /* void */ }

        INLINE VOID ClaimSharedLock( VOID )
			{ /* void */ }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ /* void */ }

		INLINE VOID ReleaseSharedLock( VOID )
 			{ /* void */ }

        ~NO_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        NO_LOCK( CONST NO_LOCK & Copy );

        VOID operator=( CONST NO_LOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Partial lock structure.                                        */
    /*                                                                  */
    /*   This class provides a partial locking mechanism for a          */
    /*   collection of higher level classes.                            */
    /*                                                                  */
    /********************************************************************/

class PARTIAL_LOCK
    {
        //
        // Private structures.
        //
		SPINLOCK                      Spinlock;

    public:
        //
        //   Public inline functions.
        //
        PARTIAL_LOCK( VOID )
			{ /* void */ }

        INLINE VOID ClaimExclusiveLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ClaimSharedLock( VOID )
			{ (VOID) Spinlock.ClaimLock(); }

        INLINE VOID ReleaseExclusiveLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

		INLINE VOID ReleaseSharedLock( VOID )
			{ (VOID) Spinlock.ReleaseLock(); }

        ~PARTIAL_LOCK( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PARTIAL_LOCK( CONST PARTIAL_LOCK & Copy );

        VOID operator=( CONST PARTIAL_LOCK & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\new.hpp ===
#ifndef _NEW_HPP_
#define _NEW_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   The placement new and delete macros.                           */
    /*                                                                  */
    /*   The placement new and delete macros allow the constructor      */
    /*   and destructos of a type to be called as needed.               */
    /*                                                                  */
    /********************************************************************/

#define PLACEMENT_NEW( Address,Type )		new( Address ) Type
#define PLACEMENT_DELETE( Address,Type )	(((Type*) Address) -> ~Type())
#ifndef DISABLE_GLOBAL_NEW

    /********************************************************************/
    /*                                                                  */
    /*   The memory allocation operator.                                */
    /*                                                                  */
    /*   The memory allocation operator 'new' is overloaded to          */
    /*   provide a consistent interface.                                */
    /*                                                                  */
    /********************************************************************/

INLINE VOID *operator new( size_t Size )
    {
    REGISTER VOID *Store = malloc( Size );

    if ( Store == NULL )
        { Failure( "Out of system memory" ); }

    return Store;
    }

    /********************************************************************/
    /*                                                                  */
    /*   The memory deallocation operator.                              */
    /*                                                                  */
    /*   The memory deallocation operator releases allocated memory.    */
    /*                                                                  */
    /********************************************************************/

INLINE VOID operator delete( VOID *Store )
    { free( Store ); }
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\pool.hpp ===
#ifndef _POOL_HPP_
#define _POOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Delay.hpp"
#include "Lock.hpp"
#include "New.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinPoolSize			  = 64;
CONST SBIT16 PoolStackSize			  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class POOL : public LOCK
    {
		//
		//   Private type definitions.
		//
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        DELAY< VECTOR<TYPE_SIZE> >    Delay;
		STACK<POINTER>				  Stack;

    public:
        //
        //   Public functions.
        //
        POOL( SBIT32 NewMinSize = MinPoolSize );

        TYPE **MultiplePopPool
            ( 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID MultiplePushPool
            ( 
            CONST TYPE					  *Type[], 
            CONST SBIT32				  Size 
            );

        TYPE *PopPool( VOID );

        VOID PushPool( CONST TYPE *Type );

        ~POOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 MaxSize );

        //
        //   Disabled operations.
        //
        POOL( CONST POOL & Copy );

        VOID operator=( CONST POOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::POOL( SBIT32 NewMinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMinSize )
    {
#ifdef DEBUGGING
    if ( NewMinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        MaxSize = 0;
        MinSize = NewMinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "Min size in constructor for POOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID POOL<TYPE,LOCK>::ExpandSize
		( 
		SBIT32						  NewSize 
		)
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	REGISTER SBIT32 ActualSize =
		((NewSize <= MinSize) ? MinSize : NewSize);
	REGISTER VECTOR<TYPE> *NewBlock =
		(
		(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
			( 
			ActualSize, 
			CacheLineSize,
			CacheLineSize
			)
		);

	//
	//   We need to keep a note of the number of elements 
	//   we have allocated thus far.
	//
    MaxSize += ActualSize;

	//
	//   We put the address of each element we allocate on
	//   a stack to enable high speed allocation and 
	//   deallocation.
	//
    for 
			( 
			Count1 = 0;
			Count1 < ActualSize;
			Count1 += PoolStackSize 
			)
        {
		AUTO POINTER NewCalls[ PoolStackSize ];

		//
		//   We add elements to the stack in blocks
		//   to reduce the number of call to the
		//   stack code.
		//
        for 
				( 
				Count2 = 0;
				((Count1 + Count2) < ActualSize)
					&&
				(Count2 < PoolStackSize);
				Count2 ++ 
				)
            {
			REGISTER TYPE *NewCall =
				(
                & (*NewBlock)[ (Count1 + Count2) ]
				);
                 
            NewCalls[ Count2 ] = (POINTER) NewCall;
            }

		//
		//   Add the next block for free work packets to
		//   the global free stack.
		//
        Stack.MultiplePushStack
            ( 
            NewCalls,
            Count2 
            );
        }

    //
    //   Add the newly allocated block to the list of
    //   things to be deleted when this class is deleted.
    //
    Delay.DeferedDelete( ((VECTOR<TYPE_SIZE>*) NewBlock) );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We allocate a multiple elements from the allocation pool.      */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE **POOL<TYPE,LOCK>::MultiplePopPool
        ( 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	AUTO TYPE *Type[ PoolStackSize ];
	REGISTER SBIT32 Count;

	//
	//   Compute the actual request size.
	//
	Requested = ((Requested <= PoolStackSize) ? Requested : PoolStackSize);

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Extract as may elements from the stack as possible.
	//   If the stack is empty then allocate more.
	//
	while ( ! Stack.MultiplePopStack( Requested,(POINTER*) Type,Size ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructors.
	//
	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We push multiple existing elements into the pool for reuse.    */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::MultiplePushPool
        ( 
        CONST TYPE					  *Type[],
        CONST SBIT32				  Size 
        )
	{
	REGISTER SBIT32 Count;
	
	//
	//   Call the destructors.
	//
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Type[ Count ],TYPE ); }


	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the elements back onto the free stack.
	//
	Stack.MultiplePushStack( (POINTER*) Type,Size ); 

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We allocate a new element from the allocation pool.            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE TYPE *POOL<TYPE,LOCK>::PopPool( VOID )
    {
	AUTO TYPE *Type;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   We pop an element off the stack if the
	//   stack is empty we create more elements.
	//
	while ( ! Stack.PopStack( (POINTER*) & Type ) )
		{ ExpandSize( MaxSize ); }

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	//
	//   Call the constructor.
	//
	(VOID) PLACEMENT_NEW( Type, TYPE );

	return Type;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We push an existing element into the pool for reuse.           */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> INLINE VOID POOL<TYPE,LOCK>::PushPool
		( 
		CONST TYPE					  *Type 
		)
	{
	//
	//   Call the destructor.
	//
	PLACEMENT_DELETE( Type,TYPE );

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   Push the element back onto the free stack.
	//
	Stack.PushStack( (POINTER) Type );

	//
	//   Release and lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> POOL<TYPE,LOCK>::~POOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\map.hpp ===
#ifndef _MAP_HPP_
#define _MAP_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The map constants specify the initial size of the map.         */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MapSize				  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Maps and map management.                                       */
    /*                                                                  */
    /*   This class provides general purpose mapping functions to       */
    /*   safely convert handles into some pointer or value.             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class MAP : public LOCK
    {
        //
        //   Private structures.
        //
        typedef struct
            {
            BOOLEAN                   Available;
            TYPE                      Value;
            }
        VALUE;

        //
        //   Private data.
        //
        SBIT32                        MaxMap;
        SBIT32                        MapUsed;

        STACK<SBIT32>                 FreeStack;
        VECTOR<VALUE>                 Map;

    public:
        //
        //   Public functions.
        //
        MAP( SBIT32 NewMaxMap = MapSize, SBIT32 Alignment = 1 );

        SBIT32 NewHandle( CONST TYPE & Value );

		BOOLEAN FindHandle
			( 
			SBIT32                        Handle, 
			TYPE                          *Value 
			);

		VOID DeleteHandle( SBIT32 Handle );

        ~MAP( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 MaxHandles( VOID )
			{ return MapUsed; }

	private:
        //
        //   Disabled operations.
        //
        MAP( CONST MAP & Copy );

        VOID operator=( CONST MAP & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new map and prepare it for use.  This call is         */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::MAP
		( 
		SBIT32						  NewMaxMap,
		SBIT32						  Alignment 
		) :
		//
		//   Call the constructors for the contained classes.
		//
		FreeStack( NewMaxMap ), 
		Map( NewMaxMap,Alignment,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxMap > 0 )
        {
#endif
        MaxMap = NewMaxMap;
        MapUsed = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Max map size in constructor for MAP" ); }
#endif
    }

	/********************************************************************/
    /*                                                                  */
    /*   Create a new handle.                                           */
    /*                                                                  */
    /*   We create a new handle for the supplied value.                 */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 MAP<TYPE,LOCK>::NewHandle
		( 
		CONST TYPE					  & Value 
		)
    {
	AUTO SBIT32 Handle;
	REGISTER VALUE *NewValue;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Expand the mapping table if it is too
	//   small be resizing it.
	//
	if ( ! FreeStack.PopStack( & Handle ) )
		{
		if ( (Handle = MapUsed ++) >= MaxMap )
			{ Map.Resize( (MaxMap *= ExpandStore) ); }
		}

	//
	//   Link in the new mapping.
	//
	NewValue = & Map[ Handle ];

	NewValue -> Available = True;
	NewValue -> Value = Value;

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();

	return Handle;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Find the value associated with a handle.                       */
    /*                                                                  */
    /*   We find the value associated with the supplied handle.         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN MAP<TYPE,LOCK>::FindHandle
        ( 
        SBIT32                        Handle, 
        TYPE                          *Value 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Find the handle and return the associated value.
	//
	Result = 
		( 
		((Handle >= 0) && (Handle < MaxMap))
			&& 
		(Map[ Handle ].Available) 
		);

	if ( Result )
		{ (*Value) = Map[ Handle ].Value; }

	//
	//   Release any lock claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Delete a handle.                                               */
    /*                                                                  */
    /*   We delete the supplied handle and the associated value.        */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID MAP<TYPE,LOCK>::DeleteHandle
		( 
        SBIT32                        Handle
		)
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the handle is valid then delete any
	//   associated value.
	//
	if ( (Handle >= 0) && (Handle < MaxMap) && (Map[ Handle ].Available) )
		{
		Map[ Handle ].Available = False;
		FreeStack.PushStack( Handle );
		}
	else
		{ Failure( "No mapping in DeleteMapHandle()" ); } 

	//
	//   Release any lock claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the map.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> MAP<TYPE,LOCK>::~MAP( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\prefetch.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Prefetch.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
BOOLEAN PREFETCH::Active =
	(
	(BOOLEAN) IsProcessorFeaturePresent
		( 
		PF_XMMI_INSTRUCTIONS_AVAILABLE
		)
	);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\sharelock.hpp ===
#ifndef _SHARELOCK_HPP_
#define _SHARELOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Sharelock and Semaphore locking.                               */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  A lock can be obtained in         */
    /*   either exclusive mode or shared mode.  If the lock is not      */
    /*   available the caller waits by spinning or if that fails        */
    /*   by sleeping.                                                   */
    /*                                                                  */
    /********************************************************************/

class SHARELOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32                        MaxSpins;
		SBIT32                        MaxUsers;

        VOLATILE SBIT32               Exclusive;
        VOLATILE SBIT32               TotalUsers;

#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalExclusiveLocks;
        VOLATILE SBIT32               TotalShareLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SHARELOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE VOID ChangeExclusiveLockToSharedLock( VOID );

        INLINE BOOLEAN ChangeSharedLockToExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimExclusiveLock( SBIT32 Sleep = INFINITE );

        INLINE BOOLEAN ClaimShareLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseExclusiveLock( VOID );

        INLINE VOID ReleaseShareLock( VOID );

        BOOLEAN UpdateMaxSpins( SBIT32 NewMaxSpins );

        BOOLEAN UpdateMaxUsers( SBIT32 NewMaxUsers );

        ~SHARELOCK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 ActiveUsers( VOID ) 
			{ return (SBIT32) TotalUsers; }

    private:
        //
        //   Private functions.
        //
		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

        BOOLEAN SleepWaitingForLock( SBIT32 Sleep );

		VOID UpdateSemaphore( VOID );

        BOOLEAN WaitForExclusiveLock( SBIT32 Sleep );

        BOOLEAN WaitForShareLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SHARELOCK( CONST SHARELOCK & Copy );

        VOID operator=( CONST SHARELOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Change an exclusive lock to a shared lock.                     */
    /*                                                                  */
    /*   Downgrade the existing exclusive lock to a shared lock.        */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ChangeExclusiveLockToSharedLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Simply decrement the exclusive count.
		//   This allows the lock to be shared.
		//
		(VOID) AtomicDecrement( & Exclusive );
#ifdef ENABLE_RECURSIVE_LOCKS
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Change a shared lock to an exclusive lock.                     */
    /*                                                                  */
    /*   Upgrade the existing shared lock to an exclusive lock.         */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ChangeSharedLockToExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif		
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared.
		//
		(VOID) AtomicIncrement( & Exclusive );

		//
		//   If the total number of users is one then
		//   we have the lock exclusively otherwise we
		//   may need to wait.
		//
		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim an exclusive lock.                                       */
    /*                                                                  */
    /*   Claim an exclusive lock if available else wait or exit.        */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimExclusiveLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the exclusive count
		//   to prevent the lock from being shared and
		//   the total number of users count.
		//
		(VOID) AtomicIncrement( & Exclusive );
		(VOID) AtomicIncrement( & TotalUsers );

		if ( TotalUsers != 1 )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForExclusiveLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new exclusive owner
		//   of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalExclusiveLocks );
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim a shared lock.                                           */
    /*                                                                  */
    /*   Claim a shared lock if available else wait or exit.            */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SHARELOCK::ClaimShareLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own an exclusive lock. If so 
	//   we increment the recursive count otherwise 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   We need to increment the total number of 
		//   users count to prevent the lock from being 
		//   claimed for exclusive use.
		//
		(VOID) AtomicIncrement( & TotalUsers );

		if ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
			{
			//
			//   We have to wait.  If we are not allowed 
			//   to sleep or we have timed out then exit.
			//
			if ( ! WaitForShareLock( Sleep ) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalShareLocks );
#endif

	return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release an exclusive lock.                                     */
    /*                                                                  */
    /*   Release an exclusive lock and if needed wakeup any sleepers.   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseExclusiveLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();

#endif
		//
		//   Release an exclusive lock.
		//
#ifdef DEBUGGING
		if
				(
				(AtomicDecrement( & TotalUsers ) < 0)
					||
				(AtomicDecrement( & Exclusive ) < 0)
				)
			{ Failure( "Negative lock count in ReleaseExclusiveLock" ); }
#else
			AtomicDecrement( & TotalUsers );
			AtomicDecrement( & Exclusive );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Release a shared lock.                                         */
    /*                                                                  */
    /*   Release a shared lock and if needed wakeup any sleepers.       */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SHARELOCK::ReleaseShareLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
#endif
#ifdef DEBUGGING
		//
		//   Release a shared lock.
		//
		if ( AtomicDecrement( & TotalUsers ) < 0 )
			{ Failure( "Negative lock count in ReleaseShareLock" ); }
#else
		AtomicDecrement( & TotalUsers );
#endif

		//
		//   Wakeup anyone who is asleep waiting.
		//
		if ( Waiting > 0 )
			{ WakeAllSleepers(); }
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\prefetch.hpp ===
#ifndef _PREFETCH_HPP_
#define _PREFETCH_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch a cache line.				                            */
    /*                                                                  */
    /*   Support of data prefetch on the Pentium III or better.         */
    /*                                                                  */
    /********************************************************************/

class PREFETCH : public ASSEMBLY
    {
#ifdef ASSEMBLY_X86
        //
        //   Staic private data.
        //
        STATIC BOOLEAN		          Active;

#endif
    public:
        //
        //   Public inline functions.
        //
        PREFETCH( VOID )
			{ /* void */ }

		STATIC INLINE VOID L1( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L2( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID L3( CHAR *Address,SBIT32 Size );

		STATIC INLINE VOID Nta( CHAR *Address,SBIT32 Size );

        ~PREFETCH( VOID )
			{ /* void */ }

	private:
        //
        //   Disabled operations.
        //
        PREFETCH( CONST PREFETCH & Copy );

        VOID operator=( CONST PREFETCH & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L1( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL1( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L2.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L2 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L2( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL2( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L3.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L3 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::L3( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchL3( Address ); }
		}
#endif
	}

    /********************************************************************/
    /*                                                                  */
    /*   Prefetch to the L1.                                            */
    /*                                                                  */
    /*   Prefetch an area of memory to the L1 cache if the processor    */
    /*   supports this feature.                                         */
    /*                                                                  */
    /********************************************************************/

VOID PREFETCH::Nta( CHAR *Address,SBIT32 Size )
	{
#ifdef ASSEMBLY_X86
	//
	//   We ensure the processor has prefetch functionality
	//   otherwise the instruction will fail.
	//
	if ( Active )
		{
		//
		//   We execute a prefetch for each cache line
		//   (which assumes things are alignment).
		//
		for 
				( 
				/* void */;
				Size > 0;
				Address += CacheLineSize, Size -= CacheLineSize 
				)
			{ PrefetchNta( Address ); }
		}
#endif
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\slist.hpp ===
#ifndef _SLIST_HPP_
#define _SLIST_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A lockless list.                                               */
    /*                                                                  */
    /*   An SList is a lockless list suitable for high contention       */
    /*   SMP access.                                                    */
    /*                                                                  */
    /********************************************************************/

class SLIST : public ASSEMBLY
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
	        SLIST                     *Address;
	        SBIT16                    Size;
	        SBIT16                    Version;
			}
		SLIST_HEADER;

        //
        //   Private data.
        //
        VOLATILE SBIT64	              Header;

    public:
        //
        //   Public functions.
        //
        SLIST( VOID );

		BOOLEAN Pop( SLIST **Element );

		VOID PopAll( SLIST **List );

		VOID Push( SLIST *Element );

        ~SLIST( VOID );

	private:
        //
        //   Disabled operations.
        //
        SLIST( CONST SLIST & Copy );

        VOID operator=( CONST SLIST & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\slist.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "SList.hpp"
#ifdef ASSEMBLY_X86

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new slist and initialize it.  This call is not        */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SLIST::SLIST( VOID )
    {
	//
	//   Zero the list head.
	//
	Header = 0;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an element.                                                */
    /*                                                                  */
    /*   Pop an element from the list.                                  */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SLIST::Pop( SLIST **Element )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update;
	REGISTER SLIST_HEADER *NewElement;
	REGISTER SLIST_HEADER *NewHeader = ((SLIST_HEADER*) & Update);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		Update = Original;

		//
		//   We need to be sure that there is an element
		//   to extract.  If not we exit.
		//
		if ( (NewElement = ((SLIST_HEADER*) NewHeader -> Address)) != NULL )
			{
			//
			//   Create a new list head.
			//
			NewHeader -> Address = NewElement -> Address;
			NewHeader -> Size --;
			NewHeader -> Version ++;
			}
		else
			{ return False; }
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );

	//
	//   Update the parameter and exit.
	//
	(*Element) = ((SLIST*) NewElement);

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop all elements.                                              */
    /*                                                                  */
    /*   Pop all the elements from the list.                            */
    /*                                                                  */
    /********************************************************************/

VOID SLIST::PopAll( SLIST **List )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update = NULL;
	REGISTER SLIST_HEADER *OldHeader = ((SLIST_HEADER*) & Original);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );

	//
	//   Update the parameter and exit.
	//
	(*List) = ((SLIST*) OldHeader -> Address);
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an element.                                               */
    /*                                                                  */
    /*   Push an element onto the list.                                 */
    /*                                                                  */
    /********************************************************************/

VOID SLIST::Push( SLIST *Element )
    {
	AUTO SBIT64 Original;
	AUTO SBIT64 Update;
	REGISTER SLIST_HEADER *NewElement = ((SLIST_HEADER*) Element);
	REGISTER SLIST_HEADER *NewHeader = ((SLIST_HEADER*) & Update);

	//
	//   We repeatedly try to update the list until
	//   we are sucessful.
	//
	do 
		{
		//
		//   Clone the current head of the list.
		//
		Original = Header;
		Update = Original;

		//
		//   The current list head is copied to 
		//   the new element pointer.
		//
		NewElement -> Address = NewHeader -> Address;

		//
		//   Update the list head.
		//
		NewHeader -> Address = Element;
		NewHeader -> Size ++;
		NewHeader -> Version ++;
		}
	while 
		( AtomicCompareExchange64( & Header,Update,Original ) != Original );
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a SList.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SLIST::~SLIST( VOID )
    {
	//
	//   The list should be empty.
	//
    if ( Header != 0 )
	{ Failure( "Non-empty list in destructor for SLIST" ); }
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\queue.hpp ===
#ifndef _QUEUE_HPP_
#define _QUEUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Common.hpp"
#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The queue constants specify the initial size of the queue.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 QueueSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Queues and queue management.                                   */
    /*                                                                  */
    /*   This class provides general purpose queues along with some     */
    /*   basic management.  The queues are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a queue at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class QUEUE : public COMMON, public LOCK
    {
        //
        //   Private data.
        //
        SBIT32						  MaxSize;

		BOOLEAN						  Align;
        SBIT32						  Mask;

        SBIT32						  Back;
        SBIT32						  Front;

        VECTOR<TYPE>                  Queue;

    public:
        //
        //   Public functions.
        //
        QUEUE( SBIT32 NewMaxSize = QueueSize,BOOLEAN NewAlign = True );

        BOOLEAN MultiplePopBackOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        BOOLEAN MultiplePopFrontOfQueue
            ( 
            SBIT32					  Requested, 
            TYPE					  Data[], 
            SBIT32					  *Size 
            );

        VOID MultiplePushBackOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        VOID MultiplePushFrontOfQueue
            ( 
            CONST TYPE				  Data[], 
            CONST SBIT32			  Size 
            );

        BOOLEAN PeekBackOfQueue( TYPE *Data );

        BOOLEAN PeekFrontOfQueue( TYPE *Data );

        BOOLEAN PopBackOfQueue( TYPE *Data );

        BOOLEAN PopFrontOfQueue( TYPE *Data );

        VOID PushBackOfQueue( CONST TYPE & Data );

        VOID PushFrontOfQueue( CONST TYPE & Data );

		SBIT32 SizeOfQueue( VOID );

        ~QUEUE( VOID );

		//
		//   Public inline functions.
		//
        INLINE BOOLEAN MultiplePopQueue
				( 
				SBIT32				  Requested, 
				TYPE				  Data[], 
				SBIT32				  *Size 
				)
			{ return MultiplePopFrontOfQueue( Requested,Data,Size ); }

        INLINE VOID MultiplePushQueue
				( 
				CONST TYPE			  Data[], 
				CONST SBIT32		  Size 
				)
			{ MultiplePushBackOfQueue( Data,Size ); }

        INLINE BOOLEAN PeekQueue( TYPE *Data )
			{ return PeekFrontOfQueue( Data ); }

        INLINE BOOLEAN PopQueue( TYPE *Data )
			{ return PopFrontOfQueue( Data ); }

        INLINE VOID PushQueue( CONST TYPE & Data )
			{ PushBackOfQueue( Data ); }

	private:
		//
		//   Private functions.
		//
		VOID ExpandQueue( VOID );

        //
        //   Disabled operations.
        //
        QUEUE( CONST QUEUE & Copy );

        VOID operator=( CONST QUEUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new queue and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::QUEUE
		( 
		SBIT32						  NewMaxSize,
		BOOLEAN						  NewAlign 
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		Align = NewAlign;
        Mask = 0x7fffffff;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Compute the alignment mask.
		//
		if 
				(
				((sizeof(TYPE) > 0) && (sizeof(TYPE) <= CacheLineSize))
					&&
				(PowerOfTwo( sizeof(TYPE) ))
				)
			{ Mask = ((CacheLineSize / sizeof(TYPE))-1); }
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for QUEUE" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand a queue.                                                */
    /*                                                                  */
    /*   When a queue becomes full we need to expand it and to copy     */
    /*   the tail end of the queue into the correct place.              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::ExpandQueue( VOID )
    {
    REGISTER SBIT32 Count;
    REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

	//
	//   Expand the queue (it will be at least doubled).
	//
    Queue.Resize( NewSize );

	//
	//   Copy the tail end of the queue to the correct
	//   place in the expanded queue.
	//
    for ( Count = 0;Count < Back;Count ++ )
        { Queue[ (MaxSize + Count) ] = Queue[ Count ]; }

	//
	//   Update the control information.
	//
    Back += MaxSize;
    MaxSize = NewSize;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the back of the queue.                 */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopBackOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing a cache  
	//   line at the same time.  Here we modify the request  
	//   to pop exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = (Back & Mask);

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && (Front <= (Back - Requested))) 
                || 
            ((Front > Back) && ((Back - Requested) >= 0)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ -- Back ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
				 if ( Back <= 0 )
					{ Back = MaxSize; }

                Data[ Count ] = Queue[ -- Back ];
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop multiple items from the front of the queue.                */
    /*                                                                  */
    /*   We remove multiple items from a queue and check to make sure   */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::MultiplePopFrontOfQueue
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   When running on SMP hardware it is very important 
	//   to prevent multiple CPU fighting over the same memory.  
	//   Most systems prevent multiple CPUs accessing cache  
	//   lines at the same time.  Here we modify the request  
	//   to access exactly the correct number of items to leave  
	//   us on a cache line boundary. 
    //
    if ( Align )
        {
        REGISTER SBIT32 Spare = ((Mask + 1) - (Front & Mask));

		if ( Requested > Spare )
			{
			Requested -= Spare;
			Requested &= ~Mask;
			Requested += Spare;
			}
        }

	//
	//   If there is enough elements in the current queue
	//   to extract without wrapping then just do a straight 
	//   copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front + Requested) <= Back)) 
                || 
            ((Front > Back) && ((Front + Requested) < MaxSize)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to remove all  
        //   the requested elements with a straight copy.
        //
        for ( Count = 0;Count < Requested;Count ++ )
            { Data[ Count ] = Queue[ Front ++ ]; }

        (*Size) = Requested;

		Result = True;
		}
    else
        {
        REGISTER SBIT32 Count;
        //
        //   It is not safe to remove all the elements from 
        //   the array.  Hence, I must remove them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0,(*Size)=0;Count < Requested;Count ++,(*Size) ++ )
            {
            if ( Front != Back )
                {
                //
                //   We have found an element so return it 
				//   to the caller.  However, lets we need  
				//   to be careful about wrapping.
                //
                Data[ Count ] = Queue[ Front ++ ];

                if ( Front >= MaxSize )
                    { Front = 0; }
                }
            else
                {
                //
                //  We are out of queue elements so lets exit.  
				//  However, we only return 'False' if we didn't 
				//  find any elements at all.
                //
				Result = (Count != 0);

                break;
                }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the back of the queue.                */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushBackOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Back + Size) < MaxSize)) 
                || 
            ((Front > Back) && (Front > (Back + Size))) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ Back ++ ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count=0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the front of the array.
            //
            Queue[ Back ++ ] = Data[ Count ];

             if ( Back >= MaxSize )
                { Back = 0; }

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push multiple items onto the front of the queue.               */
    /*                                                                  */
    /*   We add multiple items to a queue and check to make sure that   */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::MultiplePushFrontOfQueue
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If there is enough space in the current queue
	//   for the new elements without wrapping then
	//   just do a straight copy.
	//
    if 
            ( 
            ((Front <= Back) && ((Front - Size) >= 0)) 
                || 
            ((Front > Back) && ((Front - Size) > Back)) 
            )
        {
        REGISTER SBIT32 Count;

        //
        //   We have verified that it is safe to copy 
        //   all the new elements on to the end of the 
		//   array.  So lets do it and then we can exit. 
        //
        for ( Count = 0;Count < Size;Count ++ )
            { Queue[ -- Front ] = Data[ Count ]; }
        }
    else
        {
        REGISTER SBIT32 Count;

        //
        //   It is not safe to add the new elements to 
		//   the end of the array so add them one at a 
		//   time.  This is tedious but should only happen 
		//   occasionally.
        //
        for ( Count = 0;Count < Size;Count ++ )
            {
            //
            //   Add element to the queue.  If necessary  
            //   wrap round to the back of the array.
            //
			 if ( Front <= 0 )
				{ Front = MaxSize; }

			Queue[ -- Front ] = Data[ Count ];

            //
            //   Verify that the queue is not full.  If 
			//   it is full then double its size and  
			//   copy wrapped data to the correct position 
			//   in the new array.
            //
            if ( Front == Back )
				{ ExpandQueue(); }
            }
        }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the back of the queue.                                    */
    /*                                                                  */
    /*   We return the end of the queue but check to make sure          */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the last element.
	//
    if ( Front != Back )
		{
		//
		//   The 'Back' index points at the next free cell.
		//   So the last element is 'Back - 1'.  However,
		//   when 'Back' is zero we need to wrap.
		//
		if ( Back > 0 )
			{ (*Data) = Queue[ (Back - 1) ]; }
		else
			{ (*Data) = Queue[ (MaxSize - 1) ]; }
	
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek the front of the queue.                                   */
    /*                                                                  */
    /*   We return the front of the queue but check to make sure        */
    /*   that the queue is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PeekFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the queue contains at least one element then
	//   return a copy of the first element.
	//
    if ( Front != Back )
		{ 
		(*Data) = Queue[ Front ];
		
		Result = True;
		}
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the back of the queue.                        */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopBackOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
         if ( Back <= 0 )
            { Back = MaxSize; }

       (*Data) = Queue[ -- Back ];

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Pop an item from the front of the queue.                       */
    /*                                                                  */
    /*   We remove a single item from a queue and check to make sure    */
    /*   that the queue has not wrapped.                                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN QUEUE<TYPE,LOCK>::PopFrontOfQueue
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the queue is not empty.
	//
    if ( Front != Back )
        {
        //
        //   We have found an element so return it to 
		//   the caller.  If we walk off the end of the 
		//   queue then wrap to the other end.
        //
        (*Data) = Queue[ Front ++ ];

        if ( Front >= MaxSize )
            { Front = 0; }

		Result = True;
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the back of the queue.                       */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushBackOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Queue[ Back ++ ] = Data;

     if ( Back >= MaxSize )
        { Back = 0; }

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Push an item onto the front of the queue.                      */
    /*                                                                  */
    /*   We add a single item to a queue and check to make sure that    */
    /*   the queue has not overflowed.  If the queue has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID QUEUE<TYPE,LOCK>::PushFrontOfQueue
		( 
		CONST TYPE					  & Data 
		)
    {
	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the back of the array.
    //
     if ( Front <= 0 )
        { Front = MaxSize; }

    Queue[ -- Front ] = Data;

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{ ExpandQueue(); }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the queue.                               */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*   This is only used when the size is needed in all other cases   */
    /*   we just try to remove the elements in the queue.               */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 QUEUE<TYPE,LOCK>::SizeOfQueue( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Claim a shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   Compute the size of the queue.
	//
	Size = (Back - Front);

	if ( Size < 0 )
		{ Size += MaxSize; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseSharedLock();

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> QUEUE<TYPE,LOCK>::~QUEUE( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\sharelock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Sharelock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The Windows NT kernel requires a maximum wakeup count when     */
    /*   creating a semaphore.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MaxShareLockUsers		  = 256;

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::SHARELOCK( SBIT32 NewMaxSpins, SBIT32 NewMaxUsers )
    {
	//
	//   Check the configurable values.
	//
	if ( NewMaxSpins > 0 )
		{ MaxSpins = NewMaxSpins; }
	else
		{ Failure( "Maximum spins invalid in constructor for SHARELOCK" ); }

	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{ MaxUsers = NewMaxUsers; }
	else
		{ Failure( "Maximum share invalid in constructor for SHARELOCK" ); }

	//
	//   Set the initial state.
	//
	Exclusive = 0;
	TotalUsers = 0;
#ifdef ENABLE_RECURSIVE_LOCKS

	Owner = NULL;
	Recursive = 0;
#endif
	Semaphore = NULL;
    Waiting = 0;

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the statistics.
	//
    TotalExclusiveLocks = 0;
    TotalShareLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Sleep waiting for the lock.                                    */
    /*                                                                  */
    /*   We have decided it is time to sleep waiting for the lock       */
    /*   to become free.                                                */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::SleepWaitingForLock( SBIT32 Sleep )
    {
	//
	//   We do not create the semaphore until somebody tries
	//   to sleep on it for the first time.
	//
	if ( Semaphore == NULL )
		{ UpdateSemaphore(); }

	//
	//   We would normally hope to find a semaphore avaiable
	//   ready for a sleep but the OS may decline the request 
	//   If this is the case we exit without sleeping.
	//
	if ( Semaphore != NULL )
		{
		//
		//   We have been spinning waiting for the lock but it
		//   has not become free.  Hence, it is now time to 
		//   give up and sleep for a while.
		//
		(VOID) AtomicIncrement( & Waiting );

		//
		//   Just before we go to sleep we do one final check
		//   to make sure that the lock is still busy and that
		//   there is someone to wake us up when it becomes free.
		//
		if ( TotalUsers > 0 )
			{
#ifdef ENABLE_LOCK_STATISTICS
			//
			//   Count the number of times we have slept on this lock.
			//
			(VOID) AtomicIncrement( & TotalSleeps );

#endif
			//
			//   When we sleep we awoken when the lock becomes free
			//   or when we timeout.  If we timeout we simply exit
			//   after decrementing various counters.
			//
			if 
					( 
					WaitForSingleObject( Semaphore, Sleep ) 
						!= 
					WAIT_OBJECT_0 
					)
				{ 
#ifdef ENABLE_LOCK_STATISTICS
				//
				//   Count the number of times we have timed out 
				//   on this lock.
				//
				(VOID) AtomicIncrement( & TotalTimeouts );

#endif
				return False; 
				}
			}
		else
			{
			//
			//   Lucky - the lock was just freed so lets
			//   decrement the sleep count and exit without
			//   sleeping.
			// 
			(VOID) AtomicDecrement( & Waiting );
			}
		}
	
	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the spin limit.                                         */
    /*                                                                  */
    /*   Update the maximum number of spins while waiting for the lock. */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxSpins( SBIT32 NewMaxSpins )
    {
	if ( NewMaxSpins > 0 )
		{ 
		MaxSpins = NewMaxSpins; 

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the sharing limit.                                      */
    /*                                                                  */
    /*   Update the maximum number of users that can share the lock.    */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::UpdateMaxUsers( SBIT32 NewMaxUsers )
    {
	//
	//   We need to verify the new value makes sense.
	//
	if ( (NewMaxUsers > 0) && (NewMaxUsers <= MaxShareLockUsers) )
		{
		ClaimExclusiveLock();

		//
		//   Update the maximum number of users.
		//
		MaxUsers = NewMaxUsers;
		
		ReleaseExclusiveLock();

		return True;
		}
	else
		{ return False; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Update the semahore.                                           */
    /*                                                                  */
    /*   We only create the semaphore on first use.  So when we need    */
    /*   need to create a new semaphore any thread that is trying       */
    /*   to sleep on it comes here.                                     */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::UpdateSemaphore( VOID )
    {
	STATIC SBIT32 Active = 0;

	//
	//   We verify that there is still no semaphore
	//   otherwise we exit.
	//
	while ( Semaphore == NULL )
		{
		//
		//   We increment the active count and if we
		//   are first we are selected for special duty.
		//
		if ( (AtomicIncrement( & Active ) == 1) && (Semaphore == NULL) )
			{
			//
			//   We try to create a new semaphore.  If
			//   we fail we still exit.
			//   
			Semaphore = CreateSemaphore( NULL,0,MaxShareLockUsers,NULL );

			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			return;
			}
		else
			{ 
			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			Sleep( 1 ); 
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for an exclusive lock.                                    */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForExclusiveLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( TotalUsers != 1 )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );
    
		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) && (TotalUsers > 0);
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decide that we need to sleep but are
				//   still holding an exclusive lock so lets drop it
				//   before sleeping.
				//
				(VOID) AtomicDecrement( & Exclusive );

				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }

				//
				//   We have woken up again so lets reclaim the
				//   exclusive lock we had earlier.
				//
				(VOID) AtomicIncrement( & Exclusive );
				}
			}
		else
			{ 
			//
			//   We have decide that we need to exit but are still
			//   holding an exclusive lock.  so lets drop it and leave.
			//
			(VOID) AtomicDecrement( & Exclusive );

			return False; 
			} 
		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}

#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for a shared lock.                                        */
    /*                                                                  */
    /*   Wait for the lock to become free and then claim it.            */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SHARELOCK::WaitForShareLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
	REGISTER SBIT32 Spins = 0;
	REGISTER SBIT32 Waits = 0;

#endif
	//
	//   We will loop round in this function until the
	//   following condition becomes false.
	//
	while ( (Exclusive > 0) || (TotalUsers > MaxUsers) )
		{
		//
		//   The lock is busy so release it and spin waiting
		//   for it to become free.
		//
		(VOID) AtomicDecrement( & TotalUsers );

		//
		//   We will only try spinning and sleeping if we
		//   are permitted to do so by the parameters.
		//   
		if ( Sleep != 0 )
			{
			REGISTER SBIT32 Count;
    
			//
			//   If there are already more threads waiting 
			//   than the number of CPUs then the odds of 
			//   getting the lock by spinning are slim, when 
			//   there is only one CPU the chance is zero, so 
			//   just bypass this step.
			//
			if ( (Cpus > 1) && (Cpus > Waiting) )
				{
				//
				//   Wait by spinning and repeatedly testing the
				//   spinlock.  We exit when the lock becomes free 
				//   or the spin limit is exceeded.
				//
				for 
					( 
						Count = MaxSpins;
						(Count > 0) 
							&& 
						((Exclusive > 0) || (TotalUsers >= MaxUsers));
						Count -- 
					);
#ifdef ENABLE_LOCK_STATISTICS

				//
				//   Update the statistics.
				//
				Spins += (MaxSpins - Count);
				Waits ++;
#endif
				}
			else
				{ Count = 0; }

			//
			//   We have exhusted our spin count so it is time to
			//   sleep waiting for the lock to clear.
			//
			if ( Count == 0 )
				{
				//
				//   We have decied that it is time to go to sleep
				//   when we wake up the lock should be available
				//   (or just aquired) unless we have timed out in
				//   wich case we exit.
				//
				if ( ! SleepWaitingForLock( Sleep ) )
					{ return False; }
				}
			}
		else
			{ return False; }

		//
		//   Lets test the lock again.
		//
		(VOID) AtomicIncrement( & TotalUsers );
		}
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicAdd( & TotalSpins, Spins );
	(VOID) AtomicAdd( & TotalWaits, Waits );
#endif

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SHARELOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SHARELOCK::~SHARELOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Sharelock: %d exclusive, %d shared, %d timeouts, " 
		"%d locks per wait, %d spins per wait, %d waits per sleep.\n",
		TotalExclusiveLocks,
		TotalShareLocks,
		TotalTimeouts,
		((TotalExclusiveLocks + TotalShareLocks) / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);
#endif
	//
	//   Close the semaphore handle.
	//
    if ( (Semaphore != NULL) && (! CloseHandle( Semaphore )) )
        { Failure( "Close semaphore in destructor for SHARELOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\smpool.hpp ===
#ifndef _SMPOOL_HPP_
#define _SMPOOL_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Block.hpp"
#include "Exclusive.hpp"
#include "Queue.hpp"
#include "Spinlock.hpp"
#include "Stack.hpp"
#include "Vector.hpp"
  
    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The server constants specify the size of the server queue      */
    /*   per processor stacks.                                          */
    /*                                                                  */
    /********************************************************************/

CONST SBIT16 MinSMPoolSize			  = 128;
CONST SBIT16 SMPoolStackSize		  = 32;

    /********************************************************************/
    /*                                                                  */
    /*   Pools and pool management.                                     */
    /*                                                                  */
    /*   This class provides general purpose memory pool along with     */
    /*   basic management.  The pools are optimized for very high       */
    /*   performance on SMP systems (although this calls does not       */
    /*   perform the actual locking.  Whenever possible multiple        */
    /*   items should allocated and deallocated at the same time.       */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class SMPOOL
    {
		//
		//   Private structures.
		//
		typedef EXCLUSIVE< QUEUE<POINTER> > LOCKED_QUEUE;
		typedef struct { CHAR TypeSize[sizeof(TYPE)]; } TYPE_SIZE;

        //
        //   Private data.
        //
		SBIT32                        MaxSize;
		SBIT32                        MinSize;

        BLOCK< VECTOR<TYPE_SIZE> >    Block;
        LOCKED_QUEUE                  FreeQueue;
		VECTOR< STACK<POINTER> >      Stacks;

    public:
        //
        //   Public functions.
        //
        SMPOOL( SBIT32 MinSize = MinSMPoolSize );

        TYPE *PopPool( SBIT16 Cpu );

        TYPE **MultiplePopPool
            ( 
            SBIT16                        Cpu, 
            SBIT32                        Requested, 
            SBIT32                        *Size 
            );

        VOID PushPool( SBIT16 Cpu, TYPE *Pool );

        VOID MultiplePushPool
            ( 
            SBIT16                        Cpu, 
            TYPE                          *Pool[], 
            SBIT32                        Size 
            );

        ~SMPOOL( VOID );

	private:
		//
		//   Private functions.
		//
		VOID ExpandSize( SBIT32 NewSize );

        //
        //   Disabled operations.
        //
        SMPOOL( CONST SMPOOL & Copy );

        VOID operator=( CONST SMPOOL & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new pool and prepare it for use.  This call is        */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::SMPOOL( SBIT32 MinSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		FreeQueue( MinSize ), 
		Stacks( NumberOfCpus(), CacheLineSize )
    {
#ifdef DEBUGGING
    if ( MinSize > 0 )
        {
#endif
		//
		//   We need to keep a note of the amount of elements 
		//   we have allocated so far.
		//
        this -> MaxSize = 0;
        this -> MinSize = MinSize;
#ifdef DEBUGGING
        }
    else
        { Failure( "MinSize in constructor for SMPOOL" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Expand size.                                                   */
    /*                                                                  */
    /*   Expand the current memory allocation if the free queue is      */
    /*   empty.                                                         */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::ExpandSize( SBIT32 NewSize )
    {
	REGISTER SBIT32 Count1;
	REGISTER SBIT32 Count2;
	STATIC SPINLOCK Spinlock;

	Spinlock.ClaimLock();

	if ( FreeQueue.SizeOfQueue() <= 0 )
		{
		REGISTER SBIT32 ActualSize =
			(NewSize <= MinSize) ? MinSize : NewSize;
		REGISTER VECTOR<TYPE> *NewBlock =
			(
			(VECTOR<TYPE>*) new VECTOR<TYPE_SIZE>
				( 
				ActualSize, 
				CacheLineSize 
				)
			);

		//
		//   We need to keep a note of the number of elements 
		//   we have allocated thus far.
		//
		MaxSize += ActualSize;

		//
		//   We put the address of each element we allocate on
		//   a stack to enable high speed allocation and 
		//   deallocation.
		//
		for 
				( 
				Count1 = 0;
				Count1 < ActualSize;
				Count1 += SMPoolStackSize 
				)
			{
			AUTO POINTER NewCalls[ SMPoolStackSize ];

			//
			//   We add elements to the stack in blocks
			//   to reduce the number of call to the
			//   stack code.
			//
			for 
					( 
					Count2 = 0;
					((Count1 + Count2) < ActualSize)
						&&
					(Count2 < SMPoolStackSize);
					Count2 ++ 
					)
				{
				REGISTER TYPE *NewCall =
					(
					& (*NewBlock)[ (Count1 + Count2) ]
					);
                 
				NewCalls[ Count2 ] = (POINTER) NewCall;
				}

			//
			//   Add the next block for free work packets to
			//   the global free queue.
			//
			Stack.MultiplePushStack
				( 
				NewCalls,
				Count2 
				);
			}

		//
		//   Add the newly allocated block to the list of
		//   things to be deleted when this class is deleted.
		//
		Block.DeferedDelete( (VECTOR<TYPE_SIZE>*) NewBlock );
		}
	
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from the pool.                            */
    /*                                                                  */
    /*   We remove a single item from the pool.  This call assumes      */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE *SMPOOL<TYPE>::PopPool( SBIT16 Cpu )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool;

	while ( ! Stack -> PopStack( (POINTER*) & NewPool ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	(VOID) PLACEMENT_NEW( NewPool, TYPE );

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from the pool.                           */
    /*                                                                  */
    /*   We remove multiple items from the pool.  This call assumes     */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> TYPE **SMPOOL<TYPE>::MultiplePopPool
        ( 
        SBIT16                        Cpu, 
        SBIT32                        Requested, 
        SBIT32                        *Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	STATIC TYPE *NewPool[ SMPoolStackSize ];

	Requested = (Requested <= SMPoolStackSize) ? Requested : SMPoolStackSize;

	while ( ! Stack -> MultiplePopStack( Requested,(POINTER*) NewPool,Size ) )
        {
        AUTO POINTER Store[ SMPoolStackSize ];
        AUTO SBIT32 Size;

        FreeQueue.RemoveMultipleFromQueue
            ( 
            SMPoolStackSize, 
            Store, 
            & Size 
            );

        if ( Size > 0 )
            { Stack -> MultiplePushStack( Store, Size ); }
		else
			{ ExpandSize( MaxSize ); }
		}

	for ( Count=0;Count < (*Size); Count ++ )
		{ (VOID) PLACEMENT_NEW( NewPool[ Count ], TYPE ); }

	return NewPool;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to the pool.                                 */
    /*                                                                  */
    /*   We add a single item to the pool.  This call assumes           */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::PushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool
        )
    {
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];

	PLACEMENT_DELETE( Pool, TYPE );

	Stack -> PushStack( (POINTER) Pool );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to the pool.                                */
    /*                                                                  */
    /*   We add a multiple items to the pool.  This call assumes        */
    /*   all calls with the same 'Cpu' value are executed serially      */
    /*   and that only one such call can be executing at any given      */
    /*   time.                                                          */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID SMPOOL<TYPE>::MultiplePushPool
        ( 
        SBIT16                        Cpu,
        TYPE                          *Pool[],
        SBIT32                        Size 
        )
    {
	REGISTER SBIT32 Count;
	REGISTER STACK<POINTER> *Stack = & Stacks[ Cpu ];
	
	for ( Count=(Size - 1);Count >= 0; Count -- )
		{ PLACEMENT_DELETE( Pool[ Count ], TYPE ); }

	Stack -> MultiplePushStack( (POINTER*) Pool,Size );

	while ( Stack -> SizeOfStack() > (SMPoolStackSize * 2) )
		{
		AUTO POINTER Store[ SMPoolStackSize ];
		AUTO SBIT32 Size;

		Stack -> MultiplePopStack
			( 
			SMPoolStackSize, 
			Store, 
			& Size 
			);

		FreeQueue.AddMultipleToQueue( Store, Size );
		}
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> SMPOOL<TYPE>::~SMPOOL( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\spinlock.hpp ===
#ifndef _SPINLOCK_HPP_
#define _SPINLOCK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The spinlock constants indicate when the lock is open and      */
    /*   when it is closed.                                             */
    /*                                                                  */
    /********************************************************************/

CONST LONG LockClosed				  = 1;
CONST LONG LockOpen					  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Spinlock and Semaphore locking.                                */
    /*                                                                  */
    /*   This class provides a very conservative locking scheme.        */
    /*   The assumption behind the code is that locks will be           */
    /*   held for a very short time.  When a lock is taken a memory     */
    /*   location is exchanged.  All other threads that want this       */
    /*   lock wait by spinning and sometimes sleeping on a semaphore    */
    /*   until it becomes free again.  The only other choice is not     */
    /*   to wait at all and move on to do something else.  This         */
    /*   module should normally be used in conjunction with cache       */
    /*   aligned memory in minimize cache line misses.                  */
    /*                                                                  */
    /********************************************************************/

class SPINLOCK : public ENVIRONMENT
    {
        //
        //   Private data.
        //
		SBIT32						  MaxSpins;
		SBIT32						  MaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
		SBIT32						  Owner;
		SBIT32						  Recursive;
#endif
        HANDLE                        Semaphore;
        VOLATILE SBIT32               Spinlock;
        VOLATILE SBIT32               Waiting;
#ifdef ENABLE_LOCK_STATISTICS

        //
        //   Counters for debugging builds.
        //
        VOLATILE SBIT32               TotalLocks;
        VOLATILE SBIT32               TotalSleeps;
        VOLATILE SBIT32               TotalSpins;
        VOLATILE SBIT32               TotalTimeouts;
        VOLATILE SBIT32               TotalWaits;
#endif

    public:
        //
        //   Public functions.
        //
        SPINLOCK( SBIT32 NewMaxSpins = 4096, SBIT32 NewMaxUsers = 256 );

        INLINE BOOLEAN ClaimLock( SBIT32 Sleep = INFINITE );

        INLINE VOID ReleaseLock( VOID );

        ~SPINLOCK( VOID );

    private:
        //
        //   Private functions.
        //
        INLINE BOOLEAN ClaimSpinlock( VOLATILE SBIT32 *Spinlock );

		INLINE VOID DeleteExclusiveOwner( VOID );

		INLINE VOID NewExclusiveOwner( SBIT32 NewOwner );

		VOID UpdateSemaphore( VOID );

        BOOLEAN WaitForLock( SBIT32 Sleep );

        VOID WakeAllSleepers( VOID );

        //
        //   Disabled operations.
        //
        SPINLOCK( CONST SPINLOCK & Copy );

        VOID operator=( CONST SPINLOCK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   A guaranteed atomic exchange.                                  */
    /*                                                                  */
    /*   An attempt is made to claim the spinlock.  This action is      */
    /*   guaranteed to be atomic.                                       */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimSpinlock( VOLATILE SBIT32 *Spinlock )
    {
    return 
		(
		AtomicCompareExchange( Spinlock,LockClosed,LockOpen ) 
			== 
		LockOpen
		); 
    }

    /********************************************************************/
    /*                                                                  */
    /*   Claim the spinlock.                                            */
    /*                                                                  */
    /*   Claim the lock if available else wait or exit.                 */
    /*                                                                  */
    /********************************************************************/

INLINE BOOLEAN SPINLOCK::ClaimLock( SBIT32 Sleep )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   We may already own the spin lock.  If so
	//   we increment the recursive count.  If not 
	//   we have to wait.
	//
	if ( Owner != ThreadId )
		{
#endif
		//
		//   Claim the spinlock.
		//
		if ( ! ClaimSpinlock( & Spinlock ) )
			{
			//
			//   We have to wait.  If we are not 
			//   allowed to sleep or we have timed
			//   out then exit.
			//
			if ( (Sleep == 0) || (! WaitForLock( Sleep )) )
				{ return False; }
			}
#ifdef ENABLE_RECURSIVE_LOCKS

		//
		//   Register the new owner of the lock.
		//
		NewExclusiveOwner( ThreadId );
		}
	else
		{ Recursive ++; }
#endif
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
	(VOID) AtomicIncrement( & TotalLocks );
#endif

    return True;
    }
#ifdef ENABLE_RECURSIVE_LOCKS

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Delete the exclusive lock owner information.                   */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::DeleteExclusiveOwner( VOID )
    {
#ifdef DEBUGGING
	if ( Owner != NULL )
		{ 
#endif
		Owner = NULL; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Sharelock has no owner in DeleteExclusiveOwner" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   New exclusive owner.                                           */
    /*                                                                  */
    /*   Register new exclusive lock owner information.                 */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::NewExclusiveOwner( SBIT32 NewOwner )
    {
#ifdef DEBUGGING
	if ( Owner == NULL )
		{ 
#endif
		Owner = NewOwner; 
#ifdef DEBUGGING
		}
	else
		{ Failure( "Already exclusive in NewExclusiveOwner" ); }
#endif
    }
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Release the spinlock.                                          */
    /*                                                                  */
    /*   Release the lock and if needed wakeup any sleepers.            */
    /*                                                                  */
    /********************************************************************/

INLINE VOID SPINLOCK::ReleaseLock( VOID )
    {
#ifdef ENABLE_RECURSIVE_LOCKS
	//
	//   When we have recursive lock calls we do not 
	//   release the lock until we have exited to the 
	//   top level.
	//
	if ( Recursive <= 0 )
		{
		//
		//   Delete the exclusive owner information.
		//
		DeleteExclusiveOwner();
#endif
#ifdef DEBUGGING

		//
		//   Release the spinlock.
		//
		if ( AtomicExchange( & Spinlock, LockOpen ) == LockClosed )
			{
#else
			(VOID) AtomicExchange( & Spinlock, LockOpen );
#endif

			//
			//   Wakeup anyone who is asleep waiting.
			//
			if ( Waiting > 0 )
				{ WakeAllSleepers(); }
#ifdef DEBUGGING
			}
		else
			{ Failure( "Spinlock released by not held in ReleaseLock" ); } 
#endif
#ifdef ENABLE_RECURSIVE_LOCKS
		}
	else
		{ Recursive --; }
#endif
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\standard.hpp ===
#ifndef _STANDARD_HPP_
#define _STANDARD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard data types.                                       */
    /*                                                                  */
    /*   The standard data types should be used in preference to the    */
    /*   data types defined in the C++ language.  This is to allow      */
    /*   for easier porting.  If no suitable standard type exists       */
    /*   then one should be created and documented here.                */
    /*                                                                  */
    /********************************************************************/

#define AUTO                          auto
#define CONST						  const
#define CONSTANT                      const
#define EXTERN                        extern
#define GLOBAL                        extern
#define INLINE                        __forceinline
#define LOCAL                         auto
#define REGISTER                      register
#define STATIC                        static
#define VIRTUAL                       virtual
#define VOLATILE                      volatile

    /********************************************************************/
    /*                                                                  */
    /*   The standard C++ types.                                        */
    /*                                                                  */
    /*   The C++ standard reserves various lower case keywords.  This   */
    /*   system uses a similar standard.  All upper case words are      */
    /*   either constants or types.  All words begining with a single   */
    /*   upper case letter are variables.                               */
    /*                                                                  */
    /********************************************************************/

typedef unsigned char                 BOOLEAN;

typedef char                          CHAR;
typedef short int                     SHORT;
typedef int                           INT;
typedef long int                      LONG;

typedef signed char                   SCHAR;
typedef signed short int              SSHORT;
typedef signed int                    SINT;
typedef signed long int               SLONG;

typedef unsigned char                 UCHAR;
typedef unsigned short int            USHORT;
typedef unsigned int                  UINT;
typedef unsigned long int             ULONG;

typedef unsigned char                 *FAULT;
typedef void                          *POINTER;

    /********************************************************************/
    /*                                                                  */
    /*   The optional standard types.                                   */
    /*                                                                  */
    /*   Some of the standard types are specified in other headers.     */
    /*   We need to be careful not to redefine these specifications     */
    /*   if they already exist.                                         */
    /*                                                                  */
    /********************************************************************/

#ifndef CDECL
#define	CDECL						  _cdecl
#endif

#ifndef VOID
#define	VOID						  void
#endif

    /********************************************************************/
    /*                                                                  */
    /*   The fixed length types.                                        */
    /*                                                                  */
    /*   The above types are intended to shadow the standard C++ types  */
    /*   built into the language.  However, these types don't assure    */
    /*   any level of accuracy.  Each of following types is defined     */
    /*   to provide a minimum level of precision.                       */
    /*                                                                  */
    /********************************************************************/

typedef unsigned __int8               BIT8;
typedef unsigned __int16              BIT16;
typedef unsigned __int32              BIT32;
typedef unsigned __int64              BIT64;

typedef signed __int8                 SBIT8;
typedef signed __int16                SBIT16;
typedef signed __int32                SBIT32;
typedef signed __int64                SBIT64;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\string.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Delay.hpp"
#include "String.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Static member initialization.                                  */
    /*                                                                  */
    /*   Static member initialization sets the initial value for all    */
    /*   static members.                                                */
    /*                                                                  */
    /********************************************************************/

#pragma init_seg(lib)
#ifdef DISABLE_STRING_LOCKS
UNIQUE<NO_LOCK> *STRING::Unique;
#else
SPINLOCK STRING::Spinlock;
UNIQUE<FULL_LOCK> *STRING::Unique = NULL;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Create the string table.                                       */
    /*                                                                  */
    /*   We create the string table on first use.  This is tricky as    */
    /*   we may have created multiple threads so we must be careful     */
    /*   to avoid race conditions.  We also arrang for the string table */
    /*   to be deleted at the end of the run unit.                      */
    /*                                                                  */
    /********************************************************************/

VOID STRING::CreateStringTable( VOID )
	{
#ifdef DISABLE_STRING_LOCKS
	STATIC DELAY<UNIQUE<NO_LOCK>> Delay;

	//
	//   Create the new string table.
	//
	Unique = new UNIQUE<NO_LOCK>;

	//
	//   Register the string table for deletion at
	//   at the end of the run unit.
	//
	Delay.DeferedDelete( Unique );
#else
	//
	//   Claim a lock to avoid race conditions.
	//
	Spinlock.ClaimLock();

	//
	//   If the string table still does not exist
	//   then create it.
	//
	if ( Unique == NULL )
		{
		STATIC DELAY< UNIQUE<FULL_LOCK> > Delay;

		//
		//   Create the new string table.
		//
		Unique = new UNIQUE<FULL_LOCK>;

		//
		//   Register the string table for deletion at
		//   at the end of the run unit.
		//
		Delay.DeferedDelete( Unique );
		}

	//
	//   Release the lock.
	//
	Spinlock.ReleaseLock();
#endif
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\stack.hpp ===
#ifndef _STACK_HPP_
#define _STACK_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The stack constants specify the initial size of the stack.     */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 StackSize				  = 1024;

    /********************************************************************/
    /*                                                                  */
    /*   Stacks and stack management.                                   */
    /*                                                                  */
    /*   This class provides general purpose stacks along with some     */
    /*   basic management.  The stacks are optimized for very high      */
    /*   performance on SMP systems.  Whenever possible multiple        */
    /*   items should added and removed from a stack at the same time.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class STACK : public LOCK
    {
        //
        //   Private data.
        //
        SBIT32                        MaxSize;
        SBIT32                        Top;

        VECTOR<TYPE>                  Stack;

    public:
        //
        //   Public functions.
        //
        STACK( SBIT32 NewMaxSize = StackSize );

        BOOLEAN MultiplePopStack
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        BOOLEAN MultiplePopStackReversed
            ( 
            SBIT32                        Requested, 
            TYPE                          Data[], 
            SBIT32                        *Size 
            );

        VOID MultiplePushStack
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        VOID MultiplePushStackReversed
            ( 
            CONST TYPE					  Data[], 
            CONST SBIT32				  Size 
            );

        BOOLEAN PeekStack( TYPE *Data );

        BOOLEAN PopStack( TYPE *Data );

        VOID PushStack( CONST TYPE & Data );

        BOOLEAN ReadStack( SBIT32 Index, TYPE *Data );

        VOID ReverseStack( VOID );

        BOOLEAN UpdateStack
            ( 
            CONST SBIT32				  Index, 
            CONST TYPE					  & Data 
            );

        ~STACK( VOID );

		//
		//   Public inline functions.
		//
        INLINE SBIT32 SizeOfStack( VOID ) 
			{ return Top; }

	private:
        //
        //   Disabled operations.
        //
        STACK( CONST STACK & Copy );

        VOID operator=( CONST STACK & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new stack and prepare it for use.  This call is       */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::STACK( SBIT32 NewMaxSize ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Stack( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
        MaxSize = NewMaxSize;
        Top = 0;
#ifdef DEBUGGING
        }
    else
        { Failure( "Size in constructor for STACK" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack.                            */
    /*                                                                  */
    /*   We remove multiple items from a stack and check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStack
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = ((*Size) - 1);Count >= 0;Count -- )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove multiple items from a stack in reverse order.           */
    /*                                                                  */
    /*   We remove multiple items from a stack in reverse order and     */
    /*   check to make sure that the stack is not empty.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::MultiplePopStackReversed
        ( 
        SBIT32                        Requested, 
        TYPE                          Data[], 
        SBIT32                        *Size 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the 
	//   top elements.
    if ( Top > 0 )
        {
        REGISTER SBIT32 Count;

        (*Size) = (Top >= Requested) ? Requested : Top;

        for ( Count = 0;Count < (*Size);Count ++ )
            { Data[ Count ] = Stack[ -- Top ]; }

		Result = True;
        }
    else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack.                                 */
    /*                                                                  */
    /*   We add multiple items to a stack and check to make sure that   */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStack
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements.
	//
    for ( Count = 0;Count < Size;Count ++ )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add multiple items to a stack in reverse order.                */
    /*                                                                  */
    /*   We add multiple items to a stack in reverse order and check    */
    /*   to make sure that the stack has not overflowed.  If the stack  */
    /*   has overflowed we double its size.                             */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::MultiplePushStackReversed
        ( 
        CONST TYPE					  Data[],
        CONST SBIT32				  Size 
        )
    {
    REGISTER SBIT32 Count;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the stack will overflow then expand it.
	//
    while ( (Top + Size) >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push the new elements in reverse order.
	//
    for ( Count = (Size-1);Count >= 0;Count -- )
        { Stack[ Top ++ ] = Data[ Count ]; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Peek at the top of stack.                                      */
    /*                                                                  */
    /*   We return the top of stack with a pop but check to make sure   */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PeekStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the stack is not empty return a copy
	//   of the top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ (Top - 1) ];

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Remove a single item from a stack.                             */
    /*                                                                  */
    /*   We remove a single item from a stack and check to make sure    */
    /*   that the stack is not empty.                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::PopStack
		( 
		TYPE						  *Data 
		)
    {
    REGISTER BOOLEAN Result;

    //
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is not empty return the
	//   top element.
	//
    if ( Top > 0 )
		{ 
		(*Data) = Stack[ -- Top ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Add a single item to a stack.                                  */
    /*                                                                  */
    /*   We add a single item to a stack and check to make sure that    */
    /*   the stack has not overflowed.  If the stack has overflowed     */
    /*   we double its size.                                            */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::PushStack
		( 
		CONST TYPE					  & Data
		)
    {    
	//
	//   Claim an exclisive lock (if enabled).
	//
	ClaimExclusiveLock();

	//
	//   If the stack is full then expand it.
	//
    while ( Top >= MaxSize )
        { Stack.Resize( (MaxSize *= ExpandStore) ); }

	//
	//   Push a new element.
	//
    Stack[ Top ++ ] = Data;

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Read a stack value.                                            */
    /*                                                                  */
    /*   We return a single item from the stack but check to make       */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::ReadStack
        ( 
        SBIT32                        Index, 
        TYPE                          *Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an shared lock (if enabled).
	//
    ClaimSharedLock();

	//
	//   If the element exists then return a copy of
	//   it to the caller.
	//
    if ( Index < Top )
		{ 
		(*Data) = Stack[ Index ];
		
		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseSharedLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Reverse the stack.                                             */
    /*                                                                  */
    /*   We reverse the order of the stack to make effectively          */
    /*   make it a queue.                .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> VOID STACK<TYPE,LOCK>::ReverseStack( VOID )
    {
	REGISTER SBIT32 Count;
	REGISTER SBIT32 MidPoint = (Top / 2);

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Swap all elements around the mid point.
	//
	for ( Count=0;Count < MidPoint;Count ++ )
		{
		REGISTER TYPE *Low = & Stack[ Count ];
		REGISTER TYPE *High = & Stack[ (Top - Count - 1) ];
		REGISTER TYPE Temp = (*Low);

		(*Low) = (*High);
		(*High) = Temp;
		}

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update a stack value.                                          */
    /*                                                                  */
    /*   We update a single item on the stack but check to make         */
    /*   sure that it exists.            .                              */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN STACK<TYPE,LOCK>::UpdateStack
        ( 
        CONST SBIT32				  Index, 
        CONST TYPE					  & Data 
        )
    {
	REGISTER BOOLEAN Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   If the element exists then update it.
	//
    if ( Index < Top )
		{ 
		Stack[ Index ] = Data;

		Result = True;
		}
	else
		{ Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
	ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the stack.  This call is not thread safe and should    */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> STACK<TYPE,LOCK>::~STACK( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\spinlock.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Spinlock.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new lock and initialize it.  This call is not         */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::SPINLOCK( SBIT32 NewMaxSpins,SBIT32 NewMaxUsers )
    {
	//
	//   Set the initial state.
	//
	MaxSpins = NewMaxSpins;
	MaxUsers = NewMaxUsers;
#ifdef ENABLE_RECURSIVE_LOCKS
	Owner = NULL;
	Recursive = 0;
#endif
    Spinlock = LockOpen;
	Semaphore = NULL;
    Waiting = 0;
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Zero the lock statistics.
	//
    TotalLocks = 0;
    TotalSleeps = 0;
    TotalSpins = 0;
    TotalTimeouts = 0;
    TotalWaits = 0;
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Update the semahore.                                           */
    /*                                                                  */
    /*   We only create the semaphore on first use.  So when we need    */
    /*   need to create a new semaphore any thread that is trying       */
    /*   to sleep on it comes here.                                     */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::UpdateSemaphore( VOID )
    {
	STATIC SBIT32 Active = 0;

	//
	//   We verify that there is still no semaphore
	//   otherwise we exit.
	//
	while ( Semaphore == NULL )
		{
		//
		//   We increment the active count and if we
		//   are first we are selected for special duty.
		//
		if ( (AtomicIncrement( & Active ) == 1) && (Semaphore == NULL) )
			{
			//
			//   We try to create a new semaphore.  If
			//   we fail we still exit.
			//   
			Semaphore = CreateSemaphore( NULL,0,MaxUsers,NULL );

			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			return;
			}
		else
			{ 
			//
			//  Decrement the active count and exit.
			//
			AtomicDecrement( & Active );

			Sleep( 1 ); 
			}
		}
	}

    /********************************************************************/
    /*                                                                  */
    /*   Wait for the spinlock.                                         */
    /*                                                                  */
    /*   Wait for the spinlock to become free and then claim it.        */
    /*                                                                  */
    /********************************************************************/

BOOLEAN SPINLOCK::WaitForLock( SBIT32 Sleep )
    {
	REGISTER LONG Cpus = ((LONG) NumberOfCpus());
#ifdef ENABLE_LOCK_STATISTICS
    REGISTER SBIT32 Sleeps = 0;
    REGISTER SBIT32 Spins = 0;
    REGISTER SBIT32 Waits = 0;

#endif
    do
        {
        REGISTER SBIT32 Count;
        
		//
		//   If there are already more threads waiting 
		//   than the number of CPUs then the odds of 
		//   getting the lock by spinning are slim, when 
		//   there is only one CPU the chance is zero, so 
		//   just bypass this step.
		//
		if ( (Cpus > 1) && (Cpus > Waiting) )
			{
			//
			//   Wait by spinning and repeatedly testing the
			//   spinlock.  We exit when the lock becomes free 
			//   or the spin limit is exceeded.
			//
			for 
				( 
					Count = MaxSpins;
					(Count > 0) && (Spinlock != LockOpen);
					Count -- 
				);
#ifdef ENABLE_LOCK_STATISTICS

			//
			//   Update the statistics.
			//
			Spins += (MaxSpins - Count);
			Waits ++;
#endif
			}
		else
			{ Count = 0; }

		//
		//   We have exhusted our spin count so it is time to
		//   sleep waiting for the lock to clear.
		//
        if ( Count == 0 )
            {
			//
			//   We do not create the semaphore until  
			//   somebody tries to sleep on it for the 
			//   first time.
			//
			if ( Semaphore == NULL )
				{ UpdateSemaphore(); }

			//
			//   We would normally hope to find a semaphore 
			//   avaiable ready for a sleep but the OS may  
			//   decline the request.  If this is the case 
			//   try the lock again.
			//
			if ( Semaphore != NULL )
				{
				//
				//   The lock is still closed so lets go to sleep on 
				//   a semaphore.  However, we must first increment
				//   the waiting count and test the lock one last time
				//   to make sure it is still busy and there is someone
				//   to wake us up later.
				//
				(VOID) AtomicIncrement( & Waiting );

				if ( ! ClaimSpinlock( & Spinlock ) )
					{
					if 
							( 
							WaitForSingleObject( Semaphore, Sleep ) 
								!= 
							WAIT_OBJECT_0 
							)
						{
#ifdef ENABLE_LOCK_STATISTICS
						//
						//   Count the number of times we have  
						//   timed out on this lock.
						//
						(VOID) AtomicIncrement( & TotalTimeouts );

#endif
						return False; 
						}
#ifdef ENABLE_LOCK_STATISTICS

					//
					//   Update the statistics.
					//
					Sleeps ++;
#endif
					}
				else
					{
					//
					//   Lucky - got the lock on the last attempt.
					//   Hence, lets decrement the sleep count and
					//   exit.
					// 
					(VOID) AtomicDecrement( & Waiting );
                
					break; 
					}
				}
            }
        }
    while ( ! ClaimSpinlock( & Spinlock ) );
#ifdef ENABLE_LOCK_STATISTICS

	//
	//   Update the statistics.
	//
    TotalSleeps += Sleeps;
    TotalSpins += Spins;
    TotalWaits += Waits;
#endif

    return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wake all sleepers.                                             */
    /*                                                                  */
    /*   Wake all the sleepers who are waiting for the spinlock.        */
    /*   All sleepers are woken because this is much more efficent      */
    /*   and it is known that the lock latency is short.                */
    /*                                                                  */
    /********************************************************************/

VOID SPINLOCK::WakeAllSleepers( VOID )
    {
    REGISTER LONG Wakeup = AtomicExchange( & Waiting, 0 );

	//
	//   We make sure there is still someone to be woken 
	//   up if not we check that the count has not become
	//   negative.
	//
    if ( Wakeup > 0 )
        {
		REGISTER LONG Cpus = ((LONG) NumberOfCpus());

		//
		//   We will only wake enough threads to ensure that 
		//   there is one active thread per CPU.  So if an 
		//   application has hundreds of threads we will try 
		//   prevent the system from becoming swampped.
		//
		if ( Wakeup > Cpus )
			{
			(VOID) AtomicAdd( & Waiting,(Wakeup - Cpus) );
			Wakeup = Cpus; 
			}

        //
        //   Wake up all sleepers as the lock has just been freed.
        //   It is a straight race to decide who gets the lock next.
        //
        if ( ! ReleaseSemaphore( Semaphore, Wakeup, NULL ) )
            { Failure( "Wakeup failed in ReleaseLock()" ); }
        }
    else
        {
        //
        //   When multiple threads pass through the critical  
        //   section it is possible for the 'Waiting' count  
		//   to become negative.  This should be very rare but 
		//   such a negative value needs to be preserved. 
        //
		if ( Wakeup < 0 )
			{ (VOID) AtomicAdd( & Waiting, Wakeup ); }
        }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a lock.  This call is not thread safe and should       */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

SPINLOCK::~SPINLOCK( VOID )
    {
#ifdef ENABLE_LOCK_STATISTICS
	//
	//   Print the lock statistics.
	//
	DebugPrint
		(
		"Spinlock: %d locks, %d timouts, "
		"%d locks per wait, %d spins per wait, %d waits per sleep.\n",
		TotalLocks,
		TotalTimeouts,
		(TotalLocks / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalSpins / ((TotalWaits <= 0) ? 1 : TotalWaits)),
		(TotalWaits / ((TotalSleeps <= 0) ? 1 : TotalSleeps))
		);

#endif
	//
	//   Close the semaphore handle.
	//
    if ( (Semaphore != NULL) && (! CloseHandle( Semaphore )) )
        { Failure( "Close semaphore in destructor for SPINLOCK" ); }
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\system.hpp ===
#ifndef _SYSTEM_HPP_
#define _SYSTEM_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard system include files.                             */
    /*                                                                  */
    /*   The standard system include files contain various definitions  */
    /*   used throughout the system.                                    */
    /*                                                                  */
    /********************************************************************/

#include <conio.h>
#include <iostream.h>
#include <stdarg.h>
#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <new.h>
#include <process.h>
#include <time.h>
#include <winsock2.h>
#include <windows.h>

    /********************************************************************/
    /*                                                                  */
    /*   Automatically set the debugging flag if needed.                */
    /*                                                                  */
    /*   There are various standards for enabling dedugging code.       */
    /*   Here we translate on to the standard used in this              */
    /*   application.                                                   */
    /*                                                                  */
    /********************************************************************/

#ifdef _M_IX86
#define ASSEMBLY_X86				  1
#endif

#ifdef _DEBUG
#define DEBUGGING                     1
#endif

#ifdef UNICODE
#undef CreateSemaphore
#undef OutputDebugString

#define CreateSemaphore				  CreateSemaphoreA
#define OutputDebugString			  OutputDebugStringA
#endif
#ifndef ALL_COMPLAINTS

    /********************************************************************/
    /*                                                                  */
    /*   Automatically disable anoying warnings.                        */
    /*                                                                  */
    /*   Some of the VC compiler warning are not very helpful so        */
    /*   we disable them here.                                          */
    /*                                                                  */
    /********************************************************************/

#pragma warning( disable : 4073 )
#pragma warning( disable : 4100 )
#pragma warning( disable : 4121 )
#pragma warning( disable : 4127 )
#pragma warning( disable : 4511 )
#pragma warning( disable : 4512 )
#pragma warning( disable : 4514 )
#pragma warning( disable : 4701 )
#pragma warning( disable : 4702 )
#pragma warning( disable : 4706 )
#pragma warning( disable : 4710 )
#pragma warning( disable : 4711 )
#pragma warning( disable : 4800 )
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\string.hpp ===
#ifndef _STRING_HPP_
#define _STRING_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Spinlock.hpp"
#include "Unique.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   A string class.                                                */
    /*                                                                  */
    /*   A typical string class manages variable length text strings.   */
    /*   Although we support the same in this class we ensure that      */
    /*   there is only one copy of every unique string.  There is a     */
    /*   cost associated with this at string creation time but a big    */
    /*   win when the strings are heavily compared, copied or           */
    /*   replicated.                                                    */
    /*                                                                  */
    /********************************************************************/

class STRING
    {
        //
        //   Private data.
        //
        DETAIL						  *Detail;

        //
        //   Static private data.
        //
#ifdef DISABLE_STRING_LOCKS
		STATIC UNIQUE<NO_LOCK>		  *Unique;
#else
		STATIC SPINLOCK				  Spinlock;
		STATIC UNIQUE<FULL_LOCK>	  *Unique;
#endif

    public:
		//
		//   Public inline functions.
		//
        STRING( VOID )
			{ DefaultString(); }

        STRING( CHAR *String )
			{ CreateString( String,strlen( String ) ); }

        STRING( CHAR *String,SBIT32 Size )
			{ CreateString( String,Size ); }

        STRING( CONST STRING & Update )
			{ Detail = Unique -> CopyString( DefaultString(),Update.Detail ); }

        INLINE VOID operator=( CONST STRING & Update )
			{ Detail = Unique -> CopyString( Detail,Update.Detail ); }

        INLINE BOOLEAN operator==( CONST STRING & String )
			{ return (Detail == String.Detail); }

        INLINE BOOLEAN operator!=( CONST STRING & String )
			{ return (Detail != String.Detail); }

        INLINE BOOLEAN operator<( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) < 0); }

        INLINE BOOLEAN operator<=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) <= 0); }

        INLINE BOOLEAN operator>( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) > 0); }

        INLINE BOOLEAN operator>=( CONST STRING & String )
			{ return (Unique -> CompareStrings( Detail,String.Detail ) >= 0); }

		INLINE SBIT32 Size( VOID )
			{ return Unique -> Size( Detail ); }

		INLINE CHAR *Value( VOID )
			{ return Unique -> Value( Detail ); }

		INLINE SBIT32 ValueID( VOID )
			{ return ((SBIT32) Detail); }

        ~STRING( VOID )
			{ DeleteString(); }

	private:
		//
		//   Private functions.
		//
		VOID CreateStringTable( VOID );

		//
		//   Private inline functions.
		//
		DETAIL *CreateString( CHAR *String,SBIT32 Size )
			{
			VerifyStringTable();

			return (Detail = Unique -> CreateString( String,Size ));
			}

        DETAIL *DefaultString( VOID )
			{
			VerifyStringTable();

			return (Detail = Unique -> DefaultString()); 
			}

        VOID DeleteString( VOID )
			{
			if ( Unique != NULL )
				{ Unique -> DeleteString( Detail ); }
			}

		VOID VerifyStringTable( VOID )
			{
			if ( Unique == NULL )
				{ CreateStringTable(); }
			}
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\thread.hpp ===
#ifndef _THREAD_HPP_
#define _THREAD_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Environment.hpp"
#include "Spinlock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The thread constants indicate various thread status            */
    /*   information.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoThread				  = -1;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures exported from the class.                       */
    /*                                                                  */
    /*   A thread started by this class should conform to the type      */
    /*   specification given here.                                      */
    /*                                                                  */
    /********************************************************************/

typedef VOID (*NEW_THREAD)( VOID *Parameter );

    /********************************************************************/
    /*                                                                  */
    /*   Thread synchronization.                                        */
    /*                                                                  */
    /*   This class privides a method for synchronizing a number        */
    /*   of worker threads with a master thread.  Each time the         */
    /*   master thread calls 'StartThread()' a new thread is created.   */
    /*   When a thread calls 'EndThread()' the thread is terminated.    */
    /*   At any point the master thread can enquire about the number    */
    /*   of active threads or wait for them to complete.                */
    /*                                                                  */
    /********************************************************************/

class THREAD : private ENVIRONMENT
    {
		//
		//   Private type definitions.
		//
		typedef struct
			{
			HANDLE					  Handle;
			SBIT32					  ThreadId;
			}
		THREAD_INFO;

        //
        //   Private data.
        //
        BOOLEAN                       Affinity;
        VOLATILE SBIT16               Cpu;
        BOOLEAN                       Priority;
        HANDLE                        Running;
        LONG                          Stack;
        HANDLE                        Started;

        SBIT32						  MaxThreads;
        SBIT32						  ThreadsUsed;
        VECTOR<THREAD_INFO>			  Threads;

		SPINLOCK					  Spinlock;

    public:
        //
        //   Public functions.
        //
        THREAD( VOID );

        VOID EndThread( VOID );

		VOID RegisterThread( VOID );

        VOID SetThreadStackSize( LONG Stack = 0 );

        BOOLEAN StartThread
			( 
			NEW_THREAD                Function, 
			VOID                      *Parameter = NULL, 
			BOOLEAN                   Wait = True 
			);

		VOID UnregisterThread( SBIT32 ThreadId = NoThread );

        BOOLEAN WaitForThreads( LONG WaitTime = INFINITE );

        ~THREAD( VOID );

		//
		//   Public inline functions.
		//
        VOID SetThreadAffinity( BOOLEAN NewAffinity = True )
			{ Affinity = NewAffinity; }

        VOID SetThreadPriority( BOOLEAN NewPriority = True )
			{ Priority = NewPriority; }

	private:
		//
		//   Private functions.
		//
		SBIT32 FindThread( SBIT32 ThreadId );

        //
        //   Disabled operations.
        //
        THREAD( CONST THREAD & Copy );

        VOID operator=( CONST THREAD & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\thread.cpp ===
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'cpp' files in this code is as         */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants local to the class.                            */
    /*      3. Data structures local to the class.                      */
    /*      4. Data initializations.                                    */
    /*      5. Static functions.                                        */
    /*      6. Class functions.                                         */
    /*                                                                  */
    /*   The constructor is typically the first function, class         */
    /*   member functions appear in alphabetical order with the         */
    /*   destructor appearing at the end of the file.  Any section      */
    /*   or function this is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "LibraryPCH.hpp"

#include "Thread.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants local to the class.                                  */
    /*                                                                  */
    /*   The thread class keeps track of active threads.                */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 ThreadsSize			  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Data structures local to the class.                            */
    /*                                                                  */
    /*   When we start a thread we want to configure it.  However,      */
    /*   we no longer have access to the class information.  Hence,     */
    /*   we need a structure to pass over all of the interesting        */
    /*   values to the new thread.                                      */
    /*                                                                  */
    /********************************************************************/

typedef struct
    {
    BOOLEAN							  Affinity;
    VOLATILE SBIT16					  *Cpu;
    NEW_THREAD						  Function;
    SBIT16							  MaxCpus; 
    VOID							  *Parameter;
    BOOLEAN							  Priority;
    HANDLE							  Running;
    HANDLE							  Started;
	THREAD							  *Thread;
	BOOLEAN							  Wait;
    }
SETUP_NEW_THREAD;

    /********************************************************************/
    /*                                                                  */
    /*   Static functions local to the class.                           */
    /*                                                                  */
    /*   The static functions used by this class are declared here.     */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL NewThread( VOID *SetupParameter );

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a thread class and initialize it.  This call is not     */
    /*   thread safe and should only be made in a single thread         */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

THREAD::THREAD( VOID ) : 
		//
		//   Call the constructors for the contained classes.
		//
		Threads( ThreadsSize,NoAlignment,CacheLineSize )
    {
	//
	//   The inital configuration.
	//
    Affinity = False;
    Cpu = 0;
    Priority = False;
    Stack = 0;

	MaxThreads = ThreadsSize;
	ThreadsUsed = 0;

	//
	//   This event is signaled when a thread is 
	//   running.
	//
    if ( (Running = CreateEvent( NULL, FALSE, FALSE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }

	//
	//   This event is signaled when a new thread can 
	//   be started.
	//
    if ( (Started = CreateEvent( NULL, FALSE, TRUE, NULL )) == NULL)
        { Failure( "Create event in constructor for THREAD" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   End a thread.                                                  */
    /*                                                                  */
    /*   Delete the thread handle from the internal table and then      */
    /*   terminate the thread.                                          */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::EndThread( VOID )
    {
	UnregisterThread();

	_endthread(); 
	}

    /********************************************************************/
    /*                                                                  */
    /*   Find a thread.                                                 */
    /*                                                                  */
    /*   Find a registered thread in the thread info table.             */
    /*                                                                  */
    /********************************************************************/

SBIT32 THREAD::FindThread( SBIT32 ThreadId )
    {
	REGISTER SBIT32 Count;

	//
	//   Find a thread in the active thread list.
	//
	for ( Count=0;Count < ThreadsUsed;Count ++ )
		{
		if ( ThreadId == Threads[ Count ].ThreadId )
			{ return Count; }
		}

	return NoThread;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   When a new thread is created it executes a special initial     */
    /*   function which configures it.  When control returns to this    */
    /*   function the thread is terminated.                             */
    /*                                                                  */
    /********************************************************************/

STATIC VOID CDECL NewThread( VOID *SetupParameter )
    {
    AUTO SETUP_NEW_THREAD Setup = (*(SETUP_NEW_THREAD*) SetupParameter);

    //
    //   Set the affinity mask to the next processor if requested.
    //  
    if ( (Setup.Affinity) && (Setup.MaxCpus > 1) )
        {
        REGISTER DWORD AffinityMask;

        if ( (*Setup.Cpu) < Setup.MaxCpus )
            { AffinityMask = (1 << ((*Setup.Cpu) ++)); }
        else
            {
            AffinityMask = 1;
            (*Setup.Cpu) = 1;
            }

        if ( SetThreadAffinityMask( GetCurrentThread(),AffinityMask ) == 0 )
            { Failure( "Affinity mask invalid in NewThread()" ); }
        }

    //
    //   Set the priority to 'HIGH' if requested.
    //
    if ( Setup.Priority )
        { SetThreadPriority( GetCurrentThread(),THREAD_PRIORITY_HIGHEST ); }

	//
	//   The thread is now so add it to the table
	//   executiong threads.
	//
	Setup.Thread -> RegisterThread();

	//
	//   Wake up anyone who is waiting.
	//
	if ( Setup.Wait )
		{ SetEvent( Setup.Running ); }

	SetEvent( Setup.Started );

    //
    //   Call thread function.
    //
    Setup.Function( Setup.Parameter );

    //
    //   The thread function has returned so exit.
    //
    Setup.Thread -> EndThread();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Register the current thread.                                   */
    /*                                                                  */
    /*   When a thread has created we can add the thread info to        */
    /*   our internal table.                                            */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::RegisterThread( VOID )
    {
	REGISTER SBIT32 ThreadId = GetThreadId();

	//
	//   Claim a spinlock so we can update the 
	//   thread table.
	//
	Spinlock.ClaimLock();

	if ( FindThread( ThreadId ) == NoThread )
		{
		AUTO HANDLE NewHandle;
		REGISTER HANDLE Process = GetCurrentProcess();
		REGISTER HANDLE Thread = GetCurrentThread();

		//
		//   We need to duplicate the handle so we get
		//   a real thread handle and not the pretend
		//   ones supplied by NT.
		//
		if
				(
				DuplicateHandle
					(
					Process,
					Thread,
					Process,
					& NewHandle,
					DUPLICATE_SAME_ACCESS,
					False,
					DUPLICATE_SAME_ACCESS
					)
				)
			{
			REGISTER THREAD_INFO *ThreadInfo;

			//
			//   We may need to expand the table if there are
			//   a large number of threads.
			//
			while ( ThreadsUsed >= MaxThreads )
				{ Threads.Resize( (MaxThreads *= ExpandStore) ); }

			//
			//   Add the thread handle to the table.
			//
			ThreadInfo = & Threads[ ThreadsUsed ++ ];

			ThreadInfo -> Handle = NewHandle;
			ThreadInfo -> ThreadId = ThreadId;
			}
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Set thread stack size.                                         */
    /*                                                                  */
    /*   Set thread stack size.  This will cause all new threads to     */
    /*   be created with the selected stack size.                       */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::SetThreadStackSize( LONG Stack ) 
    {
#ifdef DEBUGGING
    if ( Stack >= 0 )
        {
#endif
        this -> Stack = Stack;
#ifdef DEBUGGING
        }
    else
        { Failure( "Stack size in SetThreadStack()" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Start a new thread.                                            */
    /*                                                                  */
    /*   Start a new thread and configure it as requested by the        */
    /*   caller.  If needed we will set the affinity and priority       */
    /*   of this thread later.                                          */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::StartThread( NEW_THREAD Function,VOID *Parameter,BOOLEAN Wait )
    {
    STATIC SETUP_NEW_THREAD Setup;

	//
	//   Wait for any pending thread creations to
	//   complete.
	//
    while
        (
        WaitForSingleObject( Started,INFINITE )
            !=
        WAIT_OBJECT_0
        );

	//
	//   Create a thread activation record.
	//
    Setup.Affinity = Affinity;
    Setup.Cpu = & Cpu;
    Setup.Function = Function;
    Setup.MaxCpus = NumberOfCpus();
    Setup.Parameter = Parameter;
    Setup.Priority = Priority;
	Setup.Running = Running;
	Setup.Started = Started;
	Setup.Thread = this;
	Setup.Wait = Wait;

	//
	//   Call the operating system to start the thread.
	//
    if ( _beginthread( NewThread,(unsigned) Stack,(VOID*) & Setup ) != NULL )
		{
		//
		//   Wait for the thread to initialize is needed.
		//
		if ( Wait )
			{
			//
			//   Wait for the thread to start to run.
			//
			while
				(
				WaitForSingleObject( Running,INFINITE )
					!=
				WAIT_OBJECT_0
				);
			}

		return True;
		}
	else
		{ return False; }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Unregister the current thread.                                 */
    /*                                                                  */
    /*   When a thread has terminated we can delete the thread          */
    /*   info from our internal table.                                  */
    /*                                                                  */
    /********************************************************************/

VOID THREAD::UnregisterThread( SBIT32 ThreadId )
    {
	REGISTER SBIT32 Start;

	//
	//   If no 'ThreadId' assume the current thread.
	//
	if ( ThreadId == NoThread )
		{ ThreadId = GetThreadId(); }

	//
	//   Claim a spinlock so we can update the 
	//   thread table.
	//
	Spinlock.ClaimLock();

	//
	//   Search for the thread info to delete
	//   in the table.
	//
	if ( (Start = FindThread( ThreadId )) != NoThread )
		{
		REGISTER SBIT32 Count;

		//
		//   Close the handle to the thread and
		//   update the table size.
		//
		CloseHandle( Threads[ Start ].Handle );

		ThreadsUsed --;

		//
		//   Copy down the remaining thread info.
		//
		for ( Count=Start;Count < ThreadsUsed;Count ++ )
			{ Threads[ Count ] = Threads[ (Count+1) ]; }
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();
    }

    /********************************************************************/
    /*                                                                  */
    /*   Wait for threads.                                              */
    /*                                                                  */
    /*   Wait for all threads to finish and then return.  As this may   */
    /*   take a while an optional timeout may be supplied.              */
    /*                                                                  */
    /********************************************************************/

BOOLEAN THREAD::WaitForThreads( LONG WaitTime )
    {
	//
	//   Claim a spinlock so we can read the 
	//   thread table.
	//
	Spinlock.ClaimLock();

    while ( ThreadsUsed > 0 )
		{
		REGISTER HANDLE Handle = (Threads[0].Handle);
		REGISTER SBIT32 ThreadId = (Threads[0].ThreadId);
		REGISTER DWORD Status;

		//
		//   We are finished so release the lock.
		//
		Spinlock.ReleaseLock();

		//
		//   Wait for the first thread in the thread info 
		//   table to terminate.
		//
		if 
				( 
				(Status = WaitForSingleObject( Handle,(DWORD) WaitTime ))
					==
				WAIT_TIMEOUT
				)
			{ return False; }

		//
		//   We have woken up the thread must of terminated
		//   or the handle is bad in some way.  In any case
		//   lets delete the handle and try to sleep again
		//   if there are any more active threads.
		//
		UnregisterThread( ThreadId );

		//
		//   Claim a spinlock so we can read the 
		//   thread table.
		//
		Spinlock.ClaimLock();
		}

	//
	//   We are finished so release the lock.
	//
	Spinlock.ReleaseLock();

	return True;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the thread class.  This call is not thread safe        */
    /*   and should only be made in a single thread environment.        */
    /*                                                                  */
    /********************************************************************/

THREAD::~THREAD( VOID )
    {
	if 
			(
			! CloseHandle( Running )
				||
			! CloseHandle( Started )
			)
		{ Failure( "Event handles in destructor for THREAD" ); }
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\vector.hpp ===
#ifndef _VECTOR_HPP_
#define _VECTOR_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "New.hpp"
#ifdef DEBUGGING

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants specified here control various aspects of the    */
    /*   vector classes debugging operations.                           */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 DebugDisplaySize		  = 8;
#endif

    /********************************************************************/
    /*                                                                  */
    /*   Vector creation, management and use.                           */
    /*                                                                  */
    /*   A vector is esentially an allocated array of data.  However,   */
    /*   vectors also have some special features.  A vector can be      */
    /*   aligned to any binary boundary and each element can also be    */
    /*   aligned to any binary boundary.  This is very helpful in       */
    /*   SMP systems as increased performance can be obtained by        */
    /*   using vectors on selected data structures.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> class VECTOR
    {
        //
        //   Private data.
        //
        SBIT32                        Alignment;
        SBIT32                        Elements;
        SBIT32                        Size;

        CHAR                          *Allocated;
        CHAR                          *Aligned;
#ifdef DEBUGGING
		TYPE                          *Display[DebugDisplaySize];
#endif


    public:
        //
        //   Public functions.
        //
        VECTOR
            ( 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

       VECTOR
            ( 
            SBIT32					  One, 
            SBIT32					  Two, 
            SBIT32					  NumberOfElements, 
            SBIT32					  AlignSize, 
            SBIT32					  AlignStart
            );

        VOID Resize( SBIT32 Reallocate );

        ~VECTOR( VOID );

		//
		//   Public inline functions.
		//
        INLINE TYPE & operator[]( SBIT32 Index )
			{
#ifdef DEBUGGING
			if ( (Index < 0) || (Index >= Elements) )
				{ Failure( "Array subscript in VECTOR[]" ); }

#endif
			return (*((TYPE*) & Aligned[ (Index * Size) ]));
			}

        INLINE TYPE *operator&( VOID )
			{ return ((TYPE*) & Aligned[0]); }

		SBIT32 SizeOfVector( VOID ) 
			{ return Elements; }

	private:
		//
		//   Private functions.
		//
        VOID AllocateAndAlignVector
            ( 
            SBIT32                        NumberOfElements, 
            SBIT32                        AlignSize, 
            SBIT32                        AlignStart
            );

		TYPE & ComputeAddressWithMultiply( SBIT32 Index );

		TYPE & ComputeAddressWithShift( SBIT32 Index );

        //
        //   Disabled operations.
        //
        VECTOR( CONST VECTOR & Copy );

        VOID operator=( CONST VECTOR & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One,
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize,
        SBIT32                        AlignStart
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Ceate a memory allocation and initialize it.  This call is     */
    /*   not thread safe and should only be made in a single thread     */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::VECTOR
        ( 
        SBIT32                        One, 
        SBIT32                        Two, 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
	REGISTER SBIT32 Count;

	//
	//   Allocate the storage.
	//
	AllocateAndAlignVector( NumberOfElements,AlignSize,AlignStart );

	//
	//   Call the constructors.
	//
	for ( Count = 0;Count < NumberOfElements;Count ++ )
		{ (VOID) PLACEMENT_NEW( & Aligned[ (Count * Size) ], TYPE( One,Two ) ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Allocate and align a vector.                                   */
    /*                                                                  */
    /*   We need to allocate some memory and align it as requested      */
    /*   by the user.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::AllocateAndAlignVector
        ( 
        SBIT32                        NumberOfElements, 
        SBIT32                        AlignSize, 
        SBIT32                        AlignStart 
        )
    {
    if ( NumberOfElements > 0 )
        {
#ifdef DEBUGGING
		REGISTER SBIT32 Count;

#endif
        //
        //   We need to remember the initial alignment and count of
		//   elements for later.
        //   
        Alignment = AlignStart;
        Elements = NumberOfElements;

        //
        //   Calculate the new element size using the requested alignment
		//   value.
        //
		Size = (AlignSize - (sizeof(TYPE) % AlignSize));
		Size = (Size == AlignSize) ? 0 : Size;
		Size += sizeof(TYPE);

        //
        //   Allocate memory and call constructor for each element.
        //   Calculate the start address for requested alignment.
        //
        Allocated = new CHAR [ (AlignStart + (NumberOfElements * Size)) ];

		Aligned = (CHAR*) (AlignStart - (((LONG) Allocated) % AlignStart));
		Aligned = (((SBIT32) Aligned) == AlignStart) ? 0 : Aligned;
		Aligned += (LONG) Allocated;
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < NumberOfElements) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = (TYPE*) & Aligned[ (Count * Size) ]; }
#endif
        }
    else
        { Failure( "Allocation size in AllocateAndAlignVector" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Resize a memory allocation.                                    */
    /*                                                                  */
    /*   Resize a memory allocation and initialize the resized area.    */
    /*   This call is not thread safe and should only be made in a      */
    /*   single thread environment.                                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VOID VECTOR<TYPE>::Resize( SBIT32 Reallocate )
    {
    if ( Reallocate > 0 )
        {
		REGISTER SBIT32 Count;
		REGISTER CHAR *NewAllocated = new CHAR [ (Alignment + (Reallocate * Size)) ];
		REGISTER CHAR *NewAligned = ((CHAR*) (((LONG) NewAllocated) % Alignment));
		REGISTER SBIT32 Minimum = (Elements < Reallocate) ? Elements : Reallocate;

		//
		//   Calculate the new aligned address
		//.
		NewAligned = (CHAR*) (Alignment - ((LONG) NewAligned));
		NewAligned = (((SBIT32) NewAligned) == Alignment) ? 0 : NewAligned;
		NewAligned += (LONG) NewAllocated;

		//
		//   Copy each existing element into the new allocation.
		//
		for ( Count = 0;Count < Minimum;Count ++ )
			{ 
			REGISTER SBIT32 Offset = (Count * Size);

			(*((TYPE*) & NewAligned[ Offset ])) = 
				(*((TYPE*) & Aligned[ Offset ])); 
			}

		//
		//   Call the constructor for each new element.
		//
		for ( Count = Elements;Count < Reallocate;Count ++ )
			{ (VOID) PLACEMENT_NEW( & NewAligned[ (Count * Size) ], TYPE ); }

		//
		//   Call the destructor for each original original element.
		//
		for ( Count = (Elements - 1);Count >= 0;Count -- )
			{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

		//
		//   Delete the original allocation.
		//
		delete [] Allocated;
#ifdef DEBUGGING

		//
		//   When we are in debug mode calculate the addresses
		//   of the first few elements of the vector.
		//
		for 
				( 
				Count = 0;
				(Count < Reallocate) && (Count < DebugDisplaySize);
				Count ++ 
				)
			{ Display[ Count ] = (TYPE*) & NewAligned[ (Count * Size) ]; }
#endif
 
        //
        //   Finally, lets update the information about the new
		//   amended allocation.
        //   
        this -> Elements = Reallocate;
        this -> Allocated = NewAllocated;
        this -> Aligned = NewAligned;
        }
    else
        { Failure( "Rellocation size in Resize" ); }
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a vector.  This call is not thread safe and should     */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE> VECTOR<TYPE>::~VECTOR( VOID )
    {
	REGISTER SBIT32 Count;

	//
	//   Call the destructors.
	//
	for ( Count = (Elements - 1);Count >= 0;Count -- )
		{ PLACEMENT_DELETE( & Aligned[ (Count * Size) ], TYPE ); }

	//
	//   Delete the storage.
	//
    delete [] Allocated;
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\ticket.hpp ===
#ifndef _TICKET_HPP_
#define _TICKET_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Lock.hpp"
#include "Vector.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The ticket constants specify the initial size of the           */
    /*   ticket array.                                                  */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 TicketSize			  = 128;

    /********************************************************************/
    /*                                                                  */
    /*   Ticketing to maintain ordering.                                */
    /*                                                                  */
    /*   This class provides general purpose event ordering so          */
    /*   that events can arrive in any order but processed in           */
    /*   sequential order with a minimal amount of fuss.                */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK=NO_LOCK> class TICKET : public LOCK
    {
		//
		//   Private data structure.
		//
		typedef struct
			{
			BOOLEAN					  Available;
			TYPE					  Data;
			}
		STUB;

        //
        //   Private data.
        //
        SBIT32						  MaxSize;

        SBIT32						  Back;
        SBIT32						  Front;

        SBIT32						  Base;
        SBIT32						  Stride;

        VECTOR<STUB>				  Ticket;

    public:
        //
        //   Public functions.
        //
        TICKET
			( 
			SBIT32					  Start = 0,
			SBIT32					  NewMaxSize = TicketSize,
			SBIT32					  NewStride = 1  
			);

		BOOLEAN CollectTicket( TYPE *Data,SBIT32 *Ticket );

		SBIT32 NumberOfTickets( VOID );

		SBIT32 NewTicket( VOID );

		BOOLEAN PunchTicket( CONST TYPE & Data,SBIT32 Ticket );

        ~TICKET( VOID );

		//
		//   Public inline functions.
		//
		SBIT32 LowestOutstandingTicket( VOID )
			{ return Base; }

	private:

        //
        //   Disabled operations.
        //
        TICKET( CONST TICKET & Copy );

        VOID operator=( CONST TICKET & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new ticket queue and prepare it for use.  This call   */
    /*   is not thread safe and should only be made in a single thread  */
    /*   environment.                                                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::TICKET
		( 
		SBIT32						  Start,
		SBIT32						  NewMaxSize,
		SBIT32						  NewStride
		) : 
		//
		//   Call the constructors for the contained classes.
		//
		Queue( NewMaxSize,1,CacheLineSize )
    {
#ifdef DEBUGGING
    if ( NewMaxSize > 0 )
        {
#endif
		//
		//   Setup the control information.
		//
        MaxSize = NewMaxSize;

		//
		//   Setup the queue so it is empty.
		//
        Back = 0;
        Front = 0;

		//
		//   Set the initial ticket number.
		//
		Base = Start;
		Stride = NewStride;
#ifdef DEBUGGING
        }
    else
        { Failure( "MaxSize in constructor for TICKET" ); }
#endif
    }

    /********************************************************************/
    /*                                                                  */
    /*   Issue a new ticket.                                            */
    /*                                                                  */
    /*   We issue a new ticket and allocate a place in the line.  We    */
    /*   also we reserve space in the ticket queue.                     */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NewTicket( VOID )
    {
	REGISTER SBIT32 Result;

	//
	//   Claim an exclisive lock (if enabled).
	//
    ClaimExclusiveLock();

    //
    //   Add element to the queue.  If necessary wrap round 
    //   to the front of the array.
    //
    Ticket[ Back ++ ].Available = False;

     if ( Back >= MaxSize )
        { Back = 0; }

	//
	//   Compute the ticket number.
	//
	Result = (Base + (NumberOfTickets() * Stride));

    //
    //   Verify that the queue is not full.  If it is full then 
    //   double its size and copy wrapped data to the correct
    //   position in the new array.
    //
    if ( Front == Back )
		{
		REGISTER SBIT32 Count;
		REGISTER SBIT32 NewSize = (MaxSize * ExpandStore);

		//
		//   Expand the queue (it will be at least doubled).
		//
		Ticket.Resize( NewSize );

		//
		//   Copy the tail end of the queue to the correct
		//   place in the expanded queue.
		//
		for ( Count = 0;Count < Back;Count ++ )
			{ Ticket[ (MaxSize + Count) ] = Ticket[ Count ]; }

		//
		//   Update the control information.
		//
		Back += MaxSize;
		MaxSize = NewSize;
		}

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

	return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Punch a ticket and store any associated data.                  */
    /*                                                                  */
    /*   We punch a ticket so it can be collected and store any         */
    /*   related data.                                                  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::PunchTicket
		( 
		CONST TYPE					  & Data,
		SBIT32						  Ticket
		)
    {
    REGISTER BOOLEAN Result;
	REGISTER SBIT32 TicketOffset;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   Compute the offset in the ticket array.
	//
	TicketOffset = ((Ticket - Base) / Stride);

	//
	//   Ensure the ticket refers to and active ticket
	//   that has not already been recycled.
	//
	if ( (TicketOffset >= 0) && (TicketOffset < NumberOfTickets()) )
		{
		REGISTER STUB *Stub = & Ticket[ TicketOffset ];

		//
		//   Ensure the ticket has not already been
		//   punched.
		//
		if ( ! Stub -> Available )
			{
			Stub -> Available = True;
			Stub -> Data = Data;

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Collect the lowest numbered ticket.                            */
    /*                                                                  */
    /*   We try to collect the lowest numbered ticket that has been     */
    /*   issued.  If it is has been punched and is available we         */
    /*   recycle it after returning any associated data to the caller.  */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> BOOLEAN TICKET<TYPE,LOCK>::CollectTicket
		( 
		TYPE						  *Data,
		SBIT32						  *Ticket
		)
    {
    REGISTER BOOLEAN Result;

	//
	//   Claim an exclusive lock (if enabled).
	//
    ClaimExclusiveLock();

	//
	//   We make sure the ticket queue is not empty.
	//
    if ( Front != Back )
        {
		REGISTER STUB *Stub = & Ticket[ Front ];

		//
		//   We can collect the first ticket in the
		//   ticket queue if it has been punched.
		//
		if ( Stub -> Available )
			{
			//
			//   We have an ticket ready so return it to 
			//   the caller.  If we walk off the end of  
			//   the ticket queue then wrap to the other
			//   end.
			//
			(*Data) = Stub -> Data;
			(*Ticket) = (Base += Stride);

			if ( (++ Front) >= MaxSize )
				{ Front = 0; }

			Result = True;
			}
		else
			{ Result = False; }
        }
    else
        { Result = False; }

	//
	//   Release any lock we claimed earlier.
	//
    ReleaseExclusiveLock();

    return Result;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Calculate the size of the reorder queue.                       */
    /*                                                                  */
    /*   Calculate the size of the queue and return it to the caller.   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> SBIT32 TICKET<TYPE,LOCK>::NumberOfTickets( VOID )
    {
    REGISTER SBIT32 Size;

	//
	//   Compute the size of the reorder queue.
	//
	Size = (Back - Front);

	//
	//   If the queue has wrapped then adjust as needed.
	//
	if ( Size < 0 )
		{ Size += MaxSize; }

    return Size;
    }

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory a queue.  This call is not thread safe and should      */
    /*   only be made in a single thread environment.                   */
    /*                                                                  */
    /********************************************************************/

template <class TYPE,class LOCK> TICKET<TYPE,LOCK>::~TICKET( VOID )
    { /* void */ }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapia.cxx

Abstract:

    contains the ANSI version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>


/*-----------------------------------------------------------------------------
CreateContainer
----------------------------------------------------------------------------*/
URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheContainerA(
                 IN LPCSTR Name, 
                 IN LPCSTR CachePrefix, 
                 IN LPCSTR CachePath, 
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                 IN DWORD dwOptions,
                 IN OUT LPVOID pvBuffer,
                 IN OUT LPDWORD cbBuffer
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerA", "%q, %q, %q, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CreateContainer(
                        Name,
                        CachePrefix,
                        CachePath,
                        KBCacheLimit,
                        dwOptions);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheContainerA(
IN LPCSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerA", "%q, %d", Name, dwOptions));

    DWORD Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteContainer(
                        Name,
                        0
                        );

    LEAVE_CACHE_API();
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerA(
    IN OUT LPDWORD pdwModified,
    OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
    IN OUT LPDWORD lpdwContainerInfoBufferSize,
    IN DWORD dwOptions
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerA",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpdwContainerInfoBufferSize,
        dwOptions
    ));

    DWORD Error;
    HANDLE hFind = NULL;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    hFind = GlobalUrlContainers->FindFirstContainer(pdwModified, 
        lpContainerInfo, lpdwContainerInfoBufferSize, dwOptions);

    if (hFind)
        Error = ERROR_SUCCESS;
    else
    {
        Error = GetLastError();
        // BUGBUG: Free hFind?
        // does the free take NULL?
    }

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError( Error );
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

    
URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheContainerA(
IN HANDLE hFind, 
OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
IN OUT LPDWORD lpdwContainerInfoBufferSize
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerA",
        "%#x, %#x, %#x",
        hFind, 
        lpContainerInfo,
        lpdwContainerInfoBufferSize
    ));

    DWORD Error;
    DWORD i;


    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    if (GlobalUrlContainers->FindNextContainer(hFind, 
            lpContainerInfo, lpdwContainerInfoBufferSize))
        Error = ERROR_SUCCESS;
    else
        Error = GetLastError();

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwExpectedFileSize,
    IN LPCSTR   lpszFileExtension,
    OUT LPSTR lpszFileName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpszFileExtension: File extension for the saved data file

    dwExpectedFileSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileName : pointer to a buffer that receives the full path name of
        the the temp file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryA", "%q, %q, %d, %q, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) || IsBadWriteFileName( lpszFileName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Null first char in lpszFileName cues CreateUniqueFile
    // to generate a file name from scratch. Otherwise,
    // an attempt will be made to generate the filename
    // using the contents of the buffer.
    *lpszFileName = '\0';

    Error = GlobalUrlContainers->CreateUniqueFile(
                        lpszUrlName,
                        dwExpectedFileSize,
                        lpszFileExtension,
                        lpszFileName, 
                        NULL
                        );

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryA(
    IN LPCSTR lpszUrlName,
    IN LPCSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPBYTE lpHeaderInfo,
    IN DWORD dwHeaderSize,
    IN LPCSTR lpszFileExtension,
    IN LPCSTR lpszOriginalUrl
    )

/*++

Routine Description:

    This API caches a specified URL in the internet service  cache
    storage. It creates a database entry of the URL info and moves the
    URL file to cache storage.

Arguments:

    lpszUrlName : name of the URL that is cached.

    lpszLocalFileName : name of the local file where the URL data is
        stored. This file will be moved to an another file in cache storage, so
        this name is invalid after this api successfully returns. The
        name should include full path.

    ExpireTime : Expire time (GMT) of the file being cached. If it is
        unknown set it to zero.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    CacheEntryType : type of this new entry.

    lpHeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    lpszFileExtension :  file extension used to create this file.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryA",
        "%q, %q, <expires>, <last-mod>, %d, %#x, %d, %q, %q",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpHeaderInfo,
        dwHeaderSize,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadReadFileName( lpszLocalFileName ) : FALSE ) ) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( lpHeaderInfo != NULL ) 
    {
        if( IsBadReadPtr(lpHeaderInfo, dwHeaderSize) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    if( lpszFileExtension != NULL ) 
    {
        if( IsBadReadPtr(lpszFileExtension, 3) ) 
        {
            Error =  ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }

    FILETIME     ftPostCheck;
    ftPostCheck.dwLowDateTime = 0;
    ftPostCheck.dwHighDateTime = 0; 
  
    // Record args in structure.
    AddUrlArg Args;
    memset(&Args, 0, sizeof(Args));
    Args.pszUrl      = lpszUrlName;
    Args.pszFilePath = lpszLocalFileName;
    Args.dwFileSize  = 0;
    Args.qwExpires   = FT2LL(ExpireTime);
    Args.qwLastMod   = FT2LL(LastModifiedTime);
    Args.qwPostCheck = FT2LL(ftPostCheck);
    Args.ftCreate = LastModifiedTime;
    Args.dwEntryType = CacheEntryType;
    Args.pbHeaders   = (LPSTR)lpHeaderInfo;
    Args.cbHeaders   = dwHeaderSize;
    Args.pszFileExt  = lpszFileExtension;
    Args.pszRedirect = lpszOriginalUrl ? (LPSTR) lpszOriginalUrl : NULL;
    Args.fImage      = FALSE;

    Error = UrlCacheCommitFile(&Args);

    LEAVE_CACHE_API();
}



URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileA","%q, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize, dwReserved));
        
    DWORD Error;

    // validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
            IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RetrieveUrl(
                        lpszUrlName,
                        (lpCacheEntryInfo ? &lpCacheEntryInfo : NULL),
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    LEAVE_CACHE_API();
}

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamA(
    IN LPCSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API retrieves the specified URL file. When the file is retrieved
    it also checked out to the user to use. The user has to call
    UnlockUrlFile when he/she finished using it.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    fRandomRead : if this flag is set to TRUE, then stream is open for
        random access.

    dwReserved: must pass 0

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamA",
        "%q, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpdwCacheEntryInfoBufferSize,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD Error, dwFileSize;

    // Validate parameters.
    if(   IsBadUrl( lpszUrlName )
       || IsBadWriteUrlInfo(lpCacheEntryInfo, *lpdwCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->RetrieveUrl
        (lpszUrlName, &lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize,
            LOOKUP_URL_NOCREATE, RETRIEVE_WITHOUT_CHECKS);

    if( Error != ERROR_SUCCESS )
        goto Cleanup;
    fLocked = TRUE;        

    // Allocate a stream handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hStream)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hStream)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // Open the file.
    hFile = CreateFile
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);

    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        Error = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto Cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    pStream->SourceUrlName = NewString(lpszUrlName);
    if( !pStream->SourceUrlName)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    Error = ERROR_SUCCESS;

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hStream)
        {
            HandleMgr.Free (hStream);
            hStream = NULL;
        }
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(lpszUrlName);
        SetLastError (Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hStream);
    return hStream;
}


URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    OUT LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN OUT LPDWORD lpdwCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This function retrieves the specified cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that receives the url
        info.

    lpdwCacheEntryInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoA", "%q, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpdwCacheEntryInfoBufferSize));

    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ||
        (lpCacheEntryInfo && !lpdwCacheEntryInfoBufferSize) ||
        (lpCacheEntryInfo && lpdwCacheEntryInfoBufferSize && IsBadWriteUrlInfo(
                lpCacheEntryInfo,
                *lpdwCacheEntryInfoBufferSize) ) )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpdwCacheEntryInfoBufferSize,
                        LOOKUP_URL_NOCREATE,
                        0);

    LEAVE_CACHE_API();
}


BOOLAPI
GetUrlCacheEntryInfoExA(
    IN LPCSTR       lpszUrl,
    OUT LPINTERNET_CACHE_ENTRY_INFOA lpCEI,
    IN OUT LPDWORD  lpcbCEI,
    OUT LPSTR       lpszOut,
    IN OUT LPDWORD  lpcbOut,
    LPVOID          lpReserved,
    DWORD           dwFlags
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x", lpszUrl, lpCEI, lpcbCEI, lpszOut, lpcbOut, lpReserved, dwFlags));

    DWORD Error;

    // Validate parameters
    // NOTE: once the following params change, edit GetUrlCacheEntryInfoExW accordingly.
    if (   IsBadUrl(lpszUrl)
        || lpszOut
        || lpcbOut 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // We allow mixing of INTERNET_CACHE_FLAG_ALLOW_COLLISIONS with lookup flags
    Error = GlobalUrlContainers->GetUrlInfo
        (lpszUrl, lpCEI, lpcbCEI, LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS), dwFlags);
        
    LEAVE_CACHE_API();
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoA(
    IN LPCSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOA lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the specified fields of the cache entry info.

Arguments:

    lpszUrlName : name of the url file (unused now).

    lpCacheEntryInfo : pointer to the url info structure that has the url info to
        be set.

    dwFieldControl : Bitmask that specifies the fields to be set.

Return Value:

    Windows Error Code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoA", "%q, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    DWORD Error;

    //
    // validate parameters.
    //

    if( IsBadUrl( lpszUrlName ) ||
            IsBadReadUrlInfo( lpCacheEntryInfo )) {

        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlInfo(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        dwFieldControl );

    LEAVE_CACHE_API();
}

URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryA(
    IN LPCSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpdwFirstCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function starts the cache entries enumeration and returns
    the first entry in the cache.

Arguments:

    lpszUrlSearchPattern : pointer to a search pattern string. Currently
        it is not implemented.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryA",
        "%q, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpdwFirstCacheEntryInfoBufferSize
    ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if (IsBadWriteUrlInfo(lpFirstCacheEntryInfo,
                          *lpdwFirstCacheEntryInfoBufferSize))
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               lpFirstCacheEntryInfo, 
                                               lpdwFirstCacheEntryInfoBufferSize, 
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        hFind = NULL;
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryA(
    IN HANDLE hFind,
    OUT LPCACHE_ENTRY_INFOA lpNextCacheEntryInfo,
    IN OUT LPDWORD lpdwNextCacheEntryInfoBufferSize
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

    lpFirstCacheEntryInfo : pointer to a cache entry info structure.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryA",
        "%#x, %#x, %#x",
        hFind, 
        lpNextCacheEntryInfo,
        lpdwNextCacheEntryInfoBufferSize
    ));

    DWORD Error = ERROR_SUCCESS;
    CACHE_FIND_FIRST_HANDLE* pFind;

    // Validate parameters.
    if (!hFind || IsBadWriteUrlInfo(lpNextCacheEntryInfo,
                                    *lpdwNextCacheEntryInfoBufferSize)) 
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               lpNextCacheEntryInfo, 
                                               lpdwNextCacheEntryInfoBufferSize,
                                               URLCACHE_FIND_DEFAULT_FILTER,
                                               NULL,
                                               FIND_FLAGS_OLD_SEMANTICS);



Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API(Error==ERROR_SUCCESS);
    return (Error == ERROR_SUCCESS );
}


INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExA(
    IN     LPCSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExA",
        "%q, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;
    HANDLE hFind = NULL;

    // Validate parameters.
    if (IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    // Get the first entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               lpszUrlSearchPattern, 
                                               pEntryInfo, 
                                               pcbEntryInfo,
                                               dwFilter,
                                               GroupId,
                                               dwFlags);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        if (hFind)
        {
            GlobalUrlContainers->FreeFindHandle(hFind);
            hFind = NULL;
        }
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }

    DEBUG_LEAVE_API (hFind);
    return hFind;    
}

BOOLAPI
FindNextUrlCacheEntryExA(
    IN     HANDLE    hFind,
    OUT    LPINTERNET_CACHE_ENTRY_INFOA pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExA",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hFind,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    DWORD Error;

    // Validate parameters.
    if (!hFind || IsBadWritePtr (pcbEntryInfo, sizeof(DWORD)))
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    

    // Get the next entry.
    Error = GlobalUrlContainers->FindNextEntry(&hFind, 
                                               NULL, 
                                               pEntryInfo, 
                                               pcbEntryInfo, 
                                               NULL, 
                                               NULL,
                                               NULL);
    

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
FreeUrlCacheSpaceA(
    IN LPCSTR lpszCachePath,
    IN DWORD dwFactor,
    IN DWORD dwFilter
    )
/*++

Routine Description:

    This function cleans up the cache entries in the specified ccahe
    path to make space for future cache entries.

Arguments:

    dwFactor: % of free space

Return Value:

    TRUE if the cleanup is successful. Otherwise FALSE, GetLastError()
    returns the extended error.

--*/
{
    DWORD Error;
    
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpace", 
        "<path>,%d, %#x", dwFactor, dwFilter));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->CleanupUrls(lpszCachePath, dwFactor, dwFilter);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFileA(
    LPCSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
   
    DWORD Error;
    DWORD i;

    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFile",
        "%q, %#x", lpszUrlName, dwReserved));

    // validate parameters.
    if( IsBadUrl( lpszUrlName )  ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->UnlockUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntryA(
    IN LPCSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntry",
        "%q", lpszUrlName));


    DWORD Error;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) ) {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->DeleteUrl(lpszUrlName);

    LEAVE_CACHE_API();
}

#ifdef __URLCACHE_JUNK__
BOOLAPI
SetUrlCacheEntryGroupA(
    IN LPCSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupA", 
        "%q, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    DWORD Error;

    // Validate parameters.
    if (IsBadUrl(lpszUrlName)
        || !GroupId
        || pbGroupAttributes
        || cbGroupAttributes
        || lpReserved
        )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetUrlGroup (lpszUrlName, dwFlags, GroupId);

    LEAVE_CACHE_API();
}



URLCACHEAPI
BOOL
WINAPI
GetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupInfo ||
        !lpdwGroupInfo ||
        IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOA) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->GetGroupAttributes(
                        gid,
                        dwAttributes,
                        lpGroupInfo,
                        lpdwGroupInfo );
    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheGroupAttributeA(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOA    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    DWORD Error;

    // validate parameters.
    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOA) ) ) 
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->SetGroupAttributes(
            gid, dwAttributes, lpGroupInfo);

    LEAVE_CACHE_API();
}
#endif // __URLCACHE_JUNK__

// This function will be removed from the export table 
BOOLAPI
IsUrlCacheEntryExpiredA(
    IN      LPCSTR       lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    return FALSE;
}

/*
    BOOL                        bRet = TRUE;
    CACHE_ENTRY_INFOEX*         pCEI = NULL;    
    DWORD                       cbCEI;
    DWORD                       dwError;
    BOOL                        bLazy = FALSE;
    BOOL                        fLocked = FALSE;

    // Validate parameters.
    if( IsBadUrl( lpszUrlName ) || !pftLastModifiedTime ) {
        INET_ASSERT(FALSE); 
        return ERROR_INVALID_PARAMETER;
    }

    // set out LastModTime to 0
    pftLastModifiedTime->dwLowDateTime = 0 ;
    pftLastModifiedTime->dwHighDateTime = 0 ;


    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    //
    // BUGBUG
    // ideally, we should use GlobalUrlContainers->GetUrlInfo()
    // with NO_ALLOCATION and HEADONLY flag for perf.
    // however, there is a flag (lookup flag v.s entry flag) collision 
    // in that code path which prevents this working
    // so we use this anti-perf RetrieveUrl for now until that one
    // gets fixed 
    //                                           --DanpoZ, 98.09.09
    
    // Find the container and search the index.
    dwError = GlobalUrlContainers->RetrieveUrl(
                    lpszUrlName, 
                    (CACHE_ENTRY_INFO**) &pCEI, 
                    &cbCEI, 
                    (dwFlags & INTERNET_FLAG_FWD_BACK)?
                        LOOKUP_URL_TRANSLATE : LOOKUP_URL_NOCREATE,
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    
    // not found in cache
    if( dwError != ERROR_SUCCESS )
        goto Cleanup;    

    fLocked = TRUE;

    // found in cache, get the last modified time
    *pftLastModifiedTime = pCEI->LastModifiedTime;

    bRet = IsExpired(pCEI, dwFlags, &bLazy);
    if( bRet && bLazy )
    {
        //
        // the entry is not expired, however, we need to post-fetch
        // so we have to return EXPIRED back to trident to force them
        // issue a binding, on the new binding, urlmon-wininet returns
        // the cache content and queue a background update
        // (an alternative would be to ask trident to catch this case
        //  and call background update themself)
        // 
        bRet = FALSE;
    }

Cleanup:
    if( pCEI )
        FREE_MEMORY(pCEI);

    if (fLocked)
        GlobalUrlContainers->UnlockUrl(lpszUrlName);

    return bRet;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachapiw.cxx

Abstract:

    contains the UNICODE version of cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)   Dec-1997
--*/

#include <wininetp.h>
#include <cache.hxx>
#include <w95wraps.h>

#define NUMBER_MEMBERS 4


const BYTE bOffsetTable[NUMBER_MEMBERS] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszSourceUrlName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszLocalFileName),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpHeaderInfo),
        (BYTE)&(((LPINTERNET_CACHE_ENTRY_INFOW)NULL)->lpszFileExtension)
    };
    
DWORD
TransformA2W(
    IN LPINTERNET_CACHE_ENTRY_INFOA pCEIA,
    IN DWORD cbCEIA,
    OUT LPINTERNET_CACHE_ENTRY_INFOW pCEIW,
    OUT LPDWORD pcbCEIW
    )
{
    DWORD cbSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
    DWORD cc;

    if (!pCEIW || (*pcbCEIW<sizeof(INTERNET_CACHE_ENTRY_INFOW)))
    {
        *pcbCEIW = 0;
        cc = 0;
    }
    else
    {
        //
        // copy fixed portion.
        //
        memcpy((PBYTE)pCEIW, (PBYTE)pCEIA, sizeof(INTERNET_CACHE_ENTRY_INFOW) );
        pCEIW->dwStructSize = sizeof(INTERNET_CACHE_ENTRY_INFOW);
        cc = (*pcbCEIW - sizeof(INTERNET_CACHE_ENTRY_INFOW))/sizeof(WCHAR);
    }

    // Destination for strings
    PWSTR pBuffer = (pCEIW ? (PWSTR)(pCEIW + 1) : NULL);
    // Convert strings
    for (int i=0; i < NUMBER_MEMBERS; i++)
    {
        PSTR *pBufferA = (PSTR*)((PBYTE)pCEIA + bOffsetTable[i]);

        if (*pBufferA)
        {
            DWORD dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, NULL, 0);
            if ((dwTmp<=cc) && pCEIW)
            {
                INET_ASSERT(pBuffer);

                PWSTR *pBufferW = (PWSTR*)((PBYTE)pCEIW + bOffsetTable[i]);
                *pBufferW = pBuffer;
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1, *pBufferW, dwTmp);
                pBuffer += dwTmp;
                cc -= dwTmp;
            }
            cbSize += dwTmp*sizeof(WCHAR);
        }
    }

    DWORD dwErr = (*pcbCEIW>=cbSize) ? ERROR_SUCCESS : ERROR_INSUFFICIENT_BUFFER;
    *pcbCEIW = cbSize; // Tell how much space used/needed.
    return dwErr;
}


URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN DWORD dwExpectedFileSize,
    IN LPCWSTR lpszFileExtension,
    OUT LPWSTR lpszFileName,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheEntryW", "%wq, %wq, %d, %wq, %#x",
        lpszUrlName, lpszFileExtension, dwExpectedFileSize, lpszFileName, dwReserved));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName, mpFileExtension, mpFileName;

    if (lpszUrlName)
    {
        ALLOC_MB(lpszUrlName,0,mpUrlName);
        if (!mpUrlName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    ALLOC_MB(NULL, MAX_PATH, mpFileName);
    if (!mpFileName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    fResult = CreateUrlCacheEntryA(
        mpUrlName.psStr,
        dwExpectedFileSize,
        mpFileExtension.psStr,
        mpFileName.psStr,
        dwReserved);
    if (fResult)
    {
        MultiByteToWideChar(CP_ACP, 0, mpFileName.psStr, -1, lpszFileName, MAX_PATH);
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
CommitUrlCacheEntryW(
    IN LPCWSTR lpszUrlName,
    IN LPCWSTR lpszLocalFileName,
    IN FILETIME ExpireTime,
    IN FILETIME LastModifiedTime,
    IN DWORD CacheEntryType,
    IN LPWSTR lpszHeaderInfo,
    IN DWORD dwHeaders,
    IN LPCWSTR lpszFileExtension,
    IN LPCWSTR lpszOriginalUrl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CommitUrlCacheEntryW",
        "%wq, %wq, <expires>, <last-mod>, %d, %wq, %d, %wq, %wq",
        lpszUrlName,
        lpszLocalFileName,
        CacheEntryType,
        lpszHeaderInfo,
        dwHeaders,
        lpszFileExtension,
        lpszOriginalUrl
    ));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName, mpLocalFileName, mpFileExtension, mpHeaders, mpOriginalUrl;

    if( IsBadUrlW( lpszUrlName ) ||
        ( lpszLocalFileName ? IsBadStringPtrW( lpszLocalFileName, MAX_PATH ) : FALSE ) ) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpszLocalFileName)
    {
        ALLOC_MB(lpszLocalFileName,0,mpLocalFileName);
        if (!mpLocalFileName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszLocalFileName,mpLocalFileName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    
    if (lpszFileExtension)
    {
        ALLOC_MB(lpszFileExtension,0,mpFileExtension);
        if (!mpFileExtension.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszFileExtension,mpFileExtension, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (lpszHeaderInfo)
    {
        ALLOC_MB(lpszHeaderInfo,0,mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszHeaderInfo,mpHeaders, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }

    }
    if (lpszOriginalUrl)
    {
        ALLOC_MB(lpszOriginalUrl,0,mpOriginalUrl);
        if (!mpOriginalUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszOriginalUrl,mpOriginalUrl, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    fResult = CommitUrlCacheEntryA(
            mpUrlName.psStr,
            mpLocalFileName.psStr,
            ExpireTime,
            LastModifiedTime,
            CacheEntryType,
            (LPBYTE)mpHeaders.psStr,
            mpHeaders.dwSize,
            mpFileExtension.psStr,
            mpOriginalUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL
RetrieveUrlCacheEntryWCore(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved,
    IN DWORD dwLookupFlags,
    IN DWORD dwRetrievalFlags)
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD dwCEI = 0;
    
    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!(lpszUrlName && lpcbCacheEntryInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrlName, 0, mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName, mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    dwErr = GlobalUrlContainers->RetrieveUrl(
                        mpUrlName.psStr,
                        &pCEIA,
                        &dwCEI,
                        dwLookupFlags,
                        dwRetrievalFlags | RETRIEVE_WITH_ALLOCATION);

    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(
            pCEIA,
            dwCEI,
            lpCacheEntryInfo,
            lpcbCacheEntryInfo);

        if (dwErr!=ERROR_SUCCESS)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
    }

cleanup:
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr == ERROR_SUCCESS);
}


URLCACHEAPI
BOOL
WINAPI
RetrieveUrlCacheEntryFileW(
    IN LPCWSTR  lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "RetrieveUrlCacheEntryFileW","%wq, %#x, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo, dwReserved));

    BOOL fResult = RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_CREATE,
                        RETRIEVE_WITH_CHECKS);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
HANDLE
WINAPI
RetrieveUrlCacheEntryStreamW(
    IN LPCWSTR  lpszUrlName,
    OUT LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo,
    IN BOOL fRandomRead,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Handle, "RetrieveUrlCacheEntryStreamW",
        "%wq, %#x, %#x, %d, %#x",
        lpszUrlName,
        lpCacheEntryInfo,
        lpcbCacheEntryInfo,
        fRandomRead,
        dwReserved
    ));

    BOOL fLocked = FALSE;
    HANDLE hInternet = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr = ERROR_SUCCESS, dwFileSize;
    CACHE_STREAM_CONTEXT_HANDLE* pStream;

    if (!RetrieveUrlCacheEntryWCore(
                        lpszUrlName,
                        lpCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        dwReserved,
                        LOOKUP_URL_NOCREATE,
                        RETRIEVE_WITHOUT_CHECKS))
    {
        goto cleanup;
    }

    fLocked = TRUE;        

    // Allocate a stream handle.
    LOCK_CACHE();
    hInternet = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
    if (hInternet)
    {        
        pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hInternet);
        INET_ASSERT (pStream);
    }
    UNLOCK_CACHE();
    if (!hInternet)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }

    // Open the file.
    // Does CreateFileW exist on Win9x?

    hFile = CreateFileW
    (
        lpCacheEntryInfo->lpszLocalFileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL |
          (fRandomRead ? FILE_FLAG_RANDOM_ACCESS : FILE_FLAG_SEQUENTIAL_SCAN),
                // improves file read (cache) performance?
        NULL
    );
    if( hFile == INVALID_HANDLE_VALUE )
    {
        dwErr = GetLastError();
        goto cleanup;
    }

    dwFileSize = GetFileSize(hFile, NULL);
    if (dwFileSize != lpCacheEntryInfo->dwSizeLow) 
    {
        dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
        goto cleanup;
    }

    pStream->FileHandle = hFile;

    // Copy URL name storage.
    {
        MEMORYPACKET mpUrl;
        ALLOC_MB(lpszUrlName,0,mpUrl);
        if (!mpUrl.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszUrlName,mpUrl);
        
        pStream->SourceUrlName = NewString(mpUrl.psStr);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        if (hInternet)
        {
            HandleMgr.Free(hInternet);
            hInternet = NULL;
        }
        if (hFile)
            CloseHandle (hFile);

        if (fLocked)
        {
            UnlockUrlCacheEntryFileW(lpszUrlName, 0);
        }
        SetLastError (dwErr);
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOL
GetUrlCacheEntryWCore(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        DWORD dwFlags,
        DWORD dwLookupFlags,
        BOOL fConvertHeaders)
{
    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpUrlName;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;

    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }

    if (IsBadUrlW(lpszUrl))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    ALLOC_MB(lpszUrl,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrl,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (lpcbCacheEntryInfo)
    {
        dwErr = GlobalUrlContainers->GetUrlInfo(
            mpUrlName.psStr,
            &pCEIA,
            &cbCEIA,
            dwFlags,
            dwLookupFlags,
            RETRIEVE_WITH_ALLOCATION);
            
        // convert from ansi to unicode. 
        if (dwErr==ERROR_SUCCESS)
        {
            dwErr = TransformA2W(pCEIA, cbCEIA, lpCacheEntryInfo, lpcbCacheEntryInfo);
            if (dwErr==ERROR_SUCCESS)
            {
                fResult = TRUE;
            }
        }
    }
    else
    {
        fResult = GetUrlCacheEntryInfoExA(
                mpUrlName.psStr, 
                NULL,
                NULL,
                NULL,
                NULL,
                NULL,
                dwFlags);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
GetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoW", "%wq, %#x, %#x",
        lpszUrlName, lpCacheEntryInfo, lpcbCacheEntryInfo));

    BOOL fResult = GetUrlCacheEntryWCore(
                            lpszUrlName,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            0,
                            LOOKUP_URL_NOCREATE,
                            TRUE);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI
GetUrlCacheEntryInfoExW(
        IN LPCWSTR lpszUrl,
        OUT LPINTERNET_CACHE_ENTRY_INFOW lpCacheEntryInfo,
        IN OUT LPDWORD lpcbCacheEntryInfo,
        OUT LPWSTR lpszRedirectUrl,
        IN OUT LPDWORD lpcbRedirectUrl,
        LPVOID lpReserved,
        DWORD dwFlags
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheEntryInfoExW",
        "%wq, %#x, %#x, %wq, %#x, %#x, %#x", 
        lpszUrl, lpCacheEntryInfo, lpcbCacheEntryInfo, lpszRedirectUrl, lpcbRedirectUrl, lpReserved, dwFlags));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    
    if (lpszRedirectUrl
        || lpcbRedirectUrl 
        || lpReserved
       )
    {
        INET_ASSERT (FALSE);
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    fResult = GetUrlCacheEntryWCore(
                            lpszUrl,
                            lpCacheEntryInfo,
                            lpcbCacheEntryInfo,
                            dwFlags,
                            LOOKUP_URL_TRANSLATE | (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS),
                            TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheEntryInfoW(
    IN LPCWSTR lpszUrlName,
    IN LPCACHE_ENTRY_INFOW lpCacheEntryInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryInfoW", "%wq, %#x, %d",
        lpszUrlName, lpCacheEntryInfo, dwFieldControl));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrlName;
    INTERNET_CACHE_ENTRY_INFOA CacheEntryInfoA;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    memcpy( &CacheEntryInfoA, lpCacheEntryInfo, sizeof(CacheEntryInfoA) );

    ALLOC_MB(lpszUrlName,0,mpUrlName);
    if (!mpUrlName.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrlName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryInfoA(
            mpUrlName.psStr,
            &CacheEntryInfoA,
            dwFieldControl );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


BOOL FindUrlCacheEntryWCore(
    IN OUT HANDLE     *phFind,
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    IN     BOOL      fConvertHeaders
    )
{
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;
    MEMORYPACKET mpSearchPattern;
    LPINTERNET_CACHE_ENTRY_INFOA pCEIA = NULL;
    DWORD cbCEIA;
    BOOL fFindFirst = *phFind==NULL;
    
    // DebugBreak();
    
    if (!InitGlobals())
    {
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        goto cleanup;
    }
    if (!pcbEntryInfo)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (lpszUrlSearchPattern)
    {
        ALLOC_MB(lpszUrlSearchPattern, 0, mpSearchPattern);
        if (!mpSearchPattern.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszUrlSearchPattern, mpSearchPattern, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = GlobalUrlContainers->FindNextEntry(phFind, 
                                               mpSearchPattern.psStr, 
                                               &pCEIA, 
                                               &cbCEIA,
                                               dwFilter,
                                               GroupId,
                                               dwFlags,
                                               RETRIEVE_WITH_ALLOCATION);

    // TransformA2W will convert from ansi to unicode. ERROR_SUCCESS always means that
    // the cache entry has been returned.
    if (dwErr==ERROR_SUCCESS)
    {
        dwErr = TransformA2W(pCEIA,
            cbCEIA,
            pEntryInfo,
            pcbEntryInfo);
    }

cleanup: 
    if (pCEIA)
    {
        FREE_MEMORY(pCEIA);
    }
    if (dwErr!=ERROR_SUCCESS) 
    { 
        if (fFindFirst && *phFind)
        {
            GlobalUrlContainers->FreeFindHandle(*phFind);
            *phFind = NULL;
        }
        
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    return (dwErr==ERROR_SUCCESS) ;
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryW(
    IN LPCWSTR lpszUrlSearchPattern,
    OUT LPCACHE_ENTRY_INFOW lpFirstCacheEntryInfo,
    IN OUT LPDWORD lpcbCacheEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryW",
        "%wq, %#x, %#x",
        lpszUrlSearchPattern,
        lpFirstCacheEntryInfo,
        lpcbCacheEntryInfo
    ));

    HANDLE hInternet = FindFirstUrlCacheEntryExW(
                        lpszUrlSearchPattern,
                        FIND_FLAGS_OLD_SEMANTICS,
                        URLCACHE_FIND_DEFAULT_FILTER,
                        NULL,
                        lpFirstCacheEntryInfo,
                        lpcbCacheEntryInfo,
                        NULL,
                        NULL,
                        NULL);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheEntryW(
    IN HANDLE hEnumHandle,
    OUT LPCACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD pcbEntryInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryW",
       "%#x, %#x, %#x",
        hEnumHandle, 
        pEntryInfo,
        pcbEntryInfo
    ));

    BOOL fResult = FindNextUrlCacheEntryExW(
                    hEnumHandle,
                    pEntryInfo,
                    pcbEntryInfo,
                    NULL, 
                    NULL,
                    NULL);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
HANDLE
WINAPI
FindFirstUrlCacheEntryExW(
    IN     LPCWSTR    lpszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstUrlCacheEntryExW",
        "%wq, %#x, %#x, %#x, %#x, %#x, %#x, %#x, %#x",
        lpszUrlSearchPattern,
        dwFlags,
        dwFilter,
        GroupId,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    HANDLE hInternet = NULL;

    FindUrlCacheEntryWCore(
            &hInternet,
            lpszUrlSearchPattern,
            dwFlags,
            dwFilter,
            GroupId,
            pEntryInfo,
            pcbEntryInfo,
            TRUE);

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


BOOLAPI
FindNextUrlCacheEntryExW(
    IN     HANDLE    hEnumHandle,
    OUT    LPINTERNET_CACHE_ENTRY_INFOW pEntryInfo,
    IN OUT LPDWORD   pcbEntryInfo,
    OUT    LPVOID    lpGroupAttributes,     // must pass NULL
    IN OUT LPDWORD   pcbGroupAttributes,    // must pass NULL
    IN     LPVOID    lpReserved             // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheEntryExW",
        "%#x, %#x, %#x, %#x, %#x, %#x",
        hEnumHandle,
        pEntryInfo,
        pcbEntryInfo,
        lpGroupAttributes,
        pcbGroupAttributes,
        lpReserved
    ));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    
    if (!hEnumHandle)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = FindUrlCacheEntryWCore(
                        &hEnumHandle,
                        NULL,
                        0,
                        0,
                        0,
                        pEntryInfo,
                        pcbEntryInfo,
                        TRUE);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
FreeUrlCacheSpaceW(
    IN LPCWSTR lpszCachePath,
    IN DWORD dwSize,
    IN DWORD dwReserved
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FreeUrlCacheSpaceW", 
        "<path>,%d, %#x", dwSize, dwReserved));

    BOOL fResult = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fStrNotSafe = FALSE;

    MEMORYPACKET mpCachePath;
    if (lpszCachePath)
    {
        ALLOC_MB(lpszCachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(lpszCachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    fResult = FreeUrlCacheSpaceA(
            mpCachePath.psStr,
            dwSize,
            dwReserved );

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryFileW(
    LPCWSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    lpszUrlName : name of the URL that is being retrieved.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryFileW",
        "%wq, %#x", lpszUrlName, dwReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = UnlockUrlCacheEntryFileA(mpUrl.psStr, dwReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheEntryW(
    IN LPCWSTR lpszUrlName
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheEntryW",
        "%wq", lpszUrlName));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = DeleteUrlCacheEntryA(mpUrl.psStr);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI
IsUrlCacheEntryExpiredW(
    IN      LPCWSTR      lpszUrlName,
    IN      DWORD        dwFlags,
    IN OUT  FILETIME*    pftLastModifiedTime
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UrlCacheEntryExpiredW", 
        "%wq, %#x", lpszUrlName, dwFlags));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = IsUrlCacheEntryExpiredA(
                    mpUrl.psStr,
                    dwFlags,
                    pftLastModifiedTime);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL CacheGroupInfoA2W(
    IN          LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN          DWORD                           dwAnsiGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN OUT      LPDWORD                         lpdwUnicodeGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);

    lpUnicodeGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOW);
    lpUnicodeGroupInfo->dwGroupFlags = lpAnsiGroupInfo->dwGroupFlags;
    lpUnicodeGroupInfo->dwGroupType = lpAnsiGroupInfo->dwGroupType;
    lpUnicodeGroupInfo->dwDiskUsage = lpAnsiGroupInfo->dwDiskUsage;
    lpUnicodeGroupInfo->dwDiskQuota = lpAnsiGroupInfo->dwDiskQuota;

    memcpy(lpUnicodeGroupInfo->dwOwnerStorage,
           lpAnsiGroupInfo->dwOwnerStorage,
           GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );


    BOOL fRet = MultiByteToWideChar(
               CP_ACP,
               MB_PRECOMPOSED,
               lpAnsiGroupInfo->szGroupName,
               -1,         // null terminated ansi string.
               lpUnicodeGroupInfo->szGroupName,
               GROUPNAME_MAX_LENGTH
    );

    if( fRet )
    {
        *lpdwUnicodeGroupInfoSize = lpUnicodeGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwUnicodeGroupInfoSize = 0;
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return fRet;
}

BOOL CacheGroupInfoW2A(
    IN          LPINTERNET_CACHE_GROUP_INFOW    lpUnicodeGroupInfo,
    IN          DWORD                           dwUnicodeGroupInfoSize,
    OUT         LPINTERNET_CACHE_GROUP_INFOA    lpAnsiGroupInfo,
    IN OUT      LPDWORD                         lpdwAnsiGroupInfoSize
)
{
    INET_ASSERT( lpUnicodeGroupInfo && lpAnsiGroupInfo);
    BOOL fStrNotSafe = FALSE;

    lpAnsiGroupInfo->dwGroupSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    lpAnsiGroupInfo->dwGroupFlags = lpUnicodeGroupInfo->dwGroupFlags;
    lpAnsiGroupInfo->dwGroupType = lpUnicodeGroupInfo->dwGroupType;
    lpAnsiGroupInfo->dwDiskUsage = lpUnicodeGroupInfo->dwDiskUsage;
    lpAnsiGroupInfo->dwDiskQuota = lpUnicodeGroupInfo->dwDiskQuota;

    memcpy( lpAnsiGroupInfo->dwOwnerStorage,
            lpUnicodeGroupInfo->dwOwnerStorage,
            GROUP_OWNER_STORAGE_SIZE * sizeof(DWORD) );

    BOOL fRet = WideCharToMultiByte(
                CP_ACP,
                0,              // no flags.
                lpUnicodeGroupInfo->szGroupName,
                -1,             // null terminated unicode string.
                lpAnsiGroupInfo->szGroupName,
                GROUPNAME_MAX_LENGTH,
                NULL,           // lpDefaultChar
                &fStrNotSafe    // lpUseDefaultChar
    );
    if (fStrNotSafe)
    {
        fRet = FALSE;
    }

    if( fRet )
    {
        *lpdwAnsiGroupInfoSize = lpAnsiGroupInfo->dwGroupSize;
    }
    else
    {
        *lpdwAnsiGroupInfoSize = 0;
    }
    return fRet;
}


URLCACHEAPI
BOOLAPI
SetUrlCacheEntryGroupW(
    IN LPCWSTR   lpszUrlName,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId,
    IN LPBYTE   pbGroupAttributes, // must pass NULL
    IN DWORD    cbGroupAttributes, // must pass 0
    IN LPVOID   lpReserved         // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheEntryGroupW", 
        "%wq, %#x, %#x, %#x, %#x, %#x", lpszUrlName, dwFlags, GroupId, pbGroupAttributes, cbGroupAttributes, lpReserved));

    BOOL fResult = FALSE;
    BOOL fStrNotSafe = FALSE;
    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpUrl;

    if (!lpszUrlName)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    ALLOC_MB(lpszUrlName,0,mpUrl);
    if (!mpUrl.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(lpszUrlName,mpUrl, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    fResult = SetUrlCacheEntryGroupA(
                    mpUrl.psStr,
                    dwFlags,
                    GroupId,
                    pbGroupAttributes,
                    cbGroupAttributes,
                    lpReserved);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    OUT     LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPDWORD                         lpdwGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheGroupAttributeW",
        "%d, %d, %d, %#x, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpdwGroupInfo, lpReserved ));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( !lpGroupInfo || !lpdwGroupInfo )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( *lpdwGroupInfo < sizeof(INTERNET_CACHE_GROUP_INFOW) )
    {
        Error = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    if( IsBadWriteUrlInfo(lpGroupInfo, *lpdwGroupInfo) )
    {
        Error = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( GetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes,
            &AnsiGroupInfo, &dwAnsiGroupInfoSize, lpReserved ) )
    {
        fResult = CacheGroupInfoA2W( &AnsiGroupInfo, 
                                    dwAnsiGroupInfoSize,
                                    lpGroupInfo, 
                                    lpdwGroupInfo );
    }


Cleanup:
    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheGroupAttributeW(
    IN      GROUPID                         gid,
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwAttributes,
    IN      LPINTERNET_CACHE_GROUP_INFOW    lpGroupInfo,
    IN OUT  LPVOID                          lpReserved
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "SetUrlCacheGroupAttributeA",
        "%#x, %d, %d, %#x, %#x", 
        gid, dwFlags, dwAttributes, lpGroupInfo, lpReserved));

    BOOL fResult = FALSE;
    DWORD Error = ERROR_SUCCESS;
    INTERNET_CACHE_GROUP_INFOA AnsiGroupInfo;
    DWORD  dwAnsiGroupInfoSize = sizeof(INTERNET_CACHE_GROUP_INFOA);

    if( IsBadReadPtr(lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW) ) )
    {
        Error = ERROR_INVALID_PARAMETER;
    }
    else if( CacheGroupInfoW2A(
            lpGroupInfo, sizeof(INTERNET_CACHE_GROUP_INFOW),
            &AnsiGroupInfo, &dwAnsiGroupInfoSize ) )
    {
        fResult = SetUrlCacheGroupAttributeA(
            gid, dwFlags, dwAttributes, &AnsiGroupInfo, lpReserved );
    }

    if (Error!=ERROR_SUCCESS)
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// Convert all the ansi strings in a structure to unicode

/* How does this work?
    Take this structure for example:

    struct foo 
    {
        DWORD dwA;
        LPTSTR pszB;
        DWORD dwC;
        LPTSTR pszD;
    };
    where LPTSTR are embedded pointers
    
    The memory layout is thus:

    [DWORD][LPTSTR][DWORD][LPTSTR][embedded string pszB][embedded string pszD]
    ^                             ^
    |                             |
    |-struct beginning            |-beginning of embedded strings

    Assuming a 32-bit platform, we can construct pointers (relative to the struct beginning) to each element
    in the structure. In this case,

    { 0, sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Let's say we're interested in strings only, and we know that these strings are embedded. We can create a byte table thus:
    BYTE bFoo[] = { sizeof(DWORD), sizeof(DWORD)+sizeof(LPTSTR)+sizeof(DWORD) }

    Alternatively:
    BYTE bFoo[] = 
    {
        (BYTE)&(((foo*)NULL)->pszB),
        (BYTE)&(((foo*)NULL)->pszD)
    };

    This layout is the same for both Ansi and Unicode versions of a struct, UNLESS the struct contains for example 
    a TCHAR szWhat[256] (in which case, we can't use the bulk converter).

    Pass BulkConverter the following parameters, to convert strings in one swoop.

    pbSrc       = casted pointer to the beginning of the ansi structure
    pbDest      = casted pointer to the beginning of the unicode structure
    cbAvail     = number of bytes available for embedded strings
    wSkip       = offset from the beginning of the structure, at which point embedded strings may be written
    cElements   = number of elements to convert from ansi to unicode

    If BulkConverter succeeds, it'll return the number of bytes used.
    If it fails, it will return the number of bytes needed to store all the unicode strings.

BUT HOW DOES THIS THING WORK?
Oh. 

1. Using the offset table, we figure out where the pointer to the string is in both the structures.
2. Then using magic, we decided where to place the unicode string. 
3. Figure how much space we'll need to store the unicode string
4. If that much is available, convert.
5. Keep track, either way.
6. Go to 1, if we have any other strings left.
*/

LONG BulkConverter(PBYTE pbSrc, PBYTE pbDest, LONG cbAvail, WORD wSkip, CONST BYTE abTable[], WORD cElements)
{
    PWSTR pBuffer = (PWSTR)(pbDest + wSkip);
    PSTR *pBufferA;
    PWSTR *pBufferW;

    for (DWORD i=0; i < cElements; i++)
    {
        pBufferA = (PSTR*)((PBYTE)pbSrc + abTable[i]);
        pBufferW = (PWSTR*)((PBYTE)pbDest + abTable[i]);

        if (*pBufferA)
        {
            *pBufferW = pBuffer;
            LONG dwTmp = MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, 0);
            if (dwTmp<cbAvail)
            {
                MultiByteToWideChar(CP_ACP, 0,  *pBufferA, -1,
                                             *pBufferW, cbAvail);
                pBuffer += dwTmp;
            }
            cbAvail -= dwTmp;
        }
    }
    return cbAvail;
}


const BYTE bOffsetTableContainer[] = 
    {
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszName),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszCachePrefix),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeLabel),
        (BYTE)&(((LPINTERNET_CACHE_CONTAINER_INFOW)NULL)->lpszVolumeTitle)
    };

BOOL
TransformCacheContainerInfoToW(
    IN BOOL fResult,
    IN LPINTERNET_CACHE_CONTAINER_INFOA pCCIA,
    IN DWORD cbCCIA,
    OUT LPINTERNET_CACHE_CONTAINER_INFOW pCCIW,
    OUT LPDWORD pcbCCIW
)
{
    DWORD cbSize = *pcbCCIW;

    if (fResult)
    {
        // If we have pointers, try to convert from 

        LONG cc = *pcbCCIW - sizeof(INTERNET_CACHE_CONTAINER_INFOW);
        if (*pcbCCIW > sizeof(INTERNET_CACHE_CONTAINER_INFOW))
        {
            pCCIW->dwCacheVersion = pCCIA->dwCacheVersion;
        }
        cc /= sizeof(WCHAR);
        // Convert strings
        cc = BulkConverter((PBYTE)pCCIA, 
                (PBYTE)pCCIW, 
                cc, 
                sizeof(INTERNET_CACHE_CONTAINER_INFOW), 
                bOffsetTableContainer, 
                ARRAY_ELEMENTS(bOffsetTableContainer));


       // Tell how much space was actually used.
        *pcbCCIW -= cc*sizeof(WCHAR);

        if (*pcbCCIW>cbSize)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            fResult = FALSE;
        }
    }
    else if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
    {
        *pcbCCIW = (cbCCIA - sizeof(INTERNET_CACHE_CONTAINER_INFOA))*sizeof(WCHAR) + sizeof(INTERNET_CACHE_CONTAINER_INFOW);
    }

    return fResult;
}

#define USE_ORIGINAL_CODE

URLCACHEAPI
BOOL
WINAPI
CreateUrlCacheContainerW(
                 IN LPCWSTR Name,
                 IN LPCWSTR CachePrefix,
                 IN LPCWSTR CachePath,
                 IN DWORD KBCacheLimit,
                 IN DWORD dwContainerType,
                     IN DWORD dwOptions,
                     IN OUT LPVOID pvBuffer,
                     IN OUT LPDWORD cbBuffer)
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheContainerW", "%wq, %wq, %wq, %d, %d, %d, %#x, %#x",
        Name, CachePrefix, CachePath, KBCacheLimit, dwContainerType, dwOptions, pvBuffer, cbBuffer));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    MEMORYPACKET mpName, mpCachePrefix, mpCachePath;
    BOOL fStrNotSafe = FALSE;

#ifdef USE_ORIGINAL_CODE
    if (Name)
    {
        ALLOC_MB(Name, 0, mpName);
        if (!mpName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePrefix)
    {
        ALLOC_MB(CachePrefix, 0, mpCachePrefix);
        if (!mpCachePrefix.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePrefix, mpCachePrefix, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
    if (CachePath)
    {
        ALLOC_MB(CachePath,0,mpCachePath);
        if (!mpCachePath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(CachePath,mpCachePath, &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }
#else
// Theoretically, the following fragment should be smaller than the above fragment. 
// Although the retail obj shows a function that's about 100 bytes shorter, the
// actual dll doesn't show this gain. Until I figure this out, we won't use it.

    DWORD c;
    do
    {
        MEMORYPACKET* mp;
        PCWSTR psz;

        switch (c)
        {
        case 0:
            psz = Name;
            mp = &mpName;
            break;
            
        case 1:
            psz = CachePrefix;
            mp = &mpCachePrefix;
            break;

        case 2:
            psz = CachePath;
            mp = &mpCachePath;
            break;
        }
        ALLOC_MB(psz, 0, (*mp));
        if (!mp->psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI_CHECKED(psz, (*mp), &fStrNotSafe);
        if (fStrNotSafe)
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        c++;
    }
    while (c<3);

#endif

    fResult = CreateUrlCacheContainerA(
                mpName.psStr,
                mpCachePrefix.psStr,
                mpCachePath.psStr,
                KBCacheLimit,
                dwContainerType,
                dwOptions,
                pvBuffer,
                cbBuffer);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

URLCACHEAPI
BOOL
WINAPI
DeleteUrlCacheContainerW(
IN LPCWSTR Name,
IN DWORD dwOptions)
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteContainerW", "%wq, %#x", Name, dwOptions));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpName;
    BOOL fResult = FALSE, fStrNotSafe = FALSE;

    ALLOC_MB(Name, 0, mpName);
    if (!mpName.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    UNICODE_TO_ANSI_CHECKED(Name, mpName, &fStrNotSafe);
    if (fStrNotSafe)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    fResult = DeleteUrlCacheContainerA(mpName.psStr, dwOptions);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheContainerW(
    IN OUT DWORD *pdwModified,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo,
    IN DWORD dwOptions
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindFirstContainerW",
        "%#x, %#x, %#x, %#x",
        pdwModified,
        lpContainerInfo,
        lpcbContainerInfo,
        dwOptions
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    HANDLE hInternet = NULL;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    hInternet = FindFirstUrlCacheContainerA(pdwModified,
        (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, &mpCacheInfo.dwSize, dwOptions);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    if (!TransformCacheContainerInfoToW(
            hInternet ? TRUE : FALSE,
            (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
            mpCacheInfo.dwSize,
            lpContainerInfo,
            lpcbContainerInfo))
    {
        if (hInternet)
        {
            FindCloseUrlCache(hInternet);
            hInternet = NULL;
        }
    }

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheContainerW(
    IN HANDLE hEnumHandle,
        OUT LPINTERNET_CACHE_CONTAINER_INFOW lpContainerInfo,
        IN OUT LPDWORD lpcbContainerInfo
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindNextContainerW",
        "%#x, %#x, %#x",
        hEnumHandle, 
        lpContainerInfo,
        lpcbContainerInfo
    ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpCacheInfo;
    BOOL fResult = FALSE;

    if (!(lpcbContainerInfo && lpContainerInfo))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    mpCacheInfo.psStr = (PSTR)ALLOC_BYTES(*lpcbContainerInfo);
    if (!mpCacheInfo.psStr)
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto cleanup;
    }
    mpCacheInfo.dwSize = mpCacheInfo.dwAlloc = *lpcbContainerInfo;

    fResult = FindNextUrlCacheContainerA(
                    hEnumHandle,
                    (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr, 
                    &mpCacheInfo.dwSize);

    // TransformCacheContainerInfoToW takes the return value and decides if any further actions need to be taken
    // (eg. if successful, then try to convert from ansi to unicode; else if the ansi api failed, should we care?)
    
    fResult = TransformCacheContainerInfoToW(
                fResult,
                (LPINTERNET_CACHE_CONTAINER_INFOA)mpCacheInfo.psStr,
                mpCacheInfo.dwSize,
                lpContainerInfo,
                lpcbContainerInfo);

cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

/* here's the struct referred to below 

typedef struct _INTERNET_CACHE_CONFIG_INFOA {
    DWORD dwStructSize;
    DWORD dwContainer;
    DWORD dwQuota;
    DWORD dwReserved4;
    BOOL  fPerUser;
    DWORD dwSyncMode;
    DWORD dwNumCachePaths;
    union 
    { 
        struct 
        {
            CHAR   CachePath[MAX_PATH];
            DWORD dwCacheSize;
        };
        INTERNET_CACHE_CONFIG_PATH_ENTRYA CachePaths[ANYSIZE_ARRAY];
    };
    DWORD dwNormalUsage;
    DWORD dwExemptUsage;
} INTERNET_CACHE_CONFIG_INFOA, * LPINTERNET_CACHE_CONFIG_INFOA;

*/

#define ICCIA_FIXED_PORTION_SIZE ((sizeof(DWORD)*6)+sizeof(BOOL))

/*
URLCACHEAPI
BOOL
WINAPI
GetUrlCacheConfigInfoW(
    OUT LPINTERNET_CACHE_CONFIG_INFOW pCacheConfigInfo,
    IN OUT LPDWORD pcbCacheConfigInfo,
    IN DWORD dwFieldControl
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoW", "%#x, %#x, %#x",
        pCacheConfigInfo, pcbCacheConfigInfo, dwFieldControl ));

    INTERNET_CACHE_CONFIG_INFOA iccia;
    
    iccia.dwContainer = pCacheConfigInfo->dwContainer;
    iccia.dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    DWORD dwSize = sizeof(INTERNET_CACHE_CONFIG_INFOA);
    BOOL fResult = GetUrlCacheConfigInfoA(&iccia, &dwSize, dwFieldControl);
    if (fResult)
    {
        memcpy(pCacheConfigInfo, &iccia, ICCIA_FIXED_PORTION_SIZE);

        // These are appended to the _end_ of the structure.
        pCacheConfigInfo->dwNormalUsage = iccia.dwNormalUsage;
        pCacheConfigInfo->dwExemptUsage = iccia.dwExemptUsage;
        pCacheConfigInfo->dwStructSize = sizeof(INTERNET_CACHE_CONFIG_INFOW);
        if (pCacheConfigInfo->dwContainer <= HISTORY)
        {
            MultiByteToWideChar(CP_ACP, 0, iccia.CachePath, -1, pCacheConfigInfo->CachePath, ARRAY_ELEMENTS(pCacheConfigInfo->CachePath));
        }
    }

    DEBUG_LEAVE_API (fResult);
    return fResult;
}


URLCACHEAPI
BOOL
WINAPI
SetUrlCacheConfigInfoW(
    LPCACHE_CONFIG_INFOW lpConfigConfigInfo,
    DWORD dwFieldControl
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return( FALSE );
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\unique.hpp ===
#ifndef _UNIQUE_HPP_
#define _UNIQUE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Hash.hpp"
#include "List.hpp"
#include "Pool.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The constants supplied here control how unique strings         */
    /*   are constructed.                                               */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 MinDetails				  = 16;

    /********************************************************************/
    /*                                                                  */
    /*   Class forward references.                                      */
    /*                                                                  */
    /*   We need to refer to the following classes before they are      */
    /*   fully specified so here we list them as forward references.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> class UNIQUE;

    /********************************************************************/
    /*                                                                  */
    /*   A string description.                                          */
    /*                                                                  */
    /*   All unique strings have a string drescription which is         */
    /*   into either the active or free list.                           */
    /*                                                                  */
    /********************************************************************/

class DETAIL : public LIST
	{
	private:
		//
		//   Friend classes.
		//
		friend class				  UNIQUE<NO_LOCK>;
		friend class				  UNIQUE<PARTIAL_LOCK>;
		friend class				  UNIQUE<FULL_LOCK>;

		//
		//   Private data.
		//
		BOOLEAN						  Active;
		SBIT32						  Size;
		CHAR						  *Text;
		SBIT32						  Uses;
	};

    /********************************************************************/
    /*                                                                  */
    /*   A unique string.                                               */
    /*                                                                  */
    /*   Almost all the other classes in the library offer valuable     */
    /*   free-standing functionality.  However, this class is really    */
    /*   just a support class for the variable length string class.     */
    /*                                                                  */
    /********************************************************************/

template <class LOCK=PARTIAL_LOCK> class UNIQUE : public HASH<SBIT32,POINTER>
    {
		//
		//   Private data.
		//
		LIST						  Active;
		LIST						  Free;

		DETAIL						  *Default;
		POOL<DETAIL>				  Details;
		LOCK						  Sharelock;

    public:
        //
        //   Public functions.
        //
        UNIQUE( VOID );

		DETAIL *CreateString( CHAR *String,SBIT32 Size );

		SBIT32 CompareStrings( DETAIL *Detail1,DETAIL *Detail2 );

		DETAIL *CopyString( DETAIL *Detail1,DETAIL *Detail2 );

		VOID DeleteString( DETAIL *Detail );

        ~UNIQUE( VOID );

		//
		//   Public inline functions.
		//
		INLINE DETAIL *DefaultString( VOID )
			{ return Default; }

		INLINE SBIT32 Size( DETAIL *Detail )
			{ return Detail -> Size; }

		INLINE CHAR *Value( DETAIL *Detail )
			{ return Detail -> Text; }

	private:
		//
		//   Private functions.
		//
		VIRTUAL SBIT32 ComputeHashKey
			( 
			CONST SBIT32			  & Key 
			);

		VIRTUAL BOOLEAN MatchingKeys
			( 
			CONST SBIT32			  & Key1,
			CONST SBIT32			  & Key2 
			);

        //
        //   Disabled operations.
        //
        UNIQUE( CONST UNIQUE & Copy );

        VOID operator=( CONST UNIQUE & Copy );
    };

    /********************************************************************/
    /*                                                                  */
    /*   Class constructor.                                             */
    /*                                                                  */
    /*   Create a new unique string table.  This call is not thread     */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::UNIQUE( VOID )
	{
	//
	//   Create the default string.
	//
	Default = CreateString( "",0 );
	}

    /********************************************************************/
    /*                                                                  */
    /*   Create a new unique string.                                    */
    /*                                                                  */
    /*   When we are handed a new string we need to find out whether    */
    /*   it is unique (and needs to be added to the table) or just a    */
    /*   duplicate of an existing string.                               */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CreateString
		( 
		CHAR						  *String,
		SBIT32						  Size 
		)
	{
	AUTO DETAIL *Detail1;
	AUTO DETAIL *Detail2;

	//
	//   Claim an exclusive lock (if enabled).
	//
    Sharelock.ClaimExclusiveLock();

	//
	//   Let us assume that the string is unique and
	//   build an entry to for it.  If we later find
	//   it is not then we just back out the changes.
	//
	if ( Free.EndOfList() )
		{
		REGISTER SBIT32 Count;

		//
		//   Create a several new string descriptions 
		//   and link them into the free list.
		//
		for ( Count=0;Count < MinDetails;Count ++ )
			{
			//
			//   Create a new description and add it 
			//   to the free list.
			//
			Detail1 = new DETAIL;

			Detail1 -> Active = False;

			Detail1 -> Insert( & Free );
			}
		}

	//
	//   We know that the free list must contain 
	//   least one element (if not we would have 
	//   just made some).  We extract the oldest
	//   here.
	//
	if ( (Detail1 = ((DETAIL*) Free.Last())) -> Active )
		{
		//
		//   Delete any existing value when we
		//   recycle an old and unused string
		//   description.  Remember to remove
		//   it from the hash before deleting
		//   the string as the hash uses the
		//   string.
		//
		RemoveFromHash( ((SBIT32) Detail1) );

		delete [] Detail1 -> Text;

		Detail1 -> Active = False;
		}

	//
	//   We now setup the string description for the 
	//   new string.
	//
	Detail1 -> Size = Size;
	Detail1 -> Text = String;
	Detail1 -> Uses = 1;

	//
	//   We are now ready to search the hash table for
	//   a matching string.  We do this by overloading
	//   the hash table key comparision (see later).
	//
	if ( ! FindInHash( ((SBIT32) Detail1),((POINTER*) & Detail2) ) )
		{
		//
		//   We have found a new string so we need to
		//   make the string description active and
		//   insert it in the active list.
		//
		(Detail2 = Detail1) -> Active = True;

		Detail1 -> Delete( & Free );
		Detail1 -> Insert( & Active );

		//
		//   Add the new unique string the the hash 
		//   table so we can find it later.
		//
		AddToHash( ((SBIT32) Detail1),((POINTER) Detail1) );

		//
		//   We know the string is unique so lets
		//   allocate some space for it and copy it 
		//   into the new area.
		//
		Detail1 -> Text = 
			(
			strncpy
				( 
				new CHAR [ (Size + 1) ],
				String,
				Size 
				)
			);

		Detail1 -> Text[ Size ] = '\0';
		}
	else
		{
		//
		//   Increment the use count for an existing
		//   string.
		//
		if ( Detail2 != Default )
			{ 
			//
			//   We may be lucky and find an unused
			//   string.  If so we need to add it to
			//   the active list again.
			//
			if ( (Detail2 -> Uses ++) == 0 )
				{
				//
				//   Add an unused string back to the 
				//   active list again.
				//
				Detail1 -> Delete( & Free );
				Detail1 -> Insert( & Active );
				}
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two strings.                                           */
    /*                                                                  */
    /*   Compare two strings and find the relationship between them.    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::CompareStrings
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   We know that all strings are unique so if the
	//   string pointers match then they must be the 
	//   the same string.
	//
	if ( Detail1 != Detail2 )
		{
		REGISTER SBIT32 Result =
			(
			strncmp
				( 
				Detail1 -> Text,
				Detail2 -> Text,
				(Detail1 -> Size < Detail2 -> Size)
					? Detail1 -> Size
					: Detail2 -> Size
				)
			);

		//
		//   If the strings match pick the longest.
		//
		if ( Result == 0 )
			{ Result = ((Detail1 -> Size < Detail2 -> Size) ? -1 : 1); }

		return Result;
		}
	else
		{ return 0; }
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compute a hash key.                                            */
    /*                                                                  */
    /*   Compute a hash key for the supplied key.  This hash key        */
    /*   is used to select the hash chain to search.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> SBIT32 UNIQUE<LOCK>::ComputeHashKey
		( 
		CONST SBIT32				  & Key 
		)
	{
	REGISTER SBIT32 Count;
	REGISTER DETAIL *Detail = ((DETAIL*) Key);
	REGISTER SBIT32 HashKey = 2964557531;

	for ( Count=0;Count < Detail -> Size;Count ++ )
		{
		REGISTER SBIT32 Value = ((SBIT32) Detail -> Text[ Count ]);

		HashKey = ((HashKey * Value) + Value); 
		}

	return (HashKey & 0x3fffffff);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Copy a string.                                                 */
    /*                                                                  */
    /*   All strings are unique so there is no need to copy a string.   */
    /*   Nonetheless, we still have to update the use counts.           */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> DETAIL *UNIQUE<LOCK>::CopyString
		( 
		DETAIL						  *Detail1,
		DETAIL						  *Detail2
		)
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for old string.
	//
	if ( Detail1 != Default )
		{ Detail1 -> Uses --; }

	//
	//   Increment the use count for new string.
	//
	if ( Detail2 != Default )
		{ Detail2 -> Uses ++; }

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();

	return Detail2;
	}

    /********************************************************************/
    /*                                                                  */
    /*   Compare two hash keys.                                         */
    /*                                                                  */
    /*   Compare two hash keys to see if they match.                    */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> BOOLEAN UNIQUE<LOCK>::MatchingKeys
		( 
		CONST SBIT32				  & Key1,
		CONST SBIT32				  & Key2 
		)
	{
	REGISTER DETAIL *Detail1 = ((DETAIL*) Key1);
	REGISTER DETAIL *Detail2 = ((DETAIL*) Key2);

	return
		(
		(Detail1 -> Size == Detail2 -> Size)
			&&
		(strncmp( Detail1 -> Text,Detail2 -> Text,Detail1 -> Size ) == 0)
		);
	}

    /********************************************************************/
    /*                                                                  */
    /*   Delete a string.                                               */
    /*                                                                  */
    /*   Delete a text string.                                          */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> VOID UNIQUE<LOCK>::DeleteString( DETAIL *Detail )
	{
	//
	//   Claim an exclusive lock (if enabled).
	//
	Sharelock.ClaimExclusiveLock();

	//
	//   Decrement the use count for the string.
	//
	if ( Detail != Default )
		{
		//
		//   Decrement the use count and ensure that
		//   this is not the last use of the string.
		//
		if ( (-- Detail -> Uses) == 0 )
			{
			//
			//   When we delete the last use of
			//   a string we add it to the free 
			//   list.  The string can be reclaimed
			//   if it is recreated before it is
			//   deleted.
			//
			Detail -> Delete( & Active );
			Detail -> Insert( & Free );
			}
		}

	//
	//   Release any lock we got earlier.
	//
	Sharelock.ReleaseExclusiveLock();
	}

    /********************************************************************/
    /*                                                                  */
    /*   Class destructor.                                              */
    /*                                                                  */
    /*   Destory the unique string table.  This call is not thread      */
    /*   safe and should only be made in a single thread environment.   */
    /*                                                                  */
    /********************************************************************/

template <class LOCK> UNIQUE<LOCK>::~UNIQUE( VOID )
	{ 
	//
	//   Delete all active strings.
	//
	while ( ! Active.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Active.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Active );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}

	//
	//   Delete all free strings.
	//
	while ( ! Free.EndOfList() )
		{
		REGISTER DETAIL *Detail = ((DETAIL*) Free.First());

		//
		//   Delete from the list and add to the free
		//   pool just to be tidy.
		//
		Detail -> Delete( & Free );

		//
		//   The string description may be contain an 
		//   previous value and require some cleanup.
		//
		if ( Detail -> Active )
			{
			//
			//   Delete any existing value.  Remember
			//   to remove it from the hash before
			//   deleting the string as the hash uses
			//   the string.
			//
			RemoveFromHash( ((SBIT32) Detail) );

			delete [] Detail -> Text;

			Detail -> Active = False;
			}

		//
		//   Push back into the pool.
		//
		Details.PushPool( Detail );
		}
	}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\rockall\library\tls.hpp ===
#ifndef _THREAD_LOCAL_STORE_HPP_
#define _THREAD_LOCAL_STORE_HPP_
//                                        Ruler
//       1         2         3         4         5         6         7         8
//345678901234567890123456789012345678901234567890123456789012345678901234567890

    /********************************************************************/
    /*                                                                  */
    /*   The standard layout.                                           */
    /*                                                                  */
    /*   The standard layout for 'hpp' files for this code is as        */
    /*   follows:                                                       */
    /*                                                                  */
    /*      1. Include files.                                           */
    /*      2. Constants exported from the class.                       */
    /*      3. Data structures exported from the class.                 */
	/*      4. Forward references to other data structures.             */
	/*      5. Class specifications (including inline functions).       */
    /*      6. Additional large inline functions.                       */
    /*                                                                  */
    /*   Any portion that is not required is simply omitted.            */
    /*                                                                  */
    /********************************************************************/

#include "Global.hpp"

#include "Assembly.hpp"

    /********************************************************************/
    /*                                                                  */
    /*   Constants exported from the class.                             */
    /*                                                                  */
    /*   The environment constants indicate the state of thread         */
    /*   local store.                                                   */
    /*                                                                  */
    /********************************************************************/

CONST SBIT32 NoTLSMemory			  = -1;
CONST SBIT32 NoTLSStructure			  = 0;

    /********************************************************************/
    /*                                                                  */
    /*   Thread local store.                                            */
    /*                                                                  */
    /*   A wide range of applications use threads.  It is often very    */
    /*   valuable to be able to have some private per thread data.      */
    /*   This functionality is supported by the following class.        */
    /*                                                                  */
    /********************************************************************/

class THREAD_LOCAL_STORE : public ASSEMBLY
    {
        //
        //   Private data.
        //
		BOOLEAN						  Active;

		SBIT32						  TlsIndex;
		SBIT32						  TlsOffset;

    public:
        //
        //   Public functions.
        //
        THREAD_LOCAL_STORE( VOID )
			{
			if ( Active = ((TlsIndex = TlsAlloc()) != NoTLSMemory) )
				{ TlsOffset = ((TlsIndex * sizeof(void*)) + TebSlot); }
			else
				{ Failure( "No TLS available" ); }
			}

		INLINE BOOLEAN Available( VOID )
			{ return Active; }
#ifdef ASSEMBLY_X86
#ifdef ENABLE_NON_STANDARD_ASSEMBLY

		INLINE VOID *GetAddress( VOID )
			{ return (GetTlsAddress( TlsOffset )); }
#endif
#endif

		INLINE VOID *GetPointer( VOID )
			{ return (GetTlsValue( TlsIndex,TlsOffset )); }

		INLINE VOID SetPointer( VOID *NewPointer )
			{ SetTlsValue( TlsIndex,TlsOffset,NewPointer ); }

        ~THREAD_LOCAL_STORE( VOID )
			{
			Active = False;

			if ( TlsIndex != NoTLSMemory )
				{ 
				if ( ! TlsFree( TlsIndex ) )
					{ Failure( "Unable to free TLS memory" ); }
				}
			}

	private:
        //
        //   Disabled operations.
        //
        THREAD_LOCAL_STORE( CONST THREAD_LOCAL_STORE & Copy );

        VOID operator=( CONST THREAD_LOCAL_STORE & Copy );
    };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachecfg.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cachecfg.cxx

Abstract:

    This module contains the functions to get and set disk cache
    configuration parameters.

    Contents:
        GetCacheConfigInfoA
        SetCacheConfigInfoA

Author:

    Sophia Chung (sophiac)  1-May-1995
    
Environment:

    User Mode - Win32

Revision History:
    Mucho rewritten by Akabir   1Q 98

    To understand how the new registration code works, it might be better for you to start with ConfigureCache, 
    GetCacheConfigInfo, etc. for a high level acquaintance; _then_ start poring over the actual registry sets code.
--*/

#include <wininetp.h>
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <shlobj.h>

#define CACHE_TAG           "Cache"

// Cache path keys.
CHAR* g_szSubKey[] = {CONTENT_PATH_KEY, COOKIE_PATH_KEY, HISTORY_PATH_KEY};
CHAR* g_szOldSubKey[] = {CACHE_TAG, COOKIE_PATH_KEY, HISTORY_PATH_KEY};

INT g_iContainerCSIDL[] = { CSIDL_INTERNET_CACHE, CSIDL_COOKIES, CSIDL_HISTORY };
                                
// Top level cache paths resource IDs
#ifndef UNIX
CHAR* g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#else
CHAR* g_dwCachePathResourceID[] = {IDS_CACHE_DEFAULT_SUBDIR_UNIX, IDS_COOKIES_DEFAULT_SUBDIR, IDS_HISTORY_DEFAULT_SUBDIR};
#endif /* UNIX */

// Cache prefixes.
CHAR* g_szCachePrefix[] = {CONTENT_PREFIX, COOKIE_PREFIX, HISTORY_PREFIX};
CHAR* g_szVersionName[] = { CONTENT_VERSION_SUBDIR, "", "History.IE5" };

#define OLD_CACHE_PATH      "Path1"
#define OLD_CACHE_SUBKEY    DIR_SEPARATOR_STRING##"Cache1"

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);

void FlushShellFolderCache()
{
    SHFlushSFCacheWrap( );
    return;
}

typedef HRESULT (*PFNSHGETFOLDERPATH)(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

VOID CheckCacheLocationConsistency();

//#define DEBUG_CACHE_UPGRADE

#ifdef DEBUG_CACHE_UPGRADE
VOID LOG_UPGRADE_DATA(PTSTR pszData)
{
    CHAR szFileName[MAX_PATH];
    DWORD dwSize = MAX_PATH;
    CHAR szComputerName[MAX_PATH];
    HANDLE hResultsFile = NULL;
    strcpy(szFileName, "\\\\BANYAN\\IPTD\\AKABIR\\cacheupgrade\\");
    if (!GetComputerNameA(szComputerName, &dwSize))
    {
        goto exit;
    }
    lstrcatA(szFileName, szComputerName);
    hResultsFile = CreateFileA( szFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        0,
                        NULL);
    if (hResultsFile != INVALID_HANDLE_VALUE)
    {
        if (SetFilePointer(hResultsFile, 0, NULL, FILE_END)==0xFFFFFFFF)
        {
            goto exit;
        }
        DWORD dwFoo;
        if (0==WriteFile(hResultsFile, (PVOID)pszData, lstrlenA(pszData), &dwFoo, NULL))
        {
            DWORD dwE = GetLastError();
        }
    }
exit:
    if (hResultsFile)
    {
        CloseHandle(hResultsFile);
    }
}
#else
#define LOG_UPGRADE_DATA(x)
#endif

#undef SHGetFolderPath

HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath)
{
    HRESULT hr = E_POINTER;
    static PFNSHGETFOLDERPATH pfn = NULL;

    if (NULL == pfn)
    {
        if (NULL == g_HMODShell32)
            g_HMODShell32 = LoadLibrary("shell32.dll");
        if (NULL != g_HMODShell32)
            pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODShell32, "SHGetFolderPathA");

        if (NULL == pfn)
        {
            if (NULL == g_HMODSHFolder)
                g_HMODSHFolder = LoadLibrary("shfolder.dll");
            if (NULL != g_HMODSHFolder)
                pfn = (PFNSHGETFOLDERPATH)GetProcAddress(g_HMODSHFolder, "SHGetFolderPathA");
        }
        
        if (NULL != pfn)
            hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);
    }
    else
        hr = pfn(hwnd, csidl, hToken, dwFlags, pszPath);

    return hr;
}

#define CACHE_SIZE_CAP 32000000

DWORD 
GetDefaultCacheQuota(
    LPSTR pszCachePath, 
    DWORD dwFraction
    )
{ 
    DWORDLONG cKBLimit = 0, cbTotal;

    if (GetDiskInfo(pszCachePath, NULL, NULL, &cbTotal))
    {
        cKBLimit = (cbTotal / (DWORDLONG)(1024*dwFraction));
    }
    if (cKBLimit<1024)
    {
        cKBLimit = DEF_CACHE_LIMIT;
    }
    else if (cKBLimit > CACHE_SIZE_CAP)
    {
        cKBLimit = CACHE_SIZE_CAP;
    }

    return (DWORD)cKBLimit;
}
        
VOID CleanPath(PTSTR pszPath);

/*-----------------------------------------------------------------------------
NormalisePath
 (code swiped from shell32\folder.c: UnexpandEnvironmentstring)

  Collapses paths of the form C:\foobar\dir1\...\dirn to
  %FOOBAR%\dir1\...\dirn
  where %FOOBAR% = "C:\foobar".
  storing result in pszOut.

  If collapse is not possible, returns FALSE and path is unchanged.
  If the given environment variable exists as the first part of the path,
  then the environment variable is inserted into the output buffer.

  Returns TRUE if pszResult is filled in.
  Example:  Input  -- C:\WINNT\SYSTEM32\FOO.TXT -and- lpEnvVar = %SystemRoot%
            Output -- %SystemRoot%\SYSTEM32\FOO.TXT

---------------------------------------------------------------------------*/


BOOL NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar, LPTSTR pszResult, UINT cbResult)
{
    TCHAR szEnvVar[MAX_PATH];
//     DWORD dwEnvVar = ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)) - 1; // don't count the NULL
//    akabir: a curious bug? causes ExpandEnvironmentStrings to return twice the number of characters.

    ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1); // don't count the NULL
    DWORD dwEnvVar = lstrlen(szEnvVar);

    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar, dwEnvVar, pszPath, dwEnvVar) == 2) 
    {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
            strncpy(pszResult, pszEnvVar, MAX_PATH);
            strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
            return TRUE;
        }
    }
    return FALSE;
}

VOID CompressPath(LPTSTR pszSrc, LPTSTR pszDest)
{
    if (!NormalisePath(pszSrc, TEXT("%USERPROFILE%"), pszDest, MAX_PATH))
    {
        if (!NormalisePath(pszSrc, TEXT("%SystemRoot%"), pszDest, MAX_PATH))
        {
            strncpy(pszDest, pszSrc, MAX_PATH);
        }
    }
}

// ------------------------------------------------------------------------------------------------
// IE 3, 4 and 5 have different registry settings. These classes help ensure they all stay in sync.


// -- IE5's registry set ------------------------------------------------------------------------------------------------
// *** If using multiple registry sets, use InitialiseKeys for IE5 first.***
// This is to ensure that profiles-capabilities are noted.

class IE5_REGISTRYSET
{
protected:
    REGISTRY_OBJ m_roHKLMCache, m_roHKCUCache, m_roShellFolder, m_roUserShellFolder, m_roWorking;
    BOOL m_fProfiles;
    BOOL m_fWorkingPerUser;
    TCHAR m_szSharedPath[MAX_PATH];
    TCHAR m_szProfilePath[MAX_PATH];
    DWORD cbP, cbS, m_dwWorking;
    BOOL m_fInitialised;
    
    DWORD InitCommonKeys(BOOL fProfilesCapable, LPSTR pszReg)
    {
        DWORD dwError, dwFlag = CREATE_KEY_IF_NOT_EXISTS;

        m_fProfiles = fProfilesCapable;
        // Shared item info are located in HKLM/[...]/Internet Settings/5.0/Cache/*
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag);
        if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
        {
            m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, pszReg, dwFlag, BASIC_ACCESS);
            if (dwError = m_roHKLMCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roShellFolder.WorkWith(HKEY_CURRENT_USER, SHELL_FOLDER_KEY, dwFlag);
        if (dwError = m_roShellFolder.GetStatus()!=ERROR_SUCCESS)
                goto exit;

        if (fProfilesCapable)
        {
            m_roHKCUCache.WorkWith(HKEY_CURRENT_USER, pszReg, dwFlag);
            if (dwError = m_roHKCUCache.GetStatus()!=ERROR_SUCCESS)
                goto exit;
        }

        m_roUserShellFolder.WorkWith(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY, dwFlag);
        dwError = m_roUserShellFolder.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            m_fInitialised = TRUE;
        }
        // Per-user items are located in HKCU/[...]/Explorer/Shell Folders and /Internet Settings/[5.0/]Cache/*
    exit:
        return dwError;
    }

    virtual BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        // Determine if this is a per-user item
        // HKCU overrides HKLM
        // If any of the following fail, for content, we'll default to shared.

        if (!m_fProfiles)
        {
            return FALSE;    
        }
        
        DWORD dwTemp;
        REGISTRY_OBJ roCUContainer(&m_roHKCUCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        if ((roCUContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roCUContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }
        
        REGISTRY_OBJ roLMContainer(&m_roHKLMCache, g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
        BOOL fPerUser = FALSE;

        if ((roLMContainer.GetStatus()==ERROR_SUCCESS)
            &&
            (roLMContainer.GetValue(PER_USER_KEY, &dwTemp)==ERROR_SUCCESS))
        {
            return dwTemp;
        }  

        // On NT, the default will be a per-user container.
#ifndef UNIX
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_WINNT) ? TRUE : (dwWhich!=CONTENT);
#else
        dwTemp = (GlobalPlatformType == PLATFORM_TYPE_UNIX) ? TRUE : (dwWhich!=CONTENT);
#endif /* UNIX */

        roLMContainer.SetValue(PER_USER_KEY, &dwTemp);
        roCUContainer.SetValue(PER_USER_KEY, &dwTemp);
        return (BOOL)dwTemp;
    }


    // -- ValidatePath ------
    // We always assume we've been given a valid path, but we have to test that it's there
    // and available.
    BOOL ValidatePath(PSTR pszPath)
    {
        DWORD dwAttribute = GetFileAttributes(pszPath);
        if (dwAttribute==0xFFFFFFFF)
        {
            // We assume that the directory just isn't there. So we create it.
            hConstructSubDirs(pszPath);
            dwAttribute = GetFileAttributes(pszPath);
        }
        if ((dwAttribute==0xFFFFFFFF)
            ||
            (dwAttribute & FILE_ATTRIBUTE_READONLY)
            ||
            (!(dwAttribute & FILE_ATTRIBUTE_DIRECTORY)))
        {
            // BUG BUG BUG We probably want to make sure that the old path gets deleted on other machines....
            // We'll use the system path
            // BUG BUG BUG BUG BUG We are *NOT* recording this default location in the registry. Thus, on another
            // machine, the user might still be able to use the set cache location.
            memcpy(pszPath, m_szSharedPath, cbS);

#if 0
            LoadString(GlobalDllHandle, g_dwCachePathResourceID[m_dwWorking], pszPath+cbS, MAX_PATH - cbS);
#endif
            memcpy(pszPath+cbS, g_dwCachePathResourceID[m_dwWorking], 
                    strlen(g_dwCachePathResourceID[m_dwWorking]) + 1);
            
            SetPerUserStatus(FALSE);
        }
        return ERROR_SUCCESS;
    }
    
public:
    IE5_REGISTRYSET()
    {
        m_fInitialised = FALSE;
    }

    virtual DWORD InitialiseKeys(BOOL& fProfilesCapable)
    {
        if (m_fInitialised)
        {
            fProfilesCapable = m_fProfiles;
            return ERROR_SUCCESS;
        }

        DWORD dwError = ERROR_SUCCESS;

        fProfilesCapable = TRUE;
#ifndef UNIX
        cbS = GetWindowsDirectory(m_szSharedPath, sizeof(m_szSharedPath));
#else
        /* On Unix, GetWindowsDirectory points to <install dir>/common
         * And, we don't want to put the cache here.
         */
        lstrcpy(m_szSharedPath, UNIX_SHARED_CACHE_PATH);
        cbS = lstrlen(m_szSharedPath);
#endif /* UNIX */
        if (!cbS || (cbS>sizeof(m_szSharedPath)))
            return ERROR_PATH_NOT_FOUND;
            
        AppendSlashIfNecessary(m_szSharedPath, &cbS);

        cbP = 0;
        // We think that profiles are enabled, so we want to get some info before
        // proceeding. If any of this fails, though, we'll default to no profiles.
        switch (GlobalPlatformType)
        {
#ifndef UNIX
        case PLATFORM_TYPE_WIN95:
        {
            REGISTRY_OBJ roProfilesEnabled(HKEY_LOCAL_MACHINE, PROFILES_ENABLED_VALUE);
            DWORD dwProfilesEnabled = 0;
            if (  (roProfilesEnabled.GetStatus() == ERROR_SUCCESS)
                && 
                  ((roProfilesEnabled.GetValue(PROFILES_ENABLED, &dwProfilesEnabled))==ERROR_SUCCESS)
                &&
                  dwProfilesEnabled)
            {                        
                  // Windows 95 sets the profiles path in the registry.
                CHAR szProfilesRegValue[MAX_PATH];
                memcpy(szProfilesRegValue, PROFILES_PATH_VALUE, sizeof(PROFILES_PATH_VALUE)-1);
                cbP = sizeof(PROFILES_PATH_VALUE)-1;
                AppendSlashIfNecessary(szProfilesRegValue, &cbP);
                cbP = MAX_PATH-sizeof(PROFILES_PATH_VALUE);
                if (GetUserName(szProfilesRegValue + sizeof(PROFILES_PATH_VALUE), &cbP))
                {
                    cbP = MAX_PATH;
                    REGISTRY_OBJ roProfilesDirKey(HKEY_LOCAL_MACHINE, szProfilesRegValue);

                    if (!(((dwError = roProfilesDirKey.GetStatus()) != ERROR_SUCCESS)
                        || 
                        ((dwError = roProfilesDirKey.GetValue(PROFILES_PATH, (LPBYTE) m_szProfilePath, 
                                &cbP)) != ERROR_SUCCESS)))
                    {
                        m_szProfilePath[cbP-1] = DIR_SEPARATOR_CHAR;
                        m_szProfilePath[cbP] = '\0';
                        break;
                    }
                }
            }
            // Either
            // (a) Couldn't get the profiles path from the registry.
            // (b) Couldn't get the user name! 
            // Make the directory the windows directory
            fProfilesCapable = FALSE;
            break;
        }
            
        case PLATFORM_TYPE_WINNT:
            // Windows NT sets the USERPROFILE environment
            // string which contains the user's profile path
            if (cbP = GetEnvironmentVariable("USERPROFILE", m_szProfilePath, MAX_PATH))
            {
                m_szProfilePath[cbP++] = DIR_SEPARATOR_CHAR;
                m_szProfilePath[cbP] = '\0';
            }
            else
            {
                INET_ASSERT(FALSE);
                // Getting the user profiles dir from the environment
                // failed. Set the profiles directory to default.
                memcpy(m_szProfilePath, m_szSharedPath, cbS);
                memcpy(m_szProfilePath + cbS, DEFAULT_PROFILES_DIRECTORY, sizeof(DEFAULT_PROFILES_DIRECTORY));
                cbP = cbS + sizeof(DEFAULT_PROFILES_DIRECTORY) - 1;

                DWORD cbUser = MAX_PATH - cbP;;
                GetUserName(m_szProfilePath + cbP, &cbUser);
                cbP += cbUser;
            }
            break;

#else /* UNIX */
        case PLATFORM_TYPE_UNIX:
            lstrcpy(m_szProfilePath,TEXT("%USERPROFILE%"));
            lstrcat(m_szProfilePath,DIR_SEPARATOR_STRING);
            cbP = lstrlen(m_szProfilePath);
            break;
#endif /* UNIX */

        default:
            // This should never happen.
            INET_ASSERT(FALSE);
        }

        if (dwError==ERROR_SUCCESS)
        {
            dwError = InitCommonKeys(fProfilesCapable, CACHE5_KEY);
        }
        return dwError;
    }

    DWORD SetWorkingContainer(DWORD dwWhich)
    {
        m_dwWorking = dwWhich;
        m_fWorkingPerUser = DetermineKeyPlacing(dwWhich);
        return m_roWorking.WorkWith((m_fWorkingPerUser ? &m_roHKCUCache : &m_roHKLMCache), g_szSubKey[dwWhich], CREATE_KEY_IF_NOT_EXISTS);
    }

    // VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit);

    // Path --------------------------------------------------------------------------
    virtual DWORD GetPath(PTSTR pszPath)
    {
        if ((S_OK==SHGetFolderPath(NULL, g_iContainerCSIDL[m_dwWorking] | CSIDL_FLAG_CREATE, NULL, 0, pszPath))
            && (*pszPath!='\0'))
        {
            DWORD dwErr = ValidatePath(pszPath);
            if (dwErr==ERROR_SUCCESS)
            {
                DWORD ccPath = lstrlen(pszPath);
                // We check the lengths of the strings only when we're moving the containers. No need to do the check every
                // time (assume a valid path)
                if (m_dwWorking!=COOKIE)
                {
                    EnableCacheVu(pszPath, m_dwWorking);
                }
                AppendSlashIfNecessary(pszPath, &ccPath);

#ifdef UNIX
               /* On Unix, it is possible that IE4 and IE5 co-exist on a user's
                * installation. So, we need to keep the IE4 cookies which are
                * different from the IE5 cookies. For IE5, we have the following
                * configuration for the caches -
                *
                * cookies - %HOME%/.microsoft/ie5/Cookies
                * content - %HOME%/.microsoft/ie5/TempInternetFiles/Content.IE5
                * history - %HOME%/.microsoft/ie5/History/History.IE5
                */
               CHAR szIE5Dir[] = "ie5/";
               int  index = ccPath-2; // skip the last slash
               int  lenIE5Dir = lstrlen(szIE5Dir);

               while(index >= 0 && pszPath[index] != FILENAME_SEPARATOR) 
                    index--;

               index++;
               memmove(&pszPath[index+lenIE5Dir],&pszPath[index],ccPath-index+2);
               memcpy(&pszPath[index],szIE5Dir,lenIE5Dir);
               ccPath += lenIE5Dir;
#endif /* UNIX */

                memcpy(pszPath+ccPath, g_szVersionName[m_dwWorking], lstrlen(g_szVersionName[m_dwWorking])+1);
                if (GlobalIdentity && (m_dwWorking!=CONTENT))
                {
                    if (!GenerateStringWithOrdinal(NULL, GlobalIdentity, pszPath, MAX_PATH))
                    {
                        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
                    }
                }
            }
            return dwErr;
        }
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    virtual DWORD SetPath(PTSTR pszPath)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        DWORD dwError;

        /* Try to preserve the environment variables on Unix */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));
        if (m_fProfiles)
        {
            CHAR szScratch[MAX_PATH];
            CompressPath(pszPath, szScratch);
            if ((dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szScratch, REG_EXPAND_SZ))==ERROR_SUCCESS)
            {
#ifndef UNIX
               DWORD dwType = REG_SZ;
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
#else
                dwError = m_roShellFolder.SetValue(g_szOldSubKey[m_dwWorking],szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
            }
            // Possible BUG: If we move from the profiled path to the shared path, we still record it as a peruseritem.
            SetPerUserStatus(TRUE);            
        }
        // Non-profiles-enabled machine
        // On Win9x machines, with profiles disabled, we need to write the path to the 
        // HKEY_USERS/.default/blah blah/Explorer/User Shell Folders to ensure that SHGetFolderPath returns
        // the proper value for other users. 
        else
        {
            REGISTRY_OBJ roProfilesLessPath(HKEY_USERS, PROFILELESS_USF_KEY);
            dwError = roProfilesLessPath.GetStatus();
            if (dwError==ERROR_SUCCESS)
            {
                if ((dwError = roProfilesLessPath.SetValue(g_szOldSubKey[m_dwWorking],pszPath, REG_EXPAND_SZ))==ERROR_SUCCESS)
                {
#ifndef UNIX
                    DWORD dwType = REG_SZ;
#else
                    DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */
                    dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking],pszPath, dwType);
                }
            }
            // For IE4 compatibility, we might have to adjust the old cache location here, as well.
        }
        return dwError;
    }


    // Prefix ------------------------------------------------------------------------
    virtual DWORD GetPrefix(LPSTR szPrefix)
    {
        DWORD dwError, cbKeyLen = MAX_PATH;
        if ((dwError = m_roWorking.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szPrefix, &cbKeyLen))==ERROR_SUCCESS)
        {
            if (cbKeyLen > 0)
            {
                // Strip trailing whitespace.
                cbKeyLen--;
                StripTrailingWhiteSpace(szPrefix, &cbKeyLen);
            }
        }
        else
        {
            // If no prefix found in registry create via
            // defaults and write back to registry.
            strncpy(szPrefix, g_szCachePrefix[m_dwWorking], MAX_PATH);
            SetPrefix(szPrefix);
            dwError = ERROR_SUCCESS;
        }
        
        return dwError;
    }

    virtual DWORD SetPrefix(PTSTR pszPrefix)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        return m_roWorking.SetValue(CACHE_PREFIX_VALUE, (pszPrefix) ? pszPrefix : g_szCachePrefix[m_dwWorking], REG_SZ);
    }

    // Limit -------------------------------------------------------------------------
    virtual DWORD GetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        if ((m_roWorking.GetValue(CACHE_LIMIT_VALUE, &cbLimit)!=ERROR_SUCCESS) || (cbLimit < 512))
        {
            cbLimit = 0;
            return SetLimit(pszCachePath, cbLimit);
        }
        return ERROR_SUCCESS;
    }

    // virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit);

    virtual DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
    INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
    // If no limit found in registry create via
    // defaults and write back to registry.
    // Cache limit - for the content cache we calculate the cache limit
    // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
    // are set to DEF_CACHE_LIMIT.
    if (cbLimit==0)
    {
        cbLimit = (m_dwWorking==CONTENT) 
                        ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                        : DEF_CACHE_LIMIT;
    }
    DWORD dwError = m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);

    /*
    if (dwError==ERROR_SUCCESS)
    {
        // Hack so that apps that read the cache quota from the registry are
        // still able to do so.
        IE4_REGISTRYSET ie4;
        dwError = ie4.InitialiseKeys(m_fProfiles);
        if (dwError==ERROR_SUCCESS)
        {
            ie4.SetWorkingContainer(m_dwWorking);
            ie4.SetLimit(pszCachePath, cbLimit);
        }
    }
    */ 
    
    return dwError;
    }

    // Use IsFirstTime* to figure out if this is the first time for this install of wininet and for marking it so ------------
private:
    BOOL IsFirstTimeFor(HKEY hKey)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig(hKey, CACHE5_KEY);

        return roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS ? 
                        strcmp(szSigKey, CACHE_SIGNATURE) : TRUE;
    }

public:
    BOOL IsFirstTimeForUser()
    {
        return IsFirstTimeFor((m_fProfiles ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE));
    }

    BOOL IsFirstTimeForMachine()
    {
        return IsFirstTimeFor(HKEY_LOCAL_MACHINE);
    }

    VOID SetIfFirstTime()
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];

        // On a profiles-not-enabled machine, store the signature in HKLM so we don't have to research for values
        // On a profiles-enabled machine, store there to notify IE of previous installation of IE5.
        REGISTRY_OBJ roSig(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);

        // On profiles-enabled machines,  we store a signature in HKCU so that we don't have to do 
        // much hunting for registry values
        if (m_fProfiles)
        {
            REGISTRY_OBJ roSig(HKEY_CURRENT_USER, CACHE5_KEY);
            roSig.SetValue(CACHE_SIGNATURE_VALUE, CACHE_SIGNATURE, REG_SZ);
        }        
    }

    // PerUserItem ---------------------------------------------------------------------
    virtual VOID SetPerUserStatus(BOOL fState)
    {
        DWORD flState = fState;
        if (m_fProfiles && fState!=m_fWorkingPerUser)
        {
            REGISTRY_OBJ roTemp(&m_roHKCUCache, g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);            
            if (roTemp.GetStatus()==ERROR_SUCCESS)
            {
                roTemp.SetValue(PER_USER_KEY, &flState);
                m_roWorking.WorkWith((fState ? &m_roHKCUCache
                                             : &m_roHKLMCache), g_szSubKey[m_dwWorking], CREATE_KEY_IF_NOT_EXISTS);
                m_fWorkingPerUser = fState;
            }
        }
    }

    virtual DWORD GetPerUserStatus()
    {
        return m_fWorkingPerUser;
    }

/*
    DWORD UpdateContentPath(PSTR pszNewPath)
    {
        TCHAR szOldPath[MAX_PATH];
        DWORD dwError;

        dwError = ERROR_SUCCESS;

        if ((dwError=SetWorkingContainer(CONTENT))==ERROR_SUCCESS)
        {
            INTERNET_CACHE_CONFIG_INFOA icci;
            icci.dwContainer = CONTENT;
            GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
            strncpy(szOldPath, icci.CachePath, ARRAY_ELEMENTS(szOldPath));

            if (((dwError=MoveCachedFiles(szOldPath, pszNewPath))==ERROR_SUCCESS)
                &&
                ((dwError=SetPath(pszNewPath))==ERROR_SUCCESS))
            {
                EnableCacheVu(pszNewPath);

            // Right now, we're adding entries so that once we restart, we'll delete any
            // stray files.

            // BUT, there's a case that Move will be interrupted; in that case, we ought
            // to finish the move on start up -- pop up a dialog notifying user of such
            // and then delete.
            // Also, if the Move's interrupted, then this info never will get written. OTOH,
            // we can argue that the user can just move from the old location to the new.
    
                CHAR szRunOnce          [2 * MAX_PATH];
                CHAR szSystemPath       [MAX_PATH];

            // Add a RunOnce entry to be run on reboot.
                REGISTRY_OBJ roRunOnce((m_fWorkingPerUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), RUN_ONCE_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if ((dwError=roRunOnce.GetStatus())!=ERROR_SUCCESS)
                    return dwError;

            // create RunOnce string in the form:
            // "rundll32.exe <system dir>\wininet.dll,RunOnceUrlCache C:\Windows\NewCacheLocation"
                if (!GetSystemDirectory(szSystemPath, MAX_PATH))
                    return ERROR_INTERNAL_ERROR;
       
                DisableCacheVu(szOldPath);
                // Get rid of content.ie5.
                PathRemoveBackslash(szOldPath);
                PathRemoveFileSpec(szOldPath);
                DisableCacheVu(szOldPath);
                GetShortPathName(szOldPath, szOldPath, ARRAY_ELEMENTS(szOldPath));
                wnsprintf(szRunOnce, sizeof(szRunOnce),
                            "rundll32.exe %s\\wininet.dll,RunOnceUrlCache %s", 
                            szSystemPath, szOldPath);
                
            // Set the RunOnce command in registry for wininet.
                roRunOnce.SetValue(TEXT("MovingCacheA Wininet Settings"), (LPSTR)szRunOnce, REG_SZ);
            }
        }
        return dwError;
    }

  */  

// DWORD GetIEVersion();


// -- AttemptToUseSharedCache
// Given a path (and limit) attempt to use the path for a shared location.
// If the path is null, then try to use any value if present, else invent one.

VOID AttemptToUseSharedCache(PTSTR pszPath, DWORD ckbLimit)
{
    TCHAR szSharedPath[MAX_PATH];
    DWORD cc = ARRAY_ELEMENTS(szSharedPath);

    REGISTRY_OBJ roContent(&m_roHKLMCache, g_szSubKey[CONTENT], CREATE_KEY_IF_NOT_EXISTS);
    if ((roContent.GetStatus()==ERROR_SUCCESS)
        &&
        (roContent.GetValue(CACHE_PATH_VALUE, (LPBYTE)szSharedPath, &cc)==ERROR_SUCCESS))
    {
        LOG_UPGRADE_DATA("Found a shared cache location...\n");
        goto write_value;
    }

    if (pszPath!=NULL)
    {
        LOG_UPGRADE_DATA(pszPath);
        LOG_UPGRADE_DATA("\n is ");
        GetUserName(szSharedPath, &cc);

        // We're going to ignore just the user name, during this comparison. And
        // if it's in the profiles directory, fuhgedaboutit.
        if (m_fProfiles && !StrCmpNI(m_szProfilePath, pszPath, cbP-cc))
        {
            pszPath = NULL;
            LOG_UPGRADE_DATA("not okay \n");
            goto carryon;
        }
        LOG_UPGRADE_DATA("okay \n");
        strcpy(szSharedPath, pszPath);
    }

carryon:
    if (pszPath==NULL)
    {
        memcpy(szSharedPath, m_szSharedPath, (cbS+1)*sizeof(TCHAR));
        CleanPath(szSharedPath);
        LOG_UPGRADE_DATA("Using a constructed shared path\n");
    }

    // We've finally decided on the path. Now let's write the value into the registry.
    roContent.SetValue(CACHE_PATH_VALUE, szSharedPath, REG_SZ);
    SetWorkingContainer(CONTENT);
    SetPerUserStatus(FALSE);
    SetLimit(szSharedPath, ckbLimit);

write_value:
    LOG_UPGRADE_DATA("The shared cache will be located at ");
    LOG_UPGRADE_DATA(szSharedPath);
    LOG_UPGRADE_DATA("\n");
    
    // This will take care of HKCU
    CHAR szScratch[MAX_PATH];
#ifndef UNIX
    if (!NormalisePath(szSharedPath, TEXT("%SystemRoot%"), szScratch, sizeof(szScratch)))
#else
    if (!NormalisePath(szSharedPath, TEXT("%USERPROFILE%"), szScratch, sizeof(szScratch)))
#endif /* UNIX */
    {
        strncpy(szScratch, szSharedPath, MAX_PATH);
    }
    if (m_roUserShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ)==ERROR_SUCCESS)
    {
#ifndef UNIX
       DWORD dwType = REG_SZ;
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szSharedPath, dwType);
#else
        m_roShellFolder.SetValue(g_szOldSubKey[CONTENT], szScratch, REG_EXPAND_SZ);
#endif /* UNIX */
    }
}

};

#define m_roPaths           m_roShellFolder
#define m_roSpecialPaths    m_roHKCUCache

#if 0 
class IE3_REGISTRYSET : public IE5_REGISTRYSET
{
    // Registry keys shipped with IE 3:
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Paths\path1
    //                                                                        \path2
    //                                                                        \path3
    //                                                                        \path4
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Special Paths\Cookies
    //                                                                                \History
    //
    // Software\Microsoft\Windows\CurrentVersion\Internet Settings\Cache\Url History

private:
    REGISTRY_OBJ m_roPath[DEF_NUM_PATHS]; 
    
public:
    // Initialise the IE3 keys that we might work with.
    
    DWORD InitialiseKeys()
    {
        DWORD dwError, i;
        TCHAR szScratch[MAX_PATH];
        TCHAR pszBase[MAX_PATH];
        DWORD dwBaseLen;

        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        m_roHKLMCache.WorkWith(HKEY_LOCAL_MACHINE, OLD_CACHE_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roHKLMCache.GetStatus())!=ERROR_SUCCESS)
                goto exit;

        m_roPaths.WorkWith(&m_roHKLMCache, CACHE_PATHS_KEY, CREATE_KEY_IF_NOT_EXISTS);
        if ((dwError=m_roPaths.GetStatus())!=ERROR_SUCCESS)
            goto exit;

        memcpy(pszBase, OLD_CACHE_PATH, sizeof(OLD_CACHE_PATH));
        dwBaseLen = sizeof(OLD_CACHE_PATH) - 1;
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            pszBase[dwBaseLen-1] = (TCHAR)('1' + i);
            m_roPath[i].WorkWith(&m_roPaths, pszBase, CREATE_KEY_IF_NOT_EXISTS);
            if ((dwError=m_roPath[i].GetStatus())!=ERROR_SUCCESS)
                goto exit;
        }

        m_roSpecialPaths.WorkWith(&m_roHKLMCache, CACHE_SPECIAL_PATHS_KEY);
        m_fInitialised = TRUE;
    exit:
        return dwError;
    }

    BOOL GetContentDetails(LPSTR szPath, DWORD& cbLimit)
    {
        DWORD cbKey = MAX_PATH;
        if (m_roPaths.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szPath, &cbKey)!=ERROR_SUCCESS)
            return FALSE;

        cbLimit = 0;
        for (int i=0; i<DEF_NUM_PATHS; i++)
        {
            if (m_roPath[i].GetValue(CACHE_LIMIT_VALUE, &cbKey)!=ERROR_SUCCESS)
            {
                cbLimit = GetDefaultCacheQuota(szPath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION);
                break;
            }
            cbLimit += cbKey;
        }
        return TRUE;
    }

    DWORD SetPath(PTSTR pszPath)
    {
        DWORD i, nPaths, dwError;
        DWORD cb = strlen((LPSTR)pszPath);
        TCHAR szBase[MAX_PATH];
#ifndef UNIX
        DWORD dwType = REG_SZ;
#else
        DWORD dwType = REG_EXPAND_SZ;
#endif /* UNIX */

        /* On Unix, try to preserve the Environment variables if possible */
        UNIX_NORMALIZE_PATH_ALWAYS(pszPath, TEXT("%USERPROFILE%"));


        // Cache content path.
        if ((dwError = m_roPaths.SetValue(CACHE_DIRECTORY_VALUE, (LPSTR)pszPath, dwType)) != ERROR_SUCCESS)
            goto exit;

        // Number of subdirectories (optional).
        nPaths = DEF_NUM_PATHS;
        if ((dwError = m_roPaths.SetValue(CACHE_PATHS_KEY, &nPaths)) != ERROR_SUCCESS)
            goto exit;
    
        memcpy(szBase, pszPath, cb);
        memcpy(szBase + cb, OLD_CACHE_SUBKEY, sizeof(OLD_CACHE_SUBKEY));
        cb += sizeof(OLD_CACHE_SUBKEY) - 2;
        // Subdirectories' paths and limits from CONTENT.
        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            szBase[cb] = (TCHAR)('1' + i);
            if ((dwError = m_roPath[i].SetValue(CACHE_PATH_VALUE, szBase, REG_SZ)) != ERROR_SUCCESS)
                goto exit;    
        }

    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    DWORD SetLimit(DWORD dwLimit)
    {
        DWORD i, nPaths, dwError;

        for (i = 0; i < DEF_NUM_PATHS; i++)
        {
            DWORD cbCacheLimitPerSubCache = (DWORD) (dwLimit/ DEF_NUM_PATHS);
            if ((dwError = m_roPath[i].SetValue(CACHE_LIMIT_VALUE, &cbCacheLimitPerSubCache)) != ERROR_SUCCESS)
                goto exit;
        }
    exit:    
        INET_ASSERT(dwError == ERROR_SUCCESS);
        return dwError;
    }

    // Restore key IE3 values. *snicker* --------------------------------------------
    VOID FixLegacySettings(PTSTR pszPath, DWORD cbLimit)
    {
        if (InitialiseKeys()==ERROR_SUCCESS)
        {
            SetPath(pszPath);
            SetLimit(cbLimit);
        }
    }
};

class IE4_REGISTRYSET : public IE5_REGISTRYSET
{
private:
    BOOL DetermineKeyPlacing(DWORD dwWhich)
    {
        DWORD dwValue;
        if (m_fProfiles && (dwWhich==CONTENT))
        {
            if (m_roHKLMCache.GetValue(PROFILES_ENABLED, &dwValue)==ERROR_SUCCESS)
            {
                return dwValue;
            }

#ifndef UNIX
            if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
            if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* !UNIX */
            {
               return m_fProfiles;
            }

            // On Win9x we have to go through the following contortions to decide whether or not the
            // user is using a per-user cache or a shared cache.
         
            TCHAR szPath[MAX_PATH];
            DWORD cbPath = sizeof(szPath);
            if (m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS)
            {
                cbPath = sizeof(szPath);
                return (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)==ERROR_SUCCESS);
            }
        }
        return m_fProfiles;
    }

public:
    DWORD InitialiseKeys(BOOL& fProfiles)
    {
        if (m_fInitialised)
        {
            return ERROR_SUCCESS;
        }
        return InitCommonKeys(fProfiles, OLD_CACHE_KEY);
    }

    DWORD GetPath(PTSTR pszCachePath)
    {
        DWORD cbKeyLen = MAX_PATH;
        LOG_UPGRADE_DATA("Getting IE4 cache location...\n");

        DWORD dwError = m_fProfiles ? m_roShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)pszCachePath, &cbKeyLen) 
                                          : m_roWorking.GetValue(CACHE_PATH_VALUE, (LPBYTE)pszCachePath, &cbKeyLen);
#ifndef UNIX
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_WINNT) && (dwError==ERROR_SUCCESS))
#else
        if (m_fProfiles && (GlobalPlatformType == PLATFORM_TYPE_UNIX) && (dwError==ERROR_SUCCESS))
#endif /* UNIX */
        {
           LOG_UPGRADE_DATA("Correcting IE4 cache location...\n");
           LOG_UPGRADE_DATA(pszCachePath);
           LOG_UPGRADE_DATA("\n");
           TCHAR szPath[MAX_PATH];
           DWORD cbPath = ARRAY_ELEMENTS(szPath);
            if (m_roUserShellFolder.GetValue(g_szOldSubKey[m_dwWorking],(LPBYTE)szPath, &cbPath)!=ERROR_SUCCESS)
            {
                CompressPath(pszCachePath, szPath);
                dwError = m_roUserShellFolder.SetValue(g_szOldSubKey[m_dwWorking], szPath, REG_EXPAND_SZ);
            }
        }
        return dwError;
    }

    BOOL WasIE4Present(BOOL& fProfilesCapable)
    {
        DWORD cb = MAX_PATH;
        CHAR szSigKey[MAX_PATH];
        REGISTRY_OBJ roSig((fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE), OLD_CACHE_KEY);

        return (roSig.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cb)==ERROR_SUCCESS);
    }

    DWORD SetLimit(PTSTR pszCachePath, DWORD& cbLimit)
    {
        INET_ASSERT(m_roWorking.GetStatus()==ERROR_SUCCESS);
        // If no limit found in registry create via
        // defaults and write back to registry.
        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (cbLimit==0)
        {
            cbLimit = (m_dwWorking==CONTENT) 
                            ? GetDefaultCacheQuota(pszCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION)
                            : DEF_CACHE_LIMIT;
        }

        // Dumb hack for back compat. *sigh*
        if (m_dwWorking==CONTENT)
        {
            REGISTRY_OBJ roLimit(&m_roHKLMCache, g_szSubKey[CONTENT]);
            if (roLimit.GetStatus()==ERROR_SUCCESS)
            {
                roLimit.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
            }
        }
        return m_roWorking.SetValue(CACHE_LIMIT_VALUE, &cbLimit);
    }
};

#endif




#define IsFieldSet(fc, bitFlag) (((fc) & (bitFlag)) != 0)

#define FAILSAFE_TIMEOUT (60000)
#define UNMAP_TIME (120000)

// ----------------------------------------------------------------------------
// The following functions deal with keeping the cache containers all up and ready

// -- ConfigureCache() --------------------------------------------------------
// Get the cache info from registry and try to init.

// In general, GetCacheConfigInfo should only rarely fail -- mostly whenever HKCU
// is expected but not available. In that case, we use the system root cache. 
// If _that_ fails, we panic.

DWORD CConMgr::ConfigureCache()
{
    for (DWORD iter = 0; ; iter++)
    {
        DWORD dwError;
        switch (iter)
        {
        case 0:
            dwError = GetCacheConfigInfo();
            break;

        case 1:
            dwError = GetSysRootCacheConfigInfo();
            break;

        default:
            INET_ASSERT(FALSE);
            return dwError;
        }

        if (dwError==ERROR_SUCCESS && (dwError=InitFixedContainers())==ERROR_SUCCESS)
            break;

        // If InitFixedContainers has failed, it is possible that the container list 
        // (ConList) is not empty. Make sure it has no entries.
        LOCK_CACHE();
        if (ConList.Size() != 0)
            ConList.Free();
        UNLOCK_CACHE();
    }

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetCacheConfigInfo
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetCacheConfigInfo()
{
    DWORD dwError, i;

    // Prepare and initialise a registry set for every version of IE available.
    // IE5 must be initialised first because it determines whether profiles are
    // enabled on this machine and set ConMgr's _fProfilesCapable for future
    // reference. Then IE4 and IE3 can be called in whatever order.
    IE5_REGISTRYSET ie5rs;
    if ((dwError=ie5rs.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
    {
        goto exit;
    }

#ifdef WININET6
    GlobalCacheHKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
#endif

    // In WinHttp we don't care if the user had been using IE4 or whatever,
    // thus the code commented out above    
#if 0
    // Look for a signature to indicate that this cache has been placed before.
    if (ie5rs.IsFirstTimeForUser())
    {
        LOG_UPGRADE_DATA("Install 1st time for user\n");
        DiscoverRegistrySettings(&ie5rs);
    } else {
        // If the user is roaming across machines that include IE4,
        // then safeguard against IE4 writing REG_SZ values that
        // be REG_EXPAND_SZ.
        CheckCacheLocationConsistency();
    }
#endif

    // If the user is roaming across machines that include IE4,
    // then safeguard against IE4 writing REG_SZ values that
    // be REG_EXPAND_SZ.
    // CheckCacheLocationConsistency();

    // -----------------------------------------------------------------------------------
    // Get the container paths, prefixes (if any) and default limit values.
    for (i = CONTENT; i < NCONTAINERS; i++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        DWORD cbCacheLimit;
        BOOL fPerUser;
        // This should only rarely fail.

        if ((dwError=ie5rs.SetWorkingContainer(i))!=ERROR_SUCCESS)
        {
            goto exit;
        }
        
        fPerUser = ie5rs.GetPerUserStatus();
        dwError = ie5rs.GetPath(szCachePath);
        LOG_UPGRADE_DATA("GetCacheConfigInfo/ie5rs.GetPath for user: ");
        LOG_UPGRADE_DATA(szCachePath);
        LOG_UPGRADE_DATA("\n");

        if (dwError==ERROR_SUCCESS) 
        {
            ie5rs.GetPrefix(szCachePrefix);
            ie5rs.GetLimit(szCachePath, cbCacheLimit);
        }
        else
        {
            break;
        }

        // Got info, now create the container --------------------------------------
        _coContainer[i] = new URL_CONTAINER(g_szSubKey[i], 
                                            szCachePath, 
                                            szCachePrefix, 
                                            (LONGLONG)cbCacheLimit*1024,
                                            0);

        if (_coContainer[i])
        {
            dwError = _coContainer[i]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[i];
                break;
            }
            ConList.Add(_coContainer[i]);
            _coContainer[i]->SetPerUserItem(fPerUser);
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        // Maintain values for backwards compatibility
        /* We don't care in WinHTTP
        if (i==CONTENT)
        {
            // If repairing IE3's settings fails, well, who cares? IE5 is still going.
            IE3_REGISTRYSET ie3rs;
            ie3rs.FixLegacySettings(szCachePath, cbCacheLimit);
        }
        */
    }

exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetSysRootCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetSysRootCacheConfigInfo()
{
    CHAR szParentPath[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szParentPath);

#ifndef UNIX
    {
        // In case of failure to create containers in the regular location,
        // we should put the cache in a user-specifiable location HKLM\* REG_EXPAND_SZ
        // Otherwise in the temp directory
        // Otherwise in the Windows directory
        REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
        BOOL fResult = FALSE;
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            TCHAR szTemp[MAX_PATH];
            if (roCache.GetValue(TEXT("SystemCache"), (LPBYTE)szTemp, &cb)==ERROR_SUCCESS)
            {
                cb = ExpandEnvironmentStrings(szTemp,szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
                if (cb && (cb < ARRAY_ELEMENTS(szParentPath)))
                {
                    fResult = TRUE;
                }
            }
        }
        if (!fResult)
        {
            cb = ExpandEnvironmentStrings(TEXT("%TEMP%"),szParentPath,ARRAY_ELEMENTS(szParentPath)) - 1;
            if (!cb || (cb > ARRAY_ELEMENTS(szParentPath)))
            {
                cb = GetWindowsDirectory(szParentPath, ARRAY_ELEMENTS(szParentPath));
            }
        }
    }
#else
    /* On Unix, GetWindowsDirectory will point to <install dir>/common
     * and the cache should not be created here in any case
     */
    lstrcpy(szParentPath,UNIX_SHARED_CACHE_PATH);
    cb = lstrlen(szParentPath);
#endif /* UNIX */
    if (!cb || (cb>sizeof(szParentPath)))
    {
        return ERROR_PATH_NOT_FOUND;
    }
    AppendSlashIfNecessary(szParentPath, &cb);
    
    for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
    {
        CHAR szCachePath[MAX_PATH];
        CHAR szCachePrefix[MAX_PATH];
        LONGLONG cbCacheLimit;

        // Get cache paths out of dll resource and form absolute
        // paths to top level cache directories.
        memcpy(szCachePath, szParentPath, cb);

#if 0
        if (!LoadString(GlobalDllHandle, g_dwCachePathResourceID[idx], szCachePath + cb, MAX_PATH - cb))
        {
            return GetLastError();
        }
#endif
        memcpy(szCachePath+cb, g_dwCachePathResourceID[idx], 
                strlen(g_dwCachePathResourceID[idx]) + 1);
    
        DWORD ccPath = lstrlen(szCachePath);
        AppendSlashIfNecessary(szCachePath, &ccPath);
        memcpy(szCachePath+ccPath, g_szVersionName[idx], lstrlen(g_szVersionName[idx])+1);

        // Cache prefix.        
        memcpy(szCachePrefix, g_szCachePrefix[idx], strlen(g_szCachePrefix[idx]) + 1);

        // Cache limit - for the content cache we calculate the cache limit
        // as being max(DEF_CACHE_LIMIT, 1/32 of the disk size) All others caches
        // are set to DEF_CACHE_LIMIT.
        if (idx == CONTENT)
        {
            
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY);
                fResult = FALSE;
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    DWORD cKBLimit;
                    if (roLimit.GetValue(CACHE_LIMIT_VALUE, &cKBLimit)==ERROR_SUCCESS)
                    {
                        cbCacheLimit = cKBLimit * (LONGLONG)1024;
                        fResult = TRUE;
                    }
                }
            }
            if (!fResult)
            {
                cbCacheLimit = 
                        (DWORDLONG)GetDefaultCacheQuota(szCachePath, NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION) 
                        * (DWORDLONG)1024;
            }
        }
        else
        {
            // Non-CONTENT cache; use default.
            cbCacheLimit = DEF_CACHE_LIMIT * (LONGLONG)1024;
        }

        _coContainer[idx] = new URL_CONTAINER(g_szSubKey[idx], szCachePath, szCachePrefix, cbCacheLimit, 0);

        if (_coContainer[idx])
        {
            DWORD dwError = _coContainer[idx]->GetStatus();
            if (dwError!=ERROR_SUCCESS)
            {
                delete _coContainer[idx];
                return dwError;
            }
            ConList.Add(_coContainer[idx]);
            _coContainer[idx]->SetPerUserItem(FALSE);
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }    

    _fUsingBackupContainers = TRUE;
    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::GetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
/*
BOOL CConMgr::GetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    LPDWORD lpdwCacheConfigInfoBufferSize, DWORD dwFieldControl)
{
    LOCK_CACHE();

    BOOL fIE5Struct = (lpCacheConfigInfo->dwStructSize == sizeof(INTERNET_CACHE_CONFIG_INFO));
    
    if(IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC))
    {
        lpCacheConfigInfo->dwSyncMode = GlobalUrlCacheSyncMode;
    }
    
    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_QUOTA_FC))
    {
        lpCacheConfigInfo->dwQuota = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit()/1024L);
    }

    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_USAGE_FC))
    {
        lpCacheConfigInfo->dwNormalUsage = (DWORD) (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheSize()/1024L);
    }
    
    if (fIE5Struct && IsFieldSet(dwFieldControl, CACHE_CONFIG_STICKY_CONTENT_USAGE_FC) && (lpCacheConfigInfo->dwContainer==CONTENT))
    {
        lpCacheConfigInfo->dwExemptUsage = (DWORD) (_coContainer[CONTENT]->GetExemptUsage()/1024L);
    }
    
    lpCacheConfigInfo->fPerUser = IsFieldSet( dwFieldControl, CACHE_CONFIG_USER_MODE_FC)
                                    ? _coContainer[lpCacheConfigInfo->dwContainer]->IsPerUserItem()
                                    : _coContent->IsPerUserItem();

    if (IsFieldSet(dwFieldControl, CACHE_CONFIG_CONTENT_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = CONTENT;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_HISTORY_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = HISTORY;
    }
    else if (IsFieldSet(dwFieldControl, CACHE_CONFIG_COOKIES_PATHS_FC))
    {
        lpCacheConfigInfo->dwContainer = COOKIE;
    }
    // These are the actual field codes that should be sent for cache paths.
    // Note that the path returned *does not* contain subdirs (cache1..N).
    if (lpCacheConfigInfo->dwContainer <= HISTORY)
    {
        memcpy(lpCacheConfigInfo->CachePath, 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePath(), 
                _coContainer[lpCacheConfigInfo->dwContainer]->GetCachePathLen() + 1);
        lpCacheConfigInfo->dwQuota = (DWORD)
               (_coContainer[lpCacheConfigInfo->dwContainer]->GetCacheLimit() / 1024);        

        lpCacheConfigInfo->dwNumCachePaths = (DWORD) 1;    
    }

    UNLOCK_CACHE();
    return TRUE;
}
*/

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetUrlCacheConfigInfo
  ----------------------------------------------------------------------------*/
/*
BOOL CConMgr::SetUrlCacheConfigInfo(LPCACHE_CONFIG_INFO pConfig, 
                                              DWORD dwFieldControl)
{         
    DWORD i, dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);
    
    LOCK_CACHE();
    
    //  Check FieldControl bits and set the values for set fields
    if( IsFieldSet( dwFieldControl, CACHE_CONFIG_SYNC_MODE_FC ))
    {

        INET_ASSERT(pConfig->dwSyncMode <= WININET_SYNC_MODE_AUTOMATIC);

        InternetWriteRegistryDword(vszSyncMode, pConfig->dwSyncMode);

        GlobalUrlCacheSyncMode = pConfig->dwSyncMode;

        // set a new version and simultaneously
        // increment copy for this process, so we don't
        // read registry for this process
        IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                            &GlobalSettingsVersion);
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_DISK_CACHE_PATHS_FC ))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    if ( IsFieldSet( dwFieldControl, CACHE_CONFIG_QUOTA_FC ) && pConfig->dwContainer==CONTENT)
    {
        DWORD cbSize = pConfig->dwQuota;
        INET_ASSERT(cbSize);

        if (!_fUsingBackupContainers)
        {
            IE5_REGISTRYSET ie5;
            IE3_REGISTRYSET ie3;
            
            if ((dwError=ie5.InitialiseKeys(_fProfilesCapable))!=ERROR_SUCCESS)
            {
                goto exit;
            }
            ie5.SetWorkingContainer(CONTENT);
            TCHAR szTemp[MAX_PATH];
            ie5.GetPath(szTemp);
            ie5.SetLimit(szTemp, cbSize);

            if (ie3.InitialiseKeys()==ERROR_SUCCESS)
            {
                ie3.FixLegacySettings(szTemp, cbSize);
            }
        }
        else
        {
            REGISTRY_OBJ roCache(HKEY_LOCAL_MACHINE, CACHE5_KEY, CREATE_KEY_IF_NOT_EXISTS);
            BOOL fResult = (roCache.GetStatus()==ERROR_SUCCESS);
            if (fResult)
            {
                REGISTRY_OBJ roLimit(&roCache, CONTENT_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
                if (roLimit.GetStatus()==ERROR_SUCCESS)
                {
                    roLimit.SetValue(CACHE_LIMIT_VALUE, &cbSize);
                }
            }
        }

        if ((((LONGLONG)cbSize * 1024) < _coContent->GetCacheSize()))
            _coContent->CleanupUrls (DEFAULT_CLEANUP_FACTOR, 0);
        _coContent->SetCacheLimit(cbSize* (LONGLONG)1024);
    }

exit:
    UNLOCK_CACHE();
    BOOL fRet = (dwError==ERROR_SUCCESS);
    if (!fRet)
    {
        SetLastError(dwError);
        DEBUG_ERROR(INET, dwError);
    }
    return fRet;
}
*/

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetContentPath

UpdateUrlCacheContentPath leads to this function.
This initiates the cache move. Should be called just before shutdown.

----------------------------------------------------------------------------*/
/*
BOOL CConMgr::SetContentPath(PTSTR pszNewPath)
{
    IE5_REGISTRYSET ie5rs;
    DWORD dwError;
    BOOL fLock;

    if (_coContent->LockContainer(&fLock)
        && (dwError=ie5rs.InitialiseKeys(_fProfilesCapable))==ERROR_SUCCESS)
    {
        dwError = ie5rs.UpdateContentPath(pszNewPath);
    }
    
    if (fLock)
    {
        _coContent->UnlockContainer();
    }

    if (dwError==ERROR_SUCCESS)
    {
        return TRUE;
    }
    SetLastError(dwError);
    return FALSE;
}
*/
    
/*-----------------------------------------------------------------------------
DWORD CConMgr::GetExtensibleCacheConfigInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetExtensibleCacheConfigInfo(BOOL fAlways)
{
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    CHAR szPrefixMap[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];
    CHAR szVolumeTitle[MAX_PATH];

    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];

    URL_CONTAINER* pNewContainer;
    URL_CONTAINER* co;
    MUTEX_HOLDER mh;

    DWORD idx;
    DWORD idxPrefix;
    DWORD dwNow;
    DWORD dwOptions;
    BOOL fModified;
    BOOL fCDContainer;

    REGISTRY_OBJ* pro = NULL;

    LOCK_CACHE();
    fModified = WasModified(TRUE);

    hKey = _fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    //  WasModified MUST come first, so that we update our cached count!
    if (!fModified && !fAlways)
    {
         //  Unmap every container that hasn't be referenced in UNMAP_TIME
        dwNow = GetTickCountWrap();
        if ((dwNow - _dwLastUnmap) > UNMAP_TIME)
        {
            for (idx = ConList.Size()-1; idx >= NCONTAINERS; idx--)
            {
                co = ConList.Get(idx);
                if (co)
                {
                    if (co->GetDeletePending() ||
                        ((dwNow - co->GetLastReference()) > UNMAP_TIME))
                    {
                        co->TryToUnmap(1);    //  RefCount should be 1 == Us
                    }
                    co->Release(FALSE);
                }
            }

            _dwLastUnmap = dwNow;
        }
        goto exit;
    }

    // Create registry object and entry.
    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        for (idx = NCONTAINERS; idx < ConList.Size(); idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);
            if (co)
            {
                co->Mark(FALSE);
                co->Release(FALSE);
            }
        }

        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        idx = NCONTAINERS;
        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                    // Path.
                cbKeyLen = MAX_PATH;
                DWORD dwRepair = TRUE;
                CHAR szScratch[MAX_PATH];

                roVendor.GetValue(CACHE_PATCH_VALUE, &dwRepair);

                if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                    continue;

                if (!*szScratch)
                {
                    roExtensibleCache.DeleteKey(szVendorKey);
                    continue;
                }

                if (dwRepair)
                {
                    CompressPath(szScratch, szCachePath);
                    cbKeyLen = lstrlen(szCachePath)+1;
                    roVendor.SetValue(CACHE_PATH_VALUE, szCachePath, REG_EXPAND_SZ);
                    dwRepair = FALSE;
                    roVendor.SetValue(CACHE_PATCH_VALUE, &dwRepair);
                }
                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                    
                // Prefix.
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PREFIX_VALUE, (LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                    continue;
            
                // Limit.
                if (roVendor.GetValue(CACHE_LIMIT_VALUE, &cbKBLimit) != ERROR_SUCCESS)
                    continue;    

            // Options.
                if (roVendor.GetValue(CACHE_OPTIONS_VALUE, &dwOptions) != ERROR_SUCCESS)
                    continue;
            
                if (dwOptions & INTERNET_CACHE_CONTAINER_MAP_ENABLED)
                {
                    fCDContainer = TRUE;

                    // PrefixMap
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_PREFIX_MAP_VALUE, (LPBYTE) szPrefixMap, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szPrefixMap == '\0'))
                        continue;

                    // Volume label.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_LABLE_VALUE, (LPBYTE) szVolumeLabel, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeLabel == '\0'))
                        continue;
            
                    // Volume title.
                    cbKeyLen = MAX_PATH;
                    if ((roVendor.GetValue(CACHE_VOLUME_TITLE_VALUE, (LPBYTE) szVolumeTitle, &cbKeyLen) != ERROR_SUCCESS)
                        || (*szVolumeTitle == '\0'))
                        continue;
                }
                else
                {
                    fCDContainer = FALSE;
                    *szPrefixMap = '\0';
                    dwOptions &= ~INTERNET_CACHE_CONTAINER_PREFIXMAP;
                }
    
                cbCacheLimit = ((LONGLONG) cbKBLimit) * 1024;
                
                idxPrefix = FindExtensibleContainer(szVendorKey);
                if (idxPrefix != NOT_AN_INDEX)
                {
                    co = ConList.Get(idxPrefix);

                    if (co)
                    {
                        //  what if the container has been added
                        //  with the same name but a different path, prefix, or options!
                        if (stricmp(co->GetCachePath(), szCachePath) ||
                            stricmp(co->GetCachePrefix(), szCachePrefix) ||
                            co->GetOptions() != dwOptions)
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else if (fCDContainer && stricmp(co->GetPrefixMap(), szPrefixMap))
                        {
                            idxPrefix = NOT_AN_INDEX;
                        }
                        else
                        {
                            co->Mark(TRUE);
                        }
                        co->Release(FALSE);
                    }
                }
            
                if (idxPrefix == NOT_AN_INDEX)
                {
                    // Construct either a normal container, or a CD container.
                    if (!fCDContainer)                        
                    {
                        pNewContainer = new URL_CONTAINER(szVendorKey, szCachePath, szCachePrefix,
                                            cbCacheLimit, dwOptions);
                    }
                    else
                    {
                        // We'll never run into CD containers in WinHTTP, so we'll force an error
                        // if some strange things happen which leads to this codepath
#if 0                
                        pNewContainer = new CInstCon(szVendorKey, szVolumeLabel, szVolumeTitle,
                                             szCachePath, szCachePrefix, szPrefixMap, 
                                             cbCacheLimit, dwOptions);
#endif
                        pNewContainer = NULL;
                    }
                    if (pNewContainer)
                    {
                        dwError = pNewContainer->GetStatus();
                        if (dwError!=ERROR_SUCCESS)
                        {
                            delete pNewContainer;
                            pNewContainer = NULL;
                        }
                        else
                        {
                            pNewContainer->Mark(TRUE);
                            ConList.Add(pNewContainer);
                        }
                    }
                    else
                    {
                        dwError = ERROR_NOT_ENOUGH_MEMORY;
                    }
                }
                 idx++;
            }
        }
    mh.Release();

    //  Mark every container that's no longer in the registry for pending delete
    //  Unmap every container that hasn't be referenced in UNMAP_TIME
    dwNow = GetTickCountWrap();

    idx = ConList.Size() - 1;

    while (idx >= NCONTAINERS)
    {
        co = ConList.Get(idx);
        if (co)
        {
            if (!co->GetMarked() && !co->GetDeleted())
            {
                co->SetDeletePending(TRUE);
            }
            if (co->GetDeletePending() ||
                ((dwNow - co->GetLastReference()) > UNMAP_TIME))
            {
                co->TryToUnmap(1);    //  RefCount should be 1 == Us, unless enumerator
                                      //  is still open
            }
            co->Release(FALSE);
        }
        idx--;
    }

    _dwLastUnmap = dwNow;
    }
    delete pro;
    
exit:  
    UNLOCK_CACHE();
    return dwError;
}


//
//  Mixed environment of IE4 and IE5 sharing a server causes HKCU keys to get resaved as REG_SZ incorrectly
//  so we repair it here
/*
VOID CheckCacheLocationConsistency()
{
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ if necessary
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        DWORD ValueSize;
        DWORD ValueType;

        //  speed things up a bit by checking if we don't need to do this
        if (roUserShellFolders.GetValueSizeAndType(g_szOldSubKey[i], &ValueSize, &ValueType ) != ERROR_SUCCESS 
            || ValueType != REG_SZ)
        {
            continue;
        }
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.

        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));

        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);
    }
}


VOID MakeCacheLocationsConsistent()
{
    // Delete any 5.0 cache signatures from previous installs
    REGISTRY_OBJ roHKCU(HKEY_CURRENT_USER, CACHE5_KEY);
    if (roHKCU.GetStatus()==ERROR_SUCCESS)
    {
        roHKCU.DeleteValue(CACHE_SIGNATURE_VALUE);
    }
    
    // Read user shell folders (necessary only in HKCU) and write back as REG_EXPAND_SZ
    REGISTRY_OBJ roUserShellFolders(HKEY_CURRENT_USER, USER_SHELL_FOLDER_KEY);
    if (roUserShellFolders.GetStatus()!=ERROR_SUCCESS)
    {
        return;
    }
    roUserShellFolders.DeleteValue(TEXT("Content"));

    for (int i=0; i<NCONTAINERS; i++)
    {
        TCHAR szPath[MAX_PATH];
        DWORD cc = ARRAY_ELEMENTS(szPath);
        if (roUserShellFolders.GetValue(g_szOldSubKey[i], (LPBYTE)szPath, &cc)!=ERROR_SUCCESS)
        {
            continue;
        }
        // First reconcile path to whatever it should be
        // and rename the containers accordingly.
        // i. Get rid of all the trailing content.ie5 (History.IE5)
        // ii. Get rid of any trailing Temporary Internet Files (History)
        // iii. Append Temporary Internet Files (History)

        // We want to skip this for cookies, though.

        // PROBLEM: When we have upgrade on top of 0901+, we started appending content.ie5
        // internally. Thus, files start getting misplaced. How do I work around this?

        // Idea: We append Content.ie5 to the USF path, and test for existence. If it's there,
        // then we'll use that. (We won't bother with anymore detective work. Though we could also
        // verify that the index dat there is newer than the index.dat in the parent directory.)
        TCHAR szRealPath[MAX_PATH];
        
        // Expand string
        ExpandEnvironmentStrings(szPath, szRealPath, ARRAY_ELEMENTS(szRealPath));
        DisableCacheVu(szRealPath);

        if (i!=1)
        {
        }
        
        // Contract string
        if (!NormalisePath(szRealPath, TEXT("%USERPROFILE%"), szPath, sizeof(szPath)))
        {
            NormalisePath(szRealPath, TEXT("%SystemRoot%"), szPath, sizeof(szPath));
        }
        
        // Then write it back
        roUserShellFolders.DeleteValue(g_szOldSubKey[i]);
        roUserShellFolders.SetValue(g_szOldSubKey[i], szPath, REG_EXPAND_SZ);

        // Then append Content.IE5 and move the files to this subdirectory
        // Ideally, we should rename this to an intermediate folder,
        // delete the old location (UNLESS THIS IS THE ROOT OR SYSTEM DIRECTORY),
        // and then move intermediate folder to its new location

    }

    FlushShellFolderCache();
}
*/

// External hooks -------------------------------------------------------------------------------------------------------

// -- RunOnceUrlCache -------------------------
// This code is called on reboot to clean up moving the cache.
// If the shutdown was successful, this will move only the few files that were open
// at that point; we assume that we'll move quickly enough to prevent collisions.
// The old index.dat is erased.

DWORD
WINAPI
RunOnceUrlCache( HWND hwnd, HINSTANCE hinst, PSTR pszCmd, int nCmdShow)
{
    // This will clean up the move, especially important if the move was interrupted. (Not too likely.)
    if (pszCmd && *pszCmd)
    {
        CFileMgr::DeleteCache(pszCmd);
    }
    return ERROR_SUCCESS;
}

#ifdef __URLCACHE_JUNK__      
DWORD
WINAPI
DeleteIE3Cache( HWND hwnd, HINSTANCE hinst, PSTR lpszCmd, int nCmdShow)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()==ERROR_SUCCESS)
    {
        TCHAR szTemp[MAX_PATH];
        DWORD cbLimit;
        
        // This fragment will look for a cache location, and test for its share-ability. If it is,
        // we'll use the location; otherwise, we'll use our own shared location.
        if (ie3rs.GetContentDetails(szTemp, cbLimit))
        {
            DWORD cb = lstrlen(szTemp);
            AppendSlashIfNecessary(szTemp, &cb);

            PTSTR psz = szTemp+cb-2;
            while (*psz!='\\' && psz>szTemp)
            {
                psz--;
            }
            if ((psz>szTemp) && !StrCmpNI(psz+1, TEXT("content."), ARRAY_ELEMENTS("content.")-1))
            {
                *(psz+1) = TEXT('\0');
            }
            StrCatBuff(szTemp, TEXT("cache1"), MAX_PATH);
            cb = lstrlen(szTemp) - 1;

            for (int i=0; i<4; i++)
            {
                szTemp[cb] = TEXT('1')+i;
                DeleteCachedFilesInDir(szTemp);
                RemoveDirectory(szTemp);
            }
        }
    }

    return ERROR_SUCCESS;
}

// -- Externally available apis

URLCACHEAPI
BOOL
WINAPI
SetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO pConfig,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function sets the cache configuration parameters.

Arguments:

    lpCacheConfigInfo - place holding cache configuration information to be set

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetUrlCacheConfigInfo(pConfig,dwFieldControl);
}

URLCACHEAPI
BOOL
WINAPI
GetUrlCacheConfigInfoA(
    LPCACHE_CONFIG_INFO lpCacheConfigInfo,
    IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
    DWORD dwFieldControl
    )
/*++

Routine Description:

    This function retrieves cache configuration values from globals

Arguments:

    pConfig - pointer to a location where configuration information
                  is stored on a successful return

    lpdwCacheConfigInfoBufferSize : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwFieldControl - items to get

Return Value:

    Error Code

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "GetUrlCacheConfigInfoA", "%#x, %#x, %#x",
        lpCacheConfigInfo, lpdwCacheConfigInfoBufferSize, dwFieldControl ));

    BOOL fError;
    
    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        DEBUG_ERROR(API, ERROR_WINHTTP_INTERNAL_ERROR);
        fError = FALSE;
    }
    else
    {
        fError = GlobalUrlContainers->GetUrlCacheConfigInfo(lpCacheConfigInfo,
            lpdwCacheConfigInfoBufferSize, dwFieldControl);
    }
    
    DEBUG_LEAVE_API (fError);
    return fError;
}
#endif // __URLCACHE_JUNK__      


// declared in wininet\inc\urlcache.h
BOOL GetIE5ContentPath( LPSTR szPath)
{
    BOOL retVal = FALSE;
    
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesCapable;

    if( ie5rs.InitialiseKeys(fProfilesCapable) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.SetWorkingContainer(CONTENT) != ERROR_SUCCESS)
        goto doneGetContentPath;

    if( ie5rs.GetPath( szPath) != ERROR_SUCCESS)
        goto doneGetContentPath;

    retVal = TRUE;

doneGetContentPath:
    return retVal;
}

// SHDOCVW needs to know whether profiles are enabled, to determine whether
// or not it needs to filter out user names. This function will help keep things simple.
// And minimise perf impact.
#ifdef UNIX
extern "C"
#endif

BOOL IsProfilesEnabled()
{
    IE5_REGISTRYSET ie5rs;
    BOOL fProfilesEnabled;

    if (ie5rs.InitialiseKeys(fProfilesEnabled) != ERROR_SUCCESS)
    {
        fProfilesEnabled = FALSE;
    }
    return fProfilesEnabled;
}

#if 0 
BOOL CConMgr::DiscoverIE4Settings(IE5_REGISTRYSET* pie5rs)
{
    IE4_REGISTRYSET ie4rs;

    CHAR szTemp[MAX_PATH+1], szPrefix[MAX_PATH+1];
    DWORD cbLimit, dwTemp;
    BOOL fPerUser, fCaughtIE4;
        
    // Try to find IE4 settings. If any paths are found, we will not look for IE3 settings
    fCaughtIE4 = FALSE;

    if (ie4rs.WasIE4Present(_fProfilesCapable))
    {
        if (ie4rs.InitialiseKeys(_fProfilesCapable)!=ERROR_SUCCESS)
        {
           LOG_UPGRADE_DATA("IE4 initialisation failed...\n");
           return FALSE;
        }

        for (dwTemp=0;dwTemp < NCONTAINERS; dwTemp++)
        {
            ie4rs.SetWorkingContainer(dwTemp);
            if (ie4rs.GetPath(szTemp)!=ERROR_SUCCESS)
            {
                continue;
            }
            LOG_UPGRADE_DATA("DIE4Settings: ");
            LOG_UPGRADE_DATA(szTemp);
            LOG_UPGRADE_DATA("\n");
            DisableCacheVu(szTemp);

            pie5rs->SetWorkingContainer(dwTemp);

            // Because SHGetFolderPath uses shell folders to determine where the items are, we have to accomodate this
            // on no-profiles machines. 
            if (!_fProfilesCapable)
            {
                pie5rs->SetPath(szTemp);
            }
            else if (dwTemp==CONTENT)
            {
#ifndef UNIX
                if (ie4rs.GetPerUserStatus() || GlobalPlatformVersion5)
#else
                if (ie4rs.GetPerUserStatus() || GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
                {
                // If it's NT5, we want to go to a per-user, non-roaming location
                // which is the NT5 default anyway
                    LOG_UPGRADE_DATA("DIE4Settings: If NT5, ignore shared cache. Else this isn't shared anyway.");
                    pie5rs->SetPerUserStatus(TRUE);
                }
                else
                {
                // Because IE4 locates a shared cache differently from IE5, we need to
                // save the path and status.
                    LOG_UPGRADE_DATA("DIE4Settings: Will try to use shared cache");
                    pie5rs->AttemptToUseSharedCache(szTemp, 0);
                }
            }
        
            fCaughtIE4 = TRUE;

            // We don't need to check return values since we come up with
            // reasonable values on our own.
            ie4rs.GetLimit(szTemp, cbLimit);
            pie5rs->SetLimit(szTemp, cbLimit);

            ie4rs.GetPrefix(szPrefix);
            pie5rs->SetPrefix(szPrefix);
        }
    }
    if (!fCaughtIE4)
    {
        LOG_UPGRADE_DATA("No IE4 settings...\n");
    }
    else
    {
        FlushShellFolderCache();
    }
    return fCaughtIE4;
}

VOID CConMgr::DiscoverIE3Settings(IE5_REGISTRYSET* pie5rs)
{
    IE3_REGISTRYSET ie3rs;
   
    if (ie3rs.InitialiseKeys()!=ERROR_SUCCESS)
    {
        return;
    }

    TCHAR szTemp[MAX_PATH];
    DWORD cbLimit;
    
    // This fragment will look for a cache location, and test for its share-ability. If it is,
    // we'll use the location; otherwise, we'll use our own shared location.
    if (ie3rs.GetContentDetails(szTemp, cbLimit))
    {
        DeleteCachedFilesInDir(szTemp);
       // No IE4. Steal IE3's settings? We only care about content cache.
       // Is that a good idea? There's no UI for modifying the cookies/history path; 
       // if someone plumbs into the registry, do we want to support that? *sigh*
       // BUG? We're moving the cache one level deeper. We probably want to be a
       // bit more intelligent about this.
        CleanPath(szTemp);
        pie5rs->AttemptToUseSharedCache(szTemp, cbLimit);
    }

    // This fragment deletes the shared history. It should happen ONLY ONCE.
    DWORD cbKeyLen = ARRAY_ELEMENTS(szTemp);
    REGISTRY_OBJ roHist(HKEY_LOCAL_MACHINE, IE3_HISTORY_PATH_KEY);
    if ((roHist.GetStatus()==ERROR_SUCCESS)
        &&
        (roHist.GetValue(NULL,(LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
    {
        REGISTRY_OBJ roUrlHist(HKEY_LOCAL_MACHINE, szTemp);
        cbKeyLen = ARRAY_ELEMENTS(szTemp);
        if ((roUrlHist.GetStatus()==ERROR_SUCCESS)
            &&
            (roUrlHist.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szTemp, &cbKeyLen)==ERROR_SUCCESS))
        {
            DeleteCachedFilesInDir(szTemp);
        }
    }
}


// Logic for determining the location of the cache -------------------------------------------------------------

// PROFILES ENABLED --------------------------
// [on logon]
// If profiles are enabled, look in HKCU/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature. 
// If a signature is present, [carry on]
// Look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is not present, jump to [over IE4 install]
// For history and cookies, the containers will be located in the profiles directory
// For content, 
//      if it's marked per user, 
//          and there isn't a shell folder/user shell folder value, construct and put it in
//      otherwise feed the HKLM shared location into (user) shell folder.
// Insert signature and [carry on].

// [over IE4 install]
// If a signature is not present in HKCU/Software/Microsoft/Windows/Internet Settings/Cache,
//      jump to [over IE3 install]
// Determine if the content cache is per-user or not.

// [over IE3 install]
// For history and cookies, the containers will be located in the profiles directory
// Examine HKLM/Software/Microsoft/Windows/Internet Settings/Cache/Paths
// If not present, go to [clean install]
// If the cache path is located in a user's profiles directory, ignore and [clean install]
// Otherwise, adopt the values and [carry on]

// [clean install]
// Set up history/cookies to be per user.
// Set up the content cache to be shared.
// Write in default values.

// PROFILES NOT ENABLED --------------------------

// * If profiles are _not_ enabled, we'll look in HKLM/Software/Microsoft/Windows/Internet Settings/5.0/Cache
//      for a signature.
// If a signature is present, go ahead and gather information for the paths

// [carry on]
// Get info from the registry, and create the container


// -- DiscoverAnyIE5Settings
// We're going to call this function if we haven't any IE4 settings to upgrade,
// but _before_ we check for IE3,
BOOL CConMgr::DiscoverAnyIE5Settings(IE5_REGISTRYSET* pie5rs)
{
    // Let's consider the following scenario:
    // User A logs on to the machine with IE4 installed; installs IE5, and then shuts down
    // the machine. User B comes along, but IE5 hasn't been installed yet. If User B has 
    // admin privileges, install will continue, BUT still not have any IE4/5 settings.
    // Which resulted in skipping DiscoverIE4Settings. However, we don't want to look
    // at IE3's settings.

    // If we're installing over IE4/2/5, but we don't have any settings for this user, 
    // we must avoid an IE3 upgrade. Instead, short circuit to use last-minute info-gathering
    // For IE3, use a shared cache
    DWORD dwVer = GetIEVersion();
    
    // We're going to use a shared cache for IE3 and Win9x users.
    // Upgrading over IE4 and 5 -- for users who have logged in before,
    // their signatures shoudl be in place already. In those cases, we shouldn't
    // be in this function anyway. For other users, we'll use the shared cache.
    // This is the first time for the machine.
    if ((dwVer==3) && pie5rs->IsFirstTimeForMachine())
    {
        return FALSE;
    }

    pie5rs->AttemptToUseSharedCache(NULL, 0);
    return TRUE;
}


VOID CConMgr::DiscoverRegistrySettings(IE5_REGISTRYSET* pie5rs)
{
    LOG_UPGRADE_DATA("Attempting to discover IE4 settings...\n");

    if (DiscoverIE4Settings(pie5rs))
    {
        goto exit;
    }


#ifndef UNIX
    if (GlobalPlatformType == PLATFORM_TYPE_WINNT)
#else
    if (GlobalPlatformType == PLATFORM_TYPE_UNIX)
#endif /* UNIX */
    {
        LOG_UPGRADE_DATA("This is NT. Fuhgedabout IE3 et al settings...\n");

        // This will override NT's default behaviour to use per-user containers.
        pie5rs->SetWorkingContainer(CONTENT);
        if (!pie5rs->GetPerUserStatus())
        {
            pie5rs->AttemptToUseSharedCache(NULL, 0);
        }

        // Suppose this is an install over NT. Each user should get a per-user, non-roaming
        // path by default. The values we'd pick up from SHFolderGetPath will be okay; but, we need to make
        // sure that we treat this as a per-user container.

        // Suppose we upgraded from some previous version of Win9x to NT5. There are eight scenarios:
        // nothing                  : in which case, we do as above
        // IE3                      : same; need to delete old cache
        // IE4 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : same as fresh install
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path
        // IE5 -- single-user machine:same as fresh install; need to delete old cache.
        //     -- shared cache      : preserve shared path
        //     -- per user cache    : preserve path
        //     -- moved cache       : preserve path

        // If an admin wants to use a shared cache under NT5, s/he will have to set
        // HKCU/Shell Folders and User Shell Folders to point to the common path
        // AND {HKCU|HKLM}/blah/PerUserItem to 0 (or delete the HKCU value).
        if ((GetIEVersion()==3) && pie5rs->IsFirstTimeForMachine())
        {
            IE3_REGISTRYSET ie3rs;
            TCHAR szTemp[MAX_PATH];
            DWORD cbLimit;
            if ((ie3rs.InitialiseKeys()==ERROR_SUCCESS)
                &&
                (ie3rs.GetContentDetails(szTemp, cbLimit)))
            {
                DeleteCachedFilesInDir(szTemp);
            }
        }
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE5 settings...\n");
    if (DiscoverAnyIE5Settings(pie5rs))
    {
        goto exit;
    }

    LOG_UPGRADE_DATA("Attempting to discover any IE3 settings...\n");
    DiscoverIE3Settings(pie5rs);

exit:
    LOG_UPGRADE_DATA("Flushing shell folders cache...\n");
    pie5rs->SetIfFirstTime();
    FlushShellFolderCache();
}

#endif


// -- CleanPath
// Given a path, strip away any trailing content.ie5's, and if necessary, add a trailing brand mark,
// i.e. "Temporary Internet Files" or localised version.

VOID CleanPath(PTSTR pszPath)
{
    DWORD ccPath = strlen(pszPath);
    PTSTR pszLastSep = pszPath + ccPath;

    // Now we're at the null terminator, but if the last character is also a separator, we want
    // to skip that too.
    if (*(pszLastSep-1)==DIR_SEPARATOR_CHAR)
    {
        pszLastSep--;
    }
    BOOL fSlash;
    // Strip away any "content.ie5"'s from the path
    for (;(fSlash = ScanToLastSeparator(pszPath, &pszLastSep));)
    {
        if (StrCmpNI((pszLastSep+1), TEXT("content.ie"), ARRAY_ELEMENTS(TEXT("content.ie"))-1))
        {
            break;
        }
        *pszLastSep = '\0';
    }

    // Load temp int files
    TCHAR szBrand[MAX_PATH];
    DWORD ccBrand = 0;

#if 0
    ccBrand = LoadString(GlobalDllHandle, g_dwCachePathResourceID[CONTENT], szBrand, ARRAY_ELEMENTS(szBrand));
#endif
    memcpy(szBrand, g_dwCachePathResourceID[CONTENT], 
            strlen(g_dwCachePathResourceID[CONTENT]) + 1);

    // The following fragment should never happen, but just in case...
    if (!ccBrand)
    {
        ccBrand = sizeof(TEXT("Temporary Internet Files"));
        memcpy(szBrand, TEXT("Temporary Internet Files"), ccBrand);
        ccBrand /= sizeof(TCHAR);
        ccBrand--;
    }
    
    // If "Temporary Internet Files" doesn't trail the path, add it.
    if (!fSlash)
    {
        *pszLastSep++ = DIR_SEPARATOR_CHAR;
        *pszLastSep = '\0';
    }
    else
    {
        pszLastSep++;
    }
    if (StrCmpNI((pszLastSep), szBrand, ccBrand))
    {
        while (*pszLastSep && *pszLastSep!=DIR_SEPARATOR_CHAR)
        {
            pszLastSep++;
        }
        if (!*pszLastSep && (*(pszLastSep-1)!=DIR_SEPARATOR_CHAR))
        {
            *pszLastSep = DIR_SEPARATOR_CHAR;
            pszLastSep++;
        }
        else if (*pszLastSep)
        {
            pszLastSep++;
        }
        memcpy(pszLastSep, szBrand, ccBrand*sizeof(TCHAR));
    }
    *(pszLastSep+ccBrand)='\0';
}

/*
DWORD GetIEVersion()
{
    DWORD dwVer = 0;

    REGISTRY_OBJ roVersion(HKEY_LOCAL_MACHINE, OLD_VERSION_KEY);
    TCHAR szKey[MAX_PATH];
    DWORD cb = ARRAY_ELEMENTS(szKey);

    if ((roVersion.GetStatus()!=ERROR_SUCCESS)
        ||
        (roVersion.GetValue(OLD_VERSION_VALUE, (LPBYTE)szKey, &cb)!=ERROR_SUCCESS))
    {
        // This should never happen during a proper setup.
        // In case it does, however, we'll just use construct IE5's default settings.
        return 0;
    }

    PTSTR psz = szKey;
    PTSTR pszFirst = szKey;
    // Get the major version number
    while (*psz!='.')
    {
        psz++;
    }
    *psz = '\0';
    dwVer = (DWORD)StrToInt(pszFirst);

    if (dwVer==4)
    {
        psz++;
        // Skip the second number
        while (*psz!='.')
        {
            psz++;
        }
        pszFirst = psz;
        psz++;
        while (*psz!='.')
        {
            psz++;
        }
        *psz = '\0';
        dwVer = ((DWORD)StrToInt(pszFirst))==0 ? 3 : 4;
    }

    return dwVer;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachedef.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains data definitions for cache code.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _CACHEDEF_
#define _CACHEDEF_

//
// C++ inline code definition for retail build only.
//

#if DBG
#undef CHECKLOCK_NORMAL
#undef CHECKLOCK_PARANOID
#define INLINE
#else
#define INLINE      inline
#endif

#define PAGE_SIZE                        4096            // Grow memory mapped file by 1 page.
#define ALLOC_PAGES                      4               // was 2
#define HEADER_ENTRY_SIZE                ALLOC_PAGES * PAGE_SIZE
#define NORMAL_ENTRY_SIZE                128

#define DEFAULT_CLEANUP_FACTOR           10  // % free goal once cache quota exceeded
#define MAX_EXEMPT_PERCENTAGE            70

#define MEMMAP_FILE_NAME                 TEXT("index.dat")
#define DESKTOPINI_FILE_NAME             TEXT("desktop.ini")

#define DEFAULT_FILE_EXTENSION           ""

// Cache configuration and signature.
#define CACHE_SIGNATURE_VALUE           TEXT("Signature")
#define CACHE_SIGNATURE                 TEXT("Client UrlCache MMF Ver 5.2")
#define NUM_HEADER_DATA_DWORDS          (CACHE_HEADER_DATA_LAST + 1)
#define MAX_SIG_SIZE                     (sizeof(CACHE_SIGNATURE) / sizeof(TCHAR))

// The following values parametrize the schema for URL entries.
#define ENTRY_COPYSIZE_IE5    \
    (sizeof(IE5_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE5               0
#define ENTRY_COPYSIZE_IE6    \
    (sizeof(IE6_URL_FILEMAP_ENTRY) - sizeof(FILEMAP_ENTRY))
#define ENTRY_VERSION_IE6               0x10

#define ENTRY_COPYSIZE_CURRENT          ENTRY_COPYSIZE_IE6
#define ENTRY_VERSION_CURRENT           ENTRY_VERSION_IE6

// If IE5-IE? sees an entry with low bits of version set, it will be placed
// on async fixup list rather than being destroyed.
#define ENTRY_VERSION_NONCOMPAT_MASK    0x0F


// Roundup
#define ROUNDUPTOPOWEROF2(bytesize, powerof2) (((bytesize) + (powerof2) - 1) & ~((powerof2) - 1))
#define ROUNDUPBLOCKS(bytesize) ((bytesize + NORMAL_ENTRY_SIZE-1) & ~(NORMAL_ENTRY_SIZE-1))
#define ROUNDUPDWORD(bytesize) ((bytesize + sizeof(DWORD)-1) & ~(sizeof(DWORD)-1))
#define ROUNDUPPAGE(bytesize) ((bytesize + PAGE_SIZE-1) & ~(PAGE_SIZE-1))
#define NUMBLOCKS(bytesize) (bytesize / NORMAL_ENTRY_SIZE)

// Power of 2 macros
#define ISPOWEROF2(val) (!((val) & ((val)-1)))
#define ASSERT_ISPOWEROF2(val) INET_ASSERT(ISPOWEROF2(val))

#define URL_CACHE_VERSION_NUM  sizeof(CACHE_ENTRY_INFO);

// Default profiles directory under %SystemRoot%.
#define DEFAULT_PROFILES_DIRECTORY TEXT("Profiles")


//
// Registry key and value names for persistent URL management.
//

// BUGBUG - wasting space. 

#define MS_BASE TEXT("Software\\Microsoft")

#define CV_BASE MS_BASE TEXT("\\Windows\\CurrentVersion")

#define EX_BASE TEXT("\\Explorer")

#define IS_BASE TEXT("\\Internet Settings")

#define CACHE_T TEXT("\\Cache")

#define SHELL_FOLDER_KEY        CV_BASE EX_BASE TEXT("\\Shell Folders")
#define USER_SHELL_FOLDER_KEY   CV_BASE EX_BASE TEXT("\\User Shell Folders")
#define CACHE5_KEY              CV_BASE IS_BASE TEXT("\\5.0") CACHE_T
#define IDENTITIES_KEY          CV_BASE IS_BASE TEXT("\\5.0\\Identities") 
#define OLD_CACHE_KEY           CV_BASE IS_BASE CACHE_T
#define CACHE_PATHS_FULL_KEY    CV_BASE IS_BASE CACHE_T TEXT("\\Paths")
#define RUN_ONCE_KEY            CV_BASE TEXT("\\RunOnce")
#define PROFILELESS_USF_KEY     TEXT(".Default\\") USER_SHELL_FOLDER_KEY
#define CONTENT_CACHE_HARD_NAME TEXT("Content.IE5")
#define OLD_VERSION_KEY         MS_BASE TEXT("\\IE Setup\\SETUP")
#define OLD_VERSION_VALUE       TEXT("UpgradeFromIESysFile")

// from wininet\inetui\inetui.rc
#define IDS_CACHE_DEFAULT_SUBDIR "Temporary Internet Files"
#define IDS_COOKIES_DEFAULT_SUBDIR "Cookies"
#define IDS_HISTORY_DEFAULT_SUBDIR "History"
#define IDS_CACHE_DEFAULT_SUBDIR_UNIX "TempInternetFiles"

//
// Cache parameters
//
#ifndef unix
#define PATH_CONNECT_STRING                    TEXT("\\")
#define PATH_CONNECT_CHAR                      TEXT('\\')
#define ALLFILES_WILDCARD_STRING               TEXT("*.*")
#define UNIX_RETURN_IF_READONLY_CACHE 
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) 
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar)
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName)
#else
#define PATH_CONNECT_STRING                    TEXT("/")
#define PATH_CONNECT_CHAR                      TEXT('/')
#define ALLFILES_WILDCARD_STRING               TEXT("*")
#define UNIX_RETURN_IF_READONLY_CACHE   {                        \
                                           if (g_ReadOnlyCaches) \
                                              return;            \
                                        }
#define UNIX_RETURN_ERR_IF_READONLY_CACHE(error) {                      \
                                                   if (g_ReadOnlyCaches)\
                                                      return (error);   \
                                               }
#define UNIX_NORMALIZE_PATH_ALWAYS(szOrigPath, szEnvVar) \
                                        UnixNormalisePath(szOrigPath, szEnvVar);
#define UNIX_NORMALIZE_IF_CACHE_PATH(szOrigPath, szEnvVar, szKeyName) \
                      UnixNormaliseIfCachePath(szOrigPath, szEnvVar, szKeyName);

#define UNIX_SHARED_CACHE_PATH TEXT("%HOME%/.microsoft")
#endif /* !unix */

#define CACHE_PERSISTENT                TEXT("Persistent")

// Retrieval methods
#define RETRIEVE_WITHOUT_CHECKS     0
#define RETRIEVE_WITH_CHECKS        1
#define RETRIEVE_WITH_ALLOCATION    2
#define RETRIEVE_ONLY_FILENAME      4
#define RETRIEVE_ONLY_STRUCT_INFO   8
//
// Multiple URL containters can be configured under the above key such
// as :
//
//  Cache\Paths\Path1
//  Cache\Paths\Path2
//    ...
//
// Each containter will have the following two parameters.
//

// CConMgr related defines.
#define CACHE_PATHS_KEY                 TEXT("Paths")
#define CACHE_PATH_VALUE                TEXT("CachePath")
#define CACHE_PATH_VALUE_TYPE           REG_SZ
#define CACHE_LIMIT_VALUE               TEXT("CacheLimit")
#define CACHE_LIMIT_VALUE_TYPE          REG_DWORD
#define CACHE_OPTIONS_VALUE             TEXT("CacheOptions")
#define CACHE_OPTIONS_VALUE_TYPE        REG_DWORD
#define CACHE_PATCH_VALUE               TEXT("CacheRepair")
#define CACHE_PATCH_VALUE_TYPE          REG_DWORD

#define EXTENSIBLE_CACHE_PATH_KEY       "Extensible Cache"
#define CONTENT_PATH_KEY                "Content"
#define COOKIE_PATH_KEY                 "Cookies"
#define HISTORY_PATH_KEY                "History"
#define URL_HISTORY_KEY                 "Url History"

#define PER_USER_KEY                    "PerUserItem"
#define PROFILES_ENABLED_VALUE          "Network\\Logon"
#define PROFILES_ENABLED                "UserProfiles"
#define PROFILES_PATH_VALUE             CV_BASE "\\ProfileList"
#define PROFILES_PATH                   "ProfileImagePath"

#define CONTENT_PREFIX                  ""
#define COOKIE_PREFIX                   "Cookie:"
#define HISTORY_PREFIX                  "Visited:" 

#define CONTENT_VERSION_SUBDIR          "Content.IE5"
#define IE3_COOKIES_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\Cookies")
#define IE3_HISTORY_PATH_KEY            OLD_CACHE_KEY TEXT("\\Special Paths\\History")
#define IE3_PATCHED_USER_KEY            TEXT("Patched User")
#define CACHE_SPECIAL_PATHS_KEY         TEXT("Special Paths")
#define CACHE_DIRECTORY_VALUE           TEXT("Directory")
#define CACHE_DIRECTORY_TYPE            REG_EXPAND_SZ
#define CACHE_NEWDIR_VALUE              TEXT("NewDirectory")
#define CACHE_NEWDIR_TYPE               REG_EXPAND_SZ
#define CACHE_PREFIX_VALUE	            TEXT("CachePrefix")
#define CACHE_PREFIX_MAP_VALUE          "PrefixMap"
#define CACHE_VOLUME_LABLE_VALUE        "VolumeLabel"
#define CACHE_VOLUME_TITLE_VALUE        "VolumeTitle"
#define CACHE_PREFIX_TYPE               REG_SZ
#define NEW_DIR                         TEXT("NewDirectory")
#define USER_PROFILE_SZ                 "%USERPROFILE%"
#define USER_PROFILE_LEN                (sizeof(USER_PROFILE_SZ) - 1)

// URL_CONTAINER related defines.
#define DEF_NUM_PATHS                   4
#define DEF_CACHE_LIMIT                 (2048 * DEF_NUM_PATHS)
#define NO_SPECIAL_CONTAINER            0xffffffff
#define MAX_ENTRY_SIZE                  0xFFFF
#define LONGLONG_TO_FILETIME( _p_ )     ((FILETIME *)(_p_))

// Content limit defines.
#define OLD_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      64
#define NEW_CONTENT_QUOTA_DEFAULT_DISK_FRACTION      32
#define CONTENT_QUOTA_ADJUST_CHECK                   "QuotaAdjustCheck"

// CD Container related defines.
#define INTERNET_CACHE_CONTAINER_PREFIXMAP INTERNET_CACHE_CONTAINER_RESERVED1
#define MAX_FILE_SIZE_TO_MIGRATE  50000
#define MAX_EXTENSION_LEN        3


// FileMgr related defines.
#define DEFAULT_DIR_TABLE_GROW_SIZE     4
#define DEFAULT_MAX_DIRS                32
#define MAX_FILES_PER_CACHE_DIRECTORY   1024
#define MAX_COLLISSION_ATTEMPTS         150
#define INSTALLED_DIRECTORY_KEY         0xFF
#define NOT_A_CACHE_SUBDIRECTORY        0XFE

#ifdef CHECKLOCK_PARANOID
void CheckEnterCritical(CRITICAL_SECTION *_cs);
void CheckLeaveCritical(CRITICAL_SECTION *_cs);
#define ENTERCRITICAL CheckEnterCritical
#define LEAVECRITICAL CheckLeaveCritical
#else
#define ENTERCRITICAL EnterCriticalSection
#define LEAVECRITICAL LeaveCriticalSection
#endif

// Cache global variable lock -- this should not be entered while holding
// lower-level locks like URL_CONTAINER::LockContainer cross-process mutex.
#define LOCK_CACHE()                    ENTERCRITICAL( &GlobalCacheCritSect )
#define UNLOCK_CACHE()                  LEAVECRITICAL( &GlobalCacheCritSect )

//
// parameter check macros.
//

#define IsBadUrl( _x_ )               IsBadStringPtrA( _x_, (DWORD) -1)
#define IsBadUrlW( _x_ )              IsBadStringPtrW( _x_, (DWORD) -1)
#define IsBadReadFileName( _x_ )      IsBadStringPtr( _x_, MAX_PATH )
#define IsBadWriteFileName( _x_ )     IsBadWritePtr( (PVOID)_x_, MAX_PATH)
#define IsBadWriteBoolPtr( _x_ )      IsBadWritePtr( _x_, sizeof(BOOL))
#define IsBadReadUrlInfo( _x_ )       IsBadReadPtr( _x_, sizeof(CACHE_ENTRY_INFO))
#define IsBadWriteUrlInfo( _x_, _y_ ) IsBadWritePtr( _x_, _y_ )

#define MAX_URL_ENTRIES                 (BIT_MAP_ARRAY_SIZE * sizeof(DWORD) * 8)

#define OFFSET_TO_POINTER( _ep_, _offset_) \
    (LPVOID)((LPBYTE)(_ep_) + (_offset_))


#define FIND_FLAGS_OLD_SEMANTICS                0x1
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2
#define FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME 0x04

//---------------- BUGBUG : for History Only -------------------------------
#define MAX_FILETIME   0x7fffffffffffffff
#define MAX_DOSTIME    -1
//---------------- END BUGBUG ----------------------------------------------


//
// ----------------- Allocation entry header -----------------------------//
//

#define SIG_FREE   0xbadf00d
#define SIG_ALLOC  0xdeadbeef

#define SIG_URL         ' LRU'   // URL_FILEMAP_ENTRY
#define SIG_REDIR       'RDER'   // REDR_FILEMAP_ENTRY
#define SIG_LEAK        'KAEL'   // URL_FILEMAP_ENTRY
#define SIG_GLIST       'GLST'   // LIST_GROUP_ENTRY

// signatures for entries placed on fixup list
#define SIG_UPDATE      ' DPU'   // URL_FILEMAP_ENTRY
#define SIG_DELETE      ' LED'   // URL_FILEMAP_ENTRY

enum MemMapStatus
{
    MEMMAP_STATUS_OPENED_EXISTING = 0,
    MEMMAP_STATUS_REINITIALIZED = 1
};

typedef struct FILEMAP_ENTRY
{
    DWORD dwSig;
    DWORD nBlocks;
}
    *LPFILEMAP_ENTRY;

struct LIST_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwNext; // offset to next element in list
    DWORD nBlock; // sequence number for this block
};

//
// URL entry
//

struct IE5_URL_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    LONGLONG LastModifiedTime;       // must be LONGLONG
    LONGLONG LastAccessedTime;       // should be DWORD
    DWORD    dostExpireTime;
    DWORD    dostPostCheckTime;

    DWORD    dwFileSize;
    DWORD    dwRedirHashItemOffset;  // ask DanpoZ

    DWORD    dwGroupOffset;

    union
    {
        DWORD  dwExemptDelta;   // for SIG_URL
        DWORD  dwNextLeak;      // for SIG_LEAK
    };
    
    DWORD    CopySize;               // should be WORD
    DWORD    UrlNameOffset;          // should be WORD
    
    BYTE     DirIndex;           // subdirectory bucket
    BYTE     bSyncState;         // automatic sync mode state
    BYTE     bVerCreate;         // cache version that created this entry
    BYTE     bVerUpdate;         // cache version last updated this entry (unused)
        
    DWORD    InternalFileNameOffset; // should be WORD
    DWORD    CacheEntryType;
    DWORD    HeaderInfoOffset;       // should be WORD
    DWORD    HeaderInfoSize;         // should be WORD
    DWORD    FileExtensionOffset;    // should be WORD
    DWORD    dostLastSyncTime;       
    DWORD    NumAccessed;            // should be WORD
    DWORD    NumReferences;          // should be WORD
    DWORD    dostFileCreationTime;   // should be LONGLONG?

// Do not extend this structure; use inheritance instead.
};

struct IE6_URL_FILEMAP_ENTRY : IE5_URL_FILEMAP_ENTRY 
{
    DWORD   dwIdentity;

    DWORD GetIdentity()
    {
        return (bVerCreate>=ENTRY_VERSION_IE6) ? dwIdentity : 0;
    }
};

typedef IE6_URL_FILEMAP_ENTRY URL_FILEMAP_ENTRY, *LPURL_FILEMAP_ENTRY;

// FILETIME is measured in 100-ns units.
#define FILETIME_SEC    ((LONGLONG) 10000000)
#define FILETIME_DAY    (FILETIME_SEC * 60 * 60 * 24)

// Possible values for bSyncState:
#define SYNCSTATE_VOLATILE   0 // once zero, stuck at zero
#define SYNCSTATE_IMAGE      1 // eligible to increment after MIN_AGESYNC
#define SYNCSTATE_STATIC     6 // max value

// Parameters controlling transition from _IMAGE to _VOLATILE.
// #define MIN_AGESYNC  ((LONGLONG) 5 * 60 * 10000000)  // 5 min in filetime
#define MIN_AGESYNC     (FILETIME_DAY * 7)

//
// Redirect Entry
//

struct REDIR_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    DWORD dwItemOffset;  // offset to hash table item of destination URL
    DWORD dwHashValue;   // destination URL hash value (BUGBUG: collisions?)
    char  szUrl[4];      // original URL, can occupy more bytes
};

//
// Group Record
//

typedef struct GROUP_ENTRY
{
    GROUPID  gid;
    DWORD    dwGroupFlags;
    DWORD    dwGroupType;
    LONGLONG llDiskUsage;       // in Bytes (Actual Usage)
    DWORD    dwDiskQuota;       // in KB
    DWORD    dwGroupNameOffset;
    DWORD    dwGroupStorageOffset;
}
    *LPGROUP_ENTRY;


#define PAGE_SIZE_FOR_GROUPS    (PAGE_SIZE - sizeof(FILEMAP_ENTRY))
#define GROUPS_PER_PAGE         PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_ENTRY)

typedef struct _GROUP_DATA_ENTRY
{
    CHAR    szName[GROUPNAME_MAX_LENGTH];
    DWORD   dwOwnerStorage[GROUP_OWNER_STORAGE_SIZE];
    DWORD   dwOffsetNext;
} GROUP_DATA_ENTRY, *LPGROUP_DATA_ENTRY;

#define GROUPS_DATA_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(GROUP_DATA_ENTRY)

//
// so the sizeof(GROUPS_PAGE_FILEMAP_ENTRY) = PAGE_SIZE
// this is the allocation unit for groups entry
//
typedef struct _GROUPS_ALLOC_FILEMAP_ENTRY : FILEMAP_ENTRY
{
    BYTE    pGroupBlock[PAGE_SIZE_FOR_GROUPS];    
} GROUPS_ALLOC_FILEMAP_ENTRY, *LPGROUPS_ALLOC_FILEMAP_ENTRY;


typedef struct _LIST_GROUP_ENTRY 
{
    DWORD   dwGroupOffset;
    DWORD   dwNext;

} LIST_GROUP_ENTRY, *LPLIST_GROUP_ENTRY;

#define LIST_GROUPS_PER_PAGE    PAGE_SIZE_FOR_GROUPS / sizeof(LIST_GROUP_ENTRY)


#define SIGNATURE_CONTAINER_FIND 0xFAFAFAFA
#define SIG_CACHE_FIND 0XFBFBFBFB
#define SIG_GROUP_FIND 0XFCFCFCFC

typedef struct _CONTAINER_FIND_FIRST_HANDLE 
{
    DWORD dwSignature;
    DWORD dwNumContainers;
    DWORD dwContainer;
    LPSTR *ppNames;
    LPSTR *ppPrefixes;
    LPSTR *ppLabels;
    LPSTR *ppTitles;
    // DATA follows for Names, Prefixes, Volume labels and Volume titles.
} CONTAINER_FIND_FIRST_HANDLE, *LPCONTAINER_FIND_FIRST_HANDLE;

typedef struct _CACHE_FIND_FIRST_HANDLE 
{
    DWORD dwSig;
    BOOL  fFixed;
    DWORD nIdx;
    DWORD dwHandle;
    GROUPID GroupId;
    DWORD dwFilter;
    DWORD dwFlags;
} CACHE_FIND_FIRST_HANDLE, *LPCACHE_FIND_FIRST_HANDLE;

typedef struct _CACHE_STREAM_CONTEXT_HANDLE 
{
    HANDLE FileHandle;
    LPSTR SourceUrlName;
}  CACHE_STREAM_CONTEXT_HANDLE, *LPCACHE_STREAM_CONTEXT_HANDLE;

typedef struct _GROUP_FIND_FIRST_HANDLE : CACHE_FIND_FIRST_HANDLE
{
    DWORD dwLastItemOffset;
} GROUP_FIND_FIRST_HANDLE, *LPGROUP_FIND_FIRST_HANDLE;

#define OFFSET_NO_MORE_GROUP    -1
#define GID_INDEX_TO_NEXT_PAGE	-1
#define OFFSET_TO_NEXT_PAGE     -1

#define GID_MASK            0x0fffffffffffffff
#define GID_STICKY_BIT      0x1000000000000000

#define IsStickyGroup(gid)  (gid & GID_STICKY_BIT)
#define SetStickyBit(gid)   (gid | GID_STICKY_BIT)
#define IsInvalidGroup(gid) (gid & 0xE000000000000000)

//
// RealFileSize() - given the actual filesize,
// this macro computes the approximate real space that a file takes up
// on the disk. It only takes care of rounding to the cluster size
// It doesn't take into account any per-file overhead used in the filesystem
//

#define RealFileSize(fs)  ((LONGLONG) (fs + _ClusterSizeMinusOne) & _ClusterSizeMask)

#define MUTEX_DBG_TIMEOUT   5 * 1000    // 5 secs.

#define URLCACHE_OP_SET_STICKY   1
#define URLCACHE_OP_UNSET_STICKY 2

#ifdef unix
extern BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost);
extern BOOL DeleteAtomicCacheLockFile();
extern void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar);
extern void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,LPCTSTR szKeyName);
extern int  CopyDir(const char* src_dir, const char* dest_dir);
#endif /* unix */

extern VOID FileTime2DosTime(FILETIME, DWORD*);
extern VOID DosTime2FileTime(DWORD, FILETIME*);

#endif  // _CACHEDEF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cacheapi.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cacheapi.cxx

Abstract:

    contains the URL cache mangemant APIs.

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Prefixed containers for supporting cookies and history
    2) Default init, for distributing winint without setup
    3) Crossprocess versionchecking scheme to allow all wininets
       to know about registry change

--*/

#include <wininetp.h>
#include <cache.hxx>
#include <time.h>
// #include <resource.h>	
    
URLCACHEAPI
BOOL
WINAPI
UnlockUrlCacheEntryStream(
    HANDLE hStream,
    IN DWORD dwReserved
    )
/*++

Routine Description:

    This API checks in the file that was check out as part of
    RetrieveUrlFile API.

Arguments:

    hStreamHandle : stream handle returned by a RetrieveUrlCacheEntryStream call.

    dwReserved : reserved for future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "UnlockUrlCacheEntryStream",
        "%#x, %#x", hStream, dwReserved))

    DWORD Error;


    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE *pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE *) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }
    
        
    TcpsvcsDbgAssert(pStream->SourceUrlName != NULL );

    //
    // close file handle.
    //

    CloseHandle( pStream->FileHandle );

    //
    // unlock cache file.
    //

    if(!UnlockUrlCacheEntryFile(pStream->SourceUrlName, dwReserved) )
        Error = GetLastError();
    else
        Error = ERROR_SUCCESS;

    //
    // freeup url name data buffer.
    //

    FREE_MEMORY (pStream->SourceUrlName);

    //
    // free up context structure.
    //

    LOCK_CACHE();
    HandleMgr.Free (hStream);
    UNLOCK_CACHE();

    LEAVE_CACHE_API();
}

URLCACHEAPI
BOOL
WINAPI
ReadUrlCacheEntryStream(
    IN HANDLE hStream,
    IN DWORD dwLocation,
    IN OUT LPVOID lpBuffer,
    IN OUT LPDWORD lpdwLen,
    IN DWORD Reserved
    )
/*++

Routine Description:

    This API provides a method  of reading the cached data from a stream
    which has been opened using the RetrieveUrlCacheEntryStream API.

Arguments:

    hStream : Handle that was returned by the RetrieveCacheEntryStream API.

    dwLocation  : file offset to read from.

    lpBuffer : Pointer to a buffer where the data is read.

    lpdwLen : Pointer to a DWORD location where the length of the above buffer passed in, on return it contains the actual length of the data read.

    dwReserved : For future use.

Return Value:

    Windows Error code.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "ReadUrlCacheEntryStream",
        "%#x, %d, %#x, %#x, %#x", hStream, dwLocation, lpBuffer, lpdwLen, Reserved));

    DWORD Error;

    // Map and validate handle.
    CACHE_STREAM_CONTEXT_HANDLE* pStream;
    LOCK_CACHE();
    pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map(hStream);
    UNLOCK_CACHE();
    if (!pStream)
    {
        Error = ERROR_INVALID_HANDLE;
        goto Cleanup;
    }

    TcpsvcsDbgAssert( pStream->SourceUrlName);

    // PERFPERF: should we remember position to avoid this call?
    if ((DWORD) -1L == SetFilePointer
        (pStream->FileHandle, dwLocation, NULL, FILE_BEGIN))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    if( !ReadFile
        (pStream->FileHandle, lpBuffer, *lpdwLen, lpdwLen, NULL ) )
    {
        Error = GetLastError();
        goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    LEAVE_CACHE_API();
}


URLCACHEAPI
BOOL
WINAPI
FindCloseUrlCache(
    IN HANDLE hFind
    )
/*++

Routine Description:

    This member function returns the next entry in the cache.

Arguments:

    hEnumHandle : Find First handle.

Return Value:

    Returns the find first handle. If the returned handle is NULL,
    GetLastError() returns the extended error code. It returns
    ERROR_NO_MORE_ITEMS after it returns the last entry in the cache.

--*/
{
    ENTER_CACHE_API ((DBG_API, Bool, "FindCloseUrlCache",
        "%#x", hFind));

    DWORD Error;
    
    Error = GlobalUrlContainers->FreeFindHandle(hFind);

    if (Error != ERROR_SUCCESS)
    {
        SetLastError( Error );
        DEBUG_ERROR(INET, Error);
    }
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);
    return (Error==ERROR_SUCCESS);
}


BOOL
GetCurrentSettingsVersion(LPDWORD   lpdwVer) {

    // Initialize globals
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                              lpdwVer);
}

BOOL
IncrementCurrentSettingsVersion(LPDWORD lpdwVer) {

    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(CACHE_HEADER_DATA_CURRENT_SETTINGS_VERSION, 
                                                    lpdwVer);
}


BOOL
GetUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->GetHeaderData(nIdx, lpdwData);
}

BOOL
SetUrlCacheHeaderData(IN DWORD nIdx, IN  DWORD  dwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->SetHeaderData(nIdx, dwData);
}

BOOL
IncrementUrlCacheHeaderData(IN DWORD nIdx, OUT LPDWORD lpdwData)
{
    if (!InitGlobals())
    {
        SetLastError (ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }
    return GlobalUrlContainers->IncrementHeaderData(nIdx, lpdwData);
}


BOOL
LoadUrlCacheContent(VOID)
{
    DWORD dwError;
    if (!InitGlobals())
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->LoadContent();
    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}


BOOL
GetUrlCacheContainerInfo(
    IN LPSTR lpszUrlName,
	OUT LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo,
	IN OUT LPDWORD lpdwContainerInfoBufferSize,
	IN DWORD dwOptions
)
{
    DWORD dwError;

    // Initialize globals.
    if (!InitGlobals())
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        return FALSE;
    }

    dwError = GlobalUrlContainers->GetContainerInfo(lpszUrlName,
            lpContainerInfo, lpdwContainerInfoBufferSize);

    if (dwError == ERROR_SUCCESS)
        return TRUE;
    SetLastError(dwError);
    return FALSE;
}

/*
BOOL
UpdateUrlCacheContentPath(
    IN LPSTR lpszNewPath
)
{
    ENTER_CACHE_API ((DBG_API, Bool, "UpdateUrlCacheContentPath", "%q", lpszNewPath));
    INET_ASSERT(GlobalCacheInitialized);

    BOOL fResult = GlobalUrlContainers->SetContentPath(lpszNewPath);

    DEBUG_LEAVE_API(fResult);
    return fResult;
}
*/


INTERNETAPI
GROUPID 
WINAPI
CreateUrlCacheGroup(
    IN DWORD  dwFlags,
    IN LPVOID lpReserved  // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "CreateUrlCacheGroup", "%#x, %#x", dwFlags, lpReserved));
    GROUPID gid = 0;
    DWORD   Error; 

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    Error = GlobalUrlContainers->CreateGroup(dwFlags, &gid);

Cleanup:
    if( Error != ERROR_SUCCESS )
    {
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
    }
    DEBUG_LEAVE_API(gid);    
    return gid;
}

BOOLAPI
DeleteUrlCacheGroup(
    IN  GROUPID GroupId,
    IN  DWORD   dwFlags,       // must pass 0
    IN  LPVOID  lpReserved    // must pass NULL
    )
{
    ENTER_CACHE_API ((DBG_API, Bool, "DeleteUrlCacheGroup", "%#x, %#x, %#x", GroupId, dwFlags, lpReserved));
    DWORD   Error;

    // Initialize globals
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->DeleteGroup(GroupId, dwFlags);

    LEAVE_CACHE_API();
}



URLCACHEAPI
HANDLE
WINAPI
FindFirstUrlCacheGroup(
    IN      DWORD                           dwFlags,
    IN      DWORD                           dwFilter,
    IN      LPVOID                          lpSearchCondition,
    IN      DWORD                           dwSearchCondition,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
) 
{
    ENTER_CACHE_API ((DBG_API, Handle, "FindFirstUrlCacheGroup",
        "%d, %d, %#x, %d, %#x, %#x", 
        dwFlags, dwFilter, lpSearchCondition, 
        dwSearchCondition, lpGroupId, lpReserved ));

    DWORD Error;
    HANDLE hFind = 0;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
    
    // Get the first entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, dwFlags, lpGroupId);

Cleanup:

    if( Error != ERROR_SUCCESS )
    {
        GlobalUrlContainers->FreeFindHandle(hFind);
        SetLastError(Error);
        DEBUG_ERROR(API, Error);
        hFind = NULL;
    }

    INET_ASSERT (hFind);
    DEBUG_LEAVE_API (hFind);
    return hFind;
}

URLCACHEAPI
BOOL
WINAPI
FindNextUrlCacheGroup(
    IN HANDLE                               hFind,
    OUT     GROUPID*                        lpGroupId,
    IN OUT  LPVOID                          lpReserved 
    )
{

    ENTER_CACHE_API ((DBG_API, Bool, "FindNextUrlCacheGroup",
        "%#x, %#x, %#x", hFind, lpGroupId, lpReserved ));

    DWORD Error;

    // Validate parameters.
    if( !lpGroupId )
    {
        Error =  ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }


    // Get the next entry.
    Error = GlobalUrlContainers->FindNextGroup(&hFind, 0, lpGroupId);

    LEAVE_CACHE_API();
}



BOOL
AnyFindsInProgress(DWORD ContainerID)
{
    LOCK_CACHE();
    BOOL fInProgress = HandleMgr.InUse();
    UNLOCK_CACHE();
    return fInProgress;
}


BOOL
RegisterUrlCacheNotification(
    HWND        hWnd, 
    UINT        uMsg, 
    GROUPID     gid, 
    DWORD       dwFilter, 
    DWORD       dwReserve
)
{
    DWORD Error;
    ENTER_CACHE_API ((DBG_API, Bool, "RegisterUrlCacheNotification", 
        "%#x,,%#x, %#x, %#x, %#x", hWnd, uMsg, gid, dwFilter, dwReserve));

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    Error = GlobalUrlContainers->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);

    LEAVE_CACHE_API();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\conmgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conmgr.cxx

Abstract:

    Manages list of containers (CConList)

Author:
    Adriaan Canter (adriaanc) 04-02-97

--*/
#include <wininetp.h>
#include <cache.hxx>

#define FAILSAFE_TIMEOUT (60000)

/*---------------------  Private Functions -----------------------------------*/
/*-----------------------------------------------------------------------------
DWORD CConMgr::Init
----------------------------------------------------------------------------*/
DWORD CConMgr::Init()
{
    DWORD dwError = ConfigureCache();

    if (dwError==ERROR_SUCCESS)
    {
        // Get the extensible cache config info.
        // These containers are delay-initialized.
        dwError = GetExtensibleCacheConfigInfo(TRUE);
    }
    else
    {
        INET_ASSERT(FALSE);
    }
    return dwError;

}

#ifdef CHECKLOCK_PARANOID
void CConMgr::CheckNoLocks(DWORD dwThreadId)
{
    URL_CONTAINER *co;
    DWORD idx;

    LOCK_CACHE();
    for (idx = 0; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            co->CheckNoLocks(dwThreadId);
            co->Release(FALSE);
        }
    }
    UNLOCK_CACHE();
}
#endif

/*-----------------------------------------------------------------------------
BOOL CConMgr::WasModified
----------------------------------------------------------------------------*/
BOOL CConMgr::WasModified(BOOL fUpdateMemory)
{
    DWORD dwOldCount = _dwModifiedCount;
    return dwOldCount != ReadModifiedCount(fUpdateMemory);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::ReadModifiedCount
----------------------------------------------------------------------------*/
DWORD CConMgr::ReadModifiedCount(BOOL fUpdateMemory)
{
    DWORD dwChangeCount;
    DWORD *pdwChangeCount = fUpdateMemory ? &_dwModifiedCount : &dwChangeCount;

    _coContent->GetHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                             pdwChangeCount);
    return *pdwChangeCount;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::IncrementModifiedCount
----------------------------------------------------------------------------*/
void CConMgr::IncrementModifiedCount()
{
    DWORD dwLocModified;

    _coContent->IncrementHeaderData(CACHE_HEADER_DATA_CONLIST_CHANGE_COUNT,
                                   &dwLocModified);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::InitFixedContainers
----------------------------------------------------------------------------*/
DWORD CConMgr::InitFixedContainers()
{
    DWORD idx;
    DWORD dwError = ERROR_SUCCESS;
    BOOL fInitSucceeded = TRUE;

    //  Create and init
    _hMutexExtensible = OpenMutex(SYNCHRONIZE, FALSE, TEXT("_!MSFTHISTORY!_"));
    if (_hMutexExtensible == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            _hMutexExtensible = CreateMutex(psa, FALSE, TEXT("_!MSFTHISTORY!_"));
        }
    }
    if (_hMutexExtensible == NULL)
    {
        dwError = GetLastError();
        fInitSucceeded = FALSE;
        goto exit;
    }
    _dwLastUnmap = GetTickCountWrap();

    LOCK_CACHE();
    // Containers are configured. Attempt to initialize.
    for (idx = CONTENT; idx < ConList.Size(); idx++)
    {
        URL_CONTAINER *co;

        co = ConList.Get(idx);
        if (co)
        {
            dwError = co->Init();

            // NOTE - URL_CONTAINER::Init() returns ERROR_ALREADY_EXISTS
            // only if the the existing memory mapped file has been opened
            // successfully. If the memory mapped file was created, upgraded
            // or corrupted (in both cases the mem mapped file will be reinited)
            // the return value will be ERROR_SUCCESS.

            if(dwError != ERROR_SUCCESS && dwError != ERROR_ALREADY_EXISTS)
            {
                fInitSucceeded = FALSE;
                goto unlock_exit;
            }

            // Has the container been created, upgrade or corrupted?
            if (dwError == ERROR_SUCCESS)
            {
                if(idx==CONTENT)
                {
                    // Preload the content container.
                    LoadContent();
                }
                else if (idx==COOKIE)
                {
                    CCookieLoader cl;
                    cl.LoadCookies(co);
                }
            }
            co->Release(FALSE);
        }

    }

    // Enable cachevu for CONTENT and HISTORY.
    EnableCacheVu(_coContent->GetCachePath(), CONTENT);
    EnableCacheVu(_coHistory->GetCachePath(), HISTORY);

unlock_exit:

    UNLOCK_CACHE();

exit:
    dwError = (fInitSucceeded ? ERROR_SUCCESS : ERROR_INTERNAL_ERROR);
    if (!fInitSucceeded && _hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
        _hMutexExtensible = NULL;
    }
    INET_ASSERT(dwError == ERROR_SUCCESS);
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::LoadContent()
----------------------------------------------------------------------------*/
DWORD CConMgr::LoadContent()
{
    DWORD cbFile, dwError = ERROR_FILE_NOT_FOUND;
    CHAR  szPreloadKey[MAX_PATH],
          szUrl[MAX_PATH],
          szFile[MAX_PATH];

    // Preload registry key string.
    memcpy(szPreloadKey, OLD_CACHE_KEY, sizeof(OLD_CACHE_KEY) - 1);
    szPreloadKey[sizeof(OLD_CACHE_KEY)-1] = '\\';
    memcpy(szPreloadKey + sizeof(OLD_CACHE_KEY), "Preload", sizeof("PreLoad"));

    // Construct preload registry object.
    REGISTRY_OBJ roPreload(HKEY_CURRENT_USER, szPreloadKey);
    REGISTRY_OBJ roIE5Preload;
    if (roPreload.GetStatus() != ERROR_SUCCESS)
        goto exit;

    // Get the storage directory (cdf preload) to compare against to determine if we
    // need to set EDITED_CACHE_ENTRY or not. We assume any preload entry not in the
    // store dir IS and ECE.
    DWORD cb;
    CHAR szStorePath[MAX_PATH];

    // Store dir is hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szStorePath, MAX_PATH)))
    {
        AppendSlashIfNecessary(szStorePath, &cb);
        memcpy(szStorePath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1; //cb now equals size of szStorePath.
    }


    // Enum the registry url/file values and commit them
    // to the cache.
    while (roPreload.FindNextValue(szUrl, MAX_PATH,
        (LPBYTE) szFile, &(cbFile = MAX_PATH)) == ERROR_SUCCESS)
    {
        // Strip off any file:// off the file path/name.
        CHAR* ptr = szFile;

        if (!strnicmp(ptr, "file://", sizeof("file://") - 1))
            ptr += sizeof("file://") - 1;

        AddUrlArg Args;
        memset(&Args, 0, sizeof(Args));
        Args.pszUrl      = szUrl;
        Args.pszFilePath = ptr;

        // If this is a Store entry, set the type to 0 else ECE
        if (!strnicmp(ptr, szStorePath, cb))
            Args.dwEntryType = 0;
        else
            Args.dwEntryType = EDITED_CACHE_ENTRY;

        _coContent->AddUrl(&Args);
    }


    if (roIE5Preload.WorkWith(&roPreload, "IE5Preload")!=ERROR_SUCCESS)
        goto exit;
        
    DWORD cbMaxUrl, cbMaxEntry, cbEntry;
    LPSTR pszUrl;
    URL_FILEMAP_ENTRY *pEntry;
    KEY_QUERY_INFO QueryInfo;

    if (ERROR_SUCCESS != roIE5Preload.GetKeyInfo(&QueryInfo))
        goto exit;
                
    cbMaxUrl = QueryInfo.MaxValueNameLen + 1;
    cbMaxEntry = QueryInfo.MaxValueLen + 1;
    
    pszUrl = new CHAR[cbMaxUrl];
    pEntry = (URL_FILEMAP_ENTRY*) new CHAR[cbMaxEntry];

    if (!(pszUrl && pEntry))
        goto exit;


    __try
    {
        
        while ((dwError = roIE5Preload.FindNextValue(pszUrl, cbMaxUrl,
            (LPBYTE) pEntry, &(cbEntry = cbMaxEntry))) == ERROR_SUCCESS)
        {
            FILETIME ft;
            AddUrlArg Args;
            memset(&Args, 0, sizeof(Args));

            // Url
            Args.pszUrl      = pEntry->UrlNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset) : NULL;
    
            // File path
            Args.pszFilePath = pEntry->InternalFileNameOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset) : NULL;

            // Header info
            Args.pbHeaders = pEntry->HeaderInfoOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset) : NULL;
            Args.cbHeaders = pEntry->HeaderInfoSize;

            // Last modified.
            Args.qwLastMod = pEntry->LastModifiedTime;

            // Expires time.
            DosTime2FileTime(pEntry->dostExpireTime, &ft);        
            Args.qwExpires = FT2LL(ft);

            // Post check time.
            DosTime2FileTime(pEntry->dostPostCheckTime, &ft);        
            Args.qwPostCheck = FT2LL(ft);

            // File creation time.
            DosTime2FileTime(pEntry->dostFileCreationTime, &ft);        
            Args.ftCreate = ft;
        
            // File extension.
            Args.pszFileExt = pEntry->FileExtensionOffset ? 
                (LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset) : NULL;
 
            // Entry type.
            Args.dwEntryType = pEntry->CacheEntryType;

            // File size
            Args.dwFileSize = pEntry->dwFileSize;

            // Add the url.
            _coContent->AddUrl(&Args);
        }

    } // __try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = GetLastError();
    }
    ENDEXCEPT
     
    dwError = ERROR_SUCCESS;

    if (pszUrl)
        delete pszUrl;
    if (pEntry)
        delete pEntry;
        
exit:
    return dwError;
}


/*-----------------------------------------------------------------------------
HANDLE CConMgr::FindFirstContainer
----------------------------------------------------------------------------*/
HANDLE CConMgr::FindFirstContainer(DWORD *pdwModified, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    CONTAINER_FIND_FIRST_HANDLE *pFind;
    DWORD dwContainers = 0;
    DWORD dwNames = 0;
    DWORD dwPrefixes = 0;
    DWORD dwLabels = 0;
    DWORD dwTitles = 0;
    DWORD dwTotal;
    HANDLE hFind = NULL;
    DWORD dwModified;

    GetExtensibleCacheConfigInfo(FALSE);

    LOCK_CACHE();
    dwModified = *pdwModified;
    *pdwModified = _dwModifiedCount;


    if ((CACHE_FIND_CONTAINER_RETURN_NOCHANGE & dwOptions) == 0 ||
        dwModified != *pdwModified)
    {
        for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
        {
            URL_CONTAINER *co = ConList.Get(i);
            if (co)
            {
                if (co->IsVisible())
                {
                    dwContainers++;
                    dwNames += strlen(co->GetCacheName()) + 1;
                    dwPrefixes += strlen(co->GetCachePrefix()) + 1;
                    dwLabels += strlen(co->GetVolumeLabel()) + 1;
                    dwTitles += strlen(co->GetVolumeTitle()) + 1;
                }
                co->Release(TRUE);
            }
        }

        dwTotal = sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                         dwContainers*(4 * sizeof(LPSTR)) +
                         (dwNames+dwPrefixes+dwLabels+dwTitles) * sizeof(char);

        hFind = HandleMgr.Alloc (dwTotal);
        if (hFind)
        {
            LPSTR ps;

            pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
            pFind->dwSignature = SIGNATURE_CONTAINER_FIND;
            pFind->dwContainer = 0;
            pFind->dwNumContainers = dwContainers;
            if (dwContainers)
            {
                pFind->ppNames = (LPTSTR *) (((LPBYTE) pFind) + sizeof(CONTAINER_FIND_FIRST_HANDLE));
                pFind->ppPrefixes = pFind->ppNames + dwContainers;
                pFind->ppLabels = pFind->ppPrefixes + dwContainers;
                pFind->ppTitles = pFind->ppLabels + dwContainers;
                ps = (LPSTR) (((LPBYTE) pFind) +
                                sizeof(CONTAINER_FIND_FIRST_HANDLE)+
                                dwContainers*(4 * sizeof(LPSTR)));
                dwContainers = 0;

                for (DWORD i = NCONTAINERS; i < ConList.Size(); i++)
                {
                    URL_CONTAINER *co = ConList.Get(i);
                    if (co)
                    {
                        if (co->IsVisible())
                        {
                            pFind->ppNames[dwContainers] = ps;
                            strcpy(ps, co->GetCacheName());
                            ps += strlen(co->GetCacheName()) + 1;
                            pFind->ppPrefixes[dwContainers] = ps;
                            strcpy(ps, co->GetCachePrefix());
                            ps += strlen(co->GetCachePrefix()) + 1;
                            pFind->ppLabels[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeLabel());
                            ps += strlen(co->GetVolumeLabel()) + 1;
                            pFind->ppTitles[dwContainers] = ps;
                            strcpy(ps, co->GetVolumeTitle());
                            ps += strlen(co->GetVolumeTitle()) + 1;

                            dwContainers++;
                        }
                        co->Release(TRUE);
                    }
                }

            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        dwError = ERROR_WINHTTP_NO_NEW_CONTAINERS;
    }
    UNLOCK_CACHE();

    if (hFind)
    {
        if (FindNextContainer(hFind, lpContainerInfo, lpdwContainerInfoBufferSize))
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();
    }
    if( dwError != ERROR_SUCCESS )
    {
        FreeFindHandle(hFind);
        SetLastError(dwError);
        return NULL;
    }
    return hFind;
}


/*-----------------------------------------------------------------------------
BOOL CConMgr::FindNextContainer
----------------------------------------------------------------------------*/
BOOL CConMgr::FindNextContainer(HANDLE hFind, LPINTERNET_CACHE_CONTAINER_INFOA lpContainerInfo, LPDWORD lpdwContainerInfoBufferSize)
{
    // BUGBUG - this logic is borrowed from the original cachapia.cxx.

    DWORD                    dwError;
    CONTAINER_FIND_FIRST_HANDLE* pFind;

    // Map and validate the handle.
    LOCK_CACHE();
    pFind = (CONTAINER_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
    UNLOCK_CACHE();
    if (!pFind || pFind->dwSignature != SIGNATURE_CONTAINER_FIND ||
        !lpContainerInfo ||
        *lpdwContainerInfoBufferSize < sizeof(INTERNET_CACHE_CONTAINER_INFOA))
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // Continue the enumeration.
    if (pFind->dwContainer < pFind->dwNumContainers)
    {
        DWORD cbName = strlen(pFind->ppNames[pFind->dwContainer])+1;
        DWORD cbPrefix = strlen(pFind->ppPrefixes[pFind->dwContainer])+1;
        DWORD cbLabel = strlen(pFind->ppLabels[pFind->dwContainer])+1;
        DWORD cbTitle = strlen(pFind->ppTitles[pFind->dwContainer])+1;

        DWORD cbTotal = cbName+cbPrefix+cbLabel+cbTitle+sizeof(INTERNET_CACHE_CONTAINER_INFOA);
        if (cbTotal > *lpdwContainerInfoBufferSize)
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            lpContainerInfo->lpszName = (LPSTR) (((LPBYTE) lpContainerInfo) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));
            lpContainerInfo->lpszCachePrefix = lpContainerInfo->lpszName + cbName;
            lpContainerInfo->lpszVolumeLabel = lpContainerInfo->lpszCachePrefix + cbPrefix;
            lpContainerInfo->lpszVolumeTitle = lpContainerInfo->lpszVolumeLabel + cbLabel;

            strcpy(lpContainerInfo->lpszName, pFind->ppNames[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszCachePrefix, pFind->ppPrefixes[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeLabel, pFind->ppLabels[pFind->dwContainer]);
            strcpy(lpContainerInfo->lpszVolumeTitle, pFind->ppTitles[pFind->dwContainer]);
            lpContainerInfo->dwCacheVersion = URL_CACHE_VERSION_NUM;
            pFind->dwContainer++;
            dwError = ERROR_SUCCESS;
        }
        *lpdwContainerInfoBufferSize = cbTotal;
    }
    else
    {
        dwError = ERROR_NO_MORE_ITEMS;
    }

exit:
    if (dwError != ERROR_SUCCESS)
    {
        SetLastError(dwError);
        return FALSE;
    }
    return TRUE;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetContainerInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetContainerInfo(LPSTR szUrl,
                               LPINTERNET_CACHE_CONTAINER_INFOA pCI,
                               LPDWORD pcbCI)
{
    URL_CONTAINER *co;
    DWORD dwError;

    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        DWORD cbName = strlen(co->GetCacheName()) + 1;
        DWORD cbPrefix = strlen(co->GetCachePrefix()) + 1;
        DWORD cbLabel = strlen(co->GetVolumeLabel()) + 1;
        DWORD cbTitle = strlen(co->GetVolumeTitle()) + 1;
        DWORD cbReq = cbName + cbPrefix + cbLabel + cbTitle;
        if (cbReq > *pcbCI)
        {
            *pcbCI = cbReq;
            dwError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            pCI->lpszName = (LPSTR) (((LPBYTE) pCI) +
                sizeof(INTERNET_CACHE_CONTAINER_INFOA));

            pCI->lpszCachePrefix = pCI->lpszName + cbName;
            pCI->lpszVolumeLabel = pCI->lpszName + cbName + cbPrefix;
            pCI->lpszVolumeTitle = pCI->lpszName + cbName + cbPrefix + cbLabel;

            memcpy(pCI->lpszName, co->GetCacheName(), cbName);
            memcpy(pCI->lpszCachePrefix, co->GetCachePrefix(), cbPrefix);
            memcpy(pCI->lpszVolumeLabel, co->GetVolumeLabel(), cbLabel);
            memcpy(pCI->lpszVolumeTitle, co->GetVolumeTitle(), cbTitle);
            pCI->dwCacheVersion = URL_CACHE_VERSION_NUM;

            *pcbCI = cbReq;
            dwError = ERROR_SUCCESS;
        }

        co->Release(TRUE);
    }
    else
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    UNLOCK_CACHE();

    return dwError;
}

VOID CompressPath(PTSTR pszPath, PTSTR pszScratch);

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateContainer(LPCSTR Name, LPCSTR CachePrefix, LPCSTR CachePath, DWORD KBCacheLimit, DWORD dwOptions)
{
    BOOL fInsertOk = TRUE;
    DWORD dwError = ERROR_SUCCESS;
    CHAR szVendorKey[MAX_PATH];
    CHAR szDefaultPath[MAX_PATH];
    CHAR szCachePath[MAX_PATH];
    LONGLONG CacheStartUpLimit;
    HKEY hKey;
    DWORD cbKeyLen;

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = NULL;
    MUTEX_HOLDER mh;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }
    if (!CachePath || !*CachePath)
    {
        LPSTR p = _coHistory->GetCachePath();
        int len = _coHistory->GetCachePathLen();
        int clen = lstrlen(Name);

        if (len + clen + sizeof(DIR_SEPARATOR_STRING) > sizeof(szDefaultPath)) 
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        memcpy(szDefaultPath, p, len);

        memcpy(&szDefaultPath[len], Name, clen);
        memcpy(&szDefaultPath[len + clen], DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    }
    else 
    {
        INET_ASSERT((CachePrefix && *CachePrefix));

        // For non-history containers, we need to stuff into the appropriate subcontainer
        // Assumption: Content cache never falls here.
        if (!GenerateStringWithOrdinal(CachePath, 
                                       GlobalIdentity, 
                                       szDefaultPath, 
                                       ARRAY_ELEMENTS(szDefaultPath)))
        {
            INET_ASSERT(FALSE);
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    }
    CachePath = szDefaultPath;
    
    if (KBCacheLimit == 0)
    {
        CacheStartUpLimit = _coHistory->GetCacheStartUpLimit();
        KBCacheLimit = (DWORD) (CacheStartUpLimit / 1024);
    }


    if (!CachePrefix || !*CachePrefix || !CachePath || !*CachePath)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    pro = CreateExtensiRegObj(hKey);
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }   
    {
        REGISTRY_OBJ& roExtensibleCache = *pro;
        mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

        // Get the container paths, prefixes (if any) and default limit values.
        while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
        {
            REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
            if (roVendor.GetStatus()==ERROR_SUCCESS)
            {
                // Path.
                TCHAR szScratch[MAX_PATH];
                cbKeyLen = MAX_PATH;
                if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch,&cbKeyLen) != ERROR_SUCCESS)
                    continue;

                ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL
                if (!stricmp(szVendorKey, Name) || !stricmp(CachePath, szCachePath))
                {
                    fInsertOk = FALSE;
                    break;
                }
            }
        }   

        if (fInsertOk)
        {
            REGISTRY_OBJ roNewVendor(&roExtensibleCache, (LPSTR)Name, CREATE_KEY_IF_NOT_EXISTS);
            if (roNewVendor.GetStatus() == ERROR_SUCCESS)
            {
                CHAR szScratch[MAX_PATH];
                CompressPath((LPTSTR)CachePath, szScratch);
                    // Path.
                if ((dwError = roNewVendor.SetValue(CACHE_PATH_VALUE, (LPSTR)szScratch, REG_EXPAND_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Prefix.
                if ((dwError = roNewVendor.SetValue(CACHE_PREFIX_VALUE, (LPSTR)CachePrefix, REG_SZ)) != ERROR_SUCCESS)
                    goto exit;

                    // Limit.
                if ((dwError = roNewVendor.SetValue(CACHE_LIMIT_VALUE, &KBCacheLimit)) != ERROR_SUCCESS)
                        goto exit;

                    // Options.
                if ((dwError = roNewVendor.SetValue(CACHE_OPTIONS_VALUE, &dwOptions)) != ERROR_SUCCESS)
                    goto exit;
            }
        }
        else
        {
            dwError = ERROR_ALREADY_EXISTS;
        }
    }

    if (fInsertOk)
    {
        IncrementModifiedCount();
    }

exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    if (fInsertOk)
    {
        GetExtensibleCacheConfigInfo(TRUE);
    }
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::FindExtensibleContainer
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SECTION
DWORD CConMgr::FindExtensibleContainer(LPCSTR Name)
{
    DWORD n = NOT_AN_INDEX;
    DWORD i;
    URL_CONTAINER *co;

    for (i = NCONTAINERS; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (!stricmp(Name, co->GetCacheName()) && co->IsVisible())
            {
                // Found a match
                n = i;
                co->Release(FALSE);
                break;
            }
            co->Release(FALSE);
        }
    }

    return n;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteContainer
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteContainer(LPCSTR Name, DWORD dwOptions)
{
    DWORD dwError = ERROR_SUCCESS;
    URL_CONTAINER *co = NULL;
    DWORD n = NOT_AN_INDEX;
    HKEY hKey;

    if (!Name || !*Name)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    LOCK_CACHE();
    n = FindExtensibleContainer(Name);
    if (n != NOT_AN_INDEX)
    {
        co = ConList.Get(n);

        if (co)
        {
            co->SetDeletePending(TRUE);
            //  Don't release here, hold it pending until we've updated registry
        }
    }
    UNLOCK_CACHE();

    if (n!= NOT_AN_INDEX)
    {
        hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);

        REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
        if (!pro)
        {
            dwError = ERROR_ACCESS_DENIED;
            goto exit;
        }
        
        {
            REGISTRY_OBJ& roExtensibleCache = *pro;
            MUTEX_HOLDER mh;
            mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);
            dwError = roExtensibleCache.DeleteKey((LPSTR)Name);
            mh.Release();
            IncrementModifiedCount();
        }
        delete pro;
    }

exit:
    LOCK_CACHE();
    SAFERELEASE(co, TRUE);
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteFileIfNotRegistered
----------------------------------------------------------------------------*/
BOOL CConMgr::DeleteFileIfNotRegistered(URL_CONTAINER *coDelete)
{
    BOOL fDelete = TRUE;
    BOOL fFound = FALSE;
    CHAR szCachePath[MAX_PATH];
    CHAR szCachePrefix[MAX_PATH];
    DWORD dwOptions;
    LONGLONG cbCacheLimit;

    HKEY hKey = (HKEY) INVALID_HANDLE_VALUE;
    DWORD cbKeyLen, cbKBLimit, dwError;
    CHAR szVendorKey[MAX_PATH];

    hKey = (_fProfilesCapable ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE);
    REGISTRY_OBJ* pro = CreateExtensiRegObj(hKey);
    MUTEX_HOLDER mh;
    
    if (!pro)
    {
        dwError = ERROR_ACCESS_DENIED;
        goto exit;
    }
    
    if (!WasModified(FALSE))
    {
        //  If our internal cache is up to date, it can't
        //  have been deleted unless DeletePending or Deleted
        fFound = !(coDelete->GetDeletePending()||coDelete->GetDeleted());
        if (fFound)
        {
            goto exit;
        }
        //  If not found, need to look at registry to make sure we're not
        //  deleting a path that has been reused
    }

    mh.Grab(_hMutexExtensible, FAILSAFE_TIMEOUT);

    {
    REGISTRY_OBJ& roExtensibleCache = *pro;

     // Get the container paths, prefixes.
    while (roExtensibleCache.FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
    {
        BOOL fPathMatch;
        REGISTRY_OBJ roVendor(&roExtensibleCache, szVendorKey);
        if (roVendor.GetStatus()==ERROR_SUCCESS)
        {
            // Path.
            TCHAR szScratch[MAX_PATH];
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PATH_VALUE,(LPBYTE) szScratch, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            ExpandEnvironmentStrings(szScratch, szCachePath, sizeof(szCachePath)-1); // don't count the NULL

            // Prefix.
            cbKeyLen = MAX_PATH;
            if (roVendor.GetValue(CACHE_PREFIX_VALUE,(LPBYTE) szCachePrefix, &cbKeyLen) != ERROR_SUCCESS)
                continue;

            // Options.
            if (roVendor.GetValue(CACHE_OPTIONS_VALUE,&dwOptions) != ERROR_SUCCESS)
                continue;

            fPathMatch = !stricmp(coDelete->GetCachePath(), szCachePath);
            if (!stricmp(coDelete->GetCacheName(), szVendorKey) && fPathMatch &&
                !stricmp(coDelete->GetCachePrefix(), szCachePrefix) &&
                coDelete->GetOptions() != dwOptions)
            {
                fFound = TRUE;
            }
            if (fPathMatch)
                fDelete = FALSE;
        }
    }
    }
    if (fDelete)
    {
        //  This will fail if another process still has the container mapped,
        //  that's ok.  They will check on exit if container needs to be
        //  deleted
        if (coDelete->GetOptions() & INTERNET_CACHE_CONTAINER_AUTODELETE)
        {
            CFileMgr::DeleteCache(coDelete->GetCachePath());
        }
    }
exit:
    if (pro)
    {
        delete pro;
    }
    mh.Release();
    
    return !fFound;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindIndexFromPrefix
----------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
DWORD CConMgr::FindIndexFromPrefix(LPCSTR szUrl)
{
    // Unless we find a matching prefix, CONTENT is the default.
    DWORD n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
    URL_CONTAINER *co = NULL;

    //  NOTE: if deleting a container is supported, ConList.Get(i) can
    //  return NULL, if list shrinks after getting size.
    //  NOTE: if deleting containers is supported, it is not safe to
    //  assume CONTENT if prefix is not found.  client may be trying to
    //  insert into a container that has been deleted, but once existed.
    //  proper response is to return an error.  the simplest way to do this
    //  is to insist that all Extensible cache prefixes start with an illegal
    //  URL character, EXTENSIBLE_FIRST

    GetExtensibleCacheConfigInfo(FALSE);
    for (DWORD i = COOKIE; i < ConList.Size(); i++)
    {
        co = ConList.Get(i);
        if (co)
        {
            if (co->PrefixMatch(szUrl))
            {
                // For content container, strnicmp (szUrl, "", 0) returns nonzero
                if (co->IsVisible())
                {
                    // Found a match
                    n = i;
                    if (!co->IsInitialized())
                    {
                        // Init the container. If this fails,
                        // Mark it as DELETED and return CONTENT.
                        switch (co->Init())
                        {
                        case ERROR_SUCCESS:
                        case ERROR_ALREADY_EXISTS:
                            if (!(co->GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                                EnableCacheVu(co->GetCachePath(), n);
                            break;
                        default:
                            INET_ASSERT(FALSE);
                            co->SetDeleted(TRUE);
                            n = szUrl[0]==EXTENSIBLE_FIRST ? NOT_AN_INDEX : CONTENT;
                            break;
                        }
                    }
                    co->Release(FALSE);
                    break;
                }
            }
            co->Release(FALSE);
        }
    }
    return n;
}



/*-----------------------------------------------------------------------------
BOOL CConMgr::PathPrefixMatch
----------------------------------------------------------------------------*/
BOOL CConMgr::PathPrefixMatch(LPCSTR szPath, LPCSTR szPathRef)
{
    // BUGBUG - logic borrowed from original cacheapi.cxx

    INT len;

    // TRUE if the passed in path is NULL
    if (!szPath)
        return TRUE;

    len = lstrlen(szPath);

    // TRUE if it is 0 length.
    if (!len)
        return TRUE;

    // stripout the trailing slash
    if (szPath[len-1] == DIR_SEPARATOR_CHAR)
        --len;

    // Compare paths.
    if (!strnicmp(szPath, szPathRef, len))
        if (szPathRef[len] == DIR_SEPARATOR_CHAR || szPathRef[len] == 0)
            return TRUE;

    return FALSE;
}

/*---------------------  Public Functions -----------------------------------*/

/*-----------------------------------------------------------------------------
CConMgr::CConMgr

  Default Constructor
  ----------------------------------------------------------------------------*/
CConMgr::CConMgr()
: ConList()
{
    _coContent = NULL;
    _coCookies = NULL;
    _coHistory = NULL;
    _hMutexExtensible = 0;

    // Assume this is a profiles-capable machine. Later on, we'll make sure this is
    // the case.
    _fProfilesCapable = TRUE;

    // Assume that we'll be using the regular containers, instead of the backup
    _fUsingBackupContainers = FALSE;
    _dwStatus = Init();
}


/*-----------------------------------------------------------------------------
CConMgr::~CConMgr

  Default Destructor
  ----------------------------------------------------------------------------*/
CConMgr::~CConMgr()
{
    ConList.Free();
    if (_hMutexExtensible)
    {
        CloseHandle(_hMutexExtensible);
    }
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetStatus()
----------------------------------------------------------------------------*/
DWORD CConMgr::GetStatus()
{
    return _dwStatus;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::UnlockUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::UnlockUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call UnlockUrl on the appropriate container.
        dwError = co->UnlockUrl(szUrl); // may be expensive
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteUrl(LPCSTR szUrl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    DWORD idx;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    idx = FindIndexFromPrefix(szUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call DeleteUrl on the appropriate container.
        dwError = co->DeleteUrl(szUrl); // may be expensive.
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::GetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::GetHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    return _coContent->GetHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::SetHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::SetHeaderData(DWORD nIdx, DWORD dwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->SetHeaderData(nIdx, dwData);
}

/*-----------------------------------------------------------------------------
BOOL CConMgr::IncrementHeaderData
----------------------------------------------------------------------------*/
BOOL CConMgr::IncrementHeaderData(DWORD nIdx, LPDWORD pdwData)
{
    UNIX_RETURN_ERR_IF_READONLY_CACHE(FALSE);
    return _coContent->IncrementHeaderData(nIdx, pdwData);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlGroup(
    IN LPCSTR   szUrl,
    IN DWORD    dwFlags,
    IN GROUPID  GroupId
    )
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call SetUrlInGroup on the appropriate container.
        dwError = co->SetUrlGroup
            (szUrl, dwFlags, GroupId);
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateUniqueFile
----------------------------------------------------------------------------*/
DWORD CConMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedSize,
                                       LPCSTR szFileExtension, LPTSTR szFileName,
                                       HANDLE *phfHandle,
                                       BOOL   fCreatePerUser)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);


    if (co)
    {
        UNLOCK_CACHE();
        // Call CreateUniqueFile on the appropriate container.
        dwError = co->CreateUniqueFile(szUrl, dwExpectedSize,
            szFileExtension, szFileName, phfHandle, fCreatePerUser); // expensive call
        LOCK_CACHE();

        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::AddUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::AddUrl(AddUrlArg* pArgs)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();

    DWORD idx = FindIndexFromPrefix(pArgs->pszUrl);
    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call AddUrl on the appropriate container.
        dwError = co->AddUrl(pArgs); // may be expensive
        LOCK_CACHE();

        co->Release(TRUE);

        // Update the change count for the cookies container.
        if (idx == COOKIE)
        {
            DWORD dwChange = 0;
            _coContent->IncrementHeaderData(CACHE_HEADER_DATA_COOKIE_CHANGE_COUNT, &dwChange);
        }
    }

    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::RetrieveUrl
----------------------------------------------------------------------------*/
DWORD CConMgr::RetrieveUrl( LPCSTR               szUrl,
                            LPCACHE_ENTRY_INFOA* ppCacheEntryInfo,
                            LPDWORD              pcbCacheEntryInfoBufferSize,
                            DWORD                dwLookupFlags,
                            DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);


    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call RetrieveUrl on the appropriate container.
        dwError = co->RetrieveUrl(szUrl,
                                  ppCacheEntryInfo,
                                  pcbCacheEntryInfoBufferSize,
                                  dwLookupFlags, dwRetrievalFlags); // expensive?
        LOCK_CACHE();
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInfo( LPCSTR               szUrl,
                           LPCACHE_ENTRY_INFOA*  ppCacheEntryInfo,
                           LPDWORD              pcbCacheEntryInfoBufferSize,
                           DWORD                dwLookupFlags,
                           DWORD                dwEntryFlags,
                           DWORD                dwRetrievalFlags)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call GetUrlInfo on the appropriate container.
        dwError = co->GetUrlInfo(szUrl,
                                 ppCacheEntryInfo,
                                 pcbCacheEntryInfoBufferSize,
                                 dwLookupFlags,
                                 dwEntryFlags,
                                 dwRetrievalFlags);

        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::GetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          LPDWORD              pcbCacheEntryInfoBufferSize,
                          DWORD                dwLookupFlags,
                          DWORD                dwEntryFlags)
{
    return GetUrlInfo(szUrl,
                     (pCacheEntryInfo) ? &pCacheEntryInfo : NULL,
                     pcbCacheEntryInfoBufferSize,
                     dwLookupFlags,
                     dwEntryFlags,
                     0);
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetUrlInfo
----------------------------------------------------------------------------*/
DWORD CConMgr::SetUrlInfo(LPCSTR               szUrl,
                          LPCACHE_ENTRY_INFOA  pCacheEntryInfo,
                          DWORD                dwFieldControl)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        // Call SetUrlInfo on the appropriate container.
        dwError = co->SetUrlInfo(szUrl,
                                 pCacheEntryInfo,
                                 dwFieldControl);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
    return dwError;
}

DWORD CConMgr::FreeFindHandle(HANDLE hFind)
{
    DWORD dwError = ERROR_INVALID_HANDLE;

    if (hFind)
    {
        LOCK_CACHE();

        LPCACHE_FIND_FIRST_HANDLE pFind;
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (hFind);
        if (pFind)
        {
            //  NOTHING SPECIAL TO DO FOR SIGNATURE_CONTAINER_FIND
            if (pFind->dwSig == SIG_CACHE_FIND && !pFind->fFixed)
            {
                URL_CONTAINER *co = ConList.Get(pFind->nIdx);
                if (co)
                {
                    //  It now has 2 AddRefs to balance
                    co->Release(FALSE);
                    co->Release(TRUE);
                }
            }

            HandleMgr.Free (hFind);
            dwError = ERROR_SUCCESS;
        }

        UNLOCK_CACHE();
    }
    
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextEntry
----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA*  ppInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags,
      DWORD                dwRetrievalFlags)
{
    DWORD                      idx, dwError;
    URL_CONTAINER             *co    = NULL;
    LPCACHE_FIND_FIRST_HANDLE  pFind = NULL;

    LOCK_CACHE();

    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // Allocate a handle.
        //LOCK_CACHE();
        *phFind = HandleMgr.Alloc (sizeof(CACHE_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig     = SIG_CACHE_FIND;
        pFind->dwHandle  = 0;
        pFind->dwFlags   = dwFlags;

        // Find the associated container. NULL prefix
        // results in enumeration over fixed containers.
        if (!szPrefix)
        {
            pFind->fFixed = TRUE;
            pFind->nIdx   = CONTENT;

        }
        else
        {

            idx = FindIndexFromPrefix(szPrefix);
            if (idx == NOT_AN_INDEX)
            {
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }

            // Under old semantics prefix resolving to CONTENT
            // container implies that an enumeration over all
            // the fixed containers is desired. Enumeration then
            // begins with the CONTENT container. We do not keep
            // a refcount on any fixed containers in this case.
            if (idx == CONTENT && (dwFlags & FIND_FLAGS_OLD_SEMANTICS))
            {
                pFind->fFixed = TRUE;
                pFind->nIdx   = CONTENT;
            }
            else
            {
                // Otherwise only enumeration over the found container
                // is implied. Retrieve this container. Set fFixed to FALSE.
                //  NO RELEASE: hold RefCnt until handle is closed
                co = ConList.Get(idx);

                if (co)
                {
                    pFind->fFixed   = FALSE;
                    pFind->nIdx     = idx;
                    pFind->dwHandle = co->GetInitialFindHandle();
                }
                else
                {
                    dwError = ERROR_NO_MORE_ITEMS;
                    goto exit;
                }
            }

        }
        // Set filter and group id in handle.
        pFind->dwFilter = dwFilter;
        pFind->GroupId  = GroupId;
    }
    else
    {
        // Valid handle passed in - map it.
        //LOCK_CACHE();
        pFind = (CACHE_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        //UNLOCK_CACHE();
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    // -------------------------------------------------------------------------
    // The handle is initialized or was created via a previous FindNextEntry.
    //--------------------------------------------------------------------------

    dwError = ERROR_NO_MORE_ITEMS;

    // Are we only enumerating over one container?
    if (!pFind->fFixed)
    {
        // Get the associated container.
        co = ConList.Get(pFind->nIdx);

        if (co)
        {
            // Enum on the container and release.
            dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
            co->Release(TRUE);
        }
        else
        {
            // Getting container failed.
            dwError = ERROR_NO_MORE_ITEMS;
            goto exit;
        }

    }
    else
    {
        // fFixed is TRUE - enumerate over the fixed containers.
        while (pFind->nIdx < NCONTAINERS)
        {
            // Get the associated container.
            co = ConList.Get(pFind->nIdx);

            if (co)
            {
                // Get the initial hash find handle if not already done so.
                if (!pFind->dwHandle)
                    pFind->dwHandle = co->GetInitialFindHandle();

                // Enum on the container and release.
                dwError = co->FindNextEntry(&pFind->dwHandle, ppInfo, pcbInfo, pFind->dwFilter, pFind->GroupId, pFind->dwFlags, dwRetrievalFlags);
                co->Release(TRUE);

                // Goto exit only if ERROR_NO_MORE_ITEMS.
                // This handles ERROR_SUCCESS correctly.
                if (dwError != ERROR_NO_MORE_ITEMS)
                    goto exit;

                // ERROR_NO_MORE_ITEMS: Go to next container
                // and begin enum anew.
                pFind->nIdx++;
                pFind->dwHandle = 0;
            }
            else
            {
                // Getting container failed.
                dwError = ERROR_NO_MORE_ITEMS;
                goto exit;
            }
        }
    }

exit:

    UNLOCK_CACHE();

    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

DWORD CConMgr::FindNextEntry(
      HANDLE              *phFind,
      LPCSTR               szPrefix,
      LPCACHE_ENTRY_INFOA  pInfo,
      LPDWORD              pcbInfo,
      DWORD                dwFilter,
      GROUPID              GroupId,
      DWORD                dwFlags)
{
    return FindNextEntry(
                phFind,
                szPrefix,
                (pInfo ? &pInfo : NULL),
                pcbInfo,
                dwFilter,
                GroupId,
                dwFlags,
                0);
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CleanupUrls
----------------------------------------------------------------------------*/
DWORD CConMgr::CleanupUrls
    (LPCTSTR szCachePath, DWORD dwFactor, DWORD dwFilter)
{
    DWORD dwError = ERROR_SUCCESS;

    UNIX_RETURN_ERR_IF_READONLY_CACHE(dwError);

    // Bad cleanup parameter.
    if (dwFactor <= 0 || dwFactor > 100)
    {
        dwError = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    // For null or empty path, clean up content container.
    if (!szCachePath || !*szCachePath)
    {
        _coContent->CleanupUrls(dwFactor, dwFilter);
    }
    else
    {
        LOCK_CACHE();

        // Find the container with the matching cache path and clean it up.
        for (DWORD idx = CONTENT; idx < NCONTAINERS; idx++)
        {
            URL_CONTAINER *co = ConList.Get(idx);

            if (co)
            {
                if (PathPrefixMatch(szCachePath, co->GetCachePath()))
                {
                    UNLOCK_CACHE();
                    co->CleanupUrls(dwFactor, dwFilter); // expensive?
                    LOCK_CACHE();
                    co->Release(TRUE);
                    break;
                }
                co->Release(TRUE);
            }
        }

        UNLOCK_CACHE();
    }

exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetUrlInGroup
----------------------------------------------------------------------------*/
DWORD CConMgr::GetUrlInGroup(LPCSTR szUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    URL_CONTAINER *co;
    DWORD dwError = ERROR_FILE_NOT_FOUND;
    // Find the associated container.
    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szUrl);

    co = ConList.Get(idx);

    if (co)
    {
        UNLOCK_CACHE();
        // Call GetUrlInGroup on the appropriate container.
        dwError = co->GetUrlInGroup(szUrl, pGroupId, pdwExemptDelta);
        LOCK_CACHE();
        co->Release(TRUE);
    }
    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateGroup(dwFlags, pGID);
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::CreateDefaultGroups()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::CreateDefaultGroups()
{
    INET_ASSERT(_coContent); 

    LOCK_CACHE();

    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.CreateDefaultGroups();
    }


    UNLOCK_CACHE();
    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::DeleteGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_coContent);

    LOCK_CACHE();
    GroupMgr gm;
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    if( gm.Init(_coContent) )
    {
        dwError = gm.DeleteGroup(gid, dwFlags);
    }

    UNLOCK_CACHE();

    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::FindNextGroup()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::FindNextGroup(
      HANDLE*                               phFind,
      DWORD                                 dwFlags,
      GROUPID*                              pGroupId
)
{
    DWORD                      dwError;
    GROUP_FIND_FIRST_HANDLE*   pFind = NULL;
    GroupMgr gm;

    INET_ASSERT(_coContent);
    LOCK_CACHE();


    // Null handle initiates enumeration.
    if (!*phFind)
    {
        // BUGBUG currently only supports SEARCH_ALL option
        if( dwFlags )
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }


        // Allocate a handle.
        *phFind = HandleMgr.Alloc (sizeof(GROUP_FIND_FIRST_HANDLE));
        if (*phFind)
            pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);

        if (!*phFind)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }

        // Set signature and initial hash table find
        // handle in the newly allocated find handle.
        pFind->dwSig  = SIG_GROUP_FIND;
        pFind->fFixed = TRUE;
        pFind->nIdx = CONTENT;
        pFind->dwLastItemOffset = 0;
    }
    else
    {
        // Valid handle passed in - map it.
        pFind = (GROUP_FIND_FIRST_HANDLE*) HandleMgr.Map (*phFind);
        if (!pFind)
        {
            dwError = ERROR_INVALID_HANDLE;
            goto exit;
        }
    }

    //
    // The handle is initialized or was created via a previous FindNextEntry.
    //

    dwError = ERROR_FILE_NOT_FOUND;

    // Enum on the container and release.
    if( gm.Init(_coContent) )
    {
        DWORD dwLastItemOffset = pFind->dwLastItemOffset;

        dwError = gm.GetNextGroup(&dwLastItemOffset, pGroupId);

        // update offset field of the find handle
        pFind->dwLastItemOffset = dwLastItemOffset;

    }

exit:

    UNLOCK_CACHE();
    INET_ASSERT(*phFind != 0);
    INET_ASSERT(pFind != NULL);

    return dwError;
}

/*-----------------------------------------------------------------------------
DWORD CConMgr::GetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::GetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo,
    LPDWORD                             lpdwGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent) )
    {
        dwError = gm.GetGroup(gid, dwAttrib, lpGroupInfo, lpdwGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


/*-----------------------------------------------------------------------------
DWORD CConMgr::SetGroupAttributes()
  ----------------------------------------------------------------------------*/
DWORD CConMgr::SetGroupAttributes(
    GROUPID                             gid,
    DWORD                               dwAttrib,
    LPINTERNET_CACHE_GROUP_INFOA        lpGroupInfo
    )
{
    INET_ASSERT(_coContent);
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;

    LOCK_CACHE();
    GroupMgr gm;
    if( gm.Init(_coContent))
    {
        dwError = gm.SetGroup(gid, dwAttrib, lpGroupInfo);
    }

    UNLOCK_CACHE();
    return dwError;
}


DWORD CConMgr::RegisterCacheNotify(
    HWND    hWnd,
    UINT    uMsg,
    GROUPID gid,
    DWORD   dwFilter
    )
{
    DWORD dwError;
    INET_ASSERT(_coContent);
    dwError = _coContent->RegisterCacheNotify(hWnd, uMsg, gid, dwFilter);
    return dwError;
}

DWORD CConMgr::SendCacheNotification( DWORD  dwOp)
{
    DWORD dwError;

    INET_ASSERT(_coContent);
    _coContent->SendCacheNotification(dwOp);
    return ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
VOID CConMgr::GetCacheInfo
----------------------------------------------------------------------------*/
VOID CConMgr::GetCacheInfo(LPCSTR szPrefix, LPSTR szCachePath, LONGLONG *cbLimit)
{
    URL_CONTAINER *co;
    // Find the associated container.

    LOCK_CACHE();
    DWORD idx = FindIndexFromPrefix(szPrefix);
    
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call GetCacheInfo on the appropriate container.
        co->GetCacheInfo(szCachePath, cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}



/*-----------------------------------------------------------------------------
VOID CConMgr::SetCacheLimit
----------------------------------------------------------------------------*/
VOID CConMgr::SetCacheLimit(LONGLONG cbLimit, DWORD idx)
{
    URL_CONTAINER *co;
    // Find the associated container.

    UNIX_RETURN_IF_READONLY_CACHE;
    
    LOCK_CACHE();
    co = ConList.Get(idx);
    
    if (co)
    {
        // Call SetCacheLimit on the container.
        co->SetCacheLimit(cbLimit);
        co->Release(TRUE);
    }

    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachglob.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachglob.cxx

Abstract:

    contains global variables and functions of urlcache

Author:

    Madan Appiah (madana)  12-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>


// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
#ifdef unix
#include <flock.hxx>
#endif /* unix */

//
// global variables definition.
//
// from wininet\dll\globals.cxx
GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units
GLOBAL LONGLONG dwdwSessionStartTime;       // initialized in InitGlob() in urlcache
GLOBAL LONGLONG dwdwSessionStartTimeDefaultDelta = 0;


// from wininet\dll\Dllentry.cxx
CRITICAL_SECTION GlobalCacheCritSect;
BOOL GlobalCacheInitialized = FALSE;
CConMgr *GlobalUrlContainers = NULL;
LONG GlobalScavengerRunning = -1;
DWORD GlobalRetrieveUrlCacheEntryFileCount = 0;
PFNGETFILEATTREX gpfnGetFileAttributesEx = 0;

char       g_szFixup[sizeof(DWORD)];
HINSTANCE  g_hFixup;
PFN_FIXUP  g_pfnFixup;

MEMORY *CacheHeap = NULL;
HNDLMGR HandleMgr;

GLOBAL DWORD GlobalDiskUsageLowerBound = (4*1024*1024);
GLOBAL DWORD GlobalScavengeFileLifeTime = (10*60);

GLOBAL BOOL GlobalPleaseQuitWhatYouAreDoing = FALSE;

// Identity-related globals
GLOBAL DWORD GlobalIdentity = 0;
GLOBAL GUID  GlobalIdentityGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
GLOBAL BOOL GlobalSuppressCookiesPolicy = FALSE;
#ifdef WININET6
GLOBAL HKEY GlobalCacheHKey = HKEY_CURRENT_USER;
#endif

// shfolder.dll hmod handle
HMODULE g_HMODSHFolder = NULL;
// Shell32.dll hmod handle
HMODULE g_HMODShell32 = NULL;


// GLOBAL SECURITY_CACHE_LIST GlobalCertCache;

GLOBAL DWORD GlobalSettingsVersion=0; // crossprocess settings versionstamp
GLOBAL BOOL GlobalSettingsLoaded = FALSE;

GLOBAL const char vszDisableSslCaching[] = "DisableCachingOfSSLPages";

GLOBAL char vszCurrentUser[MAX_PATH];
GLOBAL DWORD vdwCurrentUserLen = 0;


// cookies info

GLOBAL BOOL vfPerUserCookies = TRUE;
const char  vszAnyUserName[]="anyuser";
const char  vszPerUserCookies[] = "PerUserCookies";
const char  vszInvalidFilenameChars[] = "<>\\\"/:|?*";


#ifdef unix
/***********************
 * ReadOnlyCache on Unix
 * *********************
 * When the cache resides on a file system which is shared over NFS
 * and the user can access the same cache from different work-stations,
 * it causes a problem. The fix is made so that, the first process has
 * write access to the cache and any subsequent browser process which
 * is started from a different host will receive a read-only version
 * of the cache and will not be able to get cookies etc. A symbolic
 * link is created in $HOME/.microsoft named ielock. Creation and
 * deletion of this symbolic link should be atomic. The functions
 * CreateAtomicCacheLockFile and DeleteAtomicCacheLockFile implement
 * this behavior. When a readonly cache is used, cache deletion is
 * not allowed (Scavenger thread need not be launched).
 *
 * g_ReadOnlyCaches denotes if a readonly cache is being used.
 * gszLockingHost denotes the host that holds the cache lock.
 */

BOOL g_ReadOnlyCaches = FALSE;
char *gszLockingHost = 0;

extern "C" void unixGetWininetCacheLockStatus(BOOL *pBool, char **pszLockingHost)
{
    if(pBool)
        *pBool = g_ReadOnlyCaches;
    if(pszLockingHost)
        *pszLockingHost = gszLockingHost;
}
#endif /* unix */

#ifdef CHECKLOCK_PARANOID

//  Code to enforce strict ordering on resources to prevent deadlock
//  One cannot attempt to take the critical section for the first time
//  if one holds a container lock
DWORD dwThreadLocked;
DWORD dwLockLevel;

void CheckEnterCritical(CRITICAL_SECTION *_cs)
{
    EnterCriticalSection(_cs);
    if (_cs == &GlobalCacheCritSect && dwLockLevel++ == 0)
    {
        dwThreadLocked = GetCurrentThreadId();
        if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
    }
}

void CheckLeaveCritical(CRITICAL_SECTION *_cs)
{
    if (_cs == &GlobalCacheCritSect)
    {
        INET_ASSERT(dwLockLevel);
        if (dwLockLevel == 1)
        {
            if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
            dwThreadLocked = 0;
        }
        dwLockLevel--;
    }
    LeaveCriticalSection(_cs);
}
#endif

//

/*++

--*/

BOOL InitGlobals (void)
{
    if (GlobalCacheInitialized)
        return TRUE;

    LOCK_CACHE();

    if (GlobalCacheInitialized)
        goto done;

    GetWininetUserName();

    // Read registry settings.
    OpenInternetSettingsKey();

    { // Detect a fixup handler.  Open scope to avoid compiler complaint.
    
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);

        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD cbFixup = sizeof(g_szFixup);
            if (ERROR_SUCCESS != roCache.GetValue
                ("FixupKey", (LPBYTE) g_szFixup, &cbFixup))
            {
                g_szFixup[0] = 0;
            }

            if (g_szFixup[0] != 'V' || g_szFixup[3] != 0)
            {
                g_szFixup[0] = 0;
            }                  
        }
    }
    
    /*
    {
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, CACHE5_KEY);
        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD dwDefTime;
            if (ERROR_SUCCESS == roCache.GetValue("SessionStartTimeDefaultDeltaSecs", &dwDefTime))
            {
                dwdwSessionStartTimeDefaultDelta = dwDefTime * (LONGLONG)10000000;
                dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
            }
        }
    }
    */
        
    // Seed the random number generator for random file name generation.
    srand(GetTickCount());

    GetCurrentGmtTime((LPFILETIME)&dwdwSessionStartTime);

    GlobalUrlContainers = new CConMgr();
    GlobalCacheInitialized =
        GlobalUrlContainers && (GlobalUrlContainers->GetStatus() == ERROR_SUCCESS);

    if( GlobalCacheInitialized )
    {
        DWORD dwError = GlobalUrlContainers->CreateDefaultGroups();
        INET_ASSERT(dwError == ERROR_SUCCESS);
    }
    else
    {
        delete GlobalUrlContainers;
        GlobalUrlContainers = NULL;
    }

done:
    UNLOCK_CACHE();
    return GlobalCacheInitialized;
}


URLCACHEAPI
BOOL
WINAPI
DLLUrlCacheEntry(
    IN DWORD Reason
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    HMODULE ModuleHandleKernel;

    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
#ifdef CHECKLOCK_PARANOID
            dwThreadLocked = 0;
            dwLockLevel = 0;
#endif
            ModuleHandleKernel = GetModuleHandle("KERNEL32");
            if (ModuleHandleKernel)
            {
                gpfnGetFileAttributesEx = (PFNGETFILEATTREX)
                    GetProcAddress(ModuleHandleKernel, "GetFileAttributesExA");
            }

            InitializeCriticalSection (&GlobalCacheCritSect);
            
            // RunOnceUrlCache (NULL, NULL, NULL, 0); // test stub
#ifdef unix
            if(CreateAtomicCacheLockFile(&g_ReadOnlyCaches,&gszLockingHost) == FALSE)
                return FALSE;
#endif /* unix */
            break;

        case DLL_PROCESS_DETACH:

            // Clean up containers list.
            if (GlobalUrlContainers != NULL)
            {
                delete GlobalUrlContainers;
                GlobalUrlContainers = NULL;
            }
            
            // Unload fixup handler.
            if (g_hFixup)
                FreeLibrary (g_hFixup);
                
            HandleMgr.Destroy();
            
#ifdef unix
        DeleteAtomicCacheLockFile();
#endif /* unix */
        DeleteCriticalSection (&GlobalCacheCritSect);

        break;
    }

    return TRUE;
}




//
// proxy info
//

// GLOBAL PROXY_INFO_GLOBAL GlobalProxyInfo;

//
// DLL version info
//
/*
GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WININET_MAJOR_VERSION,
    WININET_MINOR_VERSION
};
*/
//
// HTTP version info - default 1.0
//

// GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 0};
BOOL
PrintFileTimeInInternetFormat(
    FILETIME *lpft,
    LPSTR lpszBuff,
    DWORD   dwSize
)
{
    SYSTEMTIME sSysTime;

    if (dwSize < INTERNET_RFC1123_BUFSIZE) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (FALSE);
    }
    if (!FileTimeToSystemTime(((CONST FILETIME *)lpft), &sSysTime)) {
        return (FALSE);
    }
    return (InternetTimeFromSystemTime( &sSysTime,
                                        lpszBuff));

}


BOOL
GetWininetUserName(
    VOID
)
{
    BOOL fRet = FALSE;
    DWORD dwT;
    CHAR *ptr;

    // Note this critsect could be blocked for a while if RPC gets involved...
    // EnterCriticalSection(&GeneralInitCritSec);

    if (vdwCurrentUserLen) {
        fRet = TRUE;
        goto Done;
    }

    dwT = sizeof(vszCurrentUser);

    if (vfPerUserCookies) {

        fRet = GetUserName(vszCurrentUser, &dwT);

        if (!fRet) {

            DEBUG_PRINT(HTTP,
                        ERROR,
                        ("GetUsername returns %d\n",
                        GetLastError()
                        ));
        }

    }

    if (fRet == FALSE){

        strcpy(vszCurrentUser, vszAnyUserName);

        fRet = TRUE;
    }

    // Downcase the username.
    ptr = vszCurrentUser;
    while (*ptr)
    {
        *ptr = tolower(*ptr);
        ptr++;
    }

    INET_ASSERT(fRet == TRUE);

    vdwCurrentUserLen = (DWORD) (ptr - vszCurrentUser);


Done:
    // LeaveCriticalSection(&GeneralInitCritSec);
    return (fRet);
}




/***
*char *StrTokEx(pstring, control) - tokenize string with delimiter in control
*
*Purpose:
*       StrTokEx considers the string to consist of a sequence of zero or more
*       text tokens separated by spans of one or more control chars. the first
*       call, with string specified, returns a pointer to the first char of the
*       first token, and will write a null char into pstring immediately
*       following the returned token. when no tokens remain
*       in pstring a NULL pointer is returned. remember the control chars with a
*       bit map, one bit per ascii char. the null char is always a control char.
*
*Entry:
*       char **pstring - ptr to ptr to string to tokenize
*       char *control - string of characters to use as delimiters
*
*Exit:
*       returns pointer to first token in string,
*       returns NULL when no more tokens remain.
*       pstring points to the beginning of the next token.
*
*WARNING!!!
*       upon exit, the first delimiter in the input string will be replaced with '\0'
*
*******************************************************************************/

char * StrTokExA (char ** pstring, const char * control)
{
        unsigned char *str;
        const unsigned char *ctrl = (const unsigned char *)control;
        unsigned char map[32];
        int count;

        char *tokenstr;

        if(*pstring == NULL)
            return NULL;
            
        /* Clear control map */
        for (count = 0; count < 32; count++)
                map[count] = 0;

        /* Set bits in delimiter table */
        do
        {
            map[*ctrl >> 3] |= (1 << (*ctrl & 7));
        } while (*ctrl++);

        /* Initialize str. */
        str = (unsigned char *)*pstring;
        
        /* Find beginning of token (skip over leading delimiters). Note that
         * there is no token if this loop sets str to point to the terminal
         * null (*str == '\0') */
        while ( (map[*str >> 3] & (1 << (*str & 7))) && *str )
            str++;

        tokenstr = (char *)str;

        /* Find the end of the token. If it is not the end of the string,
         * put a null there. */
        for ( ; *str ; str++ )
        {
            if ( map[*str >> 3] & (1 << (*str & 7)) ) 
            {
                *str++ = '\0';
                break;
            }
        }

        /* string now points to beginning of next token */
        *pstring = (char *)str;

        /* Determine if a token has been found. */
        if ( tokenstr == (char *)str )
            return NULL;
        else
            return tokenstr;
}

const char vszUserNameHeader[4] = "~U:";



// ---- from wininet\http\httptime.cxx

//
// external prototypes
//

/********************* Local data *******************************************/
/******************** HTTP date format strings ******************************/

// Month
static const char cszJan[]="Jan";
static const char cszFeb[]="Feb";
static const char cszMar[]="Mar";
static const char cszApr[]="Apr";
static const char cszMay[]="May";
static const char cszJun[]="Jun";
static const char cszJul[]="Jul";
static const char cszAug[]="Aug";
static const char cszSep[]="Sep";
static const char cszOct[]="Oct";
static const char cszNov[]="Nov";
static const char cszDec[]="Dec";

// DayOfWeek in rfc1123 or asctime format
static const char cszSun[]="Sun";
static const char cszMon[]="Mon";
static const char cszTue[]="Tue";
static const char cszWed[]="Wed";
static const char cszThu[]="Thu";
static const char cszFri[]="Fri";
static const char cszSat[]="Sat";

// List of weekdays for rfc1123 or asctime style date
static const char *rgszWkDay[7] =
   {
        cszSun,cszMon,cszTue,cszWed,cszThu,cszFri,cszSat
   };

// list of month strings for all date formats
static const char *rgszMon[12] =
   {
        cszJan,cszFeb,cszMar,cszApr,cszMay,cszJun,
        cszJul,cszAug,cszSep,cszOct,cszNov,cszDec
   };

/******************** HTTP date format strings ******************************/

/* Http date format: Sat, 29 Oct 1994 19:43:00 GMT */
const char cszHttpDateFmt[]="%s, %02i %s %02i %02i:%02i:%02i GMT";

/****************************************************************************/

INTERNETAPI
BOOL
WINAPI
InternetTimeFromSystemTimeA(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format: must be FORMAT_RFC1123
    OUT LPSTR lpszTime,         // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
/*++

Routine Description:

    Converts system time to a time string fromatted in the specified RFC format


Arguments:

    pst:    points to the SYSTEMTIME to be converted

    dwRFC:  RFC number of the format in which the result string should be returned

    lpszTime: buffer to return the string in

    cbTime: size of lpszTime buffer

Return Value:

    BOOL
        TRUE    - string converted

        FALSE   - couldn't convert string, GetLastError returns windows error code

--*/
{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "InternetTimeFromSystemTimeA",
                     "%#x, %d, %#x, %d",
                     pst,
                     dwRFC,
                     lpszTime,
                     cbTime
                     ));

    DWORD dwErr;
    BOOL fResult = FALSE;
    FILETIME ft;
    
    if (   dwRFC != INTERNET_RFC1123_FORMAT
        || IsBadReadPtr (pst, sizeof(*pst))
        || IsBadWritePtr (lpszTime, cbTime)
        || !SystemTimeToFileTime(pst, &ft)
       )
    {
        dwErr = ERROR_INVALID_PARAMETER;
    } 
    else if (cbTime < INTERNET_RFC1123_BUFSIZE)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
    }
    else
    {
        SYSTEMTIME st;
        
        if ((pst->wDay < 0)
            || (pst->wDay > 6))
        {
            // ST2FT ignores the week of the day; so if we round trip back,
            // it should place the correct week of the day.
            FileTimeToSystemTime(&ft, &st);
            pst = &st;
        }

        wsprintf (lpszTime, cszHttpDateFmt,
            rgszWkDay[pst->wDayOfWeek],
            pst->wDay,
            rgszMon[pst->wMonth-1],
            pst->wYear,
            pst->wHour,
            pst->wMinute,
            pst->wSecond);
        fResult = TRUE;
    }

    if (!fResult)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\contain.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Abstract-for-module.

    Contents:

Author:

     16-Nov-1995

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

    16-Nov-1995
        Created

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Container allows any size file. The file is cleanedup at scavneging time
    2) Free 100% uses cleanupallurls, reinitializes memorymappedfile and cleansup
       all directories
    3) CurrentCacheSIze and Cache Limit in the memorymapped file itself
    4) FileCreation time and lastcheckedtime added
    5) friendly naming scheme

    25-Sep-1997

    Ahsan Kabir (akabir) made minor alterations to GetFileSizeAndTimeByName.

--*/

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Contains code that implements CONTAINER classes defined in
    contain.hxx.

Author:

    Madan Appiah (madana)  28-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; INET_ASSERT (IsContentContainer()); \
    IncrementHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif

// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
extern PFNGETFILEATTREX gpfnGetFileAttributesEx;


// private functions
DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    )
/*++

Routine Description:

    Get the size and creation time and file attributes of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    lpFindData : pointer to a WIN32_FIND_DATA structure where the size and time value is
        returned. On WinNT, only the size and time fields are valid.

Return Value:

    Windows Error Code.

--*/
{
    INET_ASSERT(lpFileAttrData != NULL);

    if (gpfnGetFileAttributesEx)
    {
        if(!gpfnGetFileAttributesEx(FileName, GetFileExInfoStandard, (LPVOID)lpFileAttrData))
            return( GetLastError() );
    }
    else
    {
        HANDLE hHandle;
        WIN32_FIND_DATA FindData;

        hHandle = FindFirstFile(FileName, &FindData);
        if( hHandle == INVALID_HANDLE_VALUE ) {
            return( GetLastError() );
        }
        memset(lpFileAttrData, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        lpFileAttrData->dwFileAttributes = FindData.dwFileAttributes;
        lpFileAttrData->nFileSizeLow = FindData.nFileSizeLow;
        lpFileAttrData->nFileSizeHigh = FindData.nFileSizeHigh;
        lpFileAttrData->ftCreationTime = FindData.ftCreationTime;

        FindClose(hHandle);
    }

    return(ERROR_SUCCESS);
}

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    )
/*++

Routine Description:

    Get the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : pointer to a longlong location where the size value is
        returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;

    // get the size of the file being cached.
    //  since we do not handle 4+gb files, we can safely ignore the high dword

    INET_ASSERT(pdwFileSize!=NULL);

    if (gpfnGetFileAttributesEx)
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
        if(!gpfnGetFileAttributesEx(pszFileName, GetFileExInfoStandard, &FileAttrData))
            return( GetLastError() );

        *pdwFileSize = FileAttrData.nFileSizeLow;
    }
    else
    {
        HANDLE hfFileHandle = CreateFile(
                        pszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( hfFileHandle == INVALID_HANDLE_VALUE )
            return(GetLastError());

        *pdwFileSize = GetFileSize( hfFileHandle, NULL);
        if(*pdwFileSize == 0xFFFFFFFF)
            dwError = GetLastError();

        CloseHandle( hfFileHandle );
    }
    return dwError;
}

// -------------------------------URL_CONTAINER----------------------------------- //

/*-----------------------------------------------------------------------------
URL_CONTAINER::URL_CONTAINER Sets path, prefix and limit.
-----------------------------------------------------------------------------*/
URL_CONTAINER::URL_CONTAINER(LPTSTR CacheName, LPTSTR CachePath,
                             LPTSTR CachePrefix, LONGLONG CacheStartUpLimit,
                             DWORD dwOptions)
{
    _fIsInitialized = FALSE;
    _fPerUserItem = TRUE;
    _dwLastReference = GetTickCountWrap();
    _fDeleted = FALSE;
    _fMarked = FALSE;
    _fDeletePending = FALSE;
    _fMustLaunchScavenger = FALSE;
//#ifdef CHECKLOCK_NORMAL
    _dwTaken = 0;
//#endif
    _dwRefCount = 0;
    _dwOptions = dwOptions;
    _dwBytesDownloaded = _dwItemsDownloaded = 0;
    _CacheEntryType = 0;
    _CacheName = NULL;
    _CachePath = NULL;
    _CachePrefix = NULL;


    if (!CachePath || !*CachePath || !CachePrefix || !CacheStartUpLimit)
    {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    _CacheName = NewString(CacheName == NULL ? TEXT(""):CacheName);

    _CachePathLen = strlen(CachePath);

    if (CachePath[_CachePathLen-1] != DIR_SEPARATOR_CHAR)
    {
        _CachePath = CatString(CachePath, DIR_SEPARATOR_STRING);
        _CachePathLen++;
    }
    else
        _CachePath = NewString(CachePath);

    _CachePrefix = NewString(CachePrefix);

    if (!_CachePath || !_CachePrefix || !_CacheName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _CachePrefixLen = strlen(_CachePrefix);

    _CacheStartUpLimit = CacheStartUpLimit;

    _UrlObjStorage = NULL;
    _FileManager = NULL;

    if (!memcmp(_CachePrefix, CONTENT_PREFIX, sizeof(CONTENT_PREFIX)))
        _CacheEntryType = NORMAL_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, COOKIE_PREFIX, sizeof(COOKIE_PREFIX)))
        _CacheEntryType = COOKIE_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, HISTORY_PREFIX, sizeof(HISTORY_PREFIX)))
        _CacheEntryType = URLHISTORY_CACHE_ENTRY;

    _Status = ERROR_SUCCESS;
}


#ifdef CHECKLOCK_PARANOID
void URL_CONTAINER::CheckNoLocks(DWORD dwThreadId)
{
    INET_ASSERT(_dwTaken == 0 || _dwThreadLocked != dwThreadId);
}
#endif

/*-----------------------------------------------------------------------------
URL_CONTAINER::Init
-----------------------------------------------------------------------------*/
DWORD URL_CONTAINER::Init()
{
    _Status = ERROR_SUCCESS;
    _FileMapEntrySize = NORMAL_ENTRY_SIZE;
    MemMapStatus eMMStatus;
    BOOL fMustUnlock = FALSE;
    DWORDLONG dlSize;

    // Generate the mutex name based on the cache path.
    DWORD i;
    LPSTR szPrefix;
    CHAR MutexName[MAX_PATH + 1];
    LPTSTR pCachePath, pMutexName;

    i = 0;
    pCachePath = _CachePath,
    pMutexName = (LPSTR) MutexName;
    while( *pCachePath != '\0'  && (i++ < MAX_PATH))
    {
        if( *pCachePath == DIR_SEPARATOR_CHAR )
            *pMutexName = '!';
        else
            *pMutexName = tolower(*pCachePath);

        pMutexName++;
        pCachePath++;
    }
    *pMutexName = '\0';

    // Open the existing mutex, or if first process, create a new one.
    BOOL fFirstProcess = FALSE;

    _MutexHandle = OpenMutex(SYNCHRONIZE, FALSE, (LPTSTR)MutexName);
    if (_MutexHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            _MutexHandle = CreateMutex(psa, FALSE, (LPTSTR)MutexName);
        }

        if (_MutexHandle != NULL)
            fFirstProcess = TRUE;
    }

    if (_MutexHandle == NULL)
    {
        _Status = GetLastError();
        goto Cleanup;
    }

    // Lock the container.
    if (!LockContainer(&fMustUnlock))
    {
        if (fMustUnlock) ReleaseMutex(_MutexHandle);
        fMustUnlock = FALSE;
        _Status = GetLastError();
        if (_MutexHandle)
        {
            CloseHandle(_MutexHandle);
            _MutexHandle = NULL;
        }
        goto Cleanup;
    }
    if ((_CachePathLen > 1) && (_CachePath[_CachePathLen-1] != PATH_CONNECT_CHAR))
    {
        lstrcat( _CachePath, PATH_CONNECT_STRING );
        _CachePathLen++;
    }

    // Initialize _ClusterSizeMinusOne and _ClusterSizeMask
    if (!GetDiskInfo(_CachePath, &_ClusterSizeMinusOne, &dlSize, NULL))
    {
        _Status = GetLastError();
        goto Cleanup;
    }
    _ClusterSizeMinusOne--;
    _ClusterSizeMask = ~_ClusterSizeMinusOne;

    // Construct and initialize the memory mapped file object.
    _UrlObjStorage = new MEMMAP_FILE;
    if( _UrlObjStorage == NULL )
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    eMMStatus = _UrlObjStorage->Init(_CachePath, _FileMapEntrySize);

    if((_Status = _UrlObjStorage->GetStatus()) != ERROR_SUCCESS )
        goto Cleanup;

    // for first process attach, we need to clean up the notification
    // hwnd, msg, gid and filter
    if( fFirstProcess && (_CacheEntryType == NORMAL_CACHE_ENTRY ))
    {
        RegisterCacheNotify(0, 0, 0, 0);
    }

    _UrlObjStorage->SetCacheLimit(_CacheStartUpLimit);

    // Construct and initialize the file manager.
    // Cookies and history don't use random subdirs.
    // BUGBUG - move this off to container manager.
    szPrefix = GetCachePrefix();

    if (!strcmp(szPrefix, COOKIE_PREFIX)
        || !strcmp(szPrefix, HISTORY_PREFIX)
        || (_dwOptions & INTERNET_CACHE_CONTAINER_NOSUBDIRS))
    {
        // Insecure cache -no random cache subdirs.
        _FileManager = new CFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }
    else
    {
        // Secure cache - random cache subdirs.
        _FileManager = new CSecFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // If first process to attach, unlock any locked entries.
    if (fFirstProcess)
        UnlockAllItems();

    // If the memory mapped file was reinitialized
    // cleanup old files.
    if (eMMStatus == MEMMAP_STATUS_REINITIALIZED)
        _FileManager->Cleanup();
    else
        eMMStatus = MEMMAP_STATUS_OPENED_EXISTING;

    _fIsInitialized = TRUE;
    if (dlSize <= (DWORDLONG)(4*1024*1024))
    {
        // Yeah, this hurts start-up perf. We also have little room to maneuvre in, so we're going to try anyway.
        CleanupUrls(DEFAULT_CLEANUP_FACTOR, 0);
    }

Cleanup:

    if( _Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "URL_CONTAINER::URL_CONTAINER() failed, %ld\n", _Status ));
        SetLastError(_Status);
    }
    if (fMustUnlock) UnlockContainer();

    if (_Status == ERROR_SUCCESS)
        return (eMMStatus == MEMMAP_STATUS_OPENED_EXISTING ? ERROR_ALREADY_EXISTS : ERROR_SUCCESS);

    return _Status;
}

void URL_CONTAINER::CloseContainerFile()
{

    // Cleanup.
    // _Filemanager holds a pointer to _UrlObjStorage and
    // must be deleted before _UrlObjStorage.
    delete _FileManager;
    delete _UrlObjStorage;

    _FileManager = NULL;
    _UrlObjStorage = NULL;

    if (!_fDeleted)
    {
        // Keep fixed container files from being deleted.
        if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
        {
            _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
            if (_fDeleted) _fDeletePending = FALSE;
        }
    }
}

URL_CONTAINER::~URL_CONTAINER(
    VOID
    )
/*++

Routine Description:

    URL_CONTAINER destructor

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fMustUnlock;

    // If not initialized, only delete path and prefix.
    if (!IsInitialized())
    {
        //  Free pending deleted container, even if someone has
        //  a enum handle open on it.  This is our last chance as we handle process
        //  detach

        LOCK_CACHE();
        TryToUnmap(0xFFFFFFFF);
        UNLOCK_CACHE();

        if(_CacheName) delete _CacheName;
        if(_CachePath) delete _CachePath;
        if(_CachePrefix) delete _CachePrefix;
        return;
    }

    LockContainer(&fMustUnlock);

    // Otherwise, do a full destruct.
    CloseContainerFile();

    if (fMustUnlock) UnlockContainer();

    // Delete mutex.
    if( _MutexHandle != NULL )
        CloseHandle( _MutexHandle );

    if(_CacheName) delete _CacheName;
    if(_CachePath) delete _CachePath;
    if(_CachePrefix) delete _CachePrefix;
}

DWORD URL_CONTAINER::GetOptions()
{
    return _dwOptions;
}

DWORD URL_CONTAINER::GetLastReference()
{
    return _dwLastReference;
}

BOOL URL_CONTAINER::IsVisible()
{
    return !(_fDeletePending || _fDeleted);
}

void URL_CONTAINER::Mark(BOOL fMarked)
{
    _fMarked = fMarked;
}

BOOL URL_CONTAINER::GetMarked()
{
    return _fMarked;
}

BOOL URL_CONTAINER::GetDeleted()
{
    return _fDeleted;
}

void URL_CONTAINER::SetDeleted(BOOL fDeleted)
{
    if (!_fIsInitialized) _fDeleted = fDeleted;
}

BOOL URL_CONTAINER::GetDeletePending()
{
    return _fDeletePending;
}

void URL_CONTAINER::SetDeletePending(BOOL fDeletePending)
{
    _fDeletePending = fDeletePending;
}

void URL_CONTAINER::AddRef()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    _dwRefCount++;
}

void URL_CONTAINER::TryToUnmap(DWORD dwAcceptableRefCount)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    BOOL fMustUnlock;

    if (_dwRefCount <= dwAcceptableRefCount)
    {
        if (_fIsInitialized)
        {
            LockContainer(&fMustUnlock);

            CloseContainerFile();

            if (fMustUnlock) UnlockContainer();

            // Delete mutex.
            if( _MutexHandle != NULL )
            {
                CloseHandle( _MutexHandle );
                _MutexHandle = NULL;
            }
            _fIsInitialized = FALSE;
        }
        else
        {
            if (!_fDeleted)
            {
                //  Never CONTENT, COOKIES or HISTORY container.
                if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
                {
                    if(GlobalUrlContainers)
                    {
                        _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
                        if (_fDeleted) _fDeletePending = FALSE;
                    }
                }
            }
        }
    }
}

DWORD URL_CONTAINER::Release(BOOL fTryToUnmap)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    DWORD dwRefCount = 0;

    INET_ASSERT(_dwRefCount);
    if (_dwRefCount)
    {
        dwRefCount = --_dwRefCount;
        if (fTryToUnmap && _dwRefCount == 0)
        {
            //  Never CONTENT, COOKIES or HISTORY container.
            if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
            {
                if (_fDeletePending)
                {
                    TryToUnmap(0);
                }
            }
        }
    }
    return dwRefCount;
}


BOOL URL_CONTAINER::LockContainer(BOOL *fMustUnlock)
/*++

Routine Description:

    This function waits for the container to be free.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _dwLastReference = GetTickCountWrap();

    *fMustUnlock = FALSE;

    if( _MutexHandle == NULL )
    {
        // Bad mutex handle.
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Container Mutex Handle is NULL.\n" ));
        return FALSE;
    }

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "LockContainer called by thread %x\n", GetCurrentThreadId()));

    //
    // Wait the for the mutex to be signalled.
    //

    DWORD Result;

    #if DBG
        DWORD MutexTimeoutCount;
        MutexTimeoutCount = 0;

    Waitagain:

    #endif

    // Check the mutex.
    #if DBG
        Result = WaitForSingleObject(_MutexHandle, MUTEX_DBG_TIMEOUT);
    #else
        Result = WaitForSingleObject(_MutexHandle, INFINITE);
    #endif

    switch ( Result )
    {
        case WAIT_OBJECT_0:

            // Mutex is signalled (normal result). We now have ownership of the mutex.
            // Do a CheckSizeGrowAndRemapAddress.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                {
                    return (FALSE);
                }
            }
            return TRUE;

    #if DBG
        case WAIT_TIMEOUT:

            // Exceeded debug timeout count. Try again.
            MutexTimeoutCount++;
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait time-out (count = %ld).\n", MutexTimeoutCount ));
            goto Waitagain;
    #endif

        case WAIT_ABANDONED :

            // The thread owning the mutex failed to release it before it terminated.
            // We still get ownership of the mutex.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex ABANDONED.\n" ));
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                    return (FALSE);
            }

            return TRUE;

        case WAIT_FAILED :

            // Failed to obtain mutex.
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait failed (%ld).\n", GetLastError() ));
            return FALSE;

    }

    INET_ASSERT( FALSE );
    return FALSE;
}


VOID URL_CONTAINER::UnlockContainer(VOID)
/*++

Routine Description:

    This function frees the container to be used by someone else.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    BOOL fMustLaunchScavenger = FALSE;

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "UnlockContainer called by thread %x\n", GetCurrentThreadId()));
    _dwLastReference = GetTickCountWrap();

    _dwTaken--;

#ifdef CHECKLOCK_NORMAL
    if( _MutexHandle)
    {
        INET_ASSERT(_dwThreadLocked == GetCurrentThreadId());

        if (_dwTaken == 0)
            _dwThreadLocked = 0;
#endif
        if (_dwTaken == 0)
        {
            fMustLaunchScavenger = _fMustLaunchScavenger;
            _fMustLaunchScavenger = FALSE;
        }
        if (ReleaseMutex( _MutexHandle ) == FALSE )
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "ReleaseMutex failed (%ld).\n", GetLastError() ));
        }
/* KV
        if (fMustLaunchScavenger)
            LaunchScavenger();
 */
#ifdef CHECKLOCK_NORMAL
    }
#endif
    return;
}

BOOL URL_CONTAINER::UpdateOfflineRedirect
(
    DWORD dwUrlItemOffset, // offset to hash table item of URL entry
    LPCSTR pszUrl,         // URL string
    DWORD cbUrl,           // URL length
    LPCSTR pszRedir        // redirect string
)
/*++
Routine Description:
    Marks a hash table item as allowing a redirect to add trailing slash,
    or creates a new redirect hash table item and memory mapped file entry.

    Addendum: We keep track of redirects in the cache and simulate them when
    offline. Often the redirected URL is the same as the original URL plus
    trailing slash.

WARNING: this function has multiple calls which can grow and remap the
memory map file, invalidating any pointers into the file.  Be careful.

Return Value: TRUE if redirect was cached

--*/

{
    DWORD cbRedir = strlen (pszRedir);
    DWORD dwUrlHash;
    DWORD dwRedirItemOffset;

    // Ignore the redirect URL if same as original URL.
    if (cbRedir == cbUrl && !memcmp(pszUrl, pszRedir, cbRedir))
        return FALSE;

    { // limit scope of pUrlItem

        HASH_ITEM* pUrlItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + dwUrlItemOffset);

        // Special case trailing slash redirect.
        if (   cbRedir + 1 == cbUrl
            && pszUrl [cbRedir] == '/'
            && !memcmp (pszUrl, pszRedir, cbRedir)
           )
        {
            pUrlItem->SetSlash();
            return TRUE;
        }

        // Record high bits of target URL hash value.
        dwUrlHash = pUrlItem->GetValue();
    }

    //
    // BUGBUG: we do not handle the case of redirect that once added a
    // trailing slash to redirect to another URL altogether.  We should
    // scan the entire hash table slot and unset the trailing slash bit
    // if we find a match.
    //

    REDIR_FILEMAP_ENTRY* pEntry;

    { // limit scope of pRedirItem

        HASH_ITEM* pRedirItem = NULL;

        if (HashFindItem (pszRedir, LOOKUP_REDIR_CREATE, &pRedirItem))
        {
            // Found existing redirect entry; update it.
            pEntry = (REDIR_FILEMAP_ENTRY*) HashGetEntry (pRedirItem);
            INET_ASSERT (pEntry->dwSig == SIG_REDIR);
            pEntry->dwHashValue = dwUrlHash;
            pEntry->dwItemOffset = dwUrlItemOffset;
            INET_ASSERT (!lstrcmp (pEntry->szUrl, pszRedir));
            return TRUE;
        }

        if (!pRedirItem)
            return FALSE;

        dwRedirItemOffset = (DWORD) ((LPBYTE) pRedirItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

    // Created new hash table item so allocate a redir entry.
    DWORD cbEntry = sizeof(*pEntry) + cbRedir;
    pEntry = (REDIR_FILEMAP_ENTRY *) _UrlObjStorage->AllocateEntry (cbEntry);

    // Associate entry with hash table item.
    HASH_ITEM *pRedirItem =
        (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwRedirItemOffset);
    if (!pEntry)
    {
        pRedirItem->MarkFree();
        return FALSE;
    }
    HashSetEntry (pRedirItem, (LPBYTE) pEntry);
    pRedirItem->SetRedir();

    // Initialize the redirect entry.
    pEntry->dwSig        = SIG_REDIR;
    pEntry->dwHashValue  = dwUrlHash;
    pEntry->dwItemOffset = dwUrlItemOffset;
    memcpy (pEntry->szUrl, pszRedir, cbRedir + 1);

    return TRUE;
}

LPSTR URL_CONTAINER::GetPrefixMap()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeLabel()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeTitle()
{
    return TEXT("");
}

DWORD URL_CONTAINER::AddIdentityUrl (AddUrlArg* pArgs)
{
    DWORD dwError = ERROR_SUCCESS;
    pArgs->dwEntryType |= IDENTITY_CACHE_ENTRY;

    // Lookup or create a hash item for the 0-URL entry.
    HASH_ITEM *pItem;
    BOOL fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_DONT_FOLLOW, &pItem);

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
        if (pOld && !IsPerUserEntry(pOld))
        {
            DeleteUrlEntry(pOld, pItem, SIG_DELETE);
            fUpdate = FALSE;
        }
    }
    if (!fUpdate)
    {
        DWORD dwIdentity = pArgs->dwIdentity;
        PTSTR pszFilePath = (PTSTR)pArgs->pszFilePath;
        pArgs->pszFilePath = NULL;
        pArgs->dwIdentity = 0;
        
//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Calling AddUrl recursively may be hazardous to your health
// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        dwError = AddUrl(pArgs);
        pArgs->dwIdentity = dwIdentity;            
        pArgs->pszFilePath = pszFilePath;
    }
    else
    {            
        DWORD dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
        DWORD dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }
    
    return dwError;
}


DWORD URL_CONTAINER::AddUrl (AddUrlArg* pArgs)

/*++

Routine Description:

    This member functions adds an URL to the container and moves the
    cache file to cache path.

Arguments:

    UrlName : pointer to an URL string.

    lpszNewFileName : pointer to a cache file (full) name.

    ExpireTime : expire time of the file.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    dwCacheEntryType : type of this new entry.

    HeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    FileExtension : file extension used to create this file.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwReturn;
    BOOL fMustUnlock;
    DWORD dwCurrentOffset;
    DWORD dwUrlNameSize;
    LPTSTR FileName;
    DWORD dwFileNameSize;
    DWORD dwUrlFileExtSize;
    DWORD dwEntrySize;
    FILETIME ftCreate;
    DWORD dwFileSize;
    LONGLONG CacheSize, CacheLimit;
    DWORD dwItemOffset;
    BOOL fUpdate;
    LPURL_FILEMAP_ENTRY NewEntry;
    HASH_ITEM *pItem;
    GROUP_ENTRY* pGroupEntry;
    GroupMgr    gm;
    DWORD dwFileMapEntrySizeAligned;
    BOOL fPlaceAnyRedirect = TRUE;

    if (!LockContainer(&fMustUnlock))
    {
        dwReturn = GetLastError();
        goto exit;
    }

    // If this is an identity-specific entry, we need to setup an identity-0
    // referrer
    if (pArgs->dwIdentity)
    {
        dwReturn = AddIdentityUrl(pArgs);
        if (dwReturn!=ERROR_SUCCESS)
        {
            goto exit;
        }
        fPlaceAnyRedirect = FALSE;
    }
    
    // Calculate dwUrlNameSize.
    dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

    // FileName points to the filename sans cachepath.  Calculate dwFileNameSize.
    if(pArgs->pszFilePath)
    {

        // Is this an absolute path (edited)?
        if (!(pArgs->dwEntryType & EDITED_CACHE_ENTRY))
        // No, so find the last slash in the file name path.
        // This delimits the file name.

        {
            CHAR  *pSlash = NULL,
                  *ptr = (LPSTR) pArgs->pszFilePath;
            while (*ptr)
            {
                if (*ptr == DIR_SEPARATOR_CHAR)
                    pSlash = ptr;

                ptr=CharNext(ptr);
            }
            FileName = pSlash  + 1;
            dwFileNameSize = (DWORD) (ptr - FileName + 1); // 64BIT
        }
        // Have an absolute path so use the full path
        else
        {
            FileName = (char *)pArgs->pszFilePath;
            dwFileNameSize = lstrlen(FileName)+1;
        }
    }
    else
    {
        FileName = NULL;
        dwFileNameSize = 0;
    }

    // Calculate dwUrlFileExtSize
    if (FileName)
    {
        dwUrlFileExtSize =
            (pArgs->pszFileExt? (lstrlen(pArgs->pszFileExt) + 1) : sizeof("txt"));

    }
    else
    {
        dwUrlFileExtSize = 0;
    }

    // Get the file size.
    if (!pArgs->pszFilePath)
        dwFileSize = 0;
    else
    {
        if (!pArgs->dwFileSize)
        {
            WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

            dwReturn = GetFileSizeAndTimeByName(pArgs->pszFilePath, &FileAttrData);
            // If not succeed, return a uniform error.
            if ((ERROR_SUCCESS!=dwReturn) || FileAttrData.nFileSizeHigh) // Accept 0 length files too ...
            {
                // Reject files of length 0 or larger than 4 GB.
                dwReturn = ERROR_INVALID_DATA;
                goto exit;
            }
            dwFileSize = FileAttrData.nFileSizeLow;
            ftCreate = FileAttrData.ftCreationTime;
        }
        else
        {
            dwFileSize = pArgs->dwFileSize;
            ftCreate = pArgs->ftCreate;
        }
    }

    dwReturn = ERROR_SUCCESS;

    { // Open a new block to limit the scope of pointer variables.

        HASH_ITEM *pItem;

        // Lookup or create a hash item for the URL entry.

        fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_CREATE, &pItem);

//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

        if (fUpdate)
        {
            // Check existing entry for refcount.
            URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
            if (pOld->NumReferences)
            {
                dwReturn = ERROR_SHARING_VIOLATION;
                goto exit;
            }

            // Validate the size of data to be copied from existing entry.
            // If the entry version is IE5, the value could be random, so
            // force it to the correct value.  If the value is otherwise
            // bogus, also set it to the IE5 size for safety.
            if (    pOld->bVerCreate == ENTRY_VERSION_IE5
                ||  pOld->CopySize > pOld->nBlocks * NORMAL_ENTRY_SIZE
                ||  pOld->CopySize & 3 // should be dword aligned
               )
            {
                pOld->CopySize = ENTRY_COPYSIZE_IE5;
            }

            dwFileMapEntrySizeAligned = pOld->CopySize;
        }
        else if (!pItem)
        {
            // Item was not found but could not allocate another hash table.
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else // brand new entry
        {
           dwFileMapEntrySizeAligned = ENTRY_COPYSIZE_CURRENT;
        }

        // Save offsets in case the memmap file must be grown and remapped.
        dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

    // Create/update offline redirect as necessary.
    if (pArgs->pszRedirect && fPlaceAnyRedirect)
    {
        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }

    DWORD dwUrlNameSizeAligned;
    DWORD dwFileNameSizeAligned;
    DWORD dwHeaderSizeAligned;
    DWORD dwUrlFileExtSizeAligned;

    // Calculate the total size of the entry, rounding up for alignment.
    dwUrlNameSizeAligned        = ROUNDUPDWORD(dwUrlNameSize);
    dwFileNameSizeAligned       = ROUNDUPDWORD(dwFileNameSize);
    dwHeaderSizeAligned         = (pArgs->pbHeaders) ? ROUNDUPDWORD(pArgs->cbHeaders) : 0;
    dwUrlFileExtSizeAligned     = ROUNDUPDWORD(dwUrlFileExtSize);

    INET_ASSERT (dwFileMapEntrySizeAligned % sizeof(DWORD) == 0);
    INET_ASSERT (sizeof(FILEMAP_ENTRY) % sizeof(DWORD) == 0);
    dwFileMapEntrySizeAligned += sizeof(FILEMAP_ENTRY);

    dwEntrySize =         dwFileMapEntrySizeAligned
                        + dwUrlNameSizeAligned
                        + dwFileNameSizeAligned
                        + dwHeaderSizeAligned
                        + dwUrlFileExtSizeAligned;

    NewEntry = (LPURL_FILEMAP_ENTRY) _UrlObjStorage->AllocateEntry(dwEntrySize);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

    // Restore pointer to hash table item.
    pItem = (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwItemOffset);

    if (!NewEntry)
    {
        if (!fUpdate)
            pItem->MarkFree();
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


/*
    Handle any differences between cache entry versions.

    IE5 inits bVerUpdate to 0 when creating an entry, but incorrectly preserves 
    the value when updating instead of forcing it to 0.  Fortunately IE6 does 
    not care since IE5 will not be able to find an identity-specific entry in 
    order to update it.

    However, we should have a safety hatch for IE7+ to realize that a downlevel 
    urlcache updated its entry and just copied over the opaque data.  Of course 
    the solution will be a total ugly hack.  One possibility is for the uplevel 
    urlcache to set dwUrlNameOffset to be dwCopySizeAligned + 4.  This will 
    leave an uninitialized dword "hole" between the fixed fields and the 4 
    variable size fields.  Once this hack is used, by IE7 for example, it 
    should correctly set bVerUpdate2 so that IE8+ can detect both IE5-6 and IE7 
    updates without creating further holes.
*/

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);

        if ((pOld->dwSig != SIG_URL)
            || (pOld->CopySize > PAGE_SIZE))
        {
            INET_ASSERT(FALSE);
            pItem->MarkFree();
            _UrlObjStorage->FreeEntry(NewEntry);
            dwReturn = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        
        CopyMemory (((LPBYTE) NewEntry) + sizeof(FILEMAP_ENTRY),
                    ((LPBYTE) pOld) + sizeof(FILEMAP_ENTRY),
                    pOld->CopySize);
        INET_ASSERT (NewEntry->CopySize == pOld->CopySize);
        if (NewEntry->CopySize == ENTRY_COPYSIZE_IE5)
            NewEntry->bVerCreate = ENTRY_VERSION_IE5;
        INET_ASSERT (NewEntry->bVerCreate == pOld->bVerCreate);
    }
    else
    {
        NewEntry->CopySize   = ENTRY_COPYSIZE_CURRENT;
        NewEntry->bVerCreate = ENTRY_VERSION_CURRENT;
        NewEntry->bVerUpdate = ENTRY_VERSION_CURRENT;
    }

    // Invalidate the signature during the update.
    NewEntry->dwSig = 0;

    // We must set entry type, file size, and exempt delta before
    // calling SetExemptDelta.  We leave the sticky bit out of the
    // entry type in case we have no more room for sticky items.
    NewEntry->CacheEntryType = _CacheEntryType
                                | (pArgs->dwEntryType & ~STICKY_CACHE_ENTRY);

    NewEntry->dwFileSize = dwFileSize;

    if (!fUpdate)
    {
        // This is a brand new entry.
        NewEntry->dwGroupOffset = 0;
        NewEntry->NumAccessed   = 1;

        if (pArgs->fImage)
        {
            NewEntry->bSyncState = SYNCSTATE_IMAGE;
            BETA_LOG (SYNCSTATE_IMAGE);
        }
        else
        {
            NewEntry->bSyncState = SYNCSTATE_VOLATILE;
            if (IsContentContainer())
                BETA_LOG (SYNCSTATE_VOLATILE);
        }

        NewEntry->dwExemptDelta = 0;
        if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
            SetExemptDelta (NewEntry, 24 * 60 * 60, dwItemOffset); // one day
    }
    else // if (fUpdate)
    {
        URL_FILEMAP_ENTRY* ExistingEntry = HashGetEntry (pItem);

        // This is an update of an existing entry.
        INET_ASSERT (NewEntry->dwGroupOffset == ExistingEntry->dwGroupOffset);

        NewEntry->NumAccessed++;  // BUGBUG: blowing off wraparound

        if (ExistingEntry->bSyncState == SYNCSTATE_STATIC)
            BETA_LOG (SYNCSTATE_STATIC_VOLATILE);

        NewEntry->bSyncState = SYNCSTATE_VOLATILE;


        if (ExistingEntry->dwExemptDelta ||
            ExistingEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            // If item was previously sticky, it is preserved upon update.
            NewEntry->dwExemptDelta = ExistingEntry->dwExemptDelta;
            INET_ASSERT (ExistingEntry->CacheEntryType | STICKY_CACHE_ENTRY);
            NewEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
        }
        else
        {
            // If the item wasn't previously sticky, it might be made so.
            NewEntry->dwExemptDelta = 0;
            if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
                SetExemptDelta (NewEntry, 24 * 60 * 60 * 1000, dwItemOffset); // one day
        }

        // if belongs to a group, adjust the group usage
        if( ExistingEntry->dwGroupOffset &&
            ExistingEntry->dwFileSize != NewEntry->dwFileSize )
        {
            LONGLONG llDelta = RealFileSize(NewEntry->dwFileSize) -
                               RealFileSize(ExistingEntry->dwFileSize);
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                if( gm.Init(this) )
                {
                    // dwGroupOffset is now offset to head of group list
                    gm.AdjustUsageOnList(ExistingEntry->dwGroupOffset, llDelta);
                }
            }
            else
            {
                // single group
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                    ExistingEntry->dwGroupOffset, pItem);

                // WARNING: quota can be reached by usage increase
                if( pGroupEntry )
                {
                    AdjustGroupUsage(pGroupEntry, llDelta);
                }
            }
        }

        // Delete the old entry if it's not an installed entry or an EDITED_CACHE_ENTRY
        // (Unless the new entry replacing it is also an EDITED_CACHE_ENTRY),
        // either way the hash table item is preserved. We also check the filesize if
        // we've determined the old entry was ECE but the new one is not, just in case
        // the client deletes the file but doesn't get around to deleting from the
        // cache index. The logic is optimized for the most likely case (want to del).
        if ((ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
            && (!(ExistingEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            // IDK=0 ECE=0 NECE=? FS=?
            DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
        }
        else if (ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        {
            // IDK=0 ECE=1 NECE=? FS=?
            if (NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)
            {
                // IDK=0 ECE=1 NECE=1 FS=?
                DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
            }
            else
            {
                // IDK=0 ECE=1 NECE=0 FS=?
                // Only want to go out to the FS to get filesize if absolutely necessary

                WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

                FileAttrData.nFileSizeLow = 0;
                dwReturn = GetFileSizeAndTimeByName(
                    (LPTSTR) OFFSET_TO_POINTER (ExistingEntry, ExistingEntry->InternalFileNameOffset),
                    &FileAttrData);
                if (!FileAttrData.nFileSizeLow)
                {
                    // IDK=0 ECE=1 NECE=0 FS=0 or not-exist
                    // if filesize is zero, might as well trounce it
                    DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
                }
                else if (dwReturn == ERROR_SUCCESS)
                {
                    // IDK=0 ECE=1 NECE=0 FS>0
                    // found a non-zero length file
                    _UrlObjStorage->FreeEntry(NewEntry);
                    pItem->MarkFree();
                    dwReturn = ERROR_SHARING_VIOLATION;
                    goto exit;
                }
            }
        }
        else
        {
            // IDK=1 ECE=? NECE=? FS=?
            // Installed directory item
            _UrlObjStorage->FreeEntry(NewEntry);
            pItem->MarkFree();
            dwReturn = ERROR_SHARING_VIOLATION;
            goto exit;
        }

    } // end else if (fUpdate)

    // Record the new offset in the hash table item.
    HashSetEntry (pItem, (LPBYTE) NewEntry);

    // Initialize NewEntry fields.
    NewEntry->dwRedirHashItemOffset = 0;
    NewEntry->NumReferences        = 0;
    NewEntry->HeaderInfoSize       = pArgs->cbHeaders;
    NewEntry->LastModifiedTime     = pArgs->qwLastMod;
    GetCurrentGmtTime ((FILETIME*) &NewEntry->LastAccessedTime);

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwExpires) ),
        &(NewEntry->dostExpireTime)   );

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwPostCheck) ),
        &(NewEntry->dostPostCheckTime)   );

    // GetDirIndex will fail if the entry is stored at an absolute path outside
    // the cache dir, This is valid for EDITED_CACHE_ENTRYs such as offline
    // Office9 docs. Even tho the call fails in this case, NewEntry->DirIndex
    // will be set to NOT_A_CACHE_SUBDIRECTORY

    DWORD dwIndex;
    if ((!_FileManager->GetDirIndex((LPSTR) pArgs->pszFilePath, &dwIndex))
        && !((pArgs->dwEntryType & EDITED_CACHE_ENTRY)
             || ((pArgs->dwEntryType & IDENTITY_CACHE_ENTRY) && !pArgs->dwIdentity)))
    {
        _UrlObjStorage->FreeEntry(NewEntry);
        pItem->MarkFree();
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    NewEntry->DirIndex = (BYTE) dwIndex;

    // If this entry points to the store directory, set
    // the INSTALLED_CACHE_ENTRY bit so that retrieval
    // from cache will not result in requests to the wire
    // from wininet except for refresh requests.

    if ((NewEntry->DirIndex == INSTALLED_DIRECTORY_KEY) ||
        (pArgs->dwEntryType & EDITED_CACHE_ENTRY))
    {
        NewEntry->CacheEntryType |= INSTALLED_CACHE_ENTRY;
    }

    FileTimeToDosDateTime( (FILETIME *)&(NewEntry->LastAccessedTime),
                           (LPWORD)&(NewEntry->dostLastSyncTime),
                           ((LPWORD)&(NewEntry->dostLastSyncTime)+1));

    // Specify identity.
    NewEntry->dwIdentity = pArgs->dwIdentity;
    if (pArgs->dwIdentity)
    {
        NewEntry->CacheEntryType |= IDENTITY_CACHE_ENTRY;
    }
    
    // The URL_FILEMAP_ENTRY will point to
    //
    // [URL_FILEMAP_ENTRY][UrlName][FileName][HeaderInfo][FileExtension]
    //                    ^        ^         ^           ^
    //                    |        |         |           FileExtensionOffset
    //                    |        |         |
    //                    |        |         HeaderInfoOffset
    //                    |        |
    //                    |        FileNameOffset
    //                    |
    //                    UrlNameOffset
    //


    dwCurrentOffset = dwFileMapEntrySizeAligned;
    NewEntry->UrlNameOffset = dwCurrentOffset;

    // Copy UrlName into NewEntry
    memcpy((LPSTR) OFFSET_TO_POINTER(NewEntry, NewEntry->UrlNameOffset),
        pArgs->pszUrl, dwUrlNameSize);

    dwCurrentOffset += dwUrlNameSizeAligned;

    // Copy FileName into NewEntry
    if(FileName)
    {
        NewEntry->InternalFileNameOffset = dwCurrentOffset;
        memcpy((LPTSTR) OFFSET_TO_POINTER (NewEntry,
            NewEntry->InternalFileNameOffset), FileName, dwFileNameSize);

        // Get file creation time of cache file.
        if (!pArgs->pszFilePath)
            NewEntry->dostFileCreationTime = 0;
        else
        {
            FileTimeToDosDateTime (&ftCreate,
                (LPWORD)&(NewEntry->dostFileCreationTime),
                ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
        }

        dwCurrentOffset += dwFileNameSizeAligned;
    }
    else
    {
        NewEntry->InternalFileNameOffset = 0;
        NewEntry->dostFileCreationTime = 0;
    }

    // Copy HeaderInfo into NewEntry
    if(pArgs->pbHeaders)
    {
        NewEntry->HeaderInfoOffset = dwCurrentOffset;
        memcpy((LPBYTE)NewEntry + NewEntry->HeaderInfoOffset,
            pArgs->pbHeaders, pArgs->cbHeaders);
        dwCurrentOffset += dwHeaderSizeAligned;
    }
    else
    {
        NewEntry->HeaderInfoOffset = 0;
    }

    // Copy FileExtension into NewEntry
    if(pArgs->pszFileExt)
    {
        NewEntry->FileExtensionOffset = dwCurrentOffset;
        memcpy ((LPTSTR) ((LPBYTE)NewEntry + NewEntry->FileExtensionOffset),
            pArgs->pszFileExt, dwUrlFileExtSize);
        dwCurrentOffset += dwUrlFileExtSizeAligned;
    }
    else
    {
        NewEntry->FileExtensionOffset = 0;
    }

    // Restore the signature.
    NewEntry->dwSig = SIG_URL;

    // Increment the FileManager's count
    if (FileName)
    {
        // This is a no-op for the COOKIES and HISTORY containers.
        _FileManager->NotifyCommit(NewEntry->DirIndex);

        // Adjust CacheSize if not an installed entry or stored outside of cache dir.
        // If disk quota is exceeded, initiate cleanup.
        // NOTE: this attempts to take the critical section, so we must defer it
        // until we have released the container mutex to avoid potential deadlock
        if ((NewEntry->DirIndex != INSTALLED_DIRECTORY_KEY) && (!(NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            _dwBytesDownloaded += (DWORD)RealFileSize(dwFileSize);
            _dwItemsDownloaded++;

            _UrlObjStorage->AdjustCacheSize(RealFileSize(dwFileSize));
            CacheSize = _UrlObjStorage->GetCacheSize();
            CacheLimit = _UrlObjStorage->GetCacheLimit();
            if (CacheSize > CacheLimit)
                _fMustLaunchScavenger = TRUE;

            // We also want to scavenge if, even though there's plenty of space available in the
            // cache, the amount of total disk space available falls below a certain threshold.
            // We'll arbitrarily set the threshold to be 4MB (below which, things are likely to get
            // painful.

            if (!_fMustLaunchScavenger && ((_dwBytesDownloaded>(1024*1024)) || (_dwItemsDownloaded>100)))
            {
                DWORDLONG dlSize = 0;

                _dwBytesDownloaded = _dwItemsDownloaded = 0;
                if (GetDiskInfo(_CachePath, NULL, &dlSize, NULL))
                {
                    _fMustLaunchScavenger = (BOOL)(dlSize <= (DWORDLONG)GlobalDiskUsageLowerBound);
                }
            }
        }
    }

    // Flush index if this is an edited document or Cookie to mitigate the risk of dirty shutdown losing changes a client
    // like Office9 might have made (they store edited docs in our cache).

    if (pArgs->dwEntryType & EDITED_CACHE_ENTRY )
    {
        FlushViewOfFile((LPCVOID)NewEntry, dwCurrentOffset);
    }

    if( pArgs->dwEntryType & COOKIE_CACHE_ENTRY )
    {
        FlushViewOfFile( (void*)(*_UrlObjStorage->GetHeapStart()), 0 );
    }


    // Notification
    // If item was previously sticky, it is preserved upon update.
    // only need to report non sticky -> sticky
    if( !fUpdate )
    {
        NotifyCacheChange(CACHE_NOTIFY_ADD_URL, dwItemOffset);
    }
    else
    {
        NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL, dwItemOffset);
    }

exit:

    if (fMustUnlock) UnlockContainer();
    return dwReturn;
}



DWORD URL_CONTAINER::AddLeakFile (LPCSTR pszFilePath)
{
    DWORD dwReturn;

    BOOL fUnlock;
    if (!LockContainer(&fUnlock))
    {
        if(fUnlock)
            ReleaseMutex(_MutexHandle);

        return GetLastError();
    }

    //
    // Calculate the size of the filename, after the last slash.
    //

    LPSTR pszSlash = NULL;
    LPSTR pszScan = (LPSTR) pszFilePath;
    while (*pszScan)
    {
        if (*pszScan == DIR_SEPARATOR_CHAR)
            pszSlash = pszScan;

        pszScan = CharNext(pszScan);
    }
    LPSTR pszFileName = pszSlash + 1;
    DWORD cbFileName = (DWORD) (pszScan - pszFileName + 1); // 64BIT

    //
    // Determine the directory bucket.
    //

    DWORD nDirIndex;
    if (!_FileManager->GetDirIndex((LPSTR) pszFilePath, &nDirIndex))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the file size and create time.
    //

    WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
    dwReturn = GetFileSizeAndTimeByName (pszFilePath, &FileAttrData);
    if (!FileAttrData.nFileSizeLow || FileAttrData.nFileSizeHigh)
    {
        // Reject files of length 0 or larger than 4 GB.
        dwReturn = ERROR_INVALID_DATA;
        goto exit;
    }

    //
    // Allocate a leaked file entry.
    //

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////


    URL_FILEMAP_ENTRY* NewEntry;
    NewEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->AllocateEntry
        (sizeof(URL_FILEMAP_ENTRY) + cbFileName);
    if (!NewEntry)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////


    //
    // Fill only the fields important to WalkLeakList method.
    //

    NewEntry->dwSig = SIG_LEAK;
    NewEntry->dwFileSize = FileAttrData.nFileSizeLow;
    NewEntry->InternalFileNameOffset = sizeof(URL_FILEMAP_ENTRY);
    memcpy ((LPBYTE) (NewEntry + 1), pszFileName, cbFileName);
    NewEntry->DirIndex = (BYTE) nDirIndex;
    FileTimeToDosDateTime( &FileAttrData.ftCreationTime,
                           (LPWORD)&(NewEntry->dostFileCreationTime),
                           ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
    NewEntry->NumReferences = 0;

    //
    // Add this entry on to the head of the scavenger leak list.
    //
    _UrlObjStorage->GetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &NewEntry->dwNextLeak);
    _UrlObjStorage->SetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
         OffsetFromPointer (NewEntry));

    //
    // Update the cache usage and directory count.
    //

    _UrlObjStorage->AdjustCacheSize(RealFileSize(NewEntry->dwFileSize));
    _FileManager->NotifyCommit(NewEntry->DirIndex);

    //
    // We could check here if usage exceeds quota then launch scavenger,
    // but it will probably happen soon enough anyway upon AddUrl.
    //

    dwReturn = ERROR_SUCCESS;

exit:
    if (fUnlock)
        UnlockContainer();

    return dwReturn;
}

DWORD URL_CONTAINER::RetrieveUrl
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppInfo,
    LPDWORD pcbInfo,
    DWORD dwLookupFlags, // e.g. redirect
    DWORD dwRetrievalFlags
)

/*++

Routine Description:

    This member function retrives an url from the cache. The url is marked
    as referenced, so that caller should call UnlockUrl when he is done
    using it.

Arguments:

    UrlName : pointer to the url name.

    ppInfo :  ptr to ptr to an entry info buffer, where the url entry info
        is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
        above buffer, on return it has the size of the buffer consumed or
        size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find the item.
    HASH_ITEM *pItem;

    if (!HashFindItem (UrlName, dwLookupFlags, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Get the hash entry.
    UrlEntry = HashGetEntry (pItem);
    if (UrlEntry->InternalFileNameOffset == 0)
    {
        Error = ERROR_INVALID_DATA;
        goto exit;
    }
    
    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = TRUE; IsCorrectUser() = %s \r\n",
            (IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))? "TRUE" : "FALSE"
            ));

        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }
    else
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = FALSE\r\n"));
    }
    // Hide sparse cache entries from non-wininet clients.

    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
            && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Found the entry. Copy URL info in the return buffer first.
    Error = CopyUrlInfoGuard( UrlEntry, ppInfo, pcbInfo, dwRetrievalFlags );
    if( Error != ERROR_SUCCESS )
        goto Cleanup;

    if ((*ppInfo)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // Delete the item and entry but not the file.
        UrlEntry->InternalFileNameOffset = 0;
        DeleteUrlEntry (UrlEntry, pItem, SIG_DELETE);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    // Verify the file size is what it is supposed to be.
    if (dwRetrievalFlags & RETRIEVE_WITH_CHECKS)
    {
        DWORD dwFileSize;
        Error = GetFileSizeByName
            ((LPCSTR)((*ppInfo)->lpszLocalFileName), &dwFileSize);
        if (Error != ERROR_SUCCESS)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if (dwFileSize != UrlEntry->dwFileSize)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }
    }

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount++;

    // Increment the reference count before returning.
    if (UrlEntry->NumReferences)
    {
        if( !pItem->IsLocked() )
        {
            //
            // corrupted index file
            // entry says it's locked, hash table say it's not
            // believe the hash table by fixing up the entry
            //
            INET_ASSERT (FALSE);
            UrlEntry->NumReferences = 0;
        }
    }
    else
        pItem->SetLocked();

    UrlEntry->NumReferences++;

    // Update last accessed time.
    GetCurrentGmtTime ((FILETIME*) &UrlEntry->LastAccessedTime);
 
    // And the number of times this was accessed
    UrlEntry->NumAccessed++;

Cleanup:

    if (Error != ERROR_SUCCESS)
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "RetrieveUrl call failed, %ld.\n",
            Error ));
        SetLastError(Error);
    }
exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


DWORD URL_CONTAINER::DeleteUrl(LPCSTR  UrlName)
/*++

Routine Description:

    This member function deletes the specified url from the cache.

Arguments:

    UrlName : pointer to the url name.

Return Value:

    Windows Error Code.

--*/
{
    BOOL fMustUnlock;
    DWORD Error;
    URL_FILEMAP_ENTRY *pEntry;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find (and validate) the entry.
    if (!HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    pEntry = HashGetEntry(pItem);

    // Delete the hash table item and entry from the index.
    Error = DeleteUrlEntry (pEntry, pItem, SIG_DELETE);

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "DeleteUrl: RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    // Notify
    NotifyCacheChange(
        CACHE_NOTIFY_DELETE_URL,
        (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
    );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


/*++
Routine Description:
    This member functions deletes an URL from the container and also
    deletes the cache file from cache path.

    dwSig - if we must put an uplevel entry on the async fixup list,
       this param distinguishes between updates and deletions.

Return Value:
    Windows Error Code.
--*/

DWORD URL_CONTAINER::DeleteUrlEntry
    (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM *pItem, DWORD dwSig)
{
    INET_ASSERT (pItem? dwSig == SIG_DELETE : dwSig == SIG_UPDATE);

    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Error;
    GROUP_ENTRY* pGroupEntry = NULL;
    GroupMgr     gm;

    // Check for locked entry.
    if (pEntry->NumReferences)
    {
        // Mark the entry for pending delete.
        pEntry->CacheEntryType |= PENDING_DELETE_CACHE_ENTRY;
        Error = ERROR_SHARING_VIOLATION;
        goto Cleanup;
    }

    // If the entry version is beyond our understanding...
    if (pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK)
    {
        INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));

        pEntry->dwSig = dwSig; // mark as either updated or deleted

        // Add entry to head of fixup list.
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET, &pEntry->dwNextLeak);
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET,
             OffsetFromPointer (pEntry));

        // Increment count of items on fixup list, maybe trigger fixup.
        DWORD dwCount, dwTrigger;
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, &dwCount);
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_TRIGGER, &dwTrigger);
        if (++dwCount > dwTrigger)
            _fMustLaunchScavenger = TRUE;
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, dwCount);

        goto delete_hash_item;
    }

    // If group associated, Adjust Group's disk Usage
    // if pItem == NULL, we should perserve all the group info
    if( pEntry->dwGroupOffset && pItem )
    {
        if( pItem->HasMultiGroup() )
        {
            // multiple group
            if( gm.Init(this) )
            {
                // dwGroupOffset now offset to head of group list
                gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
            }
        }
        else
        {
            // single group
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);

            if( pGroupEntry )
            {
                AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize) );
            }
        }
    }

    // Delete any associated file.
    if (pEntry->InternalFileNameOffset
        && (pEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        && (!(pEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
    {
        // Reduce the exempt usage for sticky item (could be an update)
        if ( pEntry->dwExemptDelta ||
             (pEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));

        // Get the absolute path to the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];
        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            && _FileManager->DeleteOneCachedFile
            (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));
            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // Link the entry at the head of leaked files list.
            INET_ASSERT(pEntry->NumReferences==0);

            pEntry->dwSig = SIG_LEAK;
            _UrlObjStorage->GetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &pEntry->dwNextLeak);
            _UrlObjStorage->SetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                 OffsetFromPointer (pEntry));
        }
    }
    else
    {
        // NOTE: In the case that the entry is in a store (INSTALLED_DIRECTORY_KEY)
        // we do allow the cache entry to be deleted, but we do NOT allow the associated
        // file to be deleted. This at least allows us to delete these entries from
        // the cache without affecting their (permanent) backing store files.

        _UrlObjStorage->FreeEntry(pEntry);
    }

delete_hash_item:

    // Delete this item from the hash table.
    if (pItem)
        pItem->MarkFree();

    Error = ERROR_SUCCESS;

Cleanup:

    TcpsvcsDbgPrint ((DEBUG_ERRORS,
        "URL_CONTAINER::DeleteUrlEntry() returning %ld\n", Error));
    return Error;
}


DWORD URL_CONTAINER::UnlockUrl(LPCSTR UrlName)
/*++

Routine Description:

    This member function unreferences the url entry, so that it can be
    freed up when used no one.

Arguments:

    Url : pointer to an URL name.

Return Value:

    Windows Error Code.

--*/
 {
    DWORD Error;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    HASH_ITEM* pItem;
    URL_FILEMAP_ENTRY* pEntry;

    // Look up the entry.
    if (HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
        pEntry = HashGetEntry (pItem);
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    UnlockItem (pEntry, pItem);

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount--;
    Error = ERROR_SUCCESS;

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

DWORD URL_CONTAINER::GetUrlInfo
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppUrlInfo,
    LPDWORD UrlInfoLength,
    DWORD dwLookupFlags,
    DWORD dwEntryFlags,
    DWORD dwRetrievalFlags
)
/*++

Routine Description:

    This member function retrieves the url info.

Arguments:

    UrlName : name of the url file (unused now).

    ppUrlInfo : pointer to the pointer to the url info structure that receives the url
        info.

    UrlInfoLength : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwLookupFlags: flags, e.g. translate through redirects

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY UrlEntry;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Look up the entry.
    UrlEntry = HashFindEntry (UrlName, dwLookupFlags);
    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }

    // Hide sparse cache entries from non-wininet clients.
    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
        && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Find only installed entry types.
    if ((dwEntryFlags & INTERNET_CACHE_FLAG_INSTALLED_ENTRY)
        && (!(UrlEntry->CacheEntryType & INSTALLED_CACHE_ENTRY)))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if (UrlInfoLength)
    {
        if (!ppUrlInfo || !*ppUrlInfo)
            *UrlInfoLength = 0;

       Error = CopyUrlInfoGuard( UrlEntry, ppUrlInfo, UrlInfoLength,
                            (dwEntryFlags & INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY ?
                                RETRIEVE_ONLY_FILENAME : 0) |
                            (dwEntryFlags & INTERNET_CACHE_FLAG_GET_STRUCT_ONLY ? 
                                RETRIEVE_ONLY_STRUCT_INFO : 0) |
                            dwRetrievalFlags);
    }
    else
       Error = ERROR_SUCCESS;

exit:
   if (fMustUnlock) UnlockContainer();
   return( Error );
}


DWORD URL_CONTAINER::SetExemptDelta
    (URL_FILEMAP_ENTRY* UrlEntry, DWORD dwExemptDelta, DWORD dwItemOffset)
{
    // Expanded history calls with STICKY_CACHE_ENTRY for no good reason.
    // INET_ASSERT (UrlEntry->FileSize);

    DWORD dwError = ERROR_SUCCESS;

    if (dwExemptDelta)
    {
        if (!UrlEntry->dwExemptDelta)
        {
            // Entry is changing from non-exempt to exempt.
            // (exempt limit check should be done at UpdateStickness
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_SET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }
    else // if (!dwExemptDelta)
    {
        if (UrlEntry->dwExemptDelta)
        {
            // Entry is changing from exempt to non-exempt.
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_UNSET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }

    UrlEntry->dwExemptDelta = dwExemptDelta;
End:
    return dwError;
}



DWORD URL_CONTAINER::SetUrlInfo(LPCSTR UrlName,
                                LPCACHE_ENTRY_INFO UrlInfo, DWORD FieldControl)
/*++

Routine Description:

Arguments:

    UrlName : name of the url file (unused now).

    UrlInfo : pointer to the url info structure that has the url info to
        be set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    // Look up the entry.
    if (HashFindItem (UrlName, 0, &pItem))
    {
        UrlEntry = HashGetEntry (pItem);
    }
    else
    {
        UrlEntry = NULL;
    }

    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // Set cache entry ATTRIBUTE.
    if(FieldControl & CACHE_ENTRY_ATTRIBUTE_FC)
    {
        // We must preserve IDENTITY_CACHE_ENTRY bits, if they set
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType 
                                   | (UrlEntry->CacheEntryType & IDENTITY_CACHE_ENTRY);
    }
    
    // Reset cache entry HITRATE.
    if(FieldControl & CACHE_ENTRY_HITRATE_FC)
        UrlEntry->NumAccessed = UrlInfo->dwHitRate;

    // Set last modified time.
    if(FieldControl & CACHE_ENTRY_MODTIME_FC)
         UrlEntry->LastModifiedTime = FT2LL(UrlInfo->LastModifiedTime);

    // Set expire time.
    if( FieldControl & CACHE_ENTRY_EXPTIME_FC)
    {
        FileTime2DosTime(UrlInfo->ExpireTime, &(UrlEntry->dostExpireTime) );
    }

    // Set last access time.
    if(FieldControl & CACHE_ENTRY_ACCTIME_FC)
        UrlEntry->LastAccessedTime = FT2LL(UrlInfo->LastAccessTime);

    // Set last sync time.
    if(FieldControl & CACHE_ENTRY_SYNCTIME_FC)
    {
        FileTimeToDosDateTime( &(UrlInfo->LastSyncTime),
                                (LPWORD)&(UrlEntry->dostLastSyncTime),
                               ((LPWORD)&(UrlEntry->dostLastSyncTime)+1));

        if (   UrlEntry->bSyncState != SYNCSTATE_VOLATILE
            && UrlEntry->bSyncState < SYNCSTATE_STATIC)
        {
            // See if we should transition to SYNCSTATE_STATIC.
            if (UrlEntry->bSyncState == SYNCSTATE_IMAGE)
            {
                // We have not had the image long enough to
                // conclude it is static.  See if it is older
                // than MIN_AGESYNC.

                LONGLONG qwCreate;
                INET_ASSERT (UrlEntry->dostFileCreationTime);
                DosDateTimeToFileTime(
                    * (LPWORD)&(UrlEntry->dostFileCreationTime),
                    *((LPWORD)&(UrlEntry->dostFileCreationTime)+1),
                    (FILETIME*) &qwCreate);

                if (FT2LL(UrlInfo->LastSyncTime) > qwCreate + MIN_AGESYNC)
                {
                    UrlEntry->bSyncState++;
                }
            }
            else
            {
                if (++UrlEntry->bSyncState == SYNCSTATE_STATIC)
                    BETA_LOG (SYNCSTATE_IMAGE_STATIC);
            }

        }
    }

    if (FieldControl & CACHE_ENTRY_TYPE_FC)
    {
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType;
    }
    
    // Set exemption delta.
    if (FieldControl & CACHE_ENTRY_EXEMPT_DELTA_FC)
    {
        Error = SetExemptDelta (
            UrlEntry,
            UrlInfo->dwExemptDelta,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

        if (Error != ERROR_SUCCESS)
            goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Adds or removes a URL from a group.  If adding, may set exemption time.
--*/
DWORD URL_CONTAINER::SetUrlGroup (LPCSTR lpszUrl, DWORD dwFlags, GROUPID GroupId)
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY pEntry;
    GROUP_ENTRY* pGroupEntry = NULL;
    GROUP_ENTRY* pOldGroupEntry = NULL;
    GROUPID      gid = 0;
    HASH_ITEM    *pItem = NULL;
    GroupMgr gm;

    if (dwFlags & INTERNET_CACHE_GROUP_NONE)
        return ERROR_SUCCESS;

    if (!GroupId)
        return ERROR_INVALID_PARAMETER;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    //
    // HashFindEntry will do the same thing, however, we need pItem
    // here so that we can set/clear the group bit
    //
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if( !gm.Init(this) )
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    if (dwFlags & INTERNET_CACHE_GROUP_REMOVE)
    {
        // offset to GROUP_ENTRY*
        DWORD dwGEOffset = 0;

        // find the group via GroupOffset
        if( !pEntry->dwGroupOffset )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Get GroupEntry Offset
        if( pItem->HasMultiGroup() )
        {
            // multiple group, get from list
            Error = gm.GetOffsetFromList(
                pEntry->dwGroupOffset, GroupId, &dwGEOffset);
            if( Error != ERROR_SUCCESS )
                goto exit;
        }
        else
        {
            dwGEOffset = pEntry->dwGroupOffset;
        }

        // get group entry from the offset
        pGroupEntry = _UrlObjStorage->ValidateGroupOffset(dwGEOffset, pItem);

        if( !pGroupEntry )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Remove the group from list
        if( pItem->HasMultiGroup() )
        {
            // remove it from list
            DWORD dwNewHeaderOffset = pEntry->dwGroupOffset;

            Error = gm.RemoveFromGroupList(
                pEntry->dwGroupOffset, dwGEOffset, &dwNewHeaderOffset );

            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            //
            // header may have been changed (if head is the one we want)
            // newHeaderOffset = 0 means last group has been removed
            //
            // NOTE: even we may have one item left on the list, we
            //       are not changing the multiGroup flag on this
            //       entry, so the dwGroupOffset are still points to
            //       the list
            pEntry->dwGroupOffset = dwNewHeaderOffset;

        }
        else
        {
            // set offset to 0 (single group)
            pEntry->dwGroupOffset = 0;

        }

        // if dwExamptDelta is set, we should leave the stick bit
        if(!pEntry->dwExemptDelta)
        {
            //
            // if the unassociated group is sticky, we are remove
            // the sticky bit of this url
            //
            // For multiple groups, we will have to make sure all
            // the remaining groups are non-sticky
            //

            if( IsStickyGroup(pGroupEntry->gid ) &&
                ( !pItem->HasMultiGroup()  ||
                  gm.NoMoreStickyEntryOnList(pEntry->dwGroupOffset) )
            )
            {
                Error = UpdateStickness(
                    pEntry,
                    URLCACHE_OP_UNSET_STICKY,
                    (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
                );
                if( Error != ERROR_SUCCESS )
                    goto exit;
            }
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize));
        }

        //
        // update hash bit indicating no group associate with this url
        // we won't clear the multiple group flag even if there is single
        // group left on the group list.
        //
        if( !pEntry->dwGroupOffset )
        {
            pItem->ClearGroup();
            pItem->ClearMultGroup();
        }

    }
    else
    {

        // Find Group via gid
        Error = gm.FindEntry(GroupId, &pGroupEntry, FALSE);
        if( Error != ERROR_SUCCESS )
        {
            goto exit;
        }

        if( pItem->HasGroup() )
        {
            // multiple group

            LPBYTE  lpBase;
            DWORD dwGroupEntryOffset = 0;

            lpBase = *_UrlObjStorage->GetHeapStart();
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            DWORD dwListEntryOffset = 0;
            DWORD dwEntryOffset = 0;
            DWORD dwItemOffset = 0;
            DWORD dwOldGroupEntryOffset = 0;

            if( !pItem->HasMultiGroup() )
            {
                //
                // switch from a single group to multiple
                // group, need to
                //  1) create a new group list
                //  2) add the existing single group to the newly created list
                //


//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                //
                // get a new List (memfile may grown)
                //
                Error = gm.CreateNewGroupList(&dwListEntryOffset);
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                // restore pointers based on (possible) new base addr
                lpBase = *_UrlObjStorage->GetHeapStart();

                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

                //
                // add the original group (whose offset is indicated
                // with dwGroupOffset of the url entry)
                // to the newly created list
                //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                Error = gm.AddToGroupList(
                        dwListEntryOffset, pEntry->dwGroupOffset);

                // restore offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }


                
//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                //
                // the dwGroupOffset of the url entry now
                // points the the head of a group list
                //
                pEntry->dwGroupOffset = dwListEntryOffset;
                pItem->MarkMultGroup();

            }

            //
            // Multiple group, just add the new group to the list
            //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
            // save offset
            lpBase = *_UrlObjStorage->GetHeapStart();
            dwEntryOffset = PtrDiff32(pEntry, lpBase);
            dwItemOffset = PtrDiff32(pItem, lpBase);
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            Error = gm.AddToGroupList(
                pEntry->dwGroupOffset, dwGroupEntryOffset);


            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            // remap since multiple group may cause memfile grow
            lpBase = *_UrlObjStorage->GetHeapStart();
            pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
            pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
            pItem = (HASH_ITEM*) (lpBase + dwItemOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
        }
        else
        {
            // single group, dwGroupOffset points the real group
            pEntry->dwGroupOffset = PtrDiff32(pGroupEntry, *_UrlObjStorage->GetHeapStart());
        }



        // update hash bit indicating group associate with this url
        pItem->MarkGroup();

        // if group is sticky, mark the entry to sticky as well
        if( IsStickyGroup(pGroupEntry->gid) )
        {
            Error = UpdateStickness(
                pEntry,
                URLCACHE_OP_SET_STICKY,
                (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
            );
            if( Error != ERROR_SUCCESS )
                goto exit;
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, RealFileSize(pEntry->dwFileSize) );
        }

        //
        // track the usage and quota
        // NOTE: we still allow this url to be added to the group
        //       even if usage > quota, DISK_FULL error will be
        //       returned, so the client is responsible to take
        //       futher action
        //
        if( pGroupEntry->llDiskUsage > (pGroupEntry->dwDiskQuota * 1024) )
        {
            Error = ERROR_NOT_ENOUGH_QUOTA;
            goto  exit;
        }
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Gets group ID and exemption time for a particular URL.
--*/
DWORD URL_CONTAINER::GetUrlInGroup
    (LPCSTR lpszUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    DWORD dwError;
    BOOL fMustUnlock;
    URL_FILEMAP_ENTRY* pEntry;
    GROUP_ENTRY*       pGroupEntry = NULL;
    HASH_ITEM*          pItem = NULL;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }


    // Look up the entry.
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
        dwError = ERROR_FILE_NOT_FOUND;
    else
    {
        if( pEntry->dwGroupOffset )
        {
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);
            if( pGroupEntry )
            {

                INET_ASSERT(pGroupEntry->gid);
                *((LONGLONG*) pGroupId) = pGroupEntry->gid;
            }
            else
            {
                dwError = ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            *((LONGLONG*) pGroupId) = 0;
        }

        *pdwExemptDelta = pEntry->dwExemptDelta;
        dwError = ERROR_SUCCESS;
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}


DWORD URL_CONTAINER::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedSize,
                                   LPCSTR lpszFileExtension, LPTSTR FileName,
                                   HANDLE *phfHandle, BOOL fCreatePerUser)
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    UrlName : name of the url file (unused now).

    ExpectedSize : expected size of the incoming file. If it is unknown
        this value should be set to 0.

    lpszFileExtension: extension for the filename created

    FileName : pointer to a buffer that receives the full path name of the
        the temp file.

    phfHandle : pointer to a handle that receives the handle of the file
        being create; pass null if we don't care (the file will be closed).

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;

    // BUGBUG - adding LockContainer here.
    if (!LockContainer(&fMustUnlock))
    {
        Error = (GetLastError());
        goto exit;
    }

    Error = _FileManager->CreateUniqueFile((LPSTR) UrlName, (DWORD) ExpectedSize, (LPSTR) FileName,
        (LPSTR) lpszFileExtension, (HANDLE*) phfHandle, (BOOL)fCreatePerUser);

exit:
    if (fMustUnlock) UnlockContainer();
    return( Error );
}



DWORD URL_CONTAINER::FindNextEntry
    (LPDWORD lpdwEnum, LPCACHE_ENTRY_INFO *ppCEI, LPDWORD lpdwCEI, DWORD dwFilter, GROUPID GroupId, DWORD dwFlags, DWORD dwRetrievalFlags)
{

    DWORD Error;
    URL_FILEMAP_ENTRY* pEntry;
    DWORD dwEnumSave;
    BOOL fMustUnlock;
    DWORD dwCopyFlags;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    BOOL fCheckUser;
    fCheckUser = IsContentContainer() && !(dwFilter & OTHER_USER_CACHE_ENTRY);
    dwCopyFlags = 0;
    if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO)
    {
        dwCopyFlags = RETRIEVE_ONLY_STRUCT_INFO;
    }
    else if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME)
    {
        dwCopyFlags = RETRIEVE_ONLY_FILENAME;
    }
    dwCopyFlags |= dwRetrievalFlags;
    while (1)
    {
        dwEnumSave = *lpdwEnum;
        pEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->FindNextEntry(lpdwEnum, dwFilter, GroupId);

        if(!pEntry)
        {
            Error = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        // For content container, skip items marked for another user.
        if (fCheckUser)
        {
            LPSTR pszHeaders = ((LPSTR) pEntry) + pEntry->HeaderInfoOffset;
            if (!IsCorrectUser(pszHeaders, pEntry->HeaderInfoSize))
                continue;
        }

        // Copy the data
        Error = CopyUrlInfoGuard(pEntry, ppCEI, lpdwCEI, dwCopyFlags);
        switch (Error)
        {
            case ERROR_INSUFFICIENT_BUFFER:
                // Restore current enum position.
                *lpdwEnum = dwEnumSave;
                goto Cleanup;

            case ERROR_FILE_NOT_FOUND:
                continue;

            default:
                INET_ASSERT (FALSE);
            // intentional fall through
            case ERROR_SUCCESS:
                goto Cleanup;
        }
    } // end while(1)

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}



/*------------------------------------------------------------------------------
    CopyUrlInfo

Routine Description:

    Copy URL info data from an URL_FILEMAP_ENTRY in the memory mapped file
    to CACHE_ENTRY_INFO output buffer. If the buffer given is sufficient,
    it returns ERROR_INSUFFICIENT_BUFFER, and pcbInfo will contain
    buffer size required.

Arguments:

    pEntry     : pointer to the source of the URL info.

    ppInfo   : ptr to ptr to an entry info buffer, where the url entry info
               is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
               above buffer, on return it has the size of the buffer consumed or
               size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

------------------------------------------------------------------------------*/
DWORD URL_CONTAINER::CopyUrlInfo(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD cbRequired;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSourceUrlName;
    DWORD cbLocalFileName;
    DWORD cbHeaderInfo;
    DWORD cbFileExt;

    INET_ASSERT(!((dwFlags & RETRIEVE_WITH_ALLOCATION) &&
                  (dwFlags & RETRIEVE_ONLY_FILENAME
                    || dwFlags & RETRIEVE_ONLY_STRUCT_INFO)));
    // Check signature
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Verify url string exists.
    if (!pEntry->UrlNameOffset)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Hate using goto's but, don't want to clutter anymore than I have to.
    // We assume that anything functions that pass these flags will have allocated
    // enough memory before hand.
    if ((dwFlags & RETRIEVE_ONLY_FILENAME) || (dwFlags & RETRIEVE_ONLY_STRUCT_INFO))
    {
        if (ppInfo && *ppInfo)
        {
            memset(*ppInfo, 0, sizeof(INTERNET_CACHE_ENTRY_INFO));
        }
        goto ShortCircuit;
    }

    // -----------------  Calculate embedded data sizes ------------------------
    // All byte counts are sizes.

    // SourceUrlName length;
    cbSourceUrlName = strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset)) + 1;

    // LocalFileName length.
    if(pEntry->InternalFileNameOffset)
    {
        cbLocalFileName =
            _FileManager->GetDirLen(pEntry->DirIndex)
            + strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset))
            + 1;
    }
    else
        cbLocalFileName = 0;

    // HeaderInfo length.
    cbHeaderInfo = (pEntry->HeaderInfoOffset) ? pEntry->HeaderInfoSize + 1 : 0;

    // File extension length.
    if (pEntry->FileExtensionOffset)
    {
        cbFileExt =
              strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset)) + 1;
    }
    else
        cbFileExt = 0;

    // Alignment - these quantities are already aligned in
    // URL_FILEMAP_ENTRY and should be reflected in its size.
    cbSourceUrlName  = ROUNDUPDWORD(cbSourceUrlName);
    cbLocalFileName  = ROUNDUPDWORD(cbLocalFileName);
    cbHeaderInfo     = ROUNDUPDWORD(cbHeaderInfo);
    cbFileExt        = ROUNDUPDWORD(cbFileExt);

    cbRequired = *pcbInfo;
    *pcbInfo = sizeof(CACHE_ENTRY_INFO)
                   + cbSourceUrlName
                   + cbLocalFileName
                   + cbHeaderInfo
                   + cbFileExt;

    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are allocating entry info, use the ex version.
        *pcbInfo += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
        *ppInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbInfo);
        if (!*ppInfo)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        // Second check for required buffer size.
        if (cbRequired < *pcbInfo )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
    }

    // ----------------------  Copy embedded data --------------------------------

    // A Typical CACHE_ENTRY_INFO will look like
    //
    // [CACHE_ENTRY_INFO][UrlName][FileName][Headers][FileExtension]
    //
    //                   ^        ^         ^        ^
    //                   |        |         |        |
    //                   |        |         |        lpszFileExtension
    //                   |        |         |
    //                   |        |         lpHeaderInfo
    //                   |        |
    //                   |        lpszLocalFileName
    //                   |
    //                   lpszSourceUrlName
    //

    // Pointer walks through CACHE_ENTRY_INFO appended data.
    LPBYTE pCur;
    pCur = (LPBYTE) *ppInfo + sizeof(CACHE_ENTRY_INFO);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are creating the -ex version, skip over those fields.
        pCur += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
    }

    // UrlName.
    memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset), cbSourceUrlName);
    (*ppInfo)->lpszSourceUrlName = (LPSTR) pCur;
    pCur += cbSourceUrlName;

    // FileName
    if (cbLocalFileName)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) pCur, &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        
        (*ppInfo)->lpszLocalFileName = (LPTSTR) pCur;
        pCur += cbLocalFileName;
    }
    else
        (*ppInfo)->lpszLocalFileName = NULL;


    // HeaderInfo
    if (cbHeaderInfo)
    {
        memcpy (pCur, OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset),
            pEntry->HeaderInfoSize);
        pCur[pEntry->HeaderInfoSize] = 0;
        (*ppInfo)->lpHeaderInfo = (LPTSTR)pCur;
        pCur += cbHeaderInfo;
    }
    else
        (*ppInfo)->lpHeaderInfo = NULL;


    // FileExt
    if (cbFileExt)
    {
        memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset), cbFileExt);
        (*ppInfo)->lpszFileExtension = (LPTSTR) pCur;
        pCur += cbFileExt;
    }
    else
        (*ppInfo)->lpszFileExtension = NULL;


    // ------------  Set remaining CACHE_ENTRY_INFO members -------------
ShortCircuit:
    // Struct size, entry type, use count and hit rate.
    (*ppInfo)->dwStructSize = URL_CACHE_VERSION_NUM;
    (*ppInfo)->CacheEntryType = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
    if (pEntry->bSyncState == SYNCSTATE_STATIC)
        (*ppInfo)->CacheEntryType |= STATIC_CACHE_ENTRY;
    (*ppInfo)->dwUseCount     = pEntry->NumReferences;
    (*ppInfo)->dwHitRate      = pEntry->NumAccessed;

    // File size.
    (*ppInfo)->dwSizeLow      = pEntry->dwFileSize;
    (*ppInfo)->dwSizeHigh     = 0;

    // Last modified, expire, last access and last sync times, maybe download time.
    (*ppInfo)->LastModifiedTime   = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    // expire time may be 0

    DosTime2FileTime(pEntry->dostExpireTime, &((*ppInfo)->ExpireTime));

    (*ppInfo)->LastAccessTime     = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        CACHE_ENTRY_INFOEX* pCEI = (CACHE_ENTRY_INFOEX*) *ppInfo;
        DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostFileCreationTime),
                             *((LPWORD)&(pEntry->dostFileCreationTime)+1),
                             &pCEI->ftDownload);

        DosTime2FileTime(pEntry->dostPostCheckTime, &pCEI->ftPostCheck);

    }

    DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostLastSyncTime),
                          *((LPWORD)&(pEntry->dostLastSyncTime)+1),
                          &((*ppInfo)->LastSyncTime));


    // Header info size and exempt delta.
    (*ppInfo)->dwHeaderInfoSize   = pEntry->HeaderInfoSize;
    (*ppInfo)->dwExemptDelta      = pEntry->dwExemptDelta;

    // If we want only struct info and filename, we'll assume that we've preallocated
    // enough memory.
    if (dwFlags & RETRIEVE_ONLY_FILENAME)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO),
            &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        (*ppInfo)->lpszLocalFileName = (LPTSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO);
    }

exit:
    return dwError;
}


// CopyUrlInfoGuard puts an exception handler around CopyUrlInfo
// for those case when we don't get a chance to flush the memory-mapped
// file, thus corrupting the cache.

// We put the try in this function, rather than in CopyUrlInfo, to
// avoid affecting the perf characteristics.
DWORD URL_CONTAINER::CopyUrlInfoGuard(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD dwError;
    
    __try
    {
        dwError = CopyUrlInfo(pEntry, ppInfo, pcbInfo, dwFlags);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
    }
    ENDEXCEPT
    return dwError;
}


void URL_CONTAINER::UnlockItem (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM* pItem)
{
    // Possibly a bogus assert due to using lazy-write mappings?
    //INET_ASSERT (pEntry->NumReferences);


    if (pEntry->NumReferences)
    {
        if (--pEntry->NumReferences)
        {
            if( !pItem->IsLocked() )
            {
                // corrupted index file, we have to believe the hash table
                // to fixup the cache entry
                INET_ASSERT (FALSE);
                pEntry->NumReferences = 0;
            }
        }
        else
        {
            pItem->ClearLocked();

            // If the item is marked for pending delete, do it now.
            if (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)
                DeleteUrlEntry (pEntry, pItem, SIG_DELETE);
        }
    }
}


void URL_CONTAINER::UnlockAllItems (void)
{
    DWORD dwEnum = *(_UrlObjStorage->GetPtrToHashTableOffset());

    // Enumerate hash table items.
    while (dwEnum)
    {
        HASH_ITEM *pItem = HashGetNextItem
            (_UrlObjStorage, *(_UrlObjStorage->GetHeapStart()), &dwEnum, 0);

        if (pItem && (pItem->IsLocked()))
        {
            // Validate and unlock the entry.
            URL_FILEMAP_ENTRY *pEntry =
                _UrlObjStorage->ValidateUrlOffset (pItem->dwOffset);
            if (!pEntry)
                pItem->MarkFree(); // invalid item
            else
            {
                // Clear the lockcount.
                pEntry->NumReferences = 1;
                UnlockItem (pEntry, pItem);
            }
        }
    }
}


DWORD URL_CONTAINER::RegisterCacheNotify( HWND      hWnd,
                                          UINT      uMsg,
                                          GROUPID   gid,
                                          DWORD     dwFilter)
{
    BOOL fUnlock;
    LockContainer(&fUnlock);

    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_HWND,    GuardedCast((DWORD_PTR)hWnd));
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_MESG,    (DWORD)uMsg);
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER,  (DWORD)dwFilter);

    if (fUnlock) UnlockContainer();

    return ERROR_SUCCESS;
}


// update stickness will do:
//      1. flip the bit
//      2. update the exempt usage
//      3. send notification
DWORD URL_CONTAINER::UpdateStickness( URL_FILEMAP_ENTRY* pEntry,
                                      DWORD              dwOp,
                                      DWORD              dwItemOffset)
{
    DWORD dwError = ERROR_SUCCESS;

    if( dwOp == URLCACHE_OP_SET_STICKY )
    {
        if( !( pEntry->CacheEntryType & STICKY_CACHE_ENTRY ) )
        {
            // Ensure that exempt items do not crowd the cache.
            LONGLONG FileUsage = RealFileSize(pEntry->dwFileSize);
            LONGLONG ExemptUsage = _UrlObjStorage->GetExemptUsage();
            LONGLONG CacheLimit  = _UrlObjStorage->GetCacheLimit();
            LONGLONG MaxExempt = (CacheLimit * MAX_EXEMPT_PERCENTAGE) / 100;
            if (ExemptUsage + FileUsage > MaxExempt)
                return ERROR_DISK_FULL;

            pEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_SET_STICKY, dwItemOffset);
        }
    }

    else
    if( dwOp == URLCACHE_OP_UNSET_STICKY )
    {
        if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            pEntry->CacheEntryType &= ~STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_UNSET_STICKY, dwItemOffset);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}

VOID FileTime2DosTime(FILETIME ft, DWORD* pdt)
{
    INET_ASSERT(pdt);

    *pdt = 0;
    if( FT2LL(ft) != LONGLONG_ZERO )
    {
        if( FT2LL(ft) == MAX_FILETIME)
        {
            *pdt = MAX_DOSTIME;
        }
        else
        {
            FileTimeToDosDateTime(
                &ft,
                ((LPWORD)(pdt)    ),
                ((LPWORD)(pdt) + 1)
            );
        }
    }
}

VOID DosTime2FileTime(DWORD dt, FILETIME* pft)
{
    INET_ASSERT(pft);

    LONGLONG llZero = LONGLONG_ZERO;
    LONGLONG llMax = MAX_FILETIME;
    if( dt )
    {
        if( dt == MAX_DOSTIME )
        {
            *pft = *LONGLONG_TO_FILETIME(&llMax);
        }
        else
        {
            DosDateTimeToFileTime(
                *((LPWORD)&(dt)    ),
                *((LPWORD)&(dt) + 1),
                pft
            );
        }
    }
    else
    {
        *pft = *LONGLONG_TO_FILETIME(&llZero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cachglob.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachglob.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif

// Prototype for async fixup callback.
typedef DWORD (CALLBACK* PFN_FIXUP) 
(
    DWORD   dwVer,      // version of cache
    LPSTR   pszPath,    // directory containing index file
    LPSTR   pszPrefix,  // protocol prefix
    BOOL*   pfDetach,   // ptr. to global indicating dll shutdown
    DWORD   dwFactor,   // as passed to CleanupUrls
    DWORD   dwFilter,   // as passed to CleanupUrls
    LPVOID  lpvReserved // reserved: pass null
);

//
// global variables.
//

extern CRITICAL_SECTION GlobalCacheCritSect;


extern BOOL GlobalCacheInitialized;
extern CConMgr *GlobalUrlContainers;
#define GlobalMapFileGrowSize (PAGE_SIZE * ALLOC_PAGES)
extern LONG GlobalScavengerRunning;
extern MEMORY *CacheHeap;
extern HNDLMGR HandleMgr;
extern DWORD GlobalRetrieveUrlCacheEntryFileCount;

// globals for async fixup handler
extern char       g_szFixup[sizeof(DWORD)];
                                 // regkey to lookup fixup dll,entry point
extern HINSTANCE  g_hFixup;      // dll containing fixup handler
extern PFN_FIXUP  g_pfnFixup;    // entry point of fixup handler


#ifdef unix
extern BOOL g_ReadOnlyCaches;
extern char* gszLockingHost;
#endif /* unix */


// -- from wininet\inc\globals.h 
extern BOOL vfPerUserCookies;

BOOL GetWininetUserName(VOID);
// BUGBUG: GetWininetUserName must be called before accessing vszCurrentUser.
// Instead, it should return the username ptr and the global not accessed.
extern char vszCurrentUser[];
extern DWORD vdwCurrentUserLen;

extern const char vszPerUserCookies[];

// --- from wininet\inetui\inetp.h
BOOL
GetCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

BOOL
IncrementCurrentSettingsVersion(
    LPDWORD lpdwVer
    );

extern DWORD GlobalDiskUsageLowerBound;
extern DWORD GlobalScavengeFileLifeTime;

extern BOOL GlobalPleaseQuitWhatYouAreDoing;
extern DWORD  GlobalSettingsVersion;
extern BOOL   GlobalSettingsLoaded;
extern const char   vszInvalidFilenameChars[];


char *
StrTokExA(
    IN OUT char ** pstring, 
    IN const char * control);



#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\conlist.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conlist.cxx

Abstract:

    Linked list of URL_CONTAINERs
    
Author:
    Adriaan Canter (adriaanc) 04-02-97
    
--*/
#include <wininetp.h>
#include <cache.hxx>

/*------------------------ CConElem -----------------------------------------*/

/*-----------------------------------------------------------------------------
CConElem constructor
  ---------------------------------------------------------------------------*/
CConElem::CConElem(URL_CONTAINER* pUrlCon)
{
    _pUrlCon = pUrlCon;
    _pNext = NULL;
}

/*-----------------------------------------------------------------------------
CConElem destructor. Destructs URL_CONTAINER* member.
  ---------------------------------------------------------------------------*/
CConElem::~CConElem()
{
    delete _pUrlCon;
}


/*------------------------ CConList Private Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList::Seek      Sets current pointer to element of index nElem.
  ---------------------------------------------------------------------------*/
BOOL CConList::Seek(DWORD nElem)
{   
    // Bad list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Seek to element from current.
    if (nElem > _nCur)        
    {
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

//
// BUGBUG: VC5 optimizer assumes if (a < b), then (b > a), so check (a != b) instead
//
    else if (nElem != _nCur) // if (nElem < _nCur)
    {
        // Seek to element from head.
        _nCur = 0;
        _pCur = _pHead;
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

    INET_ASSERT(_nCur != 0 || (_pCur == _pHead));

    return TRUE;
}


/*------------------------ CConList Public Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList constructor.
  ---------------------------------------------------------------------------*/
CConList::CConList()
: _n(0), _nCur(0), _pCur(NULL), _pHead(NULL)
{
}

/*-----------------------------------------------------------------------------
CConList destructor.
  ---------------------------------------------------------------------------*/
CConList::~CConList()
{
}

/*-----------------------------------------------------------------------------
CConList::Size      Returns number of elements in list.
  ---------------------------------------------------------------------------*/
DWORD CConList::Size()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD n = (_pHead ? _n+1 : 0);
    return n;
}

/*-----------------------------------------------------------------------------
CConList::Free      Removes and destructs each element in list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Free()
{
    LOCK_CACHE();

    DWORD i = Size();

    //  Delete CONTENT last, as we reference fields of it's header (dwChangeCount)
    //  in destructors of extensible containers
    while (i)
    {
        Remove(--i);
    }
    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
CConList::Add      Appends new element to list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Add(URL_CONTAINER * pUrlCon)
{
    LOCK_CACHE();
    BOOL bSuccess = FALSE;
    CConElem *pNew;
    DWORD i;
    
    // Bad pointer.
    if (!pUrlCon)
    {
        INET_ASSERT(FALSE);
        goto exit;        
    }

    if (_pHead)
    {
        //  try to reuse a Container which has been deleted
        for (i = 0; i <= _n; i++)
        {
            if (Seek(i))
            {
                if (_pCur->_pUrlCon->GetDeleted())
                {
                    delete _pCur->_pUrlCon;
                    _pCur->_pUrlCon = pUrlCon;
                    bSuccess = TRUE;
                    goto exit;
                }
            }
        }
    }

    // Construct new element.
    pNew = new CConElem(pUrlCon);

    if (!pNew)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // If valid list, seek to last element and add element.
    if (_pHead)
    {
        if (_n == LARGEST_INDEX)
        {
            delete pNew;
            INET_ASSERT(FALSE);
            goto exit;        
        }
        Seek(_n);
        _pCur->_pNext = pNew;
        pNew->_pNext = _pHead;
        _n++;
    }
    // If empty list, set head and current to new element.
    else
    {
        _pHead = _pCur = pNew;
        pNew->_pNext = _pHead;
        _n = _nCur = 0;
    }
    
    bSuccess = TRUE;
exit:
    
    UNLOCK_CACHE();
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::Remove      Removes nElem'th element from list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Remove(DWORD nElem)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD     nPrev;
    CConElem *pElem;
    BOOL bSuccess = FALSE;

    // Empty list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // Seek to previous element, or last if removing head.
    nPrev = (nElem == 0 ? _n : nElem - 1);
    Seek(nPrev);

    // Save pointer to element, update prevous' next pointer.
    pElem = _pCur->_pNext;
    _pCur->_pNext = _pCur->_pNext->_pNext;

    // Update head if necessary.
    if (nElem == 0)
        _pHead = _pHead->_pNext;

    // Decrement index of last, zero out values if empty.
    if (_n > 0)
        _n--;
    else
    {
        _pHead = _pCur = NULL;
        _n = _nCur = 0;
    }    
    
    // Destruct element.
    delete pElem;
    
    bSuccess = TRUE;
exit:
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::operator Get Returns Addref'ed reference to URL_CONTAINER* of index nElem.
  ---------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
URL_CONTAINER* CConList::Get (DWORD nElem)
{
    URL_CONTAINER* pUrlCon;
    if (Seek(nElem))
        pUrlCon = _pCur->_pUrlCon;
    else
        pUrlCon = NULL;
        
    if (pUrlCon) pUrlCon->AddRef();
    return pUrlCon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\cookies.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  cookies.cxx

Abstract:

  Cookie upgrade object implementation

  Upgrades cookies to new format by parsing existing cookies
  files and adding them to the newly created cookie cache index.

  Currently upgrades v3.2 to v4.0.


Author:
    Adriaan Canter (adriaanc) 01-Nov-1996.

Modification history:
    Ahsan Kabir (akabir) 25-Sep-1997 made a few minor alterations.
-------------------------------------------------------------------------------*/
#include <wininetp.h>
#include <cache.hxx>

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory

  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    DWORD dwError;
    REGISTRY_OBJ roCookiePath(HKEY_LOCAL_MACHINE, IE3_COOKIES_PATH_KEY);
    DWORD cbKeyLen = MAX_PATH;

    if ((dwError=roCookiePath.GetStatus())==ERROR_SUCCESS)
    {
        dwError = roCookiePath.GetValue(CACHE_DIRECTORY_VALUE, (LPBYTE)szCookiesDirectory,  &cbKeyLen);
    }

    return dwError;

}
/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;

    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokExA(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokExA(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokExA(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokExA(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokExA(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokExA(&ptr, "\n");
        pszLastTimeLow    = StrTokExA(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokExA(&ptr, "\n");
        pszDelimiter      = StrTokExA(&ptr, "\n");      // Delimiter should be "*"


        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            TcpsvcsDbgAssert(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);

        pszNextCookie = pszDelimiter+2;
    }

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        TcpsvcsDbgAssert(FALSE);
        pszNextCookie = 0;
        goto exit;
    }
    ENDEXCEPT

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(URL_CONTAINER *UrlContainer)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szOldMemMapFilePath     [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];

    CHAR               *pszHash, *ptr,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    LPCACHE_ENTRY_INFO pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;
    DWORD dwDIR_SEP_STRING = strlen(DIR_SEPARATOR_STRING);
    DWORD dwLen;
    REGISTRY_OBJ roCachePath(HKEY_CURRENT_USER, OLD_CACHE_KEY);
    DWORD cbKeyLen = MAX_PATH;

    szBuffer = 0;

    __try
    {

        if (!UrlContainer)
        {
            dwError = ERROR_INVALID_PARAMETER;
            goto exit;
        }

        TCHAR szSigKey[MAX_PATH];
        
        // Check to see if we are upgrading cookies
        // from local machine to per user.
        // If IE4's signature isn't present, then we'll guess that IE3 might have been.
        if (UrlContainer->IsPerUserItem()
            &&
            ((roCachePath.GetStatus()!=ERROR_SUCCESS)
             ||  
             (roCachePath.GetValue(CACHE_SIGNATURE_VALUE, (LPBYTE) szSigKey, &cbKeyLen)!=ERROR_SUCCESS)))
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            dwLen = strlen(szHKLMCookiesPath) +
                    strlen(szUserName) +
                    dwDIR_SEP_STRING   +
                    7;        // strlen("@*.txt" + '\0';

            if( dwLen > MAX_PATH )
            {
                dwError =  ERROR_INSUFFICIENT_BUFFER;
                goto exit;
            }

            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, DIR_SEPARATOR_STRING);
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");

            // Enumerate the users cache files
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind != INVALID_HANDLE_VALUE)
            {
                // One or more cookie files exist.
                do
                {
                    // Construct absolute path from HKLM to cookies file.
                    dwLen = strlen(szHKLMCookiesPath) +
                            strlen(FindData.cFileName) +
                            dwDIR_SEP_STRING +
                            1;
                    if( dwLen > MAX_PATH )
                    {
                        dwError =  ERROR_INSUFFICIENT_BUFFER;
                        goto exit;
                    }
                    strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                    strcat(szHKLMCookieFileName, DIR_SEPARATOR_STRING);
                    strcat(szHKLMCookieFileName, FindData.cFileName);

                    // Construct absolute path from HKCU to cookies file.
                    dwLen = strlen(UrlContainer->GetCachePath()) +
                            strlen(FindData.cFileName) +
                            1;
    
                    // We should rescue as many cookies as we can.
                    if( dwLen <= MAX_PATH )
                    {
                        strcpy(szHKCUCookieFileName, UrlContainer->GetCachePath());
                        strcat(szHKCUCookieFileName, FindData.cFileName);
                        // Move the file to the per-user directory.
                        CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);
                    }
                } while (FindNextFile(hFind, &FindData));

                // Close the Find handle.
                if (hFind != INVALID_HANDLE_VALUE)
                {
                    FindClose(hFind);
                    hFind = INVALID_HANDLE_VALUE;
                }
            } // Per-user upgrade.
        }

        // No per-user upgrade. szCookieFileNamePattern will look like
        // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
        dwLen = strlen(UrlContainer->GetCachePath()) + 8;        // strlen("*@*.txt" + '\0';

        if( dwLen > MAX_PATH )
        {
            dwError =  ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
        strcpy(szCookieFileNamePattern, UrlContainer->GetCachePath());
        strcat(szCookieFileNamePattern, "*@*.txt");

        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            dwLen = strlen(UrlContainer->GetCachePath()) +
                    strlen(FindData.cFileName) +
                    1;
            if( dwLen > MAX_PATH )
            {
                continue;
            }

            strcpy(szCookieFileName, UrlContainer->GetCachePath());
            strcat(szCookieFileName, FindData.cFileName);

            // Get the WIN32_FILE_ATTRIBUTE for the call to AddUrl
            // This wrapper works for Win95 and WinNT.

            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );

            // File handle must be valid.
            TcpsvcsDbgAssert(hFile != INVALID_HANDLE_VALUE);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? ->
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                TcpsvcsDbgAssert(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie,
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);

                        ptr = strstr(szCookieName, "@");

                        // Downcase the username portion of the file.
                        CHAR* tptr = ptr;
                        while (*--tptr != ':')
                            *tptr = tolower(*tptr);

                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (LPCACHE_ENTRY_INFO) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = UrlContainer->GetUrlInfo(szCookieName, &pCacheEntryInfo,
                            &cbCacheEntryInfoBuffer, 0, 0, 0);

#ifndef UNIX
                        if (dwError == ERROR_SUCCESS
                            && CompareFileTime(pCacheEntryInfo->LastModifiedTime, ftLast) > 0)
#else
                        /* There is a problem with multiple cookies in a single
                         * cookie file. When adding the second cookie, we will
                         * try to delete the existing cookie (the first one that
                         * was added), and thus try to delete the cookie file
                         * itself. But, deletion of the cookie file will fail on
                         * Win32 because the file is already open above for
                         * parsing. On Unix, the deletion will succeed.
                         * So, the work-around is to not add the second cookie
                         * which is from the same site. The entry will remain
                         * in the cookie file anyway.
                         */
                        if (dwError == ERROR_SUCCESS)
#endif /* UNIX */
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or
                            // it was found and the last modified time on it is
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.

                            // Add it to the cookie container.
                            // BUGBUG - besides assert, what to do if this fails?

                            AddUrlArg Args;
                            memset(&Args, 0, sizeof(Args));
                            Args.pszUrl      = szCookieName;  // user@foobar.com
                            Args.pszFilePath = szCookieFileName; // c:\winnt\cookies\user@foobar.txt
                            Args.qwExpires   = FT2LL(ftExpire); // Expire time.
                            Args.qwLastMod   = FT2LL(ftLast); // Last modified time.
                            Args.dwEntryType |= COOKIE_CACHE_ENTRY;
                            dwError = UrlContainer->AddUrl(&Args);

                            TcpsvcsDbgAssert(dwError == ERROR_SUCCESS);
                        }

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.

        } while (FindNextFile(hFind, &FindData));


        // No more cookie files or an error occured.
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);


    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        TcpsvcsDbgAssert(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

    ENDEXCEPT
                
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\downsize.cxx ===
/*++
Copyright (c) 1997  Microsoft Corp.

Module Name: downsize.cxx

Abstract:

    Implementation of heuristic pruning and wholesale purge of cache index.

Author:

    Rajeev Dujari (rajeevd) 15-Apr-97

    RajeevD rewrote scoring and pruning algo, Aug-98.

--*/

#include <wininetp.h>
#include <cache.hxx>

#ifdef BETA_LOGGING
#define SCAVENGER_TRACE
#define TRACE_FACTOR 99
#endif


BOOL // whether memory mapped index file was deleted
URL_CONTAINER::DeleteIndex (void)
{                                        
    BOOL fRetVal = FALSE;
    BOOL fMustUnlock;

    // Get the full path name of the cache directory.
    if (!LockContainer(&fMustUnlock))
        goto exit;

    CHAR szFullPath[MAX_PATH];
    memcpy(szFullPath, _UrlObjStorage->GetFullPathName(),
        _UrlObjStorage->GetFullPathNameLen() + 1);

    if (fMustUnlock)
    {
        UnlockContainer();
        fMustUnlock = FALSE;
    }

    // Delete the cache files not in use (index.dat is open by us)
    CFileMgr::DeleteCache (szFullPath);

    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(szFullPath);


    if (!LockContainer(&fMustUnlock))
        goto exit;

#ifdef NUKE_CACHE_INDEX_FILE

    // If no handles are actively in use by this process,
    // attempt to shrink the index file.
    if (!AnyFindsInProgress(0) && !GlobalRetrieveUrlCacheEntryFileCount)
    {

        LONGLONG qwLimit = _UrlObjStorage->GetCacheLimit();
        fRetVal = _UrlObjStorage->Reinitialize();
        if (fRetVal)
        {
            _UrlObjStorage->SetCacheLimit (qwLimit);
            _FileManager->Init();
            // BUGBUG: call SetCacheSize with total not deleted by DeleteCache.

        }
    }

#endif

exit:
    if (fMustUnlock)
        UnlockContainer();
    return fRetVal;
}

// Weightings of various score components...
#define IDLETIME_WEIGHT     (60000)
#define EXPIRY_WEIGHT       ( 3000)
#define NUMACCESS_WEIGHT    ( 3000)

/*=======================================================================
ScoreEntry computes the score for the given url entry.

    The lower the score the more likely is an entry to be
    removed from the cache. Entries with higher scores are
    considered more useful.  Only the relative values matter.

    The components that contribute to the score are as follows...
        idle time since last access
        number of times accessed
        expiry, last-modified, and other sync factors
    They are weighted so that idle time predominates if the
    item has been accessed recently while older items are
    more easily influenced by the other factors.

    IDLE TIME is measured as number of days since last access,
    not rounded to an integer but including a fraction.  Then
    the score decays as 1/(days+1).  To illustrate:

        Elapsed Time    Rel. Score
        ============    ==========
        0                   60
        12 hours            40
        1 day               30
        1.5 days            24
        2 days              20
        5 days              10
        9 days               6
        29 days              2
        30-59 days           1
        60+ days             0

    NUMBER OF TIMES ACCESSED is a predictor of both the likelihood
    the item will ever be accessed again and the frequency of future
    access.  This subscore is scaled by (1 - 1/num).  For example:

        Num         Rel. Score
        ===         ==========
         1               0
         2              10
         4              15
        10              18
        20+             20

    EXPIRY in the future is worth full credit because we need
    not issue if-modified-since requests (except upon refresh.)

    Similarly, an item which is approaching SYNCSTATE_VOLATILE
    gets checked rarely and gets nearly full credit.  Items on
    the way to approaching this state get pro-rated credit.

    An expiry in the past is treated same has no expiry at all.

    An item gets half credit if last-modified-time is set.
    Otherwise any net hit would download  new content so the
    cache entry is of limited value.

    To summarize:

        Expiry  LastMod SyncState   Rel. Score
        ======  ======= =========   ==========
        future  n/a     n/a             14
        other   present static          13
        other   present image            8
        other   present volatile         7
        other   none    n/a              0

    We are agnostic about file size.  Pruning a larger file means
    we reclaim a lot of disk space, but it takes longer to download.
    Small files often waste a lot of disk space on a FAT partition,
    but incur the same fixed cost as downloading a large file.

Arguments:
    pEntry :  pointer to the Url entry.
    CurrentGmtTime : Current GMT time.

Return Value: DWORD score.
=======================================================================*/
DWORD ScoreEntry
(
    URL_FILEMAP_ENTRY* pEntry,
    LONGLONG CurrentGmtTime
)
{
    INET_ASSERT(pEntry->dwSig == SIG_URL);

    // Compute scored based on days since last access.

    // We're adding 15 minutes to the CurrentGmtTime to account for the continual 
    // readjustments to the pc's internal clock; this will handle occasional blips
    // (cases when the gmt is suddenly earlier than the LastAccessedTime, for example)
    CurrentGmtTime += (15*60*FILETIME_SEC);

    LONGLONG IdleTime = CurrentGmtTime - pEntry->LastAccessedTime;

    // In case the Last Accessed Time is later than the GMT, we want to protect against
    // a negative time
    if (IdleTime < 0)
    {
        IdleTime = 0;
    }

    DWORD dwScore = (DWORD) (((LONGLONG) IDLETIME_WEIGHT * FILETIME_DAY)
        / (IdleTime + FILETIME_DAY));

#ifdef UNIX
    {
       /* We don't want to delete items that were just created.
        * On Win32, because the InternetLockRequestFile will hold onto
        * the entries. This will not work on Unix because they use
        * InternetLockRequestFile uses CreateFile, which does not really
        * lock the file on unix, because of the lack of file handles.
        * 
        * So, just like in IE4, we will give a grace period for the cache
        * item.
        */
       #define UNIX_STICKY_SCORE 0L
       if (IdleTime < (1 * 60 * (LONGLONG)10000000))
          return UNIX_STICKY_SCORE;
    }
#endif /* UNIX */

    // Add to score based on number of times accessed.
    DWORD dwAccess = pEntry->NumAccessed;
    if (!dwAccess)
    {
        INET_ASSERT (pEntry->NumAccessed);
        dwAccess = 1;
    }
    dwScore += NUMACCESS_WEIGHT - NUMACCESS_WEIGHT/dwAccess;

    // Add to score based on expiry and syncstate.
    FILETIME ftExpireTime;
    DosTime2FileTime(pEntry->dostExpireTime, &ftExpireTime);
    if (FT2LL(ftExpireTime) > CurrentGmtTime)
        dwScore += EXPIRY_WEIGHT;
    else if (pEntry->LastModifiedTime)
    {
        // Add a bonus for having a last-modified time.
        dwScore += EXPIRY_WEIGHT / 2;

        // Add more as the item approaches auto sync mode.
        INET_ASSERT (pEntry->bSyncState <= SYNCSTATE_STATIC);
        dwScore += (EXPIRY_WEIGHT * pEntry->bSyncState)
            / (2 * (SYNCSTATE_STATIC + 1));
    }

    INET_ASSERT (dwScore <=
        IDLETIME_WEIGHT + EXPIRY_WEIGHT + NUMACCESS_WEIGHT);
    return dwScore;
}


/*=======================================================================
WalkLeakList attempts to delete files that we couldn't delete earlier.
========================================================================*/
BOOL URL_CONTAINER::WalkLeakList (void)
{
    BOOL fMustUnlock;
    LockContainer(&fMustUnlock);

    // Set loop variables to head of list.
    DWORD dwPrevOffset = OffsetFromPointer(_UrlObjStorage->GetPtrToLeakListOffset());
    DWORD dwCurrOffset, dwFirstItemOffset;
    _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwCurrOffset);

    // Validate offset and block signature.
    URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
    if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
        || pEntry->dwSig != SIG_LEAK)
    {
        INET_ASSERT(dwCurrOffset==0);
        
        // Replace the bad link with a terminator.
        _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, 
                                      0);
        return fMustUnlock;
    }
    dwFirstItemOffset = dwCurrOffset;
    
    while (1)
    {
        // Extract full path of the file.
        // and attempt to delete the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];

        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            &&
            (!pEntry->NumReferences)
            &&
            (_FileManager->DeleteOneCachedFile
                (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex)))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));

            // Remove this item from the list.
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = pEntry->dwNextLeak;

            if (dwFirstItemOffset==dwCurrOffset)
            {
                _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  pEntry->dwNextLeak);
            }
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }

            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // We don't have permission to delete this entry
            dwPrevOffset = OffsetFromPointer (&pEntry->dwNextLeak);
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }
        }
    
        // If the shutdown event signalled, call it quits.
        // Also, if we've reached the end of the list, quit
        if (GlobalPleaseQuitWhatYouAreDoing || (dwCurrOffset==0))
            break;

        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
            || pEntry->dwSig != SIG_LEAK)
        {
            // Replace the bad link with a terminator.
            INET_ASSERT (FALSE);
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = 0;
            break;
        }
        pEntry->NumReferences++;

        // Relinquish the lock and time slice so other threads don't get starved.
        if (fMustUnlock)
        {
            UnlockContainer();
            fMustUnlock = FALSE;
        }

        SuspendCAP();
        Sleep (0);
        ResumeCAP();

        LockContainer(&fMustUnlock);
        _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwFirstItemOffset);
        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        pEntry->NumReferences--;
    }

    return fMustUnlock;
}

/*=======================================================================
IsUrlEntryExemptFromScavenging filters out items exempt from scavenging.

Returns BOOL: TRUE indicating the item should not be scavenged.
========================================================================*/
BOOL URL_CONTAINER::IsUrlEntryExemptFromScavenging
(
    HASH_ITEM* pItem,
    URL_FILEMAP_ENTRY* pEntry,
    DWORD dwFilter,
    LONGLONG qwGmtTime,
    GroupMgr* pgm
)
{
    // If entry points to a store directory, ignore it.
    if ((pEntry->DirIndex == INSTALLED_DIRECTORY_KEY)
    || (pEntry->CacheEntryType & EDITED_CACHE_ENTRY))
    {
        return TRUE;
    }

    // If filter==0, trash everything, son.
    if (dwFilter==0)
    {
        return FALSE;
    }
    
    // If entry type excluded by filter, ignore it.
    if (pEntry->CacheEntryType & dwFilter)
        return TRUE;

    // If not deleting all entries, check for exemption from scavenging.
    if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY)
    {
        // sticky + exemptDelta == 0 means sticky forever
        // because item must belong to non-purgeable group
        // or the cache entry type would not have sticky bit.
        if( !(pEntry->dwExemptDelta) )
            return TRUE;

        // sticky group == sticky forever! no exempt delta
        // needs to be looked.

        if( pEntry->dwGroupOffset )
        {
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                // if there are other sticky groups attached to
                // this url entry, leave this entry alone
                if(!pgm->NoMoreStickyEntryOnList(pEntry->dwGroupOffset))
                    return TRUE;
            }
            else
            {
                // single group
                // if the group attached to this url entry is
                // sticky, leave this entry alone
                GROUP_ENTRY* pGroupEntry = NULL;
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset
                    (pEntry->dwGroupOffset, pItem);
                if(pGroupEntry && IsStickyGroup(pGroupEntry->gid) )
                    return TRUE;
            }
        }

        // Skip over the item if it's within its exemption period.
        // FILETIME units are 100-ns ticks, exempt delta in seconds.

        LONGLONG qwExemptDelta = FILETIME_SEC * pEntry->dwExemptDelta;
        if (qwGmtTime < pEntry->LastAccessedTime + qwExemptDelta)
            return TRUE;
    }

    return FALSE;
}

/*=======================================================================
ScavengeItem deletes a cache entry and yields with the lock unowned.

Returns BOOL: FALSE if dll shutdown has been signalled.
========================================================================*/
BOOL URL_CONTAINER::ScavengeItem (HASH_ITEM* pItem, BOOL* pfMustUnlock)
{
    DeleteUrlEntry (HashGetEntry (pItem), pItem, SIG_DELETE);

    // If the shutdown event signalled, call it quits.
    if (GlobalPleaseQuitWhatYouAreDoing)
        return FALSE;

    // Relinquish the lock and time slice so other threads don't get starved.
    if (*pfMustUnlock)
    {
        UnlockContainer();
        *pfMustUnlock = FALSE;
    }

    SuspendCAP();
    Sleep (0);
    ResumeCAP();

    LockContainer(pfMustUnlock);
    return TRUE;
}


#define NUM_SCORE_ITEMS 100

//=======================================================================
#define FIND_MIN 1
#define FIND_MAX 0

PRIVATE SCORE_ITEM* FindMinOrMaxScoreItem
    (SCORE_ITEM* pScore, DWORD cScore, DWORD MinOrMax)
{
    INET_ASSERT (cScore);
    INET_ASSERT (MinOrMax == FIND_MIN || MinOrMax == FIND_MAX);

    SCORE_ITEM* pRet = pScore;
    DWORD dwScore = pScore->dwScore;

    for (DWORD iScore=1; iScore<cScore; iScore++)
    {
        pScore++;
        if ((dwScore < pScore->dwScore ? TRUE : FALSE) ^ MinOrMax)
        {
            pRet = pScore;
            dwScore = pScore->dwScore;
        }
    }

    return pRet;
}

//=======================================================================
PRIVATE void SwapScoreItems (SCORE_ITEM *p1, SCORE_ITEM *p2)
{
    SCORE_ITEM t;
    memcpy (&t, p1, sizeof(SCORE_ITEM));
    memcpy (p1, p2, sizeof(SCORE_ITEM));
    memcpy (p2, &t, sizeof(SCORE_ITEM));
}

//=======================================================================
PRIVATE void SortScoreItems (SCORE_ITEM* pScore, DWORD cScore)
{

    while (cScore > 1)
    {
        SCORE_ITEM *pMax =
            FindMinOrMaxScoreItem (pScore, cScore--, FIND_MAX);
        SwapScoreItems (pScore + cScore, pMax);
    }
}

//=======================================================================
void URL_CONTAINER::ScavengerDebugSpew
    (SCORE_ITEM* pScoreItem, LONGLONG* pqwDeleted)
{
    HASH_ITEM* pItem = (HASH_ITEM*)
        (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
    if (pScoreItem->dwHashValue == pItem->GetValue()
        && pScoreItem->dwHashOffset == pItem->dwOffset)
    {
        URL_FILEMAP_ENTRY* pEntry = HashGetEntry (pItem);
        char szBuf[1024];
        LPSTR pszOp;

        if (!pqwDeleted)
            pszOp = "IGNORE";
        else
        {
            pszOp = "DELETE";
            *pqwDeleted += RealFileSize (pEntry->dwFileSize);
        }

        wsprintf (szBuf, "%s %05d ", pszOp, pScoreItem->dwScore);
        OutputDebugString (szBuf);
        if (pqwDeleted)
        {
            wsprintf (szBuf, "%02d%% ", (*pqwDeleted * 100) / GetCacheLimit());
            OutputDebugString (szBuf);
        }
        PrintFileTimeInInternetFormat ((FILETIME*)
            &pEntry->LastAccessedTime , szBuf, sizeof(szBuf));
        OutputDebugString (szBuf);
        wsprintf (szBuf, " %s\n", ((LPSTR) pEntry) + pEntry->UrlNameOffset);
        OutputDebugString (szBuf);
    }
}


#ifndef SCAVENGER_TRACE
#define ScavengerTrace(x,y,z) { }
#else
#define ScavengerTrace(dwFactor, pScoreItem, pdwDel) \
    if (dwFactor==TRACE_FACTOR) {ScavengerDebugSpew(pScoreItem, pdwDel);}
#endif

/*========================================================================*/
DWORD URL_CONTAINER::FixupHandler (DWORD dwFactor, DWORD dwFilter)
{
    LOCK_CACHE();
    
    if (!g_pfnFixup)
    {
        // This is the first time we needed the handler; initialize.
        char szDll[MAX_PATH + 80];
        DWORD cbDll = sizeof(szDll);
        
        // Look up the fixup handler for the highest cache version installed.
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);
        if (ERROR_SUCCESS != roCache.GetStatus())
            goto err;
        if (ERROR_SUCCESS != roCache.GetValue (g_szFixup, (LPBYTE) szDll, &cbDll))
            goto err;
            
        LPSTR pszEntryPoint;

        // The dll name and entry point are delimited by a comma; tokenize.
        pszEntryPoint = StrChr (szDll, TEXT(','));
        if (!pszEntryPoint)
            goto err;
        *pszEntryPoint++ = 0;
        
        g_hFixup = LoadLibrary (szDll);
        if (!g_hFixup)
            goto err;
                
        g_pfnFixup = (PFN_FIXUP) GetProcAddress (g_hFixup, pszEntryPoint);
        if (!g_pfnFixup)
        {
            FreeLibrary (g_hFixup);
            goto err;
        }
    }

    UNLOCK_CACHE();
    
    return (*g_pfnFixup)
        (ENTRY_VERSION_CURRENT, _CachePath, _CachePrefix, 
        &GlobalPleaseQuitWhatYouAreDoing, dwFactor, dwFilter, NULL);

err:
    // We couldn't locate async fixup handler; fail gracefully.
    g_szFixup[0] = 0;
    UNLOCK_CACHE();
    return ERROR_WINHTTP_INTERNAL_ERROR;
}


/*=======================================================================
Routine Description:

Arguments:
    Factor : amount of free space to make. Factor of 25 means delete
        sufficient files to make CacheSize <= .75 * CacheLimit.

The index does not maintain a list of items sorted by score because the cost
of scavenging would be amortized across update operations, which are
performed on a foreground thread.  Such a list would be doubly linked because
updating an item would change its score and probably change its rank.  If the
items were directly linked together, this would likely result in touching two
other random pages on update.  A lookaside list would be a better approach
but would still require hitting another page on update or increasing the size
of the lookup hash table.  Furthermore, the ranking would need to be strictly
LRU, or else we would have to a 16-bit score in the entry and an updated item
might not go to the head of the list and require some traversal.

The scavenger thread scores items on the fly.  It attempts to avoid a full
enumeration of the cache and sorting of the scores.  Instead, it attempts to
track items that fall below a cutoff score and delete the lowest-scoring
among this set, possibly before completing the enumeration.  Specifically, it
starts by enumerating 100 items and sorting them.  Since the rank of the
items is uniformly distributed, by definition, the score of the 10th lowest
item is an estimate of the 10th percentile.  Of course, deleting 10% of the
items in the cache is no guarantee 10% of disk usage will be reclaimed.
However hitting the low-water mark of 90% of cache quota is not a strict goal
and will probably get the cache under the quota.  Even if not, the scavenger
will be invoked again on the next update and establish a higher cutoff.

If this cutoff score proves to be too low, then it's possible the scavenger
will enumerate the entire cache without bringing it below quota, in which
case it will be restarted by the next cache update, probably with a higher
threshhold.  On the other hand, if the cutoff score is too high, then we
might end the enumeration early and delete some items in the 20th or even
30th percentiles.  The latter outcome seems better since we never promised to
be perfect anyway, so we bias the algorithm by picking the 20th lowest
item for the threshhold score.

Once the cutoff score is established, the enumeration continues.  The list is
not kept sorted.  If all of the items in the 100-item list are below the
cutoff, then the lowest-scoring one is deleted.  Otherwise the highest-scoring
item is merely removed from the list and forgotten.  The the next item in the
enumeration is added to the list.  If the enumeration completes without
reaching the target usage, then the lowest-scoring item is deleted until the
list is empty, even those items that fall above the cutoff, which after all was
too low.

After each file deletion, the scavenger thread yields without holding the
container lock.  Otherwise another thread wanting to acquire the lock would
block, wake up the scavenger thread, and switch back after the scavenger
unlocked.

Return Value: ERROR_SUCCESS
========================================================================*/
DWORD URL_CONTAINER::CleanupUrls(DWORD dwFactor, DWORD dwFilter)
{
    DWORD Error = ERROR_SUCCESS;

    // dwFactor must be between 1 and 100 inclusive.
    INET_ASSERT (dwFactor >= 1 && dwFactor <= 100);

    // If an uplevel fixup handler is installed, delegate.

    if (g_szFixup[0])
        return FixupHandler (dwFactor, dwFilter);
    
    // Special case purging entire container.
    BOOL fPurge = (dwFactor == 100 && dwFilter == 0);
    if (fPurge && DeleteIndex())
        return ERROR_SUCCESS;

    // First loop through the leaked files and try to delete them.
    BOOL fMustUnlock = WalkLeakList();

    // before index get nuked, we need to send out last notification
    // about the whole cache gets deleted
    DWORD dwHWnd = 0;
    DWORD dwUMsg = 0;
    DWORD dwNotifFilter = 0;

    GroupMgr gm;
    if( !gm.Init(this) )
    {
        INET_ASSERT(FALSE);
    }

    BOOL fLowDiskSpace = FALSE;
    
    _UrlObjStorage->GetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER, &dwNotifFilter);
    if( dwNotifFilter & CACHE_NOTIFY_DELETE_ALL)
    {
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_HWND, &dwHWnd);
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_MESG, &dwUMsg);
    }

    // Calculate usage goal.
    LONGLONG qwQuota = _UrlObjStorage->GetCacheLimit();
    LONGLONG qwGoal = (qwQuota * (100 - dwFactor)) / 100;
    LONGLONG qwGmtTime;
    GetCurrentGmtTime ((FILETIME*) &qwGmtTime);

    DWORDLONG dlAvail = 0;
    if (GetDiskInfo(_CachePath, NULL, &dlAvail, NULL)
        &&
        (BOOL)(dlAvail <= (DWORDLONG)GlobalDiskUsageLowerBound))
    {
        fLowDiskSpace = TRUE;
        // We'll set the goal even lower, if the disk space falls below the 4 GIG threshold
        // qwResult contains how much disk space would be available with the current goal
        LONGLONG qwResult = dlAvail + (_UrlObjStorage->GetCacheSize() - qwGoal);
        if (qwResult < (LONGLONG)GlobalDiskUsageLowerBound)
        {
            qwGoal = _UrlObjStorage->GetCacheSize() - ((LONGLONG)(GlobalDiskUsageLowerBound - dlAvail));

            // At the very least, we'll preserve 128K (about three pages)
            if (qwGoal<(LONGLONG)(128*1024))
            {
                qwGoal = (LONGLONG)(128*1024);
            }
        }
    }

#ifdef SCAVENGER_TRACE

    // If we are simulating a scavenging, we accumulate the number
    // of bytes, adjusted for cluster slop, that would be reclaimed
    // if this were for real.  By setting the usage target to 0, we
    // also stress the scavenger to see how well it selects items
    // in edge cases where we just can't seem to delete enough.

    LONGLONG qwDeleted = 0;
    if (dwFactor == TRACE_FACTOR)
        qwGoal = 0;

#endif

    SCORE_ITEM ScoreList[NUM_SCORE_ITEMS];
    DWORD cScore = 0;  // number of valid entries in score list

    DWORD dwCutoffScore = 0;

    DWORD dwEnum = GetInitialFindHandle();

    // The loop code below is organized in two parts.
    // Part 1 - enum the cache to add another item to the list.
    // Part 2 - remove an item from a list, by throwing out a
    //   a high-scoring item or deleting a low-scoring item.

    // The looping occurs in 3 phases.
    // A. Do part 1 only until there are 100 items or enum is complete.
    // B. Do part 1 and part 2 until the enum is complete.
    // C. Do part 2 only until the list is empty.
    // Note that it's possible to skip directly from phase A to C.

    while (1) // until goal is met or score list is empty
    {

        // PART 1 OF LOOP: Enumerate another item from the cache.

        HASH_ITEM* pItem = HashGetNextItem
            (_UrlObjStorage, *_UrlObjStorage->GetHeapStart(), &dwEnum, fPurge);

        if (pItem)
        {
            // Validate offset.
            if (_UrlObjStorage->IsBadOffset (pItem->dwOffset))
            {
                pItem->MarkFree();
                continue;
            }

            // Get the signature.
            FILEMAP_ENTRY* pBlock = (FILEMAP_ENTRY*)
                (((LPBYTE) *_UrlObjStorage->GetHeapStart()) + pItem->dwOffset);

            if (pBlock->dwSig != SIG_URL)
            {
                if (fPurge && (pBlock->dwSig == SIG_REDIR))
                    _UrlObjStorage->FreeEntry (pBlock);
                else
                    INET_ASSERT (pBlock->dwSig == SIG_LEAK );

                pItem->MarkFree();
                continue;
            }

            // Filter out items exempt from scavenging.
            URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) pBlock;

            // The entry should not be from an uplevel cache, or
            // we ought to be deferring to its scavenger.
            INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));
            
            if (IsUrlEntryExemptFromScavenging
                (pItem, pEntry, dwFilter, qwGmtTime, &gm))
            {
#ifdef SCAVENGER_TRACE
                if (dwFactor == TRACE_FACTOR)
                {
                    char szBuf[1024];
                    wsprintf (szBuf, "EXEMPT %s\n",
                        ((LPSTR) pEntry) + pEntry->UrlNameOffset);
                    OutputDebugString (szBuf);
                }
#endif
                continue;
            }

            // If we are deleting all items, no need to score.
            if (dwFactor==100)
            {
                if (ScavengeItem (pItem, &fMustUnlock))
                    continue;
                else
                    goto done;
            }

            // If we've fallen below the 4MB threshold, we won't exempt anything from 
            // scavenging.

            // Otherwise, we look at the size of the item. If its size is greater than
            // whatever 90% of the cache quota is (arbitrary), then we won't scavenge it
            // for this session. 

            // For all other instances, we won't scavenge items we've seen in the past
            // ten minutes.

            if (!fLowDiskSpace)
            {
                if (((LONGLONG)pEntry->dwFileSize > (LONGLONG)((LONGLONG)(qwQuota * (LONGLONG)9)/(LONGLONG)10))
                    && (dwdwSessionStartTime < pEntry->LastAccessedTime))
                    continue;
                
                if (qwGmtTime < (pEntry->LastAccessedTime + (LONGLONG)(GlobalScavengeFileLifeTime*FILETIME_SEC)))
                    continue;
            }
            
            // Otherwise score the entry.
            SCORE_ITEM* pScoreItem = ScoreList + cScore;

            pScoreItem->dwScore = ScoreEntry (pEntry, qwGmtTime);

#ifdef UNIX
            if (!pScoreItem->dwScore)
               continue;
#endif /* UNIX */

            // Add to the list.
            pScoreItem->dwItemOffset =          // 64BIT
                (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart());
            pScoreItem->dwHashValue  = pItem->GetValue();
            pScoreItem->dwHashOffset = pItem->dwOffset;

             // Check if list is full.
            if (++cScore != NUM_SCORE_ITEMS)
                continue;

            if (!dwCutoffScore)
            {
                // Establish a cutoff score.
                SortScoreItems (ScoreList, cScore);
                DWORD nIndex; // of item used as cutoff

                switch (dwFactor)
                {
                    case DEFAULT_CLEANUP_FACTOR:
#ifdef SCAVENGER_TRACE
                    case TRACE_FACTOR:
#endif
                        nIndex = NUM_SCORE_ITEMS / 5;
                        break;

                    default:
                        nIndex = (NUM_SCORE_ITEMS * dwFactor) / 100;
                        break;
                }

                dwCutoffScore = ScoreList[nIndex].dwScore;
            }
        } // end if (pItem)

        // PART 2 OF LOOP: remove an item from the list

        // If enumeration complete and list is empty, then
        // break out of the infinite loop.
        if (!cScore)
            break;

        SCORE_ITEM *pScoreItem;

        // Is the score list full?
        if (cScore == NUM_SCORE_ITEMS)
        {
            // Find the highest scoring item.
            pScoreItem = FindMinOrMaxScoreItem
                (ScoreList, NUM_SCORE_ITEMS, FIND_MAX);
            if (pScoreItem->dwScore > dwCutoffScore)
            {
                ScavengerTrace (dwFactor, pScoreItem, NULL);

                // Some of the items are above the cutoff score.
                // Remove the highest-scoring item from the list
                // by swapping it to the end and reducing count.
                cScore--;
                SwapScoreItems (pScoreItem, ScoreList + cScore);
                continue;
            }
        }

        // Either the score list isn't full or all of the items
        // are below the cutoff score.  Delete lowest scoring item.
        pScoreItem = FindMinOrMaxScoreItem (ScoreList, cScore, FIND_MIN);

        // We yield the lock between deletes, so do some sanity
        // checking before attemptint to delete the item.
        pItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
        if (pScoreItem->dwHashValue == pItem->GetValue()
            && pScoreItem->dwHashOffset == pItem->dwOffset)
        {
            ScavengerTrace (dwFactor, pScoreItem, &qwDeleted);

            if (!ScavengeItem (pItem, &fMustUnlock))
                goto done;

            // If we met our goal, call it quits.
            if (dwFactor != 100 && _UrlObjStorage->GetCacheSize() < qwGoal)
                break;
        }

        // Remove the lowest-scoring item from the list.
        cScore--;
        SwapScoreItems (pScoreItem, ScoreList + cScore);

    } // end while (1)

    if( dwHWnd && dwUMsg && IsWindow((HWND)DWORD_PTR(dwHWnd)) )
    {
        PostMessage(
            (HWND)DWORD_PTR(dwHWnd),
            (UINT)dwUMsg,
            (WPARAM)CACHE_NOTIFY_DELETE_ALL,
            (LPARAM)0
        );
    }

done:
    if (fMustUnlock)
        UnlockContainer();
    return ERROR_SUCCESS;
}

VOID CacheScavenger(LPVOID Parameter)
/*++

Routine Description:

    This function is the main  function for the cache management scavenger
    thread. This function performs verious time critical operations.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    DWORD Error;
    DWORD WaitStatus;

    //StartCAP();

    // Set a global to indicate the thread is no longer suspended.
    LOCK_CACHE();
    if (!GlobalPleaseQuitWhatYouAreDoing)
    {
        UNLOCK_CACHE();

        // Why aren't we locking in this case?
        
        // Attempt to reduce the cache usage below the quota.
        GlobalUrlContainers->CleanupUrls (NULL, DEFAULT_CLEANUP_FACTOR, 0);

        // Clear a global to indicate the scavenger thread has exited.
        InterlockedDecrement(&GlobalScavengerRunning);

        LOCK_CACHE();
    }
    UNLOCK_CACHE();

    //StopCAP();
}


void LaunchScavenger (void)
{
#ifdef unix
    INET_ASSERT(!g_ReadOnlyCaches);
#endif /* unix */

    LOCK_CACHE(); 

    // only if scavenger is not already running.
    if (!InterlockedIncrement(&GlobalScavengerRunning))
    {
        // don't fire off new thread. Just queue scavenger as work item for
        // thread pool
        SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)CacheScavenger,
                            NULL,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0
                            );
    }
    else
    {
        InterlockedDecrement(&GlobalScavengerRunning);
    }
    
    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\debug.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    Contains debug functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#if DBG


#include <windows.h>
#include <winnt.h>

#include <stdlib.h>
#include <stdio.h>
#include <debug.h>



VOID
InternetDebugPrintValist(
    IN LPSTR Format,
    va_list list
    );

extern BOOL UrlcacheDebugEnabled;

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    )

{
    va_list arglist;

#if 0
    if (!UrlcacheDebugEnabled) {

        return;

    }
#endif //0

    va_start(arglist, Format);

    InternetDebugPrintValist(Format, arglist);

    va_end(arglist);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\filemgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  filemgr.cxx

Abstract:

    Manages cache file & directory creation/deletion.

Author:
    Adriaan Canter (adriaanc) 04-02-97

Modifications:
    Ahsan Kabir (akabir) 25-Sept-97 made minor alterations.
    
--*/

#include <wininetp.h>
#include <cache.hxx>
#define WWW_DOT "www."

#define MAP_KEY_TO_PATH    0
#define MAP_PATH_TO_KEY    1


//
//==================== CFileMgr Public Functions =============================
//


/*-----------------------------------------------------------------------------
CFileMgr::CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::CFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : _mmFile(mmFile), _dwOptions(dwOptions)
{
    INET_ASSERT(_mmFile);

    // GetFullPathNameLen includes trailing backslash.
    _cbBasePathLen = _mmFile->GetFullPathNameLen();
}


/*-----------------------------------------------------------------------------
CFileMgr::~CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::~CFileMgr()
{}


/*-----------------------------------------------------------------------------
virtual CFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CFileMgr::Init()
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual GetDirLen
Returns length of cache dir path.
----------------------------------------------------------------------------*/
DWORD CFileMgr::GetDirLen(DWORD nKey)
{
    return _cbBasePathLen;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::CreateUniqueFile
Generates cache files.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedLength, LPTSTR szFileName,
                                LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    return CreateUniqueFile((LPCSTR) szUrl, (DWORD) dwExpectedLength, (LPTSTR) _mmFile->GetFullPathName(),
        (LPTSTR) szFileName, (LPTSTR) szFileExtension, (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::NotifyCommit
No-op.
----------------------------------------------------------------------------*/
BOOL CFileMgr::NotifyCommit(DWORD nDirIndex)
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
CFileMgr::DeleteCache
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteCache(LPSTR szRoot)
{
    BOOL fHasCacheVu = IsValidCacheSubDir(szRoot);

    if ( fHasCacheVu)
        DisableCacheVu(szRoot);
        
    if (DeleteCachedFilesInDir(szRoot) == ERROR_SUCCESS)
    {
        SetFileAttributes(szRoot, FILE_ATTRIBUTE_DIRECTORY);
        RemoveDirectory(szRoot);
    }

    if( fHasCacheVu)
        EnableCacheVu( szRoot);
    
    return TRUE;
}

/*-----------------------------------------------------------------------------
CFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CFileMgr::Cleanup()
{
    return TRUE;
}

/*-----------------------------------------------------------------------------
virtual CFileMgr::GetDirIndex
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetDirIndex(LPSTR szFilePath, LPDWORD pnIndex)
{
    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                    LPSTR szSubDirPath, LPDWORD pcb)
{
    INET_ASSERT(pEntry && szSubDirPath && pcb && *pcb);

    // "anyuser@msn.txt"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);

    // Lengths of path and file.
    DWORD cbFile = strlen(szFile);
    DWORD cbPath = _mmFile->GetFullPathNameLen();

    // Don't overflow output buffer.
    DWORD cbSubDirPath = cbPath + cbFile;
    if (cbSubDirPath + 1 > *pcb)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // "C:\Windows\Profiles\anyuser\Cookies\"
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cbPath);

    // "C:\Windows\Profiles\anyuser\Cookies\anyuser@msn.txt"
    memcpy(szSubDirPath + cbPath, szFile, cbFile + 1);

    *pcb = cbSubDirPath;

    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::DeleteOneCachedFile
Deletes a single cache file given the absolute path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                                   DWORD dostEntry, DWORD nIndex)
{
    return ::DeleteOneCachedFile(lpszFileName, dostEntry);
}


/*-----------------------------------------------------------------------------
    virtual BOOL  CreateDirWithSecureName( LPSTR);

Creates a cache directory with a given name to allow existing directories
to be copied into another cache file.  Just the eight letters of the new
directory are given.
----------------------------------------------------------------------------*/
BOOL CFileMgr::CreateDirWithSecureName( LPSTR szDirName)
{
    return _mmFile->CreateDirWithSecureName( szDirName);
}


//
//================== CFileMgr Protected Functions =============================
//

/*-----------------------------------------------------------------------------
CFileMgr::GetStoreDirectory
    Returns "%windir%\web\" - ie "C:\Windows\Web\" and length. There
    is currently only ONE store directory and this is it.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetStoreDirectory(LPSTR szPath, LPDWORD pcbPath)
{
    DWORD cb;

    // Hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szPath, MAX_PATH)) && cb<=MAX_PATH)
    {
        AppendSlashIfNecessary(szPath, &cb);
        memcpy(szPath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1;
        *pcbPath = cb;
        return TRUE;
    }
    INET_ASSERT(FALSE);
    return FALSE;
}

/*-----------------------------------------------------------------------------
CFileMgr::MapStoreKey
    Maps path to storage directory key (stored in the FILEMAP_ENTRY::DirIndex)
    or storage directory key to path (ie C:\Windows\Web\). There is currently
    only one key and it is INSTALLED_DIRECTORY_KEY. Mapping depends on dwFlag.
----------------------------------------------------------------------------*/
BOOL CFileMgr::MapStoreKey(LPSTR szPath, LPDWORD pcbPath, 
                           LPDWORD dwKey, DWORD dwFlag)
{
    DWORD cb;
    BOOL fReturn = FALSE;
    CHAR szStoreDir[MAX_PATH];

    // Must be able to get store dir in any case.
    if (GetStoreDirectory(szStoreDir, &cb))
    {
        // Mapping a path to a key requested.
        if (dwFlag == MAP_PATH_TO_KEY)
        {
            // Path matches?
            if ((*pcbPath == cb) 
                && !strnicmp(szStoreDir, szPath, cb))
            {
                // We only map one directory for now.
                *dwKey = INSTALLED_DIRECTORY_KEY;
                fReturn = TRUE;
            }
        }

        // Mapping a key to a path requested.    
        else if (dwFlag == MAP_KEY_TO_PATH)
        {
            if (*dwKey == INSTALLED_DIRECTORY_KEY)
            {
                memcpy(szPath, szStoreDir, cb+1);
                *pcbPath = cb;
                fReturn = TRUE;
            }
        }
    }
    //INET_ASSERT(fReturn);
    return fReturn;
}

/*-----------------------------------------------------------------------------
SetFileSize

Routine Description:  Set the expected file size of a newly created file

Arguments:

    hfHandle: pointer to the file handle

    dwExpectedLength: size of the file

Return Value:

----------------------------------------------------------------------------*/
VOID CFileMgr::SetFileSize(HANDLE hfHandle, DWORD dwExpectedLength) 
{
    DWORD dwFilePointer = 0;

    // Set the expected size of the file if necessary
    if (dwExpectedLength != 0) 
    {
        dwFilePointer = SetFilePointer(hfHandle, dwExpectedLength, NULL, FILE_BEGIN );
        if( dwFilePointer != INVALID_SET_FILE_POINTER )
        {
            SetEndOfFile( hfHandle );

            // reset the file pointer to the beginning of the file
            dwFilePointer = SetFilePointer(hfHandle, 0, NULL, FILE_BEGIN );
            INET_ASSERT (INVALID_SET_FILE_POINTER != dwFilePointer);
        }
    }
    return;
}
    

/*-----------------------------------------------------------------------------
CreateUniqueFile

Routine Description:

Arguments:

    UrlName : pointer to url name.

    Path : pointer to cache path.

    FileName : pointer to a buffer that receives the full path name of the
        newly created file.

    Extension : if specified the extension is used to make random file.

Return Value:

    Windows Error Code.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedLength,
								 LPTSTR Path, LPTSTR FileName, LPTSTR Extension, 
                                 HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD cbPath, cbName, cbFull;
    cbPath = strlen(Path);

    DWORD Error, len, lenExt=0;

    TCHAR RandomFileName[MAX_PATH];

    TCHAR FullFileName[MAX_PATH];

    HANDLE FileHandle;

    DWORD dwCollision = 0, dwTotalCollissionCount;
    char szHost[MAX_PATH], szUrl[INTERNET_MAX_PATH_LENGTH], szExtraInfo[MAX_PATH];
    URL_COMPONENTS sUrl;

    LPTSTR FileNamePtr = FileName, lpT;
    
    BOOL fUseFileName = FALSE, fPrettyName = FALSE;

    DWORD cbFileName;
    CHAR szExt[MAX_PATH];
    *szExt = '\0';  

    if (phfHandle)
        *phfHandle = INVALID_HANDLE_VALUE;
    
    // If a filename has been passed in attempt to use it.
    if (FileName[0] != '\0')
    {
        // Various checks to determine validity of name.

        // First strip any trailing whitespace.
        cbFileName = strlen(FileName);
        StripTrailingWhiteSpace(FileName, &cbFileName);

        // Check length.
        if (cbFileName < MAX_PATH)
        {            

            // '.' and '..' are illegal.
            if (memcmp(FileName, ".", sizeof("."))
                && memcmp(FileName, "..", sizeof("..")))
            {
                // slashes and backslashes are illegal.
                LPTSTR ptr = FileName;
                while (*ptr != '\0')
                {
                    if (IsDBCSLeadByte(*ptr))
                        ++ptr;
                    else
                    if (*ptr == '\\' || *ptr == '/')
                        break;
                    ptr++;
                }
                

                // Filename has no slashes in it.
                if (!*ptr)
                {
                    // Preliminary judgment. Creating
                    // this file could possibly fail,
                    // depending on further tests.
                    fUseFileName = TRUE;
                }
            }
        }
    }

    // Preliminary checks indicate valid filename.
    if (fUseFileName)
    {
        // Attempt to parse a file extension.

        CHAR* pExt = StrChr(FileName, '.');

        // Found a file extension delimiter.
        if (pExt)
        {
            // '.' but no extension (eg "foo.")
            if (*(pExt + 1) == '\0')
            {
                *pExt = '\0';
                len = cbFileName - 1;
            }

            // '.' at beginning (eg ".foo") Valid file, no extension.
            else if (pExt == FileName)
            {
                len = cbFileName;
            }

            // Common case (eg foo.bar)
            else
            {
                // Separate out the file extension w/o '.'
                lenExt = (DWORD) (cbFileName - (pExt - FileName) - 1);  // 64BIT
                memcpy(szExt, pExt+1, lenExt + 1);

                // Filename without extension.
                *pExt = '\0';
                len = (DWORD) (pExt - FileName);     // 64BIT
            }
        }     

        // No file extension found
        else
        {
            len = cbFileName;
        }
        fPrettyName = TRUE;
        goto have_file_name;
    }

    // No or bad filename passed in.
    else
    {
        // Copy over any extension passed in,
        // limiting the length as necessary.
        if (Extension)
        {
            lenExt = strlen(Extension);
            if (lenExt >= MAX_PATH)
            {
                lenExt = MAX_PATH - 1;
            }
            memcpy(szExt, Extension, lenExt);
            szExt[lenExt] = '\0';
        }
        else
        {
            *szExt = '\0';
            lenExt = 3;
        }
    }

    memset(&sUrl, 0, sizeof(sUrl));

    sUrl.dwStructSize = sizeof(sUrl);

    sUrl.lpszHostName = szHost;
    sUrl.dwHostNameLength = sizeof(szHost);

    sUrl.lpszUrlPath = szUrl;
    sUrl.dwUrlPathLength = sizeof(szUrl);


    sUrl.lpszExtraInfo = szExtraInfo;
    sUrl.dwExtraInfoLength = sizeof(szExtraInfo);

    // changed from InternetCrackUrl to WinHttpCrackUrlA
    if (WinHttpCrackUrlA(UrlName, lstrlen(UrlName), 0, &sUrl)) {
        fPrettyName = TRUE;

        if ((sUrl.dwUrlPathLength == 1) && (szUrl[0] == '/')) {

            FileNamePtr = szHost;
            len = sUrl.dwHostNameLength;

            // strip out www., this info is redundant

            if (!strnicmp(FileNamePtr, WWW_DOT, sizeof(WWW_DOT)-1)) {

                len -= (sizeof(WWW_DOT)-1);

                // copy the NULL terminator too

                memmove(FileNamePtr, FileNamePtr+sizeof(WWW_DOT)-1,len+1);

            }
        }
        else {

            FileNamePtr = szUrl;
            len = sUrl.dwUrlPathLength;

            // if there is a terminating slash let us fix it.
            // len-1 wont' break because we know the url is more than 1 char
            // Above assumption not valid.
            if (len && (FileNamePtr[len-1] == '/')) 
            {
                FileNamePtr[len-1] = 0;
                --len;
            }

            // get the tail
            if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '/'))
            {
                ++lpT;

                len = len - (DWORD)PtrDifference(lpT, FileNamePtr);

                //
                // truncate the FileNamePtr if it is too long -
                //   the "fudge-factor" number is to allow room for stuff like "[%d]"
                //    in the URL -- this number doesn't have to be accurate since
                //    the worst-case scenario is us using a random (ugly) filename.
                //
                unsigned int newlen = MAX_PATH - (cbPath + lenExt + 2 + /*fudge-factor*/5);

                if ((newlen > 2) && (newlen < len))
                {
                    // For UTF-8, we don't want to chop in the middle of a %XX
                    if (lpT[newlen - 2] == '%')
                        newlen -= 2;
                    else if (lpT[newlen - 1] == '%')
                        newlen -= 1;

                    len      = newlen;
                    lpT[len] = '\0';
                }

                // copy the NULL terminator as well
                memmove(FileNamePtr, lpT, len+1);
            }
		
            // Special hack for cookies: Ensure that the username is
            // prepended on to the filename. The preceding filename
            // generation code does not generate this for cookies
            // which specify paths in addition to domains.   
            if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
            {                
                // This is a cookie url of the form Cookie:username@domain/path
                if (GetWininetUserName())
                {
                    DWORD cb = vdwCurrentUserLen;
                    if (len + cb + 1 < MAX_PATH)
                    {
                        if (memcmp(FileNamePtr, vszCurrentUser, cb) 
                            || FileNamePtr[cb] != '@'
                            || FileNamePtr[cb+1] == '\0')
                        {
                            memmove(FileNamePtr + cb + 1, FileNamePtr, len+1);
                            FileNamePtr[cb] = '@';
                            memcpy(FileNamePtr, vszCurrentUser, cb);
                            len += cb + 1;
                        }
                    }
                }
            }
        
        }

        
        if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '.'))
        {
            *lpT = 0;
            len = (DWORD) PtrDifference(lpT, FileNamePtr);
        }

        // convert all invalid char (including '%') to '_'
        for(lpT = FileNamePtr; *lpT; ++lpT) 
        {
            if (IsDBCSLeadByte(*lpT))
                ++lpT;
            else if ((strchr(vszInvalidFilenameChars, *lpT))) 
                *lpT = '_';
        }

        if ((cbPath+len+lenExt+2) > MAX_PATH) {

            fPrettyName = FALSE;

        }
    }
    else {

        fPrettyName = FALSE;
    }


have_file_name:


    for(dwTotalCollissionCount = 0;
        dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS;
        dwTotalCollissionCount++) {


        //
        // make a random file name.
        //
        if (!fPrettyName) 
        {
            // If fUseFileName is TRUE, it means we've attempted to create
            // a file using the filename passed in and failed. We still want 
            // to create a cache file, but since the extension parsed from the
            // filename is also suspect, we want to create a cache filename
            // without any passed in extension, or NULL.
            if (fUseFileName)
            {
                if (Extension)
                {
                    lenExt = strlen(Extension);
                    memcpy(szExt, Extension, lenExt+1);
                }
                else
                {
                    lenExt = 0;
                    *szExt = '\0';
                }
            }

            Error = MakeRandomFileName(UrlName, RandomFileName, szExt);

        }
        else {

            DWORD digit;
            DWORD cb = strlen(FileNamePtr);
            memcpy(RandomFileName, FileNamePtr, cb+1);

            lpT = RandomFileName+len;

            // Always decorate the cache file name with [1-99]
            // We use square brackets instead of parens because
            // NT cmd shell barfs on parens.
            
            if (++dwCollision > 99)
            {
                fPrettyName = FALSE;
                continue;
            }

#ifndef UNIX
            if (fCreatePerUser && GlobalIdentity)
            {
                lpT += wsprintf (lpT, "[%d][%d]", GlobalIdentity, dwCollision);
            }
            else
            {
                lpT += wsprintf (lpT, "[%d]", dwCollision);
            }
#else
            /* Square brackets cause problems on UNIX */
            lpT += wsprintf (lpT, "(%d)", dwCollision);
#endif /* UNIX */
                
            if (*szExt)
            {
                *lpT++ = '.';
                memcpy(lpT, szExt, lenExt + 1);
            }
            
            Error = ERROR_SUCCESS;

        }

        if (Error != ERROR_SUCCESS) {
            INET_ASSERT(FALSE);
            return (Error);

        }

        cbName = strlen(RandomFileName);
        cbFull = cbPath + cbName + 1;

        if (cbFull > MAX_PATH)
        {
            INET_ASSERT(FALSE);
            return(ERROR_FILENAME_EXCED_RANGE);
        }
#ifndef UNIX
        // Hack for special DOS filenames:
        // aux.*, com[0-9].*, con.*, lpt[0-9].*, 
        // nul.* and prn.* on non-NT platforms.
        if (!IsPlatformWinNT())
        {
            DWORD cbMajor = cbName - lenExt;
            if (cbMajor == 4 || cbMajor == 5)
            {
                switch(tolower(*RandomFileName))
                {
                    // Test for aux.*
                    case 'a':
                    if (!strnicmp(RandomFileName + 1, "ux.", 3))
                    {
                        continue;
                    }
                    break;

                    // Test for com[0-9].* and con.*
                    case 'c':
                    if (tolower(RandomFileName[1]) == 'o')
                    {
                        CHAR c = tolower(RandomFileName[2]);
                        if (c == 'm')
                        {
                            if (isdigit(RandomFileName[3])
                                && RandomFileName[4] == '.')
                            {
                                continue;
                            }
                        }
                        else if (c == 'n')
                        {
                            if (RandomFileName[3] == '.')
                            {
                                continue;
                            }
                        }
                    }
                    break;
    
                    // Test for lpt[0-9].*
                    case 'l':
                    {
                        if (!strnicmp(RandomFileName + 1, "pt", 2)
                            && isdigit(RandomFileName[3])
                            && RandomFileName[4] == '.')
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for nul.*
                    case 'n':
                    {
                        if (!strnicmp(RandomFileName + 1, "ul.", 3))
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for prn.*
                    case 'p':
                    {
                        if (!strnicmp(RandomFileName + 1, "rn.", 3))
                        {
                            continue;
                        }
                        break;
                    }
                }
            }
        }
#endif /* !UNIX */

        // Make full path name.
        memcpy(FullFileName, Path, cbPath);
        memcpy(FullFileName + cbPath, RandomFileName, cbName + 1);

        // Check if this file exists.
        if (GetFileAttributes(FullFileName)!=0xffffffff) 
        {
            // A file or dir by this name exists.
            // This will also take care of special DOS filenames
            // on NT, which return !0xffffffff.
            continue;
        }



        FileHandle = CreateFile(
                        FullFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( FileHandle != INVALID_HANDLE_VALUE ) 
        {
            SetFileSize(FileHandle, ExpectedLength); 

            // successfully create a new file either return handle or close it and return.
            if ( phfHandle )
                *phfHandle = FileHandle;
            else
                CloseHandle( FileHandle );

            break;
        }
        else
        {
            // Couldn't create the file. This is possibly due to the file
            // already existing or to the fact that the directory was deleted.

            // Check for the existance of the directory:
            if (GetFileAttributes(Path) == 0xffffffff)
            {
                // Directory was deleted. Create one and then
                // create the file.
                if (CreateDirectory(Path, NULL))
                {
                    // Set system attribute.
                    SetFileAttributes(Path, FILE_ATTRIBUTE_SYSTEM);

                    // Enable cachevu in this directory
                    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                        EnableCacheVu(Path);

                    FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                    // We just created the directory and the
                    // child file, so the file handle should
                    // be valid.
                    if( FileHandle != INVALID_HANDLE_VALUE ) 
                    {
                        SetFileSize(FileHandle, ExpectedLength);

                        // successfully create a new file either return handle or close it and return.
                        if ( phfHandle )
                            *phfHandle = FileHandle;
                        else
                            CloseHandle( FileHandle );

                        break;
                    }
                }
            }
        }

        Error = GetLastError();

        if( Error != ERROR_FILE_EXISTS )
        {
            if (!fPrettyName)
            {
                INET_ASSERT(FALSE);
                return( Error );
            }
            else
            {
                fPrettyName = FALSE;
                Error = ERROR_SUCCESS;
            }
        }
        else {

            // We found that the file exists
            // if it is zero size, let us just use it.
            // this in itself is an unlikely occurrence
            // but we any way try to work around the IBM virus software

            // ACHTUNG!!! this is a special hack for IBM antivirus software

            FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

            if (FileHandle != INVALID_HANDLE_VALUE) {

                // this looks usable
                if (GetFileSize(FileHandle, NULL) == 0)
                {
                    if (phfHandle)
                        *phfHandle = FileHandle;
                    else
                        CloseHandle( FileHandle );
                    break;
                }
                    
                CloseHandle( FileHandle );
                INET_ASSERT(FALSE);
            }
            return (ERROR_DISK_FULL);
        }

        //
        // try another random file.
        //
    } // end of the for loop

    if (dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS) {

        memcpy(FileName, FullFileName, cbFull);
        return( ERROR_SUCCESS );

    }
    else {
        INET_ASSERT(FALSE);
        return (ERROR_DISK_OPERATION_FAILED);

    }
}

/*-----------------------------------------------------------------------------
MakeRandomFileName

  Routine Description:

    Creates a random 8.3 file name. The format of the name will be as
    below:

        ca(0-99999).(0-999)

    Ex ca19200.340
    Ex ca19354.tmp - if an extension (tmp) is specified.

Arguments:

    UrlName : pointer to an URL string

    FileName : pointer to a string buffer where the random file name is
        returned. The buffer length must be atleast 8+3+1+1= 13 wchars.

    Extension : pointer to an extension string. if this is non-NULL, then
        the specified extension is used otherwise random extension as
        explained above is used.

Return Value:

    none.
----------------------------------------------------------------------------*/
DWORD CFileMgr::MakeRandomFileName(LPCSTR UrlName,
                                      LPTSTR FileName, LPTSTR Extension)
{
    DWORD RandNum;
    LPTSTR FileNamePtr = FileName;
    static Counter;
    DWORD i;
    DWORD cbExtension = 0;

    if (Extension)
        cbExtension = lstrlen(Extension) + 1;

    if (cbExtension > (MAX_PATH-(8+1)))
    {
        return(ERROR_FILENAME_EXCED_RANGE);
    }

    // Additional special hack for cookie urls.

    if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
    {                
        // This is a cookie url of the form Cookie:username@domain/path
        if (GetWininetUserName())
        {
          DWORD cb = vdwCurrentUserLen;
          
          if (cb + 8 + cbExtension + 1 < MAX_PATH)
          {
              memcpy(FileName, vszCurrentUser, cb);
              FileName[cb] = '@';
              FileNamePtr += (cb + 1);
          }
        }
    }

    
    // Check that the total name doesn't exceed MAX_PATH
    // Our total name is 8 chars basename + a dot + the extension + 0


    *FileNamePtr++ = L'C';
    *FileNamePtr++ = L'A';

    //
    // generate a six digits random string;
    //

    //
    // We can't use rand() alone to generate a random number because it will
    // repeat the same sequence for each new thread that comes in.  We can't
    // use the TickCount alone because it is a little too predicable.  But
    // the two combined should be nice.  Adding in Counter will take care of
    // the case of two brand-new threads coming in at the same time.
    //


    for ( i = 0; i < 6; i++) {
        UINT digit;

        RandNum = (GetTickCount() * rand()) + Counter++;

        digit = RandNum % 36; // 10 digits + 26 letters

        *FileNamePtr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *FileNamePtr++ = L'.';
  
    
    //
    // if an extension is specified, use it.
    //
    if( Extension != NULL )
    {
        // if a 0 extension if provided, we will create a
        // file with no extension
        memcpy(FileNamePtr, Extension, cbExtension);
        return ERROR_SUCCESS;
    }

    // Append default file extension.
    memcpy(FileNamePtr, DEFAULT_FILE_EXTENSION, sizeof(DEFAULT_FILE_EXTENSION));
    return ERROR_SUCCESS;
}






//
//===================== CSecFileMgr Public Functions ==========================
//


/*-----------------------------------------------------------------------------
CSecFileMgr::CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::CSecFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : CFileMgr(mmFile, dwOptions)
{
    INET_ASSERT(_mmFile);

    // BUGBUG - have to guard against getting out of sync with dirs.
    if (_mmFile->GetDirCount() == 0)
        Init();
}


/*-----------------------------------------------------------------------------
CSecFileMgr::~CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::~CSecFileMgr()
{}


/*-----------------------------------------------------------------------------
CSecFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Init()
{
    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(_mmFile->GetFullPathName());

    return CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
}


/*-----------------------------------------------------------------------------
GetDirLen()
Returns cache dir path length.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::GetDirLen(DWORD nKey)
{
    DWORD cb = 0;

    if (nKey < DEFAULT_MAX_DIRS)
    {    
        // + 1 to account for trailing backslash.
        cb = _cbBasePathLen + DIR_NAME_SIZE + 1;
    }
    else
    {
        CHAR szStoreDir[MAX_PATH];
        GetStoreDirectory(szStoreDir, &cb);
    }
    INET_ASSERT(cb);
    return cb;
}

/*-----------------------------------------------------------------------------
CSecFileMgr::CreateUniqueFile
Creates a cache file.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::CreateUniqueFile(LPCSTR szUrl, DWORD dwExpectedLength, LPTSTR szFileName,
                                   LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD nDir, nFiles;
    DWORD nDirCount = _mmFile->GetDirCount();

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    FindMinFilesSubDir(nDir, nFiles);

    if (nFiles >= MAX_FILES_PER_CACHE_DIRECTORY
        && nDirCount < DEFAULT_MAX_DIRS)
    {
        if (CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE))
            nDir++;
    }

    // Get the cache path and subdirectory
    // from the memory mapped file
    CHAR szSubDirPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cb);

    _mmFile->GetDirName(nDir, szSubDirPath + cb);
    memcpy(szSubDirPath + cb + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    return CFileMgr::CreateUniqueFile((LPCSTR) szUrl, dwExpectedLength, (LPTSTR) szSubDirPath,
                                      (LPTSTR) szFileName, (LPTSTR) szFileExtension,
                                      (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
CSecFileMgr::NotifyCommit
Tracks committed cache file counts.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::NotifyCommit(DWORD nDirIndex)
{
    INET_ASSERT(_mmFile->GetDirCount() <= DEFAULT_MAX_DIRS);

    // Regular random subdir
    if (nDirIndex < _mmFile->GetDirCount())
    {
        _mmFile->IncrementFileCount(nDirIndex);
        return TRUE;
    }
    // Not a directory.
    else if (nDirIndex == NOT_A_CACHE_SUBDIRECTORY)
    {
        //INET_ASSERT(FALSE);
        //return FALSE;
        // May be an absolute path EDITED_CACHE_ENTRY so pass
        return TRUE;
    }

    // Otherwise this had better be an installed directory.
    INET_ASSERT(nDirIndex == INSTALLED_DIRECTORY_KEY);
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Cleanup()
{

    CHAR szPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szPath, _mmFile->GetFullPathName(), cb+1);

    if (!AppendSlashIfNecessary(szPath, &cb))
        return FALSE;

    memcpy(szPath + cb, "*.*", sizeof("*.*"));

    WIN32_FIND_DATA fd;

    HANDLE handle = FindFirstFile(szPath, &fd);

    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            && (strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..")))
        {
            memcpy(szPath + cb, fd.cFileName, strlen(fd.cFileName) + 1);

            // Only delete directory if it is a valid subdirectory.
            if (IsValidCacheSubDir(szPath))
            {
                if (_mmFile->GetDirIndex(szPath) == NOT_A_CACHE_SUBDIRECTORY)
                {
                    DisableCacheVu(szPath);
                    if (DeleteCachedFilesInDir(szPath) == ERROR_SUCCESS)
                    {
                        SetFileAttributes(szPath, FILE_ATTRIBUTE_DIRECTORY);
                        RemoveDirectory(szPath);
                    }
                }
            }
        }
    } while (FindNextFile(handle, &fd));


    FindClose(handle);

  return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::GetDirIndex
Returns index of random cache subdirectory from an absolute file path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetDirIndex(LPSTR szAbsPath, LPDWORD pnIndex)
{
    BOOL fReturn = FALSE;
    DWORD idx;

    INET_ASSERT(pnIndex);

    if (szAbsPath && *szAbsPath)
    {
        // First look in mem map file for regular dir.
        idx = _mmFile->GetDirIndex(szAbsPath);

        // If didn't find it in the mem map file,
        // check if it is the storage directory.
        if (idx == NOT_A_CACHE_SUBDIRECTORY)
        {
            // First we need to find the path to the file sans \filename.ext
            DWORD cbAbsPath = strlen(szAbsPath);
            LPSTR ptr = StrRChr(szAbsPath, szAbsPath + cbAbsPath, DIR_SEPARATOR_CHAR);
            if (ptr)
            {
                // Separate path from filename and attempt to map.
                // Note - trailing slash is included in path mapped.
                DWORD cbPath = (DWORD) (ptr - szAbsPath + 1);   // 64BIT
                if (MapStoreKey(szAbsPath, &cbPath, &idx, MAP_PATH_TO_KEY))
                {
                    *pnIndex = idx;
                    fReturn = TRUE;
                }
                // Must be an EDITED_CACHE_ENTRY set at an absolute path so just update the idx and fail
                else
                {
                    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
                }
            }
        }

        // Otherwise, this should be a valid cache subdirectory.
        else
        {
            *pnIndex = idx;
            fReturn = TRUE;
        }
    }
    else
    {
        *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    }
    
    return fReturn;
}



/*-----------------------------------------------------------------------------
CSecFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                       LPSTR szAbsPath, LPDWORD pcb)
{
    DWORD cbSubDirPath, cbFile;

    INET_ASSERT(pEntry && szAbsPath && pcb && *pcb);
    
    // Get file name and length - eg "default.html"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);
    cbFile = strlen(szFile);
    
    // Make real time check?
    if (cbFile && (cbFile < MAX_PATH))
    {
        // Does entry reside in on of the random subdirs?
        if (pEntry->DirIndex != NOT_A_CACHE_SUBDIRECTORY 
            && pEntry->DirIndex < DEFAULT_MAX_DIRS)
        {
            // Path length.
            DWORD cbFull = _mmFile->GetFullPathNameLen();

            // Don't overflow output buffer.
            cbSubDirPath =
                  cbFull
                + DIR_NAME_SIZE
                + sizeof(DIR_SEPARATOR_STRING) - 1
                + cbFile;

            if (cbSubDirPath + 1 > *pcb)
            {
                // INET_ASSERT(FALSE);
                return FALSE;
            }

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\"
            memcpy(szAbsPath, _mmFile->GetFullPathName(), cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7"
            _mmFile->GetDirName(pEntry->DirIndex, szAbsPath + cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof (DIR_SEPARATOR_STRING));

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\default.htm"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE + sizeof(DIR_SEPARATOR_STRING) - 1, szFile, cbFile + 1);
        }
     
        // There is no cache subdirectory which has been can be mapped
        // from the index. See if there is an existing store mapping.
        else
        {

            if (pEntry->DirIndex == NOT_A_CACHE_SUBDIRECTORY) 
            // Assume an ECE absolute path item as AddURL only writes NACS entries with ECE set
            {
                cbSubDirPath = cbFile + 1;  // Add terminator to size
                if (cbSubDirPath > *pcb)
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
                memcpy(szAbsPath, szFile, cbSubDirPath);
            }
            else
            {

                INET_ASSERT(pEntry->DirIndex == INSTALLED_DIRECTORY_KEY);
        
                DWORD cbPath = 0;
                DWORD dwIndex = INSTALLED_DIRECTORY_KEY;
                if (MapStoreKey(szAbsPath, &cbPath, &dwIndex, MAP_KEY_TO_PATH))
                {
                    // "C:\Winnt\Web\"
                    cbSubDirPath = cbPath + cbFile;
                    if (cbSubDirPath + 1 > *pcb)
                    {
                        INET_ASSERT(FALSE);                
                        return FALSE;
                    }
                    // "C:\Winnt\Web\default.html"
                    memcpy(szAbsPath + cbPath, szFile, cbFile + 1);
                }
                else
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
            }            
            
        }

        // Hand out the absolute path to the file.
        *pcb = cbSubDirPath;
        
        return TRUE;
    }

    INET_ASSERT(FALSE);
    return FALSE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::DeleteOneCachedFile
Deletes one cache file and decrements the file count.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                         DWORD dostEntry, DWORD nDirIndex)
{
    if (!::DeleteOneCachedFile(lpszFileName, dostEntry))
        return FALSE;

    INET_ASSERT(nDirIndex != NOT_A_CACHE_SUBDIRECTORY);
    _mmFile->DecrementFileCount(nDirIndex);

    return TRUE;
}



//
//==================== CSecFileMgr Protected Functions =======================
//



/*-----------------------------------------------------------------------------
CSecFileMgr::CreateRandomDirName
Creates a random subdirectory name under the root container path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateRandomDirName(LPSTR szDirName)
{
    DWORD RandNum;
    LPSTR ptr = szDirName;
    static Counter;

    INET_ASSERT(szDirName);

    // Stolen from MakeRandomFileName.
    for (DWORD i = 0; i < DIR_NAME_SIZE; i++)
    {
        UINT digit;
        RandNum = (GetTickCount() * rand()) + Counter++;

        // 10 digits + 26 letters
        digit = RandNum % 36;
        *ptr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *ptr = '\0';

    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateAdditionalSubDirectories
Creates nAdditionalDirs random subdirectories, up to DEFAULT_MAX_DIRS.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateAdditionalSubDirectories(DWORD nAdditionalDirs)
{
    DWORD nTotalDirs;
    DWORD nDirCount = _mmFile->GetDirCount();
    BOOL bSuccess = TRUE;

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    // Don't create more than the max allowed dirs.
    nTotalDirs = nAdditionalDirs + nDirCount;
    INET_ASSERT(nTotalDirs <= DEFAULT_MAX_DIRS);

    // Create the dir and set the file count to 0.
    DWORD i = nDirCount;
    DWORD nTotalTries = 0;
    do
    {
        if (CreateSubDirectory(i))
        {
            _mmFile->SetFileCount(i, 0);
            _mmFile->IncrementDirCount();
            i++;
        }
        else
        {
            INET_ASSERT(FALSE);
            bSuccess = FALSE;
        }

        if (nTotalTries++ > 100)
        {
            bSuccess = FALSE;
            break;
        }

    } while (i < nTotalDirs);

    return bSuccess;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateSubDirectory(DWORD nIdx)
Actual creation of subdirectory.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateSubDirectory(DWORD nIdx)
{
    CHAR szCacheDir[MAX_PATH];
    CHAR szSubDir[DIR_NAME_SIZE + 1];

    // Generate full path to random dir.
    CreateRandomDirName(szSubDir);
    DWORD cb = _mmFile->GetFullPathNameLen();

    memcpy(szCacheDir, _mmFile->GetFullPathName(), cb);
    memcpy(szCacheDir + cb, szSubDir, DIR_NAME_SIZE + 1);

    // Create the directory and add it to
    // the list of directories in the index.
    if (CreateDirectory(szCacheDir, NULL))
    {
        _mmFile->SetDirName(nIdx, szSubDir);

        // For cachevu must be hidden and system.
        // BUGBUG - sure it must be hidden?
        SetFileAttributes(szCacheDir, FILE_ATTRIBUTE_SYSTEM);

        if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
           EnableCacheVu(szCacheDir);

    }
    else
    {
        // Couldn't create the directory.
        INET_ASSERT(FALSE);
        return FALSE;
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::FindMinFilesSubDir
Determines the cache subdirectory with the minimum file count for load balancing.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::FindMinFilesSubDir(DWORD& nMinFileDir, DWORD& nFiles)
{
    DWORD nDirCount = _mmFile->GetDirCount();

    if (nDirCount == 0 || nDirCount > DEFAULT_MAX_DIRS)
    {
        INET_ASSERT(FALSE);
        _mmFile->SetDirCount(0);
        CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
        nDirCount = _mmFile->GetDirCount();
    }

    nMinFileDir = 0;
    DWORD nMinFiles = _mmFile->GetFileCount(0);

    for (DWORD i = 1; i < nDirCount; i++)
    {
        if (_mmFile->GetFileCount(i) < nMinFiles)
        {
            nMinFiles = _mmFile->GetFileCount(i);
            nMinFileDir = i;
        }

    }
    nFiles = _mmFile->GetFileCount(nMinFileDir);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\filemap.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    filemap.cxx

Abstract:

    contains implementation of MEMMAP_FILE class.

Author:

    Madan Appiah (madana)  28-April-1995

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of (7/6/96)

    1) Fix crossproces problems on win95 in checksizegrowandremap
    2) Exception handling to deal with badsector being memorymapped
    3) More robust validation at init time
    4) Reinitialization code to really clear the cache
    5) Bug fixes in GrowMap while growing partially filled dword

--*/

#include <wininetp.h>
#include <cache.hxx>


#define FILE_SIZE_MAX_DIGITS 16


DWORD
ValidateAndCreatePath(
    LPTSTR PathName
    )
{
    DWORD Error, len;
    DWORD FileAttribute;
    LPTSTR PathDelimit;

    //
    // check to see the path specified is there.
    //

    FileAttribute = GetFileAttributes( PathName );

    if( FileAttribute != 0xFFFFFFFF ) {

        //
        // check to see the attribute says it is a dir.
        //

        if( !(FileAttribute & FILE_ATTRIBUTE_DIRECTORY) ) {
            
            return( ERROR_INVALID_PARAMETER );
        }

        // We found the file and it is a dir.
        // Set the system attribute just in case
        // it has been unset.
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( (Error != ERROR_FILE_NOT_FOUND) &&
        (Error != ERROR_PATH_NOT_FOUND) ) {

        return( Error );
    }

    //
    // we did not find the path, so create it.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( Error != ERROR_PATH_NOT_FOUND ) {

        return( Error );
    }

    //
    // sub-path is not found, create it first.
    //

    len = lstrlen( PathName );

    if (len < 5) {

        SetLastError(ERROR_INVALID_NAME);

        return (ERROR_INVALID_NAME);
    }

    PathDelimit = PathName + len -1 ;

    // step back from the trailing backslash

    if( *PathDelimit == PATH_CONNECT_CHAR ) {
        PathDelimit--;
    }

    //
    // find the last path delimiter.
    //

    while( PathDelimit >  PathName ) {
        if( *PathDelimit == PATH_CONNECT_CHAR ) {
            break;
        }

        PathDelimit--;
    }

    if( PathDelimit == PathName ) {
        return( ERROR_INVALID_PARAMETER );
    }

    *PathDelimit = TEXT('\0');

    //
    // validate sub-path now.
    //

    Error = ValidateAndCreatePath( PathName ) ;

    //
    // replace the connect char anyway.
    //

    *PathDelimit = PATH_CONNECT_CHAR;

    if( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // try to create one more time.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //

        return( ERROR_SUCCESS );
    }

    Error = GetLastError();
    return( Error );
}


DWORD
MEMMAP_FILE::CheckSizeGrowAndRemapAddress(
    VOID
    )
{
    DWORD dwNewFileSize;

#ifdef WIN95_BUG
    if( _FileSize == (dwNewFileSize = _HeaderInfo->FileSize )) {
        return( ERROR_SUCCESS );
    }
#endif //WIN95_BUG

    // ideally we would have liked to do as in the above two lines
    // this works right on NT but doesn't on win95.

    // This is because the filesize is a part of the mapname
    // In the initial state the index file size is 8192. So the
    // memorymap name is c:_windows_temporaray internet files_8192.
    // Both the processes have this map in their address space.
    // Process B starts pumping in the data, and at some point the index
    // file needs to be grown. Process B, increases the index file to 16384,
    // updates the filesize in the header "while it is still mapped in the
    // map corresponding to the old filesize" and then remaps to the new map
    // with the name c:_windows_temporaray internet files_16384.
    // Any subsequent growth is now recorded in this map.
    // The old map c:_windows_temporaray internet files_8192 still has only
    // the first transition.


    // the work around is to actually get the filesize from the filesystem
    // This works correctly on win95 and NT both. Optimally, we would
    // check for a transition and then get the real size, but we will do that
    // after IE30 ships.



    //NB!!!!!!! The check below is the basis of our cross process
    // cache. All APIs finally make this call before touching the memory
    // mapped file. If there is a chneg, they remap it to the new size
    // with the sizename as part of the mapping, so they get the latest
    // stuff.
    // When anyone gets here, they are protected by a crossprocess mutex


    if( _FileSize == (dwNewFileSize = GetFileSize(_FileHandle, NULL))) {
        return( ERROR_SUCCESS );
    }

    //
    // so other user of the memmap file has increased the file size,
    // let's remap our address space so that the new portion is
    // visible to us too.
    //

    DWORD Error;
    DWORD OldFileSize;
    DWORD OldNumBitMapDWords;

   //
   // set our internal file size and num bit map entries.
   //

    OldFileSize = _FileSize;
    OldNumBitMapDWords = _NumBitMapDWords;


    _FileSize = dwNewFileSize;

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        //
        // reset the file size.
        //

        _FileSize = OldFileSize;
        _NumBitMapDWords = OldNumBitMapDWords;
    }
    else {

#if INET_DEBUG
        if ((GetFileSize(_FileHandle, NULL)) != (_HeaderInfo->FileSize)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);

        }
#endif //INET_DEBG

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

    return( Error );
}

BOOL
MEMMAP_FILE::ValidateCache(
    VOID
    )
/*++

    This private member function validates the cache file content.

Arguments:

    NONE.

Return Value:

    TRUE - if the cache is valid.
     FALSE - otherwise.

--*/
{
    BOOL ReturnCode = FALSE;
    int i, k;
    DWORD BitPosition, TotalAlloced, MaxAllocedPosition, RunningCounter;


    __try {

        // validate signatue.
        if( memcmp(
                _HeaderInfo->FileSignature,
                CACHE_SIGNATURE,
                MAX_SIG_SIZE * sizeof(TCHAR) ) != 0 ) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "File signature does not match.\n" ));
            goto Cleanup;
        }

        // Also check the index does not contain entries with a higher
        // version than the current machine can handle.  This can happen
        // due to Windows kludgy concept of roaming, which replicates 
        // parts of the file system and registry hkcu.
        
        LPSTR pszHighVer = (LPSTR) (_HeaderInfo->dwHeaderData
            + CACHE_HEADER_DATA_HIGH_VERSION_STRING);
        if (pszHighVer[0] != 'V' || pszHighVer[3] != 0)
            memset (pszHighVer, 0, sizeof(DWORD));
        else if (!g_szFixup[0] || strcmp (g_szFixup, pszHighVer) < 0)
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Cannot handle uplevel index file.\n" ));
            goto Cleanup;
        }

        // check the hash table root offset is valid
        if( _HeaderInfo->dwHashTableOffset != 0 ) {

            if( _HeaderInfo->dwHashTableOffset > _FileSize ) {
                TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "invalid b-tree root offset.\n" ));
                goto Cleanup;
            }
        }

        // check file size.
        if( _HeaderInfo->FileSize != _FileSize ) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "invalid file size.\n" ));
            goto Cleanup;
        }

        // one more file size check.
        DWORD ExpectedFileSize;
        ExpectedFileSize =
            HEADER_ENTRY_SIZE +
                _HeaderInfo->NumUrlInternalEntries * _EntrySize;

        // cell the size to GlobalMapFileGrowSize.
        if( ExpectedFileSize % GlobalMapFileGrowSize ) {
                ExpectedFileSize =
                ((ExpectedFileSize /  GlobalMapFileGrowSize) + 1) *
                        GlobalMapFileGrowSize;
        }

        if( _FileSize != ExpectedFileSize ) {

            // it is ok if the file size is one block bigger.
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid file size.\n" ));
            goto Cleanup;
        }


        if(_HeaderInfo->NumUrlInternalEntries < _HeaderInfo->NumUrlEntriesAlloced) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc entires.\n" ));
            goto Cleanup;
        }


        TotalAlloced = 0;
        MaxAllocedPosition = 0;
        RunningCounter = 0;

        // scan the enire bitmap and do some consistency check for allocated bits
        for(i=0; i<BIT_MAP_ARRAY_SIZE; ++i) {
            // k goes from 0 to 31
            // BitPosition goes from 0x00000001 to 0x80000000

            for(BitPosition=1, k=0; k<NUM_BITS_IN_DWORD; ++k, BitPosition <<=1) {

                ++RunningCounter;
                if(_HeaderInfo->AllocationBitMap[i] & BitPosition) {

                    ++TotalAlloced;

                    MaxAllocedPosition = RunningCounter;

                }

            }
        }

        // if the max allocated bit is greter than the number of
        // possible entries for this filesize,
        // or the total allocated bits are greater (the above condition subsumes
        // this one, but it is OK to be paranoid)
        // or totalbits alloced don't match the count
        // there this header is not OK

        if ((MaxAllocedPosition > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced != _HeaderInfo->NumUrlEntriesAlloced)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc bitmap\n" ));
            goto Cleanup;

        }
        //
        // every thing is fine.
        //

        ReturnCode = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        ReturnCode = FALSE;

        _Status = ERROR_WRITE_FAULT;
    }
    ENDEXCEPT

Cleanup:

    if( ReturnCode == FALSE ) {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE, "Invalid Cache, or bad disk\n" ));
    }

    return( ReturnCode );
}

void MEMMAP_FILE::CloseMapping (void)
{
    if (_BaseAddr) // view
    {
        UnmapViewOfFile(_BaseAddr);
        _BaseAddr = NULL;
    }
    if (_FileMappingHandle) // mapping
    {
        CloseHandle (_FileMappingHandle);
        _FileMappingHandle = NULL;
    }
    if (_FileHandle) // file
    {
        CloseHandle (_FileHandle);
        _FileHandle = NULL;
    }
}


DWORD
MEMMAP_FILE::RemapAddress(
    VOID
    )
/*++

    This private member function remaps the memory mapped file just after
    the file size has been modified.

    Container must be locked when this function is called.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PVOID OldBaseAddr;
    DWORD OldViewSize;
    PVOID VirtualBase;
    BOOL BoolError;
    LPTSTR MapName = NULL;
    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();

    CloseMapping();
    
    //
    // Create/Open memory mapped file.
    //

    if (psa)
    {
        _FileHandle =
            CreateFile(
                _FileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                    // share this file with others while it is being used.
                psa,
                OPEN_ALWAYS,
                FILE_FLAG_RANDOM_ACCESS,
                NULL );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) {

        Error = _Status = GetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:File open failed, %ld.\n",_Status));

        TcpsvcsDbgAssert( FALSE );

        _FileHandle = NULL;
        goto Cleanup;
    }


#ifndef unix
    /*******
     * UNIX:
     *       Mainwin does not support MapName in CreateFileMapping API
     *       Let us leave the MapName as NULL till this functionality
     *       is available.
     */

    //
    // make a map name.
    //

    DWORD MapNameSize;

    MapNameSize =
        (lstrlen(_FullPathName) +
            lstrlen( _FileName) +
                1 +
                FILE_SIZE_MAX_DIGITS ) * sizeof(TCHAR) ;

    MapName = (LPTSTR) CacheHeap->Alloc( MapNameSize );

    if( MapName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memcpy(MapName, _FileName, _FullPathNameLen + sizeof(MEMMAP_FILE_NAME));
    memcpy(MapName + _FullPathNameLen + sizeof(MEMMAP_FILE_NAME) - 1, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    wsprintf(MapName + lstrlen(MapName), "%u", _FileSize);

#ifndef unix
#define BACKSLASH_CHAR          TEXT('\\')
#else
#define BACKSLASH_CHAR          TEXT('/')
#endif /* unix */
#define UNDERSCORE_CHAR         TEXT('_')
#define TERMINATING_CHAR        TEXT('\0')

    LPTSTR ScanMapName;

    //
    // Replace '\' with '_'.
    //

    ScanMapName = MapName;

    while( *ScanMapName != TERMINATING_CHAR ) {

        if( *ScanMapName == BACKSLASH_CHAR ) {
            *ScanMapName = UNDERSCORE_CHAR;
        }

        ScanMapName++;
    }
#endif /* !unix */



    //
    // re-create memory mapping.
    //
    _FileMappingHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, MapName);

    if (_FileMappingHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        if (psa)
        {
            _FileMappingHandle =
                CreateFileMapping(
                    _FileHandle,
                    psa,
                    PAGE_READWRITE,
                    0, // high dword of max memory mapped file size.
        #if defined(UNIX) && defined(ux10)
                    1024 * 1024, // map entire file.
        #else
                    0, // map entire file.
        #endif
                    MapName);
        }
    }

    if( _FileMappingHandle == NULL ) {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    //
    // remap view region.
    //

    _BaseAddr =
        MapViewOfFileEx(
            _FileMappingHandle,
            FILE_MAP_WRITE,
            0,
            0,
#if defined(UNIX) && defined(ux10)
            1024 * 1024,   // MAP entire file.
#else
            0,   // MAP entire file.
#endif
            NULL );

#if defined(UNIX) && defined(ux10)
    DWORD FilePointer = SetFilePointer(
                            _FileHandle,
                            _FileSize,
                            NULL,
                            FILE_BEGIN );
    if (FilePointer == 0xFFFFFFFF)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if (BoolError == FALSE)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }
#endif

    if( _BaseAddr == NULL ) 
    {
        Error = _Status = GetLastError();
        TcpsvcsDbgAssert( FALSE );

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MapViewOfFile failed to extend address space, %ld.\n",
                Error ));

       goto Cleanup;
    }

    //
    // reset other pointers.
    //

    _HeaderInfo = (LPMEMMAP_HEADER)_BaseAddr;
    _EntryArray = ((LPBYTE)_BaseAddr + HEADER_ENTRY_SIZE );

    _Status = Error = ERROR_SUCCESS;

Cleanup:


    if( MapName != NULL ) {
        CacheHeap->Free( MapName );
    }

        return( Error );
}

DWORD
MEMMAP_FILE::GrowMapFile(DWORD dwMapFileGrowSize)
/*++

    This private member function extends the memory mapped file and
    creates more free url store entries.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error, i;
    BOOL BoolError;
    DWORD FilePointer;
    DWORD OldNumUrlInternalEntries;
    char  buff[PAGE_SIZE];

    //
    // check to see that we have reached the limit.
    // we can hold only MAX_URL_ENTRIES url entries.
    // so the file size can grow more than
    //
    //  HEADER_ENTRY_SIZE + MAX_URL_ENTRIES * _EntrySize
    //

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif //INET_DEBG

    //BUGBUG - need to fix this
    if( (_FileSize + dwMapFileGrowSize) >=
            (HEADER_ENTRY_SIZE +
                MAX_URL_ENTRIES * _EntrySize) ) {

        //
        // best matching error code.
        //

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    FilePointer = SetFilePointer(
                            _FileHandle,
                            dwMapFileGrowSize,
                            NULL,
                            FILE_END );


    if (FilePointer != (_FileSize + dwMapFileGrowSize))
    {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "FilePointer != (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);
        
        _Status = GetLastError();
        Error = _Status;

        goto Cleanup;
    }

    if( FilePointer == 0xFFFFFFFF ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if( BoolError != TRUE ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize + dwMapFileGrowSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif

    //
    // adjust internal size parameters.
    //

    _FileSize += dwMapFileGrowSize;

    //
    // also set the new file size in the memory mapped file so that
    // other user will remap their address space and view the new portion.
    //

    _HeaderInfo->FileSize = _FileSize;

    OldNumUrlInternalEntries = _HeaderInfo->NumUrlInternalEntries;
    _HeaderInfo->NumUrlInternalEntries +=
        dwMapFileGrowSize / _EntrySize;

    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; // cell

    //
    // remap
    //

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    memset(
          (_EntryArray + _EntrySize * OldNumUrlInternalEntries),
           0,
          dwMapFileGrowSize );

    Error = ERROR_SUCCESS;


Cleanup:

    return( Error );
}

BOOL MEMMAP_FILE::CheckNextNBits(DWORD& nArrayIndex, DWORD &dwStartMask, 
                                DWORD nBitsRequired, DWORD& nBitsFound)
{
/*++
    Determines if the next N bits are unset.

Arguments:
    [IN/OUT]
    DWORD &nArrayIndex, DWORD &dwMask

    [IN]
    DWORD nBitsRequired

    [OUT]
    DWORD &nBitsFound

Return Value:

    TRUE if the next N bits were found unset.
    FALSE otherwise.

Notes:
    This function assumes that the range of bits to be checked lie
    within a valid area of the bit map. 
--*/
    DWORD i, j;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index 
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}
 

BOOL MEMMAP_FILE::SetNextNBits(DWORD nIdx, DWORD dwMask, 
                                DWORD nBitsRequired)
/*++
    Given an array index and bit mask, sets the next N bits.

Arguments:
    [IN]
    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired

Return Value:

    TRUE if the next N bits were found unset, and successfully set.
    FALSE if unable to set all the required bits.

Notes:
    This function assumes that the range of bits to be set lie
    within a valid area of the bit map. If the function returns
    false, no bits are set.
 --*/
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];
    BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {    
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            INET_ASSERT(FALSE);

            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                INET_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_HeaderInfo->AllocationBitMap[--nIdx];
                }                        
                *BitMap &= ~dwMask;
            }             
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;
    
        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }                        
    
    }

    // Success.
    return TRUE;
}


DWORD
MEMMAP_FILE::GetAndSetNextFreeEntry(
    DWORD nBitsRequired
    )
/*++
    This private member function computes the first available free entry
    index.

Arguments:

    DWORD nBitsRequired

Return Value:

    Next available free entry Index.
--*/
{
    DWORD i, nReturnBit = 0xFFFFFFFF;
    
    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);            
    
    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _NumBitMapDWords)
    {
        // Process starting from this DWORD if alignment is not required 
        // and there are free bits, or alignment is required and all bits
        // are free. 
        if (_HeaderInfo->AllocationBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _HeaderInfo->AllocationBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;
          
                    // Don't exceed the number of internal entries.
                    if (nLeadingBit + nBitsRequired > _HeaderInfo->NumUrlInternalEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _HeaderInfo->NumUrlEntriesAlloced += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _HeaderInfo->NumUrlEntriesAlloced += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits. 
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else                
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
	exit:
    return nReturnBit;
}


MemMapStatus MEMMAP_FILE::Init(LPTSTR PathName, DWORD EntrySize)
/*++

    MEMMAP_FILE object constructor.

Arguments:

    PathName : full path name of the memory mapped file.

    EntrySize : size of the each entry in this container.

Return Value:

    NONE.

--*/
{
    DWORD cb;

    _EntrySize =  EntrySize;
    _FullPathName = NULL;
    _FileName = NULL;
    _FileSize = 0;
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _BaseAddr = NULL;
    _HeaderInfo = NULL;
    _EntryArray = NULL;
    _NumBitMapDWords = 0;

    // Validate the path and create the path if it is not already there.
    _Status = ValidateAndCreatePath( PathName );
    if( _Status != ERROR_SUCCESS ) 
        goto Cleanup;

    // Path to memory mapped file.
    cb = strlen(PathName);
    _FullPathName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(DIR_SEPARATOR_STRING));

    if( _FullPathName == NULL ) 
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }

    memcpy(_FullPathName, PathName, cb + 1);
    AppendSlashIfNecessary(_FullPathName, &cb);
    
    _FullPathNameLen = cb;

    // Construct memory mapped file name.
    _FileName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(MEMMAP_FILE_NAME));
    if (!_FileName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }
    memcpy(_FileName, _FullPathName, cb);
    memcpy(_FileName + cb, 
        MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));

    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
    if (psa)
    {
        // Create/Open memory mapped file.
        _FileHandle =
            CreateFile(
                _FileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                psa,
                OPEN_ALWAYS,
                FILE_FLAG_RANDOM_ACCESS,
                NULL );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    _Status = GetLastError();

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) 
    {
        _FileHandle = NULL;
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }
    else
    {
        SetFileTime(_FileHandle, NULL, NULL, (LPFILETIME)&dwdwSessionStartTime);
    }

    // Check to this file is new.
    if ( _Status == ERROR_ALREADY_EXISTS ) 
    {

        // Old file.

        _Status = ERROR_SUCCESS;
       _NewFile = FALSE;

       _FileSize = GetFileSize( _FileHandle, NULL );

       if( _FileSize == 0xFFFFFFFF ) 
       {
           _Status = GetLastError();
           TcpsvcsDbgAssert(FALSE);
           goto Cleanup;
       }

       if ((_FileSize < GlobalMapFileGrowSize) || ((_FileSize %GlobalMapFileGrowSize) != 0)) 
       {
            TcpsvcsDbgAssert(FALSE);
            if(!Reinitialize()) 
            {
                TcpsvcsDbgAssert(FALSE);
                SetLastError(_Status);
                goto Cleanup;
            }
            // Reinitialization results in new file.
            _NewFile = TRUE;
       }
    }
    else if( _Status == ERROR_SUCCESS) 
    {
        BOOL BoolError;
        DWORD FilePointer;

        // New file.
        _NewFile = TRUE;

        // Set initial file size.
        _FileSize = GlobalMapFileGrowSize;
        FilePointer = SetFilePointer( _FileHandle, _FileSize, NULL, FILE_BEGIN );

        if( FilePointer == 0xFFFFFFFF ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }

        if (FilePointer != _FileSize )
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "FilePointer != (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);
        }

        BoolError = SetEndOfFile( _FileHandle );

        if( BoolError != TRUE ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }
    }
    else 
    {
        // We should not reach here.
        TcpsvcsDbgAssert(FALSE);
    }
    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Header Size, %ld.\n",
                    HEADER_ENTRY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Size of elements, %ld.\n",
                        sizeof(MEMMAP_HEADER_SMALL)));


    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Bit Array size, %ld.\n",
                    BIT_MAP_ARRAY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Memmap Header Size, %ld.\n",
                    sizeof(MEMMAP_HEADER)));

    TcpsvcsDbgAssert( HEADER_ENTRY_SIZE >= sizeof(MEMMAP_HEADER) );

    // validate the file content if the file is not new.
    if( _NewFile != TRUE ) 
    {
        if( ValidateCache() == FALSE) 
        {
            if (!Reinitialize()) 
            {
                _Status = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;
            }

            // Succeeded in re-initializing the file, we 
            // treat this as if we created a new file.
            _NewFile = TRUE;
        }
    }
    else
    {
        // It is a brand new file. Initialize file header.
        if(!InitHeaderInfo()) 
        {
            // This can happen if there is an exception while
            // initializing headers
            _Status = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;

        }
    }

    // Compute number of bitmap DWORDs used.
    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; //cell

    // We are done.
    _Status = ERROR_SUCCESS;

Cleanup:

    if( _Status != ERROR_SUCCESS ) 
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MEMMAP_FILE::Initfailed, %ld\n", _Status ));
        
        SetLastError(_Status);
    }

    if (_NewFile)
        return MEMMAP_STATUS_REINITIALIZED;
    else
        return MEMMAP_STATUS_OPENED_EXISTING;
}

MEMMAP_FILE::~MEMMAP_FILE(
    VOID
    )
/*++

Routine Description:

    MEMMAP_FILE object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CloseMapping();
    CacheHeap->Free( _FileName );
    CacheHeap->Free( _FullPathName );
}


BOOL MEMMAP_FILE::ReAllocateEntry(LPFILEMAP_ENTRY pEntry, DWORD cbBytes)
/*++

Routine Description:

    Attempts to reallocate an entry at the location given.

Arguments:

    LPFILEMAP_ENTRY pEntry: Pointer to location in file map.
    DWORD cbBytes : Number of bytes requested

Return Value:

    Original value of pEntry if successful. pEntry->nBlocks is set to the new
    value, but all other fields in the entry are unmodified. If insufficient contiguous 
    bits are found at the end of the original entry, NULL is returned, indicating failure.
    In this case the entry remains unmodified. 

Notes:
    
    The Map file should *not* be grown if insufficient additional bits are not found.

--*/
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD) PtrDifference(pEntry, _EntryArray);
    if (IsBadOffset(cbEntryOffset))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    
    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {           
        // Determine if additional free bits are 
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _EntrySize + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired 
            > _HeaderInfo->NumUrlInternalEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the 
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask, 
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _HeaderInfo->NumUrlEntriesAlloced += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}

LPFILEMAP_ENTRY MEMMAP_FILE::AllocateEntry(DWORD cbBytes)
/*++

Routine Description:

    Member function that returns an free entry from the cache list. If
    none is available free, it grows the map file, makes more free
    entries.

Arguments:

    DWORD cbBytes : Number of bytes requested
    DWORD cbOffset: Offset from beginning of bit map where allocation is requested.

Return Value:

    If NULL, GetStatus() will return actual error code.

--*/
{
    LPFILEMAP_ENTRY NewEntry;

    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return 0;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF ) 
    {
        // Map file is full, grow it now.
        _Status = GrowMapFile(cbBytes <= GlobalMapFileGrowSize ?
            GlobalMapFileGrowSize : ROUNDUPTOPOWEROF2(cbBytes, ALLOC_PAGES * PAGE_SIZE) );

        // Failed to grow map file.
        if( _Status != ERROR_SUCCESS ) 
        {
            return NULL;
        }

        // Retry with enlarged map file.
        FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

        TcpsvcsDbgAssert( FreeEntryIndex != 0xFFFFFFFF );

        // Failed to allocate bytes after enlarging map file.
        if( FreeEntryIndex == 0xFFFFFFFF ) 
        {
            return NULL;
        }
    }

    INET_ASSERT(  (cbBytes < PAGE_SIZE) 
        || ( (cbBytes >= PAGE_SIZE) && !((_EntrySize * FreeEntryIndex) % PAGE_SIZE)) );
    
    // Cast the memory.
    NewEntry = (LPFILEMAP_ENTRY)
        (_EntryArray + _EntrySize * FreeEntryIndex);
    
    // Mark the allocated space.
    #ifdef DBG
        ResetEntryData(NewEntry, SIG_ALLOC, nBlocksRequired);
    #else
        NewEntry->dwSig = SIG_ALLOC;
    #endif // DBG

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;
        
    return NewEntry;
}


BOOL MEMMAP_FILE::FreeEntry(LPFILEMAP_ENTRY Entry)
/*++

    This public member function frees up a file cache entry.

Arguments:

    UrlEntry : pointer to the entry that being freed.

Return Value:

    TRUE - if the entry is successfully removed from the cache.
    FALSE - otherwise.

--*/
{
    DWORD nIndex, nArrayIndex, 
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    //
    // Validate the pointer passed in.
    //
    if( ((LPBYTE)Entry < _EntryArray) 
        || ((LPBYTE)Entry >=
           (_EntryArray + _EntrySize *
           _HeaderInfo->NumUrlInternalEntries) ) ) 
    {
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD) PtrDifference(Entry, _EntryArray);
    if( nOffset % _EntrySize ) 
    {
        // Pointer does not point to a valid entry.
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }
    
    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / NORMAL_ENTRY_SIZE))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _EntrySize;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    //
    // Unmark the index bits in the map.
    //

    BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Attempted to free unset bits. Ignoring...\n"));
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    TcpsvcsDbgAssert(_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _HeaderInfo->NumUrlEntriesAlloced -= nBlocks;

return TRUE;
}


BOOL
MEMMAP_FILE::Reinitialize(void)
/*++

    This  member function reinitializes a cache index file

Arguments:



Return Value:

    Windows error code


--*/
{
    TcpsvcsDbgAssert( _FileHandle != NULL );

    // Close view, mapping, and file.
    CloseMapping();
    
    BOOL BoolError, fReinited = FALSE;
    DWORD FilePointer;

    // If we're re-initialising, that means we're losing all our cached data. 
    // Time to delete all the old stuff

    // But wait -- we only want to do this for the content cache, since we can regen
    // the index from the cookies, and history stores all its info in index file
    // We'll check for "content.ie5" in the path

    if (StrStrI(_FullPathName, "content.ie5"))
    {
        DeleteCachedFilesInDir(_FullPathName);
    }

    SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
    if (psa)
    {
        // check for exclusive access, we do this by opening the
        // file in exclsive mode, if we succeed we are the only one
        _FileHandle = CreateFile
            (
                _FileName,
                GENERIC_WRITE,
                0,    // no read/write sharing
                psa,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    if (_FileHandle == INVALID_HANDLE_VALUE)
    {
        _FileHandle = NULL;
    }
    else
    {
        DWORD FilePointer = SetFilePointer
            ( _FileHandle, GlobalMapFileGrowSize, NULL, FILE_BEGIN);
    
        if( FilePointer != 0xFFFFFFFF)
        {
            if (SetEndOfFile (_FileHandle))
            {
                // Success!
                _FileSize = GlobalMapFileGrowSize;
                fReinited = TRUE;
            }
            else
            {
                TcpsvcsDbgPrint(( DEBUG_ERRORS, "SetEndOfFile failed: %u\n",
                    GetLastError()));
            }
        }            

        // Following will be done by RemapAddress calling CloseMapping
        // CloseHandle (_FileHandle);
        // _FileHandle = NULL
    }

    // Re-attach to the file.

    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS )
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:Remap failed, %ld.\n",_Status));
        TcpsvcsDbgAssert( FALSE );
        goto Cleanup;
    }

    if (fReinited)
    {
        // if there is an exception due to bad sector, this will set
        // _status to something other than ERROR_SUCCESS
        if(!InitHeaderInfo()) 
            goto Cleanup;

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

Cleanup:

    return fReinited;
}

BOOL
MEMMAP_FILE::InitHeaderInfo()
/*++

    This  member function intializes the memorymapped headerinfo
    structure

Arguments:



Return Value:

    None

--*/
{
    //
    // initialize file header.
    //
    BOOL fSuccess = TRUE;

    __try {
        TcpsvcsDbgAssert( _HeaderInfo != NULL );

        memcpy(_HeaderInfo->FileSignature, CACHE_SIGNATURE, sizeof(CACHE_SIGNATURE));

        _HeaderInfo->FileSize = _FileSize; // set file size in the memmap file.
        _HeaderInfo->dwHashTableOffset = 0;
        _HeaderInfo->CacheSize = (LONGLONG)0;
        _HeaderInfo->CacheLimit = (LONGLONG)0;
        _HeaderInfo->ExemptUsage = (LONGLONG)0;
        _HeaderInfo->nDirCount = 0;
        
        for (int i = 0; i < DEFAULT_MAX_DIRS; i++)
        {
            _HeaderInfo->DirArray[i].nFileCount = 0;
            _HeaderInfo->DirArray[i].sDirName[0] = '\0';
        }
        
        _HeaderInfo->NumUrlInternalEntries =
            ((_FileSize - HEADER_ENTRY_SIZE ) /
                _EntrySize );

        _HeaderInfo->NumUrlEntriesAlloced = 0;

        memset( _HeaderInfo->AllocationBitMap, 0,  sizeof(_HeaderInfo->AllocationBitMap) );
        memset( _EntryArray, 0, (_FileSize - HEADER_ENTRY_SIZE) );
        memset( _HeaderInfo->dwHeaderData, 0, sizeof(DWORD) * NUM_HEADER_DATA_DWORDS);

        _Status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        _Status = ERROR_WRITE_FAULT;
        fSuccess = FALSE;
    }
    ENDEXCEPT

    return (fSuccess);
}

LPFILEMAP_ENTRY MEMMAP_FILE::FindNextEntry (DWORD* pdwEnum, DWORD dwFilter, GROUPID GroupId, DWORD dwMatch)
{
    while (1)
    {
        // Get the next item in the hash table.
        HASH_ITEM *pItem = HashGetNextItem (this, (LPBYTE)_BaseAddr, pdwEnum, 0);
        if (!pItem)
            return NULL;

        // continue if search entry within group but hash bit says no group 
        // (may avoid unnecessary page hit by pulling non-relevent pEntry)
        if( GroupId && !pItem->HasGroup() )
            continue;

            
        // Get the entry from the item.
        URL_FILEMAP_ENTRY* pEntry = ValidateUrlOffset (pItem->dwOffset);
        if (!pEntry)
        {
            pItem->MarkFree();
            continue;
        }
        
        // No filter - continue enum until ERROR_NO_MORE_ITEMS.
        if (!dwFilter)
            continue;

        // IDENTITY_CACHE_ENTRY is an identity-specific entry.
        // We don't want these to be shown inappropriately to a client.
        // We may want to be able to display all of these for debug, though.
        if ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY)
            && ((pEntry->dwIdentity != dwMatch)
                || (!pEntry->dwIdentity)))
            continue;

        DWORD cet = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
        
        // Temporary hack to always show 1.1 entries 
        // until we have a better way of dealing with them.
        dwFilter |= INCLUDE_BY_DEFAULT_CACHE_ENTRY;

        // Continue enum if no match on cache entry type.
        if ((dwFilter & cet) != cet)
            continue;

        // Continue enum if no match on group.
        if (GroupId ) 
        {
            if( pItem->HasMultiGroup() )
            {
                // need to search the list
                LIST_GROUP_ENTRY*   pListGroup = NULL;
                pListGroup = ValidateListGroupOffset(pEntry->dwGroupOffset);
                if( !pListGroup )
                    continue;

                BOOL fFoundOnList = FALSE;
                while( pListGroup && pListGroup->dwGroupOffset )
                {
                    GROUP_ENTRY* pGroup = NULL;
                    pGroup = ValidateGroupOffset( 
                                pListGroup->dwGroupOffset, pItem); 
                    if( !pGroup )
                    {
                        break;
                    }

                    if( GroupId ==  pGroup->gid )
                    {
                        fFoundOnList = TRUE;
                        break;
                    }

                    if( !pListGroup->dwNext )
                    {
                        break;
                    }

                    // next group on list
                    pListGroup = ValidateListGroupOffset(pListGroup->dwNext);
                }
               
                if( !fFoundOnList )
                    continue; 

            }
            else if( GroupId != 
                        ((GROUP_ENTRY*)( (LPBYTE)_BaseAddr + 
                                 pEntry->dwGroupOffset))->gid ) 
            { 
                continue;
            }

        }

        return (LPFILEMAP_ENTRY) (((LPBYTE)_BaseAddr) + pItem->dwOffset);
    }
}

BOOL MEMMAP_FILE::IsBadOffset (DWORD dwOffset)
{

    ASSERT_ISPOWEROF2 (_EntrySize);
    return (dwOffset == 0
        || (dwOffset & (_EntrySize-1))
        || (dwOffset >= _FileSize));

    return FALSE;

}


BOOL MEMMAP_FILE::IsBadGroupOffset (DWORD dwOffset)
{
    return (dwOffset == 0 || (dwOffset >= _FileSize));
    return FALSE;
}


GROUP_ENTRY* MEMMAP_FILE::ValidateGroupOffset (DWORD dwOffset, HASH_ITEM* hItem)
{
    GROUP_ENTRY *pEntry = NULL;

    // if hash item is available, check the group bit first.
    if( hItem && !hItem->HasGroup())
    {
        return NULL;
    }

    // check the offset 
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    
    // Get the Group.
    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (GROUP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}



URL_FILEMAP_ENTRY* MEMMAP_FILE::ValidateUrlOffset (DWORD dwOffset)
{
    // Validate offset.
    if (IsBadOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    // Validate signature.
    URL_FILEMAP_ENTRY *pEntry =
        (URL_FILEMAP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT (FALSE);
        return NULL;
    }
    
    // TODO: validate entry offsets, string terminations etc.
    return pEntry;
}


LIST_GROUP_ENTRY* MEMMAP_FILE::ValidateListGroupOffset (DWORD dwOffset)
{
    LIST_GROUP_ENTRY *pEntry = NULL;

    // Validate offset.
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL ;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    

    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (LIST_GROUP_ENTRY*) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\debug.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Contains data definitions for debug code.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _DEBUG_
#define _DEBUG_

#ifdef __cplusplus
extern "C" {
#endif

// Event tracking macros...
#define EVENTWRAP(API, h) {\
    BOOL ret = API(h);\
    if (ret) \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d)\n", h)); \
    else { \
        TcpsvcsDbgPrint((DEBUG_APIS, #API "(" #h "=%d) failed err=%d\n",\
            h, GetLastError())); \
        TcpsvcsDbgAssert( FALSE ); \
    } \
}\

#define   SETEVENT(h)  EVENTWRAP(SetEvent,    h)
#define RESETEVENT(h)  EVENTWRAP(ResetEvent,  h)
#define CLOSEHANDLE(h) EVENTWRAP(CloseHandle, h)

//
// LOW WORD bit mask (0x0000FFFF) for low frequency debug output.
//
#define DEBUG_ERRORS            0x00000001  // hard errors.
#define DEBUG_REGISTRY          0x00000002  // debug registry calls
#define DEBUG_MISC              0x00000004  // misc info.
#define DEBUG_SCAVENGER         0x00000008  // scavenger debug info.

#define DEBUG_SORT              0x00000010  // debug B-TREE functions
#define DEBUG_CONTAINER         0x00000020  // debug container
#define DEBUG_APIS              0x00000040  // debug tcpsvcs apis
#define DEBUG_FILE_VALIDATE     0x00000080 // validate file map file
#define DEBUG_SVCLOC_MESSAGE    0x00000100  // discovery messages



//
// HIGH WORD bit mask (0x0000FFFF) for high frequency debug output.
// ie more verbose.
//

#define DEBUG_TIMESTAMP         0x00010000  // print time stamps
#define DEBUG_MEM_ALLOC         0x00020000 // memory alloc
#define DEBUG_STARTUP_BRK       0x40000000  // breakin debugger during startup.

#define ENTER_CACHE_API(paramlist) \
{ DEBUG_ONLY(LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();) \
  DEBUG_ENTER_API(paramlist); \
}

#define LEAVE_CACHE_API() \
Cleanup:                         \
    if (Error != ERROR_SUCCESS)  \
    {                            \
        SetLastError( Error );   \
        DEBUG_ERROR(INET, Error); \
    }                            \
    DEBUG_LEAVE_API (Error==ERROR_SUCCESS);      \
    return (Error==ERROR_SUCCESS);                 \

#if DBG

///#define DEBUG_PRINT OutputDebugString

//
// debug functions.
//

#define TcpsvcsDbgPrint(_x_) TcpsvcsDbgPrintRoutine _x_

VOID
TcpsvcsDbgPrintRoutine(
    IN DWORD DebugFlag,
    IN LPSTR Format,
    ...
    );

#define TcpsvcsDbgAssert(Predicate) INET_ASSERT(Predicate)

#else

///#define IF_DEBUG(flag) if (FALSE)

#define TcpsvcsDbgPrint(_x_)
#define TcpsvcsDbgAssert(_x_)

#endif // DBG

#if DBG
#define INLINE
#else
#define INLINE      inline
#endif

#ifdef __cplusplus
}
#endif

#endif  // _DEBUG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\flock.cxx ===
#include "flock.hxx"
// #include <resource.h>
#include <cache.hxx>

#undef inet_ntoa
#undef inet_addr
#undef gethostname
#undef gethostbyname
#undef gethostbyaddr

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#ifdef sunos5
extern "C" int gethostname(char*,int);
#endif

extern HANDLE MwOpenProcess(pid_t, BOOL);
extern "C" MwAtExit(void (*f)(void));

//locally used functions
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len);

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400


// lock region relative to whence starting at offset upto len bytes
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK     
  lock.l_start = offset;    //byte offset, relative to l_whence
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = len;     //#bytes (0 means to EOF)

  return( fcntl(fd, cmd, &lock) );
}

// test region for locks relative to whence starting at offset for len bytes
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK 
  lock.l_start = *offset;   //byte offset, relative to l_whence     
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = *len;        // #bytes (0 means to EOF)      

  if (fcntl(fd, F_GETLK, &lock) < 0)
    return(-1);

  if (lock.l_type == F_UNLCK)
    return(0);          // nobody has lock in this region
  else if (lock.l_type == F_RDLCK) {
    *offset = lock.l_start;
    *len = lock.l_len;
    return(lock.l_start);   // byte offset of host with read lock
  } else {          // dont support extended semantics of
    return(-1);         // write lock yet
  }
}


extern "C" void unixCleanupWininetCacheLockFile()
{
//    if(!g_ReadOnlyCaches)
        //unlink(szLockDBName);
}

BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost)
{
    int fdlockdbf, fdlock, envLen, hostbynameerr;
    off_t IPOffset=0, IPLen=0, ownIPOffset, ownIPLen;
    char *hostname, hostbynamebuf[512];
    char szLockFileName[MAX_PATH+1], szLockDBName[MAX_PATH+1];
    struct hostent hostbynameresult;
#ifdef ux10
    struct hostent_data hostentdata;
#endif

    char *pEnv = getenv("MWUSER_DIRECTORY");

    /* Don't process the ielock file for Mainwin Lite programs */
    if (MwIsInitLite())
       goto Cleanup;

    if (pEnv == 0)
    return FALSE;

    envLen = strlen(pEnv);
    if (envLen > MAX_PATH-256)
        return FALSE;

    strcpy(szLockFileName, pEnv);
    if (szLockFileName[envLen-1] != '/') {
      szLockFileName[envLen] = '/';
      szLockFileName[envLen+1] = 0x00;
    }
    strcpy(szLockDBName, pEnv);
    if (szLockDBName[envLen-1] != '/') {
      szLockDBName[envLen] = '/';
      szLockDBName[envLen+1] = 0x00;
    }
    strcat(szLockFileName, LF);
    strcat(szLockDBName, LOCKDBF);

    hostname = (char *)malloc(256*sizeof(char));
    if ((hostname == NULL) || (gethostname(hostname, 256) == -1)) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

#ifdef sunos5
    if (!(gethostbyname_r(hostname, &hostbynameresult, hostbynamebuf,
                 sizeof(hostbynamebuf), &hostbynameerr))) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
#ifdef ux10
    if (gethostbyname_r(hostname, &hostbynameresult, &hostentdata) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
    struct in_addr *ptr = (struct in_addr *)*hostbynameresult.h_addr_list;
    ownIPOffset = inet_netof(*ptr);
    ownIPLen = inet_lnaof(*ptr);

    if ((fdlock = open(szLockFileName, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlock = open(szLockFileName, O_WRONLY)) < 0) {
          *pfReadOnlyCaches = TRUE;
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        return FALSE;
      }
    }

    if (writew_lock(fdlock, 0, SEEK_SET, 0) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

    /*under this lock, now do all the examination of szLockDBName*/
    if ((fdlockdbf = open(szLockDBName, O_RDWR|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlockdbf = open(szLockDBName, O_RDWR)) < 0) {
          *pfReadOnlyCaches = TRUE;
          un_lock(fdlock, 0, SEEK_SET, 0);
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return FALSE;
      }
    }

    /* check entire file for locking */
    if ((can_writelock(fdlockdbf, &IPOffset, SEEK_SET, &IPLen)) >= 0) {
      if ((IPOffset == 0) || ((IPOffset == ownIPOffset) && (IPLen == ownIPLen))){
    // either no IE writing to cache or IE on own host writing to cache
    // (IP address is identical)..either way we have write access
    *pfReadOnlyCaches = FALSE;
    *pszLockingHost = hostname;
    //lock at "network part" position for "host part" bytes
    read_lock(fdlockdbf, ownIPOffset, SEEK_SET, ownIPLen);
    un_lock(fdlock, 0, SEEK_SET, 0);
    return TRUE;
      } else {
    //some other host writing to cache
        *pfReadOnlyCaches = TRUE;
        u_long addr = inet_addr(inet_ntoa(inet_makeaddr(IPOffset, IPLen)));
        struct hostent * hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);
        if (!hp)
          ;       //cant find hostname from offset & length of locked bytes..
        else
          *pszLockingHost = hp->h_name;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return TRUE;
      }
    } else {
      //can_writelock returned -1 with some fcntl error
      *pfReadOnlyCaches = TRUE;
      un_lock(fdlock, 0, SEEK_SET, 0);
      return FALSE;
    }

Cleanup:
    return TRUE;
}

BOOL DeleteAtomicCacheLockFile()
{
    /* Don't process for MainWin Lite programs */
    /* Right now, the code below does not make sense because all
     * we do is return TRUE. So, commenting out this code for now.
     */
#if 0
    if (MwIsInitLite())
       goto Cleanup;

Cleanup:
#endif /* 0 */
    //unlink(szLockDBName);
    return TRUE;
}

#if 0 // Back out till we get a consensus on this

BOOL CALLBACK ReadOnlyCache_DlgProc(HWND   hDlg,
                                    UINT   uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam) {
     switch (uMsg) {
            case WM_INITDIALOG:
            {
                 LPTSTR lpszMessageStr = (LPTSTR)lParam;
                 TCHAR  pszText[MAX_PATH];
                 TCHAR  pszFormattedText[MAX_PATH];

                 if (lpszMessageStr)
                 {
                    if (LoadString(GlobalDllHandle,
                                   IDS_READONLYCACHE,
                                   pszText,
                                   ARRAYSIZE(pszText))) {
                       wsprintf(pszFormattedText,pszText, lpszMessageStr);
                       SetDlgItemText(hDlg, IDC_READONLYCACHE, pszFormattedText);
                    }
                 }

                 SetFocus(GetDlgItem(hDlg, IDOK));
            }
            break;

            case WM_COMMAND:
                 switch (LOWORD(wParam))
                 {
                        case IDOK:
                        {
                             if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                                EndDialog(hDlg, 1);
                             else
                                EndDialog(hDlg, 0);
                             break;
                        }

                        default:
                             return FALSE;
                 }
                 return TRUE;
            case WM_CLOSE:
            {
                 if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                    EndDialog(hDlg, 1);
                 else
                    EndDialog(hDlg, 0);
            }
            return TRUE;
     }

     return FALSE;
}

void ShowReadOnlyCacheDialog(char* pszHostName) {
     DWORD dwError = E_FAIL;
     HKEY  hKey = NULL;
     DWORD dwValue = 0;
     DWORD dwValueType;
     DWORD dwValueSize = sizeof(DWORD);

     if ((dwError = REGOPENKEYEX(HKEY_CURRENT_USER,
                            REG_READONLYCACHE,
                            0,
                            KEY_READ|KEY_WRITE,
                            &hKey)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if ((dwError = RegQueryValueEx(hKey,
                               REG_READONLYCACHEKEY,
                               0,
                               &dwValueType,
                               (LPBYTE)&dwValue,
                               &dwValueSize)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if (dwValue)
     {
        int fRet = 0;

        if ((fRet = DialogBoxParam(GlobalDllHandle,
                              MAKEINTRESOURCE(IDD_READONLYCACHE),
                              NULL,
                              ReadOnlyCache_DlgProc,
                              (LPARAM)pszHostName)) < 0)
        {
           goto Cleanup;
        }

        /*
         * we are here, because the registry told us to show this dialog.
         * now, we check if fRet == TRUE, in which case we don't show this
     * dialog in the future. And, we update the registry.
         */

        if (fRet == 1) {
           /* ShowCacheWarning will be set to False in the registry */
           dwValue = 0;

           /*
            * we don't check for the error here, because we close the key next
            * and if we did not save successfully, we will show this dialog again
            */

           RegSetValueEx(hKey,
                         REG_READONLYCACHEKEY,
                         0,
                         dwValueType,
                         (LPBYTE)&dwValue,
                         dwValueSize);
        }
     }

Cleanup:

     if (hKey)
        REGCLOSEKEY(hKey);

     return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\group.cxx ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:  group.hxx

Abstract:

    Manages cache group.
    
Author:
    Danpo Zhang (DanpoZ) 02-08-98
--*/

#include <wininetp.h>
#include <cache.hxx>

GroupMgr::GroupMgr()
{
    _pContainer = NULL;
}

GroupMgr::~GroupMgr()
{
    if( _pContainer )
    {
        _pContainer->Release(FALSE);
    }
}

BOOL
GroupMgr::Init(URL_CONTAINER* pCont)
{
    BOOL fRet = TRUE;

    if( pCont )
    {
        _pContainer = pCont;
        _pContainer->AddRef();
    }
    else
    {
        SetLastError(ERROR_WINHTTP_INTERNAL_ERROR);
        fRet = FALSE;
    }

    return fRet;
}

DWORD
GroupMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGID);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    *pGID = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }

    if( dwFlags & CACHEGROUP_FLAG_GIDONLY )
    {
        // only needs to return GID, no group needs to be created
        *pGID = ObtainNewGID();
        if( *pGID )
            dwError = ERROR_SUCCESS;
        else
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            

        goto exit;
    }

    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // get a new gid
    *pGID = ObtainNewGID();

    if( *pGID )
    {
        // insert gid into the first available entry
        
        // set the sticky bit for non purgable group
        if( dwFlags & CACHEGROUP_FLAG_NONPURGEABLE )
        {
            *pGID = SetStickyBit(*pGID);
        }

        pGroupEntry->gid = *pGID;
        pGroupEntry->dwGroupFlags = dwFlags;
        dwError = ERROR_SUCCESS;
    } 
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::CreateDefaultGroups()
{
    
    INET_ASSERT(_pContainer);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwOffsetHead = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }

    if(    GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetHead)
        && dwOffsetHead )
    {
        BOOL fBadHead = FALSE;

        // dwOffsetHead may point to a page which has not actually mapped in
        if( _pContainer->_UrlObjStorage->IsBadGroupOffset(dwOffsetHead) ) 
        {
            fBadHead = TRUE;
        }
        else
        {
            
            // if offset is too big, invalid
            FILEMAP_ENTRY* pFM = NULL;

            pFM = (FILEMAP_ENTRY*) 
                    (*_pContainer->_UrlObjStorage->GetHeapStart() + 
                    dwOffsetHead - sizeof(FILEMAP_ENTRY) );                                   
            if(pFM->dwSig != SIG_ALLOC || !pFM->nBlocks )
            {
                fBadHead = TRUE;
            }
        }
            
        if( fBadHead )
        {
            // dwOffsetHead is invalid, reset!
            SetHeaderData(CACHE_HEADER_DATA_ROOTGROUP_OFFSET, 0);
        }
    }

    // if already created, just return success
    dwError = FindEntry(CACHEGROUP_ID_BUILTIN_STICKY, &pGroupEntry, FALSE);
    if( dwError == ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // not found, need to create new default groups
    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // set the sticky bit for non purgable group
    pGroupEntry->gid = CACHEGROUP_ID_BUILTIN_STICKY;
    pGroupEntry->dwGroupFlags = CACHEGROUP_FLAG_NONPURGEABLE;
    dwError = ERROR_SUCCESS;
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid);

    BOOL                fMustUnlock;
    DWORD               dwError;
    GROUP_ENTRY*        pGroupEntry = NULL;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               hUrlFindHandle = 0;
    URL_FILEMAP_ENTRY*  pUrlEntry = 0;
    DWORD               dwFindFilter;
    HASH_ITEM*          pItem = NULL; 


    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;    
    }


    // find the first available entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }
     

    // Look for all the url associated with this group
    // mark the groupid to 0
    hUrlFindHandle = _pContainer->GetInitialFindHandle();       

    // set up find filter (do not care about cookie/history)
    dwFindFilter = URLCACHE_FIND_DEFAULT_FILTER 
                    & ~COOKIE_CACHE_ENTRY 
                    & ~URLHISTORY_CACHE_ENTRY;
    
    //
    // loop find all url belongs to this group
    // WARNING: this can be slow!
    //
    do 
    {
        // next url in this group
        pUrlEntry = (URL_FILEMAP_ENTRY*)
                        _pContainer->_UrlObjStorage->FindNextEntry( 
                                &hUrlFindHandle, dwFindFilter, gid); 

        if( pUrlEntry )
        {
            INET_ASSERT(hUrlFindHandle);
            pItem = (HASH_ITEM*)(
                    (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart() +
                    hUrlFindHandle );

            if( pItem->HasMultiGroup() )
            {
                //
                // examing the group list and remove this group
                // from the list
                //
                DWORD       dwNewHeaderOffset       = pUrlEntry->dwGroupOffset;
                DWORD       dwGroupEntryOffset      = PtrDiff32(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                //
                // find the to be deleted group entry in the list
                // of groups associated with this url, we need to
                // fix this by removing the to be dead group from 
                // the list
                //
                DWORD Error = RemoveFromGroupList(
                    pUrlEntry->dwGroupOffset, 
                    dwGroupEntryOffset,
                    &dwNewHeaderOffset 
                );
                    
            
                //
                // found the entry and head offset has been changed
                //
                if( Error == ERROR_SUCCESS && 
                    dwNewHeaderOffset != pUrlEntry->dwGroupOffset )
                {
                    pUrlEntry->dwGroupOffset = dwNewHeaderOffset;
               
                    // 
                    // no more group associated with this url 
                    // let's update the hash flags 
                    //
                    if( !dwNewHeaderOffset )
                    {
                        pItem->ClearMultGroup();
                        pItem->ClearGroup();
                    }
                }

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {
                    //
                    // unset sticky bit for this url IFF 
                    // 1) we are about to delete the last group of this url
                    // 2) there is no more sticky group associated with this
                    //    url other than the to be deleted group
                    //
                    if( !pUrlEntry->dwGroupOffset ||
                        (  pUrlEntry->dwGroupOffset &&
                           NoMoreStickyEntryOnList(pUrlEntry->dwGroupOffset)))
                    {
                    
                        _pContainer->UpdateStickness(
                            pUrlEntry,
                            URLCACHE_OP_UNSET_STICKY,
                            hUrlFindHandle        
                        );
                    }
                }
            }
            else
            {
                //
                // do not move the url entry now, so we just
                // need to reset the GroupOffset and re-exam the
                // stick bit
                //
                pUrlEntry->dwGroupOffset = 0;

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {

                    _pContainer->UpdateStickness(
                        pUrlEntry,
                        URLCACHE_OP_UNSET_STICKY,
                        hUrlFindHandle        
                    );
                }

            }


            if( dwFlags & CACHEGROUP_FLAG_FLUSHURL_ONDELETE)
            {
                //
                // Container's DeleteUrlEntry method takes two 
                // param, the url entry and hash item.
                // The hUrlFindHandle actually contains the
                // offset of the Hash Item, so we can get 
                // the hash item from there. 
                //

                // if this url belongs to other groups, 
                // do not delete it
                if( !pItem->HasMultiGroup() )
                {
                    _pContainer->DeleteUrlEntry(pUrlEntry, pItem, SIG_DELETE);
                }
            }

        } // find next url
    } while( pUrlEntry);
                    
    // if data entry exists, we should free them as well 
    if( pGroupEntry->dwGroupNameOffset )
    {
        dwError = FindDataEntry(pGroupEntry, &pData, FALSE); 
        if( dwError == ERROR_SUCCESS )
        {
            FreeDataEntry(pData);
        }
    }

    memset(pGroupEntry, 0, sizeof(GROUP_ENTRY) );
    dwError = ERROR_SUCCESS;

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}



DWORD
GroupMgr::GetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pOutGroupInfo, 
    DWORD*                              pdwOutGroupInfoSize
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid && pOutGroupInfo && pdwOutGroupInfoSize);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR; 
        goto exit;    
    }

    
    *pdwOutGroupInfoSize = 0;

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE); 
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // init out param
    memset(pOutGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );

    // copy over GROUP_ENTRY -> GROUP_INFO
    Translate(
            dwAttrib,
            pOutGroupInfo, 
            pGroupEntry, 
            GROUP_ENTRY_TO_INFO, 
            pdwOutGroupInfoSize 
    ); 
    dwError = ERROR_SUCCESS; 

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::SetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pGroupInfo 
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupInfo && gid);

    BOOL  fMustUnlock;
    DWORD dwError;
    GROUP_ENTRY* pGroupEntry;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = GetLastError();
        goto Cleanup;    
    }

    pGroupEntry = NULL;

    INET_ASSERT(pGroupInfo);

    if( dwAttrib & ~(CACHEGROUP_READWRITE_MASK) ) 
    {
        //
        // read only fields are being requested
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) &&
        (strlen(pGroupInfo->szGroupName) >= GROUPNAME_MAX_LENGTH ) ) 
    {
        //
        // name too long, exceed the buffer limit 
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // copy over GROUP_INFO -> GROUP_ENTRY
    Translate(
            dwAttrib,
            pGroupInfo, 
            pGroupEntry, 
            GROUP_INFO_TO_ENTRY, 
            0 
    ); 
    dwError = ERROR_SUCCESS;
    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError; 
}


DWORD
GroupMgr::GetNextGroup(
    DWORD*                          pdwLastItemOffset, 
    GROUPID*                        pOutGroupId
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pOutGroupId);

    BOOL            fMustUnlock;
    BOOL            fEndOfGroups;
    GROUP_ENTRY*    pGroupEntry;
    DWORD           dwNewOffset;
    DWORD           dwError;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        fEndOfGroups = TRUE;
        goto Cleanup;    
    }

    pGroupEntry = NULL;
    dwNewOffset = 0;
    fEndOfGroups = FALSE;

    if( *pdwLastItemOffset == 0 )
    {
        // get root
        dwError = FindRootEntry(&pGroupEntry, FALSE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // new find and we can not get the root entry
            // this means there are no group at all. 
            //
            fEndOfGroups = TRUE;
            goto Cleanup;
        }
    } // IF: no previous offset, this is a new Find 

    else if( *pdwLastItemOffset == OFFSET_NO_MORE_GROUP )
    {
        // this group of search has completed already
        fEndOfGroups = TRUE;
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } // ELSE IF: previous FindNext has already reached the end of the groups 

    else
    {
        //
        // use the offset to jump to the last returned item's entry  
        //
        pGroupEntry = (GROUP_ENTRY*) 
            (*_pContainer->_UrlObjStorage->GetHeapStart() + *pdwLastItemOffset);                                   
        //
        // one step forward 
        //
        INET_ASSERT(pGroupEntry);                      // can't be null
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) ); // can't be index item
        pGroupEntry++;

    } // ELSE: walk to the item which has been returned by previous FindNext()


    // loop for next entry 
    while(pGroupEntry)
    {
        //
        // if this entry is the last one of the page
        // it contains offset pointing to the next page
        //
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use dwFlags to indicating if
            // this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                //
                // walk to next page
                //
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart() 
                          + pGroupEntry->dwGroupFlags );                                   
            } // IF: index entry point to next page

            else
            {
                //
                // we are done 
                //
                fEndOfGroups = TRUE;
                dwError = ERROR_FILE_NOT_FOUND;
                break; 

            } // ELSE: index page contains nothing (this is the last page)

        } // special case: current entry is the index(point to next page)


        // 
        // using gid to test if the entry is empty, if not, 
        // walk to the next entry  
        //
        if( !pGroupEntry->gid )
        {
            pGroupEntry++;
        } 
        else
        {
            break;    
        }

    } // while(pGroupEntry)
    

Cleanup:
    // update LastItemOffset
    if (!fEndOfGroups
        && pGroupEntry)
    {
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        dwNewOffset = PtrDiff32(pGroupEntry, lpbBase);
        *pdwLastItemOffset = dwNewOffset;

        // copy over GROUP_ENTRY -> GROUP_INFO
        *pOutGroupId = pGroupEntry->gid;
        dwError = ERROR_SUCCESS;

    } // IF:  find the item

    else
    {
        *pdwLastItemOffset = OFFSET_NO_MORE_GROUP;
        dwError = ERROR_FILE_NOT_FOUND;
    } // ELSE: not find 

    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::FindRootEntry(
    GROUP_ENTRY** ppOut,        // OUT: first empty entry
    BOOL fCreate                // allocate new page if needed
)
{
    INET_ASSERT(ppOut);
    *ppOut = NULL;
    
    GROUPS_ALLOC_FILEMAP_ENTRY* pPage = NULL;
    DWORD                       dwError;
    DWORD                       dwOffsetToRootEntry = 0;

    // get base offset 
    if( GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetToRootEntry))
    {
        if( !dwOffsetToRootEntry && fCreate )
        {
            dwError = CreateNewPage(&dwOffsetToRootEntry, TRUE);

            if( dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        } 
        else if( !dwOffsetToRootEntry && !fCreate )
        {
            //
            // there is no offset infomation on the mem file 
            // however, the flag says do not create a new page
            // failure is the only option here
            //
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        } 

    } // IF: retrieve base offset

    else
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 

    } // ELSE: failed to get base offset
    

    // 
    // At this point, we should either:
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetToRootEntry );
    *ppOut =  (GROUP_ENTRY*) 
        ( *_pContainer->_UrlObjStorage->GetHeapStart() + dwOffsetToRootEntry);                                   
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError; 
}



DWORD
GroupMgr::FindEntry(
    GROUPID         gid,          // gid, 0 means find first empty seat
    GROUP_ENTRY**   ppOut,        // OUT: entry with gid specified
    BOOL            fCreate       // allocate new page if needed 
                                  // (applied for searching empty seat only)
)
{
    INET_ASSERT(ppOut);

    // fCreate can only be associated with gid == 0
    INET_ASSERT( (fCreate && !gid ) || (!fCreate && gid ) );

    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwError;

    // get Root Entry
    dwError = FindRootEntry(&pGroupEntry, fCreate);
    if( dwError != ERROR_SUCCESS )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    } // failed to get the root entry


    INET_ASSERT(pGroupEntry); // pGroupEntry should be available now

    while(1)
    {
        // special case for end of this page
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use the dwFlags to indicating
            // if this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                // walk to next page
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pGroupEntry->dwGroupFlags );

            } // IF: index entry points to next page
    
            else if( fCreate)
            {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                DWORD dwOffsetToFirstEntry = 0;
                LPBYTE  lpbBase = NULL;

                // remember the old offset for pGroupEntry
                DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                // create new page!
                dwError = CreateNewPage(&dwOffsetToFirstEntry, FALSE);
                if( dwError != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                // recalculate pGroupEntry using the offset remembered 
                lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                //
                // pGroupEntry currently is the index item, insert 
                // the offset of the first item to the newly created page
                //
                pGroupEntry->dwGroupFlags = dwOffsetToFirstEntry;

                // walk to the new page 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwOffsetToFirstEntry);


            } // ELSE IF: index entry not point to new page, fCreate is
              //          set, a new page is being created  

            else
            {
                // this is the end of all groups, item still not found, 
                dwError = ERROR_FILE_NOT_FOUND;
                break;

            } // ELSE: index entry not point to new page, fCreate not set

        } // IF: this entry is an index entry


        //
        // now pGroupEntry must point to a normal group entry 
        //
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) );

        if( pGroupEntry->gid != gid )
        {
            // not found, walk to next entry
            pGroupEntry++;
        } 
        else
        {
            // found entry
            dwError = ERROR_SUCCESS;
            break;    
        }

    } // WHILE: (loop over all page)

    
Cleanup:
    if( dwError == ERROR_SUCCESS )
    {
        *ppOut = pGroupEntry;
    }
    else
    {
        *ppOut = NULL;
    }

    return dwError;
}

DWORD
GroupMgr::CreateNewPage(DWORD* dwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *dwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // mark the last entry as index to next page
        // (gid == GID_INDEX_TO_NEXT_PAGE) is the mark, 
        // the actual offset is stored at dwGroupFlags field
        //
        GROUP_ENTRY*    pEnd = (GROUP_ENTRY*) pPage->pGroupBlock;
        pEnd = pEnd + (GROUPS_PER_PAGE - 1);
        pEnd->gid = GID_INDEX_TO_NEXT_PAGE;

        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOTGROUP_OFFSET, *dwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *dwOffsetToFirstEntry = 0;
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }

        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



GROUPID
GroupMgr::ObtainNewGID()
{
    SYSTEMTIME  st;
    DWORD   dwC[2] = {0, 0};
    GROUPID gid = 0;

    // get counter from index file
    if( GetHeaderData(CACHE_HEADER_DATA_GID_LOW,  &dwC[0]) &&
        GetHeaderData(CACHE_HEADER_DATA_GID_HIGH, &dwC[1]) )
    {
        if( !dwC[0] && !dwC[1] )
        {
            // need to get the current system time
            GetSystemTime( &st );
            SystemTimeToFileTime(&st, (FILETIME*)dwC);

        } // IF: counter not initialized 

        else
        {
            // increment
            if( dwC[0] != 0xffffffff )
            {
                dwC[0] ++;
            }
            else
            {
                dwC[0] = 0;
                dwC[1] ++;
            }
        } // ELSE: counter initialized

        // send data back to cache
        if( SetHeaderData(CACHE_HEADER_DATA_GID_LOW,  dwC[0] ) &&
            SetHeaderData(CACHE_HEADER_DATA_GID_HIGH, dwC[1] ) ) 
        {
            //memcpy(&gid, dwC, sizeof(GROUPID) );
            gid = *((GROUPID *)dwC); 
        } 
    } 
    
    // apply the mask to newly created gid
    // the first 4 bits are reserved (one bit is used for stickness)  
    return (gid & GID_MASK); 
}


BOOL
GroupMgr::Translate(
    DWORD                           dwAttrib,
    INTERNET_CACHE_GROUP_INFOA*     pGroupInfo,
    GROUP_ENTRY*                    pGroupEntry, 
    DWORD                           dwFlag,
    DWORD*                          pdwSize                           
) 
{
    INET_ASSERT(pGroupInfo && pGroupEntry);
    BOOL fRet = TRUE;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               dwError;

    if( dwFlag == GROUP_ENTRY_TO_INFO )
    {
        INET_ASSERT(pdwSize);

        // clear
        memset(pGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );
        *pdwSize = 0;

        // basic entries 
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_BASIC )
        {
            pGroupInfo->dwGroupSize  = sizeof(INTERNET_CACHE_GROUP_INFOA);
            pGroupInfo->dwGroupFlags = pGroupEntry->dwGroupFlags;
            pGroupInfo->dwGroupType  = pGroupEntry->dwGroupType;
            pGroupInfo->dwDiskUsage  = (DWORD)(pGroupEntry->llDiskUsage / 1024);
            pGroupInfo->dwDiskQuota  = pGroupEntry->dwDiskQuota;
        }
        
        // user friendly name
        if( ( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
              (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  ) &&
              pGroupEntry->dwGroupNameOffset ) 
        {
            dwError = FindDataEntry(pGroupEntry, &pData, FALSE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                DWORD dwLen = strlen(pData->szName) + 1;
                INET_ASSERT( dwLen > GROUPNAME_MAX_LENGTH );

                memcpy( pGroupInfo->szGroupName, 
                        pData->szName, 
                        dwLen );

                memcpy( pGroupInfo->dwOwnerStorage,
                        pData->dwOwnerStorage, 
                        sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
            }
        }

        // set size
        *pdwSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    }

    else 
    if( dwFlag == GROUP_INFO_TO_ENTRY )
    {
        // copy
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_FLAG )
        {
            pGroupEntry->dwGroupFlags = pGroupInfo->dwGroupFlags;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_TYPE )
        {
            pGroupEntry->dwGroupType = pGroupInfo->dwGroupType;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_QUOTA )
        {
            pGroupEntry->dwDiskQuota = pGroupInfo->dwDiskQuota;
        }

        if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
            (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  )
        {

            dwError = FindDataEntry(pGroupEntry, &pData, TRUE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                
                if( dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME )  
                {
                    DWORD dwLen = strlen(pGroupInfo->szGroupName) + 1;
                    INET_ASSERT(dwLen > GROUPNAME_MAX_LENGTH);

                    memcpy( pData->szName, 
                            pGroupInfo->szGroupName, 
                            dwLen );
                }

                if( dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE ) 
                {
                    memcpy( pData->dwOwnerStorage, 
                            pGroupInfo->dwOwnerStorage,
                            sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
                }


                // BUGBUG
                // if both fields are set to be empty, we should free
                // the allocated data itam 
            }
        }
    }

    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

BOOL
GroupMgr::IsPageEmpty(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY* pGroupEntry = pHead;
    for( int i = 0; i < (GROUPS_PER_PAGE - 1); i ++)
    {
        if( pGroupEntry->gid )
        {
            break;
        }
        else
        {
            pGroupEntry++;
        }
    }

    // there is no item found on this page
    if( !pGroupEntry->gid && i == GROUPS_PER_PAGE - 1 )
    {
        fRet = TRUE; 
    }


    return fRet;
}

BOOL
GroupMgr::IsLastPage(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY*    pEnd = NULL;

    // jump to last item
    pEnd = pHead + GROUPS_PER_PAGE;

    //
    // the gid has to be marked as GID_INDEX_TO_NEXT_PAGE 
    // for index entry, and if the dwGroupFlags is 0, 
    // that means we are not pointing to any
    // other page, this is the last page indeed.
    //
    if( pEnd->gid == GID_INDEX_TO_NEXT_PAGE && !pEnd->dwGroupFlags )
    {
        fRet = TRUE;
    }

    return fRet;
}


BOOL
GroupMgr::FreeEmptyPages(DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    BOOL            fMustUnlock;

    BOOL            fRet = TRUE;
    GROUP_ENTRY*    pHead = NULL;
    GROUP_ENTRY*    pPrevHead = NULL;
    GROUP_ENTRY*    pEnd  = NULL;
    GROUP_ENTRY*    pTobeDeleted = NULL;
    BOOL            fFirstPage = TRUE;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        fRet = FALSE;
        goto Cleanup;    
    }

    // BUGBUG FindRootEntry changed the return code, check for dwError
    if( FindRootEntry(&pHead, FALSE ) )
    {
        pPrevHead = pHead; 
        while(pHead)
        {
            pTobeDeleted = NULL;

            if( IsPageEmpty(pHead) )
            {
                pTobeDeleted = pHead;

                //
                // find the offset of the next page
                // 0 which means the current page is the last one
                //
                DWORD dwOffsetNextPage = 0;
                pEnd = pHead + GROUPS_PER_PAGE;
                dwOffsetNextPage = pEnd->dwGroupFlags;

                //     
                // if the first page is to be deleted, we have to 
                // update the offset which points to the next page
                //
                if( fFirstPage)
                {
                    if( !SetHeaderData(
                        CACHE_HEADER_DATA_ROOTGROUP_OFFSET, dwOffsetNextPage))
                    {
                        fRet = FALSE;
                        goto Cleanup;
                    }
                } 
                else
                {
                
                    // 
                    // Link Prev page to Next page
                    //
                    GROUP_ENTRY* pPrevEnd = pPrevHead + GROUPS_PER_PAGE;
                    pPrevEnd->dwGroupFlags = dwOffsetNextPage;  
                }
            } 
        

            //
            // update pHead make it point to the next page 
            //
            if( !IsLastPage(pHead) )
            {
                // remember pPrev
                pPrevHead = pHead;

                // walk to next page
                pEnd = pHead + GROUPS_PER_PAGE;
                pHead = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                          + pEnd->dwGroupFlags );

                // not first page anymore
                fFirstPage = FALSE;
            }
            else
            {
                // this is the last page
                pHead = NULL;
            }

            // 
            // free the tobe deleted page
            //
            if( pTobeDeleted )
            {
                GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
                pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*) ((LPBYTE)pTobeDeleted - sizeof(FILEMAP_ENTRY));

                _pContainer->_UrlObjStorage->FreeEntry(pPage);
            }
        }
    }

    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }
    return fRet;
}


DWORD
GroupMgr::FindDataEntry(
    GROUP_ENTRY*        pGroupEntry, 
    GROUP_DATA_ENTRY**  pOutData,
    BOOL                fCreate
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupEntry && pOutData );
    *pOutData = NULL;

    BOOL            fMustUnlock;
    DWORD           dwError;
    LPBYTE          lpbBase = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR; 
        goto exit;    
    }

    if( pGroupEntry->dwGroupNameOffset )
    {
        lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
        *pOutData = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);
        dwError = ERROR_SUCCESS;
    }

    else if( fCreate)
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pGroupEntry
        DWORD_PTR   dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create new data entry
        *pOutData = GetHeadDataEntry(TRUE);
        if( *pOutData )
        {
            //
            // re-calc pGroupEntry
            //
            lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
            pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

            //
            // set entry's filename offset field 
            //
            pGroupEntry->dwGroupNameOffset = PtrDiff32(*pOutData, lpbBase);

            // succeed
            dwError = ERROR_SUCCESS;
            
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        }
//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    if( fCreate && (dwError == ERROR_SUCCESS) )
    {
        // for new item, it's nice to mark the next link to 0
        (*pOutData)->dwOffsetNext = 0;
    }
    return dwError;
}


VOID
GroupMgr::FreeDataEntry(GROUP_DATA_ENTRY* pDataEntry)
{
    // get the head entry 
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        return;
    }

    //
    // walk to the index item whose dwGroupNameOffset 
    // contains offset the the head of free list
    //
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // memset the freed data entry
    memset(pDataEntry, 0, sizeof(GROUP_DATA_ENTRY) );

    // make data item's next link points to current head
    pDataEntry->dwOffsetNext = pGroupEntry->dwGroupNameOffset;

    // make the current head to be the just freed item's offset 
    LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
    pGroupEntry->dwGroupNameOffset = PtrDiff32(pDataEntry, lpbBase);
}


LPGROUP_DATA_ENTRY
GroupMgr::GetHeadDataEntry(BOOL fCreate)
{
    GROUP_DATA_ENTRY*   pDataEntry = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;         
    LPBYTE              lpbBase = NULL;

    // get the head entry 
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // walk to the index item
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // the dwGroupNameOffset contains offset the the head of free list
    if( pGroupEntry->dwGroupNameOffset)
    {
        // get the head
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pDataEntry = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);

        // reset head to next one
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;
    }   

    else if( fCreate )
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

        // remember the old offset for pGroupEntry
        DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create a new page
        GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
        DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

        pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
                _pContainer->_UrlObjStorage->AllocateEntry(cbSize);

        if( !pPage )
        {
            goto exit;
        }
    
        // memset
        memset(pPage->pGroupBlock, 0, PAGE_SIZE_FOR_GROUPS);

        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 
        GROUP_DATA_ENTRY*   pHead = (GROUP_DATA_ENTRY*)pPage->pGroupBlock;
        pDataEntry = pHead;

        // init list on the newly created page
        for(int i = 0; i < GROUPS_DATA_PER_PAGE - 1; i++)
        {
            // point to next offset 
            GROUP_DATA_ENTRY* pNext = pHead + 1;
            pHead->dwOffsetNext =  PtrDiff32(pNext, lpbBase);
            pHead = pNext;
        }

        //
        // pGroupEntry needs to be re-calc! 
        //
        pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

        // 
        // pGroupEntry currently is the index entry of the first 
        // page, it's dwGroupNameOffset field points the head of 
        // the list of a free group data entry
        //
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        goto exit;
    }
    
exit:
    return pDataEntry;
}

DWORD
GroupMgr::GetOffsetFromList(DWORD dwHeadOffset, GROUPID gid, DWORD* pdwOffset)
{
    DWORD dwError;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;
    
    *pdwOffset = 0;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    while(1)
    {
        
        if(!_pContainer->_UrlObjStorage->IsBadGroupOffset(pListGroup->dwGroupOffset))
        {
            pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pListGroup->dwGroupOffset );
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;
        }

        if( pGroupEntry && pGroupEntry->gid == gid )
        {
            *pdwOffset = pListGroup->dwGroupOffset;
            break;
        }     

        // end of list, not found 
        if( !pListGroup->dwNext )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        }

        // walk to next
        pListGroup = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                pListGroup->dwNext); 

        if( !pListGroup )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }   
    } 

    if( *pdwOffset )    
    {
        dwError = ERROR_SUCCESS;
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

Cleanup:
    return dwError;
}


DWORD   
GroupMgr::CreateNewGroupList(DWORD* pdwHeadOffset)
{
    DWORD               dwError;
    
    // Find empty slot
    *pdwHeadOffset = 0;
    dwError = FindEmptySlotInListPage(pdwHeadOffset);
    if( ERROR_SUCCESS != dwError )
    {
        goto Cleanup;
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::AddToGroupList(DWORD dwHeadOffset, DWORD dwOffset)
{
    DWORD               dwError;
    DWORD               dwEmptySlot;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    // if the item already on the list, return success
    if( IsGroupOnList(dwHeadOffset, dwOffset) )
    {
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }

    if( !pListGroup->dwGroupOffset )
    {
        // list is empty, just need to fill up the Head
        pListGroup->dwGroupOffset = dwOffset;
    }
    else
    {
        // List is not empty, we have to walk to end of the list
        // also need to get another empty slot

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pListGroup
        DWORD_PTR dwpListGroupOffset = PtrDifference(pListGroup, *_pContainer->_UrlObjStorage->GetHeapStart());

        // find empty slot
        dwError = FindEmptySlotInListPage(&dwEmptySlot);
        if( ERROR_SUCCESS != dwError )
        {
            goto Cleanup;
        }


        // recalculate pListGroup using the offset remembered 
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        pListGroup = (LIST_GROUP_ENTRY*)(lpbBase + dwpListGroupOffset);

//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        
        // walk to end of list
        while( pListGroup->dwNext )
        {
            pListGroup = 
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 
            if( !pListGroup )
            {
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;
            }
        }

        // Get ListGroupEmpty Object from the empty slot
        pListGroupEmpty = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwEmptySlot); 
        if( !pListGroupEmpty )
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto Cleanup;
        }

        // assign the new offset
        pListGroupEmpty->dwGroupOffset = dwOffset;

        // append empty slot at the end of the list
        // this need to be done at last to prevent some invalid
        // object get on the list
        pListGroup->dwNext = dwEmptySlot;
    }


    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}

DWORD   
GroupMgr::RemoveFromGroupList(
    DWORD      dwHeadOffset, 
    DWORD      dwOffset, 
    LPDWORD    pdwNewHeadOffset
)
{
    DWORD dwError = ERROR_SUCCESS;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupPrev = NULL;
    LPBYTE              lpbBase = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

    // header is the one we need, we will have to assign new header
    if( pListGroup->dwGroupOffset == dwOffset )
    {
        // new head
        *pdwNewHeadOffset = pListGroup->dwNext;

        // empty removed head and added to free list
        pListGroup->dwGroupOffset = 0;
        pListGroup->dwNext= 0;
        AddToFreeList(pListGroup);

        // done
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( !pListGroup->dwNext )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    pListGroupPrev = pListGroup;
    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
    if( !pListGroup)
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

      
    while( pListGroup )
    {
        INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwOffset )
        {
            pListGroupPrev->dwNext = pListGroup->dwNext;

            // empty removed item and added it to free list
            pListGroup->dwGroupOffset = 0;
            pListGroup->dwNext= 0;
            AddToFreeList(pListGroup);

            dwError = ERROR_SUCCESS;
            break;
        }

        if( pListGroup->dwNext )
        {
            pListGroupPrev = pListGroup;
            pListGroup =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
        }
        else
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;

        }
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::FindEmptySlotInListPage(DWORD* pdwOffsetToSlot)
{

    DWORD   dwError;
    DWORD   dwOffsetRoot = 0;
    LPBYTE  lpbBase = NULL;
    LIST_GROUP_ENTRY*   pListGroupFreeHead = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    if( !GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 
    } 

    if( !dwOffsetRoot)
    {
        // new page needs to be created
        dwError = CreateNewListPage(&dwOffsetRoot, TRUE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;
    } 

    // 
    // At this point, we've got the root entry 
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetRoot);

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
    pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwOffsetRoot);                                   
    if( !pListGroupFreeHead )
    {
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup; 
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    // get the next free item from the list
    if( !pListGroupFreeHead->dwNext )
    {
        // no free slot left!, let's create a new page!

        // remember the old offset free list head entry
        DWORD_PTR dwpFreeHeadOffset = PtrDifference(pListGroupFreeHead, lpbBase);

        // create a new page
        DWORD  dwNewList;
        dwError = CreateNewListPage(&dwNewList, FALSE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;

        // restore
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwpFreeHeadOffset);                                   
        //
        // add the newly created page contains a list of empty
        // slot (already chained together), now update the head 
        // of free list pointing to the head of the newly created
        // list
        //
        pListGroupFreeHead->dwNext = dwNewList;
    }
//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

     
    // get the empty slot offset
    *pdwOffsetToSlot = pListGroupFreeHead->dwNext;

    // update the free list to point to the next slot
    pListGroupEmpty = (LIST_GROUP_ENTRY*)(lpbBase + pListGroupFreeHead->dwNext);
    pListGroupFreeHead->dwNext = pListGroupEmpty->dwNext;
    
    memset(pListGroupEmpty, 0, sizeof(LIST_GROUP_ENTRY) );
    
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}


DWORD
GroupMgr::CreateNewListPage(DWORD* pdwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *pdwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // chain all items together  
        // (Last item will have dwNext == 0 since we have alredy memset 
        //  the whole page ) 
        //
        LIST_GROUP_ENTRY*    pList = (LIST_GROUP_ENTRY*) pPage->pGroupBlock;

        for( DWORD dwi = 0; dwi < (LIST_GROUPS_PER_PAGE -1); dwi++)
        {
            pList->dwNext = PtrDiff32(pList+1, lpbBase);
            pList++ ;
        }


        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, 
                    *pdwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *pdwOffsetToFirstEntry = 0;
                dwError = ERROR_WINHTTP_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }
        
        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



BOOL    
GroupMgr::IsGroupOnList(DWORD dwHeadOffset, DWORD dwGrpOffset)
{
    BOOL    fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;

    LIST_GROUP_ENTRY   *pMilestone  = NULL; // used for detecting cycles
    unsigned long       dwNodeCount = 1;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwGrpOffset )
        {
            fRet = TRUE;
            break;
        }

        if( pListGroup->dwNext )
        {
            LIST_GROUP_ENTRY*   plgTemp =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 

            // Sometimes the list is corrupted and contains a cycle
            // This is detected by comparing against the saved pointer
            // (Revisiting an earlier milestone indicates a cycle)
            if (plgTemp==pMilestone)
                break;

            // Also check (and fix) simple self-loops
            if (plgTemp==pListGroup) 
            {
                pListGroup->dwNext = 0;
                break;
            }

            // Advance to next node
            pListGroup = plgTemp;

            // Choose new milestone when node count is power of 2
            dwNodeCount++;

            if ((dwNodeCount & (dwNodeCount-1)) == 0)
                pMilestone = pListGroup;
        }
        else
        {
            break;
        }
    }

Cleanup:
    return fRet;
}


BOOL    
GroupMgr::NoMoreStickyEntryOnList(DWORD dwHeadOffset)
{
    BOOL                fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // IsSticky?
            if( IsStickyGroup(pGroupEntry->gid) )
            {
                goto Cleanup;
            }
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            break;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

    //
    // reach here means we are at end of the list and can not find
    // any sticky group, return TRUE
    //
    fRet = TRUE;

Cleanup:
    return fRet;


}


void
GroupMgr::AdjustUsageOnList(DWORD dwHeadOffset, LONGLONG llDelta)
{
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        // INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // AdjustUsage
            _pContainer->AdjustGroupUsage(pGroupEntry, llDelta);
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            goto Cleanup;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

Cleanup:
    return;

}

void
GroupMgr::AddToFreeList(LIST_GROUP_ENTRY* pFreeListGroup)
{
    DWORD dwOffsetRoot  = 0;
    LIST_GROUP_ENTRY*   pFreeListHead = NULL;
    
    if( GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {

        pFreeListHead = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwOffsetRoot); 
   
        if( pFreeListHead && pFreeListGroup )
        {
            pFreeListGroup->dwNext = pFreeListHead->dwNext;

            pFreeListHead->dwNext = PtrDiff32(pFreeListGroup,
                                              *_pContainer->_UrlObjStorage->GetHeapStart());
        } 
    } 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\makefile.inc ===
..\inc\urlcache.h: urlcache.w
    wcshdr < urlcache.w > $@

!IF "$(PROCESSOR_ARCHITECTURE)" == "x86"

urlcache.sym: urlcache.map
    ..\win32s\tools\mapsympe -o urlcache.sym urlcache.map
    binplace urlcache.map
    binplace urlcache.sym

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\hndlmgr.cxx ===
#include <wininetp.h>
#include <cache.hxx>

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include "hndlmgr.hxx"

#define ALLOCATE_FIXED_MEMORY(size) malloc(size)
#define REALLOCATE_MEMORY(ptr, size, flags) realloc(ptr, size)
#define FREE_MEMORY(ptr) free(ptr)

int main ()
{
    HNDLMGR HandleMgr;
    HANDLE h[10];
    HANDLE hBad = (HANDLE) 5150;

    // Test alloc and realloc of handle heap.
    for (int i=9; i>=0; i--)
    {
        h[i] = HandleMgr.Alloc (54);
        printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    }

    // Test invalid, valid, and double free.
    printf ("Free(%d) returns %d\n", NULL, HandleMgr.Free(NULL));
    printf ("Free(%d) returns %d\n", hBad, HandleMgr.Free(hBad));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[9], HandleMgr.Free(h[9]));

    // Test mapping of invalid, free, and valid handles.
    printf ("Map(%d) = %d\n", NULL, HandleMgr.Map(NULL));
    printf ("Map(%d) = %d\n", hBad, HandleMgr.Map(hBad));
    printf ("Map(%d) = %d\n", h[3], HandleMgr.Map(h[3]));
    printf ("Map(%d) = %d\n", h[5], HandleMgr.Map(h[5]));

    // Test recycling of handles from free list.
    i = 3;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    i = 9;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);

    return 1;
}

#endif // TEST

#define INC_GROW 8

//=========================================================================
void HNDLMGR::Destroy (void)
{
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if ((DWORD_PTR) pHeap->pvHandles[iHandle] >= pHeap->dwMaxHandles)
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
        }
        FREE_MEMORY (pHeap);
    }        
}

//=========================================================================
BOOL HNDLMGR::IsValidOffset (DWORD_PTR dwp)
{
    return (pHeap && (dwp < pHeap->dwNumHandles) && 
        ((DWORD_PTR) pHeap->pvHandles[dwp]) >= pHeap->dwMaxHandles);
}

//=========================================================================
HANDLE HNDLMGR::Alloc (DWORD cbAlloc)
{
    PVOID pTemp;

    if (!pHeap)
    {
        // Allocate the heap.
        pHeap = (HNDLHEAP*) ALLOCATE_FIXED_MEMORY
            (sizeof(HNDLHEAP) + INC_GROW * sizeof(LPVOID));
        if (!pHeap)
            return NULL;

        // Initialize the heap.
        pHeap->dwNumHandles = 0;
        pHeap->dwNumInUse = 0;
        pHeap->dwMaxHandles = 0xFFFFFFFF;
        pHeap->dwFirstFree = 0;
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    else if (pHeap->dwFirstFree == pHeap->dwNumHandles)
    {
        // Reallocate the heap.
        if (pHeap->dwNumHandles + INC_GROW >= pHeap->dwMaxHandles)
        {
            // Uh oh, heap is hit the lower bound set by the allocator.
            return NULL; 
        }
        pTemp = REALLOCATE_MEMORY (pHeap, sizeof(HNDLHEAP)
            + (pHeap->dwNumHandles + INC_GROW) * sizeof(LPVOID), LMEM_MOVEABLE);
        if (!pTemp)
            return NULL;
        pHeap = (HNDLHEAP*) pTemp;

        // Extend the free list.
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    // Allocate a handle.
    pTemp = ALLOCATE_FIXED_MEMORY (cbAlloc);
    if (!pTemp)
        return NULL;
    if ((DWORD_PTR) pTemp < pHeap->dwNumHandles)
    {
        // Uh oh, allocator returned a low value!
        FREE_MEMORY (pTemp);
        return NULL;
    }
    if (pHeap->dwMaxHandles >= ((DWORD_PTR) pTemp))
        pHeap->dwMaxHandles = ((DWORD_PTR) pTemp);

    INET_ASSERT(pHeap->dwFirstFree < pHeap->dwNumHandles);
    // Pop the handle off the top of the free list.
    DWORD_PTR dwOffset = pHeap->dwFirstFree;
    pHeap->dwFirstFree = (DWORD_PTR) pHeap->pvHandles[pHeap->dwFirstFree];
    pHeap->pvHandles[dwOffset] = pTemp;
    pHeap->dwNumInUse++;
    return (HANDLE) (dwOffset + 1);
}

//=========================================================================
LPVOID HNDLMGR::Map (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;
    if (!IsValidOffset (dwOffset) || (((DWORD_PTR) pHeap->pvHandles[dwOffset]) == -1))
    {
        return NULL;
    }
    else
        return pHeap->pvHandles[dwOffset];
}

//=========================================================================
BOOL HNDLMGR::Free (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;

    if (!IsValidOffset (dwOffset))
        return FALSE;

    if (((DWORD_PTR) pHeap->pvHandles[dwOffset]) != -1)
    {
        // Push the handle on the top of the free list.
        FREE_MEMORY (pHeap->pvHandles[dwOffset]);
    }

    INET_ASSERT(pHeap->dwFirstFree <= pHeap->dwNumHandles);
    pHeap->pvHandles[dwOffset] = (LPVOID) pHeap->dwFirstFree;
    pHeap->dwFirstFree = dwOffset;
    pHeap->dwNumInUse--;
    return TRUE;
}

//=========================================================================
VOID HNDLMGR::InvalidateAll()
{
    // We're in the process of switching identities; all cache handles
    // should be invalidated so that they can no longer be used.
    
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if (((DWORD_PTR) pHeap->pvHandles[iHandle] > pHeap->dwNumHandles)
                && ((DWORD_PTR) pHeap->pvHandles[iHandle] != -1))
            {
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
                pHeap->pvHandles[iHandle] = (HANDLE)-1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains proto type definitions of several functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

extern "C"
{
    VOID CacheScavenger(LPVOID Parameter);
}

LONGLONG GetGmtTime(VOID);

DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    );

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    );

BOOL InitGlobals (void);

void LaunchScavenger (void);

DWORD
CreateUniqueFile(
    LPCSTR UrlName,
    LPTSTR Path,
    LPTSTR FileName,
    LPTSTR Extension,
    HANDLE *phfHandle
    );

#endif  // _PROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\unxcache.cxx ===
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <unistd.h>

#include <errno.h>


extern int errno;

/* Code swiped from cachecfg.cxx */
static BOOL _NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar,
                           LPTSTR pszResult, UINT cbResult)
{
     TCHAR szEnvVar[MAX_PATH];

     // don't count the NULL
     ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1);
     DWORD dwEnvVar = lstrlen(szEnvVar);

     if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar,
                       dwEnvVar, pszPath, dwEnvVar) == 2)
     {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
           strncpy(pszResult, pszEnvVar, MAX_PATH);
           strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
           return TRUE;
         }
     }

     return FALSE;
}

void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar)
{
     TCHAR szScratch[MAX_PATH];
    
     if (_NormalisePath(pszOrigPath,pszEnvVar,szScratch,sizeof(szScratch)))
        strncpy(pszOrigPath,szScratch,MAX_PATH);
}

void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,
                              LPCTSTR pszKeyName)
{
     if (!strncmp(pszKeyName,CACHE_PATH_VALUE,lstrlen(CACHE_PATH_VALUE)))
        UnixNormalisePath(pszOrigPath,pszEnvVar);
}

int UnixPathExists(LPCTSTR pszPath)
{
     struct stat statbuf;

     if (stat(pszPath, &statbuf) < 0)
     {
        /* If path does not exist */
        if (errno == ENOENT)
           return 0;
        else
           return -1;
     }
     
     /* TODO */
     /* Make sure path points to a directory */

     return 1;
}

void UnixGetValidParentPath(LPTSTR szDevice)
{
     TCHAR szDeviceExists[MAX_PATH];
     PTSTR pszDeviceExists = NULL;
     PTSTR pszEnd          = NULL;
 
     if (!szDevice)
        return;

     lstrcpy(szDeviceExists, szDevice);
 
     pszDeviceExists = szDeviceExists;
     pszEnd          = szDeviceExists + lstrlen(szDeviceExists);
 
     for(;;)
     {
        int   fPathExists;
 
        if (pszEnd == pszDeviceExists)
           break;
 
        fPathExists = UnixPathExists(pszDeviceExists);
        if (fPathExists == -1)
        {
           /* Error */
           break;
        }
        else
        if (fPathExists == 0)
        {
           /* Path does not exist */
           while (*pszEnd != DIR_SEPARATOR_CHAR &&
                  pszEnd != pszDeviceExists)
                 pszEnd--;
 
           *pszEnd = '\0';

           continue;
        }
        else
        {
           /* Path exists */
           lstrcpy(szDevice, pszDeviceExists);
           break;
        }
    }
}

/* CopyDir */

static int DoCopy();

static int UnixCopyCacheFile(const char* file_src,
                         const char* file_dest,
                         mode_t fmode);

static int UnixCreateCacheFolder( const char* dir_dest, mode_t fmode);

#ifndef BUFSIZ
#define BUFSIZ 4096
#endif /* BUFSIZ */

#define CUR_DIR  "."
#define PREV_DIR ".."

static char* pathdir1 = NULL;
static char* pathdir2 = NULL;

int CopyDir(const char* dirname1, const char* dirname2)
{
    int Error = 0;
    struct stat statdir1, statdir2;

    if (!dirname1 || !dirname2)
    {
       goto Cleanup;
    }

    /* We are assuming that dirname1 and dirname2 are absolute paths */
    if (stat(dirname1, &statdir1) < 0)
    {
       Error = errno;
       goto Cleanup;
    }
    else
    if (!S_ISDIR(statdir1.st_mode))
    {
       Error = -1; /* source is not directory */
       goto Cleanup;
    }

    if (stat(dirname2, &statdir2) < 0)
    {
       if (errno != ENOENT)
       {
          Error = errno;
          goto Cleanup;
       }
       /* It is fine if the destination dir does not exist
        * provided all directories above the leaf dir exist
        */
    }
    else
    if (!S_ISDIR(statdir2.st_mode))
    {
       Error = -1; /* destination is not directory */
       goto Cleanup; 
    }

    pathdir1 = (char*)malloc((MAX_PATH+1)*sizeof(char));
    pathdir2 = (char*)malloc((MAX_PATH+1)*sizeof(char));

    lstrcpy(pathdir1, dirname1);
    lstrcpy(pathdir2, dirname2);

    Error = DoCopy();

Cleanup:

    if (pathdir1)
       free(pathdir1);

    if (pathdir2)
       free(pathdir2);

    pathdir1 = pathdir2 = NULL;

    return Error;
}

int DoCopy()
{
    struct stat statbuf;
    struct dirent *dirp;
    DIR           *dp;
    int           Error;
    char          *ptr1, *ptr2;

    if (stat(pathdir1, &statbuf) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    /* Check if this is a regular file */
    if ((statbuf.st_mode & S_IFMT) == S_IFREG)
    {
       Error = UnixCopyCacheFile(pathdir1, pathdir2, statbuf.st_mode);
       goto Cleanup;
    }

    /* Now, we are dealing with a directory */
    if ((Error = UnixCreateCacheFolder(pathdir2, statbuf.st_mode)))
       goto Cleanup;

    ptr1 = pathdir1 + lstrlen(pathdir1);
    *ptr1++ = '/';
    *ptr1   = 0;

    ptr2 = pathdir2 + lstrlen(pathdir2);
    *ptr2++ = '/';
    *ptr2 = 0;

    if ((dp = opendir(pathdir1)) == NULL)
    {
       Error = errno;
       goto Cleanup;
    }

    while ((dirp = readdir(dp)) != NULL)
    {
          if (!lstrcmp(dirp->d_name, CUR_DIR) ||
              !lstrcmp(dirp->d_name, PREV_DIR))
             continue;

          lstrcpy(ptr1, dirp->d_name);
          lstrcpy(ptr2, dirp->d_name);

          if ((Error = DoCopy()))
             break;
    }
    ptr1[-1] = 0;
    ptr2[-1] = 0;

    /* If this fails, ignore this error */
    closedir(dp);

Cleanup:

    return Error;
}

static int UnixCreateCacheFolder( const char* path_dest, mode_t mode_src)
{
    int Error = 0;
    struct stat statbuf2;

    if (stat(path_dest, &statbuf2) < 0)
    {
       if (errno == ENOENT)
       {
          if (mkdir(path_dest, mode_src) < 0)
          {
             Error = errno;
             goto Cleanup;
          }
       }
       else
       {
          Error = errno;
          goto Cleanup;
       }
    }
    else
    if (!S_ISDIR(statbuf2.st_mode))
       Error = -1; /* we are expecting a directory */

Cleanup:
    return Error;
}

int UnixCopyCacheFile(const char* file_src, const char* file_dest, mode_t fmode)
{
    int Error = 0;
    int fd1, fd2;
    char buf[BUFSIZ];
    int  nread, nwrite;

    if ((fd1 = open(file_src, O_RDONLY)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    if ((fd2 = open(file_dest, O_CREAT|O_TRUNC|O_WRONLY, fmode)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    while((nread = read(fd1, buf, BUFSIZ)) > 0)
    {
         if ((nwrite = write(fd2, buf, nread)) != nread)
         {
            Error = errno;
            goto Cleanup;
         }
    }

    Error = 0;

Cleanup:

    if (fd1 > 0)
       close(fd1);

    if (fd2 > 0)
       close(fd2);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\oldnames.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oldnames.h

Abstract:

    contains old names of cache structures, etc.

Author:

    Richard L Firth (rfirth) 09-May-1996

Revision History:

    09-May-1996 rfirth
        Created

--*/

#define CACHE_ENTRY_INFO            INTERNET_CACHE_ENTRY_INFO
#define LPCACHE_ENTRY_INFO          LPINTERNET_CACHE_ENTRY_INFO

#define CACHE_ENTRY_INFOA           INTERNET_CACHE_ENTRY_INFOA
#define LPCACHE_ENTRY_INFOA         LPINTERNET_CACHE_ENTRY_INFOA

#define CACHE_ENTRY_INFOW           INTERNET_CACHE_ENTRY_INFOW
#define LPCACHE_ENTRY_INFOW         LPINTERNET_CACHE_ENTRY_INFOW

#define CACHE_CONFIG_PATH_ENTRY     INTERNET_CACHE_CONFIG_PATH_ENTRY
#define LPCACHE_CONFIG_PATH_ENTRY   LPINTERNET_CACHE_CONFIG_PATH_ENTRY

#define CACHE_CONFIG_PATH_ENTRYA    INTERNET_CACHE_CONFIG_PATH_ENTRYA
#define LPCACHE_CONFIG_PATH_ENTRYA  LPINTERNET_CACHE_CONFIG_PATH_ENTRYA

#define CACHE_CONFIG_PATH_ENTRYW    INTERNET_CACHE_CONFIG_PATH_ENTRYW
#define LPCACHE_CONFIG_PATH_ENTRYW  LPINTERNET_CACHE_CONFIG_PATH_ENTRYW

#define CACHE_CONFIG_INFO           INTERNET_CACHE_CONFIG_INFO
#define LPCACHE_CONFIG_INFO         LPINTERNET_CACHE_CONFIG_INFO

#define CACHE_CONFIG_INFOA          INTERNET_CACHE_CONFIG_INFOA
#define LPCACHE_CONFIG_INFOA        LPINTERNET_CACHE_CONFIG_INFOA

#define CACHE_CONFIG_INFOW          INTERNET_CACHE_CONFIG_INFOW
#define LPCACHE_CONFIG_INFOW        LPINTERNET_CACHE_CONFIG_INFOW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\hashutil.cxx ===
/*++
Copyright (c) 1996  Microsoft Corp.

Module Name: hashutil.cxx

Abstract:

    Implementation of linked list of hash tables for cache index lookup.

Author:
    Rajeev Dujari (rajeevd) 22-Oct-96

--*/

#include <wininetp.h>
#include <cache.hxx>

#define SIG_HASH ('H'|('A'<<8)|('S'<<16)|('H'<<24))

typedef LIST_FILEMAP_ENTRY HASH_FILEMAP_ENTRY;

// hash table parameters
#define BYTES_PER_PAGE 4096

#define ITEMS_PER_BUCKET ((BYTES_PER_PAGE - sizeof(HASH_FILEMAP_ENTRY))\
    / (SLOT_COUNT * sizeof(HASH_ITEM)))
#define BYTES_PER_TABLE (sizeof(HASH_FILEMAP_ENTRY) \
    + SLOT_COUNT * ITEMS_PER_BUCKET * sizeof(HASH_ITEM))


//
// Hash Function: Pearson's method
//

PRIVATE DWORD HashKey (LPCSTR lpsz, DWORD dwAddedHash)
{
    union
    {
        DWORD dw;
        BYTE c[4];
    }
    Hash, Hash2;
        
    const static BYTE bTranslate[256] =
    {
        1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
        87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
        49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
        12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
        176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
        178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
        102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
        166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
        121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
        193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
        6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
        84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
        249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
        230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
        44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
        163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
    };

    // Seed the hash values based on the first character.
    Hash.c[0] = bTranslate[ *lpsz];
    Hash.c[1] = bTranslate[(*lpsz+1) & 255];
    Hash.c[2] = bTranslate[(*lpsz+2) & 255];
    Hash.c[3] = bTranslate[(*lpsz+3) & 255];
    Hash.dw += dwAddedHash;
    
    while (*++lpsz)
    {
        // Allow URLs differing only by trailing slash to collide.
        if (lpsz[0] == '/' && lpsz[1] == 0)
            break;

        Hash2.c[0] = Hash.c[0] ^ *lpsz;
        Hash2.c[1] = Hash.c[1] ^ *lpsz;
        Hash2.c[2] = Hash.c[2] ^ *lpsz;
        Hash2.c[3] = Hash.c[3] ^ *lpsz;
            
        Hash.c[0] = bTranslate[Hash2.c[0]];
        Hash.c[1] = bTranslate[Hash2.c[1]];
        Hash.c[2] = bTranslate[Hash2.c[2]];
        Hash.c[3] = bTranslate[Hash2.c[3]];
    }

    return Hash.dw;
}
    
//
// HashLookupItem support functions specific to urlcache:
//      AllocTable
//      IsMatch
//


PRIVATE HASH_FILEMAP_ENTRY* AllocTable
    (LPVOID pAllocObj, LPBYTE* ppBase, LPDWORD* ppdwOffset)
{
    // Save the offset to the table offset.
    DWORD_PTR dpOffsetToTableOffset = (LPBYTE)*ppdwOffset - *ppBase;  // 64BIT
    
    // Ask for BYTES_PER_PAGE instead of BYTES_PER_TABLE
    // so the allocator knows to align on a page boundary.
    INET_ASSERT (BYTES_PER_PAGE >= BYTES_PER_TABLE);
    MEMMAP_FILE* pmmf = (MEMMAP_FILE*) pAllocObj;
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY *) pmmf->AllocateEntry (BYTES_PER_PAGE);
    if (!pTable)
        return NULL;  
    INET_ASSERT (! (((LPBYTE) pTable - *pmmf->GetHeapStart()) & (BYTES_PER_PAGE-1)) );

    // Chain new table to previous table.
    *ppBase = *pmmf->GetHeapStart();
    *ppdwOffset = (DWORD*) (*ppBase + dpOffsetToTableOffset);
    **ppdwOffset = (DWORD) ((LPBYTE)pTable - *ppBase);             // 64BIT
    
    // Initialize the header.
    pTable->dwSig = SIG_HASH;
    pTable->dwNext = 0;
    
    // Fill the rest of the entry with HASH_END
    DWORD* pdw = (DWORD *) (pTable + 1);
    DWORD cdw = SLOT_COUNT * ITEMS_PER_BUCKET * (sizeof(HASH_ITEM)/sizeof(DWORD));
    INET_ASSERT (!(sizeof(HASH_ITEM) % sizeof(DWORD)));
    while (cdw--)
        *pdw++ = HASH_END;

    // Return the new table.
    return pTable;
}

//
// IsMatch: determine if hash table item with a matching 32-bit hash value
// is an actual match or return NULL if a collision.
//

PRIVATE HASH_ITEM* URL_CONTAINER::IsMatch
    (HASH_ITEM *pItem, LPCSTR pszKey, DWORD dwFlags)
{
    MEMMAP_FILE* pmmf = _UrlObjStorage;

    dwFlags &= (LOOKUP_BIT_REDIR | LOOKUP_BIT_CREATE);

    if (pmmf->IsBadOffset (pItem->dwOffset))
    {
        // Fix up a bad hash table item.  This could happen if a thread
        // died between allocating a hash table item and setting the offset.
        pItem->MarkFree();
        return NULL;
    }

    FILEMAP_ENTRY* pEntry = (FILEMAP_ENTRY*)
        (*pmmf->GetHeapStart() + pItem->dwOffset);

    switch (pEntry->dwSig)
    {
        case SIG_URL:
        {        
            // Fail if lookup flags are inconsistent with url entry type.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_NOTURL));

            // Get pointer to URL.
            URL_FILEMAP_ENTRY *pUrlEntry = (URL_FILEMAP_ENTRY *) pEntry;
            LPSTR pszUrl = ((LPSTR) pUrlEntry) + pUrlEntry->UrlNameOffset;
            LPCSTR pszKey2 = pszKey, pszUrl2 = pszUrl;
            
            while ( *pszKey2 && *pszUrl2 && *pszKey2 == *pszUrl2 )
            {
                pszKey2++;
                pszUrl2++;
            }

            if (!*pszKey2 && ! *pszUrl2)
            {
                // Found exact match.

                if (dwFlags == LOOKUP_REDIR_CREATE)
                {
                    // We are have a cache entry for a URL which is now
                    // redirecting.  Delete the cache entry.
                    DeleteUrlEntry (pUrlEntry, pItem, SIG_DELETE);
                    return NULL;
                }

                return pItem;
            }

            // If redirects allowed, check for trailing slash match.
            if ((dwFlags == LOOKUP_URL_TRANSLATE)
                && (pItem->dwHash & HASH_BIT_REDIR))
            {
                DWORD cbUrl = strlen (pszUrl);
                DWORD cbKey = strlen (pszKey);
                INET_ASSERT (cbUrl && pszUrl[cbUrl - 1] == '/');
                if (cbUrl == (cbKey + 1) && !memcmp (pszUrl, pszKey, cbKey))
                    return pItem;
            }
                
            return NULL;
        }
        
        case SIG_REDIR:
        {
            // When online, filter out offline redirect entries.
            if (dwFlags == LOOKUP_URL_NOCREATE)
                return NULL;

            // Check that redirect URL matches exactly.
            REDIR_FILEMAP_ENTRY* pRedir = (REDIR_FILEMAP_ENTRY *) pEntry;
            if (lstrcmp (pszKey, pRedir->szUrl))
                return NULL;

            switch (dwFlags)
            {
                case LOOKUP_URL_CREATE:

                    // We are creating a new entry for a URL that once
                    // redirected.  Delete the stale redirect entry.
                    pmmf->FreeEntry (pRedir);
                    pItem->MarkFree();
                    return NULL;

                case LOOKUP_REDIR_CREATE:
                
                    // Return the redirect item if we're looking for it.
                    return pItem;

                case LOOKUP_URL_TRANSLATE:

                    // Otherwise, translate through the redirect item.
                    pItem = (HASH_ITEM *)
                        (*pmmf->GetHeapStart() + pRedir->dwItemOffset);

                    // Perform some consistency checks.
                    if (pItem->dwHash & HASH_BIT_NOTURL)
                        return NULL; // not an URL entry
                    if ((pItem->dwHash & ~SLOT_MASK) != pRedir->dwHashValue)
                        return NULL; // not a matching URL entry
                    return pItem;

                default:
                    INET_ASSERT (FALSE);                
            }
        }
        
        default:
        {
            // Fix up a bad hash table entry.  This can happen if a thread
            // died between allocating a hash table item and setting the offset.
            pItem->MarkFree();
            return NULL;
        }            
    }
}


//
// HashFindItem: finds a matching entry or else the first free slot
//

BOOL URL_CONTAINER::HashFindItem
    (LPCSTR pszKey, DWORD dwFlags, HASH_ITEM** ppItem)
{    
    INET_ASSERT(!((dwFlags & LOOKUP_URL_DONT_FOLLOW) && (dwFlags & LOOKUP_BIT_CREATE)));
    DWORD dwFind = 0;
    BOOL fLookAgain = !(dwFlags & LOOKUP_URL_DONT_FOLLOW) && GlobalIdentity;
again:
    LPVOID pAllocObj = (LPVOID) _UrlObjStorage;
    LPBYTE pBase = *_UrlObjStorage->GetHeapStart();
    LPDWORD pdwTableOffset = _UrlObjStorage->GetPtrToHashTableOffset();
    
    // Scan flags.
    BOOL fCreate = dwFlags & LOOKUP_BIT_CREATE;

    HASH_ITEM* pFree = NULL;
    DWORD nBlock = 0;
    
    // Hash the URL and calculate the slot.
    DWORD dwHash = HashKey(pszKey, dwFind);
    DWORD iSlot = dwHash & SLOT_MASK;
    dwHash &= ~SLOT_MASK;

    // Walk through the list of hash tables.
    while (*pdwTableOffset && !_UrlObjStorage->IsBadOffset(*pdwTableOffset))
    {
        // Calculate offset to next hash table and validate signature.
        HASH_FILEMAP_ENTRY* pTable =
            (HASH_FILEMAP_ENTRY*) (pBase + *pdwTableOffset);
        if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock++)
            break;

        // Calculate offset to bucket in this table.
        HASH_ITEM* pItem = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;

        // Scan the bucket.
        for (DWORD iSeat=0; iSeat<ITEMS_PER_BUCKET; iSeat++, pItem++)
        {
            // No reserved bits should ever be set on an item.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));

            switch (pItem->dwHash)
            {
                case HASH_FREE: // free item but more items might follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    // If caller wants a free item, record the first one we find.
                    if (!pFree && fCreate)
                        pFree = pItem;
                }                        
                    continue;

                case HASH_END: // first previously unused free item; no more to follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    if (!fCreate)
                        *ppItem = NULL;
                    else
                    {
                        // Hand out the first free slot.
                        if (pFree)
                        {
                            // Invalidate offset in case caller neglects to set it.
                            pFree->dwOffset = HASH_END;
                            *ppItem = pFree;
                        }
                        else
                        {
                            // The first free slot has never been used before.
                            INET_ASSERT (pItem->dwOffset == HASH_END);
                            *ppItem = pItem;
                        }
                        (*ppItem)->dwHash = dwHash;
                    }
                }
                    return FALSE;

                default:
                {
                    // Check if the key matches.
                    if (dwHash == (pItem->dwHash & ~SLOT_MASK))
                    {
                        if (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS)
                        {
                            *ppItem = pItem;
                            return TRUE;
                        }
                        
                        HASH_ITEM* pItem2 = IsMatch(pItem, pszKey, dwFlags);
                        if (pItem2)
                        {
                            LPURL_FILEMAP_ENTRY pEntry = 
                                (URL_FILEMAP_ENTRY*)(*(((MEMMAP_FILE*)_UrlObjStorage)->GetHeapStart())
                                                + pItem2->dwOffset);

                            // This will check for a ~U: header or IDENTITY_CACHE_ENTRY
                            // We use the first for compatibility with Wininet5
                            // We use IDENTITY_CACHE_ENTRY for entries we wish to hide from Wininet5
                            if ((pEntry->dwSig==SIG_URL)
                                && (!(dwFlags & LOOKUP_URL_DONT_FOLLOW) 
                                   && ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY) 
                                       || IsPerUserEntry(pEntry))))
                            {
                                // We'll search again for an entry corresponding to GlobalIdentity
                                if (fLookAgain)
                                {
                                    fLookAgain = FALSE;
                                    dwFind = GlobalIdentity;
                                    goto again;
                                }

                                // Guarantee that this is what we want
                                if (pEntry->GetIdentity()!=GlobalIdentity)
                                {
                                    continue;
                                }
                                // If we're looking for an identity-0 cache entry
                                // and there is no filename, we need to do the following:
                                // 1. if we're trying to create an entry, then return this
                                // 2. otherwise, say No, the entry is not present
                                if (!pEntry->InternalFileNameOffset && !fCreate)
                                {
                                    *ppItem = NULL;
                                    return FALSE;
                                }
                            }
                            *ppItem = pItem2;
                            return TRUE;
                        }
                    }                    
                }
                    continue;
                    
            } // end switch
          
        } // end for loop to scan seats in bucket
        
        // Follow the link to the next table.
        pdwTableOffset = &pTable->dwNext;

    } // end while (*pdwTableOffset)

    // If we've encountered a corrupt table, we'll have to recover
    if (*pdwTableOffset)
    {
        INET_ASSERT(FALSE);
        *pdwTableOffset = 0;
    }
   
    // We are out a buckets, so an item hasn't been found.

    if (fCreate && !pFree)
    {
        // Caller wanted a free item but we didn't find one.
       
        HASH_FILEMAP_ENTRY* pTable = AllocTable
            (pAllocObj, &pBase, &pdwTableOffset);

//////////////////////////////////////////////////////////////////////
// WARNING: the file might have grown and remapped, so any pointers //
// hereafter must be recalculated by offsets from the new base.     //
//////////////////////////////////////////////////////////////////////

        if (pTable)
        {
            pTable->nBlock = nBlock;
            // Calculate next free slot.
            pFree = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;
            INET_ASSERT (pFree->dwHash   == HASH_END);
            INET_ASSERT (pFree->dwOffset == HASH_END);
        }
    }

    // Return free item if desired and indicate no item found.
    if (pFree)
    {
        INET_ASSERT (fCreate);
        pFree->dwHash   = dwHash;
        pFree->dwOffset = HASH_END; // invalid in case caller neglects to set it
    }
    *ppItem = pFree;
    return FALSE;
}

//
// HashFindNextItem: scans the table for the next valid URL item
//

PUBLIC
HASH_ITEM*
HashGetNextItem
(
    IN     LPVOID       pAllocObj,      // allocator object
    IN     LPBYTE       pBase,          // base for all offsets
    IN OUT LPDWORD      pdwItemOffset,  // current item offset
    IN     DWORD        dwFlags         // include redirects?
)
{
    INET_ASSERT (!(dwFlags & ~LOOKUP_BIT_REDIR));
    
    // Check if there if the hash table is empty (or we are at the end already.)
    if (!*pdwItemOffset)
        return NULL;

    HASH_ITEM* pItem = (HASH_ITEM*) (pBase + *pdwItemOffset);

    // Calculate current table offset, assuming it's the previous page boundary.
    INET_ASSERT (BYTES_PER_TABLE <= BYTES_PER_PAGE);
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY*) (((DWORD_PTR)pItem) & ~(BYTES_PER_PAGE - 1));

    // Advance item pointer to next location.
    if (pItem == (HASH_ITEM*) pTable)
        pItem = (HASH_ITEM*) (pTable + 1); // first location in table
    else
        pItem++; // next location in table

    do // Scan the list of tables.
    {
        if (pTable->dwSig != SIG_HASH)
            break;
            
        // Scan the current table.
        for (; (LPBYTE) pItem < ((LPBYTE) pTable) + BYTES_PER_TABLE; pItem++)
        {
            // No reserved bits should be set.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));
            
            if (!(pItem->dwHash & HASH_BIT_NOTURL)
                ||      (dwFlags /* & LOOKUP_BIT_REDIR */)
                    &&  ((pItem->dwHash & HASH_FLAG_MASK) == HASH_REDIR))
            {
                // Found a valid entry.
                *pdwItemOffset = (DWORD) ((LPBYTE)pItem - pBase);  // 64BIT
                return pItem;
            }
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
            pTable = NULL;
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (pBase + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                pTable = NULL;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
        while (pTable);

    // We reached the end of the last table.
    *pdwItemOffset = 0;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\ids.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    ids.cxx

Abstract:

    Contains functions responsible for managing identities in wininet
    
    Contents:

Author:

    July - September 1999. akabir

Environment:

    Win32 user-mode DLL

Revision History:


--*/

#include <wininetp.h>
#include <cache.hxx>

#undef SHGetFolderPath
HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);


#if 0

#include <hlink.h>
#include <urlmon.h>
#include <shlobj.h>
#define HMONITOR_DECLARED    1
#include <shlobjp.h>


typedef HRESULT (*PFNSHGETDESKTOPFOLDER)(IShellFolder**);

HRESULT _SHGetDesktopFolder(IShellFolder **psfDesktop)
{
    HMODULE h = LoadLibrary("shell32.dll");
    HRESULT hr = E_POINTER;
    if (h) 
    {
        PFNSHGETDESKTOPFOLDER pfn = (PFNSHGETDESKTOPFOLDER)GetProcAddress(h, "SHGetDesktopFolder");
        if (pfn)
        {
            hr = pfn(psfDesktop);
        }
        FreeLibrary(h);
    }
    return hr;
}

typedef VOID (*PFNILFREE)(LPITEMIDLIST);

VOID _ILFree(LPITEMIDLIST pidl)
{
    HMODULE h = LoadLibrary("shell32.dll");
    if (h) 
    {
        PFNILFREE pfn = (PFNILFREE)GetProcAddress(h, "ILFree");
        if (pfn)
        {
            pfn(pidl);
        }
        FreeLibrary(h);
    }
}


const GUID  DefaultGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const GUID  IID_IHistSFPrivate = { 0x62e1261L, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38 };
#endif // 0


// -- Utility functions --------------------------------------------------------------------------------------

// Create an ansi representation of a guid.
VOID GuidToAnsiStr(GUID* pGuid, PSTR psz, DWORD dwSize)
{
    WCHAR   wszUid[MAX_PATH];
    StringFromGUID2(*pGuid, wszUid, ARRAY_ELEMENTS(wszUid));
    SHUnicodeToAnsi(wszUid, psz, dwSize);
}


REGISTRY_OBJ* CreateExtensiRegObjFor(HKEY hKey, GUID* pguid)
{
    REGISTRY_OBJ *pro = NULL;

    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(pguid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s\\%s", 
                              IDENTITIES_KEY, 
                              sz, 
                              EXTENSIBLE_CACHE_PATH_KEY) >= 0)
    {
        pro = new REGISTRY_OBJ(hKey, szBranches, CREATE_KEY_IF_NOT_EXISTS);
    }

    return pro;
}

#ifdef WININET6
DWORD IDRegDwordCore(LPCTSTR psz, PDWORD pdw, BOOL fSet)
{
    INET_ASSERT(GlobalIdentity);
    
    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(&GlobalIdentityGuid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    DWORD dwError = ERROR_INVALID_PARAMETER;
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s", 
                              IDENTITIES_KEY, 
                              sz) >= 0)
    {
        REGISTRY_OBJ ro(GlobalCacheHKey, szBranches);
        dwError = ro.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            dwError = fSet ? ro.SetValue((LPTSTR)psz, pdw)
                           : ro.GetValue((LPTSTR)psz, pdw);
        }
    }
    return dwError;
}

DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw)
{
    return IDRegDwordCore(psz, pdw, FALSE);
}

DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw)
{
    return IDRegDwordCore(psz, &dw, TRUE);
}
#endif

// Disable the funny business of altering identities for now. It can be
// enabled once we have a better understanding of how this can fit
// into WinHttp
#if 0

VOID CreateCurrentHistory()
{
    INTERNET_CACHE_CONFIG_INFO icci;
    icci.dwStructSize = sizeof(icci);
    if (GlobalUrlContainers->GetUrlCacheConfigInfo(&icci, NULL, CACHE_CONFIG_HISTORY_PATHS_FC)
        && SUCCEEDED(CoInitialize(NULL)))
    {
        // We want to ensure that the history is valid for this user.
        IShellFolder *psfDesktop;
        if (SUCCEEDED(_SHGetDesktopFolder(&psfDesktop)))
        {
            WCHAR wszPath[MAX_PATH];
            LPITEMIDLIST pidlHistory;
            IShellFolder *psfHistory;
            MultiByteToWideChar(CP_ACP, 0, icci.CachePath, -1, wszPath, ARRAY_ELEMENTS(wszPath));
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // trim the "content.ie5" junk
            if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL, wszPath, NULL, &pidlHistory, NULL)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pidlHistory, NULL, IID_IShellFolder, (VOID**)&psfHistory)))
                {
                    IHistSFPrivate *phsf;
                    if (SUCCEEDED(psfHistory->QueryInterface(IID_IHistSFPrivate, (void**)&phsf)))
                    {
                        FILETIME ftBogus = { 0 };
                        // This forces the validation in shdocvw
                        phsf->WriteHistory(L"", ftBogus, ftBogus, NULL);
                        phsf->Release();
                    }
                    psfHistory->Release();
                }
                _ILFree(pidlHistory);
            }
            psfDesktop->Release();
        }
        CoUninitialize();
    }
}


CONST TCHAR c_szIdentityOrdinal[] = "Identity Ordinal";

DWORD MapGuidToOrdinal(GUID* lpGUID)
{
    DWORD dwOrdinal = 0;
    HKEY    hSourceSubKey;

    if (!memcmp(lpGUID, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return 0;
    }

    if (RegCreateKey(HKEY_CURRENT_USER, IDENTITIES_KEY, &hSourceSubKey) == ERROR_SUCCESS)
    {        
        CHAR    szUid[MAX_PATH];
        GuidToAnsiStr(lpGUID, szUid, ARRAY_ELEMENTS(szUid));

        DWORD   dwSize, dwType;
        DWORD   dwIdentityOrdinal = 1;

        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        HKEY    hkUserKey;
        if (RegCreateKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                }
            }            
            RegCloseKey(hkUserKey); 
        }
        RegCloseKey(hSourceSubKey);
    }

    INET_ASSERT(dwOrdinal);
    return dwOrdinal;
}

DWORD AlterIdentity(DWORD dwFlags)
{
    if (!GlobalIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
    switch (dwFlags)
    {
    case INTERNET_IDENTITY_FLAG_PRIVATE_CACHE:
    case INTERNET_IDENTITY_FLAG_SHARED_CACHE:
    case INTERNET_IDENTITY_FLAG_CLEAR_DATA:
    case INTERNET_IDENTITY_FLAG_CLEAR_COOKIES:
    case INTERNET_IDENTITY_FLAG_CLEAR_HISTORY:
    case INTERNET_IDENTITY_FLAG_CLEAR_CONTENT:
        break;
    }    
    return ERROR_CALL_NOT_IMPLEMENTED;
}

DWORD RemoveIdentity(GUID* pguidIdentity)
{
    if (!pguidIdentity 
        || !memcmp(pguidIdentity, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CHAR    szUid[MAX_PATH];
    GuidToAnsiStr(pguidIdentity, szUid, ARRAY_ELEMENTS(szUid));
    DWORD dwIdentity = MapGuidToOrdinal(pguidIdentity);
    if (dwIdentity==GlobalIdentity)
    {
        DWORD dwErr = SwitchIdentity(NULL);
        if (dwErr!=ERROR_SUCCESS)
            return dwErr;
    }

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    REGISTRY_OBJ roIds(HKEY_CURRENT_USER, IDENTITIES_KEY);
    if (roIds.GetStatus()==ERROR_SUCCESS)
    {        
        // We want to delete the containers before we delete the reg keys.
        // First the extensible containers
        REGISTRY_OBJ* pro = CreateExtensiRegObjFor(HKEY_CURRENT_USER, pguidIdentity);
        if (pro && (pro->GetStatus()==ERROR_SUCCESS))
        {
            CHAR szVendorKey[MAX_PATH];
            while (pro->FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
            {
                REGISTRY_OBJ roVendor(pro, szVendorKey);
                if (roVendor.GetStatus()==ERROR_SUCCESS)
                {
                    TCHAR szPath[MAX_PATH];
                    DWORD ccKeyLen = ARRAY_ELEMENTS(szPath);
                    if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szPath, &ccKeyLen)==ERROR_SUCCESS)
                    {
                        TCHAR szScratch[MAX_PATH+1];
                        ExpandEnvironmentStrings(szPath, szScratch, ARRAY_ELEMENTS(szScratch)-1); // don't count the NULL
                        DeleteCachedFilesInDir(szScratch);
                        RemoveDirectory(szScratch);
                    }
                }
            }
        }
        if (pro)
        {
            delete pro;
        }
        TCHAR szPath[MAX_PATH];
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_COOKIES | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            StrCatBuff(szPath, "\\History.IE5", ARRAY_ELEMENTS(szPath));
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }

        // We'll leave the content; it'll be scavenged anyway.        
        if (roIds.DeleteKey(szUid)==ERROR_SUCCESS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    return dwErr;
}


DWORD SwitchIdentity(GUID* pguidIdentity)
{
    DWORD dwIdentity = pguidIdentity ? MapGuidToOrdinal(pguidIdentity) : 0;
    if (dwIdentity==GlobalIdentity)
        return ERROR_SUCCESS;

    DWORD dwErr = ERROR_SUCCESS;
    
    LOCK_CACHE();
    INET_ASSERT(dwIdentity!=GlobalIdentity);

    CloseTheCookieJar();

    DWORD dwTemp = GlobalIdentity;
    GUID guidTemp;
    GlobalIdentity = dwIdentity;
    GlobalCacheInitialized = FALSE;
    memcpy(&guidTemp, &GlobalIdentityGuid, sizeof(GlobalIdentityGuid));
    if (dwIdentity==0)
    {
        memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));
    }
    else
    {
        memcpy(&GlobalIdentityGuid, pguidIdentity, sizeof(*pguidIdentity));
    }

    CConMgr* NewGUC = new CConMgr();

    if (!NewGUC 
        || (NewGUC->GetStatus()!=ERROR_SUCCESS)
        || (!InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0)))
    {
        INET_ASSERT(FALSE);
        if (NewGUC)
            delete NewGUC;
        
        dwErr = ERROR_WINHTTP_INTERNAL_ERROR;
        GlobalCacheInitialized = TRUE;
        GlobalIdentity = dwTemp;
        memcpy(&GlobalIdentityGuid, &guidTemp, sizeof(GlobalIdentityGuid));
        goto exit;
    }

    // We need to stop the scavenger
    GlobalPleaseQuitWhatYouAreDoing = TRUE;
    while (GlobalScavengerRunning!=-1)
    {
        Sleep(0);
    }
    
    delete GlobalUrlContainers;
    GlobalUrlContainers = NewGUC;
    GlobalCacheInitialized = TRUE;

    // It's safe now, you can scavenge
    GlobalPleaseQuitWhatYouAreDoing = FALSE;

    if (AnyFindsInProgress(0))
    {
        HandleMgr.InvalidateAll();
    }

    CreateCurrentHistory();
    
    // Note to ASK: check what this call does, if it affects identities
    if ((dwErr = GlobalUrlContainers->CreateDefaultGroups())!=ERROR_SUCCESS)
        goto exit;
        
    if (!OpenTheCookieJar()) 
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

#ifdef WININET6
    // Set warnings appropriately.
    GlobalWarnOnPost = FALSE;
    GlobalWarnAlways = FALSE;
    GlobalWarnOnZoneCrossing = TRUE;
    GlobalWarnOnBadCertSending = FALSE;
    GlobalWarnOnBadCertRecving = TRUE;
    GlobalWarnOnPostRedirect = TRUE;
    GlobalDataReadWarningUIFlags();
#endif

exit:
    UNLOCK_CACHE();
    INET_ASSERT((dwErr==ERROR_SUCCESS));
    return dwErr;
}

#endif


// CreateExtensiRegObj ----------------
// Create an identity-appropriate registry object
// for extensible cache containers.

REGISTRY_OBJ* CreateExtensiRegObj(HKEY hKey)
{
    REGISTRY_OBJ *pro = NULL;
    
    if (GlobalIdentity)
    {
        pro = CreateExtensiRegObjFor(hKey, &GlobalIdentityGuid);
    }
    else
    {
        REGISTRY_OBJ roCache(hKey, CACHE5_KEY);
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            pro = new REGISTRY_OBJ(&roCache, EXTENSIBLE_CACHE_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
        }
    }

    if (pro && pro->GetStatus()!=ERROR_SUCCESS)
    {
        delete pro;
        pro = NULL;
    }

    return pro;
}


// GenerateStringWithOrdinal ------------
// We want to append the identity ordinal to a string
// If psz is null, then pszBuffer better contain a 0-terminated string that we can
//      append the ordinal to.
// Otherwise, we copy psz to pszBuffer and append to that.
BOOL GenerateStringWithOrdinal(PCTSTR psz, DWORD dwOrdinal, PTSTR pszBuffer, DWORD dwMax)
{
    DWORD cc = psz ? lstrlen(psz) : lstrlen(pszBuffer);

    if (cc>dwMax)
        return FALSE;

    if (psz)
    {
        memcpy(pszBuffer, psz, cc*sizeof(*pszBuffer));
    }
    
    if (dwOrdinal)
    {
        if (!AppendSlashIfNecessary(pszBuffer, &cc))
            return FALSE;   

        if (wnsprintf(pszBuffer+cc, dwMax-cc,
                                "%d", 
                                dwOrdinal) < 0)
            return FALSE;
    }
    else
    {
        pszBuffer[cc] = TEXT('\0');
    }
    
    return TRUE;
}

// IsPerUserEntry
// Examine the headers of a cache entry to determine whether or 
// not it is user-specific

BOOL IsPerUserEntry(LPURL_FILEMAP_ENTRY pfe)
{
    INET_ASSERT(pfe);
    
    BOOL fRet = FALSE;
    PTSTR lpszHeaderInfo = (PTSTR)pfe + pfe->HeaderInfoOffset;
    DWORD dwHeaderSize = pfe->HeaderInfoSize;

    if (!lpszHeaderInfo || !dwHeaderSize)
    {
        return FALSE;
    }
    
    LPSTR lpTemp = lpszHeaderInfo+dwHeaderSize-1;
    LPSTR lpTemp2;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) 
    {
        if (*lpTemp ==':') 
        {
                   // compare with "~U:"
            fRet = (!strnicmp(lpTemp-2, vszUserNameHeader, sizeof(vszUserNameHeader)-1))
                   // guarantee that this is the beginning of a header
                   && (((lpTemp-2)==lpszHeaderInfo)
                       || isspace(*(lpTemp-3)));
            break;
        }
        --lpTemp;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <wininetp.h>
#include <cache.hxx>

REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = DEFAULT_KEY_ACCESS;
    return;
};


DWORD REGISTRY_OBJ::WorkWith(
    HKEY ParentHandle,
    LPTSTR KeyName,
    DWORD dwFlags,
    DWORD dwAccess
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = dwAccess;
    
    _Status = REGOPENKEYEX(
                ParentHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        REGISTRY_OBJ roTemp(ParentHandle, (LPSTR)NULL);
        _Status = roTemp.GetStatus();
        if (_Status==ERROR_SUCCESS)
        {
            _Status = roTemp.Create(KeyName, &_RegHandle);
        }
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD REGISTRY_OBJ::WorkWith(
    REGISTRY_OBJ *ParentObj,
    LPTSTR KeyName,
    DWORD dwFlags
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = ParentObj->GetAccessFlags();
    _Status = REGOPENKEYEX(
                ParentObj->_RegHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        _Status = ParentObj->Create(KeyName, &_RegHandle);
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    HKEY* pChildHandle
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    _Status = REGCREATEKEYEX(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               (pChildHandle) ? pChildHandle : &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS )
    {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
#else
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
    }

    //
    // close the child handle before return.
    //

    if (!pChildHandle)
    {
        REGCLOSEKEY( ChildHandle );
    }

    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

//    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
//    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPTSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

#ifdef unix
    if (Error == ERROR_SUCCESS) {
       CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)StringData,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           CacheHeap->Free(StringData);
           return (Error);
        }

        CacheHeap->Free(StringData);
        StringData = (LPBYTE)CacheHeap->Alloc( Length );
        if(StringData == NULL){
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        memcpy(StringData,szExpand,Length+1);
    }
#endif /* unix */

    *Data = (LPTSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPTSTR StrPtr = (LPTSTR)StringData;
        DWORD Len;

        while( (Len = lstrlen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

#ifdef unix
    {
    CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)Data,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           return (Error);
        }
        memcpy(Data,szExpand,Length+1);
    }
#endif /* unix */
    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPTSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    UNIX_NORMALIZE_IF_CACHE_PATH((LPTSTR)Data,TEXT("%USERPROFILE%"),ValueName);

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(TCHAR) * (lstrlen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPTSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(TCHAR);
    Error = RegEnumKeyEx(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPTSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPTSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPTSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPTSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPTSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKey( _RegHandle, (LPTSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::DeleteValue(
    LPTSTR ValueName
    )
{
    DWORD Error;
    Error = RegDeleteValue(
                _RegHandle,
                ValueName
                );


    return( Error );
}


DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\urlcache.h ===
#ifndef URLCACHE_H

#define URLCACHE_H

/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    urlcache.h

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:

    Rajeev Dujari (rajeevd) 10-Apr-1997

Revision History:

    10-Apr-97 rajeevd
        Created

--*/


DWORD
UrlCacheRetrieve
(
    IN  LPSTR                pszUrl,
    IN  BOOL                 fRedir,
    OUT HANDLE*              phStream,
    OUT CACHE_ENTRY_INFOEX** ppCEI
);

void UrlCacheFlush (void); // check registry to flush cache

DWORD 
UrlCacheCreateFile
(
    IN LPCSTR szUrl, 
    IN OUT LPTSTR szFile, 
    IN LPTSTR szExt,
    IN HANDLE* phfHandle,
    IN BOOL fCreatePerUser = FALSE,
    IN DWORD dwExpectedLength = 0
);

struct AddUrlArg
{
    LPCSTR   pszUrl;
    LPCSTR   pszRedirect;
    LPCTSTR  pszFilePath;
    DWORD    dwFileSize;
    LONGLONG qwExpires;
    LONGLONG qwLastMod;
    LONGLONG qwPostCheck;
    FILETIME ftCreate;
    DWORD    dwEntryType;
    LPCSTR   pbHeaders;
    DWORD    cbHeaders;
    LPCSTR   pszFileExt;
    BOOL     fImage;
    DWORD    dwIdentity;
};


DWORD UrlCacheCommitFile (IN AddUrlArg* pArgs);

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile);

DWORD UrlCacheSendNotification (IN DWORD dwOp);

BOOL IsExpired
(
    CACHE_ENTRY_INFOEX* pInfo, 
    DWORD dwCacheFlags, 
    BOOL* pfLaxyUpdate
);

extern const char vszUserNameHeader[4];

#ifdef UNIX
extern "C"
#endif /* UNIX */

BOOL GetIE5ContentPath( LPSTR szPath);

#if 0
DWORD SwitchIdentity(GUID* guidIdentity);
DWORD RemoveIdentity(GUID* guidIdentity);
DWORD AlterIdentity(DWORD dwControl);
#endif

#ifdef WININET6
DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw);
DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw);
#endif

#endif //URLCACHE.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\urlcache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corp.

Module Name: urlcache.cxx

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:
    Rajeev Dujari (rajeevd) 10-Apr-97

--*/

#include <wininetp.h>
#include <cache.hxx>

DWORD
UrlCacheRetrieve
(
        IN  LPSTR                pszUrl,
        IN  BOOL                 fOffline,
        OUT HANDLE*              phStream,
        OUT CACHE_ENTRY_INFOEX** ppCEI
)
{
    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr;

    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DWORD dwLookupFlags = fOffline? LOOKUP_URL_TRANSLATE
        : (LOOKUP_BIT_SPARSE | LOOKUP_URL_NOCREATE);

    DWORD cbCEI;
    
    // Find the container and search the index.
    dwErr = GlobalUrlContainers->RetrieveUrl(
                    pszUrl, 
                    (CACHE_ENTRY_INFO **) ppCEI, 
                    &cbCEI, 
                    dwLookupFlags, 
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    fLocked = TRUE;
    if ((*ppCEI)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {    
        *phStream = NULL;    
    }
    else
    {
        // Allocate a stream handle.
        CACHE_STREAM_CONTEXT_HANDLE* pStream;
        LOCK_CACHE();
        hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
        if (hStream)
        {
            pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
            INET_ASSERT (pStream);
        }
        UNLOCK_CACHE();
        if (!hStream)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        // Open the file.
        hFile = CreateFile
        (
            (*ppCEI)->lpszLocalFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
        );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError();
            goto Cleanup;
        }

        DWORD dwFileSize = GetFileSize(hFile, NULL);

        if (dwFileSize != (*ppCEI)->dwSizeLow) 
        {
            dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
            goto Cleanup;
        }

        pStream->FileHandle = hFile;

        // Copy URL name storage.
        pStream->SourceUrlName = NewString(pszUrl);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        *phStream = hStream;
    }
    
    dwErr = ERROR_SUCCESS;

Cleanup:

    if( dwErr != ERROR_SUCCESS )
    {
        if (*ppCEI)
        {
            FREE_MEMORY (*ppCEI);
            *ppCEI = NULL;
        }
        if (hStream)
            HandleMgr.Free (hStream);
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(pszUrl);
    }
    return dwErr;
}


void UrlCacheFlush (void)
{
    DWORD fPersist;
    
    REGISTRY_OBJ regCache (HKEY_CURRENT_USER, OLD_CACHE_KEY);
    
    if (    ERROR_SUCCESS == regCache.GetStatus()
        &&  ERROR_SUCCESS == regCache.GetValue (CACHE_PERSISTENT, &fPersist)
        &&  !fPersist
       )
    {
        FreeUrlCacheSpace (NULL, 100, STICKY_CACHE_ENTRY);
    }
}

DWORD UrlCacheCreateFile(LPCSTR szUrl, LPTSTR szExt, LPTSTR szFile, HANDLE *phfHandle, BOOL fCreatePerUser, DWORD dwExpectedLength)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->CreateUniqueFile(szUrl, dwExpectedLength, szExt, szFile, phfHandle, fCreatePerUser);
}

DWORD UrlCacheCommitFile(AddUrlArg* pArgs)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else        
        return GlobalUrlContainers->AddUrl(pArgs);
}

DWORD UrlCacheSendNotification(DWORD   dwOp)
{
    DWORD Error;

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto Cleanup;
    }
        
    Error = GlobalUrlContainers->SendCacheNotification(dwOp);

Cleanup:
    return Error;
}

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile)
{
    if (!InitGlobals())
        return ERROR_WINHTTP_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->AddLeakFile (pszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\wininet.inc ===
!IF 0

Copyright (c) 1994  Microsoft Corporation

Module Name:

    wininet.inc

Abstract:

    Common makefile contents for wininet project

Author:

    Richard L Firth (rfirth) 10-Feb-1996

Revision History:

    10-Feb-1996 rfirth
        Created

!ENDIF

SXS_ASSEMBLY_NAME=Microsoft.Windows.WinHTTP
SXS_SHORT_ASSEMBLY_NAME=msft-windows-winhttp
SXS_ASSEMBLY_VERSION=5.1
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1

!IFNDEF SDKINC
SDKINC=$(SDK_INC_PATH)
!ENDIF

!IFDEF LIBDIR
!ERROR LIBDIR already defined - choose new name
!ENDIF

LIBDIR=..\lib\$(_OBJ_DIR)

#
# if TARGETPATH is not defined (in the paths that build libraries) then this
# is the default target path
#

!IFNDEF TARGETPATH
TARGETPATH=$(LIBDIR)
TARGETTYPE=LIBRARY
!ENDIF

#
# what it is that we're building
#

MAJORCOMP=winhttpx

USE_NOLIBS=1
USE_MSVCRT=1
NO_NTDLL=1


#
# compiler definitions
#

C_DEFINES=$(C_DEFINES) -D_WINHTTP_INTERNAL_  -DCOMPILING_ROCKALL_LIBRARY -DFD_SETSIZE=256

# Get same version from NT or IE builds.
C_DEFINES=$(C_DEFINES)

!IFDEF USE_ICECAP
C_DEFINES=$(C_DEFINES) -DICECAP
!ENDIF

#
# Set debugging level
#

!IF "$(NTDEBUG)" != "" && "$(NTDEBUG)" != "retail" && "$(NTDEBUG)" != "ntsdnodbg"

C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG

#
# remove maximal diagnostics for customer debug version based on environment
# variable
#

!IF "$(FULL_DEBUG)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_DEBUG_MEMORY
!ELSE
C_DEFINES=$(C_DEFINES) -DRETAIL_LOGGING
!IF "$(BUILD_PRODUCT)" != "NT"
C_DEFINES=$(C_DEFINES) -DDISABLE_ASSERTS
!ENDIF
!ENDIF

!ELSE IF "$(ALMOSTRETAIL)" != ""
C_DEFINES=$(C_DEFINES) -DENABLE_DEBUG
!ENDIF

!IF "$(WIN64)" == "0" && "$(FULL_DEBUG)"==""
C_DEFINES=$(C_DEFINES) -DUSE_ROCKALL
!ENDIF

!if "$(WINHTTP_BROWSER_INFO)" == "1"
BROWSER_INFO = 1;
NO_BROWSER_FILE = 1;
USER_ENV_BROWSER_INFO=1
!endif


#
# performance diagnostics
#

!IF "$(PERF_BUILD)" != ""
C_DEFINES=$(C_DEFINES) -DUSE_PERF_DIAG
!ENDIF

!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

#
# Linker flags
#

!if "$(BUILD_PRODUCT)" == "IE"
USE_WIN98OPT=1
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)

#
# Do this to assure that we run on NT 4.0 and Win95, even with
# NT5/Memphis headers.
#

WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400

#
# compiler warning flags
#
!IF "$(W4CHECK)" != ""
MSC_WARNING_LEVEL=/W4 /WX /wd4127 /wd4201
!ELSE
MSC_WARNING_LEVEL=/W3 /WX 
!ENDIF

#
# precompiled header options
#

!IFNDEF WININET_PCH

PRECOMPILED_OPTION=/Fp..\inc\$(_OBJ_DIR)\*\wininetp.pch /Yuwininetp.h
PRECOMPILED_CXX=1

!ENDIF

CONDITIONAL_INCLUDES = \
        winwlm.h \
        macwin32.h \
        ia64inst.h \
        pshpck16.h \
        rpcerr.h \
        rpcmac.h \
        macname1.h \
        macpub.h \
        macapi.h \
        macname2.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\autodial.cxx ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    autodial.cxx

Abstract:

    Contains the implementation of autodial

    Contents:

Author:

    Darren Mitchell (darrenmi) 22-Apr-1997

Environment:

    Win32(s) user-mode DLL

Revision History:

    14-Jan-2002 ssulzer
        Ported small subset to WinHttp

    22-Apr-1997 darrenmi
        Created


--*/

#include "wininetp.h"
#include "autodial.h"
#include "rashelp.h"
#include <winsvc.h>
#include <iphlpapi.h>

// Globals.

DWORD   g_dwLastTickCount = 0;

// serialize access to RAS
HANDLE g_hRasMutex = INVALID_HANDLE_VALUE;

// don't check RNA state more than once every 10 seconds
#define MIN_RNA_BUSY_CHECK_INTERVAL 10000

//
// Current ras connections - used so we don't poll ras every time we're
// interested - only poll every 10 seconds (const. above)
//
RasEnumConnHelp * g_RasCon;

DWORD       g_dwConnections = 0;
BOOL        g_fRasInstalled = FALSE;
DWORD       g_dwLastDialupTicks = 0;

//
// Control of autodial initialization
//
BOOL        g_fAutodialInitialized = FALSE;


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                         RAS dynaload code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

static HINSTANCE g_hRasLib = NULL;

static _RASENUMENTRIESW          pfnRasEnumEntriesW = NULL;
static _RASGETCONNECTSTATUSW     pfnRasGetConnectStatusW = NULL;
static _RASENUMCONNECTIONSW      pfnRasEnumConnectionsW = NULL;
static _RASGETENTRYPROPERTIESW   pfnRasGetEntryPropertiesW = NULL;


typedef struct _tagAPIMAPENTRY {
    FARPROC* pfn;
    LPSTR pszProc;
} APIMAPENTRY;

APIMAPENTRY rgRasApiMapW[] = {
    { (FARPROC*) &pfnRasEnumEntriesW,            "RasEnumEntriesW" },
    { (FARPROC*) &pfnRasGetConnectStatusW,       "RasGetConnectStatusW" },
    { (FARPROC*) &pfnRasEnumConnectionsW,        "RasEnumConnectionsW" },
    { (FARPROC*) &pfnRasGetEntryPropertiesW,     "RasGetEntryPropertiesW"},
    { NULL, NULL },
};

#define RASFCN(_fn, _part, _par, _dbge, _dbgl)     \
DWORD _##_fn _part                          \
{                                           \
    DEBUG_ENTER(_dbge);                     \
                                            \
    DWORD dwRet;                            \
    if(NULL == pfn##_fn)                    \
    {                                       \
        _dbgl(ERROR_INVALID_FUNCTION);      \
        return ERROR_INVALID_FUNCTION;      \
    }                                       \
                                            \
    dwRet = (* pfn##_fn) _par;              \
                                            \
    _dbgl(dwRet);                           \
    return dwRet;                           \
}


RASFCN(RasEnumEntriesW,
    (LPWSTR lpszReserved, LPWSTR lpszPhonebook, LPRASENTRYNAMEW lprasentryname,
    LPDWORD lpcb, LPDWORD lpcEntries),
    (lpszReserved, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    (DBG_DIALUP, Dword, "RasEnumEntriesW", "%#x (%Q), %#x (%Q), %#x, %#x %#x", lpszReserved, lpszReserved, lpszPhonebook, lpszPhonebook, lprasentryname, lpcb, lpcEntries),
    DEBUG_LEAVE
    );

RASFCN(RasGetConnectStatusW,
    (HRASCONN hrasconn, LPRASCONNSTATUSW lprasconnstatus),
    (hrasconn, lprasconnstatus),
    (DBG_DIALUP, Dword, "RasGetConnectStatusW", "%#x, %#x", hrasconn, lprasconnstatus),
    DEBUG_LEAVE
    );

RASFCN(RasGetEntryPropertiesW,
    (LPWSTR lpszPhonebook, LPWSTR lpszEntry, LPRASENTRYW lpRasEntry, LPDWORD lpdwEntryInfoSize, LPBYTE lpbDeviceInfo, LPDWORD lpdwDeviceInfoSize),
    (lpszPhonebook, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    (DBG_DIALUP, Dword, "RasGetEntryPropertiesW", "%#x (%Q), %#x (%Q), %#x, %#x, %#x %#x", lpszPhonebook, lpszPhonebook, lpszEntry, lpszEntry, lpRasEntry, lpdwEntryInfoSize, lpbDeviceInfo, lpdwDeviceInfoSize),
    DEBUG_LEAVE
    );

RASFCN(RasEnumConnectionsW,
    (LPRASCONNW lpRasConn, LPDWORD lpdwSize, LPDWORD lpdwConn),
    (lpRasConn, lpdwSize, lpdwConn),
    (DBG_DIALUP, Dword, "RasEnumConnectionsW", "%#x, %#x, %#x", lpRasConn, lpdwSize, lpdwConn),
    DEBUG_LEAVE
    );

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
EnsureRasLoaded(
    VOID
    )

/*++

Routine Description:

    Dynaload ras apis

Arguments:

    pfInstalled - return installed state of ras

Return Value:

    BOOL
        TRUE    - Ras loaded
        FALSE   - Ras not loaded

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "EnsureRasLoaded",
                 NULL
                 ));

    //
    // Looks like RAS is installed - try and load it up!
    //
    if(NULL == g_hRasLib)
    {
        g_hRasLib = LoadLibrary("RASAPI32.DLL");

        if(NULL == g_hRasLib)
        {
            DEBUG_LEAVE(FALSE);
            return FALSE;
        }

        APIMAPENTRY *prgRasApiMap = rgRasApiMapW;

        int nIndex = 0;
        while ((prgRasApiMap+nIndex)->pszProc != NULL)
        {
            // Some functions are only present on some platforms.  Don't
            // assume this succeeds for all functions.
            *(prgRasApiMap+nIndex)->pfn =
                    GetProcAddress(g_hRasLib, (prgRasApiMap+nIndex)->pszProc);
            nIndex++;
        }
    }

    if(g_hRasLib)
    {
        DEBUG_LEAVE(TRUE);
        return TRUE;
    }

    DEBUG_LEAVE(FALSE);
    return FALSE;
}


BOOL
IsRasInstalled(
    VOID
    )

/*++

Routine Description:

    Determines whether ras is installed on this machine

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Ras is installed

        FALSE   - Ras is not installed

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "IsRasInstalled",
                 NULL
                 ));

    static fChecked = FALSE;

    //
    // If RAS is already loaded, don't bother doing any work.
    //
    if(g_hRasLib)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if we've already done the check, don't do it again
    //
    if(fChecked)
    {
        DEBUG_LEAVE_API(g_fRasInstalled);
        return g_fRasInstalled;
    }

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    if (osvi.dwMajorVersion < 5)
    {
        // WinHttp does not support the use of RAS on NT4
        g_fRasInstalled = FALSE;
    }
    else
    {
        // NT5 and presumably beyond, ras is always installed
        g_fRasInstalled = TRUE;
    }

    fChecked = TRUE;

    DEBUG_LEAVE_API(g_fRasInstalled);
    return g_fRasInstalled;
}


BOOL
DoConnectoidsExist(
    VOID
    )

/*++

Routine Description:

    Determines whether any ras connectoids exist

Arguments:

    none

Return Value:

    BOOL
        TRUE    - Connectoids exist

        FALSE   - No connectoids exist

--*/

{
    DEBUG_ENTER_API((DBG_DIALUP,
                 Bool,
                 "DoConnectoidsExist",
                 NULL
                 ));

    static BOOL fExist = FALSE;

    //
    // If we found connectoids before, don't bother looking again
    //
    if(fExist)
    {
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // If RAS is already loaded, ask it
    //
    if(g_hRasLib)
    {
        DWORD dwRet, dwEntries;

        RasEnumHelp *pRasEnum = new RasEnumHelp;

        if (pRasEnum)
        {
            dwRet = pRasEnum->GetError();
            dwEntries = pRasEnum->GetEntryCount();
            delete pRasEnum;
        }
        else
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
            dwEntries = 0;
        }

        // If ras tells us there are none, return none
        if(ERROR_SUCCESS == dwRet && 0 == dwEntries)
        {
            DEBUG_LEAVE_API(FALSE);
            return FALSE;
        }
        // couldn't determine that there aren't any so assume there are.
        fExist = TRUE;
        DEBUG_LEAVE_API(TRUE);
        return TRUE;
    }

    //
    // if ras isn't installed, say no connectoids
    //
    if(FALSE == IsRasInstalled())
    {
        DEBUG_LEAVE_API(FALSE);
        return FALSE;
    }

    OSVERSIONINFO osvi;

    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osvi);

    // assume connectoids exist
    fExist = TRUE;

    if (osvi.dwMajorVersion < 5)
    {
        fExist = FALSE;
    }

    DEBUG_LEAVE_API(fExist);
    return fExist;
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                           Initialization
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

BOOL
InitAutodialModule()

/*++

Routine Description:

    Initialize autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 Bool,
                 "InitAutodialModule",
                 NULL
                 ));

    // Assert that WinHttp's global data has already been initialized
    INET_ASSERT(GlobalDataInitialized);

    // only do this once...
    if(g_fAutodialInitialized)
    {
        DEBUG_LEAVE(g_fAutodialInitialized);
        return g_fAutodialInitialized;
    }

    if (GlobalDataInitCritSec.Lock())
    {
        if (!g_fAutodialInitialized)
        {
            // create mutex to serialize access to RAS (per process)
            g_hRasMutex = CreateMutex(NULL, FALSE, NULL);

            if (g_hRasMutex != INVALID_HANDLE_VALUE)
            {
                g_RasCon = new RasEnumConnHelp();

                if (g_RasCon != NULL)
                {
                    g_fAutodialInitialized = TRUE;
                }
                else
                {
                    CloseHandle(g_hRasMutex);
                    g_hRasMutex = INVALID_HANDLE_VALUE;
                }
            }
        }

        GlobalDataInitCritSec.Unlock();
    }

    DEBUG_LEAVE(g_fAutodialInitialized);

    return g_fAutodialInitialized;
}


VOID
ExitAutodialModule(
    VOID
    )

/*++

Routine Description:

    Clean up autodial code

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 None,
                 "ExitAutodialModule",
                 NULL
                 ));

    // don't do anything if not initialized
    if(FALSE == g_fAutodialInitialized)
    {
        DEBUG_LEAVE(0);
        return;
    }

    if (g_RasCon)
    {
        delete g_RasCon;
        g_RasCon = NULL;
    }

    if(INVALID_HANDLE_VALUE != g_hRasMutex)
    {
        CloseHandle(g_hRasMutex);
        g_hRasMutex = INVALID_HANDLE_VALUE;
    }

    if (g_hRasLib)
    {
        FreeLibrary(g_hRasLib);
        g_hRasLib = NULL;
    }

    g_fAutodialInitialized = FALSE;

    DEBUG_LEAVE(0);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//
//                     Connection management code
//
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////




LPSTR
GetActiveConnectionName()

/*++

Routine Description:

    Figure out the current connection and fix proxy settings for it.
    Basically a cheap, return-no-info version of GetConnectedStateEx used
    by the winsock callback.

Arguments:

    none

Return Value:

    BOOL
        TRUE        - connected
        FALSE       - not connected

--*/

{
    DEBUG_ENTER((DBG_DIALUP,
                 String,
                 "GetActiveConnectionName",
                 NULL
                 ));

    static BOOL     fRasLoaded = FALSE;
    DWORD           dwNewTickCount, dwElapsed;
    DWORD           dwConnection = 0;
    LPSTR           lpstrConnection = NULL;

    //
    // Make sure everything's initialized
    //
    if (!InitAutodialModule())
        goto quit;

    //
    // serialize
    //
    WaitForSingleObject(g_hRasMutex, INFINITE);

    //
    // Check out how recently we polled ras
    //
    dwNewTickCount = GetTickCountWrap();
    dwElapsed = dwNewTickCount - g_dwLastDialupTicks;

    //
    // Only refresh if more than MIN... ticks has passed
    //
    if(dwElapsed >= MIN_RNA_BUSY_CHECK_INTERVAL)
    {
        g_dwLastDialupTicks = dwNewTickCount;
        if(DoConnectoidsExist())
        {
            if(FALSE == fRasLoaded)
                fRasLoaded = EnsureRasLoaded();

            if(fRasLoaded)
            {
                g_RasCon->Enum();
                if(g_RasCon->GetError() == 0)
                    g_dwConnections = g_RasCon->GetConnectionsCount();
                else
                    g_dwConnections = 0;
            }
        }
        else
        {
            g_dwConnections = 0;
        }
    }

    DEBUG_PRINT(DIALUP, INFO, ("Found %d connections\n", g_dwConnections));

    if(g_dwConnections > 1)
    {
        //
        // We have more than one connection and caller wants to know which one
        // is the interesting one.  Try to find a VPN connectoid.
        //
        RasEntryPropHelp *pRasProp = new RasEntryPropHelp;

        if (pRasProp)
        {
            for(DWORD dwConNum = 0; dwConNum < g_dwConnections; dwConNum++)
            {
                if(0 == pRasProp->GetW(g_RasCon->GetEntryW(dwConNum)))
                {
                    if(0 == lstrcmpiA(pRasProp->GetDeviceTypeA(), RASDT_Vpn))
                    {
                        DEBUG_PRINT(DIALUP, INFO, ("Found VPN entry: %ws\n",
                            g_RasCon->GetEntryW(dwConNum)));
                        dwConnection = dwConNum;
                        break;
                    }
                }
            }
            delete pRasProp;
        }
    }

    //
    // verify status of connection we're interested in is RASCS_Connected.
    //
    if(g_dwConnections != 0)
    {
        RasGetConnectStatusHelp RasGetConnectStatus(g_RasCon->GetHandle(dwConnection));
        DWORD dwRes = RasGetConnectStatus.GetError();
        if (!dwRes && (RasGetConnectStatus.ConnState() == RASCS_Connected))
        {
            WideCharToAscii_UsingGlobalAlloc(g_RasCon->GetEntryW(dwConnection),
                    &lpstrConnection);
        }

        DEBUG_PRINT(DIALUP, INFO, ("Connect Status: dwRet=%x, connstate=%x\n", dwRes, RasGetConnectStatus.ConnState()));
    }

    ReleaseMutex(g_hRasMutex);

quit:
    DEBUG_LEAVE(lpstrConnection);
    return lpstrConnection;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\certcach.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    certcach.cxx

Abstract:

    Contains class implementation for certificate cache object.
    This object will hold various Certificate entries.

    Contents:
        SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY
        SECURITY_CACHE_LIST_ENTRY::AddRef
        SECURITY_CACHE_LIST_ENTRY::Release
        SECURITY_CACHE_LIST_ENTRY::Clear
        SECURITY_CACHE_LIST::Find
        SECURITY_CACHE_LIST::Add
        SECURITY_CACHE_LIST::ClearList
        SECURITY_CACHE_LIST::Initialize
        SECURITY_CACHE_LIST::Terminate

    TODO:  Add Cert validation.  What if Cert is given but different?

Author:

    Arthur L Bierer (arthurbi) 20-Apr-1996

Revision History:

    20-Apr-1996 arthurbi
        Created

--*/
#include <wininetp.h>

//
//
//  List of encryption packages:  PCT, SSL, etc
//

//
// BUGBUG [arthurbi] The SSL and PCT package names
//  are hard coded into the stucture below.  We need
//  to be more flexible in case someone write a FOO security
//  package.
//

// BUGBUG:  Don't change the order of the packages below.  some old SSL2 sites deny the UNISP
// provider, and if we walk down the list to PCT1 or SSL3, things hang.
const SEC_PROVIDER g_cSecProviders[MAX_SEC_PROVIDERS] =
{
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_CLIENTS, NULL,
    UNISP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL | ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL2_CLIENT, NULL,
//    PCT1SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_PCT| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_PCT1_CLIENT, NULL,
//    SSL3SP_NAME, INVALID_CRED_VALUE , ENC_CAPS_SSL| ENC_CAPS_SCHANNEL_CREDS, FALSE, SP_PROT_SSL3_CLIENT, NULL,
    NULL,        INVALID_CRED_VALUE , FALSE,        FALSE, 0
};


//
// private manifests
//

#define MAX_CERT_CACHE_CERTS    16

//
// private types
//

//
// SECURITY_CACHE_LIST_ENTRY member functions
//


SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY(
    IN BOOL fNoRevert,
    IN LPSTR lpszHostName,
    IN INTERNET_PORT ServerPort
    )

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY constructor. Create object; don't add it to list

Arguments:

    fNoRevert       - Revert any impersonation on SSL handling?

    lpszHostName    - name of host for which this cache entry created

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST_ENTRY::SECURITY_CACHE_LIST_ENTRY",
                 "%q",
                 lpszHostName
                 ));

#if INET_DEBUG
    _List.Flink = _List.Blink = NULL;
#endif
    _cRef = 1;
    _fInCache = FALSE;
    _ServerName = lpszHostName;
    _ServerPort = ServerPort;
    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _pCertContextArray = NULL;
    _fNoRevert = fNoRevert;

#if INET_DEBUG
    m_Signature = 0x454c4353;   // 'SCLE'
#endif

    DEBUG_LEAVE(0);
}


SECURITY_CACHE_LIST_ENTRY::~SECURITY_CACHE_LIST_ENTRY()

/*++

Routine Description:

    SECURITY_CACHE_LIST_ENTRY destructor.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "~SECURITY_CACHE_LIST_ENTRY",
                 "{%#x [%q]}",
                 this,
                 _ServerName.StringAddress()
                 ));

    INET_ASSERT((_List.Flink == NULL) && (_List.Blink == NULL));

    Clear();

    DEBUG_LEAVE(0);
}


LONG
SECURITY_CACHE_LIST_ENTRY::AddRef(
    VOID
    )

/*++

Routine Description:

    Increment reference count of SECURITY_CACHE_LIST_ENTRY

Arguments:

    None.

Return Value:

    LONG    - reference count after increment

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::AddRef",
                 "{%#x [%q, %d]}",
                 this,
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    InterlockedIncrement(&_cRef);

    DEBUG_LEAVE(_cRef);

    return _cRef;
}


LONG
SECURITY_CACHE_LIST_ENTRY::Release(
    VOID
    )

/*++

Routine Description:

    Decrement reference count and destroy object if (<=) zero

Arguments:

    None.

Return Value:

    LONG    - reference count after decrement

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 Int,
                 "SECURITY_CACHE_LIST_ENTRY::Release",
                 "{%q [%d]}",
                 _ServerName.StringAddress(),
                 _cRef
                 ));

    LONG cRet;

    if (0 >= (cRet = InterlockedDecrement(&_cRef))) {
        delete this;
    }

    DEBUG_LEAVE(cRet);

    return cRet;
}


VOID
SECURITY_CACHE_LIST_ENTRY::Clear()

/*++

Routine Description:

    Clear out SECURITY_CACHE_LIST_ENTRY

Arguments:

    Clear   -

Return Value:

    None.

--*/

{
    if (_CertInfo.pCertificate != NULL)
    {
        SAFE_WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext), _fNoRevert, (_CertInfo.pCertificate));
        _CertInfo.pCertificate = NULL;
    }

    ZeroMemory(&_CertInfo, sizeof(_CertInfo));
    _CertInfo.dwSize = sizeof(_CertInfo);

    _dwSecurityFlags = 0;
    _dwStatusFlags = 0;
    _ServerName = NULL;
    if( _pCertContextArray )
    {
        delete _pCertContextArray;
        _pCertContextArray = NULL;
    }
}

//
// SECURITY_CACHE_LIST member functions
//


VOID
SECURITY_CACHE_LIST::ClearList(
    VOID
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::ClearList",
                 NULL
                 ));

    if (!LockSerializedList(&_List))
    {
        DEBUG_PRINT(OBJECTS,
                    ERROR,
                    ("Failed to obtain lock -- SECURITY_CACHE_LIST potentially leaked\n"
                    ));
        goto quit;
    }

    while (!IsSerializedListEmpty(&_List)) {

        SECURITY_CACHE_LIST_ENTRY * CacheEntry;

        //
        // remove the PROXY_SERVER_LIST_ENTRY at the head of the serialized
        // list
        //

        LPVOID entry = SlDequeueHead(&_List);

        //
        // entry should not be NULL - IsSerializedListEmpty() told us we
        // could expect something
        //

        INET_ASSERT(entry != NULL);

        //
        // get the address of the object (should be the same as entry) and
        // delete it
        //

        CacheEntry = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("releasing %q (%d)\n",
                    CacheEntry->_ServerName.StringAddress(),
                    CacheEntry->_cRef
                    ));

        CacheEntry->Release();
    }

    UnlockSerializedList(&_List);

quit:
    DEBUG_LEAVE(0);
}


DWORD
SECURITY_CACHE_LIST::Add(
    IN SECURITY_CACHE_LIST_ENTRY * entry
    )

/*++

Routine Description:

    Adds a CertInfo Structure to the list front of the list.

Arguments:

    lpszHost    - Hostname to add.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "SECURITY_CACHE_LIST::Add",
                 "%#x [%q, %d]",
                 entry,
                 entry ? entry->_ServerName.StringAddress() : "",
                 entry ? entry->_cRef : 0
                 ));

    DWORD error = ERROR_SUCCESS;

    INET_ASSERT(entry != NULL);

    if (entry != NULL) {
        if (LockSerializedList(&_List))
        {

            //
            // If we've grown too much, nuke the oldest one.
            //

            if (ElementsOnSerializedList(&_List) >= MAX_CERT_CACHE_CERTS) {

                SECURITY_CACHE_LIST_ENTRY *pOld;
                LPVOID old_entry = SlDequeueTail(&_List);

                INET_ASSERT(old_entry != NULL);

                pOld = CONTAINING_RECORD(old_entry, SECURITY_CACHE_LIST_ENTRY, _List);

                //
                // entry should not be NULL - IsSerializedListEmpty() told us we
                // could expect something
                //

                pOld->_fInCache = FALSE;

                //
                // Clean Our old object, and reinstatiate with a new name.
                //

                pOld->Release();
            }
            if (InsertAtHeadOfSerializedList(&_List, &entry->_List)) {
                entry->AddRef();
                entry->_fInCache = TRUE;
            }
            UnlockSerializedList(&_List);
        }
        else
            error = ERROR_NOT_ENOUGH_MEMORY;
    }

    DEBUG_LEAVE(error);

    return error;
}


SECURITY_CACHE_LIST_ENTRY *
SECURITY_CACHE_LIST::Find(
    IN LPSTR lpszHost,
    IN INTERNET_PORT HostPort 
    )

/*++

Routine Description:

    Searches the linked list for the Cert, and returns
    the found entry, or NULL if not found.

Arguments:

    lpszHost    - Hostname to search on.

Return Value:

    CERT_CACHE_LIST_ENTRY *
        Success - Pointer to found entry.

        Failure - NULL, not found.

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Pointer,
                 "SECURITY_CACHE_LIST::Find",
                 "%q",
                 lpszHost
                 ));

    SECURITY_CACHE_LIST_ENTRY * info = NULL;

    //
    // BUGBUG need to validate against Server Certifcate on every
    //  connection, this Find only validates by Hostname.
    //  What about DNS spoofing?  Won't we be hosed?
    //

    //
    // TODO if found, need to push to front of list.
    //

    if (LockSerializedList(&_List))
    {
        for (PLIST_ENTRY entry = HeadOfSerializedList(&_List);
            entry != (PLIST_ENTRY)SlSelf(&_List);
            entry = entry->Flink)
        {
            info = CONTAINING_RECORD(entry, SECURITY_CACHE_LIST_ENTRY, _List);

            //
            // check to see if they match.
            //

            if ((info->_ServerName.Stricmp(lpszHost) == 0) && info->_ServerPort == HostPort) {
                info->AddRef();
                break; // match.
            }
            info = NULL;
        }
        UnlockSerializedList(&_List);
    }

    DEBUG_LEAVE(info);

    return info;
}


BOOL SECURITY_CACHE_LIST::Initialize(
    VOID
    )
{
    if (!InitializeSerializedList(&_List))
        return FALSE;

#if INET_DEBUG
    m_Signature = 0x4c436553;   // "SeCL"
#endif

    // Fill in default starting values, will enumerate and acquire handles
    // during the first SSL handshake for the session.
    CopyMemory((LPVOID)_SecProviders,
           (CONST VOID *)g_cSecProviders,
           sizeof(SEC_PROVIDER) * MAX_SEC_PROVIDERS);

    _dwEncFlags = 0;
    _dwSecureProtocols = DEFAULT_SECURE_PROTOCOLS;

    return TRUE;
}


VOID SECURITY_CACHE_LIST::Terminate(
    VOID
    )
{

    DEBUG_ENTER((DBG_OBJECTS,
                 None,
                 "SECURITY_CACHE_LIST::Terminate",
                 "{%#x}",
                 this
                 ));

    ClearList();

    //
    //  free all security pkg credential handles
    //
    for (DWORD i = 0; _SecProviders[i].pszName != NULL ; i++)
    {
        if (_SecProviders[i].fEnabled)
        {
            if (_SecProviders[i].pCertCtxt == NULL && !IsCredClear(_SecProviders[i].hCreds))
            {
                // Beta1 Hack. Because of some circular dependency between dlls
                // both crypt32 and schannel's PROCESS_DETACH gets called before wininet.
                // This is catastrophic if we have a cert context attached to the credentials
                // handle. In this case we will just leak the handle since the process is dying
                // anyway. We really need to fix this.
                WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle,
                                      IsImpersonationEnabled(),
                                      (&_SecProviders[i].hCreds));
            }
        }
#if 0 // See comments above.
        if (_SecProviders[i].pCertCtxt != NULL)
        {
            (*g_pfnCertFreeCertificateContext)(_SecProviders[i].pCertCtxt);
            _SecProviders[i].pCertCtxt = NULL;
        }
#endif
    }

    TerminateSerializedList(&_List);

    DEBUG_LEAVE(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)    24-Nov-1997

--*/

#include <wininetp.h>
#include <cache.hxx>

typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

static char vszDot[] = ".";
static char vszDotDot[] = "..";
#ifdef UNIX
static char vszIndexFile[] = "index.dat";
#endif /* UNIX */

static char vszSHClassInfo[]=".ShellClassInfo";

static char vszCLSIDKey[]="CLSID";
static char vszCLSID[]="{FF393560-C2A7-11CF-BFF4-444553540000}";

static char vszUICLSIDKey[]="UICLSID";
static char vszUICLSID[]="{7BD29E00-76C1-11CF-9DD0-00A0C9034933}";

typedef HRESULT (*PFNSHFLUSHCACHE)(VOID);

#ifdef UNIX
extern void UnixGetValidParentPath(LPTSTR szDevice);
#endif /* UNIX */

/*-----------------------------------------------------------------------------
DeleteOneCachedFile

    Deletes a file belonging to the cache.

Arguments:

    lpszFileName: Fully qualified filename

Return Value:

    TRUE if successful. If FALSE, GetLastError() returns the error code.

Comments:

  ---------------------------------------------------------------------------*/
BOOL
DeleteOneCachedFile(
    LPSTR   lpszFileName,
    DWORD   dostEntry)
{

    if (dostEntry)
    {
        DWORD dostCreate = 0;
        LPWORD pwCreate = (LPWORD) &dostCreate;
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        switch (GetFileSizeAndTimeByName(lpszFileName, &FileAttrData))
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }                    
    
        FileTimeToDosDateTime(&FileAttrData.ftCreationTime, pwCreate, pwCreate+1);

        if (dostCreate != dostEntry)
           return TRUE; // not our file, so consider it done!
    }


    if(!DeleteFile(lpszFileName))
    {
        TcpsvcsDbgPrint (( DEBUG_ERRORS, "DeleteFile failed on %s, Error=%ld\n",
            lpszFileName, GetLastError()));

        switch (GetLastError())
        {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }
    }
    else
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Deleted %s\n", lpszFileName ));
        return TRUE;
    }
}


/*-----------------------------------------------------------------------------
DeleteCachedFilesInDir
  ---------------------------------------------------------------------------*/
DWORD DeleteCachedFilesInDir(
    LPSTR   lpszPath,
    DWORD   dwLevel
    )
{
    TCHAR PathFiles[MAX_PATH+1];
    TCHAR FullFileName[MAX_PATH+1];
    LPTSTR FullFileNamePtr;
    WIN32_FIND_DATA FindData;

    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    // Since this has become a recursive call, we don't want to go more than 6 levels.
    if (dwLevel>5)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    DWORD Error, len, cbUsed;
    BOOL fFindSuccess;

    DWORD cb = strlen(lpszPath);
    memcpy(PathFiles, lpszPath, cb + 1);

    if(!AppendSlashIfNecessary(PathFiles, &cb)) 
    {
        Error = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    memcpy(FullFileName, PathFiles, cb + 1);
    memcpy(PathFiles + cb, ALLFILES_WILDCARD_STRING, sizeof(ALLFILES_WILDCARD_STRING));

    FullFileNamePtr = FullFileName + lstrlen( (LPTSTR)FullFileName );

    if ( IsValidCacheSubDir( lpszPath))
        DisableCacheVu( lpszPath);

    FindHandle = FindFirstFile( (LPTSTR)PathFiles, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE ) 
    {
        Error = GetLastError();
        goto Cleanup;
    }

    cbUsed = (unsigned int)(FullFileNamePtr-FullFileName);
    FullFileName[MAX_PATH] = '\0';
    do
    {
        cb = strlen(FindData.cFileName);
        if (cb+cbUsed+1 > MAX_PATH)
        {
            // Subtracting 1 extra so that the null terminator doesn't get overwritten
            cb = MAX_PATH - cbUsed - 2;
        }
        memcpy(FullFileNamePtr, FindData.cFileName, cb+1);

#ifndef UNIX
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#else
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszIndexFile, sizeof(vszIndexFile)-1) || 
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#endif /* UNIX */
        {
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                Error = DeleteCachedFilesInDir(FullFileName, dwLevel + 1);
                if (Error!=ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
                SetFileAttributes(FullFileName, FILE_ATTRIBUTE_DIRECTORY);
                RemoveDirectory(FullFileName);
            }
            else
            {
                DeleteOneCachedFile( (LPTSTR)FullFileName, 0);
            }
        }

        //
        // find next file.
        //

    } while (FindNextFile( FindHandle, &FindData ));

    Error = GetLastError();
    if( Error == ERROR_NO_MORE_FILES) 
    {
        Error = ERROR_SUCCESS;
    }

Cleanup:

    if( FindHandle != INVALID_HANDLE_VALUE ) 
    {
        FindClose( FindHandle );
    }

    if( Error != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "DeleteCachedFilesInDir failed, %ld.\n",
                Error ));
    }

    return( Error );
}


/*-----------------------------------------------------------------------------
AppendSlashIfNecessary
  ---------------------------------------------------------------------------*/
BOOL AppendSlashIfNecessary(LPSTR szPath, DWORD* pcbPath)
{
    if (*pcbPath > (MAX_PATH-2)) 
        return FALSE;
    if (szPath[*pcbPath-1] != DIR_SEPARATOR_CHAR)
    {
        szPath[*pcbPath] = DIR_SEPARATOR_CHAR;
        (*pcbPath)++;
        szPath[*pcbPath] = '\0';
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
EnableCachevu
  ---------------------------------------------------------------------------*/
BOOL EnableCacheVu(LPSTR szPath, DWORD dwContainer)
{       
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];
    DWORD dwFileAttributes;

    HMODULE hInstShell32 = 0;
    PFNSHFLUSHCACHE pfnShFlushCache = NULL;

#define DESIRED_ATTR (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

    // Calls with non-existant directory allowed and return false.
    dwFileAttributes = GetFileAttributes(szPath);
    if (dwFileAttributes == 0xFFFFFFFF)
        return FALSE;
    
    // Always be set to enable cachevu.
    SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM);
    
    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    if (dwFileAttributes == 0xFFFFFFFF)
    {
        dwFileAttributes = 0;

        // Always write out the UICLSID
        WritePrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  vszUICLSID,  szDesktopIni);    

        // HISTORY requires an additional CLSID.
        if (dwContainer == HISTORY)
            WritePrivateProfileString(vszSHClassInfo,  vszCLSIDKey,  vszCLSID,  szDesktopIni);    

        // Flush buffer - problems on Win95 if you don't.
        WritePrivateProfileString(NULL, NULL, NULL,  szDesktopIni);
    }

    if ((dwFileAttributes & DESIRED_ATTR) != DESIRED_ATTR)
    {
        // Should be hidden, read-only and system for cachevu to work correctly.
        SetFileAttributes(szDesktopIni, DESIRED_ATTR);
    }
/*
    BUGBUG - taking this code out for raid # 45710.
    // We now need to notify the shell that a new desktop.ini has been created.
    hInstShell32 = GetModuleHandle("shell32.dll");
    if (hInstShell32)
    {    
        pfnShFlushCache = (PFNSHFLUSHCACHE) GetProcAddress(hInstShell32, (LPSTR) 526);
        if (pfnShFlushCache)
        {
            __try
            {
                (*pfnShFlushCache)();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            ENDEXCEPT
        }
    }
*/
    return TRUE;

}

/*-----------------------------------------------------------------------------
IsValidCacheSubDir
  ---------------------------------------------------------------------------*/
BOOL IsValidCacheSubDir(LPSTR szPath)
{
    DWORD dwFileAttributes, cb, cbPath;
    CHAR szDesktopIni[MAX_PATH];
    CHAR szCLSID     [MAX_PATH];
    CHAR szWindowsDir[MAX_PATH];
    CHAR szSystemDir [MAX_PATH];

    cbPath = strlen(szPath);
            
    // Root, Windows or System directories
    // are decidedly not cache subdirectories.
    cb = GetWindowsDirectory(szWindowsDir, MAX_PATH);
    if (!cb || cb>MAX_PATH)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    AppendSlashIfNecessary(szWindowsDir, &cb);

    cb = GetSystemDirectory(szSystemDir, MAX_PATH);
    AppendSlashIfNecessary(szSystemDir, &cb);

    if (cbPath < 4 
        || !strnicmp(szPath, szWindowsDir, cbPath)
        || !strnicmp(szPath, szSystemDir, cbPath))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
    
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    // No desktop.ini found or system attribute not set.
    if (dwFileAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // Found UICLSID (CONTENT cachevu) ?
    if (GetPrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  
                                "", szCLSID, MAX_PATH, szDesktopIni)
        && !strcmp(szCLSID, vszUICLSID)) 
    {
        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
DisableCachevu
  ---------------------------------------------------------------------------*/
BOOL DisableCacheVu(LPSTR szPath)
{
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szDesktopIni);
    return TRUE;
}

/*-----------------------------------------------------------------------------
StripTrailingWhiteSpace
  ---------------------------------------------------------------------------*/
VOID StripTrailingWhiteSpace(LPSTR szString, LPDWORD pcb)
{
    INET_ASSERT(szString);

    if (*pcb == 0)
        return;

    CHAR* ptr = szString + *pcb - 1;

    while (*ptr == ' ')
    {
        ptr--;
        if (--(*pcb) == 0)
            break;
    }
    *(ptr+1) = '\0';
}


/* PerformOperationOverUrlCache-----------------------

The purpose of this function is to iterate through the content cache and perform the same action (here, called
an operation) on each entry in the cache.

This function takes all the parameters that FindFirstUrlCacheEntryEx accepts, 
plus two more:

op              -- This is of type CACHE_OPERATOR, discussed below
pOperatorData   -- a pointer to an array of data that the calling process and op use to collect/maintain info
 */

/* CACHE_OPERATOR
    is a pointer to function, that takes three arguments(pointer to a cache entry, cache entry size, and a pointer to 
    state data.

    The operator can perform whatever operation (move/copy/data collection) it wishes on the supplied cache entry.
    It must return TRUE if the operation has succeeded and PerformOperationOverUrlCache can continue to iterate through
    the cache, FALSE otherwise.

    pOpData can be null, or a cast pointer to whatever structure the operator will use to maintain state information.
        
    PerformOperationOverUrlCache guarantees that each cache entry will have sufficient space for its information.
*/ 

typedef BOOL (*CACHE_OPERATOR)(INTERNET_CACHE_ENTRY_INFO* pcei, PDWORD pcbcei, PVOID pOpData);


// hAdjustMemory is a helper function
// that ensures that the buffer used by PerformOperationOverUrlCache
// is large enough to hold all of a cache entry's info

BOOL hAdjustMemory(PBYTE pbSrc, PDWORD pcbAvail, LPINTERNET_CACHE_ENTRY_INFO* pbNew, PDWORD pcbNeeded)
{
    if ((PBYTE)*pbNew!=pbSrc)
    {
        FREE_MEMORY(*pbNew);
    }
    do
    {
        *pcbAvail += 1024;
    } 
    while (*pcbAvail < *pcbNeeded);
    *pcbNeeded = *pcbAvail;
    *pbNew = (LPINTERNET_CACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbAvail);
    return (*pbNew!=NULL);
}


// PerformOperationOverUrlCache
// described above
// uses FindFirstUrlCacheEntryEx and FindNext as any other wininet client would.
// and passes a complete cache entry to the operator for processing

BOOL PerformOperationOverUrlCacheA(
    IN     PCSTR     pszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    PVOID     pReserved1,
    IN OUT PDWORD    pdwReserved2,
    IN     PVOID     pReserved3,
    IN       CACHE_OPERATOR op, 
    IN OUT PVOID     pOperatorData
    )
{
    BOOL fResult = FALSE;

    BYTE buffer[sizeof(INTERNET_CACHE_ENTRY_INFO) + 1024];
    DWORD cbAvail = sizeof(buffer);
    DWORD cbCEI = cbAvail;
    LPINTERNET_CACHE_ENTRY_INFO pCEI = (LPINTERNET_CACHE_ENTRY_INFO)buffer;
    HANDLE hFind = NULL;
    
    hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    if (!hFind && (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(buffer, &cbAvail, &pCEI, &cbCEI))
    {
        hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    }

    if (hFind!=NULL)
    {
        do
        {
            fResult = op(pCEI, &cbCEI, pOperatorData);
            if (fResult)
            {
                cbCEI = cbAvail;
                fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                if (!fResult && (GetLastError()==ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(buffer, &cbAvail, &pCEI, &cbCEI))
                {
                    fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                }
            } 
        }
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = TRUE;
        } 
    }

    if (pCEI!=(LPINTERNET_CACHE_ENTRY_INFO)buffer)
    {
        FREE_MEMORY(pCEI);
    }
    return fResult;
}

// ------ MoveCachedFiles ---------------------------------------------------------------------------------------
// Purpose: Moves as many files as possible from the current Temporary Internet Files to the new location


// State information required for the move operation
struct MOVE_OP_STATE
{
    TCHAR szNewPath[MAX_PATH];
    TCHAR szOldPath[MAX_PATH];
    DWORD ccNewPath;
    DWORD ccOldPath;
    DWORDLONG dlCacheSize;
    DWORD dwClusterSizeMinusOne;
    DWORD dwClusterSizeMask;
};

// Helper function that, 
// given a string pointer, 
// returns the next occurrence of DIR_SEPARATOR_CHAR ('/' || '\\')
PTSTR hScanPastSeparator(PTSTR pszPath)
{
    while (*pszPath && *pszPath!=DIR_SEPARATOR_CHAR)
    {
        pszPath++;
    }
    if (*pszPath)
    {
        return pszPath+1;
    }
    return NULL;
}

// Helper function that,
// given a path,
// ensures that all the directories in the path exist
BOOL hConstructSubDirs(PTSTR pszBase)
{
    PTSTR pszLast = hScanPastSeparator(pszBase);

    if (NULL == pszLast)
        return TRUE;    // returning TRUE on purpose

    PTSTR pszNext = pszLast;
    while ((pszNext=hScanPastSeparator(pszNext))!=NULL)
    {
        *(pszNext-1) = '\0';
        CreateDirectory(pszBase, NULL);
        *(pszNext-1) = DIR_SEPARATOR_CHAR;
        pszLast = pszNext;
    }
    return TRUE;
}

// MoveOperation
// actually moves a cached file to the new location

BOOL MoveOperation(LPINTERNET_CACHE_ENTRY_INFO pCEI, PDWORD pcbCEI, PVOID pOpData)
{
    MOVE_OP_STATE* pmos = (MOVE_OP_STATE*)pOpData;
    BOOL fResult = TRUE;

    if (pCEI->lpszLocalFileName)
    {
        if (!strnicmp(pCEI->lpszLocalFileName, pmos->szOldPath, pmos->ccOldPath))
        {
            // Copy the file
            lstrcpy(pmos->szNewPath + pmos->ccNewPath, pCEI->lpszLocalFileName + pmos->ccOldPath);        
            fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
            if (!fResult && GetLastError()==ERROR_PATH_NOT_FOUND)
            {
                if (hConstructSubDirs(pmos->szNewPath))
                {
                    fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
                }
            }
            // If the move was successful, we need to adjust the size of the new cache
            if (fResult)
            {
                fResult = FALSE;
                
                HANDLE h1 = CreateFile(pCEI->lpszLocalFileName, 
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

                // If we can't open the original file, then the new file will never
                // get scavenged because we'll never be able to match creation times
                if (h1!=INVALID_HANDLE_VALUE)
                {
                    HANDLE h2 = CreateFile(pmos->szNewPath, 
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
                    if (h2!=INVALID_HANDLE_VALUE)
                    {
                        FILETIME ft;
                        if (GetFileTime(h1, &ft, NULL, NULL))
                        {
                            fResult = SetFileTime(h2, &ft, NULL, NULL);
                        }
                        CloseHandle(h2);
                    }
                    CloseHandle(h1);
                }
            }

            // If we haven't been able to set the create time, then we've got a problem
            // we'd sooner not deal with.
            if (!fResult)
            {
                DeleteUrlCacheEntry(pCEI->lpszSourceUrlName);
                DeleteFile(pmos->szNewPath);
            }
            else
            {
                pmos->dlCacheSize += ((LONGLONG) (pCEI->dwSizeLow + pmos->dwClusterSizeMinusOne) 
                                        & pmos->dwClusterSizeMask);
            }

            // Delete the old one
            DeleteFile(pCEI->lpszLocalFileName);
        }
    }
    return TRUE;
}


DWORD
MoveCachedFiles(
    LPSTR     pszOldPath,
    LPSTR     pszNewPath
)
{
    MOVE_OP_STATE mos;
    INET_ASSERT(pszOldPath && pszNewPath);

    mos.ccNewPath = lstrlen(pszNewPath);
    memcpy(mos.szNewPath, pszNewPath, mos.ccNewPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);
    memcpy(mos.szNewPath + mos.ccNewPath, CONTENT_VERSION_SUBDIR, sizeof(CONTENT_VERSION_SUBDIR)*sizeof(TCHAR));
    mos.ccNewPath += sizeof(CONTENT_VERSION_SUBDIR)-1;
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);

    mos.ccOldPath = lstrlen(pszOldPath);
    memcpy(mos.szOldPath, pszOldPath, mos.ccOldPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szOldPath, &mos.ccOldPath);

    mos.dlCacheSize = 0;
    GetDiskInfo(mos.szNewPath, &mos.dwClusterSizeMinusOne, NULL, NULL);
    mos.dwClusterSizeMinusOne--;
    mos.dwClusterSizeMask = ~mos.dwClusterSizeMinusOne;
    
    GlobalUrlContainers->WalkLeakList(CONTENT);

    // We don't need to get all the information about each and every entry.
    PerformOperationOverUrlCacheA(
        NULL, 
        FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME,
        NORMAL_CACHE_ENTRY | STICKY_CACHE_ENTRY | SPARSE_CACHE_ENTRY,
        NULL,
        NULL,
        NULL,
        NULL,
        MoveOperation, 
        (PVOID)&mos);

    GlobalUrlContainers->SetCacheSize(CONTENT, mos.dlCacheSize);
    
    // Copy desktop.ini and index.dat, since these aren't cached
    TCHAR szFile[MAX_PATH];
    DWORD ccOldPath = lstrlen(pszOldPath);
    memcpy(szFile, pszOldPath, ccOldPath);
    AppendSlashIfNecessary(szFile, &ccOldPath);
    memcpy(szFile + ccOldPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    memcpy(szFile + ccOldPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
IsCorrectUser

Routine Description:

    checks to see from the headers whether there is any username in there and
    whether it matches the currently logged on user. If no one is logged on a
    default username string is used

Arguments:

    lpszHeaderInfo: headers to check

    dwheaderSize:   size of the headers buffer

Return Value:

    BOOL


---------------------------------------------------------------------------*/
BOOL
IsCorrectUserPrivate(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    LPSTR lpTemp, lpTemp2;

    INET_ASSERT (lpszHeaderInfo);

    lpTemp = lpszHeaderInfo+dwHeaderSize-1;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) {

        if (*lpTemp ==':') {
            // If this is less than the expected header:
            // then we know that there is no such usernameheader 
            // <MH> i.e. it's not a peruseritem so allow access</MH>

            if ((DWORD)PtrDifference((lpTemp+1), lpszHeaderInfo) < (sizeof(vszUserNameHeader)-1)) {
                TcpsvcsDbgPrint((DEBUG_CONTAINER,
                    "IsCorrectUser (Util.cxx): Didn't find header <lpTemp = 0x%x %s> <lpszHeaderInfo = 0x%x %s> <vszCurrentUser = %s> <PtrDifference = %d> <sizeof(vszUserNameHeader)-1) = %d>\r\n",
                    lpTemp,
                    lpTemp,
                    lpszHeaderInfo,
                    lpszHeaderInfo,
                    vszCurrentUser,
                    PtrDifference(lpTemp, lpszHeaderInfo),
                    (sizeof(vszUserNameHeader)-1)
                    ));
                return (TRUE); // No such header. just ay it is OK
            }

            // point this puppy to the expected header start
            lpTemp2 = lpTemp - (sizeof(vszUserNameHeader)-2);

            // if the earlier char is not a white space [0x9-0xd or 0x20]
            // then this is not the beginning of the header
            // <MH> Also need to check for the first header which would not 
            // have whitespace preceding it. Want to first check lpTemp2 ==
            // lpszheaderInfo to prevent underflowing when dereferencing.</MH>

            if (((lpTemp2) == lpszHeaderInfo) || isspace(*(lpTemp2-1))) {

                // we have the beginning of a header
                if (!strnicmp(lpTemp2
                                , vszUserNameHeader
                                , sizeof(vszUserNameHeader)-1)) {

                    // right header, let us see whether this is the right person
                    if(!strnicmp(lpTemp+1, vszCurrentUser, vdwCurrentUserLen)) {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): Match!! %s header == %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));
                    
                        return (TRUE); // right guy
                    }
                    else {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): No match!! %s header != %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));

                    }

                    return(FALSE); // wrong guy
                }
            }
        }
        --lpTemp;
    }

    return (TRUE); // there was no UserName header, just say it is OK
}


BOOL
IsCorrectUser(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    BOOL fRet = FALSE;
    
    __try
    {
        fRet = IsCorrectUserPrivate(lpszHeaderInfo, dwHeaderSize);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        fRet = FALSE;
    }
    ENDEXCEPT
    return fRet;
}



#ifndef UNICODE
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExA"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionA"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionA"
#else
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExW"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionW"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionW"
#endif

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef BOOL (WINAPI *PFNWNETUSECONNECTION)(HWND, LPNETRESOURCE, PSTR, PSTR, DWORD, PSTR, PDWORD, PDWORD);
typedef BOOL (WINAPI *PFNWNETCANCELCONNECTION)(LPCTSTR, BOOL);

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn)
{
    if (*pfn==(PFN)-1)
    {
        *pfn = NULL;
        HMODULE ModuleHandle = GetModuleHandle(pszModule);
        if (ModuleHandle)
        {
            *pfn = (PFN)GetProcAddress(ModuleHandle, pszFunction);
        }
    }        

    return (*pfn!=NULL);
}


// GetPartitionClusterSize

// GetDiskFreeSpace has the annoying habit of lying about the layout
// of the drive; thus we've been ending up with bogus sizes for the cluster size.
// You can't imagine how annoying it is to think you've a 200 MB cache, but it
// starts scavenging at 20MB.

// This function will, if given reason to doubt the veracity of GDFS, go straight 
// to the hardware and get the information for itself, otherwise return the passed-in
// value.

// The code that follows is heavily doctored from msdn sample code. Copyright violation? I think not.

static PFNGETDISKFREESPACEEX pfnGetDiskFreeSpaceEx = (PFNGETDISKFREESPACEEX)-1;
#define VWIN32_DIOC_DOS_DRIVEINFO   6

typedef struct _DIOC_REGISTERS 
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} 
DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 

typedef struct 
_DPB {
    BYTE    dpb_drive;          // Drive number (1-indexed)
    BYTE    dpb_unit;           // Unit number
    WORD    dpb_sector_size;    // Size of sector in bytes
    BYTE    dpb_cluster_mask;   // Number of sectors per cluster, minus 1
    BYTE    dpb_cluster_shift;  // The stuff after this, we don't really care about. 
    WORD    dpb_first_fat;
    BYTE    dpb_fat_count;
    WORD    dpb_root_entries;
    WORD    dpb_first_sector;
    WORD    dpb_max_cluster;
    WORD    dpb_fat_size;
    WORD    dpb_dir_sector;
    DWORD   dpb_reserved2;
    BYTE    dpb_media;
    BYTE    dpb_first_access;
    DWORD   dpb_reserved3;
    WORD    dpb_next_free;
    WORD    dpb_free_cnt;
    WORD    extdpb_free_cnt_hi;
    WORD    extdpb_flags;
    WORD    extdpb_FSInfoSec;
    WORD    extdpb_BkUpBootSec;
    DWORD   extdpb_first_sector;
    DWORD   extdpb_max_cluster;
    DWORD   extdpb_fat_size;
    DWORD   extdpb_root_clus;
    DWORD   extdpb_next_free;
} 
DPB, *PDPB;

#pragma pack()

DWORD GetPartitionClusterSize(PTSTR szDevice, DWORD dwClusterSize)
{
    switch (GlobalPlatformType)
    {
    case PLATFORM_TYPE_WIN95:
        // If GetDiskFreeSpaceEx is present _and_ we're running Win9x, this implies
        // that we must be doing OSR2 or later. We can trust earlier versions 
        // of the GDFS (we think; this assumption may be invalid.)

        // Since Win95 can't read NTFS drives, we'll freely assume we're reading a FAT drive.
        // Basically, we're performing an MSDOS INT21 call to get the drive partition record. Joy.
        
        if (pfnGetDiskFreeSpaceEx)
        {
            HANDLE hDevice;
            DIOC_REGISTERS reg;
            BYTE buffer[sizeof(WORD)+sizeof(DPB)];
            PDPB pdpb = (PDPB)(buffer + sizeof(WORD));
    
            BOOL fResult;
            DWORD cb;

            // We must always have a drive letter in this case
            int nDrive = *szDevice - TEXT('A') + 1;  // Drive number, 1-indexed

            hDevice = CreateFile("\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if (hDevice!=INVALID_HANDLE_VALUE)
            {
                reg.reg_EDI = PtrToUlong(buffer);
                reg.reg_EAX = 0x7302;        
                reg.reg_ECX = sizeof(buffer);
                reg.reg_EDX = (DWORD) nDrive; // drive number (1-based) 
                reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

                fResult = DeviceIoControl(hDevice, 
                                          VWIN32_DIOC_DOS_DRIVEINFO,
                                          &reg, sizeof(reg), 
                                          &reg, sizeof(reg), 
                                          &cb, 0);

                if (fResult && !(reg.reg_Flags & 0x0001))
                {
                    // no error if carry flag is clear
                    dwClusterSize = DWORD((pdpb->dpb_cluster_mask+1)*pdpb->dpb_sector_size);
                }
                CloseHandle(hDevice);
            }
        }
        break;

    default:
        // Do nothing. Trust the value we've been passed.
        // UNIX guys will have to treat this separately.

        // For NT, however, this might be another issue. We can't use the DOS INT21.
        // Questions:
        // NT5 (but not NT4) supports FAT32; will we get honest answers? Apparently, yes.
        // NT4/5: NTFS drives and other FAT drives -- do we still get honest answers? Investigation
        // so far says, Yes. 
        break;
    }
    
    return dwClusterSize;
}


/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfoA(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal)
{
    static PFNWNETUSECONNECTION pfnWNetUseConnection = (PFNWNETUSECONNECTION)-1;
    static PFNWNETCANCELCONNECTION pfnWNetCancelConnection = (PFNWNETCANCELCONNECTION)-1;

    if (!pszPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    INET_ASSERT(pdwClusterSize || pdlAvail || pdlTotal);
    // If GetDiskFreeSpaceExA is available, we can be confident we're running W95OSR2+ || NT4
    EstablishFunction(TEXT("KERNEL32"), SZ_GETDISKFREESPACEEX, (PFN*)&pfnGetDiskFreeSpaceEx);
  
    BOOL fRet = FALSE;
    TCHAR szDevice[MAX_PATH];
    PTSTR pszGDFSEX = NULL;
   
    if (*pszPath==DIR_SEPARATOR_CHAR)
    {
        // If we're dealing with a cache that's actually located on a network share, 
        // that's fine so long as we have GetDiskFreeSpaceEx at our disposal.
        // _However_, if we need the cluster size on Win9x, we'll need to use
        // INT21 stuff (see above), even if we have GDFSEX available, so we need to map
        // the share to a local drive.
        
        if (pfnGetDiskFreeSpaceEx 
            && !((GlobalPlatformType==PLATFORM_TYPE_WIN95) && pdwClusterSize))
        {
            DWORD cbPath = lstrlen(pszPath);
            cbPath -= ((pszPath[cbPath-1]==DIR_SEPARATOR_CHAR) ? 1 : 0);
            if (cbPath>MAX_PATH-2)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            memcpy(szDevice, pszPath, cbPath);
            szDevice[cbPath] = DIR_SEPARATOR_CHAR;
            cbPath++;
            szDevice[cbPath] = '\0';
            pszGDFSEX = szDevice;
        }
        else
        {
            if (!(EstablishFunction(TEXT("MPR"), SZ_WNETUSECONNECTION, (PFN*)&pfnWNetUseConnection)
                &&
               EstablishFunction(TEXT("MPR"), SZ_WNETCANCELCONNECTION, (PFN*)&pfnWNetCancelConnection)))
            {
                return FALSE;
            }

           // If it's a UNC, map it to a local drive for backwards compatibility
            NETRESOURCE nr = { 0, RESOURCETYPE_DISK, 0, 0, szDevice, pszPath, NULL, NULL };
            DWORD cbLD = sizeof(szDevice);
            DWORD dwNull;
            if (pfnWNetUseConnection(NULL, 
                          &nr, 
                          NULL, 
                          NULL, 
                          CONNECT_INTERACTIVE | CONNECT_REDIRECT, 
                          szDevice,
                          &cbLD,
                          &dwNull)!=ERROR_SUCCESS)
            {
                SetLastError(ERROR_NO_MORE_DEVICES);        
                return FALSE;
            }
        }
    }
    else
    {
        memcpy(szDevice, pszPath, sizeof(TEXT("?:\\")));
        szDevice[3] = '\0';
        pszGDFSEX = pszPath;
    }
    if (*szDevice!=DIR_SEPARATOR_CHAR)
    {
        *szDevice = (TCHAR)CharUpper((LPTSTR)*szDevice);
    }

#ifdef UNIX
    /* On Unix, GetDiskFreeSpace and GetDiskFreeSpaceEx will work successfully
     * only if the path exists. So, let us pass a path that exists
     */
    UnixGetValidParentPath(szDevice);
#endif /* UNIX */

    // I hate goto's, and this is a way to avoid them...
    for (;;)
    {
        DWORDLONG cbFree = 0, cbTotal = 0;
    
        if (pfnGetDiskFreeSpaceEx && (pdlTotal || pdlAvail))
        {
            ULARGE_INTEGER ulFree, ulTotal;

            // BUG BUG BUG Is the following problematic? Also, we'll need to add checks to make sure that 
            // the  cKBlimit fits a DWORD (in the obscene if unlikely case drive spaces grow that large)
            // For instance, if this is a per user system with a non-shared cache, we might want to change
            // the ratios.
            INET_ASSERT(pszGDFSEX);
            fRet = pfnGetDiskFreeSpaceEx(pszGDFSEX, &ulFree, &ulTotal, NULL);

            // HACK Some versions of GetDiskFreeSpaceEx don't accept the whole directory; they
            // take only the drive letter. Pfft.
            if (!fRet)
            {
                fRet = pfnGetDiskFreeSpaceEx(szDevice, &ulFree, &ulTotal, NULL);
            }

            if (fRet)
            {
                cbFree = ulFree.QuadPart;
                cbTotal = ulTotal.QuadPart;
            }
        }

        if ((!fRet) || pdwClusterSize)
        {
            DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwClusters, dwClusterSize;
            if (!GetDiskFreeSpace(szDevice, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
            {
                fRet = FALSE;
                break;
            }
            
            dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;

            if (!fRet)
            {
                cbFree = (DWORDLONG)dwClusterSize * (DWORDLONG)dwFreeClusters;
                cbTotal = (DWORDLONG)dwClusterSize * (DWORDLONG)dwClusters;
            }
            
            if (pdwClusterSize)
            {
                *pdwClusterSize = GetPartitionClusterSize(szDevice, dwClusterSize);
            }
        }

        if (pdlTotal)
        {
             *pdlTotal = cbTotal;
        }
        if (pdlAvail)
        {
             *pdlAvail = cbFree;
        }
        fRet = TRUE;
        break;
    };
    
    // We've got the characteristics. Now delete local device connection, if any.
    if (*pszPath==DIR_SEPARATOR_CHAR && !pfnGetDiskFreeSpaceEx)
    {
        pfnWNetCancelConnection(szDevice, FALSE);
    }

    return fRet;
}


// -- ScanToLastSeparator
// Given a path, and a pointer within the path, discover where the path separator prior to the path
// is located and return the pointer to it. If there is none, return NULL.

BOOL ScanToLastSeparator(PTSTR pszPath, PTSTR* ppszCurrent)
{
    PTSTR pszActual = *ppszCurrent;
    pszActual--;
    while ((pszActual>(pszPath+1)) && (*pszActual!=DIR_SEPARATOR_CHAR))
    {
        pszActual--;
    }
    if ((*pszActual==DIR_SEPARATOR_CHAR) && (pszActual!=*ppszCurrent))
    {
        *ppszCurrent = pszActual;
        return TRUE;
    }

    return FALSE;
}

// -- Centralised method of tracking mutexes
// class MUTEX_HOLDER

MUTEX_HOLDER::MUTEX_HOLDER()
{
    _hHandle = NULL;
    _dwState = WAIT_FAILED;
}

MUTEX_HOLDER::~MUTEX_HOLDER()
{
    if (_hHandle)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "ERROR: Releasing ownership of mutex %d\r\n",
            _hHandle));
        ReleaseMutex(_hHandle);
    }
}

VOID MUTEX_HOLDER::Grab(HANDLE hHandle, DWORD dwTime)
{
    INET_ASSERT(hHandle);
    _hHandle = hHandle;
    _dwState = WaitForSingleObject(_hHandle, dwTime);
    if (_dwState==WAIT_ABANDONED)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of abandoned mutex %d\r\n",
            hHandle));
    }
    else if (_dwState==WAIT_OBJECT_0)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of mutex %d\r\n",
            hHandle));
    }
    else
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Unable to gain ownership of mutex %d\r\n",
            hHandle));
    }
}

VOID MUTEX_HOLDER::Release()
{
    if (_hHandle)
    {
        if (_dwState==WAIT_ABANDONED || _dwState==WAIT_OBJECT_0)
        {
            ReleaseMutex(_hHandle);
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Released ownership of mutex %d\r\n",
                _hHandle));
        }
        else
        {
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Would release ownership of mutex %d, except we don't own it\r\n",
                _hHandle));
        }
    }
    _hHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\autoprox.cxx ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    autoprox.cxx


Author:

    Stephen A Sulzer (ssulzer) 26-August-2001

--*/

#include <wininetp.h>
#include "apdetect.h"
#include <cscpsite.h>
#include "..\http\httpp.h"

//
// definitions
//

#define DEFAULT_SCRIPT_BUFFER_SIZE 4000 // bytes.
#define ONE_HOUR_DELTA  (60 * 60 * (LONGLONG)10000000)

GLOBAL LONGLONG dwdwHttpDefaultExpiryDelta = 12 * 60 * 60 * (LONGLONG)10000000;  // 12 hours in 100ns units

DWORD InProcGetProxyForUrl(
    INTERNET_HANDLE_OBJECT *    hSessionMapped,
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo  
);

DWORD OutProcGetProxyForUrl(
    INTERNET_HANDLE_OBJECT*     hSessionMapped,
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo
    );

//
// private vars
//

BOOL IsAutoProxyServiceAvailable();

//
// functions
//
INTERNETAPI
BOOL
WinHttpDetectAutoProxyConfigUrl(DWORD dwAutoDetectFlags, LPWSTR * ppwstrAutoConfigUrl)
{
    DWORD   error = ERROR_SUCCESS;
    char *  pszUrl;

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpDetectAutoProxyConfigUrl",
                     "%#x, %#x",
                     dwAutoDetectFlags,
                     ppwstrAutoConfigUrl
                     ));

    if (((dwAutoDetectFlags &
            ~(WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)) != 0)
        || (ppwstrAutoConfigUrl == NULL)
        || IsBadWritePtr(ppwstrAutoConfigUrl, sizeof(char *)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!(dwAutoDetectFlags & 
            (WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!GlobalDataInitialized) 
    {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) 
        {
            goto quit;
        }
    }

    error = ::DetectAutoProxyUrl(dwAutoDetectFlags, &pszUrl);

    if (error == ERROR_SUCCESS)
    {
        error = AsciiToWideChar_UsingGlobalAlloc(pszUrl, ppwstrAutoConfigUrl);
        FREE_MEMORY(pszUrl);
    }

quit:
    if (error != ERROR_SUCCESS)
    {
        SetLastError(error);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);
    return (error == ERROR_SUCCESS);    
}


INTERNETAPI
BOOL
WinHttpGetProxyForUrl(
    IN  HINTERNET                   hSession,
    IN  LPCWSTR                     lpcwszUrl,
    IN  WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    OUT WINHTTP_PROXY_INFO *        pProxyInfo  
    )
{
    DWORD   error;

    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpGetProxyForUrl",
                     "%#x, %wq, %#x, %#x",
                     hSession,
                     lpcwszUrl,
                     pAutoProxyOptions,
                     pProxyInfo
                     ));

    //
    // Validate the WinHttp session handle
    //
    if ((hSession == NULL) || IsBadReadPtr((void *)hSession, sizeof(void *)))
    {
        error = ERROR_INVALID_HANDLE;
        goto quit;
    }

    //
    // Validate the target URL, and AUTOPROXY_OPTIONS and PROXY_INFO structs.
    //
    if ((lpcwszUrl == NULL)  || IsBadStringPtrW(lpcwszUrl, (UINT_PTR)-1)
        || (pAutoProxyOptions == NULL)
        || IsBadReadPtr(pAutoProxyOptions, sizeof(WINHTTP_AUTOPROXY_OPTIONS))
    || (pProxyInfo == NULL)
        || IsBadWritePtr(pProxyInfo, sizeof(WINHTTP_PROXY_INFO)))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate that the caller specified at least one of the
    // AUTO_DETECT and CONFIG_URL flags.
    //
    if (!(pAutoProxyOptions->dwFlags &
             (WINHTTP_AUTOPROXY_AUTO_DETECT |
              WINHTTP_AUTOPROXY_CONFIG_URL)))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate that the caller did not set any flags other than
    // AUTO_DETECT, CONFIG_URL, RUN_INPROCESS or RUN_OUTPROCESS_ONLY.
    //
    if (pAutoProxyOptions->dwFlags &
             ~(WINHTTP_AUTOPROXY_AUTO_DETECT |
               WINHTTP_AUTOPROXY_CONFIG_URL  |
               WINHTTP_AUTOPROXY_RUN_INPROCESS |
               WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY))
    {
        goto ErrorInvalidParameter;
    }

    // make sure RUN_INPROC & RUN_OUTPROC_ONLY is mutually exclusive
    if ((pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_INPROCESS) && 
        (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY))
    {
        goto ErrorInvalidParameter;
    }

    //
    // Validate the detection flags if the application
    // requests autodetection.
    //
    if (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT)
    {
        if ((pAutoProxyOptions->dwAutoDetectFlags &
                    ~(WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)) != 0)
        {
            goto ErrorInvalidParameter;
        }
        if (!(pAutoProxyOptions->dwAutoDetectFlags & 
                (WINHTTP_AUTO_DETECT_TYPE_DHCP | WINHTTP_AUTO_DETECT_TYPE_DNS_A)))
        {
            goto ErrorInvalidParameter;
        }
    }

    //
    // Validate if lpszAutoConfigUrl string if the application 
    // specifies the CONFIG_URL option.
    //
    if ((pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_CONFIG_URL) &&
            (!pAutoProxyOptions->lpszAutoConfigUrl  ||
            IsBadStringPtrW(pAutoProxyOptions->lpszAutoConfigUrl, (UINT_PTR)-1L) ||
            (*(pAutoProxyOptions->lpszAutoConfigUrl) == '\0')))
    {
        goto ErrorInvalidParameter;
    }

    if (!GlobalDataInitialized) 
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto quit;
    }

    error = ERROR_SUCCESS;

    INTERNET_HANDLE_OBJECT *    hSessionMapped = NULL;
    HINTERNET_HANDLE_TYPE       handleType = (HINTERNET_HANDLE_TYPE)0;

    error = MapHandleToAddress(hSession, (LPVOID *)&hSessionMapped, FALSE);

    if ((error != ERROR_SUCCESS) && (hSessionMapped == NULL))
    {
        goto quit;
    }

    error = RGetHandleType(hSessionMapped, &handleType);

    if (error == ERROR_SUCCESS && handleType == TypeInternetHandle)
    {
        if ((pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_INPROCESS))
        {
            error = InProcGetProxyForUrl(hSessionMapped, 
                                         lpcwszUrl, 
                                         pAutoProxyOptions, 
                                         pProxyInfo);
        }
        else 
        {
            BOOL fOutProcSucceed = FALSE;

            if (IsAutoProxyServiceAvailable())
            {
                error = OutProcGetProxyForUrl(hSessionMapped,
                                              lpcwszUrl, 
                                              pAutoProxyOptions, 
                                              pProxyInfo);
            }
            else
            {
                error = ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR;
            }

            if ((error != ERROR_WINHTTP_AUTO_PROXY_SERVICE_ERROR) && 
                (error != ERROR_WINHTTP_LOGIN_FAILURE)  // APSvc doesn't support auth fully.
                )
            {
                fOutProcSucceed = TRUE;
            }

            // when failed to detect a proxy thru the NT service, we fall back to try again in-proc if
            // app allows

            if (!fOutProcSucceed && !(pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY))
            {
                error = InProcGetProxyForUrl(hSessionMapped, 
                                             lpcwszUrl, 
                                             pAutoProxyOptions, 
                                             pProxyInfo);
            }
        }
    }
    else
    {
        error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
    }

    DereferenceObject(hSessionMapped);

    if (error != ERROR_SUCCESS)
        goto quit;

quit:

    if (error != ERROR_SUCCESS)
    {
        SetLastError(error);
    }

    DEBUG_LEAVE_API(error == ERROR_SUCCESS);

    return (error == ERROR_SUCCESS);

ErrorInvalidParameter:
    error = ERROR_INVALID_PARAMETER;
    goto quit;
}

DWORD InProcGetProxyForUrl(
    INTERNET_HANDLE_OBJECT *    hSessionMapped,
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo  
)
{
    DWORD error;
    CAutoProxy * pAutoProxy;

    pAutoProxy = hSessionMapped->GetAutoProxy();

    if (pAutoProxy)
    {
        error = pAutoProxy->GetProxyForURL(lpcwszUrl, pAutoProxyOptions, pProxyInfo);
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    return error;
}

BOOL
CAutoProxy::Initialize()
{
    _pszAutoConfigUrl          = NULL;
    _pdwDetectedInterfaceIp    = NULL;
    _cDetectedInterfaceIpCount = 0;
    memset(&_ftLastDetectionTime, 0, sizeof(_ftLastDetectionTime));

    _pszConfigScript = NULL;

    memset(&_ftExpiryTime, 0, sizeof(_ftExpiryTime));
    memset(&_ftLastModifiedTime, 0, sizeof(_ftLastModifiedTime));
    memset(&_ftLastSyncTime, 0, sizeof(_ftLastSyncTime));

    _fHasExpiry      = FALSE;
    _fHasLastModifiedTime = FALSE;
    _fMustRevalidate = FALSE;

    _ScriptResLock.Initialize();

    return (_ScriptResLock.IsInitialized() && _CritSec.Init());
}


CAutoProxy::~CAutoProxy()
{
    if (_pszAutoConfigUrl)
        FREE_MEMORY(_pszAutoConfigUrl);

    if (_pdwDetectedInterfaceIp)
        FREE_MEMORY(_pdwDetectedInterfaceIp);

    if (_pszConfigScript)
        FREE_MEMORY(_pszConfigScript);
}

BOOL
CAutoProxy::IsSessionAborted() const
{
    INET_ASSERT(_hSession != NULL);
    return _hSession->IsInvalidated();
}

DWORD
CAutoProxy::GetProxyForURL(
    LPCWSTR                     lpcwszUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    WINHTTP_PROXY_INFO *        pProxyInfo  
)
{
    DWORD       error = ERROR_SUCCESS;
    char *      pszAutoConfigUrl = NULL;
    char *      pszConfigScript = NULL;
    char *      pszUrl = NULL;
    char *      pszQueryResults = NULL;
    bool        bReleaseScriptLock = false;

    //
    // If the application requests auto-detect, then attempt to detect
    // the autonconfig URL and download the autoproxy script.
    //
    if (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_AUTO_DETECT)
    {
        error = DetectAutoProxyUrl(pAutoProxyOptions->dwAutoDetectFlags,
                        &pszAutoConfigUrl);

        if (error == ERROR_SUCCESS)
        {
            INET_ASSERT(pszAutoConfigUrl);

            error = DownloadAutoConfigUrl(pszAutoConfigUrl, pAutoProxyOptions, &pszConfigScript);

            if (error != ERROR_SUCCESS)
            {
                FREE_MEMORY(pszAutoConfigUrl);
                pszAutoConfigUrl = NULL;
            }
            else
            {
                bReleaseScriptLock = true;
                INET_ASSERT(pszConfigScript != NULL);
            }
        }
        else
        {
            INET_ASSERT(pszAutoConfigUrl == NULL);
        }
    }

    //
    // If autodetection or downloading the autoproxy script fails,
    // or if autodetection is not requested, then fall back to an
    // (optional) autoconfig URL supplied by the application.
    //
    if ((error != ERROR_SUCCESS || pszAutoConfigUrl == NULL)
        && (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_CONFIG_URL))
    {
        INET_ASSERT(pAutoProxyOptions->lpszAutoConfigUrl);

        error = WideCharToAscii(pAutoProxyOptions->lpszAutoConfigUrl,
                        &pszAutoConfigUrl);
       
        if (error != ERROR_SUCCESS)
            goto quit;

        error = DownloadAutoConfigUrl(pszAutoConfigUrl, pAutoProxyOptions, &pszConfigScript);

        if (error == ERROR_SUCCESS)
        {
            bReleaseScriptLock = true;
        }
    }


    //
    // Could not obtain the autoproxy script, bail out.
    //
    if (error != ERROR_SUCCESS)
        goto quit;

    // Need the app's target URL in ANSI
    error = WideCharToAscii(lpcwszUrl, &pszUrl);

    if (error != ERROR_SUCCESS)
        goto quit;

    // This is an internal callback indicating we are about to execute the download proxy
    // script. Only the auto-proxy service subscribe this callback.
    
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    _InternetSetObjectHandle(lpThreadInfo, _hSession, _hSession);

    InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_BEGIN_PROXY_SCRIPT_RUN, NULL, 0);

    if (IsSessionAborted())
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Execute the proxy script.
    //
    error = RunProxyScript(pszUrl, pszConfigScript, &pszQueryResults);

    if (error != ERROR_SUCCESS)
        goto quit;

    //
    // Parse the output from the autoproxy script and
    // convert it into a WINHTTP_PROXY_INFO struct for
    // the application.
    //
    error = ParseProxyQueryResults(pszQueryResults, pProxyInfo);

quit:
    if (bReleaseScriptLock)
    {
        _ScriptResLock.Release();
    }

    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }

    if (pszAutoConfigUrl)
    {
        FREE_MEMORY(pszAutoConfigUrl);
    }

    if (pszQueryResults)
    {
        GlobalFree(pszQueryResults);
    }

    return error;
}


DWORD
CAutoProxy::DetectAutoProxyUrl(DWORD dwAutoDetectFlags, LPSTR * ppszAutoConfigUrl)
{
    char *  pszAutoConfigUrl = NULL;
    BOOL    fDetectionNeeded;
    DWORD   error            = ERROR_SUCCESS;

    fDetectionNeeded = IsDetectionNeeded();  // avoid holding a critsec across this

    if (_CritSec.Lock())
    {
        if (_pszAutoConfigUrl == NULL)
        {
            fDetectionNeeded = TRUE;
        }
        else if (!fDetectionNeeded)
        {
            pszAutoConfigUrl = NewString(_pszAutoConfigUrl);
        }

        _CritSec.Unlock();
    }

    // We should have either the AutoConfigUrl string or
    // fDetectionNeeded should be TRUE; otherwise raise
    // an out-of-memory error.
    if (!(pszAutoConfigUrl || fDetectionNeeded))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    // check detection cache; also check for network changes or if
    // this machine's IP address have changed

    if (fDetectionNeeded)
    {
        int      cInterfaces      = 0;
        DWORD *  pdwInterfaceIp   = NULL;
        FILETIME ftDetectionTime;

        //
        // Save out the Host IP addresses, before we start the detection,
        //  after the detection is complete, we confirm that we're still
        //  on the same set of Host IPs, in case the user switched connections.
        //

        error = GetHostAddresses(&cInterfaces, &pdwInterfaceIp);

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // Important: cannot hold the _CritSec lock across the autodetection
        // call, as it can take several seconds, which could cause
        // waiting EnterCriticalSection() calls to raise POSSIBLE_DEADLOCK
        // exceptions.
        error = ::DetectAutoProxyUrl(dwAutoDetectFlags, &pszAutoConfigUrl);

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        if (IsSessionAborted())
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
            goto quit;
        }

        GetCurrentGmtTime(&ftDetectionTime); // mark when detection was run.

        if (_CritSec.Lock())
        {
            // 
            // Clear out any cached autoconfig script
            //
            if (_pszConfigScript)
            {
                FREE_MEMORY(_pszConfigScript);
                _pszConfigScript = NULL;
            }

            //
            // Cache new AutoConfigUrl string and detection time
            //
            if (_pszAutoConfigUrl)
            {
                FREE_MEMORY(_pszAutoConfigUrl);
            }

            _pszAutoConfigUrl = pszAutoConfigUrl;

            _ftLastDetectionTime = ftDetectionTime;

            //
            // Cache IP address of host machine at time of detection
            //
            if (_pdwDetectedInterfaceIp)
            {
                FREE_MEMORY(_pdwDetectedInterfaceIp);
            }

            _pdwDetectedInterfaceIp = pdwInterfaceIp;
            _cDetectedInterfaceIpCount = cInterfaces;

            //
            // Prepare return string for caller
            //
            *ppszAutoConfigUrl = NewString(pszAutoConfigUrl);

            if (*ppszAutoConfigUrl == NULL)
            {
                error = ERROR_NOT_ENOUGH_MEMORY;
            }

            // Exit lock
            _CritSec.Unlock();
        }
        else
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    else
    {
        INET_ASSERT(pszAutoConfigUrl);
        *ppszAutoConfigUrl = pszAutoConfigUrl;
    }

quit:
    return error;
}


DWORD
CAutoProxy::DownloadAutoConfigUrl(
    LPSTR                       lpszAutoConfigUrl,
    WINHTTP_AUTOPROXY_OPTIONS * pAutoProxyOptions,
    LPSTR *                     ppszConfigScript
)
{
    HINTERNET   hInternet = NULL;
    HINTERNET   hConnect  = NULL;
    HINTERNET   hRequest  = NULL;
    
    LPSTR   pszHostName = NULL;
    
    BOOL    fSuccess;
    DWORD   error = ERROR_SUCCESS;

    CHAR    szContentType[MAX_PATH+1];

    LPSTR   lpszScriptBuffer = NULL;
    DWORD   dwScriptBufferSize;

    DWORD   dwStatusCode = ERROR_SUCCESS;
    DWORD   cbSize = sizeof(DWORD);

    bool    bCloseInternetHandle  = false;
    bool    bValidateCachedScript = false;
    bool    bAcquiredScriptLock    = false;

    static const char * AcceptTypes[] = { "*/*", NULL };
    URL_COMPONENTSA     Url;


    INET_ASSERT(lpszAutoConfigUrl);

    if (!_CritSec.Lock())
        return ERROR_NOT_ENOUGH_MEMORY;

    //
    // Does the given AutoConfig URL match the last one that
    // was downloaded? If so, the autoconfig script may
    // already be cached.
    //
    if (_pszAutoConfigUrl &&
            StrCmpIA(_pszAutoConfigUrl, lpszAutoConfigUrl) == 0)
    {
        //
        // If we have a cached script and it has not expired,
        // then we're done.
        //
        if (_pszConfigScript)
        {
            if (!IsCachedProxyScriptExpired())
            {
                lpszScriptBuffer = _pszConfigScript;
                
                // Acquire non-exclusive read lock
                if (_ScriptResLock.Acquire())
                {
                    error = ERROR_SUCCESS;
                    bAcquiredScriptLock = true;
                }
                else
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                }
                goto quit;
            }
            else
            {
                bValidateCachedScript = true;
            }
        }
    }
    else if (_pszAutoConfigUrl)
    {
        FREE_MEMORY(_pszAutoConfigUrl);
        _pszAutoConfigUrl = NULL;
    }


    //
    // Acquire exclusive write lock - this will wait for all the 
    // outstanding reader locks to release.
    //
    if (!_ScriptResLock.AcquireExclusive())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    bAcquiredScriptLock = true;


    //
    // Prepare to GET the auto proxy script.
    //

    ZeroMemory(&Url, sizeof(Url));
    Url.dwStructSize = sizeof(URL_COMPONENTSA);
    Url.dwHostNameLength  = 1L;
    Url.dwUrlPathLength   = 1L;
    Url.dwExtraInfoLength = 1L;

    if (!WinHttpCrackUrlA(lpszAutoConfigUrl, 0, 0, &Url))
    {
        goto quitWithLastError;
    }

    // Check for non-http schemes
    if (Url.nScheme != INTERNET_SCHEME_HTTP && Url.nScheme != INTERNET_SCHEME_HTTPS)
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    if (Url.dwHostNameLength == 0)
    {
        error = ERROR_WINHTTP_INVALID_URL;
        goto quit;
    }

    // If the client does not specify a resource path,
    // then add the "/".
    if (Url.dwUrlPathLength == 0)
    {
        INET_ASSERT(Url.dwExtraInfoLength == 1);

        Url.lpszUrlPath = "/";
        Url.dwUrlPathLength = 1;
    }

    pszHostName = NewString(Url.lpszHostName, Url.dwHostNameLength);

    if (!pszHostName)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (IsSessionAborted())
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Fire up a mini WinHttp Session to download a
    //  config file found on some internal server.
    //

    if (_hSession->IsAsyncHandle())
    {
        hInternet = InternetOpenA(
                        NULL,
                        WINHTTP_ACCESS_TYPE_NO_PROXY,
                        NULL,
                        NULL,
                        0);
        if (!hInternet)
        {
            goto quitWithLastError;
        }
        bCloseInternetHandle = true;
    }
    else
    {
        hInternet = _hSession;
    }


    hConnect = InternetConnectA(hInternet, pszHostName, Url.nPort, WINHTTP_CONNECT_FLAG_NO_INDICATION, NULL);

    if (!hConnect)
    {
        goto quitWithLastError;
    }

    // disinherit user's session callback if set.
    WinHttpSetStatusCallback(hConnect, NULL, NULL, NULL);

    hRequest = HttpOpenRequestA(hConnect, NULL, // "GET"
                        Url.lpszUrlPath ? Url.lpszUrlPath : "/",
                        NULL,   // Version
                        NULL,   // Referrer:
                        AcceptTypes,
                        (Url.nScheme == INTERNET_SCHEME_HTTPS) ?
                            WINHTTP_FLAG_SECURE
                          : 0,  // Flags
                        NULL);  // Context

    if (!hRequest)
    {
        goto quitWithLastError;
    }

    //
    // Initialize the Request object
    //

    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType    = WINHTTP_ACCESS_TYPE_NO_PROXY;
    ProxyInfo.lpszProxy       = NULL;
    ProxyInfo.lpszProxyBypass = NULL;

    fSuccess = WinHttpSetOption(hRequest, WINHTTP_OPTION_PROXY,
                        (void *) &ProxyInfo,
                        sizeof(ProxyInfo));
    if (!fSuccess)
    {
        goto quitWithLastError;
    }

    if (pAutoProxyOptions->fAutoLogonIfChallenged)
    {
        DWORD   dwAutoLogonPolicy = WINHTTP_AUTOLOGON_SECURITY_LEVEL_LOW;

        fSuccess = WinHttpSetOption(hRequest, WINHTTP_OPTION_AUTOLOGON_POLICY,
                            (void *) &dwAutoLogonPolicy,
                            sizeof(dwAutoLogonPolicy));
        if (!fSuccess)
        {
            goto quitWithLastError;
        }
    }

   
    //
    // We have an expired cached script; add If-Modified-Since request
    // header if possible to check if the cached script is still valid.
    //
    if (bValidateCachedScript)
    {
        AddIfModifiedSinceHeaders(hRequest);
    }


    if (IsSessionAborted())
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Send the request synchronously
    //

    if (!WinHttpSendRequest(hRequest, NULL, 0, NULL, 0, 0, NULL))
    {
        error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }

    if (!WinHttpReceiveResponse(hRequest, NULL))
    {
        error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
        goto quit;
    }

    if (IsSessionAborted())
    {
        error = ERROR_WINHTTP_OPERATION_CANCELLED;
        goto quit;
    }

    //
    // Update LastSyncTime
    //
    GetCurrentGmtTime(&_ftLastSyncTime);


    //
    // Check status code
    //
    cbSize = sizeof(dwStatusCode);

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_STATUS_CODE | HTTP_QUERY_FLAG_NUMBER,
            NULL,
            (LPVOID) &dwStatusCode,
            &cbSize,
            NULL))
    {
        if (dwStatusCode == HTTP_STATUS_DENIED)
        {
            error = ERROR_WINHTTP_LOGIN_FAILURE;
            goto quit;
        }
        else if (dwStatusCode >= HTTP_STATUS_NOT_FOUND)
        {
            error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
            goto quit;
        }
        else if (dwStatusCode == HTTP_STATUS_NOT_MODIFIED)
        {
            INET_ASSERT(bValidateCachedScript);
            INET_ASSERT(_pszConfigScript);

            error = ERROR_SUCCESS;

            lpszScriptBuffer = _pszConfigScript;

            //
            // Release exclusive write lock and take read lock.
            // This is atomic because we also have the general
            // autoproxy critical section.
            //
            _ScriptResLock.Release(); // Release exclusive write lock.
            _ScriptResLock.Acquire(); // Acquire non-exclusive read lock.
            
            goto quit;
        }
    }


    //
    // Clear existing cache config script if any before
    // downloading the new script code.
    //
    if (_pszConfigScript)
    {
        FREE_MEMORY(_pszConfigScript);
        _pszConfigScript = NULL;
    }

    DWORD dwIndex;
    DWORD dwTempSize;

    dwIndex = 0;
    dwTempSize = sizeof(dwScriptBufferSize);

    dwScriptBufferSize = 0;
    
    if (HttpQueryInfoA(hRequest, (HTTP_QUERY_CONTENT_LENGTH | HTTP_QUERY_FLAG_NUMBER),
           NULL,
           (LPVOID) &dwScriptBufferSize,
           &dwTempSize,
           &dwIndex))
    {
        // Reject script files that exceed our limit.
        if (dwScriptBufferSize > MAX_PAC_SCRIPT_SIZE)
        {
            error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
            goto quit;
        }
    }
    else
    {
        // failure, just defaults 
        dwScriptBufferSize = DEFAULT_SCRIPT_BUFFER_SIZE;
    }
   
    lpszScriptBuffer = (LPSTR)
                        ALLOCATE_MEMORY(((dwScriptBufferSize + 2) * sizeof(CHAR)));
    if (lpszScriptBuffer == NULL) 
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }


    //
    // read script data
    //

    DWORD   dwBytes     = 0;
    DWORD   dwBytesRead = 0;
    DWORD   dwBytesLeft = dwScriptBufferSize;
    LPSTR   lpszDest    = lpszScriptBuffer;

    do
    {
        fSuccess = WinHttpReadData(hRequest, lpszDest, dwBytesLeft, &dwBytes);

        if (!fSuccess)
        {
            error = GetLastError();
            goto quit;
        }

        if (dwBytes > 0)
        {
            dwBytesRead += dwBytes;
            dwBytesLeft -= dwBytes;

            if (dwBytesLeft == 0)
            {
                dwScriptBufferSize += DEFAULT_SCRIPT_BUFFER_SIZE;
                lpszScriptBuffer = (LPSTR)
                                    REALLOCATE_MEMORY(lpszScriptBuffer,
                                            (dwScriptBufferSize + 2) * sizeof(CHAR));
                if (lpszScriptBuffer == NULL)
                {
                    error = ERROR_NOT_ENOUGH_MEMORY;
                    goto quit;
                }
                dwBytesLeft = DEFAULT_SCRIPT_BUFFER_SIZE;
            }

            // Reject script files that exceed our limit.
            if (dwBytesRead > MAX_PAC_SCRIPT_SIZE)
            {
                error = ERROR_WINHTTP_UNABLE_TO_DOWNLOAD_SCRIPT;
                goto quit;
            }

            lpszDest = lpszScriptBuffer + dwBytesRead;
        }

        if (IsSessionAborted())
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
            goto quit;
        }
    } while (dwBytes != 0);

    lpszScriptBuffer[dwBytesRead] = '\0';


    //
    // Figure out what kind of file we're dealing with.
    //  ONLY allow files with the correct extension or the correct MIME type.
    //

    szContentType[0] = '\0';
    dwBytes = ARRAY_ELEMENTS(szContentType)-1;

    fSuccess = HttpQueryInfoA(hRequest, HTTP_QUERY_CONTENT_TYPE, NULL,
                     szContentType,
                     &dwBytes,
                     NULL);

    if (fSuccess && !IsSupportedMimeType(szContentType))
    {
        if (!IsSupportedFileExtension(lpszAutoConfigUrl))
        {
            error = ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT;
            goto quit;
        }
    }

    //
    // The script has been downloaded successfully, so now process
    // any Cache-Control and/or Expires headers.
    //
    CalculateTimeStampsForCache(hRequest);

    if (!_pszAutoConfigUrl)
    {
        _pszAutoConfigUrl = NewString(lpszAutoConfigUrl);
        // ok to ignore OOM
    }

    //
    // Cache script
    //
    _pszConfigScript = lpszScriptBuffer;

    //
    // Release exclusive write lock and take read lock.
    // This is atomic because we also have the general
    // autoproxy critical section.
    //
    _ScriptResLock.Release(); // Release exclusive write lock.
    _ScriptResLock.Acquire(); // Acquire non-exclusive read lock.

quit:
    _CritSec.Unlock();

    if (error == ERROR_SUCCESS)
    {
        *ppszConfigScript = lpszScriptBuffer;

        INET_ASSERT(bAcquiredScriptLock);
    }
    else
    {
        if (bAcquiredScriptLock)
        {
            _ScriptResLock.Release();
        }

        if (lpszScriptBuffer)
        {
            FREE_MEMORY(lpszScriptBuffer);
        }
    }

    if (hRequest)
    {
        WinHttpCloseHandle(hRequest);
    }

    if (hConnect)
    {
        WinHttpCloseHandle(hConnect);
    }

    if (bCloseInternetHandle)
    {
        WinHttpCloseHandle(hInternet);
    }

    if (pszHostName)
    {
        FREE_MEMORY(pszHostName);
    }

    return error;


quitWithLastError:
    error = GetLastError();
    INET_ASSERT(error != ERROR_SUCCESS);
    goto quit;
}


BOOL
CAutoProxy::IsSupportedMimeType(char * szType)
{
    return StrCmpIA(szType, "application/x-ns-proxy-autoconfig") == 0;
}

BOOL
CAutoProxy::IsSupportedFileExtension(LPCSTR lpszUrl)
{
    LPCSTR lpszExtension;
    LPCSTR lpszQuestion;

    static const char * rgszExtensionList[] = { ".dat", ".js", ".pac", ".jvs", NULL };

    BOOL    fMatch = FALSE;

    //
    // We need to be careful about checking for a period on the end of an URL
    //   Example: if we have: "http://auto-proxy-srv/fooboo.exe?autogenator.com.ex" ?
    //

    lpszQuestion = strchr(lpszUrl, '?');

    lpszUrl = (lpszQuestion) ? lpszQuestion : lpszUrl;

    lpszExtension = strrchr(lpszUrl, '.');


    if (lpszExtension)
    {
        for (int i = 0; rgszExtensionList[i] != NULL; i++)
        {
            if (StrCmpIA(lpszExtension, rgszExtensionList[i]) == 0)
            {
                fMatch = TRUE;
                break;
            }
        }
    }

    return fMatch;
}


BOOL
CAutoProxy::IsCachedProxyScriptExpired()
/*++

Routine Description:

    Determines whether the cached proxy config script is expired.  If it's 
    expired then we need to synchronize (i.e. do a i-m-s request)

Parameters:

    NONE

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "CAutoProxy::IsCachedProxyScriptExpired",
                 NULL
                 ));

    BOOL        fExpired = FALSE;
    FILETIME    ftCurrentTime;
    
    GetCurrentGmtTime(&ftCurrentTime);

    // Always strictly honor expire time from the server.
    if (_fHasExpiry)
    {
        fExpired = FT2LL(_ftExpiryTime) <= FT2LL(ftCurrentTime);
    }
    else
    {
        // We'll assume the data could change within 12 hours of the last time
        // we sync'ed.
        fExpired = (FT2LL(ftCurrentTime) >= (FT2LL(_ftLastSyncTime) + dwdwHttpDefaultExpiryDelta));
    }
    

    DEBUG_LEAVE(fExpired);
    return fExpired;
}


VOID
CAutoProxy::CalculateTimeStampsForCache(HINTERNET hRequest)
/*++

Routine Description:

    extracts timestamps from the http response. If the timestamps don't exist,
    does the default thing. has additional goodies like checking for expiry etc.

Side Effects:  

    The calculated time stamps values are saved as private members 
    _ftLastModifiedTime, _ftExpiryTime, _fHasExpiry,
    _fHasLastModifiedTime, and _fMustRevalidate.

Return Value: 

    NONE

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "CAutoProxy::CalculateTimeStampsForCache",
                 NULL
                 ));

    TCHAR   buf[256];
    BOOL    fRet = FALSE;
    DWORD   dwLen, index = 0;

    // reset the private variables
    _fHasLastModifiedTime = FALSE;
    _fHasExpiry = FALSE;
    _fMustRevalidate = FALSE;

    // Determine if a Cache-Control: max-age header exists. If so, calculate expires
    // time from current time + max-age minus any delta indicated by Age:

    CHAR  *ptr, *pToken;

    BOOL fResult;
    DWORD dwError;
    
    while (1)
    {
        // Scan headers for Cache-Control: max-age header.
        dwLen = sizeof(buf);
        fResult = HttpQueryInfoA(hRequest, 
                                WINHTTP_QUERY_CACHE_CONTROL,
                                NULL,
                                buf,
                                &dwLen,
                                &index);

        if (fResult == TRUE) 
            dwError = ERROR_SUCCESS;
        else
            dwError = GetLastError();

        switch (dwError)
        {
        case ERROR_SUCCESS:      
            buf[dwLen] = '\0';
            pToken = ptr = buf;

            // Parse a token from the string; test for sub headers.
            while (NULL != (pToken = StrTokEx(&ptr, ",")))  // <<-- Really test this out, used StrTokEx before
            {
                SKIPWS(pToken);

                if (strnicmp(MAX_AGE_SZ, pToken, MAX_AGE_LEN) == 0)
                {
                    // Found max-age. Convert to integer form.
                    // Parse out time in seconds, text and convert.
                    pToken += MAX_AGE_LEN;

                    SKIPWS(pToken);

                    if (*pToken != '=')
                        break;

                    pToken++;

                    SKIPWS(pToken);

                    INT nDeltaSecs = atoi(pToken);
                    INT nAge;

                    // See if an Age: header exists.

                    // Using a local index variable:
                    DWORD indexAge = 0;
                    dwLen = sizeof(INT)+1;

                    if (HttpQueryInfoA(hRequest,
                                      HTTP_QUERY_AGE | HTTP_QUERY_FLAG_NUMBER,
                                      NULL,
                                      &nAge,
                                      &dwLen,
                                      &indexAge))

                    {
                        // Found Age header. Convert and subtact from max-age.
                        // If less or = 0, attempt to get expires header.
                        nAge = ((nAge < 0) ? 0 : nAge);

                        nDeltaSecs -= nAge;
                        if (nDeltaSecs <= 0)
                        {
                            // The server (or some caching intermediary) possibly sent an incorrectly
                            // calculated header. Use "Expires", if no "max-age" directives at higher indexes.
                            continue;
                        }
                    }

                    // Calculate expires time from max age.
                    GetCurrentGmtTime(&_ftExpiryTime);
                    AddLongLongToFT(&_ftExpiryTime, (nDeltaSecs * (LONGLONG) 10000000));
                    fRet = TRUE;
                }
                else if (strnicmp(MUST_REVALIDATE_SZ, pToken, MUST_REVALIDATE_LEN) == 0)
                {
                    pToken += MUST_REVALIDATE_LEN;
                    SKIPWS(pToken);
                    if (*pToken == 0 || *pToken == ',')
                        _fMustRevalidate = TRUE;
            
                }
            }

            // If an expires time has been found, break switch.
            if (fRet)
                break;
                    
            // Need to bump up index to prevent possibility of never-ending outer while(1) loop.
            // Otherwise, on exit from inner while, we could be stuck here reading the 
            // Cache-Control at the same index.
            // HttpQueryInfoA(WINHTTP_QUERY_CACHE_CONTROL, ...) will return either the next index,
            // or an error, and we'll be good to go:
            index++;
            continue;

        case ERROR_INSUFFICIENT_BUFFER:
            index++;
            continue;

        default:
            break; // no more Cache-Control headers.
        }

        break; // no more Cache-Control headers.
    }

    // If no expires time is calculated from max-age, check for expires header.
    if (!fRet)
    {
        dwLen = sizeof(buf) - 1;
        index = 0;
        if (HttpQueryInfoA(hRequest, HTTP_QUERY_EXPIRES, NULL, buf, &dwLen, &index))
        {
            fRet = FParseHttpDate(&_ftExpiryTime, buf);

            //
            // as per HTTP spec, if the expiry time is incorrect, then the page is
            // considered to have expired
            //

            if (!fRet)
            {
                GetCurrentGmtTime(&_ftExpiryTime);
                AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
                fRet = TRUE;
            }
        }
    }

    // We found or calculated a valid expiry time, let us check it against the
    // server date if possible
    FILETIME ft;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_DATE, NULL, buf, &dwLen, &index)
        && FParseHttpDate(&ft, buf))
    {

        // we found a valid Date: header

        // if the expires: date is less than or equal to the Date: header
        // then we put an expired timestamp on this item.
        // Otherwise we let it be the same as was returned by the server.
        // This may cause problems due to mismatched clocks between
        // the client and the server, but this is the best that can be done.

        // Calulating an expires offset from server date causes pages
        // coming from proxy cache to expire later, because proxies
        // do not change the date: field even if the reponse has been
        // sitting the proxy cache for days.

        // This behaviour is as-per the HTTP spec.


        if (FT2LL(_ftExpiryTime) <= FT2LL(ft))
        {
            GetCurrentGmtTime(&_ftExpiryTime);
            AddLongLongToFT(&_ftExpiryTime, (-1)*ONE_HOUR_DELTA); // subtract 1 hour
        }
    }

    _fHasExpiry = fRet;

    if (!fRet)
    {
        _ftExpiryTime.dwLowDateTime = 0;
        _ftExpiryTime.dwHighDateTime = 0;
    }

    fRet = FALSE;
    dwLen = sizeof(buf) - 1;
    index = 0;

    if (HttpQueryInfoA(hRequest, HTTP_QUERY_LAST_MODIFIED, NULL, buf, &dwLen, &index))
    {
        DEBUG_PRINT(PROXY,
                    INFO,
                    ("Last Modified date is: %q\n",
                    buf
                    ));

        fRet = FParseHttpDate(&_ftLastModifiedTime, buf);

        if (!fRet)
        {
            DEBUG_PRINT(PROXY,
                        ERROR,
                        ("FParseHttpDate() returns FALSE\n"
                        ));
        }
    }

    _fHasLastModifiedTime = fRet;

    if (!fRet)
    {
        _ftLastModifiedTime.dwLowDateTime = 0;
        _ftLastModifiedTime.dwHighDateTime = 0;
    }

    DEBUG_LEAVE(0);
}


VOID
CAutoProxy::AddIfModifiedSinceHeaders(HINTERNET hRequest)
/*++

Routine Description:

    Add the necessary IMS request headers to validate whether a cache
    entry can still be used to satisfy the GET request.

Return Value: 

    BOOL
    
--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 None,
                 "CAutoProxy::AddIfModifiedSinceHeaders",
                 NULL
                 ));

    // add if-modified-since only if there is last modified time
    // sent back by the site. This way you never get into trouble
    // where the site doesn't send you an last modified time and you
    // send if-modified-since based on a clock which might be ahead
    // of the site. So the site might say nothing is modified even though
    // something might be. www.microsoft.com is one such example
    if (_fHasLastModifiedTime)
    {
        #define HTTP_IF_MODIFIED_SINCE_SZ   "If-Modified-Since:"
        #define HTTP_IF_MODIFIED_SINCE_LEN  (sizeof(HTTP_IF_MODIFIED_SINCE_SZ) - 1)

        TCHAR szBuf[80];
        TCHAR szHeader[HTTP_IF_MODIFIED_SINCE_LEN + 80];
        DWORD dwLen;

        INET_ASSERT (FT2LL(_ftLastModifiedTime));

        dwLen = sizeof(szBuf);

        if (FFileTimetoHttpDateTime(&_ftLastModifiedTime, szBuf, &dwLen))
        {
            dwLen = wsprintf(szHeader, "%s %s", HTTP_IF_MODIFIED_SINCE_SZ, szBuf); 
            
            HttpAddRequestHeadersA(hRequest, 
                     szHeader, 
                     dwLen,
                     WINHTTP_ADDREQ_FLAG_ADD);
        }
    }
 
    DEBUG_LEAVE(0);
}



DWORD
CAutoProxy::RunProxyScript(
    LPCSTR      lpszUrl,
    LPCSTR      pszProxyScript,
    LPSTR *     ppszQueryResults
)
{
    CScriptSite *           pScriptSite     = NULL;
    AUTO_PROXY_HELPER_APIS  AutoProxyFuncs;

    URL_COMPONENTSA Url;
    char *          pszHostName = NULL;
    DWORD           error = ERROR_SUCCESS;
    HRESULT         hrCoInit = E_FAIL;
    HRESULT         hr = NOERROR;

    if(!DelayLoad( &g_moduleOle32))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Must initialize COM in order to host the JScript engine.
    //
    hrCoInit = DL(CoInitializeEx)(NULL, COINIT_MULTITHREADED);

    pScriptSite = new CScriptSite(this);

    if (!pScriptSite)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    ZeroMemory(&Url, sizeof(Url));
    Url.dwStructSize = sizeof(URL_COMPONENTSA);
    Url.dwHostNameLength  = 1L;
    Url.dwUrlPathLength   = 1L;

    if (!WinHttpCrackUrlA(lpszUrl, 0, 0, &Url))
    {
        error = ::GetLastError();
        goto quit;
    }

    pszHostName = NewString(Url.lpszHostName, Url.dwHostNameLength);

    if (!pszHostName)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // Make the call into the external DLL,
    //  and let it run, possibly initilization and doing a bunch
    //  of stuff.
    //

    hr = pScriptSite->Init(&AutoProxyFuncs, pszProxyScript);

    if (FAILED(hr))
    {
        goto quit;
    }

    __try
    {
        hr = pScriptSite->RunScript(lpszUrl, pszHostName, ppszQueryResults);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        hr = E_UNEXPECTED;
    }

quit:
    if (FAILED(hr))
    {
        error = ERROR_WINHTTP_BAD_AUTO_PROXY_SCRIPT;
    }

    if (pszHostName)
    {
        FREE_MEMORY(pszHostName);
    }

    if (pScriptSite)
    {
        pScriptSite->DeInit();
        delete pScriptSite;
    }

    if (SUCCEEDED(hrCoInit))
    {
        DL(CoUninitialize)();
    }
    return error;
}

DWORD
CAutoProxy::ParseProxyQueryResults(
    LPSTR                   pszQueryResults,
    WINHTTP_PROXY_INFO *    pProxyInfo
)
{
    LPSTR   pszProxy  = NULL;
    LPSTR   psz;
    size_t  len;
    DWORD   error;
    BOOL    fReadProxy = FALSE;

    memset(pProxyInfo, 0, sizeof(WINHTTP_PROXY_INFO));

    pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;

    for (;;)
    {
        // Skip any white space
        while (*pszQueryResults == ' ')
            pszQueryResults++;

        //
        // Skip to the end of the current token
        //
        psz = pszQueryResults;
        while (*psz != '\0' && *psz != ' ' && *psz != ';' && *psz != ',')
            psz++;

        len = psz - pszQueryResults;

        if (len == 0)
            break;

        if (!fReadProxy)
        {
            if (StrCmpNIA(pszQueryResults, "DIRECT", len) == 0)
            {
                break;
            }
            else if (StrCmpNIA(pszQueryResults, "PROXY", len) == 0)
            {
                fReadProxy = TRUE;
            }
            else // error
            {
                break;
            }
        }
        else
        {
            if (!pszProxy)
            {
                pszProxy = new char[lstrlen(pszQueryResults)+1];

                if (!pszProxy)
                    goto ErrorOutOfMemory;

                *pszProxy = '\0';
            }
            else
            {
                StrCatA(pszProxy, ";");
            }

            StrNCatA(pszProxy, pszQueryResults, len+1);

            fReadProxy = FALSE;
        }

        //
        // Are we at the end of the query-results string?
        // If not, advance to the next character.
        //
        if (*psz == '\0')
            break;
        else
            pszQueryResults = psz + 1;
    }

    if (pszProxy)
    {
        error = AsciiToWideChar_UsingGlobalAlloc(pszProxy, &pProxyInfo->lpszProxy);

        delete [] pszProxy;

        if (error)
            goto ErrorOutOfMemory;

        pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
    }

    return ERROR_SUCCESS;

ErrorOutOfMemory:
    error = ERROR_NOT_ENOUGH_MEMORY;
    goto Error;

Error:
    return error;
}


BOOL
CAutoProxy::IsDetectionNeeded()

/*++

Routine Description:

  Detects whether we need to actually run a detection on the network,
    or whether we can resuse current results from previous runs

Arguments:

    lpProxySettings - structure to fill

Return Value:

    DWORD
        ERROR_SUCCESS    - success

        Win32 Error code - failure

--*/

{
    int         addressCount;
    LPHOSTENT   lpHostent;
    BOOL        fDetectionNeeded = FALSE;

    if (_pdwDetectedInterfaceIp == NULL)
    {
        // no saved IP address, so detection required
        fDetectionNeeded = TRUE;
    }
    else
    {
        //
        // Check for IP addresses that no longer match, indicating a network change
        //
        __try
        {
            lpHostent = _I_gethostbyname(NULL);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            lpHostent = NULL;
        }

        if (lpHostent != NULL && _CritSec.Lock())
        {
            for (addressCount = 0;
                 lpHostent->h_addr_list[addressCount] != NULL;
                 addressCount++ );  // gather count

            if (addressCount != _cDetectedInterfaceIpCount)
            {
                fDetectionNeeded = TRUE; // detect needed, the IP count is different
            }
            else
            {
                for (int i = 0; i < addressCount; i++)
                {
                    if (*((DWORD *)(lpHostent->h_addr_list[i])) != _pdwDetectedInterfaceIp[i] )
                    {
                        fDetectionNeeded = TRUE; // detect needed, mismatched values
                        break;
                    }
                }
            }

            _CritSec.Unlock();
        }
    }

    return fDetectionNeeded; // default, do not need to redetect
}


DWORD 
CAutoProxy::GetHostAddresses(int * pcInterfaces, DWORD ** ppdwInterfaceIp)
{
    int         addressCount = 0;
    LPHOSTENT   lpHostent;
    DWORD       error;
    DWORD *     pdwInterfaceIp  = NULL;

    error = LoadWinsock();

    if ( error != ERROR_SUCCESS )
    {
        goto quit;
    }

    
    //
    // Gather IP addresses and start copying them over
    //

    __try
    {
        lpHostent = _I_gethostbyname(NULL);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        lpHostent = NULL;
    }

    if (lpHostent == NULL )
    {
        goto quit;
    }

    for (addressCount = 0;
         lpHostent->h_addr_list[addressCount] != NULL;
         addressCount++ );  // gather count

    pdwInterfaceIp = (DWORD *) ALLOCATE_FIXED_MEMORY(addressCount * sizeof(DWORD));

    if (pdwInterfaceIp != NULL)
    {
        for (int i = 0; i < addressCount; i++)
        {
            (pdwInterfaceIp)[i] = *((DWORD *)(lpHostent->h_addr_list[i]));
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    if (pdwInterfaceIp)
    {
        *ppdwInterfaceIp = pdwInterfaceIp;
        *pcInterfaces    = addressCount;
    }

    return error;
}



AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{
    URL_COMPONENTSA urlComponents;

    Initalize();

    if ( lpszUrl )
    {
        _lpszUrl      = lpszUrl;
        _dwUrlLength  = lstrlen(lpszUrl);
        _tUrlProtocol = isUrlScheme;
        _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
        _pmaAllocMode = MSG_ALLOC_STACK_ONLY;

        memset(&urlComponents, 0, sizeof(urlComponents));
        urlComponents.dwStructSize = sizeof(urlComponents);
        urlComponents.lpszHostName = lpszUrlHostName;
        urlComponents.dwHostNameLength = dwUrlHostNameLength;

        //
        // parse out the host name and port. The host name will be decoded; the
        // original URL will not be modified
        //

        if (WinHttpCrackUrlA(lpszUrl, 0, ICU_DECODE, &urlComponents))
        {
           _nUrlPort            = urlComponents.nPort;
           _lpszUrlHostName     = urlComponents.lpszHostName;
           _dwUrlHostNameLength = urlComponents.dwHostNameLength;

           if ( _tUrlProtocol == INTERNET_SCHEME_UNKNOWN )
           {
               _tUrlProtocol = urlComponents.nScheme;
           }

        }
        else
        {
            _Error = GetLastError();
        }
    }
    else
    {
        _Error = ERROR_NOT_ENOUGH_MEMORY;
    }
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength
    )
{

    Initalize();

    _tUrlProtocol = isUrlScheme;
    _pmProxyQuery = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode = MSG_ALLOC_STACK_ONLY;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    Initalize();

    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;

}

VOID
AUTO_PROXY_ASYNC_MSG::SetProxyMsg(
    IN INTERNET_SCHEME isUrlScheme,
    IN LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN LPSTR lpszUrlHostName,
    IN DWORD dwUrlHostNameLength,
    IN INTERNET_PORT nUrlPort
    )
{
    _tUrlProtocol        = isUrlScheme;
    _pmProxyQuery        = PROXY_MSG_GET_PROXY_INFO;
    _pmaAllocMode        = MSG_ALLOC_STACK_ONLY;
    _nUrlPort            = nUrlPort;
    _lpszUrlHostName     = lpszUrlHostName;
    _dwUrlHostNameLength = dwUrlHostNameLength;
    _lpszUrl             = lpszUrl;
    _dwUrlLength         = dwUrlLength;
}


AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN PROXY_MESSAGE_TYPE pmProxyQuery
    )
{
    Initalize();

    _pmaAllocMode = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pmProxyQuery = pmProxyQuery;
}

AUTO_PROXY_ASYNC_MSG::AUTO_PROXY_ASYNC_MSG(
    IN AUTO_PROXY_ASYNC_MSG *pStaticAutoProxy
    )
{
    Initalize();

    _tUrlProtocol          = pStaticAutoProxy->_tUrlProtocol;
    _lpszUrl               = (pStaticAutoProxy->_lpszUrl) ? NewString(pStaticAutoProxy->_lpszUrl) : NULL;
    _dwUrlLength           = pStaticAutoProxy->_dwUrlLength;
    _lpszUrlHostName       =
                (pStaticAutoProxy->_lpszUrlHostName ) ?
                NewString(pStaticAutoProxy->_lpszUrlHostName, pStaticAutoProxy->_dwUrlHostNameLength) :
                NULL;
    _dwUrlHostNameLength   = pStaticAutoProxy->_dwUrlHostNameLength;
    _nUrlPort              = pStaticAutoProxy->_nUrlPort;
    _tProxyScheme          = pStaticAutoProxy->_tProxyScheme;

    //
    // ProxyHostName is something that is generated by the request,
    //   therefore it should not be copied OR freed.
    //

    INET_ASSERT( pStaticAutoProxy->_lpszProxyHostName == NULL );
    //_lpszProxyHostName     = (pStaticAutoProxy->_lpszProxyHostName ) ? NewString(pStaticAutoProxy->_lpszProxyHostName) : NULL;


    _dwProxyHostNameLength = pStaticAutoProxy->_dwProxyHostNameLength;
    _nProxyHostPort        = pStaticAutoProxy->_nProxyHostPort;
    _pmProxyQuery          = pStaticAutoProxy->_pmProxyQuery;
    _pmaAllocMode          = MSG_ALLOC_HEAP_MSG_OBJ_OWNS;
    _pProxyState           = pStaticAutoProxy->_pProxyState;

    INET_ASSERT(_pProxyState == NULL);

    _dwQueryResult         = pStaticAutoProxy->_dwQueryResult;
    _Error                 = pStaticAutoProxy->_Error;
    _MessageFlags.Dword    = pStaticAutoProxy->_MessageFlags.Dword;
    _dwProxyVersion        = pStaticAutoProxy->_dwProxyVersion;
}

AUTO_PROXY_ASYNC_MSG::~AUTO_PROXY_ASYNC_MSG(
    VOID
    )
{
    DEBUG_ENTER((DBG_OBJECTS,
                None,
                "~AUTO_PROXY_ASYNC_MSG",
                NULL
                ));

    if ( IsAlloced() )
    {
        DEBUG_PRINT(OBJECTS,
                    INFO,
                    ("Freeing Allocated MSG ptr=%x\n",
                    this
                    ));


        if ( _lpszUrl )
        {
            //DEBUG_PRINT(OBJECTS,
            //            INFO,
            //            ("Url ptr=%x, %q\n",
            //            _lpszUrl,
            //            _lpszUrl
            //            ));

            FREE_MEMORY(_lpszUrl);
        }

        if ( _lpszUrlHostName )
        {
            FREE_MEMORY(_lpszUrlHostName);
        }


        if ( _pProxyState )
        {
            delete _pProxyState;
        }
    }
    if (_bFreeProxyHostName && (_lpszProxyHostName != NULL)) {
        FREE_MEMORY(_lpszProxyHostName);
    }

    DEBUG_LEAVE(0);
}



DWORD
AUTO_PROXY_HELPER_APIS::ResolveHostName(
    IN LPSTR lpszHostName,
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Resolves a HostName to an IP address by using Winsock DNS.
 
Arguments:
 
    lpszHostName   - the host name that should be used.
 
    lpszIPAddress  - the output IP address as a string.
 
    lpdwIPAddressSize - the size of the outputed IP address string.
 
Return Value:
 
    DWORD
        Win32 error code.
 
--*/
 
{
    // Figure out if we're being asked to resolve a name or an address literal.
    // If getaddrinfo() with the AI_NUMERICHOST flag succeeds then we were
    // given a string respresentation of an IPv6 or IPv4 address. Otherwise
    // we expect getaddrinfo to return EAI_NONAME.
    //

    DWORD dwIPAddressSize;
    BOOL bResolved = FALSE;
    ADDRINFO Hints;
    LPADDRINFO lpAddrInfo;
    DWORD error;

    memset(&Hints, 0, sizeof(struct addrinfo));
    Hints.ai_flags = AI_NUMERICHOST;  // Only check for address literals.
    Hints.ai_family = PF_UNSPEC;      // Accept any protocol family.
    Hints.ai_socktype = SOCK_STREAM;  // Constrain results to stream socket.
    Hints.ai_protocol = IPPROTO_TCP;  // Constrain results to TCP.

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);
    if (error != EAI_NONAME) {
        if (error != 0) {
            if (error == EAI_MEMORY)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
                error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }

        //
        // An IP address (either v4 or v6) was passed in.
        // This is precisely what we want, so if we have the room,
        // just copy it back out.
        //

        _I_freeaddrinfo(lpAddrInfo);

        dwIPAddressSize = lstrlen(lpszHostName);
 
        if ( *lpdwIPAddressSize < dwIPAddressSize ||
              lpszIPAddress == NULL )
        {
            *lpdwIPAddressSize = dwIPAddressSize+1;
            error = ERROR_INSUFFICIENT_BUFFER;
            goto quit;
        }
 
        lstrcpy(lpszIPAddress, lpszHostName);
        goto quit;
    }
  
    DEBUG_PRINT(SOCKETS,
                INFO,
                ("resolving %q\n",
                lpszHostName
                ));

    error = _I_getaddrinfo(lpszHostName, NULL, &Hints, &lpAddrInfo);

    DEBUG_PRINT(SOCKETS,
                INFO,
                ("%q %sresolved\n",
                lpszHostName,
                (error == 0) ? "" : "NOT "
                ));
 
    if (error == 0) {
        bResolved = TRUE;
    } else {
        if (error == EAI_MEMORY)
            error = ERROR_NOT_ENOUGH_MEMORY;
        else
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
        goto quit;
    }

    INET_ASSERT(lpAddrInfo != NULL);

    //
    // We have an addrinfo struct for lpszHostName.
    // Convert its IP address into a string.
    //

    //
    // BUGBUG: Until our caller can deal with IPv6 addresses, we'll only
    // return IPv4 addresses here, regardless of what may be in the cache.
    // Step through chain until we find an IPv4 address.
    //

    LPADDRINFO IPv4Only;

    IPv4Only = lpAddrInfo;
    while (IPv4Only->ai_family != AF_INET) {

        IPv4Only = IPv4Only->ai_next;
        if (IPv4Only == NULL) {
            error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
            goto quit;
        }
    }

    error = _I_getnameinfo(IPv4Only->ai_addr, IPv4Only->ai_addrlen,
                           lpszIPAddress, *lpdwIPAddressSize, NULL, 0,
                           NI_NUMERICHOST);

    if (error != 0) {
        error = ERROR_WINHTTP_NAME_NOT_RESOLVED;
    }

quit:
    if (bResolved)
    {
        _I_freeaddrinfo(lpAddrInfo);
    }

    return error;
}

BOOL
AUTO_PROXY_HELPER_APIS::IsResolvable(
    IN LPSTR lpszHost
    )
 
/*++
 
Routine Description:
 
    Determines wheter a HostName can be resolved.  Performs a Winsock DNS query,
      and if it succeeds returns TRUE.
 
Arguments:
 
    lpszHost   - the host name that should be used.
 
Return Value:
 
    BOOL
        TRUE - the host is resolved.
 
        FALSE - could not resolve.
 
--*/
 
{
 
    DWORD dwDummySize;
    DWORD error;
 
    error = ResolveHostName(
                lpszHost,
                NULL,
                &dwDummySize
                );
 
    if ( error == ERROR_INSUFFICIENT_BUFFER )
    {
        return TRUE;
    }
    else
    {
        INET_ASSERT(error != ERROR_SUCCESS );
        return FALSE;
    }
 
}
DWORD
AUTO_PROXY_HELPER_APIS::GetIPAddress(
    IN OUT LPSTR   lpszIPAddress,
    IN OUT LPDWORD lpdwIPAddressSize
    )
 
/*++
 
Routine Description:
 
    Acquires the IP address string of this client machine WINHTTP is running on.
 
Arguments:
 
    lpszIPAddress   - the IP address of the machine, returned.
 
    lpdwIPAddressSize - size of the IP address string.
 
Return Value:
 
    DWORD
        Win32 Error.
 
--*/
 
{
 
    CHAR szHostBuffer[255];
    int serr;
 
    serr = _I_gethostname(
                szHostBuffer,
                255-1 
                );
 
    if ( serr != 0)
    {
        return ERROR_WINHTTP_INTERNAL_ERROR;
    }
 
    return ResolveHostName(
                szHostBuffer,
                lpszIPAddress,
                lpdwIPAddressSize
                );
 
}

BOOL
AUTO_PROXY_HELPER_APIS::IsInNet(
    IN LPSTR   lpszIPAddress,
    IN LPSTR   lpszDest,
    IN LPSTR   lpszMask
    )
 
/*++
 
Routine Description:
 
    Determines whether a given IP address is in a given dest/mask IP address.
 
Arguments:
 
    lpszIPAddress   - the host name that should be used.
 
    lpszDest        - the IP address dest to check against.
 
    lpszMask        - the IP mask string
 
Return Value:
 
    BOOL
        TRUE - the IP address is in the given dest/mask
 
        FALSE - the IP address is NOT in the given dest/mask
 
--*/
 
{
    DWORD dwDest, dwIpAddr, dwMask;
 
    INET_ASSERT(lpszIPAddress);
    INET_ASSERT(lpszDest);
    INET_ASSERT(lpszMask);
 
    dwIpAddr = _I_inet_addr(lpszIPAddress);
    dwDest   = _I_inet_addr(lpszDest);
    dwMask   = _I_inet_addr(lpszMask);
 
    if ( dwDest   == INADDR_NONE ||
         dwIpAddr == INADDR_NONE  )
 
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
 
    if ( (dwIpAddr & dwMask) != dwDest)
    {
        return FALSE;
    }
 
    //
    // Pass, its Matches.
    //
 
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5\urlcache\test\testurlcache.cxx ===
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//
// Copyright 1996 Microsoft Corporation.  All Rights Reserved.
// ===========================================================================
// 
// Test driver for the persistant URL Cache component
//

// This define is a hack
#define __CACHE_INCLUDE__

#include <windows.h>
#include <winhttp.h>
#include "..\cache.hxx"
#include <conio.h>
#include <stdio.h>
#include <crtdbg.h>
#include <stdlib.h>
#include <time.h>

// support for Unicode
#include <tchar.h>

// file I/O include
#include <fstream.h>

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define DEFAULT_BUFFER_SIZE 1024
#define MAX_URL_LENGTH (1024 * 5)

// URL string constants
#define URL_1 "t-eddieng"
#define URL_2 "http://www.microsoft.com"

// global variables
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];

// General Utility Functions
// =======================================================================
LPTSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPTSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};
    
    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        _stprintf (OutputBuffer, _T( "<none>" ));
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        _stprintf( OutputBuffer,
                    _T( "%02u/%02u/%04u %02u:%02u:%02u " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    
    return( OutputBuffer );
}

DWORD TestCommitCacheEntryWithoutInet(VOID) {
	DWORD dwExpectedSize = 0;	                
	TCHAR lpFileExtension[] = "html";
	TCHAR lpszFileName[MAX_PATH];
    TCHAR szBuffer[] = "<HTML><TITLE>Test</TITLE><BODY>Testgadfasing</BODY></HTML>";
    HANDLE hWrite;
    DWORD dwWritten;

    // Prepare cache entry by calling CreateUrlCacheEntry
    if( !CreateUrlCacheEntryA(
                URL_1,
                dwExpectedSize,
                lpFileExtension,
                lpszFileName,
                0 )  ) {
        printf ("CreateUrlCacheEntry failed: %x\n", GetLastError());
        return( GetLastError() );
    }

    _tprintf(_T( "URL = %s\n" ), lpszFileName);

    // Now monkey around with the local file (lpszFileName)
    hWrite = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hWrite == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    WriteFile(hWrite, &szBuffer, sizeof(szBuffer), &dwWritten, NULL);
    if (sizeof(szBuffer) != dwWritten) {
        printf ("WriteFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    CloseHandle(hWrite);

    FILETIME unknownTime1;
    unknownTime1.dwLowDateTime = 0;
    unknownTime1.dwHighDateTime = 0;
    
    FILETIME unknownTime2;
    unknownTime2.dwLowDateTime = 0;
    unknownTime2.dwHighDateTime = 0;

    // Commit cache entry by calling CommitUrlCacheEntry
    if ( !CommitUrlCacheEntryA(URL_1, 
                               lpszFileName, 
                               unknownTime1, /* unknown expire time */
                               unknownTime2, /* unknown last modified time */
                               NORMAL_CACHE_ENTRY,
                               NULL,
                               0,
                               NULL,
                               NULL)) {
        printf ("CommitUrlCacheEntry failed: %x\n", GetLastError());
        return GetLastError();
    }
    
    return TRUE;
}

/* +++

    FPTestEnumerateCache Function pointers

--- */
// =======================================================================

DWORD TestCommitCacheEntryFromInet(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

	TCHAR *lpFileExtension = NULL;
	LPSTR lpszUrlName = lpCacheEntryInfo->lpszSourceUrlName;
    LPSTR lpszFileName = lpCacheEntryInfo->lpszLocalFileName;

    TCHAR szBuffer[] = "<HTML><TITLE>Test</TITLE><BODY>Testing</BODY></HTML>";
    HANDLE hWrite;
    DWORD dwWritten;
    DWORD dwExpectedSize;

    printf ("%s\n", lpszFileName);

    
    // Now monkey around with the local file (lpszFileName)
    hWrite = CreateFile(lpszFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hWrite == INVALID_HANDLE_VALUE) {
        printf ("CreateFile failed: %x\n", GetLastError());
        return GetLastError();
    }

    WriteFile(hWrite, &szBuffer, sizeof(szBuffer), &dwWritten, NULL);
    if (sizeof(szBuffer) != dwWritten) {
        printf ("WriteFile failed: %x\n", GetLastError());
        return GetLastError();
    }

	dwExpectedSize = GetFileSize(hWrite, NULL); 

    CloseHandle(hWrite);

    // Commit cache entry by calling CommitUrlCacheEntry
    if ( !CommitUrlCacheEntryA(lpszUrlName, 
                               lpszFileName, 
                               lpCacheEntryInfo->ExpireTime,  /* expire time */
                               lpCacheEntryInfo->LastModifiedTime, /* last modified time */
                               NORMAL_CACHE_ENTRY,
                               NULL,
                               0,
                               NULL,
                               NULL)) {
        printf ("CommitUrlCacheEntry failed: %x\n", GetLastError());
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}

// getting the content of the a cache entry into memory (i.e. don't need to write to disk)
DWORD TestRetrieveCacheEntryToMemory(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    DWORD dwLen;
    DWORD szFileSize = lpCacheEntryInfo->dwSizeLow;
    DWORD dwCurLocation = 0;
    TCHAR lpszUrlName[MAX_URL_LENGTH];
    HANDLE hCacheEntryStream;
    LPSTR pszBuffer;
    DWORD dwEntryBufferSize = CACHE_ENTRY_BUFFER_SIZE;
    
    strncpy(lpszUrlName, lpCacheEntryInfo->lpszSourceUrlName, MAX_URL_LENGTH); 

    if ((hCacheEntryStream = RetrieveUrlCacheEntryStreamA(lpszUrlName, lpCacheEntryInfo, 
                                &dwEntryBufferSize, TRUE, 0)) == NULL) 
    {
        return GetLastError();
    }

    // srand( (unsigned)time(NULL));

    //while (TRUE) {
        dwLen = szFileSize;
        pszBuffer = new char[dwLen+1];
        ZeroMemory(pszBuffer, dwLen+1);

        if (ReadUrlCacheEntryStream(hCacheEntryStream, dwCurLocation, (LPVOID)pszBuffer, &dwLen, 0)) {
            printf ("%s\n\n", pszBuffer);
            delete pszBuffer;
        }
        else
        {
            delete pszBuffer;
            dwCurLocation += dwLen;
            if (dwCurLocation == szFileSize)
                return GetLastError();

            _ASSERT(0);
        }
            
    //}

    // close the cache entry stream handle
    UnlockUrlCacheEntryStream(hCacheEntryStream, 0);
    return ERROR_SUCCESS;
    
}    
DWORD TestGetUrlCacheEntryInfo(LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo) {
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

    if (!(lpCacheEntryInfo->CacheEntryType & COOKIE_CACHE_ENTRY) && 
       !(lpCacheEntryInfo->CacheEntryType & URLHISTORY_CACHE_ENTRY)) {
        printf("\n\n------------------------------------------------------------------\n");
        _tprintf( _T( "%sUrlName = %s\n" ), Tab, lpCacheEntryInfo->lpszSourceUrlName );
#if UNICODE
        _tprintf( _T( "%sLocalFileName = %ws\n" ), Tab, lpCacheEntryInfo->lpszLocalFileName );
#else
        _tprintf( _T( "%sLocalFileName = %s\n" ), Tab, lpCacheEntryInfo->lpszLocalFileName );
#endif
        _tprintf( _T( "%sdwStructSize = %lx\n" ), Tab, lpCacheEntryInfo->dwStructSize );
        _tprintf( _T( "%sCacheEntryType = %lx\n" ), Tab, lpCacheEntryInfo->CacheEntryType );
        _tprintf( _T( "%sUseCount = %ld\n" ), Tab, lpCacheEntryInfo->dwUseCount );

        _tprintf( _T( "%sHitRate = %ld\n" ), Tab, lpCacheEntryInfo->dwHitRate );
        _tprintf( _T( "%sSize = %ld:%ld\n" ), Tab, lpCacheEntryInfo->dwSizeLow, lpCacheEntryInfo->dwSizeHigh );
        _tprintf( _T( "%sLastModifiedTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastModifiedTime, TimeBuffer) );
        _tprintf( _T( "%sExpireTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->ExpireTime, TimeBuffer) );
        _tprintf( _T( "%sLastAccessTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastAccessTime, TimeBuffer) );
        _tprintf( _T( "%sLastSyncTime = %s\n" ), Tab, ConvertGmtTimeToString( lpCacheEntryInfo->LastSyncTime, TimeBuffer) );
#if 1
        _tprintf( _T( "%sHeaderInfo = \n%s\n" ), Tab, lpCacheEntryInfo->lpHeaderInfo );
#endif
        _tprintf( _T( "%sHeaderInfoSize = %ld\n" ), Tab, lpCacheEntryInfo->dwHeaderInfoSize );
#if UNICODE
        _tprintf( _T( "%sFileExtension = %ws\n" ), Tab, lpCacheEntryInfo->lpszFileExtension );
#else
        _tprintf( _T( "%sFileExtension = %s\n" ), Tab, lpCacheEntryInfo->lpszFileExtension );
#endif

    }
    return ERROR_SUCCESS;

}

// =============================================================================
typedef DWORD (*FPTestEnumerateCache)(LPINTERNET_CACHE_ENTRY_INFO);
    
/* +++

    TestEnumerateCache

    Purpose:
    Enumerate the persistent URL cache entry in the system.
    
    Parameters:
        [in] count  -    number of iterations to enumerate.  If set to 0 than enumerate all
        ptrfunc     -   a the function pointer to call for each cache entry.  If set to NULL then
                        no functions are called

    Return Value:
        ERROR_SUCCESS if call succeeds.  Otherwise return GetLastError()

--- */

DWORD TestEnumerateCache(DWORD dwCount, FPTestEnumerateCache pfTestEnumerateCache) {

    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo;
    DWORD CacheEntryInfoBufferSize;
    
    DWORD dwBufferSize;
    HANDLE EnumHandle;
    DWORD dwIndex = 0;
    TCHAR UrlName[1024];
    DWORD dwError = ERROR_SUCCESS;

    do
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        dwBufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( dwIndex++ == 0)
        {
            EnumHandle = FindFirstUrlCacheEntryEx (
                NULL,                   // search pattern
                0,                      // flags
                0xffffffff,             // filter
                0,                      // groupid
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &dwBufferSize,
                NULL,
                NULL,
                NULL
            );

            if( EnumHandle == NULL ) {
                return( GetLastError() );
            }
        } else {
            if( !FindNextUrlCacheEntryEx(
                    EnumHandle,
                    (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                    &dwBufferSize, NULL, NULL, NULL))
            {
                dwError = GetLastError();
                if( dwError != ERROR_NO_MORE_ITEMS ) 
                    return( dwError );                   
                break;
            }
        }

        // now we've got the URL entry, do something about it
        strcpy(UrlName, ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);

        lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;

        // clean up the block of memory
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

        _ASSERT(UrlName);

        // put cache entry info into lpCacheEntryInfo
        if (GetUrlCacheEntryInfoA(UrlName,
                                 lpCacheEntryInfo,
                                 &CacheEntryInfoBufferSize ))
        {
            if (pfTestEnumerateCache(lpCacheEntryInfo) != ERROR_SUCCESS)
                printf ("Function pointer call failed\n");
        }
    }
    while (dwCount == 0 || (dwCount != 0 && dwIndex < dwCount));

    FindCloseUrlCache(EnumHandle);
	return TRUE;
}

// =============================================================================
/* +++

    Sets of test cases to execute directly from main()
    
---*/
   
void TestCase1() {
	(void) TestEnumerateCache(0, (FPTestEnumerateCache)TestGetUrlCacheEntryInfo);
	//(void) TestEnumerateCache(1, (FPTestEnumerateCache)TestCommitCacheEntryFromInet);
}

void TestCase2() {
    (void) TestCommitCacheEntryWithoutInet();
}

// test retrieving the cache entry to memory (i.e. don't need a file) incrementally using the Wininet API
void TestCase3() {
    (void) TestEnumerateCache(4, (FPTestEnumerateCache)TestRetrieveCacheEntryToMemory);
}

void TestCase4() {
    (void) TestEnumerateCache(1, (FPTestEnumerateCache)TestCommitCacheEntryFromInet);
}

void __cdecl main() {
	// HACK: At the time being, DLLUrlCacheEntry has to be called explicitly during initialization and termination, 
	// since the urlcache component is not attached to WinHttp's DLL hooks yet.
	// We'll remove this constraint when the cache component becomes part of WinHTTP
	DLLUrlCacheEntry(DLL_PROCESS_ATTACH);    

    TestCase1();

	DLLUrlCacheEntry(DLL_PROCESS_DETACH);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\cliauth.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    cliauth.cxx

Abstract:

    Contains Schannel/SSPI specific code for handling Client Authenication
    multiplexed between several asynchronous requests using fibers

    Contents:
        CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY
        CERT_CONTEXT_ARRAY::Reset
        CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY
        CliAuthSelectCredential

Author:

    Arthur L Bierer (arthurbi) 13-Jun-1996

Environment:

    Win32 user-mode DLL

Revision History:

    13-Jun-1996 arthurbi
        Created, based on orginal code from a-petesk.

--*/

#include <wininetp.h>


extern "C" {

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsecapi.h>

}


CERT_FREE_CERTIFICATE_CONTEXT_FN       g_pfnCertFreeCertificateContext = NULL;


CERT_CONTEXT_ARRAY::CERT_CONTEXT_ARRAY(BOOL fNoRevert)
{
    _error           = ERROR_SUCCESS;
    _iSelected  = -1;
    _ppCertContexts    = (PCCERT_CONTEXT *)
                        ALLOCATE_MEMORY(sizeof(PCERT_CONTEXT)* CERT_CONTEXT_ARRAY_ALLOC_UNIT);

    if ( _ppCertContexts == NULL ) {
        _error = GetLastError();
    }

    _cAlloced  = CERT_CONTEXT_ARRAY_ALLOC_UNIT;
    _cCertContexts     = 0;

    ClearCreds(_hCreds);
    _cs.Init();

    _fNoRevert = fNoRevert;
}

void CERT_CONTEXT_ARRAY::Reset(void)
{
    if ( _ppCertContexts )
    {
        for ( DWORD i = 0; i < _cCertContexts; i++ )
        {
            INET_ASSERT(_ppCertContexts[i]);
            WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext), _fNoRevert, (_ppCertContexts[i]));
        }
    }
    _cCertContexts = 0;
    
    // It is important that this Free is guarded by a try except.
    // These objects get freed up at dll unload time and there is a circular
    // dependency between winient and schannel which can cause schannel to 
    // get unloaded. If that is the case we could fault here.
    if (!IsCredClear(_hCreds))
    {
        SAFE_WRAP_REVERT_USER_VOID(g_FreeCredentialsHandle, _fNoRevert, (&_hCreds));
        ClearCreds(_hCreds);
    }
}


CERT_CONTEXT_ARRAY::~CERT_CONTEXT_ARRAY()
{
    Reset();

    FREE_MEMORY(_ppCertContexts);
}

DWORD
CliAuthSelectCredential(
    IN PCtxtHandle        phContext,
    IN LPTSTR             pszPackageName,
    IN CERT_CONTEXT_ARRAY*  pCertContextArray,
    OUT PCredHandle       phCredential,
    IN LPDWORD            pdwStatus,
    IN DWORD              dwSecureProtocols,
    IN BOOL               fNoRevert)

/*++

Routine Description:

    Uses a selected Certificate Chain to produce a Credential handle.

    The credential handle will be used by SCHANNEL to produce a valid Client
    Auth session with a server.

Arguments:

    phContext       - SSPI Context Handle

    pszPackageName  - Name of the SSPI package we're using.

    pSelectedCert   - Cert that User wishes us to use for Client Auth with this server.
                       (BUGBUG who should free this? )

    phCredential    - Outgoing SSPI Credential handle that we may generate
                    IMPORTANT: Do not free the credential handle returned by this function.
                    These have to be cached for the lifetime of the process so the user 
                    doesn't get prompted forthe password over and over. Unfortunately there is
                    no ref-counting mechanism on CredHandle's so callers of this function need to 
                    make sure they don't free the handle.

    pdwStatus       - Secure error status flag that's filled in if an error occurs.
                    Pointer is assumed to be valid.

    dwSecureProtocols - Enabled secure protocols (SSL2, SSL3, and/or TLS1) when acquiring
                        this credential.

    fNoRevert         - Determines if any impersonation should be reverted for SSL handling.

Return Value:

    DWORD
        Success - ERROR_SUCCESS
                        Caller should return ERROR_WINHTTP_CLIENT_AUTH_CERT_NEEDED,
                        to its caller.  The appropriate Cert chain was generated,
                        and the User needs to select it using UI.

        Failure -
                  ERROR_NOT_ENOUGH_MEMORY -
                        Out of Memory

                  ERROR_WINHTTP_SECURE_FAILURE -
                        Call Down to SSPI or WinTrust failed.

--*/

{

     SCHANNEL_CRED CredData = {SCHANNEL_CRED_VERSION,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     NULL,
                                     0,
                                     NULL,
                                     DEFAULT_SECURE_PROTOCOLS,
                                     0,
                                     0,
                                     0,
                                     SCH_CRED_MANUAL_CRED_VALIDATION |
                                     SCH_CRED_NO_DEFAULT_CREDS
                                     };
    SECURITY_STATUS scRet;


    DWORD           error = ERROR_SUCCESS;
    PCCERT_CONTEXT  pCert;

    UNREFERENCED_PARAMETER(phContext);

    DEBUG_ENTER((DBG_SOCKETS,
                 Dword,
                 "CliAuthSelectCredential",
                 "%#x, %s, %x, %x",
                 phContext,
                 pszPackageName,
                 pCertContextArray,
                 phCredential
                 ));


    INET_ASSERT(phContext);
    INET_ASSERT(pCertContextArray);
    INET_ASSERT(pszPackageName);


    if (!pCertContextArray->LockCredHandle( ))
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if ( pCertContextArray->GetArraySize() == 0 )
    {
        goto cleanup;
    }
    else
    {
        // First check and see if the Cert context already has a CredHandle associated with it.
        CredHandle hCreds = pCertContextArray->GetCredHandle( );

        if (!IsCredClear(hCreds))
        {
            *phCredential = hCreds;
            error = ERROR_SUCCESS;
            goto cleanup;
        }
    }

    pCert =         pCertContextArray->GetSelectedCertContext();


    //
    // Setup strucutres for AcquireCredentialsHandle call.
    //

    if ( pCert )
    {

        CredData.cCreds = 1;
        CredData.paCred = &pCert;
    }
    
    CredData.grbitEnabledProtocols = dwSecureProtocols;

    WRAP_REVERT_USER(g_AcquireCredentialsHandle,
                     fNoRevert,
                     (NULL,
                      pszPackageName,
                      SECPKG_CRED_OUTBOUND,
                      NULL,
                      &CredData,
                      NULL,
                      NULL,
                      phCredential,
                      NULL),
                     scRet);

    error = MapInternetError((DWORD)scRet, pdwStatus);
    if (error == ERROR_SUCCESS)
    {
        pCertContextArray->SetCredHandle(*phCredential);
    }

cleanup:
    pCertContextArray->UnlockCredHandle();
    
quit:
    DEBUG_LEAVE(error);

    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\creds.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    Creds.cxx

Abstract:

    Contains the Creds APIs

    Contents:
        WinHttpSetCredentialsA
        WinHttpSetCredentials
        WinHttpQueryAuthSchemes
        
Author:

    Biao Wang (biaow) 27-June-2000

Environment:

    Win32 user-mode DLL

Revision History:

    27-June-2000 biaow
        Created

--*/

#include <wininetp.h>

/*
BOOLAPI WinHttpQueryAuthParams(
    IN  HINTERNET   hRequest,        // HINTERNET handle returned by WinHttpOpenRequest   
    IN  DWORD       AuthScheme,
    OUT LPVOID*     pAuthParams      // Scheme-specific Advanced auth parameters
    )
{
    //BUG-BUG Verify parameters
    
    // biaow: to implement this fully
    *pAuthParams = 0;

    return TRUE;
}
*/

BOOLAPI WinHttpQueryAuthSchemes(
    
    IN  HINTERNET   hRequest,       // HINTERNET handle returned by HttpOpenRequest.   
    OUT LPDWORD     lpdwSupportedSchemes,// a bitmap of available Authentication Schemes
    OUT LPDWORD     lpdwPreferredScheme,  // WinHttp's preferred Authentication Method 
    OUT LPDWORD      pdwAuthTarget  
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryAuthSchemes",
                     "%#x, %#x, %#x",
                     hRequest,
                     lpdwSupportedSchemes,
                     lpdwPreferredScheme
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL fResult = FALSE;
    HINTERNET_HANDLE_TYPE HandleType;    

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) 
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }
    
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    if (::IsBadWritePtr(lpdwSupportedSchemes, sizeof(DWORD)) 
        || ::IsBadWritePtr(lpdwPreferredScheme, sizeof(DWORD)) 
        || ::IsBadWritePtr(pdwAuthTarget, sizeof(DWORD)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (!pRequest->_KnowSupportedSchemes)
    {
        dwErr = ERROR_INVALID_OPERATION;
        goto cleanup;
    }

    *lpdwSupportedSchemes = pRequest->_SupportedSchemes;
    *lpdwPreferredScheme = pRequest->_PreferredScheme;
    *pdwAuthTarget = pRequest->_AuthTarget;
    
    fResult = TRUE;

    DEBUG_PRINT(API,
                INFO,
                ("Supported Scheme = %x; Preferred Scheme = %x; Auth Target = %x\n",
                *lpdwSupportedSchemes,
                *lpdwPreferredScheme,
                *pdwAuthTarget
                ));

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!= ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOL WinHttpSetCredentialsA (
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCSTR     pszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCSTR     pszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID     pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentialsA",
                     "%#x, %#x, %#x, %q, %q, %q",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pszUserName ? "<username>" : "NULL",
                     pszPassword ? "<password>" : "NULL"
                     ));
    
    // Note: we assume WinHttp will explose an Unicode only API, so this function
    // will not be called directly by Apps. If this assumption is no longer true 
    // in future revisions, we need to add more elaborate parameter validation here.

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    HINTERNET hRequestMapped = NULL;
    HTTP_REQUEST_HANDLE_OBJECT* pRequest;
    HINTERNET_HANDLE_TYPE HandleType;
    PCSTR pszRealm = NULL;

    // validate API symantics

    if (pszUserName != NULL)
    {
        // in any case, it doesn't make sense (and therefore invalid) to pass 
        // in a blank("") User Name
        if (pszUserName[0] == '\0')
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        else if (pszPassword == NULL)
        {
            // in any case, if an app passes in a UserName, it is invalid to
            // then pass in a NULL password (should use "" for blank passowrd)
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    switch (AuthScheme)
    {
        case WINHTTP_AUTH_SCHEME_BASIC:
        case WINHTTP_AUTH_SCHEME_NTLM:
        case WINHTTP_AUTH_SCHEME_PASSPORT:
        case WINHTTP_AUTH_SCHEME_DIGEST:
        case WINHTTP_AUTH_SCHEME_NEGOTIATE:
            break;
        default:
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
    }

    // if an app picks BASIC auth, it must also supply an UserName and password
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_BASIC) && (pszUserName == NULL))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // default credentials (UserName/Password == NULL/NULL) are allowed only for 
    // NTLM/NEGOTIATE/PASSPORT auth
    if (pszUserName == NULL)
    {
        if ((AuthScheme != WINHTTP_AUTH_SCHEME_NTLM) 
            && (AuthScheme != WINHTTP_AUTH_SCHEME_NEGOTIATE)
            && (AuthScheme != WINHTTP_AUTH_SCHEME_PASSPORT))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
    }

    dwErr = ::MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);
    
    if ((dwErr != ERROR_SUCCESS) || (hRequestMapped == NULL)) {
        
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if ((::RGetHandleType(hRequestMapped, &HandleType) != ERROR_SUCCESS) 
        || (HandleType != TypeHttpRequestHandle))
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    pRequest = 
        reinterpret_cast<HTTP_REQUEST_HANDLE_OBJECT*>(hRequestMapped);

    if (AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST)
    {
        if (pAuthParams)
        {
            pszRealm = (PCSTR)pAuthParams;
        }
        else
        {
            pszRealm = pRequest->_pszRealm;
        }
    }

    if (AuthTargets == WINHTTP_AUTH_TARGET_PROXY)
    {
        delete pRequest->_pProxyCreds;
        pRequest->_pProxyCreds = New WINHTTP_REQUEST_CREDENTIALS();
        
        if (pRequest->_pProxyCreds == NULL
            || !pRequest->_pProxyCreds->Initialize(AuthScheme, pszRealm, pszUserName, pszPassword))
        {
            if (pRequest->_pProxyCreds != NULL)
            {
                delete pRequest->_pProxyCreds;
                pRequest->_pProxyCreds = NULL;
            }
            
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    else 
    {
        delete pRequest->_pServerCreds;
        pRequest->_pServerCreds = New WINHTTP_REQUEST_CREDENTIALS();
        
        if (pRequest->_pServerCreds == NULL
            || !pRequest->_pServerCreds->Initialize(AuthScheme, pszRealm, pszUserName, pszPassword))
        {
            if (pRequest->_pServerCreds != NULL)
            {
                delete pRequest->_pServerCreds;
                pRequest->_pServerCreds = NULL;
            }
            
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }

    pRequest->_KnowSupportedSchemes = FALSE;
    pRequest->_PreferredScheme = 0x00000000;
    pRequest->_SupportedSchemes = 0x00000000;
    pRequest->_AuthTarget = 0x00000000;
    if (pRequest->_pszRealm)
    {
        FREE_MEMORY(pRequest->_pszRealm);
        pRequest->_pszRealm = NULL;
    }

    fResult = TRUE;

cleanup:

    if (hRequestMapped)
    {
        DereferenceObject(hRequestMapped);
    }

    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}

BOOLAPI 
WinHttpSetCredentials(
    
    IN HINTERNET   hRequest,        // HINTERNET handle returned by HttpOpenRequest.   
    
    
    IN DWORD       AuthTargets,      // Only WINHTTP_AUTH_TARGET_SERVER and 
                                    // WINHTTP_AUTH_TARGET_PROXY are supported
                                    // in this version and they are mutually 
                                    // exclusive 
    
    IN DWORD       AuthScheme,      // must be one of the supported Auth Schemes 
                                    // returned from HttpQueryAuthSchemes(), Apps 
                                    // should use the Preferred Scheme returned
    
    IN LPCWSTR     pwszUserName,     // 1) NULL if default creds is to be used, in 
                                    // which case pszPassword will be ignored
    
    IN LPCWSTR     pwszPassword,     // 1) "" == Blank Passowrd; 2)Parameter ignored 
                                    // if pszUserName is NULL; 3) Invalid to pass in 
                                    // NULL if pszUserName is not NULL
    IN LPVOID      pAuthParams
   
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetCredentials",
                     "%#x, %#x, %#x, %wq, %wq, %wq",
                     hRequest,
                     AuthTargets,
                     AuthScheme,
                     pAuthParams,
                     pwszUserName ? L"<username>" : L"NULL",
                     pwszPassword ? L"<password>" : L"NULL"
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    LPCWSTR pwszRealm = NULL;
    MEMORYPACKET mpRealm, mpUserName, mpPassword;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    // make sure only one bit in AuthScheme is set
    if ((AuthScheme & (AuthScheme - 1)) != 0x00000000)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure the input strings are valid
    if (pwszUserName 
        && ::IsBadStringPtrW(pwszUserName, (UINT_PTR)-1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pwszPassword 
        && ::IsBadStringPtrW(pwszPassword, (UINT_PTR)-1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if ((AuthScheme == WINHTTP_AUTH_SCHEME_DIGEST) && pAuthParams)
    {
        pwszRealm = (LPCWSTR)pAuthParams;
    }
    if (pwszRealm 
        && ::IsBadStringPtrW(pwszRealm, (UINT_PTR)-1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // make sure AuthTargets are either Server or Proxy (not both)
    if ((AuthTargets != WINHTTP_AUTH_TARGET_SERVER) 
        && (AuthTargets != WINHTTP_AUTH_TARGET_PROXY))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    // convert Unicode strings to Ansi
    
    if (pwszUserName)
    {
        ALLOC_MB(pwszUserName, 0, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszUserName, mpUserName);
    }
    if (pwszPassword)
    {
        ALLOC_MB(pwszPassword, 0, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszPassword, mpPassword);
    }
    if (pwszRealm)
    {
        ALLOC_MB(pwszRealm, 0, mpRealm);
        if (!mpRealm.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pwszRealm, mpRealm);
    }

    fResult = ::WinHttpSetCredentialsA(hRequest, AuthTargets,
                                       AuthScheme, mpUserName.psStr, mpPassword.psStr, mpRealm.psStr);

cleanup:
    ZERO_MEMORY_ALLOC(mpUserName);
    ZERO_MEMORY_ALLOC(mpPassword);
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        ::SetLastError(dwErr); 
        DEBUG_ERROR(HTTP, dwErr);
    }
    
    DEBUG_LEAVE_API(fResult);
    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\inetapiu.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    inetapiu.cxx

Abstract:

    Contains WinInet API utility & sub-API functions

    Contents:
        wInternetQueryDataAvailable

Author:

    Richard L Firth (rfirth) 16-Feb-1996

Environment:

    Win32 user-level

Revision History:

    16-Feb-1996 rfirth
        Created

--*/

#include <wininetp.h>

//
// functions
//


BOOL
wInternetQueryDataAvailable(
    IN LPVOID hFileMapped,
    OUT LPDWORD lpdwNumberOfBytesAvailable,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Part 2 of InternetQueryDataAvailabe. This function is called by the async
    worker thread in order to resume InternetQueryDataAvailable(), and by the
    app as the worker part of the API, post validation

    We can query available data for handle types that return data, either from
    a socket, or from a cache file:

        - HTTP request
        - FTP file
        - FTP find
        - FTP find HTML
        - gopher file
        - gopher find
        - gopher find HTML

Arguments:

    hFileMapped                 - the mapped HINTERNET

    lpdwNumberOfBytesAvailable  - where the number of bytes is returned

    dwFlags                     - flags controlling operation

    dwContext                   - context value for callbacks

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwContext);
    DEBUG_ENTER((DBG_INET,
                Bool,
                "wInternetQueryDataAvailable",
                "%#x, %#x, %#x, %#x",
                hFileMapped,
                lpdwNumberOfBytesAvailable,
                dwFlags,
                dwContext
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error;
    DWORD bytesAvailable = 0;


    INET_ASSERT(hFileMapped);

    //
    // as usual, grab the per-thread info block
    //

    if (lpThreadInfo == NULL) {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // if this is the async worker thread then set the handle, and
    // last-error info in the per-thread data block before we go any further
    // (we already did this on the sync path)
    //

    if (lpThreadInfo->IsAsyncWorkerThread) {
        _InternetSetObjectHandle(lpThreadInfo,
                                 ((HANDLE_OBJECT *)hFileMapped)->GetPseudoHandle(),
                                 hFileMapped
                                 );
        _InternetClearLastError(lpThreadInfo);

        //
        // we should only be here in async mode if there was no data immediately
        // available
        //

        INET_ASSERT(!((INTERNET_HANDLE_OBJECT *)hFileMapped)->IsDataAvailable());

    }

    //
    // we copy the number of bytes available to a local variable first, and
    // only update the caller's variable if we succeed
    //
    //
    // get the current data available
    //

    error = ((HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped)
                ->QueryDataAvailable(&bytesAvailable);

quit:

    BOOL success;

    if (error == ERROR_SUCCESS) {
        ((INTERNET_HANDLE_OBJECT *)hFileMapped)->SetAvailableDataLength(bytesAvailable);
        *lpdwNumberOfBytesAvailable = bytesAvailable;
        success = TRUE;

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    bytesAvailable
                    ));

        DEBUG_PRINT_API(API,
                        INFO,
                        ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                        lpdwNumberOfBytesAvailable,
                        bytesAvailable
                        ));

    } else {
        success = FALSE;

        DEBUG_ERROR(INET, error);

    }

    SetLastError(error);

    DEBUG_LEAVE(success);

    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\inetapia.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapia.cxx

Abstract:

    Contains the ANSI and character-mode-independent Internet APIs

    Contents:
        WinHttpCloseHandle
        WinHttpReadData
        WinHttpWriteData
        WinHttpQueryDataAvailable
        
    
        WinHttpCrackUrlA
        WinHttpCreateUrlA
        InternetCanonicalizeUrlA
        InternetCombineUrlA
        InternetOpenA
        _InternetCloseHandle
        _InternetCloseHandleNoContext
        InternetConnectA
        InternetOpenUrlA
        ReadFile_End
        InternetQueryOptionA
        InternetSetOptionA
        InternetGetLastResponseInfoA
        (wInternetCloseConnectA)
        (CreateDeleteSocket)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana


--*/


#include <wininetp.h>
#include <perfdiag.hxx>

//  because wininet doesnt know IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>


//
// private manifests
//

//
// private prototypes
//

PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    );

PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    );

PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    );

PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    );


PRIVATE
DWORD
wInternetCloseConnectA(
    IN HINTERNET lpConnectHandle,
    IN DWORD ServiceType
    );

PRIVATE
BOOL
InternetParseCommon(
    IN LPCTSTR lpszBaseUrl,
    IN LPCTSTR lpszRelativeUrl,
    OUT LPTSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );


//
// WinHttpCrackUrlA
//


BOOL winHttpCrackUrlAVerifyStringBuffer( LPSTR szStr, DWORD dwStrSize, DWORD dwFlags)
{

    if (szStr == NULL 
        && dwStrSize != 0
        && (dwFlags & (ICU_DECODE | ICU_ESCAPE)))
    {
        return FALSE;
    }
    else
        return TRUE;
}


DWORD winHttpCrackUrlACopyResultToBuffer( LPSTR szResult, DWORD dwResultLength,
                                          LPSTR* pszBuffer, DWORD* pdwBufferSize,
                                          DWORD dwSchemeType, BOOL fDecode, BOOL fEscape, BOOL* pfCopyFailure)
{
    DWORD dwError = ERROR_WINHTTP_INTERNAL_ERROR;
    LPSTR szAlloc = NULL;
    
    if (*pszBuffer != NULL 
        && *pdwBufferSize > dwResultLength+1
        && szResult != NULL
        && szResult[0] != '\0')
    {
        memcpy(*pszBuffer, szResult, dwResultLength);
        
        (*pszBuffer)[dwResultLength] = '\0';

        if (fDecode)
        {
            HRESULT hr = UrlUnescapeInPlace((*pszBuffer), 0);
            if (FAILED(hr))
            {
                dwError = HRESULT_CODE(hr);
                goto quit;
            }
        }

        if (fEscape)
        {
            DWORD dwAllocSize = (*pdwBufferSize);
            szAlloc = (LPSTR)ALLOCATE_MEMORY(dwAllocSize);
            if(szAlloc == NULL)
            {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }

            dwError = EncodeUrlPath(0, dwSchemeType, 
                                  (*pszBuffer), strlen((*pszBuffer)) + 1, 
                                  &szAlloc, &dwAllocSize);

            //  dwAllocSize was the size of the buffer going in,
            //but after calling EncodeUrlPath it is now the length (without '\0')
            //of the result.

            if(dwError != ERROR_SUCCESS)
                goto quit;
                                  
            if(dwAllocSize + 1 <= (*pdwBufferSize))
            {
                memcpy((*pszBuffer), szAlloc, dwAllocSize+1);
                (*pdwBufferSize) = dwAllocSize;  // if we had enough space, return length not including '\0'
            }
            else
            {
                (*pszBuffer)[0] = '\0';
                (*pdwBufferSize) = dwAllocSize+1;
                *pfCopyFailure = TRUE;  // if we didn't have enough space, ask for enough to include '\0'
            }
        }
        else
        {
            (*pdwBufferSize) = strlen((*pszBuffer));
        }
    } 
    else if (*pszBuffer != NULL)
    {
        //  If there wasn't room for the copy, return an empty string
        //with the size parameter returning a sufficient size to store
        //the full result.
        (*pszBuffer)[0] = '\0';

        if (dwResultLength > 0)
        {
            DWORD dwPossibleExpansion = fEscape ? 3 : 1;
            (*pdwBufferSize) = dwResultLength * dwPossibleExpansion + 1;
            *pfCopyFailure = TRUE;
        }
        else
        {
            *pdwBufferSize = 0;
        }
    }        
    else if ((*pdwBufferSize) != 0)
    {
        //  *pswBuffer == NULL && *pdwBufferSize != 0 indicates
        //user wants a pointer to the result in the original string.  This
        //also indicates WinHttpCrackUrlA called CrackUrl on the
        //original string.
        *pszBuffer = szResult;
        *pdwBufferSize = dwResultLength;
    }

    dwError = ERROR_SUCCESS;
quit:
    if (szAlloc != NULL)
        DEL_STRING(szAlloc);
    
    return dwError;
}
    


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrlA(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN LPURL_COMPONENTSA lpUrlComponents
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    lpszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if lpszUrl is ASCIIZ string, else length of lpszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrlA",
                     "%q, %#x, %#x, %#x",
                     lpszUrl,
                     dwUrlLength,
                     dwFlags,
                     lpUrlComponents
                     ));

    DWORD error;

    LPSTR lpUrl;
    LPSTR urlCopy = NULL;
    //
    // validate parameters
    //
    if (!dwUrlLength)
        dwUrlLength = lstrlen(lpszUrl);

    if (!winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszScheme, lpUrlComponents->dwSchemeLength, dwFlags)
        || !winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszHostName, lpUrlComponents->dwHostNameLength, dwFlags)
        || !winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszUserName, lpUrlComponents->dwUserNameLength, dwFlags)
        || !winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszPassword, lpUrlComponents->dwPasswordLength, dwFlags)
        || !winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszUrlPath, lpUrlComponents->dwUrlPathLength, dwFlags)
        || !winHttpCrackUrlAVerifyStringBuffer(lpUrlComponents->lpszExtraInfo, lpUrlComponents->dwExtraInfoLength, dwFlags))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }
   
    //
    //  Below are variables to be used as out params with CrackUrl()
    //

    LPSTR schemeName = NULL;
    DWORD schemeNameLength = 0;
    LPSTR hostName = NULL;
    DWORD hostNameLength = 0;
    LPSTR userName = NULL;
    DWORD userNameLength = 0;
    LPSTR password = NULL;
    DWORD passwordLength = 0;
    LPSTR urlPath = NULL;
    DWORD urlPathLength = 0;
    LPSTR extraInfo = NULL;
    DWORD extraInfoLength = 0;

    INTERNET_SCHEME schemeType;
    INTERNET_PORT nPort;
    BOOL havePort;
    
    //
    //  If we're escaping or decoding, create a separate work buffer
    //because we can't do it in place.
    //
    if (dwFlags & (ICU_ESCAPE | ICU_DECODE))
    {
        //
        // create a copy of the URL. CrackUrl() will modify this in situ. We
        // need to copy the results back to the user's buffer(s)
        //

        urlCopy = NewString((LPSTR)lpszUrl, dwUrlLength);
        if (urlCopy == NULL)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }
        lpUrl = urlCopy;
    }
    else
    {
        lpUrl = (LPSTR)lpszUrl;
        urlCopy = NULL;
    }

    //
    // crack the URL into its constituent parts
    //

    error = CrackUrl(lpUrl,
                     dwUrlLength,
                     FALSE,
                     &schemeType,
                     &schemeName,
                     &schemeNameLength,
                     &hostName,
                     &hostNameLength,
                     FALSE,
                     &nPort,
                     &userName,
                     &userNameLength,
                     &password,
                     &passwordLength,
                     &urlPath,
                     &urlPathLength,
                     lpUrlComponents->dwExtraInfoLength ? &extraInfo : NULL,
                     lpUrlComponents->dwExtraInfoLength ? &extraInfoLength : 0,
                     &havePort
                     );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }


    //
    //  Transfer the results from CrackUrl() to lpUrlComponents
    //

    BOOL fCopyFailure;
    fCopyFailure = FALSE;

    error = winHttpCrackUrlACopyResultToBuffer(
                schemeName, schemeNameLength,
                &lpUrlComponents->lpszScheme, &lpUrlComponents->dwSchemeLength,
                schemeType, dwFlags & ICU_DECODE, FALSE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    error = winHttpCrackUrlACopyResultToBuffer(
                hostName, hostNameLength,
                &lpUrlComponents->lpszHostName, &lpUrlComponents->dwHostNameLength,
                schemeType, dwFlags & ICU_DECODE, FALSE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    error = winHttpCrackUrlACopyResultToBuffer(
                userName, userNameLength,
                &lpUrlComponents->lpszUserName, &lpUrlComponents->dwUserNameLength,
                schemeType, dwFlags & ICU_DECODE, FALSE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    error = winHttpCrackUrlACopyResultToBuffer(
                password, passwordLength,
                &lpUrlComponents->lpszPassword, &lpUrlComponents->dwPasswordLength,
                schemeType, dwFlags & ICU_DECODE, FALSE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    error = winHttpCrackUrlACopyResultToBuffer(
                urlPath, urlPathLength,
                &lpUrlComponents->lpszUrlPath, &lpUrlComponents->dwUrlPathLength,
                schemeType, dwFlags & ICU_DECODE, dwFlags & ICU_ESCAPE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    error = winHttpCrackUrlACopyResultToBuffer(
                extraInfo, extraInfoLength,
                &lpUrlComponents->lpszExtraInfo, &lpUrlComponents->dwExtraInfoLength,
                schemeType, dwFlags & ICU_DECODE, dwFlags & ICU_ESCAPE, &fCopyFailure);

    if (error != ERROR_SUCCESS)
        goto quit;
                
    //
    // we may have failed to copy one or more components because we didn't have
    // enough buffer space.
    //

    if (fCopyFailure)
    {
        error = ERROR_INSUFFICIENT_BUFFER;
    }

    //
    // copy the scheme type
    //

    lpUrlComponents->nScheme = schemeType;

    //
    // convert 0 port (not in URL) to default value for scheme
    //

    if (nPort == INTERNET_INVALID_PORT_NUMBER && !havePort) {
        switch (schemeType) {
        case INTERNET_SCHEME_HTTP:
            nPort = INTERNET_DEFAULT_HTTP_PORT;
            break;

        case INTERNET_SCHEME_HTTPS:
            nPort = INTERNET_DEFAULT_HTTPS_PORT;
            break;
        }
    }
    lpUrlComponents->nPort = nPort;

quit:
    if (urlCopy != NULL)
    {
        DEL_STRING(urlCopy);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrlA(
    IN LPURL_COMPONENTSA lpUrlComponents,
    IN DWORD dwFlags,
    OUT LPSTR lpszUrl OPTIONAL,
    IN OUT LPDWORD lpdwUrlLength
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

    lpUrlComponents - pointer to URL_COMPONENTS structure containing pointers
                      and lengths of components of interest

    dwFlags         - flags controlling function:

                        ICU_ESCAPE  - the components contain characters that
                                      must be escaped in the output URL

    lpszUrl         - pointer to buffer where output URL will be written

    lpdwUrlLength   - IN: number of bytes in lpszUrl buffer
                      OUT: if success, number of characters in lpszUrl, else
                           number of bytes required for buffer

Return Value:

    BOOL
        Success - URL written to lpszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrlA",
                     "%#x, %#x, %#x, %#x",
                     lpUrlComponents,
                     dwFlags,
                     lpszUrl,
                     lpdwUrlLength
                     ));

#if INET_DEBUG

    LPSTR lpszUrlOriginal = lpszUrl;

#endif

    DWORD error = ERROR_SUCCESS;
    LPSTR encodedUrlPath = NULL;
    LPSTR encodedExtraInfo = NULL;

    //
    // validate parameters
    //

    if (!ARGUMENT_PRESENT(lpszUrl)) {
        *lpdwUrlLength = 0;
    }

    //
    // allocate large buffers from heap
    //

    encodedUrlPath = (LPSTR)ALLOCATE_MEMORY(INTERNET_MAX_URL_LENGTH + 1);
    encodedExtraInfo = (LPSTR)ALLOCATE_MEMORY(INTERNET_MAX_URL_LENGTH + 1);
    if ((encodedUrlPath == NULL) || (encodedExtraInfo == NULL)) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    //
    // if we get an exception, we return ERROR_INVALID_PARAMETER
    //
    
    __try {

        //
        // get the individual components to copy
        //

        LPSTR schemeName;
        DWORD schemeNameLength;
        DWORD schemeFlags;
        LPSTR hostName;
        DWORD hostNameLength;
        BOOL  bracketsNeeded;
        INTERNET_PORT nPort = 0;
        DWORD portLength;
        LPSTR userName;
        DWORD userNameLength;
        LPSTR password;
        DWORD passwordLength;
        LPSTR urlPath;
        DWORD urlPathLength;
        DWORD extraLength;
        DWORD encodedUrlPathLength;
        LPSTR extraInfo = NULL;
        DWORD extraInfoLength = 0;
        DWORD encodedExtraInfoLength;
        LPSTR schemeSep;
        DWORD schemeSepLength;
        INTERNET_SCHEME schemeType;
        INTERNET_PORT defaultPort;

        //
        // if the scheme name is absent then we use the default
        //

        schemeName = lpUrlComponents->lpszScheme;
        schemeType = lpUrlComponents->nScheme;

        if (schemeName == NULL) {
            if (schemeType == INTERNET_SCHEME_DEFAULT){
                schemeName = DEFAULT_URL_SCHEME_NAME;
                schemeNameLength = sizeof(DEFAULT_URL_SCHEME_NAME) - 1;
            }
            else {
                schemeName = MapUrlScheme(schemeType, &schemeNameLength);
            }
        } else {
            schemeNameLength = lpUrlComponents->dwSchemeLength;
            if (schemeNameLength == 0) {
                schemeNameLength = lstrlen(schemeName);
            }
        }

        if (schemeNameLength == 0)
        {
            error = ERROR_INVALID_PARAMETER;
            goto quit;
        }
        

        //
        // doesn't have to be a host name
        //

        hostName = lpUrlComponents->lpszHostName;
        portLength = 0;
        if (hostName != NULL) {
            hostNameLength = lpUrlComponents->dwHostNameLength;
            if (hostNameLength == 0) {
                hostNameLength = lstrlen(hostName);
            }

            //
            // If a hostname was supplied and it contains at least two colons then
            // it will be assumed to be an IPv6 literal address.  To comply with RFC 2732 
            // it will need square brackets around it when we construct the URL string.
            //
            DWORD colonCount, index;
            bracketsNeeded = FALSE;
            for (colonCount = 0, index = 0; index < hostNameLength; index++) {
                if (hostName[index] == ':') {
                    colonCount++;
                }
                if (colonCount > 1) {
                    bracketsNeeded = TRUE;
                    break;
                }
            }
            
            // Don't add square brackets to IPv6 literal if they are already there.
            
            if (bracketsNeeded && (hostName[0] == '[') && (hostName[hostNameLength-1] == ']')) {
                    bracketsNeeded = FALSE;
            }
            
        //
        // if the port is default then we don't add it to the URL, else we need to
        // copy it as a string
        //
        // there won't be a port unless there's host.

            schemeType = MapUrlSchemeName(schemeName, schemeNameLength ? schemeNameLength : -1);
            switch (schemeType) {
            case INTERNET_SCHEME_HTTP:
                defaultPort = INTERNET_DEFAULT_HTTP_PORT;
                break;

            case INTERNET_SCHEME_HTTPS:
                defaultPort = INTERNET_DEFAULT_HTTPS_PORT;
                break;

            default:
                defaultPort = INTERNET_INVALID_PORT_NUMBER;
                break;
            }

            if (lpUrlComponents->nPort != defaultPort) {

                INTERNET_PORT divisor;

                nPort = lpUrlComponents->nPort;
                if (nPort) {
                    divisor = 10000;
                    portLength = 6; // max is 5 characters, plus 1 for ':'
                    while ((nPort / divisor) == 0) {
                        --portLength;
                        divisor /= 10;
                    }
                } else {
                    portLength = 2;         // port is ":0"
                }
            }
        } else {
            hostNameLength = 0;
            bracketsNeeded = FALSE;
        }


        //
        // doesn't have to be a user name
        //

        userName = lpUrlComponents->lpszUserName;
        if (userName != NULL) {
            userNameLength = lpUrlComponents->dwUserNameLength;
            if (userNameLength == 0) {
                userNameLength = lstrlen(userName);
            }
        } else {

            userNameLength = 0;
        }

        //
        // doesn't have to be a password
        //

        password = lpUrlComponents->lpszPassword;
        if (password != NULL) {
            passwordLength = lpUrlComponents->dwPasswordLength;
            if (passwordLength == 0) {
                passwordLength = lstrlen(password);
            }
        } else {

            passwordLength = 0;
        }

        //
        // but if there's a password without a user name, then its an error
        //

        if (password && !userName) {
            error = ERROR_INVALID_PARAMETER;
        } else {

            //
            // determine the scheme type for possible uses below
            //

            schemeFlags = 0;
            if (strnicmp(schemeName, "http", schemeNameLength) == 0) {
                schemeFlags = SCHEME_HTTP;
            } else if (strnicmp(schemeName, "ftp", schemeNameLength) == 0) {
                schemeFlags = SCHEME_FTP;
            } else if (strnicmp(schemeName, "gopher", schemeNameLength) == 0) {
                schemeFlags = SCHEME_GOPHER;
            }

            //
            // doesn't have to be an URL-path. Empty string is default
            //

            urlPath = lpUrlComponents->lpszUrlPath;
            if (urlPath != NULL) {
                urlPathLength = lpUrlComponents->dwUrlPathLength;
                if (urlPathLength == 0) {
                    urlPathLength = lstrlen(urlPath);
                }
                if ((*urlPath != '/') && (*urlPath != '\\')) {
                    extraLength = 1;
                } else {
                    extraLength = 0;
                }

                //
                // if requested, we will encode the URL-path
                //

                if (dwFlags & ICU_ESCAPE) {

                    //
                    // only encode the URL-path if it's a recognized scheme
                    //

                    if (schemeFlags != 0) {
                        encodedUrlPathLength = INTERNET_MAX_URL_LENGTH + 1;
                        error = EncodeUrlPath(NO_ENCODE_PATH_SEP,
                                              schemeFlags,
                                              urlPath,
                                              urlPathLength,
                                              &encodedUrlPath,
                                              &encodedUrlPathLength
                                              );
                        if (error == ERROR_SUCCESS) {
                            urlPath = encodedUrlPath;
                            urlPathLength = encodedUrlPathLength;
                        }
                    }
                }
            } else {
                urlPathLength = 0;
                extraLength = 0;
            }

            //
            // handle extra info if present
            //

            if (error == ERROR_SUCCESS) {
                extraInfo = lpUrlComponents->lpszExtraInfo;
                if (extraInfo != NULL) {
                    extraInfoLength = lpUrlComponents->dwExtraInfoLength;
                    if (extraInfoLength == 0) {
                        extraInfoLength = lstrlen(extraInfo);
                    }

                    //
                    // if requested, we will encode the extra info
                    //

                    if (dwFlags & ICU_ESCAPE) {

                        //
                        // only encode the extra info if it's a recognized scheme
                        //

                        if (schemeFlags != 0) {
                            encodedExtraInfoLength = INTERNET_MAX_URL_LENGTH + 1;
                            error = EncodeUrlPath(0,
                                                  schemeFlags,
                                                  extraInfo,
                                                  extraInfoLength,
                                                  &encodedExtraInfo,
                                                  &encodedExtraInfoLength
                                                  );
                            if (error == ERROR_SUCCESS) {
                                extraInfo = encodedExtraInfo;
                                extraInfoLength = encodedExtraInfoLength;
                            }
                        }
                    }
                } else {
                    extraInfoLength = 0;
                }
            }

            DWORD requiredSize = 0;

            if (error == ERROR_SUCCESS) {

                //
                // Determine if we have a protocol scheme that requires slashes
                //

                if (DoesSchemeRequireSlashes(schemeName, schemeNameLength, (hostName != NULL))) {
                    schemeSep = "://";
                    schemeSepLength = sizeof("://") - 1;
                } else {
                    schemeSep = ":";
                    schemeSepLength = sizeof(":") - 1;
                }

                //
                // ensure we have enough buffer space
                //

                requiredSize = schemeNameLength
                             + schemeSepLength
                             + hostNameLength
                             + (bracketsNeeded ? 2 : 0)
                             + portLength
                             + (userName ? userNameLength + 1 : 0) // +1 for '@'
                             + (password ? passwordLength + 1 : 0) // +1 for ':'
                             + urlPathLength
                             + extraLength
                             + extraInfoLength
                             + 1                                // +1 for '\0'
                             ;

                //
                // if there is enough buffer, copy the URL
                //

                if (*lpdwUrlLength >= requiredSize) {
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeName, schemeNameLength);
                    lpszUrl += schemeNameLength;
                    memcpy((LPVOID)lpszUrl, (LPVOID)schemeSep, schemeSepLength);
                    lpszUrl += schemeSepLength;
                    if (userName) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)userName, userNameLength);
                        lpszUrl += userNameLength;
                        if (password) {
                            *lpszUrl++ = ':';
                            memcpy((LPVOID)lpszUrl, (LPVOID)password, passwordLength);
                            lpszUrl += passwordLength;
                        }
                        *lpszUrl++ = '@';
                    }
                    if (hostName) {
                        if (bracketsNeeded)
                            *lpszUrl++ = '[';
                        memcpy((LPVOID)lpszUrl, (LPVOID)hostName, hostNameLength);
                        lpszUrl += hostNameLength;
                        if (bracketsNeeded)
                            *lpszUrl++ = ']';
                        // We won't attach a port unless there's a host to go with it.
                        if (portLength) {
                            lpszUrl += wsprintf(lpszUrl, ":%d", nPort & 0xffff);
                        }

                    }
                    if (urlPath) {

                        //
                        // Only do extraLength if we've actually copied something
                        // after the scheme.
                        //

                        if (extraLength != 0 && (userName || hostName || portLength)) {
                            *lpszUrl++ = '/';
                        } else if (extraLength != 0) {
                            --requiredSize;
                        }
                        memcpy((LPVOID)lpszUrl, (LPVOID)urlPath, urlPathLength);
                        lpszUrl += urlPathLength;
                    } else if (extraLength != 0) {
                        --requiredSize;
                    }
                    if (extraInfo) {
                        memcpy((LPVOID)lpszUrl, (LPVOID)extraInfo, extraInfoLength);
                        lpszUrl += extraInfoLength;
                    }

                    //
                    // terminate string
                    //

                    *lpszUrl = '\0';

                    //
                    // -1 for terminating '\0'
                    //

                    --requiredSize;
                } else {

                    //
                    // not enough buffer space - just return the required buffer length
                    //

                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            }

            //
            // update returned parameters
            //

            *lpdwUrlLength = requiredSize;
        }
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        error = ERROR_INVALID_PARAMETER;
    }
    ENDEXCEPT
quit:

    //
    // clear up the buffers we allocated
    //


    if (encodedUrlPath != NULL) {
        FREE_MEMORY(encodedUrlPath);
    }
    if (encodedExtraInfo != NULL) {
        FREE_MEMORY(encodedExtraInfo);
    }

    BOOL success = (error==ERROR_SUCCESS);

    if (success) {

        DEBUG_PRINT_API(API,
                        INFO,
                        ("URL = %q\n",
                        lpszUrlOriginal
                        ));
    } else {

        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);
    return success;
}

//
//  ICUHrToWin32Error() is specifically for converting the return codes for
//  Url* APIs in shlwapi into win32 errors.
//  WARNING:  it should not be used for any other purpose.
//
DWORD
ICUHrToWin32Error(HRESULT hr)
{
    DWORD err = ERROR_INVALID_PARAMETER;
    switch(hr)
    {
    case E_OUTOFMEMORY:
        err = ERROR_NOT_ENOUGH_MEMORY;
        break;

    case E_POINTER:
        err = ERROR_INSUFFICIENT_BUFFER;
        break;

    case S_OK:
        err = ERROR_SUCCESS;
        break;

    default:
        break;
    }
    return err;
}


INTERNETAPI
BOOL
WINAPI
InternetCanonicalizeUrlA(
    IN LPCSTR lpszUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszUrl             - pointer to URL to be canonicalize
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetCanonicalizeUrlA",
                     "%q, %#x, %#x [%d], %#x",
                     lpszUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet = TRUE;;

    INET_ASSERT(lpszUrl);
    INET_ASSERT(lpszBuffer);
    INET_ASSERT(lpdwBufferLength && (*lpdwBufferLength > 0));

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszUrl || !lpszBuffer || !lpdwBufferLength || *lpdwBufferLength == 0 || IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCanonicalizeA(lpszUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }

    DEBUG_LEAVE(bRet);

    return bRet;
}


INTERNETAPI
BOOL
WINAPI
InternetCombineUrlA(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Combines a relative URL with a base URL to form a new full URL.

Arguments:

    lpszBaseUrl         - pointer to base URL
    lpszRelativeUrl     - pointer to relative URL
    lpszBuffer          - pointer to buffer where new URL is written
    lpdwBufferLength    - size of buffer on entry, length of new URL on exit
    dwFlags             - flags controlling operation

Return Value:

    BOOL                - TRUE if successful, FALSE if not

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetCombineUrlA",
                     "%q, %q, %#x, %#x [%d], %#x",
                     lpszBaseUrl,
                     lpszRelativeUrl,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0,
                     dwFlags
                     ));

    HRESULT hr ;
    BOOL bRet;

    INET_ASSERT(lpszBaseUrl);
    INET_ASSERT(lpszRelativeUrl);
    INET_ASSERT(lpdwBufferLength);

    //
    //  the flags for the Url* APIs in shlwapi should be the same
    //  except that NO_ENCODE is on by default.  so we need to flip it
    //
    dwFlags ^= ICU_NO_ENCODE;

    // Check for invalid parameters

    if (!lpszBaseUrl || !lpszRelativeUrl || !lpdwBufferLength || (lpszBuffer && IsBadWritePtr(lpszBuffer, *lpdwBufferLength*sizeof(CHAR))))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = UrlCombineA(lpszBaseUrl, lpszRelativeUrl, lpszBuffer,
                    lpdwBufferLength, dwFlags | URL_WININET_COMPATIBILITY);
    }

    if(FAILED(hr))
    {
        DWORD dw = ICUHrToWin32Error(hr);

        bRet = FALSE;

        DEBUG_ERROR(API, dw);

        SetLastError(dw);
    }
    else
        bRet = TRUE;

    IF_DEBUG_CODE() {
        if (bRet) {
            DEBUG_PRINT_API(API,
                            INFO,
                            ("URL = %q\n",
                            lpszBuffer
                            ));
        }
    }

    DEBUG_LEAVE(bRet);

    return bRet;
}


INTERNETAPI
HINTERNET
WINAPI
InternetOpenA(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    Opens a root Internet handle from which all HINTERNET objects are derived

Arguments:

    lpszAgent       - name of the application making the request (arbitrary
                      identifying string). Used in "User-Agent" header when
                      communicating with HTTP servers, if the application does
                      not add a User-Agent header of its own

    dwAccessType    - type of access required. Can be

                        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
                            - Gets the configuration from the registry

                        WINHTTP_ACCESS_TYPE_NO_PROXY
                            - Requests are made directly to the nominated server

                        WINHTTP_ACCESS_TYPE_NAMED_PROXY
                            - Requests are made via the nominated proxy


    lpszProxy       - if INTERNET_OPEN_TYPE_PROXY, a list of proxy servers to
                      use

    lpszProxyBypass - if INTERNET_OPEN_TYPE_PROXY, a list of servers which we
                      will communicate with directly

    dwFlags         - flags to control the operation of this API or potentially
                      all APIs called on the handle generated by this API.
                      Currently supported are:

                        WINHTTP_FLAG_ASYNC - Not supported in WinHttpX v6.


Return Value:

    HINTERNET
        Success - handle of Internet object

        Failure - NULL. For more information, call GetLastError()

--*/

{
    PERF_INIT();

    DEBUG_ENTER((DBG_API,
                     Handle,
                     "InternetOpenA",
                     "%q, %s (%d), %q, %q, %#x",
                     lpszAgent,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     lpszProxy,
                     lpszProxyBypass,
                     dwFlags
                     ));

    DWORD error;
    HINTERNET hInternet = NULL;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    //
    // validate parameters
    //

    if (!(   (dwAccessType == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY)
          || (dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
          || (   (dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
              && (ARGUMENT_PRESENT(lpszProxy))
              && (*lpszProxy != '\0'))))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if( 0 != (dwFlags & ~WINHTTP_OPEN_FLAGS_MASK))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }


    INTERNET_HANDLE_OBJECT * lpInternet;

    lpInternet = New INTERNET_HANDLE_OBJECT(lpszAgent,
                                            dwAccessType,
                                            (LPSTR)lpszProxy,
                                            (LPSTR)lpszProxyBypass,
                                            dwFlags
                                            );
    if (lpInternet == NULL) {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }
    error = lpInternet->GetStatus();
    if (error == ERROR_SUCCESS) {
        hInternet = (HINTERNET)lpInternet;

        //
        // success - don't return the object address, return the pseudo-handle
        // value we generated
        //

        hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        
    } else {

        //
        // hack fix to stop InternetIndicateStatus (called from the handle
        // object destructor) blowing up if there is no handle object in the
        // thread info block. We can't call back anyway
        //

        LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

        if (lpThreadInfo) {

            //
            // BUGBUG - incorrect handle value
            //

            _InternetSetObjectHandle(lpThreadInfo, lpInternet, lpInternet);
        }

        //
        // we failed during initialization. Kill the handle using Dereference()
        // (in order to stop the debug version complaining about the reference
        // count not being 0. Invalidate for same reason)
        //

        lpInternet->Invalidate();
        lpInternet->Dereference();

        INET_ASSERT(hInternet == NULL);

    }

quit:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
    }

    DEBUG_LEAVE(hInternet);

    return hInternet;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Closes any open internet handle object

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCloseHandle",
                     "%#x",
                     hInternet
                     ));

    PERF_ENTER(InternetCloseHandle);

    DWORD error;
    BOOL success = FALSE;
    HINTERNET hInternetMapped = NULL;

    INTERNET_THREAD_INFO    LocalThreadInfoOnStack;
    LPINTERNET_THREAD_INFO  lpThreadInfo = NULL;


    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();

    // If allocation of the thread info object failed, then
    // use a threadinfo object preallocated on our stack.
    if (!lpThreadInfo)
    {
        lpThreadInfo = InternetCreateThreadInfo(TRUE, &LocalThreadInfoOnStack);
        INET_ASSERT(lpThreadInfo->fStaticAllocation);
    }


    //
    // map the handle. Don't invalidate it (_InternetCloseHandle() does this)
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped == NULL) {

            //
            // the handle never existed or has been completely destroyed
            //

            DEBUG_PRINT(API,
                        ERROR,
                        ("Handle %#x is invalid\n",
                        hInternet
                        ));

            //
            // catch invalid handles - may help caller
            //

            DEBUG_BREAK(INVALID_HANDLES);

        } else {

            //
            // this handle is already being closed (it's invalidated). We only
            // need one InternetCloseHandle() operation to invalidate the handle.
            // All other threads will simply dereference the handle, and
            // eventually it will be destroyed
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }
        goto quit;
    }

    //
    // the handle is not invalidated
    //

    HANDLE_OBJECT * pHandle;

    pHandle = (HANDLE_OBJECT *)hInternetMapped;

    DEBUG_PRINT(INET,
                INFO,
                ("handle %#x == %#x == %s\n",
                hInternet,
                hInternetMapped,
                InternetMapHandleType(pHandle->GetHandleType())
                ));

    //
    // clear the handle object last error variables
    //

    InternetClearLastError();

    //
    // decrement session count here rather than in destructor, since 
    // the session is ref-counted and there may still be outstanding
    // references from request/connect handles on async fsms.
    //
    if (pHandle->GetHandleType() == TypeInternetHandle)
    {
        InterlockedDecrement(&g_cSessionCount);
    }

    //
    // remove the reference added by MapHandleToAddress(), or the handle won't
    // be destroyed by _InternetCloseHandle()
    //

    DereferenceObject((LPVOID)hInternetMapped);

    //
    // use _InternetCloseHandle() to do the work
    //

    success = _InternetCloseHandle(hInternet);

quit:

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(InternetCloseHandle);

    //
    // If the local stack threadinfo object is in use,
    // then clear out the pointer from TLS here. So when this thread
    // detaches, the InternetDestroyThreadInfo called
    // from DLLMain(DLL_THREAD_DETACH) will have no effect--it will
    // not find a threadinfo object in TLS on this thread.
    //
    if (lpThreadInfo == &LocalThreadInfoOnStack)
    {
        InternetSetThreadInfo(NULL);
    }

    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE_API(success);

    return success;
}


BOOL
_InternetCloseHandle(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as InternetCloseHandle() except does not clear out the last error text.
    Mainly for FTP

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError()

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandle",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    BOOL success;
    HINTERNET hInternetMapped = NULL;
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo == NULL) {
        if (InDllCleanup) {
            error = ERROR_WINHTTP_SHUTDOWN;
        } else {

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
        goto quit;
    }

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_BASE *)hInternetMapped)->AbortSocket();

    //
    // we need the parent handle - we will set this as the handle object being
    // processed by this thread. This is required for async worker threads (see
    // below)
    //

    HINTERNET hParent = NULL;
    HINTERNET hParentMapped;
    DWORD_PTR dwParentContext;

    hParentMapped = ((HANDLE_OBJECT *)hInternetMapped)->GetParent();
    if (hParentMapped != NULL) {
        hParent = ((HANDLE_OBJECT *)hParentMapped)->GetPseudoHandle();
        dwParentContext = ((HANDLE_OBJECT *)hParentMapped)->GetContext();
    }

    //
    // set the object handle in the per-thread data structure
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

    //
    // now set the object to be the parent. This is necessary for e.g.
    // FtpGetFile() and async requests (where the async worker thread will make
    // an extra callback to deliver the results of the async request)
    //

    if (hParentMapped != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hParent, hParentMapped);
    }

    //
    // if the handle was still alive after dereferencing it then we will inform
    // the app that the close is pending
    //

quit:

    success = (error==ERROR_SUCCESS);
    if (!success) {
        SetLastError(error);
        DEBUG_ERROR(INET, error);
    }
    DEBUG_LEAVE(success);
    return success;
}


DWORD
_InternetCloseHandleNoContext(
    IN HINTERNET hInternet
    )

/*++

Routine Description:

    Same as _InternetCloseHandle() except does not change the per-thread info
    structure handle/context values

    BUGBUG - This should be handled via a parameter to _InternetCloseHandle(),
             but its close to shipping...

Arguments:

    hInternet   - handle of internet object to close

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INVALID_HANDLE

--*/

{
    DEBUG_ENTER((DBG_INET,
                 Bool,
                 "_InternetCloseHandleNoContext",
                 "%#x",
                 hInternet
                 ));

    DWORD error;
    HINTERNET hInternetMapped = NULL;

    //
    // map the handle and invalidate it. This will cause any new requests with
    // the handle as a parameter to fail
    //

    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, TRUE);
    if (error != ERROR_SUCCESS) {
        if (hInternetMapped != NULL) {

            //
            // the handle is already being closed, or is already deleted
            //

            DereferenceObject((LPVOID)hInternetMapped);
        }

        //
        // since this is the only function that can invalidate a handle, if we
        // are here then the handle is just waiting for its refcount to go to
        // zero. We already removed the refcount we added above, so we're in
        // the clear
        //

        goto quit;
    }

    //
    // there may be an active socket operation. We close the socket to abort the
    // operation
    //

    ((INTERNET_HANDLE_BASE *)hInternetMapped)->AbortSocket();

    //
    // at this point, there should *always* be at least 2 references on the
    // handle - one added when the object was created, and one added by
    // MapHandleToAddress() above. If the object is still alive after the 2
    // dereferences, then it will be destroyed when the current owning thread
    // dereferences it
    //

    (void)DereferenceObject((LPVOID)hInternetMapped);
    error = DereferenceObject((LPVOID)hInternetMapped);

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
HINTERNET
WINAPI
InternetConnectA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Opens a connection with a server, logging-on the user in the process.

Arguments:

    hInternet       - Internet handle, returned by InternetOpen()

    lpszServerName  - name of server with which to connect

    nServerPort     - port at which server listens

    dwFlags         - protocol-specific flags. The following are defined:
                        - INTERNET_FLAG_KEEP_CONNECTION (HTTP)
                        - WINHTTP_FLAG_SECURE (HTTP)

    dwContext       - application-supplied value used to identify this
                      request in callbacks
                    - ignored in WinHttp

Return Value:

    HINTERNET
        Success - address of a new handle object

        Failure - NULL. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER((DBG_API,
                     Handle,
                     "InternetConnectA",
                     "%#x, %q, %d, %#08x, %#x",
                     hInternet,
                     lpszServerName,
                     nServerPort,
                     dwFlags,
                     dwContext
                     ));

    HINTERNET connectHandle = NULL;
    HINTERNET hInternetMapped = NULL;

    LPINTERNET_THREAD_INFO lpThreadInfo;

    INTERNET_CONNECT_HANDLE_OBJECT * pConnect = NULL;

    BOOL isAsync;

    DWORD error = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(dwContext);

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    
    error = MapHandleToAddress(hInternet, (LPVOID *)&hInternetMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hInternetMapped == NULL)) {
        goto quit;
    }

    //
    // set the info and clear the last error info
    //

    _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle object is invalidated
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // validate the handle & discover sync/async
    //

    error = RIsHandleLocal(hInternetMapped,
                            NULL,
                            &isAsync,
                            TypeInternetHandle
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we allow all valid flags to be passed in
    //

    if ((dwFlags & ~WINHTTP_CONNECT_FLAGS_MASK)
        || (lpszServerName == NULL)
        || (*lpszServerName == '\0')) 
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // app thread or in async worker thread but being called from another
    // async API, such as InternetOpenUrl()
    //

    INET_ASSERT(connectHandle == NULL);
    INET_ASSERT(error == ERROR_SUCCESS);
        
    error = RMakeInternetConnectObjectHandle(
                hInternetMapped,
                &connectHandle,
                (LPSTR) lpszServerName,
                nServerPort,
                dwFlags
                );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // this new handle will be used in callbacks
    //

    _InternetSetObjectHandle(lpThreadInfo,
                                ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle(),
                                connectHandle
                                );

    //
    // based on whether we have been asked to perform async I/O AND we are not
    // in an async worker thread context AND the request is to connect with an
    // FTP service (currently only FTP because this request performs network
    // I/O - gopher and HTTP just allocate & fill in memory) AND there is a
    // valid context value, we will queue the async request, or execute the
    // request synchronously
    //

    pConnect = (INTERNET_CONNECT_HANDLE_OBJECT *)connectHandle;
    

    INET_ASSERT(error == ERROR_SUCCESS);

quit:

    _InternetDecNestingCount(1);


done:

    if (error == ERROR_SUCCESS) {

        //
        // success - return generated pseudo-handle
        //

        BOOL fDeleted = ((HANDLE_OBJECT *)connectHandle)->Dereference(); // release the ref claimed by the InternetConnectA() API
        if (fDeleted)
        {
            connectHandle = NULL;
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
        else
        {
            connectHandle = ((HANDLE_OBJECT *)connectHandle)->GetPseudoHandle();
        }
    }

    if (hInternetMapped != NULL) {
        DereferenceObject((LPVOID)hInternetMapped);
    }
    if (error != ERROR_SUCCESS) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }
    DEBUG_LEAVE(connectHandle);
    return connectHandle;
}



INTERNETAPI
HINTERNET
WINAPI
InternetOpenUrlA(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    // this is dead code
    UNREFERENCED_PARAMETER(hInternet);
    UNREFERENCED_PARAMETER(lpszUrl);
    UNREFERENCED_PARAMETER(lpszHeaders);
    UNREFERENCED_PARAMETER(dwHeadersLength);
    UNREFERENCED_PARAMETER(dwFlags);
    UNREFERENCED_PARAMETER(dwContext);

    return FALSE;
}



INTERNETAPI
BOOL
WINAPI
WinHttpReadData(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    )

/*++

Routine Description:

    This functions reads the next block of data from the file object.

Arguments:

    hFile                   - handle returned from Open function

    lpBuffer                - pointer to caller's buffer

    dwNumberOfBytesToRead   - size of lpBuffer in BYTEs

    lpdwNumberOfBytesRead   - returned number of bytes read into lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReadData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    HINTERNET hFileMapped = NULL;
    DWORD bytesRead = 0;
    BOOL bEndRead = TRUE;
    BOOL b2ndDeref = FALSE;
    BOOL isAsync = FALSE;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {
        INET_ASSERT(FALSE);
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_START,
                 AR_INTERNET_READ_FILE,
                 lpThreadInfo->ThreadId,
                 hFile
                 );
    }

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // validate parameters
    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (lpdwNumberOfBytesRead)
        {
            error = ProbeAndSetDword(lpdwNumberOfBytesRead, 0);
            if (error != ERROR_SUCCESS)
            {
                goto quit;
            }
        }
        error = ProbeWriteBuffer(lpBuffer, dwNumberOfBytesToRead);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // *lpdwNumberOfBytesRead = 0;

    } // end if (!lpThreadInfo->IsAsyncWorkerThread)


    INET_ASSERT(error == ERROR_SUCCESS);

    // just call the underlying API: return whatever it returns, and let it
    // handle setting the last error

    CFsm_ReadFile *pFsm;

    pFsm = New CFsm_ReadFile(lpBuffer,
                             dwNumberOfBytesToRead,
                             /*lpdwNumberOfBytesRead*/ NULL
                             );

    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;
    if (pFsm != NULL)
    {
        if (isAsync)
        {
            pRequest->Reference();
            b2ndDeref = TRUE;
        }

        error = StartFsmChain(pFsm, pRequest, FALSE, isAsync);

        //if error == ERROR_IO_PENDING, DO NOT TOUCH this fsm or any pRequest contents.
        //another async thread could be operating on this fsm.
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    bEndRead = FALSE;

    if (error == ERROR_SUCCESS)
    {
        bytesRead = pRequest->GetBytesRead();

        success = TRUE;
        goto sync_success;
    }
    else
    {
        success = FALSE;
    }
    
quit:

    _InternetDecNestingCount(nestingLevel);

    if (bEndRead)
    {
        //
        // if handleType is not HttpRequest or File then we are making this
        // request in the context of an uninterruptable async worker thread.
        // HTTP and file requests use the normal mechanism. In the case of non-
        // HTTP and file requests, we need to treat the request as if it were
        // sync and deref the handle
        //

        ReadFile_End(!lpThreadInfo->IsAsyncWorkerThread,
                     success,
                     hFileMapped,
                     bytesRead,
                     lpBuffer,
                     dwNumberOfBytesToRead,
                     lpdwNumberOfBytesRead
                     );
    }

    if (lpThreadInfo && !lpThreadInfo->IsAsyncWorkerThread)
    {
        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_READ_FILE,
                 bytesRead,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

done:

    if (b2ndDeref)
    {
        // So that we have a refcount on the object going into the callback.
        INET_ASSERT (isAsync);
        DereferenceObject((LPVOID)hFileMapped);
    }
    
    // if error is not ERROR_SUCCESS then this function returning the error,
    // otherwise the error has already been set by the API we called,
    // irrespective of the value of success
    if (error != ERROR_SUCCESS)
    {
        if (error == ERROR_IO_PENDING)
        {
            SetLastError(ERROR_SUCCESS);
            success = TRUE;
        }
        else
        {
            DEBUG_ERROR(API, error);

            SetLastError(error);
            success = FALSE;
        }
    }

    DEBUG_LEAVE_API(success);
    return success;
    
sync_success:

    if (isAsync)
    {
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_READ_COMPLETE,
                               lpBuffer,
                               bytesRead
                               );
    }

    if (lpdwNumberOfBytesRead)
    {
        *lpdwNumberOfBytesRead = bytesRead;
    }
    
    goto quit;
}


PRIVATE
VOID
ReadFile_End(
    IN BOOL bDeref,
    IN BOOL bSuccess,
    IN HINTERNET hFileMapped,
    IN DWORD dwBytesRead,
    IN LPVOID lpBuffer OPTIONAL,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead OPTIONAL
    )

/*++

Routine Description:

    Common end-of-read processing:

        - update bytes read parameter
        - dump data if logging & API data requested
        - dereference handle if not async request

Arguments:

    bDeref                  - TRUE if handle should be dereferenced (should be
                              FALSE for async request)

    bSuccess                - TRUE if Read completed successfully

    hFileMapped             - mapped file handle

    dwBytesRead             - number of bytes read

    lpBuffer                - into this buffer

    dwNumberOfBytesToRead   - originally requested bytes to read

    lpdwNumberOfBytesRead   - where bytes read is stored

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(lpBuffer);
    DEBUG_ENTER((DBG_INET,
                 None,
                 "ReadFile_End",
                 "%B, %B, %#x, %d, %#x, %d, %#x",
                 bDeref,
                 bSuccess,
                 hFileMapped,
                 dwBytesRead,
                 lpBuffer,
                 dwNumberOfBytesToRead,
                 lpdwNumberOfBytesRead
                 ));

    if (bSuccess) {

        //
        // update the amount of immediate data available only if we succeeded
        //

        ((INTERNET_HANDLE_BASE *)hFileMapped)->ReduceAvailableDataLength(dwBytesRead);

        if (lpdwNumberOfBytesRead != NULL) {
            *lpdwNumberOfBytesRead = dwBytesRead;

            DEBUG_PRINT(API,
                        INFO,
                        ("*lpdwNumberOfBytesRead = %d\n",
                        *lpdwNumberOfBytesRead
                        ));

            //
            // dump API data only if requested
            //

            IF_DEBUG_CONTROL(DUMP_API_DATA) {
                DEBUG_DUMP_API(API,
                               "Received data:\n",
                               lpBuffer,
                               *lpdwNumberOfBytesRead
                               );
            }

            /* Likely redundant:
            TRACE_DUMP_API_IF_REQUEST(API,
                           "Received data:\n",
                           lpBuffer,
                           *lpdwNumberOfBytesRead,
                            (HANDLE_OBJECT *)(hFileMapped)
                           );
           */

        }
        if (dwBytesRead < dwNumberOfBytesToRead) {

            DEBUG_PRINT(API,
                        INFO,
                        ("(!) bytes read (%d) < bytes requested (%d)\n",
                        dwBytesRead,
                        dwNumberOfBytesToRead
                        ));

        }
    }

    //
    // if async request, handle will be deref'd after REQUEST_COMPLETE callback
    // is delivered
    //

    if (bDeref && (hFileMapped != NULL)) {
        DereferenceObject((LPVOID)hFileMapped);
    }

    PERF_LOG(PE_CLIENT_REQUEST_END,
             AR_INTERNET_READ_FILE,
             dwBytesRead,
             0,
             (!bDeref && hFileMapped) ? ((INTERNET_HANDLE_BASE *)hFileMapped)->GetPseudoHandle() : NULL
             );

    DEBUG_LEAVE(0);
}




DWORD
CFsm_ReadFile::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFile::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFile * stateMachine = (CFsm_ReadFile *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFile_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFile_Fsm(
    IN CFsm_ReadFile * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFile_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFile & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }

    // the operation has gone sync, let's store the Bytes read in the request handle, otherwise we will
    // lose it as the fsm will be deleted before returning to the API call.
    HTTP_REQUEST_HANDLE_OBJECT* pRequest =
        (HTTP_REQUEST_HANDLE_OBJECT*) fsm.GetMappedHandle();

    pRequest->SetBytesRead(fsm.m_dwBytesRead);
    }
    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 fsm.m_dwBytesRead,
                 fsm.m_lpBuffer,
                 fsm.m_dwNumberOfBytesToRead,
                 fsm.m_lpdwNumberOfBytesRead
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
CFsm_ReadFileEx::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_ReadFileEx::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_ReadFileEx * stateMachine = (CFsm_ReadFileEx *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = ReadFileEx_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
ReadFileEx_Fsm(
    IN CFsm_ReadFileEx * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "ReadFileEx_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_ReadFileEx & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if ((error == ERROR_SUCCESS) && (fsm.GetState() == FSM_STATE_INIT)) {
        fsm.m_dwNumberOfBytesToRead = fsm.m_lpBuffersOut->dwBufferLength;
        error = HttpReadData(fsm.GetMappedHandle(),
                             fsm.m_lpBuffersOut->lpvBuffer,
                             fsm.m_dwNumberOfBytesToRead,
                             &fsm.m_dwBytesRead,
                             (fsm.m_dwFlags & IRF_NO_WAIT)
                               ? SF_NO_WAIT
                               : 0
                             );
        if (error == ERROR_IO_PENDING) {
            goto quit;
        }
    }

    //
    // if we are asynchronously completing a no-wait read then we don't update
    // any app parameters - we simply return the indication that we completed.
    // The app will then make another no-wait read to get the data
    //

    BOOL bNoOutput;

    bNoOutput = ((fsm.m_dwFlags & IRF_NO_WAIT)
                && fsm.GetThreadInfo()->IsAsyncWorkerThread)
                    ? TRUE
                    : FALSE;

    ReadFile_End(!fsm.GetThreadInfo()->IsAsyncWorkerThread,
                 (error == ERROR_SUCCESS) ? TRUE : FALSE,
                 fsm.GetMappedHandle(),
                 bNoOutput ? 0    : fsm.m_dwBytesRead,
                 bNoOutput ? NULL : fsm.m_lpBuffersOut->lpvBuffer,
                 bNoOutput ? 0    : fsm.m_dwNumberOfBytesToRead,
                 bNoOutput ? NULL : &fsm.m_lpBuffersOut->dwBufferLength
                 );
    fsm.SetDone();

quit:

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
WinHttpWriteData(
    IN HINTERNET hFile,
    IN LPCVOID lpBuffer,
    IN DWORD dwNumberOfBytesToWrite,
    OUT LPDWORD lpdwNumberOfBytesWritten
    )

/*++

Routine Description:

    This function write next block of data to the internet file. Currently it
    supports the following protocol data:

        HttpWriteFile

Arguments:

    hFile                       - handle that was obtained by OpenFile Call

    lpBuffer                    - pointer to the data buffer

    dwNumberOfBytesToWrite      - number of bytes in the above buffer

    lpdwNumberOfBytesWritten    -  pointer to a DWORD where the number of bytes
                                   of data actually written is returned

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpWriteData",
                     "%#x, %#x, %d, %#x",
                     hFile,
                     lpBuffer,
                     dwNumberOfBytesToWrite,
                     lpdwNumberOfBytesWritten
                     ));

    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD nestingLevel = 0;
    DWORD error;
    BOOL success = FALSE;
    BOOL fNeedDeref = TRUE;
    HINTERNET hFileMapped = NULL;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    _InternetIncNestingCount();
    nestingLevel = 1;

    error = MapHandleToAddress(hFile, (LPVOID *)&hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    //
    // set the handle, and last-error info in the per-thread data block
    // before we go any further. This allows us to return a status in the async
    // case, even if the handle has been closed
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // if MapHandleToAddress() returned a non-NULL object address, but also an
    // error status, then the handle is being closed - quit
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    // validate handle and its type
    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        goto quit;
    }

    //
    // validate parameters - write length cannot be 0
    //

    if (!lpThreadInfo->IsAsyncWorkerThread)
    {
        if (dwNumberOfBytesToWrite != 0)
        {
            error = ProbeReadBuffer((LPVOID)lpBuffer, dwNumberOfBytesToWrite);
            if (error == ERROR_SUCCESS)
            {
                if (lpdwNumberOfBytesWritten)
                {
                    error = ProbeAndSetDword(lpdwNumberOfBytesWritten, 0);
                }
            }
        }
        else
        {
            error = ERROR_INVALID_PARAMETER;
        }         

        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }


    // # 62953
    // If the authentication state of the handle is Negotiate,
    // don't submit data to the server but return success.
    // ** Added test for NTLM or Negotiate - Adriaanc.
    //
    
    HTTP_REQUEST_HANDLE_OBJECT *pRequest;
    pRequest = (HTTP_REQUEST_HANDLE_OBJECT*) hFileMapped;

    DWORD dwBytesWritten = 0;
    if (pRequest->GetAuthState() == AUTHSTATE_NEGOTIATE
        || pRequest->GetProxyTunnelingSuppressWrite())
    {
        dwBytesWritten = dwNumberOfBytesToWrite;
        error = ERROR_SUCCESS;
        success = TRUE;
        goto sync_success;
    }
        

    INET_ASSERT(error == ERROR_SUCCESS);

    CFsm_HttpWriteData *pFsm = New CFsm_HttpWriteData((LPVOID)lpBuffer,
                                                      dwNumberOfBytesToWrite,
                                                      NULL/*lpdwNumberOfBytesWritten*/,
                                                      0,
                                                      pRequest
                                                      );

    if (pFsm != NULL)
    {
        HTTP_REQUEST_HANDLE_OBJECT *pRequest2 = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

        error = StartFsmChain(pFsm, pRequest2, FALSE, isAsync);

        //if error == ERROR_IO_PENDING, DO NOT TOUCH this fsm or any pRequest contents.
        //another async thread could be operating on this fsm/request.
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Don't Derefrence if we're going pending cause the FSM will do
    //  it for us.
    //

    if ( error == ERROR_IO_PENDING )
    {
        fNeedDeref = FALSE;
    }

    if (error == ERROR_SUCCESS)
    {
        dwBytesWritten = pRequest->GetBytesWritten();
        success = TRUE;
        goto sync_success;
    }
    else
    {
        success = FALSE;
    }
    
quit:

    if (hFileMapped != NULL && fNeedDeref)
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    _InternetDecNestingCount(nestingLevel);;

done:

    if (error != ERROR_SUCCESS)
    {
        if (error == ERROR_IO_PENDING)
        {
            SetLastError(ERROR_SUCCESS);
            success = TRUE;
        }
        else
        {
            DEBUG_ERROR(API, error);
        
            SetLastError(error);
        }
    }

    DEBUG_LEAVE_API(success);

    return success;

sync_success:

    if (isAsync)
    {
        DWORD dwResult = dwBytesWritten;
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE,
                               &dwResult,
                               sizeof (DWORD)
                               );
    }

    if (lpdwNumberOfBytesWritten)
    {
        *lpdwNumberOfBytesWritten = dwBytesWritten;
    }
    
    goto quit;
}



INTERNETAPI
BOOL
WINAPI
WinHttpQueryDataAvailable(
    IN HINTERNET hFile,
    OUT LPDWORD lpdwNumberOfBytesAvailable
    )

/*++

Routine Description:

    Determines the amount of data currently available to be read on the handle

Arguments:

    hFile                       - handle of internet object

    lpdwNumberOfBytesAvailable  - pointer to returned bytes available

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryDataAvailable",
                     "%#x, %#x, %#x",
                     hFile,
                     lpdwNumberOfBytesAvailable
                     ));

    BOOL success;
    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    HINTERNET hFileMapped = NULL;
    BOOL bDeref = TRUE;
    DWORD dwNumBytes = (DWORD)-1;

    if (!GlobalDataInitialized)
    {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        bDeref = FALSE;
        goto quit;
    }

    //
    // get the per-thread info block
    //

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL)
    {

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //INET_ASSERT(lpThreadInfo->Fsm == NULL);

    PERF_LOG(PE_CLIENT_REQUEST_START,
             AR_INTERNET_QUERY_DATA_AVAILABLE,
             lpThreadInfo->ThreadId,
             hFile
             );

    //
    // validate parameters
    //

    error = MapHandleToAddress(hFile, &hFileMapped, FALSE);
    if ((error != ERROR_SUCCESS) && (hFileMapped == NULL))
    {
        goto quit;
    }

    INET_ASSERT(hFileMapped);

    //
    // set the handle values in the per-thread info block (this API
    // can't return extended error info, so we don't care about it)
    //

    _InternetSetObjectHandle(lpThreadInfo, hFile, hFileMapped);

    //
    // if the handle is invalid, quit now
    //

    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // validate rest of parameters
    //

    if (lpdwNumberOfBytesAvailable)
    {
        error = ProbeAndSetDword(lpdwNumberOfBytesAvailable, 0);
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }

    BOOL isAsync;
    error = RIsHandleLocal(hFileMapped, NULL, &isAsync, TypeHttpRequestHandle);
    if (error != ERROR_SUCCESS)
    {
        goto quit;
    }

    //
    // since the async worker thread doesn't come back through this API, the
    // following test is sufficient. Note that we only go async if there is
    // no data currently available on the handle
    //

    BOOL dataAvailable;
    dataAvailable = ((INTERNET_HANDLE_BASE *)hFileMapped)->IsDataAvailable();

    BOOL eof;
    eof = ((INTERNET_HANDLE_BASE *)hFileMapped)->IsEndOfFile();

    DWORD available;

    if (dataAvailable || eof)
    {
        available = ((INTERNET_HANDLE_BASE *)hFileMapped)->AvailableDataLength();

        DEBUG_PRINT(API,
                    INFO,
                    ("%d bytes are immediately available\n",
                    available
                    ));

        // *lpdwNumberOfBytesAvailable = available;
        success = TRUE;
        goto sync_success;
    }

    INET_ASSERT(hFileMapped);

    //
    // sync path. wInternetQueryDataAvailable will set the last error code
    // if it fails
    //

    CFsm_QueryAvailable *pFsm;

    pFsm = New CFsm_QueryAvailable(NULL/*lpdwNumberOfBytesAvailable*/,
                                   0,
                                   NULL
                                   );

    HTTP_REQUEST_HANDLE_OBJECT *pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hFileMapped;

    if (pFsm != NULL)
    {
        error = StartFsmChain(pFsm, pRequest, FALSE, isAsync);
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

    if (error == ERROR_SUCCESS)
    {
        available = pRequest->AvailableDataLength();
        success = TRUE;
        goto sync_success;
    }
    else
    {
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
        goto quit;
    }

finish:

    DEBUG_PRINT_API(API,
                    INFO,
                    ("*lpdwNumberOfBytesAvailable (%#x) = %d\n",
                    lpdwNumberOfBytesAvailable,
                    dwNumBytes
                    ));

    if (bDeref && (hFileMapped != NULL))
    {
        DereferenceObject((LPVOID)hFileMapped);
    }

    if (lpThreadInfo)
    {

        PERF_LOG(PE_CLIENT_REQUEST_END,
                 AR_INTERNET_QUERY_DATA_AVAILABLE,
                 dwNumBytes,
                 lpThreadInfo->ThreadId,
                 hFile
                 );

    }

    if (error == ERROR_IO_PENDING)
    {
        SetLastError(ERROR_SUCCESS);
        success = TRUE;
    }
    
    DEBUG_LEAVE_API(success);
    return success;

quit:

    if (error != ERROR_IO_PENDING)
    {
        DEBUG_ERROR(API, error);
    }

    SetLastError(error);
    success = FALSE;

    goto finish;

sync_success:

    dwNumBytes = available;
    
    if (isAsync)
    {
        DWORD dwResult = available;
        InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE,
                               &dwResult,
                               sizeof (DWORD)
                               );
    }

    if (lpdwNumberOfBytesAvailable)
    {
        *lpdwNumberOfBytesAvailable = available;
    }
    
    goto finish;
}


DWORD
CFsm_QueryAvailable::RunSM(
    IN CFsm * Fsm
    )
{
    DEBUG_ENTER((DBG_HTTP,
                 Dword,
                 "CFsm_QueryAvailable::RunSM",
                 "%#x",
                 Fsm
                 ));

    DWORD error;
    CFsm_QueryAvailable * stateMachine = (CFsm_QueryAvailable *)Fsm;

    switch (Fsm->GetState()) {
    case FSM_STATE_INIT:
    case FSM_STATE_CONTINUE:
        error = QueryAvailable_Fsm(stateMachine);
        break;

    case FSM_STATE_ERROR:
        error = Fsm->GetError();
        INET_ASSERT (error == ERROR_WINHTTP_OPERATION_CANCELLED);
        Fsm->SetDone();
        break;

    default:
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        Fsm->SetDone(ERROR_WINHTTP_INTERNAL_ERROR);

        INET_ASSERT(FALSE);

        break;
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
QueryAvailable_Fsm(
    IN CFsm_QueryAvailable * Fsm
    )
{
    DEBUG_ENTER((DBG_INET,
                 Dword,
                 "QueryAvailable_Fsm",
                 "%#x",
                 Fsm
                 ));

    CFsm_QueryAvailable & fsm = *Fsm;
    DWORD error = fsm.GetError();

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)fsm.GetMappedHandle();

    if (fsm.GetState() == FSM_STATE_INIT) {
        error = pRequest->QueryDataAvailable(fsm.m_lpdwNumberOfBytesAvailable);
    }
    if (error == ERROR_SUCCESS) {
        pRequest->SetAvailableDataLength(*fsm.m_lpdwNumberOfBytesAvailable);

        DEBUG_PRINT(INET,
                    INFO,
                    ("%d bytes available\n",
                    *fsm.m_lpdwNumberOfBytesAvailable
                    ));

        fsm.SetApiData(*fsm.m_lpdwNumberOfBytesAvailable);
    }

quit:

    if (error != ERROR_IO_PENDING) {
        fsm.SetDone();
    }

    DEBUG_LEAVE(error);

    return error;
}



INTERNETAPI
BOOL
WINAPI
InternetGetLastResponseInfoA(
    OUT LPDWORD lpdwErrorCategory,
    IN LPSTR lpszBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    This function returns the per-thread last internet error description text
    or server response.

    If this function is successful, *lpdwBufferLength contains the string length
    of lpszBuffer.

    If this function returns a failure indication, *lpdwBufferLength contains
    the number of BYTEs required to hold the response text

Arguments:

    lpdwErrorCategory   - pointer to DWORD location where the error catagory is
                          returned

    lpszBuffer          - pointer to buffer where the error text is returned

    lpdwBufferLength    - IN: length of lpszBuffer
                          OUT: number of characters in lpszBuffer if successful
                          else size of buffer required to hold response text

Return Value:

    BOOL
        Success - TRUE
                    lpszBuffer contains the error text. The caller must check
                    *lpdwBufferLength: if 0 then there was no text to return

        Failure - FALSE
                    Call GetLastError() for more information

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetGetLastResponseInfoA",
                     "%#x, %#x, %#x [%d]",
                     lpdwErrorCategory,
                     lpszBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength ? *lpdwBufferLength : 0
                     ));

    DWORD error;
    BOOL success;
    DWORD textLength;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    //
    // validate parameters
    //

    if (IsBadWritePtr(lpdwErrorCategory, sizeof(*lpdwErrorCategory))
    || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
    || (ARGUMENT_PRESENT(lpszBuffer)
        ? IsBadWritePtr(lpszBuffer, *lpdwBufferLength)
        : FALSE)) {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    //
    // if the buffer pointer is NULL then its the same as a zero-length buffer
    //

    if (!ARGUMENT_PRESENT(lpszBuffer)) {
        *lpdwBufferLength = 0;
    } else if (*lpdwBufferLength != 0) {
        *lpszBuffer = '\0';
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {

        DEBUG_PRINT(INET,
                    ERROR,
                    ("failed to get INTERNET_THREAD_INFO\n"
                    ));

        //informational INET_ASSERT(FALSE);

        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto quit;
    }

    //
    // there may not be any error text for this thread - either no server
    // error/response has been received, or the error text has been cleared by
    // an intervening API
    //

    if (lpThreadInfo->hErrorText != NULL) {

        //
        // copy as much as we can fit in the user supplied buffer
        //

        textLength = lpThreadInfo->ErrorTextLength;
        if (*lpdwBufferLength && lpszBuffer != NULL) {

            LPBYTE errorText;

            errorText = (LPBYTE)LOCK_MEMORY(lpThreadInfo->hErrorText);
            if (errorText != NULL) {
                textLength = min(textLength, *lpdwBufferLength) - 1;
                memcpy(lpszBuffer, errorText, textLength);

                //
                // the error text should always be zero terminated, so the
                // calling app can treat it as a string
                //

                lpszBuffer[textLength] = '\0';

                UNLOCK_MEMORY(lpThreadInfo->hErrorText);

                if (textLength == lpThreadInfo->ErrorTextLength - 1) {
                    error = ERROR_SUCCESS;
                } else {

                    //
                    // returned length is amount of buffer required
                    //

                    textLength = lpThreadInfo->ErrorTextLength;
                    error = ERROR_INSUFFICIENT_BUFFER;
                }
            } else {

                DEBUG_PRINT(INET,
                            ERROR,
                            ("failed to lock hErrorText (%#x): %d\n",
                            lpThreadInfo->hErrorText,
                            GetLastError()
                            ));

                error = ERROR_WINHTTP_INTERNAL_ERROR;
            }
        } else {

            //
            // user's buffer is not large enough to hold the info. We'll
            // let them know the required length
            //

            error = ERROR_INSUFFICIENT_BUFFER;
        }
    } else {

        INET_ASSERT(lpThreadInfo->ErrorTextLength == 0);

        textLength = 0;
        error = ERROR_SUCCESS;
    }

    *lpdwErrorCategory = lpThreadInfo->ErrorNumber;
    *lpdwBufferLength = textLength;

    IF_DEBUG(ANY) {
        if ((error == ERROR_SUCCESS)
        || ((textLength != 0) && (lpszBuffer != NULL))) {

            DEBUG_DUMP_API(API,
                           "Last Response Info:\n",
                           lpszBuffer,
                           textLength
                           );

        }
    }

    if ((error == ERROR_SUCCESS)
    || ((textLength != 0) && (lpszBuffer != NULL))) {

        TRACE_DUMP_API_IF_REQUEST(API,
                       "Last Response Info:\n",
                       lpszBuffer,
                       textLength,
                       (HANDLE_OBJECT *) (lpThreadInfo->hObjectMapped)
                       );

    }

quit:
    success = (error == ERROR_SUCCESS);
    if (!success) {
        DEBUG_ERROR(API, error);
        SetLastError(error);
    }

    DEBUG_LEAVE(success);

    return success;
}


BOOL
internalWinHttpGetDefaultProxyConfigurationA( IN OUT WINHTTP_PROXY_INFOA * pProxyInfo)
/*++

Routine Description:

    Reads the settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure to receive proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    DWORD dwError;
    
    INTERNET_PROXY_INFO_EX proxyInfoEx;
    memset( &proxyInfoEx, 0, sizeof( proxyInfoEx));
    proxyInfoEx.dwStructSize = sizeof( proxyInfoEx);

    dwError = ReadProxySettings( &proxyInfoEx);

    if( dwError == ERROR_SUCCESS)
    {
        //  reset access type result to one of two known..
        pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NO_PROXY;
        if( proxyInfoEx.dwFlags == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
            pProxyInfo->dwAccessType = WINHTTP_ACCESS_TYPE_NAMED_PROXY;
        
        pProxyInfo->lpszProxy = (LPSTR)proxyInfoEx.lpszProxy;  // allocated by GlobalAlloc()
        pProxyInfo->lpszProxyBypass = (LPSTR)proxyInfoEx.lpszProxyBypass;  // allocated by GlobalAlloc()
    }

    if( dwError != ERROR_SUCCESS)
        SetLastError( dwError);

    return dwError == ERROR_SUCCESS ? TRUE : FALSE;
}


BOOL
internalWinHttpSetDefaultProxyConfigurationA( IN WINHTTP_PROXY_INFOA * pProxyInfo)
/*++

Routine Description:

    Writes settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure describing proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;

    //
    //  Parameter validation
    //

    //  If AccessType is NO_PROXY, make sure no proxy information is given.
    if( pProxyInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
    {
        if( pProxyInfo->lpszProxy != NULL
            || pProxyInfo->lpszProxyBypass != NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    //  If AccessType is NAMED_PROXY, make sure a proxy is given.  ProxyBypass list is optional.
    else if( pProxyInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if( pProxyInfo->lpszProxy == NULL)
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    else
    {
        //  AccessType is not NAMED_PROXY or NO_PROXY
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //  verify validity of proxy server list
    if( pProxyInfo->lpszProxy != NULL)
    {
        //  verify validity of proxy server list
        PROXY_SERVER_LIST proxyServerList( pProxyInfo->lpszProxy);

        if( ERROR_SUCCESS != proxyServerList.GetError())
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }
    
    //  verify validity of proxy server bypass list
    if( pProxyInfo->lpszProxyBypass != NULL)
    {
        PROXY_BYPASS_LIST proxyBypassList( pProxyInfo->lpszProxyBypass);
        if( ERROR_SUCCESS != proxyBypassList.GetError())
        {
            SetLastError( ERROR_INVALID_PARAMETER);
            goto done;
        }
    }

    INTERNET_PROXY_INFO_EX proxyInfoEx;
    memset( &proxyInfoEx, 0, sizeof( proxyInfoEx));
    proxyInfoEx.dwStructSize = sizeof( proxyInfoEx);
    proxyInfoEx.dwFlags = pProxyInfo->dwAccessType;
    proxyInfoEx.lpszProxy = pProxyInfo->lpszProxy;
    proxyInfoEx.lpszProxyBypass = pProxyInfo->lpszProxyBypass;

    DWORD dwError;
    dwError = WriteProxySettings( &proxyInfoEx);
    if( ERROR_SUCCESS != dwError)
    {
        SetLastError( dwError);
        goto done;
    }
    
    blReturnValue = TRUE;

done:
    return blReturnValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\inetapiw.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    inetapiw.cxx

Abstract:

    Contains the wide-character Internet APIs

    Contents:
        WinHttpCrackUrl
        WinHttpCreateUrl
        WinHttpOpen
        WinHttpConnect
        WinHttpSetStatusCallback

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

//  because wininet doesnt know about IStream
#define NO_SHLWAPI_STREAM
#include <shlwapi.h>
#include <shlwapip.h>
#include "autodial.h"

// -- FixStrings ------

//  Used in WinHttpCrackUrlW only.
//  Either
//  (a) If we have an ansi string, AND a unicode buffer, convert from ansi to unicode
//  (b) If we have an ansi string, but NO unicode buffer, determine where the ansi string
//         occurs in the unicode URL, and point the component there.
//
//  Insufficient buffer errors are not reported through the return value but rather
//through *pdwBufferError.  If the buffer is sufficient, *pdwBufferError should be
//left UNMODIFIED.
//
DWORD
FixStrings(    
    LPSTR& pszA, 
    DWORD cbA, 
    LPWSTR& pszW, 
    DWORD& ccW, 
    LPSTR pszUrlA, 
    LPCWSTR pszUrlW,
    DWORD *pdwBufferError)
{
    DWORD dwErr = ERROR_SUCCESS;
    if (pszW == NULL)
    {
        if (ccW == 0)
        {
            //  pszW == NULL && ccW == 0 -> report nothing.
        }
        else
        {
            //  pszW == NULL && ccW != 0 -> report strings position in place.
        pszW = (LPWSTR)(pszUrlW + MultiByteToWideChar(CP_UTF8, 0, 
                                      pszUrlA, (int) (pszA-pszUrlA), NULL, 0));
        ccW = MultiByteToWideChar(CP_UTF8, 0, pszA, cbA, NULL, 0);         }
    }
    else// if (pszW) 
    {
        if (pszA == NULL)
        {
            INET_ASSERT(0);
            pszW[0] = '\0';
            ccW = 0;
            goto done;
        }

        if (pszA[0] == '\0')
        {
            //  Detect if there wasn't enough buffer given for this to succeed or if the result was empty
            pszW[0] = L'\0';
            ccW = cbA;  // this result may actually be high if the UTF-8 encoding expanded characters.
            if (cbA != 0)
                *pdwBufferError = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            //  we still may not have enough buffer if the ANSI->Unicode translation
            DWORD dwSizeNeeded = MultiByteToWideChar(CP_UTF8, 0, pszA, cbA, 0, 0);
            if(dwSizeNeeded == 0 && cbA != 0)
            {
                dwErr = GetLastError();
                INET_ASSERT(dwErr != ERROR_INSUFFICIENT_BUFFER);
            }
            else if (dwSizeNeeded + 1 > ccW)
            {
                *pszW = L'\0';
                ccW = dwSizeNeeded + 1;
                *pdwBufferError = ERROR_INSUFFICIENT_BUFFER;
            }
            else
            {
                ccW = MultiByteToWideChar(CP_UTF8, 0, pszA, cbA, pszW, ccW);
                pszW[ccW] = L'\0';
                if (ccW == 0 && cbA != 0)
                {
                    dwErr = GetLastError();
                    INET_ASSERT(dwErr != ERROR_INSUFFICIENT_BUFFER);
                }
            }
        }
    } 

done:    
    return dwErr;
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
WinHttpCrackUrl(
    IN LPCWSTR pszUrlW,
    IN DWORD dwUrlLengthW,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS pUCW
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts. Optionally escapes the url-path.
    We assume that the user has supplied large enough buffers for the various
    URL parts

Arguments:

    pszUrl         - pointer to URL to crack

    dwUrlLength     - 0 if pszUrl is ASCIIZ string, else length of pszUrl

    dwFlags         - flags controlling operation

    lpUrlComponents - pointer to URL_COMPONENTS

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCrackUrl",
                     "%wq, %#x, %#x, %#x",
                     pszUrlW,
                     dwUrlLengthW,
                     dwFlags,
                     pUCW
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    DWORD c;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;
    memset(&UCA, 0, sizeof(UCA));
    UCA.dwStructSize = sizeof(URL_COMPONENTSA); 

    //
    //  Validate parameters
    //

    if (!pszUrlW
        || IsBadStringPtrW(pszUrlW,(UINT_PTR)-1)
        || !pUCW
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW)) 
        || (dwFlags & ~(ICU_ESCAPE | ICU_DECODE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    //
    //  Create an ANSI version of the target URL
    // 

    if (pszUrlW)
    {
        dwErr = ConvertUnicodeToMultiByte(pszUrlW, CP_UTF8, &mpUrlA, 
                    WINHTTP_FLAG_ESCAPE_DISABLE |
                    WINHTTP_FLAG_ESCAPE_DISABLE_QUERY);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;
    }

    //
    //  Create ANSI versions of the buffer passed in by the user.
    //
    //  This is done by having a MEMORYPACKET act as a buffer for each
    //buffer passed in through URL_COMPONENTSW.  The ansi URL_COMPONENTSA
    //structure is set to store its results in these MEMORYPACKETS.
    //
    
    for (c=0; c<=5; c++) {
        LPWSTR pszWorker = NULL;
        DWORD ccLen = 0;
        MEMORYPACKET* pmpWorker = NULL;
        
        switch(c)
        {
        case 0:
            pszWorker = pUCW->lpszScheme;
            ccLen = pUCW->dwSchemeLength;
            pmpWorker = &mpScheme;
            break;

        case 1:
            pszWorker = pUCW->lpszHostName;
            ccLen = pUCW->dwHostNameLength;
            pmpWorker = &mpHostName;
            break;

        case 2:
            pszWorker = pUCW->lpszUserName;
            ccLen = pUCW->dwUserNameLength;
            pmpWorker = &mpUserName;
            break;

        case 3:
            pszWorker = pUCW->lpszPassword;
            ccLen = pUCW->dwPasswordLength;
            pmpWorker = &mpPassword;
            break;

        case 4:
            pszWorker = pUCW->lpszUrlPath;
            ccLen = pUCW->dwUrlPathLength;
            pmpWorker = &mpUrlPath;
            break;

        case 5:
            pszWorker = pUCW->lpszExtraInfo;
            ccLen = pUCW->dwExtraInfoLength;
            pmpWorker = &mpExtraInfo;
            break;
        }

        if (pszWorker) 
        {
            //  reject pointers to 0-byte buffers
            if (ccLen == 0)  
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            //  make sure the given buffer is writeable
            if (pszWorker 
                && ccLen 
                && (ProbeWriteBuffer(pszWorker,ccLen) != ERROR_SUCCESS) )
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            //
            //  We alloc a buffer three times as long because the number
            //of characters could be larger in the UTF-8 version than the
            //Unicode version.  So later we'll have to watch out
            //that even if the result fit in the ANSI version of the buffer,
            //it may not fit in the Unicode verison of the buffer.
            //  We don't increase the buffersize to compensate for escaping
            //because both the ANSI and Unicode string sizes  will be affected 
            //in the same way.
            //
            pmpWorker->dwAlloc = ccLen*3;
            ALLOC_BYTES(pmpWorker->psStr, pmpWorker->dwAlloc);
            if (!pmpWorker->psStr) 
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
        } 
        else 
        { 
            pmpWorker->dwAlloc = ccLen; 
        }
    };

    REASSIGN_ALLOC(mpScheme,UCA.lpszScheme,UCA.dwSchemeLength);
    REASSIGN_ALLOC(mpHostName, UCA.lpszHostName,UCA.dwHostNameLength);
    REASSIGN_ALLOC(mpUserName, UCA.lpszUserName,UCA.dwUserNameLength);
    REASSIGN_ALLOC(mpPassword,UCA.lpszPassword,UCA.dwPasswordLength);
    REASSIGN_ALLOC(mpUrlPath,UCA.lpszUrlPath,UCA.dwUrlPathLength);
    REASSIGN_ALLOC(mpExtraInfo,UCA.lpszExtraInfo,UCA.dwExtraInfoLength);
                
    fResult = WinHttpCrackUrlA(mpUrlA.psStr, mpUrlA.dwSize, dwFlags, &UCA);
    if (fResult || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        DWORD dwBufferError = ERROR_SUCCESS;
        BOOL fIsInplacePointer;

        dwErr = FixStrings(UCA.lpszScheme, UCA.dwSchemeLength, pUCW->lpszScheme, 
                           pUCW->dwSchemeLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;
        
        dwErr = FixStrings(UCA.lpszHostName, UCA.dwHostNameLength, pUCW->lpszHostName, 
                           pUCW->dwHostNameLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        //  usage of fIsInplacePointer:
        //
	//  fIsInplacePointer detects the case where the application is asking
        //for either the username or password in place.  Older versions of WinHTTP
        //would return NULL for their position if they were not present, fIsInplacePointer
        //is checked to maintain this behavior.

        fIsInplacePointer = pUCW->dwUserNameLength != 0
                            && pUCW->lpszUserName == NULL;
        
        dwErr = FixStrings(UCA.lpszUserName, UCA.dwUserNameLength, pUCW->lpszUserName, 
                           pUCW->dwUserNameLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        if (fIsInplacePointer
            && pUCW->dwUserNameLength == 0)
        {
            pUCW->lpszUserName = NULL;
        }
        
        fIsInplacePointer = pUCW->dwPasswordLength != 0
                            && pUCW->lpszPassword == NULL;
        
        dwErr = FixStrings(UCA.lpszPassword, UCA.dwPasswordLength, pUCW->lpszPassword, 
                           pUCW->dwPasswordLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        if (fIsInplacePointer
            && pUCW->dwPasswordLength == 0)
        {
            pUCW->lpszPassword = NULL;
        }
        
        dwErr = FixStrings(UCA.lpszUrlPath, UCA.dwUrlPathLength, pUCW->lpszUrlPath, 
                           pUCW->dwUrlPathLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;
        
        dwErr = FixStrings(UCA.lpszExtraInfo, UCA.dwExtraInfoLength, pUCW->lpszExtraInfo, 
                           pUCW->dwExtraInfoLength, mpUrlA.psStr, pszUrlW, &dwBufferError);

        if (dwErr != ERROR_SUCCESS)
            goto cleanup;

        //  if one or more buffers caused an ERROR_INSUFFICIENT_BUFFER, report it
        dwErr = dwBufferError;  
        
        pUCW->nScheme = UCA.nScheme;
        pUCW->nPort = UCA.nPort;
        pUCW->dwStructSize = sizeof(URL_COMPONENTSW);
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
        fResult = FALSE;
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpCreateUrl(
    IN LPURL_COMPONENTS pUCW,
    IN DWORD dwFlags,
    OUT LPWSTR pszUrlW,
    IN OUT LPDWORD pdwUrlLengthW
    )

/*++

Routine Description:

    Creates an URL from its constituent parts

Arguments:

Return Value:

    BOOL
        Success - URL written to pszUrl

        Failure - call GetLastError() for more info

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpCreateUrl",
                     "%#x, %#x, %#x, %#x",
                     pUCW,
                     dwFlags,
                     pszUrlW,
                     pdwUrlLengthW
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpUrlA, mpHostName, mpUserName, mpScheme, mpPassword, mpUrlPath, mpExtraInfo;
    URL_COMPONENTSA UCA;

    if (!pdwUrlLengthW 
        || (pUCW==NULL)
        || IsBadWritePtr(pUCW, sizeof(*pUCW))
        || (pUCW->dwStructSize != sizeof(*pUCW))
        || (pszUrlW && IsBadWritePtr(pszUrlW, *pdwUrlLengthW*sizeof(WCHAR)))
        || (dwFlags & ~(ICU_ESCAPE)))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    if (pszUrlW)
    {
        ALLOC_MB(pszUrlW, *pdwUrlLengthW, mpUrlA);
        if (!mpUrlA.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
    }
    mpUrlA.dwSize = mpUrlA.dwAlloc;
    UCA.dwStructSize = sizeof(URL_COMPONENTSA);

    UCA.nScheme = pUCW->nScheme;
    UCA.nPort = pUCW->nPort;
    if (pUCW->lpszScheme)
    {
        if (pUCW->dwSchemeLength
            ? IsBadReadPtr(pUCW->lpszScheme, pUCW->dwSchemeLength)
            : IsBadStringPtrW(pUCW->lpszScheme, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszScheme, pUCW->dwSchemeLength, mpScheme);
        if (!mpScheme.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszScheme, mpScheme);
    }
    REASSIGN_SIZE(mpScheme, UCA.lpszScheme, UCA.dwSchemeLength);
    if (pUCW->lpszHostName)
    {
        if (pUCW->dwHostNameLength
            ? IsBadReadPtr(pUCW->lpszHostName, pUCW->dwHostNameLength)
            : IsBadStringPtrW(pUCW->lpszHostName, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszHostName, pUCW->dwHostNameLength, mpHostName);
        if (!mpHostName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszHostName, mpHostName);
    }
    REASSIGN_SIZE(mpHostName, UCA.lpszHostName, UCA.dwHostNameLength);
    if (pUCW->lpszUserName)
    {
        if (pUCW->dwUserNameLength
            ? IsBadReadPtr(pUCW->lpszUserName, pUCW->dwUserNameLength)
            : IsBadStringPtrW(pUCW->lpszUserName, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUserName, pUCW->dwUserNameLength, mpUserName);
        if (!mpUserName.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUserName, mpUserName);
    }
    REASSIGN_SIZE(mpUserName, UCA.lpszUserName, UCA.dwUserNameLength);
    if (pUCW->lpszPassword)
    {
        if (pUCW->dwPasswordLength
            ? IsBadReadPtr(pUCW->lpszPassword, pUCW->dwPasswordLength)
            : IsBadStringPtrW(pUCW->lpszPassword, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszPassword, pUCW->dwPasswordLength, mpPassword);
        if (!mpPassword.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszPassword, mpPassword);
    }
    REASSIGN_SIZE(mpPassword, UCA.lpszPassword, UCA.dwPasswordLength);
    if (pUCW->lpszUrlPath)
    {
        if (pUCW->dwUrlPathLength
            ? IsBadReadPtr(pUCW->lpszUrlPath, pUCW->dwUrlPathLength)
            : IsBadStringPtrW(pUCW->lpszUrlPath, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszUrlPath, pUCW->dwUrlPathLength, mpUrlPath); 
        if (!mpUrlPath.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszUrlPath, mpUrlPath);
    }
    REASSIGN_SIZE(mpUrlPath, UCA.lpszUrlPath, UCA.dwUrlPathLength);
    if (pUCW->lpszExtraInfo)
    {
        if (pUCW->dwExtraInfoLength
            ? IsBadReadPtr(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength)
            : IsBadStringPtrW(pUCW->lpszExtraInfo, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pUCW->lpszExtraInfo, pUCW->dwExtraInfoLength, mpExtraInfo);
        if (!mpExtraInfo.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(pUCW->lpszExtraInfo, mpExtraInfo);
    }
    REASSIGN_SIZE(mpExtraInfo, UCA.lpszExtraInfo, UCA.dwExtraInfoLength);
    fResult = WinHttpCreateUrlA(&UCA, dwFlags, mpUrlA.psStr, &mpUrlA.dwSize);
    if (fResult)
    {
        DWORD dwRet;

        fResult = FALSE;
        
        if (pszUrlW && *pdwUrlLengthW)
        {
            //On success, reduce length of terminating NULL widechar.
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, *pdwUrlLengthW);
            
            if (dwRet)
            {
                *pdwUrlLengthW = dwRet-1;
                fResult = TRUE;
            }
        }
        
        //If no url or no length or failure in prev. call, use MBtoWC to calculate required length of buffer.
        //If a value is returned, then set ERROR_INSUFFICIENT_BUFFER as last error
        if (!fResult)
        {
            dwRet = MultiByteToWideChar(CP_ACP, 0, mpUrlA.psStr, mpUrlA.dwSize+1, pszUrlW, 0);
            
            if (dwRet)
            {
                dwErr = ERROR_INSUFFICIENT_BUFFER;
                *pdwUrlLengthW = dwRet;
                
            }
            else
            {
                dwErr = GetLastError();
                //Morph the error since we don't know what to initialize pdwUrlLengthW to
                if (dwErr == ERROR_INSUFFICIENT_BUFFER)
                {
                    dwErr = ERROR_INVALID_PARAMETER;
                }
            }
        }
    }
    else
    {
        *pdwUrlLengthW = mpUrlA.dwSize;
    }

cleanup:        
    if (dwErr!=ERROR_SUCCESS) 
    { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(fResult);
    return fResult;
}


// implemented in inetapia.cxx
DWORD ICUHrToWin32Error(HRESULT);


INTERNETAPI
HINTERNET
WINAPI
WinHttpOpen(
    IN LPCWSTR pszAgentW,
    IN DWORD dwAccessType,
    IN LPCWSTR pszProxyW OPTIONAL,
    IN LPCWSTR pszProxyBypassW OPTIONAL,
    IN DWORD dwFlags
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    pszAgent       -

    dwAccessType    -

    pszProxy       -

    pszProxyBypass -

    dwFlags         -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpOpen",
                     "%wq, %s (%d), %wq, %wq, %#x",
                     pszAgentW,
                     InternetMapOpenType(dwAccessType),
                     dwAccessType,
                     pszProxyW,
                     pszProxyBypassW,
                     dwFlags
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    HINTERNET hInternet = NULL;
    MEMORYPACKET mpAgentA, mpProxyA, mpProxyBypassA;

    if (dwFlags &~ (WINHTTP_OPEN_FLAGS_MASK))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszAgentW)
    {
        if (IsBadStringPtrW(pszAgentW, (UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(pszAgentW,0,mpAgentA);
        if (!mpAgentA.psStr)
        {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
        }
        UNICODE_TO_ANSI(pszAgentW,mpAgentA);
    }

    if (dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
    {
        if (pszProxyW)
        {
            if (IsBadStringPtrW(pszProxyW, (UINT_PTR)-1) 
                || (*pszProxyW == L'\0'))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyW,0,mpProxyA);
            if (!mpProxyA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyW,mpProxyA);
        }
        if (pszProxyBypassW)
        {
            if (IsBadStringPtrW(pszProxyBypassW, (UINT_PTR)-1))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                goto cleanup;
            }
            ALLOC_MB(pszProxyBypassW,0,mpProxyBypassA);
            if (!mpProxyBypassA.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                goto cleanup;
            }
            UNICODE_TO_ANSI(pszProxyBypassW,mpProxyBypassA);
        }
    }

    hInternet = InternetOpenA(mpAgentA.psStr, dwAccessType, mpProxyA.psStr, 
                                        mpProxyBypassA.psStr, dwFlags);

                                        
cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
HINTERNET
WINAPI
WinHttpConnect(
    IN HINTERNET hInternetSession,
    IN LPCWSTR pszServerNameW,
    IN INTERNET_PORT nServerPort,
    IN DWORD dwReserved
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternetSession    -
    pszServerName      -
    nServerPort         -
    pszUserName        -
    pszPassword        -
    dwService           -
    dwReserved             -

Return Value:

    HINTERNET

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Handle,
                     "WinHttpConnect",
                     "%#x, %wq, %d, %#x",
                     hInternetSession,
                     pszServerNameW,
                     nServerPort,
                     dwReserved
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpServerNameA;
    HINTERNET hInternet = NULL;

    if (dwReserved)
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (pszServerNameW)
    {
        if (IsBadStringPtrW(pszServerNameW,(UINT_PTR)-1))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        dwErr = ConvertUnicodeToMultiByte(pszServerNameW, 0/*CODEPAGE not used here*/, &mpServerNameA, 
                    WINHTTP_FLAG_VALID_HOSTNAME); 
        if (dwErr != ERROR_SUCCESS)
        {
            goto cleanup;
        }
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    hInternet = InternetConnectA
        (hInternetSession, mpServerNameA.psStr, nServerPort, dwReserved, NULL);

cleanup:        
    if (dwErr!=ERROR_SUCCESS) { 
        SetLastError(dwErr); 
        DEBUG_ERROR(API, dwErr);
    }

    DEBUG_LEAVE_API(hInternet);
    return hInternet;
}


INTERNETAPI
WINHTTP_STATUS_CALLBACK
WINAPI
WinHttpSetStatusCallback(
    IN HINTERNET hInternet,
    IN WINHTTP_STATUS_CALLBACK lpfnInternetCallback,
    IN DWORD dwNotificationFlags,
    IN DWORD_PTR dwReserved
    )

/*++

Routine Description:

    Sets the status callback function for the DLL or the handle object

Arguments:

    hInternet               - handle of the object for which we wish to set the
                              status callback

    lpfnInternetCallback    - pointer to caller-supplied status function

Return Value:

    FARPROC
        Success - previous status callback function address

        Failure - INTERNET_INVALID_STATUS_CALLBACK. Call GetLastErrorInfo() for
                  more information:

                    ERROR_INVALID_PARAMETER
                        The callback function is invalid

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        Cannot set the callback on the supplied handle (probably
                        a NULL handle - per-process callbacks no longer
                        supported)

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Pointer,
                     "WinHttpSetStatusCallback",
                     "%#x, %#x, %#x",
                     hInternet,
                     lpfnInternetCallback,
                     dwNotificationFlags
                     ));
                 
    DWORD dwErr = ERROR_SUCCESS;
    BOOL fIsUnicode = TRUE; //vestigial UNICODE indicator
    
    WINHTTP_STATUS_CALLBACK previousCallback = WINHTTP_INVALID_STATUS_CALLBACK;
    HINTERNET hObjectMapped = NULL;

    if (!GlobalDataInitialized) 
    {
        dwErr = GlobalDataInitialize();
        if (dwErr != ERROR_SUCCESS) 
        {
            goto cleanup;
        }
    }

    if (((lpfnInternetCallback != NULL) && IsBadCodePtr((FARPROC)lpfnInternetCallback))
        || ((lpfnInternetCallback != NULL) && (dwNotificationFlags == 0)) || (dwReserved != 0))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    if (!hInternet)
    {
        dwErr = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto cleanup;
    }

    // map the handle
    dwErr = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
    if (dwErr != ERROR_SUCCESS)
    {
        if (hObjectMapped == NULL)
        {
            //
            // the handle never existed or has been completely destroyed.  Fail the call.
            //
            goto cleanup;
        }
        else
        {
            //
            //  This handle is already being closed (it's invalidated). However the client
            //could be trying to turn off callbacks inside a callback.  Allow that, otherwise
            //fail the call.
            //
            if (lpfnInternetCallback != NULL)
            {
                goto cleanup;
            }
        }

    }

    // swap the new and previous handle object status callbacks, ONLY
    // if there are no pending requests on this handle
    previousCallback = lpfnInternetCallback;
    dwErr = RExchangeStatusCallback(hObjectMapped, &previousCallback, fIsUnicode, dwNotificationFlags);
    
cleanup:

    if (hObjectMapped != NULL) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(API, dwErr);
    }
    
    DEBUG_LEAVE_API(previousCallback);
    return previousCallback;
}


// WinHttpPlatformCheck() API routines //////////////////////////////////////

static void ConvertVersionString(LPCSTR pszVersion, WORD rwVer[], CHAR ch)
{
    LPCSTR pszEnd;
    LPCSTR pszTemp;
    int    i; 

    for (i = 0; i < 4; i++)
        rwVer[i] = 0;

    pszEnd = pszVersion + lstrlen(pszVersion);
    pszTemp = pszVersion;

    for (i = 0; i < 4 && pszTemp < pszEnd; i++)
    {
        while (pszTemp < pszEnd && *pszTemp != ch)
        {
            rwVer[i] = rwVer[i] * 10 + (*pszTemp - '0');
            pszTemp++;
        }

        pszTemp++;
    }
}


const char c_gszRegActiveSetup[]        = "Software\\Microsoft\\Active Setup\\Installed Components\\";
const char c_gszInternetExplorerCLSID[] = "{89820200-ECBD-11cf-8B85-00AA005B4383}";

static void GetInstalledComponentVersion(LPCSTR szCLSID, DWORD *pdwMSVer, DWORD *pdwLSVer)
{
    HKEY    hKey;
    char    szKey[MAX_PATH];
    WORD    rgwVersion[4];
    DWORD   dwSize;
    
    *pdwMSVer = 0;
    *pdwLSVer = 0;

    if ((lstrlen(c_gszRegActiveSetup)+lstrlen(szCLSID)) < sizeof(szKey))
    {

    // Build the registry path.
    lstrcpy(szKey, c_gszRegActiveSetup);
    lstrcat(szKey, szCLSID);
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKey, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szKey);

        if ((RegQueryValueEx(hKey, "Version", NULL, NULL, (BYTE *)szKey, &dwSize) == ERROR_SUCCESS) &&
            (dwSize > 0))
        {
            ConvertVersionString(szKey, rgwVersion, ',');

            *pdwMSVer = (DWORD)rgwVersion[0] << 16;    // Make hi word of MS version
            *pdwMSVer += (DWORD)rgwVersion[1];         // Make lo word of MS version
            *pdwLSVer = (DWORD)rgwVersion[2] << 16;    // Make hi word of LS version
            *pdwLSVer += (DWORD)rgwVersion[3];         // Make lo word of LS version
        }

        RegCloseKey(hKey);
    }
    }
}

static BOOL Is_IE_501_OrLaterInstalled()
{
    DWORD   dwMSVer;
    DWORD   dwLSVer;

    //
    // Find the IE version number. IE 5.01 has version number 5.00.2919.6300.
    // This will be returned from GetInstalledComponentVersion as two DWORDs,
    // like so:
    //      5.00   ->  0x00050000
    //   2919.6300 ->  0x0B67189C
    //

    GetInstalledComponentVersion(c_gszInternetExplorerCLSID, &dwMSVer, &dwLSVer);

    if (dwMSVer > 0x00050000)
        return TRUE;
    else if ((dwMSVer == 0x00050000) && (dwLSVer >= 0x0B67189C))
        return TRUE;

    return FALSE;
}

#if 0

#define REGSTR_CCS_CONTROL_WINDOWS  TEXT("SYSTEM\\CurrentControlSet\\Control\\WINDOWS")
#define CSDVERSION                  TEXT("CSDVersion")
#define SP6_VERSION                 0x0600

static BOOL Is_SP6_OrLater()
{
    BOOL    fSP6OrLater = FALSE;
    HKEY    hKey;
    DWORD   dwCSDVersion;
    DWORD   dwSize;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwCSDVersion);

        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (BYTE *)&dwCSDVersion, &dwSize) == ERROR_SUCCESS)
        {
            fSP6OrLater = (LOWORD(dwCSDVersion) >= SP6_VERSION);
        }
        RegCloseKey(hKey);
    }

    return fSP6OrLater;
}
#endif


INTERNETAPI
BOOL
WINAPI
WinHttpCheckPlatform(void)
{
    static BOOL _fCheckedPlatform = FALSE;
    static BOOL _fPlatformOk;


    if (!_fCheckedPlatform)
    {
        OSVERSIONINFO   osvi;
        BOOL            fPlatformOk = FALSE;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
        if (GetVersionEx(&osvi))
        {
            // Allow only Win2K or NT-based platforms.
            if (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT)
            {
                if (osvi.dwMajorVersion >= 5)
                {
                    // Ok on Win2K or later.
                    fPlatformOk = TRUE;
                }
                else if (osvi.dwMajorVersion == 4)
                {
                    // On NT4, we require IE 5.01 (or later).
                    fPlatformOk = Is_IE_501_OrLaterInstalled();
                }
            }
        }

        _fPlatformOk = fPlatformOk;

        InterlockedExchange((long *)&_fCheckedPlatform, TRUE);
    }

    return _fPlatformOk;
}


// WinHttpGet/SetDefaultProxyConfiguration APIs /////////////////////////////

WINHTTPAPI
BOOL
WINAPI
WinHttpGetDefaultProxyConfiguration( IN OUT WINHTTP_PROXY_INFOW * pProxyInfo)
/*++

Routine Description:

    Reads the settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure to receive proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;
    DWORD dwError;
    
    LPWSTR lpszProxy = NULL, lpszProxyBypass = NULL;

    WINHTTP_PROXY_INFOA ansiProxyInfo;
    memset( &ansiProxyInfo, 0, sizeof( ansiProxyInfo));

    if( IsBadWritePtr( pProxyInfo, sizeof( *pProxyInfo)))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //
    //  Get results and make available in Unicode format
    //
    if( FALSE == internalWinHttpGetDefaultProxyConfigurationA( &ansiProxyInfo))
    {
        //  SetLastError() performed by Ansi version of WinHttpGetDefaultProxyConfiguration
        goto done;
    }

    if( ansiProxyInfo.lpszProxy != NULL)
    {
        dwError = AsciiToWideChar_UsingGlobalAlloc( ansiProxyInfo.lpszProxy, &(lpszProxy));
        if( dwError != ERROR_SUCCESS)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    if( ansiProxyInfo.lpszProxyBypass != NULL)
    {
        dwError = AsciiToWideChar_UsingGlobalAlloc( ansiProxyInfo.lpszProxyBypass, &(lpszProxyBypass));
        if( dwError != ERROR_SUCCESS)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    //
    //  Return results
    //
    pProxyInfo->dwAccessType = ansiProxyInfo.dwAccessType;
    pProxyInfo->lpszProxy = lpszProxy;
    lpszProxy = NULL;
    pProxyInfo->lpszProxyBypass = lpszProxyBypass;
    lpszProxyBypass = NULL;

    blReturnValue = TRUE;

done:
    if( NULL != lpszProxy)
        GlobalFree( lpszProxy);
    
    if( NULL != lpszProxyBypass)
        GlobalFree( lpszProxyBypass);

    if( NULL != ansiProxyInfo.lpszProxy)
        GlobalFree( ansiProxyInfo.lpszProxy);
    
    if( NULL != ansiProxyInfo.lpszProxyBypass)
        GlobalFree( ansiProxyInfo.lpszProxyBypass);
    
    return blReturnValue;
}


WINHTTPAPI
BOOL
WINAPI
WinHttpSetDefaultProxyConfiguration( IN WINHTTP_PROXY_INFOW * pProxyInfo)
/*++

Routine Description:

    Writes settings for WinHTTP's default proxy mode.
    
Arguments:

    pProxyInfo  - Pointer to structure describing proxy settings

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info

--*/
{
    BOOL blReturnValue = FALSE;
    DWORD dwError;

    WINHTTP_PROXY_INFOA ansiProxyInfo;
    memset( &ansiProxyInfo, 0, sizeof( ansiProxyInfo));

    //
    //  Validate parameters
    //    (Ansi WinHttpSetDEfaultProxyConfiguration does deeper verification)
    if( IsBadReadPtr( pProxyInfo, sizeof( *pProxyInfo))
        || ((NULL != pProxyInfo->lpszProxy) && IsBadStringPtrW( pProxyInfo->lpszProxy, (DWORD)-1))
        || ((NULL != pProxyInfo->lpszProxyBypass) && IsBadStringPtrW( pProxyInfo->lpszProxyBypass, (DWORD)-1)))
    {
        SetLastError( ERROR_INVALID_PARAMETER);
        goto done;
    }

    //
    //  Convert WINHTTP_PROXY_INFOW to WINHTTP_PROXY_INFOA
    //
    ansiProxyInfo.dwAccessType = pProxyInfo->dwAccessType;

    if( pProxyInfo->lpszProxy != NULL)
    {
        dwError = WideCharToAscii( pProxyInfo->lpszProxy, &(ansiProxyInfo.lpszProxy));
        if( ERROR_SUCCESS != dwError)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    if( pProxyInfo->lpszProxyBypass != NULL)
    {
        dwError = WideCharToAscii( pProxyInfo->lpszProxyBypass, &(ansiProxyInfo.lpszProxyBypass));
        if( ERROR_SUCCESS != dwError)
        {
            SetLastError( dwError);
            goto done;
        }
    }

    //
    //  call Ansi version
    //
    blReturnValue = internalWinHttpSetDefaultProxyConfigurationA( &ansiProxyInfo);

done:
    if( ansiProxyInfo.lpszProxy != NULL)
        delete[] ansiProxyInfo.lpszProxy;
    
    if( ansiProxyInfo.lpszProxyBypass != NULL)
        delete[] ansiProxyInfo.lpszProxyBypass;

    return blReturnValue;
}



INTERNETAPI
BOOL
WINAPI
WinHttpGetIEProxyConfigForCurrentUser
(
    WINHTTP_CURRENT_USER_IE_PROXY_CONFIG * pProxyConfig
)
{
    WININET_PROXY_INFO_EX   WinInetProxyInfo;
    DWORD                   error = ERROR_SUCCESS;

    if (pProxyConfig == NULL ||
        IsBadWritePtr(pProxyConfig, sizeof(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG)))
    {
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    }

    if (!GlobalDataInitialized)
    {
        error = GlobalDataInitialize();

        if (error != ERROR_SUCCESS)
            goto quit;
    }

    memset(pProxyConfig, 0, sizeof(WINHTTP_CURRENT_USER_IE_PROXY_CONFIG));
    memset(&WinInetProxyInfo, 0, sizeof(WinInetProxyInfo));

    WinInetProxyInfo.dwStructSize = sizeof(WinInetProxyInfo);

    // GetActiveConnectionName will use RAS APIs to determine if
    // there are any active VPN or dial-up connections, and then return
    // the name of one of them. If no active VPN/dial-up connections
    // are found, then the function returns NULL, in which we'll
    // default to LAN Settings.
    WinInetProxyInfo.lpszConnectionName = GetActiveConnectionName();

    error = ReadWinInetProxySettings(&WinInetProxyInfo);

    if (error == ERROR_SUCCESS)
    {
        DWORD dwFlags = WinInetProxyInfo.dwFlags;

        if (dwFlags & PROXY_TYPE_AUTO_DETECT)
        {
            pProxyConfig->fAutoDetect = TRUE;
        }

        if ((dwFlags & PROXY_TYPE_AUTO_PROXY_URL) && WinInetProxyInfo.lpszAutoconfigUrl)
        {
            AsciiToWideChar_UsingGlobalAlloc(WinInetProxyInfo.lpszAutoconfigUrl,
                    &pProxyConfig->lpszAutoConfigUrl);
        }

        if ((dwFlags & PROXY_TYPE_PROXY) && WinInetProxyInfo.lpszProxy)
        {
            if (ERROR_SUCCESS == AsciiToWideChar_UsingGlobalAlloc(
                        WinInetProxyInfo.lpszProxy,
                        &pProxyConfig->lpszProxy)
                )
            {
                if (WinInetProxyInfo.lpszProxyBypass)
                {
                    AsciiToWideChar_UsingGlobalAlloc(WinInetProxyInfo.lpszProxyBypass,
                            &pProxyConfig->lpszProxyBypass);
                }
            }
        }
    }

    CleanWinInetProxyStruct(&WinInetProxyInfo);

quit:
    if (error != ERROR_SUCCESS)
    {
        SetLastError(error);
    }

    return (error == ERROR_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\parseurl.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    parseurl.cxx

Abstract:

    Contains functions to parse the basic URLs - FTP, Gopher, HTTP.

    An URL parser simply acts as a macro: it must break out the protocol-specific
    information from the URL and initiate opening the identified resource: all
    this can be accomplished by calling the relevant Internet protocol APIs.

    Code in this module is based on RFC1738

    Contents:
        IsValidUrl
        DoesSchemeRequireSlashes
        ParseUrl
        CrackUrl
        EncodeUrlPath
        (HexCharToNumber)
        (NumberToHexChar)
        DecodeUrl
        DecodeUrlInSitu
        DecodeUrlStringInSitu
        GetUrlAddressInfo
        GetUrlAddress
        MapUrlSchemeName
        MapUrlScheme
        MapUrlSchemeToName

Author:

    Richard L Firth (rfirth) 26-Apr-1995

Environment:

    Win32(s) user-mode DLL

Revision History:

    26-Apr-1995
        Created

--*/

#include <wininetp.h>

//
// private manifests
//

#define RESERVED    SAFE

//
// private macros
//

//#define HEX_CHAR_TO_NUMBER(ch) \
//    ((ch <= '9') \
//        ? (ch - '0') \
//        : ((ch >= 'a') \
//            ? ((ch - 'a') + 10) \
//            : ((ch - 'A') + 10)))

#define NUMBER_TO_HEX_CHAR(n) \
    (((n) <= 9) ? ((char)(n) + '0') : (((char)(n) - 10) + 'A'))

#define IS_UNSAFE_URL_CHARACTER(Char, Scheme) \
    (((UCHAR)(Char) <= 0x20) || ((UCHAR)(Char) >= 0x7f) \
    || (SafetyList[(Char) - 0x21] & (UNSAFE | Scheme)))

#define IS_UNSAFE_URL_WIDECHARACTER(wChar, Scheme) \
    (((WCHAR)(wChar) <= 0x0020) || ((WCHAR)(wChar) >= 0x007f) \
    || (SafetyList[(wChar) - 0x0021] & (UNSAFE | Scheme)))

//
// private types
//

//
// private prototypes
//

PRIVATE
char
HexCharToNumber(
    IN char ch
    );

PRIVATE
char
NumberToHexChar(
    IN int Number
    );


//
// private data
//

//
// SafetyList - the list of characters above 0x20 and below 0x7f that are
// classified as safe, unsafe or scheme-specific. Safe characters do not need
// to be escaped for any URL scheme. Unsafe characters must be escaped for all
// URL schemes. Scheme-specific characters need only be escaped for the relevant
// scheme(s)
//

const
PRIVATE
UCHAR
SafetyList[] = {

    //
    // UNSAFE: 0x00..0x20
    //

    SAFE | HOSTNAME,                        // 0x21 (!)
    UNSAFE,                                 // 0x22 (")
    UNSAFE,                                 // 0x23 (#)
    SAFE | HOSTNAME,                        // 0x24 ($)
    UNSAFE,                                 // 0x25 (%)
    RESERVED | HOSTNAME,                    // 0x26 (&)
    SAFE | HOSTNAME,                        // 0x27 (')
    SAFE | HOSTNAME,                        // 0x28 (()
    SAFE | HOSTNAME,                        // 0x29 ())
    SAFE | HOSTNAME,                        // 0x2A (*)
    SCHEME_GOPHER | HOSTNAME,               // 0x2B (+)
    SAFE | HOSTNAME,                        // 0x2C (,)
    SAFE,                                   // 0x2D (-)
    SAFE,                                   // 0x2E (.)
    RESERVED | HOSTNAME,                    // 0x2F (/)
    SAFE,                                   // 0x30 (0)
    SAFE,                                   // 0x31 (1)
    SAFE,                                   // 0x32 (2)
    SAFE,                                   // 0x33 (3)
    SAFE,                                   // 0x34 (4)
    SAFE,                                   // 0x35 (5)
    SAFE,                                   // 0x36 (6)
    SAFE,                                   // 0x37 (7)
    SAFE,                                   // 0x38 (8)
    SAFE,                                   // 0x39 (9)
    RESERVED | HOSTNAME,                    // 0x3A (:)
    RESERVED | HOSTNAME,                    // 0x3B (;)
    UNSAFE,                                 // 0x3C (<)
    RESERVED | HOSTNAME,                    // 0x3D (=)
    UNSAFE,                                 // 0x3E (>)
    RESERVED | SCHEME_GOPHER | HOSTNAME,    // 0x3F (?)
    RESERVED | HOSTNAME,                    // 0x40 (@)
    SAFE,                                   // 0x41 (A)
    SAFE,                                   // 0x42 (B)
    SAFE,                                   // 0x43 (C)
    SAFE,                                   // 0x44 (D)
    SAFE,                                   // 0x45 (E)
    SAFE,                                   // 0x46 (F)
    SAFE,                                   // 0x47 (G)
    SAFE,                                   // 0x48 (H)
    SAFE,                                   // 0x49 (I)
    SAFE,                                   // 0x4A (J)
    SAFE,                                   // 0x4B (K)
    SAFE,                                   // 0x4C (L)
    SAFE,                                   // 0x4D (M)
    SAFE,                                   // 0x4E (N)
    SAFE,                                   // 0x4F (O)
    SAFE,                                   // 0x50 (P)
    SAFE,                                   // 0x51 (Q)
    SAFE,                                   // 0x42 (R)
    SAFE,                                   // 0x43 (S)
    SAFE,                                   // 0x44 (T)
    SAFE,                                   // 0x45 (U)
    SAFE,                                   // 0x46 (V)
    SAFE,                                   // 0x47 (W)
    SAFE,                                   // 0x48 (X)
    SAFE,                                   // 0x49 (Y)
    SAFE,                                   // 0x5A (Z)
    UNSAFE,                                 // 0x5B ([)
    UNSAFE,                                 // 0x5C (\)
    UNSAFE,                                 // 0x5D (])
    UNSAFE,                                 // 0x5E (^)
    SAFE,                                   // 0x5F (_)
    UNSAFE,                                 // 0x60 (`)
    SAFE,                                   // 0x61 (a)
    SAFE,                                   // 0x62 (b)
    SAFE,                                   // 0x63 (c)
    SAFE,                                   // 0x64 (d)
    SAFE,                                   // 0x65 (e)
    SAFE,                                   // 0x66 (f)
    SAFE,                                   // 0x67 (g)
    SAFE,                                   // 0x68 (h)
    SAFE,                                   // 0x69 (i)
    SAFE,                                   // 0x6A (j)
    SAFE,                                   // 0x6B (k)
    SAFE,                                   // 0x6C (l)
    SAFE,                                   // 0x6D (m)
    SAFE,                                   // 0x6E (n)
    SAFE,                                   // 0x6F (o)
    SAFE,                                   // 0x70 (p)
    SAFE,                                   // 0x71 (q)
    SAFE,                                   // 0x72 (r)
    SAFE,                                   // 0x73 (s)
    SAFE,                                   // 0x74 (t)
    SAFE,                                   // 0x75 (u)
    SAFE,                                   // 0x76 (v)
    SAFE,                                   // 0x77 (w)
    SAFE,                                   // 0x78 (x)
    SAFE,                                   // 0x79 (y)
    SAFE,                                   // 0x7A (z)
    UNSAFE,                                 // 0x7B ({)
    UNSAFE,                                 // 0x7C (|)
    UNSAFE,                                 // 0x7D (})
    UNSAFE                                  // 0x7E (~)

    //
    // UNSAFE: 0x7F..0xFF
    //

};


INT ByteCountForLeadUtf8Byte(char ch)
{
    static const int aiByteCountForFirstZero[] = {1,1,2,3,4,5,6,1}; // the final 1 shouldn't happen on a proper UTF-8 string
    
    DWORD dwFirstZeroBit = 0;
    BYTE chMask = 0x80;  //  binary 1000 0000

    //  While the mask reveals a non-zero and we haven't counted zeroes past
    //the range of aiByteCountForLeadNibbleInUtf8[], look for a zero.
    while ((char)chMask & ch 
           && dwFirstZeroBit < ARRAY_ELEMENTS(aiByteCountForFirstZero)-1 )
    {
        dwFirstZeroBit++;
        chMask = chMask >> 1;
    }

    return aiByteCountForFirstZero[dwFirstZeroBit];
}


LPSTR Utf8StrChr( LPSTR pString, LPSTR pEnd, char chTarget)
{
    while( pString < pEnd && *pString != '\0')
    {
        if (*pString == chTarget)
            return pString;

        pString += ByteCountForLeadUtf8Byte(*pString);
    }

    return NULL;
};


LPSTR Utf8StrChrEx( LPSTR pString, LPSTR pEnd, char chTarget1, char chTarget2)
{
    while( pString < pEnd && *pString != '\0')
    {
        if (*pString == chTarget1
            || *pString == chTarget2)
        {
            return pString;
        }

        pString += ByteCountForLeadUtf8Byte(*pString);
    }

    return NULL;
};


//
// UrlSchemeList - the list of schemes that we support
//

typedef struct {
    LPSTR SchemeName;
    DWORD SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD SchemeFlags;
    BOOL NeedSlashes;
    DWORD OpenFlags;
} URL_SCHEME_INFO;


const
PRIVATE
URL_SCHEME_INFO
UrlSchemeList[] = {
    NULL,           0,  INTERNET_SCHEME_DEFAULT,    0,              FALSE,  0,
    "http",         4,  INTERNET_SCHEME_HTTP,       SCHEME_HTTP,    TRUE,   0,
    "https",        5,  INTERNET_SCHEME_HTTPS,      SCHEME_HTTP,    TRUE,   WINHTTP_FLAG_SECURE,
};

#define NUMBER_OF_URL_SCHEMES   ARRAY_ELEMENTS(UrlSchemeList)

BOOL ScanSchemes(LPTSTR pszToCheck, DWORD ccStr, PDWORD pwResult)
{
    for (DWORD i=0; i<NUMBER_OF_URL_SCHEMES; i++)
    {
        if ((UrlSchemeList[i].SchemeLength == ccStr)
            && (strnicmp(UrlSchemeList[i].SchemeName, pszToCheck, ccStr)==0))
        {
            *pwResult = i;
            return TRUE;
        }
    }
    return FALSE;
}

//
// functions
//


BOOL
IsValidUrl(
    IN LPCSTR lpszUrl
    )

/*++

Routine Description:

    Determines whether an URL has a valid format

Arguments:

    lpszUrl - pointer to URL to check.

    Assumes:    1. lpszUrl is non-NULL, non-empty string

Return Value:

    BOOL

--*/

{
    INET_ASSERT(lpszUrl != NULL);
    INET_ASSERT(*lpszUrl != '\0');

    while (*lpszUrl != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszUrl, SCHEME_ANY)) {
            return FALSE;
        }
        ++lpszUrl;
    }
    return TRUE;
}


BOOL
IsValidHostNameW(
    IN LPCWSTR lpwszHostName,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Determines whether an hostname has valid chars in it

Arguments:

    lpwszHostName   - Pointer to hostname to check. Assumes lpwszHostName 
                        is non-NULL and points to a non-empty UNICODE string.

    dwFlags         - Flags that modify validation.  
                      If IVH_DISALLOW_IPV6_SCOPE_ID is set then an IPv6 literal
                      address containing a scope ID will be invalid
                    
Return Value:

    BOOL

--*/

{
    SOCKADDR_IN6 Address;
    INT Error;
    INT AddressLength;
    BOOL bAllowScopeID = ((dwFlags & IVHN_DISALLOW_IPV6_SCOPE_ID) == 0);
    
    INET_ASSERT(lpwszHostName != NULL);

    // first check if this is a valid IPv4 iteral

    AddressLength = (INT)sizeof(Address);
    Error = _I_WSAStringToAddressW((LPWSTR)lpwszHostName, AF_INET, NULL, (LPSOCKADDR)&Address, &AddressLength);

    if (Error == 0) {
        return TRUE; 
    }
    
    // now check if this is a valid IPv6 literal

    AddressLength = sizeof(Address);
    Error = _I_WSAStringToAddressW((LPWSTR)lpwszHostName, AF_INET6, NULL, (LPSOCKADDR)&Address, &AddressLength);

    if (Error == 0) {

        // is an IPv6 literal but we also require surrounding brackets

        if ((*lpwszHostName == L'[') && (*(lpwszHostName+lstrlenW(lpwszHostName)-1) == L']')) {

            // check scope ID situation

            if (bAllowScopeID) {
                return TRUE;
            } else {
                if (Address.sin6_scope_id == 0) {
                    return TRUE;
                }
            }
        }
    }
        
    // not a literal address so do strict bad character checking

    while (*lpwszHostName != L'\0') {
        if (IS_UNSAFE_URL_WIDECHARACTER(*lpwszHostName, HOSTNAME)) {
            return FALSE;
        }
        ++lpwszHostName;
    }
    return TRUE;
}

BOOL
IsValidHostNameA(
    IN LPCSTR lpszHostName,
    IN DWORD   dwFlags
    )

/*++

Routine Description:

    Determines whether an hostname has valid chars in it

Arguments:

    lpszHostName - pointer to Hostname to check.

    lpszHostName   - Pointer to hostname to check. Assumes lpszHostName 
                        is non-NULL and points to a non-empty ASCII string.

    dwFlags         - Flags that modify validation.  
                      If IVH_DISALLOW_IPV6_SCOPE_ID is set then an IPv6 literal
                      address containing a scope ID will be invalid
                    
Return Value:

    BOOL

--*/

{
    SOCKADDR_IN6 Address;
    INT Error;
    INT AddressLength;
    BOOL bAllowScopeID = ((dwFlags & IVHN_DISALLOW_IPV6_SCOPE_ID) == 0);
    
    INET_ASSERT(lpszHostName != NULL);

    // first check if this is a valid IPv4 iteral

    AddressLength = sizeof(Address);
    Error = _I_WSAStringToAddressA((LPSTR)lpszHostName, AF_INET, NULL, (LPSOCKADDR)&Address, &AddressLength);

    if (Error == 0) {
        return TRUE; 
    }
    
    // now check if this is a valid IPv6 literal

    AddressLength = sizeof(Address);
    Error = _I_WSAStringToAddressA((LPSTR)lpszHostName, AF_INET6, NULL, (LPSOCKADDR)&Address, &AddressLength);

    if (Error == 0) {

        // is an IPv6 literal but we also require surrounding brackets

        if ((*lpszHostName == '[') && (*(lpszHostName+lstrlen(lpszHostName)-1) == ']')) {

            // check scope ID situation

            if (bAllowScopeID) {
                return TRUE;
            } else {
                if (Address.sin6_scope_id == 0) {
                    return TRUE;
                }
            }
        }
    }
        
    // not a literal address so do strict bad character checking

    while (*lpszHostName != '\0') {
        if (IS_UNSAFE_URL_CHARACTER(*lpszHostName, HOSTNAME)) {
            return FALSE;
        }
        ++lpszHostName;
    }
    return TRUE;
}


BOOL
DoesSchemeRequireSlashes(
    IN LPSTR lpszScheme,
    IN DWORD dwSchemeLength,
    IN BOOL bHasHostName
    )

/*++

Routine Description:

    Determines whether a protocol scheme requires slashes

Arguments:

    lpszScheme      - pointer to protocol scheme in question
                      (does not include ':' or slashes, just scheme name)

    dwUrlLength     - if not 0, string length of lpszScheme

Return Value:

    BOOL

--*/

{
    DWORD i;

    //
    // if dwSchemeLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwSchemeLength == 0) {
        dwSchemeLength = strlen(lpszScheme);
    }

    if (ScanSchemes(lpszScheme, dwSchemeLength, &i))
    {
        return UrlSchemeList[i].NeedSlashes;
    }
    return bHasHostName;
}


DWORD
CrackUrl(
    IN OUT LPSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN BOOL bEscape,
    OUT LPINTERNET_SCHEME lpSchemeType OPTIONAL,
    OUT LPSTR* lpszSchemeName OPTIONAL,
    OUT LPDWORD lpdwSchemeNameLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    IN  BOOL fUnescapeHostName,
    OUT LPINTERNET_PORT lpServerPort OPTIONAL,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszUrlPath OPTIONAL,
    OUT LPDWORD lpdwUrlPathLength OPTIONAL,
    OUT LPSTR* lpszExtraInfo OPTIONAL,
    OUT LPDWORD lpdwExtraInfoLength OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    Cracks an URL into its constituent parts

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

    bEscape is no longer used/supported and must always be false.

Arguments:

    lpszUrl                 - pointer to URL to crack. This buffer WILL BE
                              OVERWRITTEN if it contains escape sequences that
                              we will convert back to ANSI characters and
                              fUnescapeHostName == TRUE

    dwUrlLength             - if not 0, string length of lpszUrl

    bEscape                 - TRUE if we are to escape the url-path

    lpSchemeType            - returned scheme type - e.g. INTERNET_SCHEME_HTTP

    lpszSchemeName          - returned scheme name

    lpdwSchemeNameLength    - length of scheme name

    lpszHostName            - returned host name

    lpdwHostNameLength      - length of host name buffer

    lpServerPort            - returned server port if present in the URL, else 0

    lpszUserName            - returned user name if present

    lpdwUserNameLength      - length of user name buffer

    lpszPassword            - returned password if present

    lpdwPasswordLength      - length of password buffer

    lpszUrlPath             - returned, canonicalized URL path

    lpdwUrlPathLength       - length of url-path buffer

    lpszExtraInfo           - returned search string or intra-page link if present

    lpdwExtraInfoLength     - length of extra info buffer

    pHavePort               - returned boolean indicating whether port was specified

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_UNRECOGNIZED_SCHEME

--*/

{
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;
    DWORD schemeLength;
    INTERNET_SCHEME schemeType;
    LPSTR pCursor, pEnd;

    if(bEscape)
    {
        INET_ASSERT(!"bEscape==TRUE no longer supported for parseurl.cxx::CrackUrl()");
        error = ERROR_INVALID_PARAMETER;
        goto quit;
    };

    //
    // if dwUrlLength is 0 then lpszUrl is ASCIIZ. Find its length
    //

    if (dwUrlLength == 0) {
        dwUrlLength = strlen(lpszUrl);
    }

    pCursor = lpszUrl;
    pEnd = lpszUrl + dwUrlLength;

    //
    //  extract the scheme   (ex:  "SCHEME://host/path...")
    //
    
    pEnd = Utf8StrChr(pCursor, pEnd, ':');
    if (pEnd == NULL)
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    schemeLength = (DWORD)(pEnd - pCursor);

    //
    //  We now point to the scheme with pCursor.. extract some info about it
    //

    DWORD i;
    int skip;
    BOOL needSlashes;
    BOOL haveSlashes;

    needSlashes = FALSE;
    haveSlashes = FALSE;

    schemeType = INTERNET_SCHEME_UNKNOWN;

    if (ScanSchemes(pCursor, schemeLength, &i))
    {
        schemeType = UrlSchemeList[i].SchemeType;
        needSlashes = UrlSchemeList[i].NeedSlashes;
    }
    else
    {
        error = ERROR_WINHTTP_UNRECOGNIZED_SCHEME;
        goto quit;
    }

    skip = 1;       // skip ':'

    if ((dwUrlLength - schemeLength > 3) && (memcmp(&lpszUrl[schemeLength], "://", 3) == 0))
    {
        skip = 3;   // skip "://"
        haveSlashes = TRUE;
    }

    //
    // If we don't have slashes, make sure we don't need them.
    // If we have slashes, make sure they are required.
    //

    if( (haveSlashes || needSlashes) && !(haveSlashes && needSlashes))
    {
        error = ERROR_WINHTTP_INVALID_URL;
        goto quit;
    }

    //
    //  We've parsed the scheme, so set up that result.
    //
    if (ARGUMENT_PRESENT(lpSchemeType)) {
        *lpSchemeType = schemeType;
    }
    if (ARGUMENT_PRESENT(lpszSchemeName)) {
        *lpszSchemeName = lpszUrl;
        *lpdwSchemeNameLength = schemeLength;
    }

    //
    //  Now crack the rest of the URL
    //
    lpszUrl += schemeLength + skip;
    dwUrlLength -= schemeLength + skip;
   
    error = GetUrlAddress(&lpszUrl,
                          &dwUrlLength,
                          lpszUserName,
                          lpdwUserNameLength,
                          lpszPassword,
                          lpdwPasswordLength,
                          lpszHostName,
                          lpdwHostNameLength,
                          fUnescapeHostName,
                          lpServerPort,
                          pHavePort
                          );

    if (error != ERROR_SUCCESS)
        goto quit;

    if (ARGUMENT_PRESENT(lpszExtraInfo))
    {
        pCursor = Utf8StrChrEx(lpszUrl, lpszUrl+dwUrlLength, '#', '?');
        if (pCursor == NULL)
            pCursor = lpszUrl+dwUrlLength;
        
        *lpszExtraInfo = pCursor;
        *lpdwExtraInfoLength = (DWORD)(lpszUrl+dwUrlLength-pCursor);
        dwUrlLength -= *lpdwExtraInfoLength;
    }

    //
    //  If the user didn't ask for the extra info, it is returned appended to the url path.
    //
    if (ARGUMENT_PRESENT(lpszUrlPath))
    {
        *lpszUrlPath = lpszUrl;
        *lpdwUrlPathLength = dwUrlLength;
    }

quit:

    return error;
}

#define DEFAULT_REALLOC_SIZE 1024

DWORD
EncodeUrlPath(
    IN DWORD Flags,
    IN DWORD SchemeFlags,
    IN LPSTR UrlPath,
    IN DWORD UrlPathLength,
    OUT LPSTR* pEncodedUrlPath,
    IN OUT LPDWORD EncodedUrlPathLength
    )

/*++

Routine Description:

    Encodes an URL-path. That is, escapes the string. Creates a new URL-path in
    which all the 'unsafe' and reserved characters for this scheme have been
    converted to escape sequences

Arguments:

    Flags                   - controlling expansion

    SchemeFlags             - which scheme we are encoding for -
                              SCHEME_HTTP, etc.

    UrlPath                 - pointer to the unescaped string

    UrlPathLength           - length of Url

    EncodedUrlPath          - pointer to buffer where encoded URL will be
                              written

    EncodedUrlPathLength    - IN: size of EncodedUrlPath
                              OUT: number of bytes written to EncodedUrlPath

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_INSUFFICIENT_BUFFER
                    UrlPathLength not large enough to store encoded URL path

--*/

{
    DWORD error;
    DWORD len;

    len = *EncodedUrlPathLength;
    LPSTR EncodedUrlPath = *pEncodedUrlPath;
    UCHAR ch;

    UNREFERENCED_PARAMETER(UrlPathLength);

    while(0 != (ch = (UCHAR)*UrlPath++))
    {
        //
        // check whether this character is safe. For now, we encode all unsafe
        // and scheme-specific characters the same way (i.e. irrespective of
        // scheme)
        //
        // We are allowing '/' to be copied unmodified
        //

        if (len < 3) 
        {
            LPSTR pStr = (LPSTR)REALLOCATE_MEMORY(*pEncodedUrlPath, *EncodedUrlPathLength+DEFAULT_REALLOC_SIZE);

            if (pStr)
            {
                EncodedUrlPath = pStr+*EncodedUrlPathLength-len;
                *pEncodedUrlPath = pStr;
                len += DEFAULT_REALLOC_SIZE;
                *EncodedUrlPathLength += DEFAULT_REALLOC_SIZE;
            }
            else
            {                
                goto error;
            }
        }
        
        if (IS_UNSAFE_URL_CHARACTER(ch, SchemeFlags)
        && !((ch == '/') && (Flags & NO_ENCODE_PATH_SEP))) 
        {
            *EncodedUrlPath++ = '%';
            //*EncodedUrlPath++ = NumberToHexChar((int)ch / 16);
            *EncodedUrlPath++ = (CHAR)NUMBER_TO_HEX_CHAR((int)ch / 16);
            //*EncodedUrlPath++ = NumberToHexChar((int)ch % 16);
            *EncodedUrlPath++ = (CHAR)NUMBER_TO_HEX_CHAR((int)ch % 16);
            len -= 2; // extra --len below
        } 
        else 
        {
            *EncodedUrlPath++ = (signed char)ch;
        }
        --len;
    }
    
    *EncodedUrlPath = '\0';
    *EncodedUrlPathLength -= len;
    error = ERROR_SUCCESS;

quit:
    return error;

error:
    error = ERROR_NOT_ENOUGH_MEMORY;
    goto quit;
}


PRIVATE
char
HexCharToNumber(
    IN char ch
    )

/*++

Routine Description:

    Converts an ANSI character in the range '0'..'9' 'A'..'F' 'a'..'f' to its
    corresponding hexadecimal value (0..f)

Arguments:

    ch  - character to convert

Return Value:

    char
        hexadecimal value of ch, as an 8-bit (signed) character value

--*/

{
    return (CHAR)((ch <= '9') ? (ch - '0')
                       : ((ch >= 'a') ? ((ch - 'a') + 10) : ((ch - 'A') + 10)));
}


PRIVATE
char
NumberToHexChar(
    IN int Number
    )

/*++

Routine Description:

    Converts a number in the range 0..15 to its ASCII character hex representation
    ('0'..'F')

Arguments:

    Number  - to convert

Return Value:

    char
        character in above range

--*/

{
    return (Number <= 9) ? (char)('0' + Number) : (char)('A' + (Number - 10));
}


DWORD
DecodeUrl(
    IN LPSTR Url,
    IN DWORD UrlLength,
    OUT LPSTR DecodedString,
    IN OUT LPDWORD DecodedLength
    )

/*++

Routine Description:

    Converts an URL string with embedded escape sequences (%xx) to a counted
    string

    It is safe to pass the same pointer for the string to convert, and the
    buffer for the converted results: if the current character is not escaped,
    it just gets overwritten, else the input pointer is moved ahead 2 characters
    further than the output pointer, which is benign

Arguments:

    Url             - pointer to URL string to convert

    UrlLength       - number of characters in UrlString

    DecodedString   - pointer to buffer that receives converted string

    DecodedLength   - IN: number of characters in buffer
                      OUT: number of characters converted

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    UrlString couldn't be converted

                  ERROR_INSUFFICIENT_BUFFER
                    ConvertedString isn't large enough to hold all the converted
                    UrlString

--*/

{
    DWORD bufferRemaining;

    bufferRemaining = *DecodedLength;
    while (UrlLength && bufferRemaining) {

        char ch;

        if (*Url == '%') {

            //
            // BUGBUG - would %00 ever appear in an URL?
            //

            ++Url;
            if (isxdigit(*Url)) {
                ch = HexCharToNumber(*Url++) << 4;
                if (isxdigit(*Url)) {
                    ch |= HexCharToNumber(*Url++);
                } else {
                    return ERROR_WINHTTP_INVALID_URL;
                }
            } else {
                return ERROR_WINHTTP_INVALID_URL;
            }
            UrlLength -= 3;
        } else {
            ch = *Url++;
            --UrlLength;
        }
        *DecodedString++ = ch;
        --bufferRemaining;
    }
    if (UrlLength == 0) {
        *DecodedLength -= bufferRemaining;
        return ERROR_SUCCESS;
    } else {
        return ERROR_INSUFFICIENT_BUFFER;
    }
}


DWORD
DecodeUrlInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Decodes an URL string, if it contains escape sequences. The conversion is
    done in place, since we know that a string containing escapes is longer than
    the string with escape sequences (3 bytes) converted to characters (1 byte)

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD stringLength;

    stringLength = *BufferLength;
    if (memchr(BufferAddress, '%', stringLength)) {
        return DecodeUrl(BufferAddress,
                         stringLength,
                         BufferAddress,
                         BufferLength
                         );
    } else {

        //
        // no escape character in the string, just return success
        //

        return ERROR_SUCCESS;
    }
}


DWORD
DecodeUrlStringInSitu(
    IN LPSTR BufferAddress,
    IN OUT LPDWORD BufferLength
    )

/*++

Routine Description:

    Performs DecodeUrlInSitu() on a string and zero terminates it

    Assumes: 1. Even if no decoding is performed, *BufferLength is large enough
                to fit an extra '\0' character

Arguments:

    BufferAddress   - pointer to the string to convert

    BufferLength    - IN: number of characters to convert
                      OUT: length of converted string, excluding '\0'

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                  ERROR_INSUFFICIENT_BUFFER

--*/

{
    DWORD error;

    error = DecodeUrlInSitu(BufferAddress, BufferLength);
    if (error == ERROR_SUCCESS) {
        BufferAddress[*BufferLength] = '\0';
    }
    return error;
}


DWORD
GetUrlAddressInfo(
    IN OUT LPSTR* Url,
    IN OUT LPDWORD UrlLength,
    OUT LPSTR* PartOne,
    OUT LPDWORD PartOneLength,
    OUT LPBOOL PartOneEscape,
    OUT LPSTR* PartTwo,
    OUT LPDWORD PartTwoLength,
    OUT LPBOOL PartTwoEscape
    )

/*++

Routine Description:

    Given a string of the form foo:bar, splits them into 2 counted strings about
    the ':' character. The address string may or may not contain a ':'.

    This function is intended to split into substrings the host:port and
    username:password strings commonly used in Internet address specifications
    and by association, in URLs

    Modified to handle IPv6 literal addresses in URLs surrounded by brackets "[ ]" as per 
    RFC 2732.  Input of "[foo]:bar" is now considered equivalent to "foo:bar".  The brackets 
    ARE returned as part of a string and counted.  
       

Arguments:

    Url             - pointer to pointer to string containing URL. On output
                      this is advanced past the address parts

    UrlLength       - pointer to length of URL in UrlString. On output this is
                      reduced by the number of characters parsed

    PartOne         - pointer which will receive first part of address string

    PartOneLength   - pointer which will receive length of first part of address
                      string

    PartOneEscape   - TRUE on output if PartOne contains escape sequences

    PartTwo         - pointer which will receive second part of address string

    PartTwoLength   - pointer which will receive length of second part of address
                      string

    PartOneEscape   - TRUE on output if PartTwo contains escape sequences

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL

--*/

{
    LPSTR pString;
    LPSTR pColon;
    DWORD partLength;
    LPBOOL partEscape;
    DWORD length;

    //
    // parse out <host>[:<port>] or <name>[:<password>] (i.e. <part1>[:<part2>]
    //

    pString = *Url;
    pColon = NULL;
    partLength = 0;
    *PartOne = pString;
    *PartOneLength = 0;
    *PartOneEscape = FALSE;
    *PartTwoEscape = FALSE;
    partEscape = PartOneEscape;
    length = *UrlLength;
    
    if ((length != 0) && (*pString == '[')) {
        //
        // If the first part starts with a '[' then we assume it's an IPv6 
        // literal address and it must be terminated with a ']'. 
        // 
        // Note we DO NOT output PartOneEscape == TRUE if there is a % in
        // the IPv6 literal address designating a Scope ID.
        //
        *PartOne = pString;
        for (;;) {

            if(*pString & ~0x7F)
                return ERROR_WINHTTP_INVALID_URL;
            
            ++partLength;
            ++pString;
            --length;
            if (length == 0) {
                return ERROR_WINHTTP_INVALID_URL;
            }
            if (*pString == ']') {
                ++partLength;
                break;                    
            }
        }
        ++pString;
        --length;
        //
        // If there's more, then there should be a colon or forward slash
        // We allow http://[addr]/...
        //          http://[addr]:port/...
        // not
        //          http://[addr]junk/...
        //
        if (length != 0) {
            if ((*pString != ':') &&
                (*pString != '/'))
                return ERROR_WINHTTP_INVALID_URL;
        }
    }
    
    while ((*pString != '/') && (*pString != '\0') && (length != 0)) {
        if (*pString == '%') {

            //
            // if there is a % in the string then it *must* (RFC 1738) be the
            // start of an escape sequence. This function just reports the
            // address of the substrings and their lengths; calling functions
            // must handle the escape sequences (i.e. it is their responsibility
            // to decide where to put the results)
            //

            *partEscape = TRUE;
        }
        if (*pString == ':') {
            if (pColon != NULL) {

                //
                // we don't expect more than 1 ':'
                //

                return ERROR_WINHTTP_INVALID_URL;
            }
            pColon = pString;
            *PartOneLength = partLength;
            if (partLength == 0) {
                *PartOne = NULL;
            }
            partLength = 0;
            partEscape = PartTwoEscape;
        } else {
            ++partLength;
        }

        if(*pString & ~0x7F)
            return ERROR_WINHTTP_INVALID_URL;

        ++pString;
        --length;
    }

    //
    // we either ended on the host (or user) name or the port number (or
    // password), one of which we don't know the length of
    //

    if (pColon == NULL) {
        *PartOneLength = partLength;
        *PartTwo = NULL;
        *PartTwoLength = 0;
        *PartTwoEscape = FALSE;
    } else {
        *PartTwoLength = partLength;
        *PartTwo = pColon + 1;

        //
        // in both the <user>:<password> and <host>:<port> cases, we cannot have
        // the second part without the first, although both parts being zero
        // length is OK (host name will be sorted out elsewhere, but (for now,
        // at least) I am allowing <>:<> for username:password, since I don't
        // see it expressly disallowed in the RFC. I may be revisiting this code
        // later...)
        //
        // N.B.: ftp://ftp.microsoft.com uses http://:0/-http-gw-internal-/menu.gif

//      if ((*PartOneLength == 0) && (partLength != 0)) {
//          return ERROR_WINHTTP_INVALID_URL;
//      }
    }

    //
    // update the URL pointer and length remaining
    //

    *Url = pString;
    *UrlLength = length;

    return ERROR_SUCCESS;
}


DWORD
GetUrlAddress(
    IN OUT LPSTR* lpszUrl,
    OUT LPDWORD lpdwUrlLength,
    OUT LPSTR* lpszUserName OPTIONAL,
    OUT LPDWORD lpdwUserNameLength OPTIONAL,
    OUT LPSTR* lpszPassword OPTIONAL,
    OUT LPDWORD lpdwPasswordLength OPTIONAL,
    OUT LPSTR* lpszHostName OPTIONAL,
    OUT LPDWORD lpdwHostNameLength OPTIONAL,
    IN  BOOL fUnescapeHostName,
    OUT LPINTERNET_PORT lpPort OPTIONAL,
    OUT LPBOOL pHavePort
    )

/*++

Routine Description:

    This function extracts any and all parts of the address information for a
    generic URL. If any of the address parts contain escaped characters (%nn)
    then they are converted in situ

    The generic addressing format (RFC 1738) is:

        <user>:<password>@<host>:<port>

    The addressing information cannot contain a password without a user name,
    or a port without a host name
    NB: ftp://ftp.microsoft.com uses URL's that have a port without a host name!
    (e.g. http://:0/-http-gw-internal-/menu.gif)

    Although only the lpszUrl and lpdwUrlLength fields are required, the address
    parts will be checked for presence and completeness

    Assumes: 1. If one of the optional lpsz fields is present (e.g. lpszUserName)
                then the accompanying lpdw field must also be supplied

Arguments:

    lpszUrl             - IN: pointer to the URL to parse
                          OUT: URL remaining after address information

                          N.B. The url-path is NOT canonicalized (unescaped)
                          because it may contain protocol-specific information
                          which must be parsed out by the protocol-specific
                          parser

    lpdwUrlLength       - returned length of the remainder of the URL after the
                          address information

    lpszUserName        - returned pointer to the user name
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpdwUserNameLength  - returned length of the user name part
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user names in the URL

    lpszPassword        - returned pointer to the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpdwPasswordLength  - returned length of the password
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user passwords in the URL

    lpszHostName        - returned pointer to the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpdwHostNameLength  - returned length of the host name
                          This parameter can be omitted by those protocol parsers
                          that do not require the host name info

    lpPort              - returned value of the port field
                          This parameter can be omitted by those protocol parsers
                          that do not require or expect user port number

    pHavePort           - returned boolean indicating whether a port was specified
                          in the URL or not.  This value is not returned if the
                          lpPort parameter is omitted.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_INVALID_URL
                    We could not parse some part of the address info, or we
                    found address info where the protocol parser didn't expect
                    any

                  ERROR_INSUFFICIENT_BUFFER
                    We could not convert an escaped string

--*/

{
    DWORD error = ERROR_WINHTTP_INTERNAL_ERROR;
    
    DWORD urlLength;
    LPSTR pUrl;
    BOOL part1Escape;
    BOOL part2Escape;
    char portNumber[INTERNET_MAX_PORT_NUMBER_LENGTH + 1];
    DWORD portNumberLength;
    LPSTR pPortNumber;
    LPSTR hostName;
    DWORD hostNameLength;

    pUrl = *lpszUrl;
    urlLength = strlen(pUrl);

    char *pHead, *pTail;

    //
    // check to see if there is an '@' separating user name & password. If we
    // see a '/' or get to the end of the string before we see the '@' then
    // there is no username:password part
    //

    char *pAt, *pSlash;

    pHead = pUrl;
    pTail = pHead + urlLength;

    pSlash = Utf8StrChr(pHead, pTail, '/');
    if (pSlash == NULL)
        pSlash = pTail;
    pAt = Utf8StrChr(pHead, pSlash, '@');

    {
        char *pUsername, *pPassword;
        int iUsernameLength, iPasswordLength;
        pUsername = pSlash;
        pPassword = pSlash;
        iUsernameLength = 0;
        iPasswordLength = 0;
        if (pAt != NULL)
        {
            pUsername = pHead;
            pPassword = Utf8StrChr( pUsername, pAt, ':');  //  still a ':' ahead of the actual password..
            if (pPassword == NULL)
                pPassword = pAt;
            iUsernameLength = (DWORD)(pPassword - pUsername);

            if (*pPassword == ':')
                pPassword++;

            iPasswordLength = (DWORD)(pAt - pPassword);

            pHead = pAt + 1;
        }

        if (ARGUMENT_PRESENT(lpszUserName))
        {
            INET_ASSERT(ARGUMENT_PRESENT(lpdwUserNameLength));
            *lpszUserName = pUsername;
            *lpdwUserNameLength = iUsernameLength;
        }

        if (ARGUMENT_PRESENT(lpszPassword))
        {
            INET_ASSERT(ARGUMENT_PRESENT(lpdwPasswordLength));
            *lpszPassword = pPassword;
            *lpdwPasswordLength = iPasswordLength;
        }   
    }
        
    //
    // now get the host name and the optional port
    //

    pUrl = pHead;
    urlLength = (DWORD)(pTail - pHead);

    pPortNumber = portNumber;
    portNumberLength = sizeof(portNumber);
    error = GetUrlAddressInfo(&pUrl,
                              &urlLength,
                              &hostName,
                              &hostNameLength,
                              &part1Escape,
                              &pPortNumber,
                              &portNumberLength,
                              &part2Escape
                              );
    if (error != ERROR_SUCCESS)
        goto done;

    //
    // the URL address information MUST contain the host name
    //

    if ((hostName == NULL) || (hostNameLength == 0))
    {
        error = ERROR_WINHTTP_INVALID_URL;
        goto done;
    }

    if (ARGUMENT_PRESENT(lpszHostName))
    {
        INET_ASSERT(ARGUMENT_PRESENT(lpdwHostNameLength));

        //
        // if the host name contains escaped characters, convert them in situ
        //

        if (part1Escape && fUnescapeHostName)
        {
            error = DecodeUrlInSitu(hostName, &hostNameLength);
            if (error != ERROR_SUCCESS)
                goto done;
        }
        *lpszHostName = hostName;
        *lpdwHostNameLength = hostNameLength;
    }

    //
    // if there is a port field, convert it if there are escaped characters,
    // check it for valid numeric characters, and convert it to a number
    //

    if (portNumberLength != 0)
    {
        DWORD i;
        DWORD port;

        INET_ASSERT(pPortNumber != NULL);

        //
        //  We can ignore part2Escape because below we detect
        //non-digits in the port.
        //

        //
        // ensure all characters in the port number buffer are numeric, and
        // calculate the port number at the same time
        //

        for (i = 0, port = 0; i < portNumberLength; ++i, ++pPortNumber)
        {
            if (!isdigit(*pPortNumber))
            {
                error = ERROR_WINHTTP_INVALID_URL;
                goto done;
            }
            port = port * 10 + (int)(*pPortNumber - '0');
            // We won't allow ports larger than 65535 ((2^16)-1)
            // We have to check this every time to make sure that someone
            // doesn't try to overflow a DWORD.
            if (port > 65535)
            {
                error = ERROR_WINHTTP_INVALID_URL;
                goto done;
            }
        }

        if (ARGUMENT_PRESENT(lpPort))
            *lpPort = (INTERNET_PORT)port;
        if (ARGUMENT_PRESENT(pHavePort))
            *pHavePort = TRUE;
    }
    else
    {
        if (ARGUMENT_PRESENT(lpPort))
            *lpPort = INTERNET_INVALID_PORT_NUMBER;
        if (ARGUMENT_PRESENT(pHavePort))
            *pHavePort = FALSE;
    }

    //
    // update the URL pointer and the length of the url-path
    //

    *lpszUrl = pUrl;
    *lpdwUrlLength = urlLength;

    error = ERROR_SUCCESS;

done:
    return error;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName      - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1) {
        dwSchemeNameLength = (DWORD)lstrlen(lpszSchemeName);
    }

    DWORD i;
    if (ScanSchemes(lpszSchemeName, dwSchemeNameLength, &i))
    {
        return UrlSchemeList[i].SchemeType;
    }
    return INTERNET_SCHEME_UNKNOWN;
}


LPSTR
MapUrlScheme(
    IN INTERNET_SCHEME Scheme,
    OUT LPDWORD lpdwSchemeNameLength
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme                  - enumerated scheme type to map

    lpdwSchemeNameLength    - pointer to returned length of scheme name

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) 
    {
        *lpdwSchemeNameLength = UrlSchemeList[Scheme].SchemeLength;
        return UrlSchemeList[Scheme].SchemeName;
    }
    *lpdwSchemeNameLength = 0;
    return NULL;
}


LPSTR
MapUrlSchemeToName(
    IN INTERNET_SCHEME Scheme
    )

/*++

Routine Description:

    Maps the enumerated scheme name type to the name

Arguments:

    Scheme  - enumerated scheme type to map

Return Value:

    LPSTR   - pointer to scheme name or NULL

--*/

{
    if ((Scheme >= INTERNET_SCHEME_FIRST)
    && (Scheme <= INTERNET_SCHEME_LAST)) {
        return UrlSchemeList[Scheme].SchemeName;
    }
    return NULL;
}




//
//
// UnsafeInPathAndQueryFlags   flag in table set to 1 if symbol is unsafe for path or query
//                             question mark treated as safe
//                             this table is fater then SafetyList because it requires no substraction and no masking
//                             and only one bound checking to access it
//
//
const
PRIVATE
BYTE
UnsafeInPathAndQueryFlags[128] = {
//  00  01  02  03  04  05  06  07  08  09  0a  0b  0c  0d  0e  0f
//  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

//  10  11  12  13  14  15  16  17  18  19  1a  1b  1c  1d  1e  1f
//  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx  xx
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

//  20  21  22  23  24  25  26  27  28  29  2a  2b  2c  2d  2e  2f
//      !   "   #   $   %   &   '   (   )   *   +   ,   -   .   /
    1,  0,  1,  1,  0,  1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  30  31  32  33  34  35  36  37  38  39  3a  3b  3c  3d  3e  3f
//  0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  0,  1,  0,

//  40  41  42  43  44  45  46  47  48  49  4a  4b  4c  4d  4e  4f
//  @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  50  51  52  53  54  55  56  57  58  59  5a  5b  5c  5d  5e  5f
//  P   Q   R   S   T   U   V   W   X   Y   Z   [   \   ]   ^   _
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  0,

//  60  61  62  63  64  65  66  67  68  69  6a  6b  6c  6d  6e  6f
//  `   a   b   c   d   e   f   g   h   i   j   k   l   m   n   o
    1,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

//  70  71  72  73  74  75  76  77  78  79  7a  7b  7c  7d  7e  7f
//  p   q   r   s   t   u   v   w   x   y   z   {   |   }   ~   xx
    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  0,  1
};





//
//
// ADD_HEX_TO_STRING   adds ch in "%hh" format to a given string and increases string ptr
//                     for use inside ConvertUnicodeToMultiByte only
//
//
#define ADD_HEX_TO_STRING(pStr, ch) \
{ UCHAR c = (UCHAR)(ch);\
  *pStr++ = '%'; \
  *pStr++ = hexArray[c>>4]; \
  *pStr++ = hexArray[c & 0x0f]; \
}
//#define ADD_HEX_TO_STRING(pStr, ch) \
//    { UCHAR c = (UCHAR)ch; *(DWORD*)pStr = (DWORD)'%' + ((DWORD)(hexArray[c>>4]) << 8) + ((DWORD)(hexArray[c & 0x0f]) << 16); \
//    pStr += 3; }



/*
 * ConvertUnicodeToMultiByte:
 *

dwFlags: 

    WINHTTP_FLAG_VALID_HOSTNAME         only for server name; fast conversion is performed, no escaping
    WINHTTP_FLAG_NULL_CODEPAGE          assumes string contains only ASCII chars, fast conversion is performed
    WINHTTP_FLAG_ESCAPE_PERCENT         if escaping enabled, escape percent as well
    WINHTTP_FLAG_ESCAPE_DISABLE         disable escaping (if WINHTTP_FLAG_VALID_HOSTNAME not set)
    WINHTTP_FLAG_ESCAPE_DISABLE_QUERY   if escaping enabled escape path part, but do not escape query

 */

DWORD
ConvertUnicodeToMultiByte(
    LPCWSTR lpszObjectName, 
    DWORD dwCodePage, 
    MEMORYPACKET* pmp, 
    DWORD dwFlags)
{
    static CHAR* hexArray = "0123456789ABCDEF";

    DWORD dwError = ERROR_SUCCESS;
    BOOL bPureAscii = TRUE;
    BOOL bTreatPercentAsSafe = (dwFlags & WINHTTP_FLAG_ESCAPE_PERCENT) ? FALSE : TRUE;
    BOOL bNeedEscaping = (dwFlags & WINHTTP_FLAG_ESCAPE_DISABLE) ? FALSE : TRUE;
    BOOL bEscapeQuery = (dwFlags & WINHTTP_FLAG_ESCAPE_DISABLE_QUERY) ? FALSE : TRUE;

//determine size of string and/or safe characters
    DWORD dwUnsafeChars = 0; 
    DWORD dwUnicodeUrlSize;

    if (dwFlags & WINHTTP_FLAG_VALID_HOSTNAME)
    {
        bNeedEscaping = FALSE;

        if (!IsValidHostNameW(lpszObjectName, 0)) {  // 0 == allow v6 literal scope ids
            dwError = ERROR_WINHTTP_INVALID_URL;
            goto done;
        }

        dwUnicodeUrlSize = lstrlenW(lpszObjectName)+1;            

    }
    else if ((dwFlags & WINHTTP_FLAG_NULL_CODEPAGE) && !bNeedEscaping)
    {
        //if no escaping needed there is no need to calcaulate num of unsafe char
        dwUnicodeUrlSize = lstrlenW(lpszObjectName)+1;
    }
    else 
    {
        // optimization to check for unsafe characters, and optimize the common case.
        // calculate the length, and while parsing the string, check if there are unsafeChars
        PCWSTR pwStr;

        if (bTreatPercentAsSafe)
            for(pwStr = lpszObjectName; *pwStr; ++pwStr)
            {
                UINT16 wc = *pwStr;
                if (wc <= 0x7f)
                {
                    if (UnsafeInPathAndQueryFlags[wc] && (wc != L'%'))
                        ++dwUnsafeChars;                
                }
                else
                {
                    bPureAscii = FALSE;
                    ++dwUnsafeChars;
                }
            }
        else
            for(pwStr = lpszObjectName; *pwStr; ++pwStr)
            {
                UINT16 wc = *pwStr;
                if (wc <= 0x7f)
                {
                    if (UnsafeInPathAndQueryFlags[wc])
                        ++dwUnsafeChars;                
                }
                else
                {
                    bPureAscii = FALSE;
                    ++dwUnsafeChars;
                }
            }

        dwUnicodeUrlSize = (DWORD)(pwStr-lpszObjectName+1);
    }

//convert to MBCS
    if (bPureAscii)
    {
        pmp->dwAlloc = dwUnicodeUrlSize;
        if (bNeedEscaping)
            pmp->dwAlloc += 2 * dwUnsafeChars;

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        PSTR pStr = pmp->psStr;
        if (bNeedEscaping)
        {
            UCHAR chPercent = bTreatPercentAsSafe ? (UCHAR)'%' : (UCHAR)0;

            if (bEscapeQuery)
                for (; *lpszObjectName; ++lpszObjectName)
                {
                    UCHAR ch = (UCHAR)*lpszObjectName;
                    if (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent))
                        *pStr++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, ch)
                    }
                }
            else
                for (; *lpszObjectName && (*lpszObjectName != L'?'); ++lpszObjectName)
                {
                    UCHAR ch = (UCHAR)*lpszObjectName;
                    if (!UnsafeInPathAndQueryFlags[ch] || ch == chPercent)
                        *pStr++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, ch)
                    }
                }
        }

        for (; *lpszObjectName; ++lpszObjectName)
            *pStr++ = (CHAR)*lpszObjectName;
        *pStr = '\0';

        pmp->dwSize = (DWORD)(pStr - pmp->psStr);
    }
    else if (dwCodePage == CP_UTF8)
    {
        //converts to UTF8 and performs escaping at same time
        pmp->dwAlloc = dwUnicodeUrlSize + (bNeedEscaping ? 8 : 2) * dwUnsafeChars; //yep, some extra allocation possible

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        PSTR pStr = pmp->psStr;

        if (bNeedEscaping)
        {
            WCHAR wcPercent = bTreatPercentAsSafe ? L'%' : (WCHAR)0;
            WCHAR wcQMark = bEscapeQuery ? (WCHAR)0 : L'?';

            for (; *lpszObjectName && (*lpszObjectName != wcQMark); ++lpszObjectName)
            {
                UINT16 wc = *lpszObjectName;
                if (wc <= 0x007f) // encode to one byte
                {
                    if (!UnsafeInPathAndQueryFlags[wc] || wc == wcPercent)
                        *pStr++ = (CHAR)wc;
                    else
                    {
                        ADD_HEX_TO_STRING (pStr, wc)
                    }
                }
                else if (wc <= 0x07FF) //encode to two bytes
                {
                    ADD_HEX_TO_STRING (pStr, 0xC0 | (wc >> 6))
                    ADD_HEX_TO_STRING (pStr, 0x80 | (wc & 0x3F))
                }
                else //encode to three bytes
                {
                    ADD_HEX_TO_STRING (pStr, 0xe0 | (wc >> 12))
                    ADD_HEX_TO_STRING (pStr, 0x80 | ((wc >> 6) & 0x3F))
                    ADD_HEX_TO_STRING (pStr, 0x80 | (wc & 0x3F))
                }
            }
        }

        for (; *lpszObjectName; ++lpszObjectName)
        {
            UINT16 wc = *lpszObjectName;
            if (wc <= 0x007f) // encode to one byte
            {
                *pStr++ = (CHAR)wc;
            }
            else if (wc <= 0x07FF) //encode to two bytes
            {
                *pStr++ = (CHAR)(0xC0 | (wc >> 6));
                *pStr++ = (CHAR)(0x80 | (wc & 0x3F));
                //*(WORD*)pStr = (WORD)0x80C0 | (wc >> 6) | ((wc & 0x3F) << 8);
                //pStr += 2;
            }
            else //encode to three bytes
            {
                *pStr++ = (CHAR)(0xe0 | (wc >> 12));
                *pStr++ = (CHAR)(0x80 | ((wc >> 6) & 0x3F));
                *pStr++ = (CHAR)(0x80 | (wc & 0x3F));
                //DWORD tmp = 0x8080e0 | (wc >> 12) | ((wc << 2) & 0x3f00) | (((DWORD)wc << 16) & 0x3f0000);
                //*(DWORD*)pStr = tmp;
                //pStr += 3;
            }
        }

        *pStr = '\0';

        pmp->dwSize = (DWORD)(pStr - pmp->psStr);
    }
    else
    {
        //last and final, so not to loose perf don't set dwCodePage to values other then CP_UTF8 :)
        // convert with WideCharToMultiByte()

        pmp->dwAlloc = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, NULL, 0, NULL, NULL);
        if (!pmp->dwAlloc)
        {
            dwError = GetLastError();
            goto done;
        }

        pmp->psStr = (LPSTR)ALLOCATE_FIXED_MEMORY(pmp->dwAlloc);

        if (!pmp->psStr)
        {
            pmp->dwAlloc = 0;
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto done;
        }

        //find out if query is present
        PCHAR pchQMInConverted = NULL;
        DWORD dwQuerySize;
        if (bNeedEscaping)
        {
            WCHAR* pQM = wcschr(lpszObjectName, L'?');
            if (pQM)
            {
                DWORD dwPathSize = 0;
                if (pQM != lpszObjectName)
                {
                    dwPathSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, (DWORD)(pQM - lpszObjectName), pmp->psStr, pmp->dwAlloc, NULL, NULL);
                    
                    if (!dwPathSize)
                    {
                        dwError = GetLastError();
                        goto done;
                    }
                }

                dwQuerySize = WideCharToMultiByte(dwCodePage, 0, pQM,  dwUnicodeUrlSize - (DWORD)(pQM - lpszObjectName), pmp->psStr + dwPathSize, pmp->dwAlloc - dwPathSize, NULL, NULL);

                if (!dwQuerySize)
                {
                    dwError = GetLastError();
                    goto done;
                }

                --dwQuerySize;

                pmp->dwSize = dwPathSize + dwQuerySize;
                pchQMInConverted = pmp->psStr + dwPathSize;
            }
        }

        if (!pchQMInConverted)
        {
            pmp->dwSize = WideCharToMultiByte(dwCodePage, 0, lpszObjectName, dwUnicodeUrlSize, pmp->psStr, pmp->dwAlloc, NULL, NULL);

            if (!pmp->dwSize)
            {
                dwError = GetLastError();
                goto done;
            }
            else
                --(pmp->dwSize); 
        }

        if (bNeedEscaping)
        {
            //collect information about code page
            DWORD dwCharSize = 1;

            if (dwCodePage != CP_UTF7)
            {
                CPINFO CPInfo;
                if (!GetCPInfo(dwCodePage, &CPInfo))
                {
                    dwError = GetLastError();
                    goto done;
                }
                dwCharSize = CPInfo.MaxCharSize;
            }

            UCHAR chPercent = bTreatPercentAsSafe ? '%' : (UCHAR)0;

            if (dwCharSize == 1)
            {
                dwUnsafeChars = 0;

                //calculate number of unsafe chars
                PSTR pStop = pchQMInConverted ? pchQMInConverted : (pmp->psStr + pmp->dwSize);

                PSTR pStr = pmp->psStr;
                //this loop counts unsafe chars in path, count '?' as well
                for(; pStr != pStop; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)) || (ch == '?'))
                        ++dwUnsafeChars;
                }
                //this loop counts unsafe chars in query, do not count '?'
                for(; *pStr; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)))
                        ++dwUnsafeChars;
                }

                if (dwUnsafeChars == 0)
                    goto done;

                //make new allocation
                DWORD dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
                LPSTR pDest, pNewStr;
                pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);
                if (!pDest)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }

                //escaping

                //escape path part
                pStr = pmp->psStr;
                for(; pStr != pStop; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch <= 0x7F) && ((!UnsafeInPathAndQueryFlags[ch] && (ch != '?')) || (ch == chPercent)))
                        *pDest++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pDest, ch)
                    }
                }
                //escape query part
                for(; *pStr; ++pStr)
                {
                    UCHAR ch = *pStr;
                    if ((ch <= 0x7F) && (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent)))
                        *pDest++ = ch;
                    else
                    {
                        ADD_HEX_TO_STRING (pDest, ch)
                    }
                }
                *pDest = '\0';

                FREE_FIXED_MEMORY(pmp->psStr);
                pmp->psStr = pNewStr;
                pmp->dwSize = (DWORD)(pDest-pNewStr);
                pmp->dwAlloc = dwNewAlloc;
            }
            else
            {
                //well, string is mbcs

                dwUnsafeChars = 0;

                //calculate number of unsafe chars
                PSTR pStop = pchQMInConverted ? pchQMInConverted : (pmp->psStr + pmp->dwSize);

                PSTR pStr = pmp->psStr;

                //this loop counts unsafe chars in path, count '?' as well
                while (pStr != pStop)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch] || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                        ch = *pStr;
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch] || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                    else
                    {
                        if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)) || (ch == '?'))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                }
                //this loop counts unsafe chars in query, do not count '?'
                while(*pStr)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch])
                            ++dwUnsafeChars;
                        ++pStr;
                        ch = *pStr;
                        if ((ch > 0x7F) || UnsafeInPathAndQueryFlags[ch])
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                    else
                    {
                        if ((ch > 0x7F) || (UnsafeInPathAndQueryFlags[ch] && (ch != chPercent)))
                            ++dwUnsafeChars;
                        ++pStr;
                    }
                }

                if (dwUnsafeChars == 0)
                    goto done;

                //make new allocation
                DWORD dwNewAlloc = pmp->dwAlloc + dwUnsafeChars*2;
                LPSTR pDest, pNewStr;
                pNewStr = pDest = (LPSTR)ALLOCATE_FIXED_MEMORY(dwNewAlloc);
                if (!pDest)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto done;
                }

                //escaping

                //escape path part
                pStr = pmp->psStr;
                while (pStr != pStop)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch] && (ch != '?'))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                        ch = *pStr;
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch] && (ch != '?'))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                    else
                    {
                        if ((ch <= 0x7F) && ((!UnsafeInPathAndQueryFlags[ch] && (ch != '?')) || (ch == chPercent)))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                }

                //escape query part
                while (*pStr)
                {
                    UCHAR ch = *pStr;
                    if (IsDBCSLeadByteEx(dwCodePage, ch))
                    {
                        //do not allow percent here
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch])
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                        ch = *pStr;
                        if ((ch <= 0x7F) && !UnsafeInPathAndQueryFlags[ch])
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                    else
                    {
                        if ((ch <= 0x7F) && (!UnsafeInPathAndQueryFlags[ch] || (ch == chPercent)))
                            *pDest++ = ch;
                        else
                        {
                            ADD_HEX_TO_STRING (pDest, ch)
                        }
                        ++pStr;
                    }
                }

                *pDest = '\0';

                FREE_FIXED_MEMORY(pmp->psStr);
                pmp->psStr = pNewStr;
                pmp->dwSize = (DWORD)(pDest-pNewStr);
                pmp->dwAlloc = dwNewAlloc;
            }
        }
    }
     
done:
    if (pmp->psStr)
        pmp->dwAlloc = (pmp->dwAlloc > MP_MAX_STACK_USE) ? pmp->dwAlloc : MP_MAX_STACK_USE+1;// to force FREE in ~MEMORYPACKET
        
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\proxreg.cxx ===
#include "wininetp.h"

static const CHAR szRegPathConnections[] = REGSTR_PATH_INTERNET_SETTINGS "\\Connections";




// some winsock stacks fault if we do a gethostbyname(NULL).  If we come
// accross one of these, don't do any more autodetecting.
BOOL g_fGetHostByNameNULLFails = FALSE;

//
// IsConnectionMatch - a worker function to simply some logic elsewhere,
//  it just handles Connection Name Matching.
//

BOOL 
IsConnectionMatch(
    LPCSTR lpszConnection1,
    LPCSTR lpszConnection2)
{
    if ( lpszConnection1 == NULL && 
         lpszConnection2 == NULL) 
    {
        return TRUE;
    }

    if ( lpszConnection1 && lpszConnection2 &&
         stricmp(lpszConnection1, lpszConnection2) == 0 )
    {
        return TRUE;
    }

    return FALSE;
}

///////////////////////////////////////////////////////////////////////////
//
// CRegBlob implementation
//
///////////////////////////////////////////////////////////////////////////

CRegBlob::CRegBlob(
    BOOL fWrite
    )
{
    // initialize members
    _fWrite = fWrite;
    _fCommit = TRUE;
    _dwOffset = 0;
    _pBuffer = NULL;
    _dwBufferLimit = 0;
    _hkey = NULL;
}


CRegBlob::~CRegBlob(
    )
{
    Commit();

    if(_hkey)
        REGCLOSEKEY(_hkey);

    if(_pBuffer)
        FREE_FIXED_MEMORY(_pBuffer);

    // caller owns _pszValue pointer
}


DWORD
CRegBlob::Init(
    HKEY hBaseKey,
    LPCSTR pszSubKey,
    LPCSTR pszValue
    )
{
    long lRes;
    REGSAM  regsam = KEY_QUERY_VALUE;
    DWORD dwDisposition;

    // If we're writing, save reg value name and set access
    if(_fWrite)
    {
        _pszValue = pszValue;
        regsam = KEY_SET_VALUE;

        lRes = REGCREATEKEYEX(hBaseKey, pszSubKey, 0, "", 0,
                    regsam, NULL, &_hkey, &dwDisposition);
    }
    else
    {
        // If not writing, then use RegOpenKeyEx so we don't need
        // registry write permissions.
        lRes = REGOPENKEYEX(hBaseKey, pszSubKey, 0, regsam, &_hkey);
    }

    if(lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // figure out buffer size
    _dwBufferLimit = BLOB_BUFF_GRANULARITY;
    if(FALSE == _fWrite)
    {
        // get size of registry blob
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, NULL, &_dwBufferLimit);
        if(lRes != ERROR_SUCCESS)
        {
            // nothing there - make zero size buffer
            _dwBufferLimit = 0;
        }
    }

    // allocate buffer if necessary
    if(_dwBufferLimit)
    {
        _pBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(_dwBufferLimit);
        if(NULL == _pBuffer)
            return GetLastError();
    }

    // if we're reading, fill in buffer
    if(FALSE == _fWrite && _dwBufferLimit)
    {
        // read reg key
        DWORD dwSize = _dwBufferLimit;
        lRes = RegQueryValueEx(_hkey, pszValue, NULL, NULL, _pBuffer, &dwSize);
        if(lRes != ERROR_SUCCESS)
        {
            return lRes;
        }
    }

    // reset pointer to beginning of blob
    _dwOffset = 0;

    return 0;
}

DWORD
CRegBlob::Abandon(
    VOID
    )
{
    // don't commit changes when the time comes
    _fCommit = FALSE;

    return 0;
}

DWORD
CRegBlob::Commit(
    )
{
    long lres = 0;

    if(_fCommit && _fWrite && _pszValue && _pBuffer)
    {
        // save blob to reg key
        lres = RegSetValueEx(_hkey, _pszValue, 0, REG_BINARY, _pBuffer, _dwOffset);
    }

    return lres;
}


DWORD
CRegBlob::WriteString(
    LPCSTR pszString
    )
{
    DWORD dwBytes, dwLen = 0;

    if(pszString)
    {
        dwLen = lstrlen(pszString);
    }

    dwBytes = WriteBytes(&dwLen, sizeof(DWORD));
    if(dwLen && dwBytes == sizeof(DWORD))
        dwBytes = WriteBytes(pszString, dwLen);

    return dwBytes;
}



DWORD
CRegBlob::ReadString(
    LPCSTR * ppszString
    )
{
    DWORD dwLen, dwBytes = 0;
    LPSTR lpszTemp = NULL;

    dwBytes = ReadBytes(&dwLen, sizeof(DWORD));
    if(dwBytes == sizeof(DWORD))
    {
        if(dwLen)
        {
            lpszTemp = (LPSTR)GlobalAlloc(GPTR, dwLen + 1);
            if(lpszTemp)
            {
                dwBytes = ReadBytes(lpszTemp, dwLen);
                lpszTemp[dwBytes] = 0;
            }
        }
    }

    *ppszString = lpszTemp;
    return dwBytes;
}


DWORD
CRegBlob::WriteBytes(
    LPCVOID pBytes,
    DWORD dwByteCount
    )
{
    BYTE * pNewBuffer;

    // can only do this on write blob
    if(FALSE == _fWrite)
        return 0;

    // grow buffer if necessary
    if(_dwBufferLimit - _dwOffset < dwByteCount)
    {
        DWORD dw = _dwBufferLimit + ((dwByteCount / BLOB_BUFF_GRANULARITY)+1)*BLOB_BUFF_GRANULARITY;
        pNewBuffer = (BYTE *)ALLOCATE_FIXED_MEMORY(dw);
        if(NULL == pNewBuffer)
        {
            // failed to get more memory
            return 0;
        }

        memset(pNewBuffer, 0, dw);
        memcpy(pNewBuffer, _pBuffer, _dwBufferLimit);
        FREE_FIXED_MEMORY(_pBuffer);
        _pBuffer = pNewBuffer;
        _dwBufferLimit = dw;
    }

    // copy callers data to buffer
    memcpy(_pBuffer + _dwOffset, pBytes, dwByteCount);
    _dwOffset += dwByteCount;

    // tell caller how much we wrote
    return dwByteCount;
}



DWORD
CRegBlob::ReadBytes(
    LPVOID pBytes,
    DWORD dwByteCount
    )
{
    DWORD   dwActual = _dwBufferLimit - _dwOffset;

    // can only do this on read blob
    if(_fWrite)
        return 0;

    // don't read past end of blob
    if(dwByteCount < dwActual)
        dwActual = dwByteCount;

    // copy bytes and increment offset
    if(dwActual > 0)
    {
        memcpy(pBytes, _pBuffer + _dwOffset, dwActual);
        _dwOffset += dwActual;
    }

    // tell caller how much we actually read
    return dwActual;
}


//
// Function Declarations
//


DWORD
LoadProxySettings()
/*
** Load global proxy info from registry.
** 
*/
{
    DWORD error;

    //
    // Get proxy struct for proxy object
    //
    INTERNET_PROXY_INFO_EX info;

    memset(&info, 0, sizeof(info));

    info.dwStructSize = sizeof(info);
    info.lpszConnectionName = NULL;

    //
    // Read LAN proxy settings and stuff them into the GlobalProxyInfo object.
    //
    error = ReadProxySettings(&info);

    if (error == ERROR_SUCCESS)
    {
        error = g_pGlobalProxyInfo->SetProxySettings(&info, FALSE);

        info.lpszConnectionName = NULL; // we don't allocate this field
        CleanProxyStruct(&info);
    }

    return error;
}



#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"

HKEY
FindBaseProxyKey(
    VOID
    )
/*
** Determine whether proxy settings live in HKLM or HKCU
**
** WinHttpX is hard-coded to always use HKEY_LOCAL_MACHINE
** 
*/

{
    return HKEY_LOCAL_MACHINE;
}


DWORD
ReadProxySettings(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    HKEY    hBaseKey;

    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "ReadProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        DEBUG_LEAVE(ERROR_INVALID_PARAMETER);
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        pszConnectionName = "WinHttpSettings";
    }

    // figure out base key
    hBaseKey = FindBaseProxyKey();

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = (lRes == ERROR_FILE_NOT_FOUND) ? ERROR_SUCCESS : lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&pInfo->dwStructSize, sizeof(DWORD)) ||
         (pInfo->dwStructSize < sizeof(*pInfo)))
    {
        // blob didn't exist or in correct format - set default values
        pInfo->dwStructSize = sizeof(*pInfo);
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
    }

    //
    // WinHttpX does not support proxy autodection or autoconfig URL's,
    // so make sure those PROXY_TYPE flags are turned off.
    //
    pInfo->dwFlags &= ~(PROXY_TYPE_AUTO_DETECT | PROXY_TYPE_AUTO_PROXY_URL);


    DEBUG_PRINT(PROXY, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>")
                    ));

quit:
    DEBUG_LEAVE(error);
    return error;
}


void
CleanProxyStruct(
    LPINTERNET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    memset(pInfo, 0, sizeof(INTERNET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}


DWORD WriteProxySettings(INTERNET_PROXY_INFO_EX * pInfo)
{
    CRegBlob    r(TRUE);
    DWORD       error = ERROR_SUCCESS;
    long        lRes;

    // verify pInfo
    if(NULL == pInfo || pInfo->dwStructSize != sizeof(INTERNET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // init blob
    lRes = r.Init(HKEY_LOCAL_MACHINE, szRegPathConnections, "WinHttpSettings");
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

    if (r.WriteBytes(&pInfo->dwStructSize, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD)) == 0
        || r.WriteBytes(&pInfo->dwFlags, sizeof(DWORD)) == 0
        || r.WriteString(pInfo->lpszProxy) == 0
        || r.WriteString(pInfo->lpszProxyBypass) == 0)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        r.Abandon();
        goto quit;
    }

    lRes = r.Commit();
    if (lRes)
    {
        error = lRes;
        goto quit;
    }

quit:
    return error;
}


//
// support routines for WinHttpGetIEProxyConfigForCurrentUser API ///////////
//

//
//
// Maximum size of TOKEN_USER information.
//

#define SIZE_OF_TOKEN_INFORMATION                   \
    sizeof( TOKEN_USER )                            \
    + sizeof( SID )                                 \
    + sizeof( ULONG ) * SID_MAX_SUB_AUTHORITIES

#define MAX_SID_STRING 256


// type for RtlConvertSidToUnicodeString, exported from ntdll.dll
typedef NTSTATUS (* PCONVERTSID)(
    PUNICODE_STRING UnicodeString,
    PSID Sid,
    BOOLEAN AllocateDestinationString
    );


//
// Function Declarations
//

BOOL
InitClientUserString (
    LPWSTR pString
    )

/*++

Routine Description:

Arguments:

    pString - output string of current user

Return Value:

    TRUE = success,
    FALSE = fail

    Returns in pString a ansi string if the impersonated client's
    SID can be expanded successfully into  Unicode string. If the conversion
    was unsuccessful, returns FALSE.

--*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Bool,
                 "InitClientUserString",
                 "%#x",
                 pString
                 ));

    HANDLE      TokenHandle;
    UCHAR       TokenInformation[ SIZE_OF_TOKEN_INFORMATION ];
    ULONG       ReturnLength;
    BOOL        Status;
    DWORD       dwLastError;
    UNICODE_STRING UnicodeString;
    HMODULE     hNtDll;
    PCONVERTSID pRtlConvertSid;

    //
    // get RtlConvertSideToUnicodeString entry point in NTDLL
    //
    hNtDll = LoadLibrary("ntdll.dll");
    if(NULL == hNtDll)
    {
        return FALSE;
    }

    pRtlConvertSid = (PCONVERTSID)GetProcAddress(hNtDll, "RtlConvertSidToUnicodeString");
    if(NULL == pRtlConvertSid)
    {
        FreeLibrary(hNtDll);
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // We can use OpenThreadToken because this server thread
    // is impersonating a client
    //
    Status = OpenThreadToken(
                GetCurrentThread(),
                TOKEN_READ,
                TRUE,                // Open as self
                &TokenHandle
                );
    dwLastError = GetLastError();

    if( Status == FALSE )
    {
        DEBUG_PRINT(PROXY, INFO, ("OpenThreadToken() failed: Error=%d\n",
                    dwLastError
                    ));

        Status = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_READ,
                    &TokenHandle
                    );
        dwLastError = GetLastError();

        if( Status == FALSE )
        {
            DEBUG_LEAVE(FALSE);
            return FALSE ;
        }
    }

    //
    // Notice that we've allocated enough space for the
    // TokenInformation structure. so if we fail, we
    // return a NULL pointer indicating failure
    //
    Status = GetTokenInformation( TokenHandle,
                                  TokenUser,
                                  TokenInformation,
                                  sizeof( TokenInformation ),
                                  &ReturnLength
                                   );
    dwLastError = GetLastError();
    CloseHandle( TokenHandle );

    if ( Status == FALSE ) {
        DEBUG_PRINT(PROXY, INFO, ("GetTokenInformation failed: Error=%d\n",
                    dwLastError
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }

    //
    // Convert the Sid (pointed to by pSid) to its
    // equivalent Unicode string representation.
    //

    UnicodeString.Length = 0;
    UnicodeString.MaximumLength = MAX_SID_STRING;
    UnicodeString.Buffer = pString;

    Status = (*pRtlConvertSid)(
                 &UnicodeString,
                 ((PTOKEN_USER)TokenInformation)->User.Sid,
                 FALSE );
    FreeLibrary(hNtDll);

    if( !NT_SUCCESS( Status )){
        DEBUG_PRINT(PROXY, INFO, ("RtlConvertSidToUnicodeString failed: Error=%d\n",
                    Status
                    ));
        DEBUG_LEAVE(FALSE);
        return FALSE;
    }
    
    DEBUG_PRINT(PROXY, INFO, ("User SID = %ws\n",
                pString
                ));

    DEBUG_LEAVE(TRUE);
    return TRUE;
}


HKEY
GetClientUserHandle(
    IN REGSAM samDesired
    )

/*++

Routine Description:

Arguments:

Returns:

---*/

{
    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "GetClientUserHandle",
                 "%#x",
                 samDesired
                 ));

    HKEY   hKeyClient;
    WCHAR  String[MAX_SID_STRING];
    LONG   ReturnValue;

    if (!InitClientUserString(String)) {
        DEBUG_LEAVE(0);
        return NULL ;
    }

    //
    // We now have the Unicode string representation of the
    // local client's Sid we'll use this string to open a handle
    // to the client's key in  the registry.

    ReturnValue = RegOpenKeyExW( HKEY_USERS,
                                 String,
                                 0,
                                 samDesired,
                                 &hKeyClient );

    //
    // If we couldn't get a handle to the local key
    // for some reason, return a NULL handle indicating
    // failure to obtain a handle to the key
    //

    if ( ReturnValue != ERROR_SUCCESS )
    {
        DEBUG_PRINT(PROXY, INFO, ("RegOpenKeyW failed: Error=%d\n",
                    ReturnValue
                    ));

        DEBUG_ERROR(PROXY, ReturnValue);
        SetLastError( ReturnValue );

        DEBUG_LEAVE(0);
        return NULL;
    }

    DEBUG_LEAVE(hKeyClient);
    return( hKeyClient );
}


HKEY
FindWinInetBaseProxyKey(
    VOID
    )

/*
** Determine whether proxy settings live in HKLM or HKCU
**
** Returns HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE
**
** Checks \HKLM\SW\MS\Win\CV\Internet Settings\ProxySettingsPerUser.  If
** exists and is zero, use HKLM otherwise use HKCU.
*/

{
    HKEY hkeyBase = NULL;

    DWORD   dwType, dwValue, dwSize = sizeof(DWORD);

    if (ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, INTERNET_POLICY_KEY,
                TEXT("ProxySettingsPerUser"), &dwType, &dwValue, &dwSize) &&
                0 == dwValue)
    {
        hkeyBase = HKEY_LOCAL_MACHINE;
     }
    else
    {
        //
        // Find an HKCU equivalent for this process
        //
        hkeyBase = GetClientUserHandle(KEY_QUERY_VALUE | KEY_SET_VALUE);

        if (!hkeyBase)
        {
            BOOL fLocalSystem = FALSE;

            if (GlobalIsProcessNtService)
            {
                char    szUserName[32];
                DWORD   cbUserNameSize = sizeof(szUserName);
                
                if (GetUserName(szUserName, &cbUserNameSize))
                {
                    if (0 == lstrcmpi(szUserName, "SYSTEM") ||
                        0 == lstrcmpi(szUserName, "LOCAL SERVICE") || 
                        0 == lstrcmpi(szUserName, "NETWORK SERVICE"))
                    {
                        fLocalSystem = TRUE;
                    }
                }
            }
            
            if (hkeyBase == NULL && !fLocalSystem)
            {
                hkeyBase = HKEY_CURRENT_USER;
            }
        }
    }

    return hkeyBase;
}


DWORD
ReadWinInetProxySettings(
    LPWININET_PROXY_INFO_EX pInfo
    )

{
    CRegBlob r(FALSE);
    LPCSTR  pszConnectionName;
    LPCSTR  pszSavedConnectionName;
    DWORD   error = ERROR_SUCCESS;
    long    lRes;
    BOOL    fLanConnection = FALSE;
    HKEY    hBaseKey = NULL;
    DWORD   dwStructVersion = 0;

    DEBUG_ENTER((DBG_PROXY,
                 Dword,
                 "ReadWinInetProxySettings",
                 "%#x",
                 pInfo
                 ));

    // verify pInfo
    if (NULL == pInfo || pInfo->dwStructSize != sizeof(WININET_PROXY_INFO_EX))
    {
        return ERROR_INVALID_PARAMETER;
    }

    // figure out connection name  (NULL == 'network')
    pszConnectionName = pInfo->lpszConnectionName;
    pszSavedConnectionName = pInfo->lpszConnectionName;
    if(NULL == pszConnectionName || 0 == *pszConnectionName)
    {
        fLanConnection = TRUE;
        pszConnectionName = "DefaultConnectionSettings";
    }

    // figure out base key
    hBaseKey = FindWinInetBaseProxyKey();
    if (hBaseKey == NULL)
    {
        error = ERROR_FILE_NOT_FOUND;
        goto quit;
    }

    // initialize structure
    memset(pInfo, 0, sizeof(*pInfo));
    pInfo->dwStructSize = sizeof(*pInfo);
    pInfo->lpszConnectionName = pszSavedConnectionName;
    pInfo->dwFlags = PROXY_TYPE_DIRECT;

    // init blob
    lRes = r.Init(hBaseKey, szRegPathConnections, pszConnectionName);
    if(lRes)
    {
        error = lRes;
        goto quit;
    }

    // read fields from blob
    if(0 == r.ReadBytes(&dwStructVersion, sizeof(DWORD)) ||
         (dwStructVersion < WININET_PROXY_INFO_EX_VERSION))
    {
        // blob didn't exist or in correct format - set default values

        //
        // All lan connections and overridden dial-ups get autodetect
        //
        if(fLanConnection)
        {
            pInfo->dwFlags |= PROXY_TYPE_AUTO_DETECT;
        }
    }
    else
    {
        // read the rest of the blob
        r.ReadBytes(&pInfo->dwCurrentSettingsVersion, sizeof(DWORD));
        r.ReadBytes(&pInfo->dwFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszProxy);
        r.ReadString(&pInfo->lpszProxyBypass);
        r.ReadString(&pInfo->lpszAutoconfigUrl);
        r.ReadBytes(&pInfo->dwAutoDiscoveryFlags, sizeof(DWORD));
        r.ReadString(&pInfo->lpszLastKnownGoodAutoConfigUrl);

#if 0 // WinHttp does not need the rest of the WinInet proxy config data.
    /*
        r.ReadBytes(&pInfo->ftLastKnownDetectTime, sizeof(FILETIME));

        // read interface ips
        r.ReadBytes(&pInfo->dwDetectedInterfaceIpCount, sizeof(DWORD));
        if(pInfo->dwDetectedInterfaceIpCount)
        {
            pInfo->pdwDetectedInterfaceIp = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD) * pInfo->dwDetectedInterfaceIpCount);
            if(pInfo->pdwDetectedInterfaceIp)
            {
                for(i=0; i<pInfo->dwDetectedInterfaceIpCount; i++)
                {
                    r.ReadBytes(&pInfo->pdwDetectedInterfaceIp[i], sizeof(DWORD));
                }
            }
        }

        r.ReadString(&pInfo->lpszAutoconfigSecondaryUrl);
        r.ReadBytes(&pInfo->dwAutoconfigReloadDelayMins, sizeof(DWORD));
    */
#endif
    }

    DEBUG_PRINT(PROXY, INFO, ("conn=%s, vers=%u, flag=%X, prox=%s, by=%s, acu=%s\n", 
                    pszConnectionName,
                    pInfo->dwCurrentSettingsVersion,
                    pInfo->dwFlags,
                    (pInfo->lpszProxy ? pInfo->lpszProxy : "<none>"),
                    (pInfo->lpszProxyBypass ? pInfo->lpszProxyBypass : "<none>"),
                    (pInfo->lpszAutoconfigUrl ? pInfo->lpszAutoconfigUrl : "<none>")
                    ));

quit:
    if (hBaseKey != NULL &&
        hBaseKey != INVALID_HANDLE_VALUE &&
        hBaseKey != HKEY_LOCAL_MACHINE &&
        hBaseKey != HKEY_CURRENT_USER)
    {
        RegCloseKey(hBaseKey);
    }

    DEBUG_LEAVE(error);
    return error;
}


void
CleanWinInetProxyStruct(
    LPWININET_PROXY_INFO_EX pInfo
    )

{
    if(pInfo->lpszConnectionName)             GlobalFree((LPSTR) pInfo->lpszConnectionName);
    if(pInfo->lpszProxy)                      GlobalFree((LPSTR) pInfo->lpszProxy);
    if(pInfo->lpszProxyBypass)                GlobalFree((LPSTR) pInfo->lpszProxyBypass);
    if(pInfo->lpszAutoconfigUrl)              GlobalFree((LPSTR) pInfo->lpszAutoconfigUrl);
    if(pInfo->lpszLastKnownGoodAutoConfigUrl) GlobalFree((LPSTR) pInfo->lpszLastKnownGoodAutoConfigUrl);
    if(pInfo->pdwDetectedInterfaceIp)         GlobalFree(pInfo->pdwDetectedInterfaceIp);
    memset(pInfo, 0, sizeof(WININET_PROXY_INFO_EX));
    pInfo->dwFlags = PROXY_TYPE_DIRECT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\globals.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    globals.cxx

Abstract:

    Contains global data items for WININET.DLL and initialization function

    Contents:
        GlobalDllInitialize
        GlobalDllTerminate
        GlobalDataInitialize
        GlobalDataTerminate
        IsHttp1_1
        SetOfflineUserState
        GetWininetUserName
        ChangeGlobalSettings

Author:

    Richard L Firth (rfirth) 15-Jul-1995

Revision History:

    15-Jul-1995 rfirth
        Created

    07-Oct-1998 joshco
        updated minor version number 1->2

--*/

#include <wininetp.h>
#include <ntverp.h>
#include <schnlsp.h>
#include <persist.h>
#include "autodial.h"

#ifdef INCLUDE_CACHE
#include "..\urlcache\cache.hxx"
#endif

//
// WinHttpX major & minor versions - allow to be defined externally
//

#if !defined(WINHTTPX_MAJOR_VERSION)
#define WINHTTPX_MAJOR_VERSION   5
#endif
#if !defined(WINHTTPX_MINOR_VERSION)
#define WINHTTPX_MINOR_VERSION   1
#endif

//
// external functions
//

#if INET_DEBUG

VOID
InitDebugSock(
    VOID
    );

#endif


//
// global DLL state data
//

GLOBAL HINSTANCE GlobalDllHandle = NULL;
GLOBAL DWORD GlobalPlatformType;
GLOBAL DWORD GlobalPlatformVersion5;
GLOBAL DWORD GlobalPlatformMillennium = FALSE;
GLOBAL DWORD GlobalPlatformWhistler = FALSE;
GLOBAL DWORD GlobalPlatformDotNet = FALSE;
GLOBAL BOOL GlobalDataInitialized = FALSE;

GLOBAL BOOL GlobalIsProcessNtService = FALSE;

GLOBAL HANDLE g_hCompletionPort = NULL;
GLOBAL LPOVERLAPPED g_lpCustomOverlapped = NULL;
GLOBAL DWORD g_cNumIOCPThreads = 0;

#if INET_DEBUG
LONG g_cWSACompletions = 0;
LONG g_cCustomCompletions = 0;
#endif

#if defined (INCLUDE_CACHE)
GLOBAL LPOVERLAPPED g_lpCustomUserOverlapped = NULL;
#if INET_DEBUG
LONG g_cCustomUserCompletions = 0;
LONG g_cCacheFileCompletions = 0;
#endif
#endif

//
// WinInet DLL version information (mainly for diagnostics)
//

#if !defined(VER_PRODUCTBUILD)
#define VER_PRODUCTBUILD    0
#endif

GLOBAL DWORD InternetBuildNumber = VER_PRODUCTBUILD;

//
// transport-based time-outs, etc.
//

#ifndef unix
GLOBAL const DWORD GlobalConnectTimeout = DEFAULT_CONNECT_TIMEOUT;
#else
GLOBAL const DWORD GlobalConnectTimeout = 1 * 60 * 1000;
#endif /* unix */
GLOBAL const DWORD GlobalResolveTimeout = DEFAULT_RESOLVE_TIMEOUT;
GLOBAL const DWORD GlobalConnectRetries = DEFAULT_CONNECT_RETRIES;
GLOBAL const DWORD GlobalSendTimeout = DEFAULT_SEND_TIMEOUT;
GLOBAL const DWORD GlobalReceiveTimeout = DEFAULT_RECEIVE_TIMEOUT;
GLOBAL const DWORD GlobalReceiveResponseTimeout = DEFAULT_RECEIVE_RESPONSE_TIMEOUT;
GLOBAL const DWORD GlobalTransportPacketLength = DEFAULT_TRANSPORT_PACKET_LENGTH;
GLOBAL const DWORD GlobalKeepAliveSocketTimeout = DEFAULT_KEEP_ALIVE_TIMEOUT;
GLOBAL const DWORD GlobalSocketSendBufferLength = DEFAULT_SOCKET_SEND_BUFFER_LENGTH;
GLOBAL const DWORD GlobalSocketReceiveBufferLength = DEFAULT_SOCKET_RECEIVE_BUFFER_LENGTH;
GLOBAL const DWORD GlobalMaxHttpRedirects = DEFAULT_MAX_HTTP_REDIRECTS;
GLOBAL const DWORD GlobalMaxHttpStatusContinues = 10;
GLOBAL const DWORD GlobalConnectionInactiveTimeout = DEFAULT_CONNECTION_INACTIVE_TIMEOUT;
GLOBAL const DWORD GlobalServerInfoTimeout = DEFAULT_SERVER_INFO_TIMEOUT;
GLOBAL const DWORD GlobalMaxSizeStatusLineResultText = 1024;
GLOBAL const DWORD GlobalMaxHeaderSize = (64 * 1024);
GLOBAL const DWORD GlobalMaxDrainSize = (1000 * 1024);

//
// switches
//

GLOBAL BOOL InDllCleanup = FALSE;
GLOBAL BOOL GlobalDynaUnload = FALSE;

//
// AutoDetect Proxy Globals
//

GLOBAL LONG GlobalInternetOpenHandleCount = -1;
GLOBAL DWORD GlobalProxyVersionCount = 0;
GLOBAL BOOL GlobalAutoProxyInInit = FALSE;
GLOBAL BOOL GlobalAutoProxyCacheEnable = TRUE;
GLOBAL BOOL GlobalDisplayScriptDownloadFailureUI = FALSE;

//
//  Workaround for Novell's Client32
//

GLOBAL const BOOL fDontUseDNSLoadBalancing = FALSE;

//
// lists
//
#if INET_DEBUG
GLOBAL SERIALIZED_LIST GlobalObjectList;
#endif

GLOBAL BOOL GlobalDisableNTLMPreAuth = FALSE;

//
// critical sections
//

GLOBAL CCritSec MlangCritSec;
GLOBAL CCritSec GlobalDataInitCritSec;


// Mlang related data and functions.
PRIVATE HINSTANCE hInstMlang;
PRIVATE PFNINETMULTIBYTETOUNICODE pfnInetMultiByteToUnicode;
PRIVATE BOOL bFailedMlangLoad;  // So we don't try repeatedly if we fail once.
BOOL LoadMlang( );
BOOL UnloadMlang( );
#define MLANGDLLNAME    "mlang.dll"


//
// novell client32 (hack) "support"
//

GLOBAL BOOL GlobalRunningNovellClient32 = FALSE;
GLOBAL const BOOL GlobalNonBlockingClient32 = FALSE;

//
// proxy info
//

GLOBAL PROXY_INFO_GLOBAL * g_pGlobalProxyInfo;

//
// DLL version info
//

GLOBAL INTERNET_VERSION_INFO InternetVersionInfo = {
    WINHTTPX_MAJOR_VERSION,
    WINHTTPX_MINOR_VERSION
};

//
// HTTP version info - default 1.1
//

GLOBAL HTTP_VERSION_INFO HttpVersionInfo = {1, 1};


GLOBAL BOOL fCdromDialogActive = FALSE; // this needs to go

//
// The following globals are literal strings passed to winsock.
// Do NOT make them const, otherwise they end up in .text section,
// and web release of winsock2 has a bug where it locks and dirties
// send buffers, confusing the win95 vmm and resulting in code
// getting corrupted when it is paged back in.  -RajeevD
//

GLOBAL char gszAt[]   = "@";
GLOBAL char gszBang[] = "!";
GLOBAL char gszCRLF[] = "\r\n";

GLOBAL LONG g_cSessionCount=0;
GLOBAL CAsyncCount* g_pAsyncCount = NULL;

// implemented in ihttprequest\httprequest.cxx:
extern void CleanupWinHttpRequestGlobals();


//
// functions
//

#if 0 
/*
BOOL AddEventSource(void)
{
    HKEY hKey; 
    DWORD dwData; 
    CHAR szBuf[80];
    DWORD dwDispo;
    // Add your source name as a subkey under the Application 
    // key in the EventLog registry key. 
 
    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE, 
                        "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\WinHttp",
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDispo) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    if (dwDispo == REG_OPENED_EXISTING_KEY)
    {
        RegCloseKey(hKey); 
        return TRUE;
    }
 
    // Set the name of the message file. 
 
    strcpy(szBuf, "%SystemRoot%\\System32\\WinHttp.dll"); 
 
    // Add the name to the EventMessageFile subkey. 
 
    if (RegSetValueEx(hKey,             // subkey handle 
            "EventMessageFile",       // value name 
            0,                        // must be zero 
            REG_EXPAND_SZ,            // value type 
            (LPBYTE) szBuf,           // pointer to value data 
            strlen(szBuf) + 1) != ERROR_SUCCESS)       // length of value data
    {
        RegCloseKey(hKey); 
        return FALSE;
    }
 
    // Set the supported event types in the TypesSupported subkey. 
 
    dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | 
        EVENTLOG_INFORMATION_TYPE; 
 
    if (RegSetValueEx(hKey,      // subkey handle 
            "TypesSupported",  // value name 
            0,                 // must be zero 
            REG_DWORD,         // value type 
            (LPBYTE) &dwData,  // pointer to value data 
            sizeof(DWORD)) != ERROR_SUCCESS)    // length of value data 
    {
        RegCloseKey(hKey); 
        return FALSE;
    }

    RegCloseKey(hKey);
    return TRUE;
} 

HANDLE g_hEventLog = 0;

BOOL InitializeEventLog(void)
{
    if (AddEventSource() == FALSE)
    {
        return FALSE;
    }

    g_hEventLog = ::RegisterEventSourceA(NULL, "WinHttp");

    return g_hEventLog != NULL;
}

void TerminateEventLog(void)
{
    if (g_hEventLog)
    {
        ::DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
}
*/
#endif


#ifdef UNIX
extern "C"
#endif /* UNIX */
BOOL
GlobalDllInitialize(
    VOID
    )

/*++

Routine Description:

    The set of initializations - critical sections, etc. - that must be done at
    DLL_PROCESS_ATTACH

Arguments:

    None.

Return Value:

    TRUE, only FALSE when not enough memory to initialize globals

--*/

{
    BOOL fResult = FALSE;
    
    DEBUG_ENTER((DBG_GLOBAL,
                 Bool,
                 "GlobalDllInitialize",
                 NULL
                 ));

    CLEAR_DEBUG_CRIT(szDebugBlankBuffer);

    if (MlangCritSec.Init() &&
#if INET_DEBUG
        InitializeSerializedList(&GlobalObjectList) &&
#endif
        AuthOpen() &&
        IwinsockInitialize() &&
        SecurityInitialize() &&
        GlobalDataInitCritSec.Init() &&
        DIGEST_CTX::s_CritSection.Init()
#ifdef INCLUDE_CACHE
        &&
        DLLUrlCacheEntry(DLL_PROCESS_ATTACH)
#endif
        )
    {
        fResult = TRUE;
    }

    DEBUG_LEAVE(fResult);
    return fResult;
}


#ifdef UNIX
extern "C"
#endif /* UNIX */
VOID
GlobalDllTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes the initializations of GlobalDllInitialize

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDllTerminate",
                 NULL
                 ));

    //
    // only perform resource clean-up if this DLL is being unloaded due to a
    // FreeLibrary() call. Otherwise, we take the lazy way out and let the
    // system clean up after us
    //

    if (GlobalDynaUnload) {
        TerminateAsyncSupport(TRUE);
        IwinsockTerminate();
        HandleTerminate();
    }

    CHECK_SOCKETS();

    AuthClose();

    CTracer::s_CritSectionTraceInit.FreeLock();

#if INET_DEBUG
    //
    //BUGBUG: we can't Terminate the list here because
    //        of a race condition from IE3
    //        (someone still holds the handle)
    //        but we don't want to leak the CritSec
    //        TerminateSerlizedList == DeleteCritSec + some Asserts
    //
    //TerminateSerializedList(&GlobalObjectList);
    GlobalObjectList.Lock.FreeLock();
#endif

    MlangCritSec.FreeLock();

    GlobalDataInitCritSec.FreeLock();
    DIGEST_CTX::s_CritSection.FreeLock();
    
    SecurityTerminate();

    DLOleTerminate();

#ifdef INCLUDE_CACHE
    DLLUrlCacheEntry(DLL_PROCESS_DETACH);
#endif

    //Close this here because keepalive sync sockets may depend on it.
    if (g_hCompletionPort)
    {
        CloseHandle(g_hCompletionPort);
        g_hCompletionPort = NULL;
    }

    if (g_lpCustomOverlapped)
    {
        delete g_lpCustomOverlapped;
        g_lpCustomOverlapped = NULL;
    }

#if defined (INCLUDE_CACHE)
    if (g_lpCustomUserOverlapped)
    {
        delete g_lpCustomUserOverlapped;
        g_lpCustomUserOverlapped = NULL;
    }
#endif

    DEBUG_LEAVE(0);
}


DWORD
GlobalDataInitialize(
    VOID
    )

/*++

Routine Description:

    Loads any global data items from the registry

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 Dword,
                 "GlobalDataInitialize",
                 NULL
                 ));

    static BOOL Initializing = FALSE;
    static BOOL Initialized = FALSE;
    static DWORD error = ERROR_SUCCESS;
    
    //
    // only one thread initializes
    //

    if (!GlobalDataInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }

    if (Initializing) 
    {
        //if re-entered on same thread, fail.
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto leave;
    }
    else if (GlobalDataInitialized)
    {
        //else some other thread succeeded, and we can fall out.
        error = ERROR_SUCCESS;
        goto leave;
    }
    else if (Initialized)
    {
        //else if we've failed initialization for non-entrancy reasons, don't reattempt
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto leave;
    }

    Initializing = TRUE;

    //Ensure that the GlobalDataInitCritSec function is never abandoned.
    __try
    {
        //
        // create the global proxy lists
        //

        INET_ASSERT(g_pGlobalProxyInfo==NULL);
        g_pGlobalProxyInfo = New PROXY_INFO_GLOBAL();

        if (!g_pGlobalProxyInfo)
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
            goto quit;
        }

        g_pGlobalProxyInfo->InitializeProxySettings();

        //
        // Load proxy config settings from registry...
        //
        error = LoadProxySettings();

        if (error != ERROR_SUCCESS)
            goto quit;

        //
        // perform module/package-specific initialization
        //

        error = HandleInitialize();
        if (error != ERROR_SUCCESS) {
            goto quit;
        }

        g_pGlobalServerInfoPool = New CGlobalServerInfoPool();

        if (!g_pGlobalServerInfoPool
            || !g_pGlobalServerInfoPool->Initialize())
        {
            error = ERROR_NOT_ENOUGH_MEMORY;
        }

        char buf[MAX_PATH + 1];

        if (GetModuleFileName(NULL, buf, sizeof(buf)-1)) // leave room for null char
        {
            buf[sizeof(buf)-1] = '\0'; // guarantee null-termination
            LPSTR p = strrchr(buf, DIR_SEPARATOR_CHAR);
            p = p ? ++p : buf;

            DEBUG_PRINT(GLOBAL, INFO, ("process is %q\n", p));

            if (!lstrcmpi(p, "SVCHOST.EXE") || !lstrcmpi(p, "SERVICES.EXE"))
            {
                GlobalIsProcessNtService = TRUE;
            }
        }
        else
        {
            DEBUG_PRINT(GLOBAL,
                        INFO,
                        ("GetModuleFileName() returns %d\n",
                        GetLastError()
                        ));
        }

        XStringInitialize();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto leave_change_state;
    }
    ENDEXCEPT
    
quit:

    if (error == ERROR_SUCCESS) {
        GlobalDataInitialized = TRUE;
    }
    
leave_change_state:


    //
    // irrespective of success or failure, we have attempted global data
    // initialization. If we failed then we assume its something fundamental
    // and fatal: we don't try again
    //

    Initialized = TRUE;
    Initializing = FALSE;

//jump here if you grabbed GlobalDataInitCritSec but don't want to affect Init*
leave:

    GlobalDataInitCritSec.Unlock();

//jump here IFF you didn't grab GlobalDataInitCritSec
done:

    DEBUG_LEAVE(error);

    return error;
}



VOID
GlobalDataTerminate(
    VOID
    )

/*++

Routine Description:

    Undoes work of GlobalDataInitialize()

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "GlobalDataTerminate",
                 NULL
                 ));

    RIP(g_cSessionCount == 0);
#ifndef WININET_SERVER_CORE
    //
    // Release background task manager
    //
    UnloadBackgroundTaskMgr();
#endif

    AuthUnload();

    //
    // terminate the global proxy lists
    //

    if (g_pGlobalProxyInfo)
    {
        g_pGlobalProxyInfo->TerminateProxySettings();
        delete g_pGlobalProxyInfo;
        g_pGlobalProxyInfo = NULL;
    }

    if (g_pGlobalServerInfoPool)
    {
        g_pGlobalServerInfoPool->Terminate();
        delete g_pGlobalServerInfoPool;
        g_pGlobalServerInfoPool = NULL;
    }

    UnloadMlang();
    UnloadSecurity();
    UnloadAutoProxy();

    ExitAutodialModule();

    CleanupWinHttpRequestGlobals();

    XStringUninitialize();

    UnloadWinsock(TRUE);

    GlobalDataInitialized = FALSE;

    DEBUG_LEAVE(0);
}


BOOL
IsHttp1_1(
    VOID
    )

/*++

Routine Description:

    Determine if we are using HTTP 1.1 or greater

Arguments:

    None.

Return Value:

    BOOL

--*/

{
    return (HttpVersionInfo.dwMajorVersion > 1)
            ? TRUE
            : (((HttpVersionInfo.dwMajorVersion == 1)
                && (HttpVersionInfo.dwMajorVersion >= 1))
                ? TRUE
                : FALSE);
}



VOID
ChangeGlobalSettings(
    VOID
    )

/*++

Routine Description:

    Changes global settings

Arguments:

    None.

Return Value:

    None.

--*/

{
    DEBUG_ENTER((DBG_GLOBAL,
                 None,
                 "ChangeGlobalSettings",
                 NULL
                 ));

    DEBUG_LEAVE(0);
}



// Loads Mlang.dll and get the entry point we are interested in.

BOOL LoadMlang( )
{
    if (!MlangCritSec.Lock())
        goto quit;

    if (hInstMlang == NULL && !bFailedMlangLoad)
    {
        INET_ASSERT(pfnInetMultiByteToUnicode == NULL);
        hInstMlang = LoadLibrary(MLANGDLLNAME);

        if (hInstMlang != NULL)
        {
            pfnInetMultiByteToUnicode = (PFNINETMULTIBYTETOUNICODE)GetProcAddress
                                            (hInstMlang,"ConvertINetMultiByteToUnicode");
            if (pfnInetMultiByteToUnicode == NULL)
            {
                INET_ASSERT(FALSE);
                FreeLibrary(hInstMlang);
                hInstMlang = NULL;
            }
        }
        else
        {
            INET_ASSERT(FALSE); // bad news if we can't load mlang.dll
        }

        if (pfnInetMultiByteToUnicode == NULL)
            bFailedMlangLoad = TRUE;
    }

    MlangCritSec.Unlock();

quit:
    return (pfnInetMultiByteToUnicode != NULL);
}

BOOL UnloadMlang( )
{
    if (!MlangCritSec.Lock())
        return FALSE;

    if (hInstMlang)
        FreeLibrary(hInstMlang);

    hInstMlang = NULL;
    pfnInetMultiByteToUnicode = NULL;
    bFailedMlangLoad = FALSE;

    MlangCritSec.Unlock();

    return TRUE;
}

PFNINETMULTIBYTETOUNICODE GetInetMultiByteToUnicode( )
{
    // We are checking for pfnInetMultiByteToUnicode without getting a crit section.
    // This works only because UnloadMlang is called at the Dll unload time.

    if (pfnInetMultiByteToUnicode == NULL)
    {
        LoadMlang( );
    }

    return pfnInetMultiByteToUnicode;
}


#if 0
/*
int cdecl _sprintf(char* buffer, char* format, va_list args);

void LOG_EVENT(DWORD dwEventType, char* format, ...)
{
    if (g_hEventLog == NULL)
    {
        return;
    }

    va_list args;
    int n;
    char *pBuffer = (char *) ALLOCATE_FIXED_MEMORY(1024);

    if (pBuffer == NULL)
        return;

    va_start(args, format);
    n = _sprintf(pBuffer, format, args);
    va_end(args);
    
    LPCSTR pszMessages[1];
    pszMessages[0] = &pBuffer[0];

    ::ReportEvent(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventType,
                  NULL,
                  1,
                  0,
                  &pszMessages[0],
                  NULL);

    FREE_MEMORY(pBuffer);
}
*/
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\options.cxx ===
/*++

Copyright (c) 1994-98  Microsoft Corporation

Module Name:

    options.cxx

Abstract:

    Contains the Internet*Option APIs

    Contents:
        InternetQueryOptionA
        InternetSetOptionA
        WinHttpQueryOption
        WinHttpSetOption
        (FValidCacheHandleType)

Author:

    Richard L Firth (rfirth) 02-Mar-1995

Environment:

    Win32 user-mode DLL

Revision History:

    02-Mar-1995 rfirth
        Created

    07-Mar-1995 madana

    07-Jul-1998 Forked by akabir

--*/

#include <wininetp.h>
#include <perfdiag.hxx>
#include "msident.h"

//
// private macros
//

//
// IS_PER_THREAD_OPTION - options applicable to the thread (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_THREAD_OPTION(option) ((                     \
       ((option) == WINHTTP_OPTION_EXTENDED_ERROR)         \
    ) ? TRUE : FALSE)

//
// IS_PER_PROCESS_OPTION - options applicable to the process (HINTERNET is NULL).
// Subset of IS_VALID_OPTION()
//

#define IS_PER_PROCESS_OPTION(option)                       \
    (( ((option) == WINHTTP_OPTION_GET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_SET_DEBUG_INFO)         \
    || ((option) == WINHTTP_OPTION_GET_HANDLE_COUNT)       \
    || ((option) == WINHTTP_OPTION_PROXY)                  \
    || ((option) == WINHTTP_OPTION_VERSION)                \
    || ((option) == WINHTTP_OPTION_HTTP_VERSION)           \
    || ((option) == WINHTTP_OPTION_WORKER_THREAD_COUNT) \
    ) ? TRUE : FALSE)

//
// IS_DEBUG_OPTION - the set of debug-specific options
//

#define IS_DEBUG_OPTION(option)                     \
    (( ((option) >= INTERNET_FIRST_DEBUG_OPTION)    \
    && ((option) <= INTERNET_LAST_DEBUG_OPTION)     \
    ) ? TRUE : FALSE)

//
// IS_VALID_OPTION - the set of known option values, for a HINTERNET, thread, or
// process. In the retail version, debug options are invalid
//

#if INET_DEBUG

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    || IS_DEBUG_OPTION(option)              \
    ) ? TRUE : FALSE)

#else

#define IS_VALID_OPTION(option)             \
    (((((option) >= WINHTTP_FIRST_OPTION)  \
    && ((option) <= WINHTTP_LAST_OPTION_INTERNAL))  \
    ) ? TRUE : FALSE)

#endif // INET_DEBUG

//
// private prototypes
//
PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    );

PRIVATE
VOID
InitIPCOList(LPINTERNET_PER_CONN_OPTION_LISTW plistW, LPINTERNET_PER_CONN_OPTION_LISTA plistA)
{
    plistA->dwSize = sizeof(INTERNET_PER_CONN_OPTION_LISTA);
    plistA->dwOptionCount = plistW->dwOptionCount;
    if (plistW->pszConnection && *plistW->pszConnection)
    {
        SHUnicodeToAnsi(plistW->pszConnection, plistA->pszConnection, RAS_MaxEntryName + 1);
    }
    else
    {
        plistA->pszConnection = NULL;
    }
}

//
// functions
//


INTERNETAPI
BOOL
WINAPI
InternetQueryOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    Returns information about various handle-specific variables

Arguments:

    hInternet           - handle of object for which information will be
                          returned

    dwOption            - the handle-specific WINHTTP_OPTION to query

    lpBuffer            - pointer to a buffer which will receive results

    lpdwBufferLength    - IN: number of bytes available in lpBuffer
                          OUT: number of bytes returned in lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_INSUFFICIENT_BUFFER
                        lpBuffer is not large enough to hold the requested
                        information; *lpdwBufferLength contains the number of
                        bytes needed

                    ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                        The handle is the wrong type for the requested option

                    ERROR_WINHTTP_INVALID_OPTION
                        The option is unrecognized

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetQueryOptionA",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD error;
    BOOL success;
    HINTERNET_HANDLE_TYPE handleType = (HINTERNET_HANDLE_TYPE)0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize = 0;
    LPVOID lpSource = NULL;
    DWORD dwValue;
    DWORD_PTR dwPtrValue;
    HINTERNET hObjectMapped = NULL;
    BOOL isString = FALSE;
    BOOL freeString = FALSE;
    // INTERNET_DIAGNOSTIC_SOCKET_INFO socketInfo;

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // validate parameters
    //

    INET_ASSERT(lpdwBufferLength);

    if (!ARGUMENT_PRESENT(lpBuffer)) {
        *lpdwBufferLength = 0;
    }

    //
    // validate the handle and get its type
    //

    HINTERNET hOriginal;

    hOriginal = hInternet;
    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    //
    // if the option and handle combination is valid then query the option value
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pReq;
    switch(handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet;
            break;
        default:
            pReq = NULL;
            break;
    }
        
    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else
        {
            lpSource = pReq->GetProp (dwOption);
            isString = TRUE;
            error = ERROR_SUCCESS;
            freeString = (lpSource != NULL);
            goto copy;
        }
        goto quit;
    }

    //  ensure SSL is loaded if this is an SSL related option
    switch (dwOption)
    {
    case WINHTTP_OPTION_CLIENT_CERT_CONTEXT:
    case WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT:
    case WINHTTP_OPTION_SERVER_CERT_CONTEXT:
        // Make sure SSL is loaded now
        error = LoadSecurity();
        if (ERROR_SUCCESS != error)
        {
            goto quit;
        }
    };
    
    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
        requiredSize = sizeof(WINHTTP_STATUS_CALLBACK);
        if (hInternet != NULL) {
            error = RGetStatusCallback(hInternet,
                                       (LPWINHTTP_STATUS_CALLBACK)&dwValue
                                       );
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_INVALID_HANDLE;
        }
        break;

    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
        requiredSize = sizeof(DWORD);

        //
        // remember hInternet in the INTERNET_THREAD_INFO then call
        // GetTimeoutValue(). If hInternet refers to a valid Internet
        // object handle, then the relevant timeout value will be
        // returned from that, else we will return the global value
        // corresponding to the requested option
        //

        InternetSetObjectHandle(hOriginal, hInternet);
        dwValue = GetTimeoutValue(dwOption);
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_REDIRECT_POLICY:
    case WINHTTP_OPTION_AUTOLOGON_POLICY:
    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
    case WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE:
    case WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE:
    case WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE:

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->GetDwordOption(dwOption, &dwValue) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            else
            {
                requiredSize = sizeof(DWORD);
                lpSource = (LPVOID)&dwValue;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->GetDwordOption(dwOption);
            requiredSize = sizeof(DWORD);
            lpSource = (LPVOID)&dwValue;
            break;

        default:

            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_HANDLE_TYPE:

        requiredSize = sizeof(dwValue);
        switch (handleType)
        {
        case TypeInternetHandle:
            dwValue = WINHTTP_HANDLE_TYPE_SESSION;
            break;

        case TypeHttpConnectHandle:
            dwValue = WINHTTP_HANDLE_TYPE_CONNECT;
            break;

        case TypeHttpRequestHandle:
            dwValue = WINHTTP_HANDLE_TYPE_REQUEST;
            break;

        default:
            error = ERROR_WINHTTP_INTERNAL_ERROR;
            break;
        }
        lpSource = (LPVOID)&dwValue;
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:
        requiredSize = sizeof(DWORD_PTR);
        error = RGetContext(hInternet, &dwPtrValue);
        lpSource = (LPVOID)&dwPtrValue;
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
    
        if (pReq)
        {
            requiredSize = sizeof(DWORD);
            error = ERROR_SUCCESS;
            dwValue = pReq->GetBufferSize(dwOption);
            lpSource = (LPVOID)&dwValue;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PARENT_HANDLE:
        hInternet = ((HANDLE_OBJECT *)hInternet)->GetParent();
        if (hInternet != NULL) {
            hInternet = ((HANDLE_OBJECT *)hInternet)->GetPseudoHandle();
        }
        requiredSize = sizeof(hInternet);
        lpSource = (LPVOID)&hInternet;
        break;

    case WINHTTP_OPTION_EXTENDED_ERROR:
        requiredSize = sizeof(lpThreadInfo->dwMappedErrorCode);
        lpSource = (LPVOID)&lpThreadInfo->dwMappedErrorCode;
        break;
    
    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            dwValue = lphHttpRqst->GetSecureFlags();

            DEBUG_PRINT(INET,
                        INFO,
                        ("SECURITY_FLAGS: %X\n",
                        dwValue
                        ));


            error = ERROR_SUCCESS;
        }

        break;

   
    case WINHTTP_OPTION_URL:

        //
        // return the URL associated with the request handle. This may be
        // different from the original URL due to redirections
        //

        if (pReq)
        {

            //
            // only these handle types (retrieved object handles) can have
            // associated URLs
            //

            lpSource = pReq->GetURL();
            isString = TRUE;

            INET_ASSERT(error == ERROR_SUCCESS);

        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;


    case WINHTTP_OPTION_SECURITY_CONNECTION_INFO:
        //
        // Caller is expected to pass in an INTERNET_SECURITY_CONNECTION_INFO structure.

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_SECURITY_CONNECTION_INFO)) {
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            LPINTERNET_SECURITY_CONNECTION_INFO lpSecConnInfo;
            INTERNET_SECURITY_INFO ciInfo;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *)hInternet;
            lpSecConnInfo = (LPINTERNET_SECURITY_CONNECTION_INFO)lpBuffer;
            requiredSize = sizeof(INTERNET_SECURITY_CONNECTION_INFO);

            if ((error = lphHttpRqst->GetSecurityInfo(&ciInfo)) == ERROR_SUCCESS) {
                // Set up that data members in the structure passed in.
                lpSecConnInfo->fSecure = TRUE;

                lpSecConnInfo->dwProtocol = ciInfo.dwProtocol;
                lpSecConnInfo->aiCipher = ciInfo.aiCipher;
                lpSecConnInfo->dwCipherStrength = ciInfo.dwCipherStrength;
                lpSecConnInfo->aiHash = ciInfo.aiHash;
                lpSecConnInfo->dwHashStrength = ciInfo.dwHashStrength;
                lpSecConnInfo->aiExch = ciInfo.aiExch;
                lpSecConnInfo->dwExchStrength = ciInfo.dwExchStrength;

                if (ciInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                          GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                          (ciInfo.pCertificate));
                }

            } else if (error == ERROR_WINHTTP_INTERNAL_ERROR)  {
                // This implies we are not secure.
                error = ERROR_SUCCESS;
                lpSecConnInfo->fSecure = FALSE;
            }

            lpSecConnInfo->dwSize = requiredSize;
            *lpdwBufferLength = requiredSize;
        }

        goto quit;


    case WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT:

        //
        // Allocates memory that caller is expected to free.
        //

        if (handleType != TypeHttpRequestHandle) {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        } else if (*lpdwBufferLength < (DWORD)sizeof(INTERNET_CERTIFICATE_INFO)) {
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(INTERNET_CERTIFICATE_INFO);

            if( !(lphHttpRqst->GetOpenFlags() & WINHTTP_FLAG_SECURE))
            {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
                goto quit;
            }

            if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
            {
                error = ConvertSecurityInfoIntoCertInfoStruct(&cInfo, (LPINTERNET_CERTIFICATE_INFO)lpBuffer, lpdwBufferLength);
                if(cInfo.pCertificate)
                {
                    WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                          GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                          (cInfo.pCertificate));
                }
                goto quit;
            }
            else
            {
                error = ERROR_INVALID_OPERATION;
            }
        }
        break;

    case WINHTTP_OPTION_SERVER_CERT_CONTEXT:
        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (*lpdwBufferLength < (DWORD)sizeof(PCCERT_CONTEXT))
        {
            requiredSize = sizeof(PCCERT_CONTEXT);
            *lpdwBufferLength = requiredSize;
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO cInfo;
            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            requiredSize = sizeof(PCERT_CONTEXT);

            if( !(lphHttpRqst->GetOpenFlags() & WINHTTP_FLAG_SECURE))
            {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
                goto quit;
            }

            if (lpBuffer)
            {
                if (ERROR_SUCCESS == lphHttpRqst->GetSecurityInfo(&cInfo))
                {
                    // GetSecurityInfo calls CertDuplicateCertificateContext, so
                    // the client app should call CertFreeCertificateContext when
                    // finished in order to maintain the proper ref count.
                    *((PCCERT_CONTEXT *) lpBuffer) = cInfo.pCertificate;  
                }
                else
                {
                    error = ERROR_INVALID_OPERATION;
                }
            }
        }
        goto quit;
        
    case WINHTTP_OPTION_SECURITY_KEY_BITNESS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;
            INTERNET_SECURITY_INFO secInfo;

            requiredSize = sizeof(dwValue);
            dwValue = 0;
            lpSource = (LPVOID)&dwValue;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            if (ERROR_SUCCESS != lphHttpRqst->GetSecurityInfo(&secInfo)) {
                error = ERROR_INVALID_OPERATION;
            } else {
                dwValue = secInfo.dwCipherStrength;
                WRAP_REVERT_USER_VOID((*g_pfnCertFreeCertificateContext),
                                      GetRootHandle(lphHttpRqst)->GetSslSessionCache()->IsImpersonationEnabled(),
                                      (secInfo.pCertificate));

                INET_ASSERT (error == ERROR_SUCCESS);

                DEBUG_PRINT(INET,
                            INFO,
                            ("SECURITY_KEY_BITNESS: %X\n",
                            dwValue
                            ));

            }
        }

        break;


    case WINHTTP_OPTION_PROXY:
        if (!ARGUMENT_PRESENT(hInternet)) {

            error = g_pGlobalProxyInfo->GetProxyStringInfo(lpBuffer, lpdwBufferLength);
            requiredSize = *lpdwBufferLength;
            goto quit;

        } else if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle)) {

            //
            // GetProxyInfo() will return the data, or calculate the buffer
            // length required
            //

            error = ((INTERNET_HANDLE_BASE *)hInternet)->GetProxyStringInfo(
                lpBuffer,
                lpdwBufferLength
                );
            requiredSize = *lpdwBufferLength;
            goto quit;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_VERSION:
        requiredSize = sizeof(InternetVersionInfo);
        lpSource = (LPVOID)&InternetVersionInfo;
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (handleType == TypeInternetHandle) {
            lpSource = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetUserAgent();
            isString = TRUE;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT:
        if (handleType == TypeHttpRequestHandle) {
            AUTHCTX* pAuthCtx = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetAuthCtx();
            if (pAuthCtx && (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT))
            {
                lpSource = ((PASSPORT_CTX*)pAuthCtx)->m_pszCbTxt;
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_COBRANDING_URL:
        if (handleType == TypeHttpRequestHandle) {
            AUTHCTX* pAuthCtx = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetAuthCtx();
            if (pAuthCtx && (pAuthCtx->GetSchemeType() == WINHTTP_AUTH_SCHEME_PASSPORT))
            {
                lpSource = ((PASSPORT_CTX*)pAuthCtx)->m_pszCbUrl;
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_PASSPORT_RETURN_URL:
        if (handleType == TypeHttpRequestHandle) {
            if (((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->m_lpszRetUrl)
            {
                lpSource = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->m_lpszRetUrl;
                UrlUnescapeA((LPSTR)lpSource, NULL, NULL, URL_UNESCAPE_INPLACE);
                isString = TRUE;
            }
            else
            {
                lpSource = NULL;
            }

            if (lpSource == NULL)
            {
                error = ERROR_WINHTTP_HEADER_NOT_FOUND;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            requiredSize = sizeof(dwValue);
            dwValue = ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->GetPriority();
            lpSource = (LPVOID)&dwValue;
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        requiredSize = sizeof(HttpVersionInfo);
        lpSource = (LPVOID)&HttpVersionInfo;
        break;

    //case WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO:

    //    //
    //    // internal option
    //    //

    //    if (pReq) {
    //        requiredSize = sizeof(socketInfo);
    //        lpSource = (LPVOID)&socketInfo;

    //        socketInfo.Socket = pReq->GetSocket();
    //        socketInfo.SourcePort = pReq->GetSourcePort();
    //        socketInfo.DestPort = pReq->GetDestPort();
    //        socketInfo.Flags = (pReq->IsSocketFromGlobalKeepAlivePool()
    //                                ? IDSI_FLAG_KEEP_ALIVE : 0)
    //                            | (pReq->IsSecure()
    //                                ? IDSI_FLAG_SECURE : 0)
    //                            | (pReq->IsRequestUsingProxy()
    //                                ? IDSI_FLAG_PROXY : 0)
    //                            | (pReq->IsTunnel()
    //                                ? IDSI_FLAG_TUNNEL : 0)
    //                            | (pReq->IsSocketAuthenticated()
    //                                ? IDSI_FLAG_AUTHENTICATED : 0);
    //    } else {
    //        error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
    //    }
    //    break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (hInternet)
        {
            if (handleType == TypeInternetHandle)
            {
                requiredSize = sizeof(dwValue);
                dwValue = 0;
                lpSource = (LPVOID)&dwValue;
                dwValue = ((INTERNET_HANDLE_OBJECT *)hInternet)->GetMaxConnectionsPerServer(dwOption);
            }
            else
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
            error = ERROR_INVALID_OPERATION;
        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        requiredSize = sizeof(DWORD);
        dwValue = g_cNumIOCPThreads;
        lpSource = (LPVOID)&dwValue;
        break;
        
#if INET_DEBUG

    case WINHTTP_OPTION_GET_DEBUG_INFO:
        error = InternetGetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     lpdwBufferLength
                                     );

        //
        // everything updated, so quit without going through common buffer
        // processing
        //

        goto quit;
        break;

    case WINHTTP_OPTION_GET_HANDLE_COUNT:
        requiredSize = sizeof(DWORD);
        dwValue = InternetHandleCount();
        lpSource = (LPVOID)&dwValue;
        break;

#endif // INET_DEBUG

    default:
        requiredSize = 0;
        error = ERROR_INVALID_PARAMETER;
        break;
    }

    //
    // if we have a buffer and enough space, then copy the data
    //

copy:
    if (error == ERROR_SUCCESS) {

        //
        // if we are returning a string, calculate the amount of space
        // required to hold it
        //

        if (isString) {
            if (lpSource != NULL) {
                requiredSize = lstrlen((LPCSTR)lpSource) + 1;
            } else {

                //
                // option string is NULL: return an empty string
                //

                lpSource = "";
                requiredSize = 1;
                freeString = FALSE;
            }
        }

        INET_ASSERT(lpSource != NULL);

        if ((*lpdwBufferLength >= requiredSize)
        && ARGUMENT_PRESENT(lpBuffer)) {
            memcpy(lpBuffer, lpSource, requiredSize);
            if (isString) {

                //
                // string copied successfully. Returned length is string
                // length, not buffer length, i.e. drop 1 for '\0'
                //

                --requiredSize;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }

        if (freeString)
        {
            SecureZeroMemory(lpSource, requiredSize);
            FREE_MEMORY(lpSource);
        }
    }

quit:

    //
    // return the amount the app needs to supply, or the amount of data in the
    // buffer, depending on success/failure status
    //

    *lpdwBufferLength = requiredSize;

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error == ERROR_SUCCESS) {
        success = TRUE;

        IF_DEBUG(API) {

            if (isString) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("returning %q (%d chars)\n",
                                lpBuffer,
                                requiredSize
                                ));

            } else {

                DEBUG_DUMP_API(API,
                               "option data:\n",
                               lpBuffer,
                               requiredSize
                               );

            }
        }
    } else {

        DEBUG_ERROR(API, error);

        IF_DEBUG(API) {

            if (error == ERROR_INSUFFICIENT_BUFFER) {

                DEBUG_PRINT_API(API,
                                INFO,
                                ("*lpdwBufferLength (%#x)= %d\n",
                                lpdwBufferLength,
                                *lpdwBufferLength
                                ));

            }
        }

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}


INTERNETAPI
BOOL
WINAPI
WinHttpQueryOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet           -

    dwOption            -

    lpBuffer            -

    lpdwBufferLength    -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpQueryOption",
                     "%#x, %s (%d), %#x, %#x [%d]",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpdwBufferLength,
                     lpdwBufferLength
                        ? (!IsBadReadPtr(lpdwBufferLength, sizeof(DWORD))
                            ? *lpdwBufferLength
                            : 0)
                        : 0
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpBuffer;

    if (!lpdwBufferLength
        || IsBadWritePtr(lpdwBufferLength, sizeof(*lpdwBufferLength))
        || (lpBuffer && *lpdwBufferLength && IsBadWritePtr(lpBuffer, *lpdwBufferLength)) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
    case WINHTTP_OPTION_PASSPORT_COBRANDING_TEXT:
    case WINHTTP_OPTION_PASSPORT_COBRANDING_URL:
    case WINHTTP_OPTION_PASSPORT_RETURN_URL:
        if (lpBuffer)
        {
            mpBuffer.dwAlloc = mpBuffer.dwSize = *lpdwBufferLength;
            ALLOC_BYTES(mpBuffer.psStr, mpBuffer.dwAlloc*sizeof(CHAR));
            if (!mpBuffer.psStr)
            {
                dwErr = ERROR_NOT_ENOUGH_MEMORY;
                break;
            }
        }
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  (LPVOID)mpBuffer.psStr,
                                  &mpBuffer.dwSize
                                 );
        if (fResult)
        {
            *lpdwBufferLength = sizeof(WCHAR) *
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize + 1, NULL, 0);
                
            if (*lpdwBufferLength <= mpBuffer.dwAlloc && lpBuffer)
            {
                MultiByteToWideChar(CP_ACP, 0, mpBuffer.psStr, mpBuffer.dwSize+1,
                        (LPWSTR)lpBuffer, *lpdwBufferLength);
                (*lpdwBufferLength)-=sizeof(WCHAR);
            }
            else
            {
                fResult = FALSE;
                dwErr = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            if (GetLastError()==ERROR_INSUFFICIENT_BUFFER)
            {
                *lpdwBufferLength = mpBuffer.dwSize*sizeof(WCHAR);
            }
        }

        switch(dwOption)
        {
        case WINHTTP_OPTION_USERNAME:
        case WINHTTP_OPTION_PASSWORD:
        case WINHTTP_OPTION_PROXY_USERNAME:
        case WINHTTP_OPTION_PROXY_PASSWORD:
            ZERO_MEMORY_ALLOC(mpBuffer);
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            
            union
            {
                WINHTTP_PROXY_INFOA InfoA;
                char                Buffer[1024];
            };

            char *  pBuffer = NULL;
            DWORD   dwBufferLen = sizeof(Buffer);
            bool    fFreeBuffer = false;

            if (IsBadWritePtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) ||
                (*lpdwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                            (void *) &Buffer,
                            &dwBufferLen);
            
            if (!fResult && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
            {
                pBuffer = New char[dwBufferLen];

                if (pBuffer)
                {
                    fFreeBuffer = true;

                    fResult = InternetQueryOptionA(hInternet, WINHTTP_OPTION_PROXY,
                                    (void *) pBuffer,
                                    &dwBufferLen);
                }
                else
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
            }

            if (fResult)
            {
                pInfo->dwAccessType = InfoA.dwAccessType;
            
                dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxy,
                                &(pInfo->lpszProxy));

                if (dwErr == ERROR_SUCCESS)
                {
                    dwErr = AsciiToWideChar_UsingGlobalAlloc(InfoA.lpszProxyBypass,
                                    &(pInfo->lpszProxyBypass));

                    if ((dwErr != ERROR_SUCCESS) && (pInfo->lpszProxy != NULL))
                    {
                        GlobalFree(pInfo->lpszProxy);
                        pInfo->lpszProxy = NULL;
                    }
                }

                fResult = (dwErr == ERROR_SUCCESS);
            }

            if (fFreeBuffer)
            {
                delete [] pBuffer;
            }
        }
        break;

    case WINHTTP_OPTION_ENABLETRACING:
        {
            if(hInternet)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            BOOL *pInfo = (BOOL *)lpBuffer;
            if (IsBadWritePtr(pInfo, sizeof(BOOL)) ||
                (*lpdwBufferLength < sizeof(BOOL)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            *pInfo = CTracer::IsTracingEnabled();
            fResult = TRUE;
        }
        break;

    default:
        fResult = InternetQueryOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  lpdwBufferLength
                                 );
    }

cleanup:
    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
InternetSetOptionA(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    Sets a handle-specific variable, or a per-thread variable

Arguments:

    hInternet           - handle of object for which information will be set,
                          or NULL if the option defines a per-thread variable

    dwOption            - the handle-specific WINHTTP_OPTION to set

    lpBuffer            - pointer to a buffer containing value to set

    dwBufferLength      - size of lpBuffer

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Call GetLastError() for more info:
                    ERROR_INVALID_HANDLE
                        hInternet does not identify a valid Internet handle
                        object

                    ERROR_WINHTTP_INTERNAL_ERROR
                        Shouldn't see this?

                    ERROR_INVALID_PARAMETER
                        One of the parameters was bad

                    ERROR_WINHTTP_INVALID_OPTION
                        The requested option cannot be set

                    ERROR_WINHTTP_OPTION_NOT_SETTABLE
                        Can't set this option, only query it

                    ERROR_INSUFFICIENT_BUFFER
                        The dwBufferLength parameter is incorrect for the
                        expected type of the option

--*/

{
    DEBUG_ENTER((DBG_API,
                     Bool,
                     "InternetSetOptionA",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD error;
    BOOL success = TRUE;
    HINTERNET_HANDLE_TYPE handleType = (HINTERNET_HANDLE_TYPE)0;
    LPINTERNET_THREAD_INFO lpThreadInfo;
    DWORD requiredSize;
    HINTERNET hObjectMapped = NULL;

    INET_ASSERT(dwBufferLength != 0);

    if (!GlobalDataInitialized) {
        error = GlobalDataInitialize();
        if (error != ERROR_SUCCESS) {
            goto done;
        }
    }

    //
    // validate the handle and get its type
    //

    if (ARGUMENT_PRESENT(hInternet)) {

        //
        // map the handle
        //

        error = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);
        if (error == ERROR_SUCCESS) {
            hInternet = hObjectMapped;
            error = RGetHandleType(hInternet, &handleType);
        }
    } else if (IS_PER_THREAD_OPTION(dwOption)) {

        //
        // this option updates the per-thread information block, so this is a
        // good point at which to get it
        //

        lpThreadInfo = InternetGetThreadInfo();
        if (lpThreadInfo != NULL) {
            error = ERROR_SUCCESS;
        } else {

            DEBUG_PRINT(INET,
                        ERROR,
                        ("InternetGetThreadInfo() returns NULL\n"
                        ));

            //
            // we never expect this - ERROR_WINHTTP_SPANISH_INQUISITION
            //

            INET_ASSERT(FALSE);

            error = ERROR_WINHTTP_INTERNAL_ERROR;
        }
    } else if (IS_PER_PROCESS_OPTION(dwOption)) {
        error = ERROR_SUCCESS;
    } else {

        //
        // catch any invalid options for the NULL handle. If the option is valid
        // then it is incorrect for this handle type, otherwise its an invalid
        // option, period
        //

        error = IS_VALID_OPTION(dwOption)
                    ? ERROR_WINHTTP_INCORRECT_HANDLE_TYPE
                    : ERROR_WINHTTP_INVALID_OPTION
                    ;
    }

    if (error != ERROR_SUCCESS) {
        goto quit;
    }
    
    HTTP_REQUEST_HANDLE_OBJECT *pReq;

    switch (handleType)
    {
        case TypeHttpRequestHandle:
            pReq = (HTTP_REQUEST_HANDLE_OBJECT*) hInternet; 
            break;
        default:
            pReq = NULL;
            break;
    }

    // New fast path for request handle options.

    if (dwOption > WINHTTP_OPTION_MASK)
    {
        dwOption &= WINHTTP_OPTION_MASK;
        if (dwOption > MAX_INTERNET_STRING_OPTION)
            error = ERROR_INVALID_PARAMETER;
        else if (!pReq)
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        else if (pReq->SetProp (dwOption, (LPSTR) lpBuffer))
            error = ERROR_SUCCESS;
        else
            error = ERROR_WINHTTP_INTERNAL_ERROR;

        goto quit;
    }

    
    //
    // if the option and handle combination is valid then set the option value
    //

    switch (dwOption) {
    case WINHTTP_OPTION_CALLBACK:
    case WINHTTP_OPTION_HANDLE_TYPE:
    
        // these options cannot be set by this function
        error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
        break;
        
    case WINHTTP_OPTION_RESOLVE_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_TIMEOUT:
    case WINHTTP_OPTION_CONNECT_RETRIES:
    case WINHTTP_OPTION_SEND_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_TIMEOUT:
    case WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT:
    case WINHTTP_OPTION_REDIRECT_POLICY:
    case WINHTTP_OPTION_AUTOLOGON_POLICY:
    case WINHTTP_OPTION_MAX_HTTP_AUTOMATIC_REDIRECTS:
    case WINHTTP_OPTION_MAX_HTTP_STATUS_CONTINUE:
    case WINHTTP_OPTION_MAX_RESPONSE_HEADER_SIZE:
    case WINHTTP_OPTION_MAX_RESPONSE_DRAIN_SIZE:
        requiredSize = sizeof(DWORD);
        if (dwBufferLength != requiredSize) 
        {
            error = ERROR_INSUFFICIENT_BUFFER;
            break;
        }

        // For WinHttp, these options are per-handle, not per-process.
        if (hInternet == NULL) 
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }

        //
        //  Do per-option parameter validation where applicable
        //
        error = ERROR_SUCCESS;
        switch(dwOption)
        {
        case WINHTTP_OPTION_REDIRECT_POLICY:
            if( WINHTTP_OPTION_REDIRECT_POLICY_LAST < (*(LPDWORD)lpBuffer))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            break;
        case WINHTTP_OPTION_AUTOLOGON_POLICY:
            if( WINHTTP_AUTOLOGON_SECURITY_LEVEL_HIGH < (*(LPDWORD)lpBuffer))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            break;
        };
        if(error != ERROR_SUCCESS)
            break;

        // we have a non-NULL context handle: the app wants to set specific
        // protocol timeouts
        switch (handleType) 
        {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            if (! ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetDwordOption(dwOption, *(LPDWORD)lpBuffer) )
            {    
                error = ERROR_NOT_ENOUGH_MEMORY;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetDwordOption(dwOption, *(LPDWORD)lpBuffer);
            break;

        default:

            // any other handle type (?) cannot have timeouts set for it
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
        }
        break;

    case WINHTTP_OPTION_CONTEXT_VALUE:

        //
        // BUGBUG - can't change context if async operation is pending
        //

        if (dwBufferLength == sizeof(LPVOID)) {
            error = RSetContext(hInternet, *((DWORD_PTR *) lpBuffer));
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_READ_BUFFER_SIZE:
    case WINHTTP_OPTION_WRITE_BUFFER_SIZE:
        if (pReq)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                DWORD bufferSize;

                bufferSize = *(LPDWORD)lpBuffer;
                if (bufferSize > 0)
                {
                    pReq->SetBufferSize(dwOption, bufferSize);
                    error = ERROR_SUCCESS;
                }
                else  // the read/write buffer size cannot be set to 0
                {
                    error = ERROR_INVALID_PARAMETER;
                }
            }
            else
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_CLIENT_CERT_CONTEXT:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(CERT_CONTEXT))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            CERT_CONTEXT_ARRAY* pArray = NULL;

            if( !(pRequest->GetOpenFlags() & WINHTTP_FLAG_SECURE))
            {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_STATE;
                break;
            }

            pArray = pRequest->GetCertContextArray();
            if (!pArray)
            {
                pArray = New CERT_CONTEXT_ARRAY(GetRootHandle(pRequest)->
                                                GetSslSessionCache()->
                                                IsImpersonationEnabled());
                pRequest->SetCertContextArray(pArray);
            }

            if (!pArray)
                error = ERROR_NOT_ENOUGH_MEMORY;
            else
            {
                pArray->Reset();
                pArray->AddCertContext((PCCERT_CONTEXT) lpBuffer);
                pArray->SelectCertContext(0);
                error = ERROR_SUCCESS;
            }
        }
        break;

    case WINHTTP_OPTION_SECURITY_FLAGS:

        if (handleType != TypeHttpRequestHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            HTTP_REQUEST_HANDLE_OBJECT *lphHttpRqst;

            lphHttpRqst = (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;

            lphHttpRqst->SetSecureFlags(*(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_CONFIGURE_PASSPORT_AUTH:
        if (handleType != TypeInternetHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            DWORD dwFlags = *(LPDWORD)lpBuffer;

            if (dwFlags == WINHTTP_DISABLE_PASSPORT_AUTH)
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableTweener();
            }
            else
            {
                if (dwFlags & WINHTTP_ENABLE_PASSPORT_AUTH)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableTweener();
                }

                if (dwFlags & WINHTTP_DISABLE_PASSPORT_KEYRING)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->DisableKeyring();
                }

                if (dwFlags & WINHTTP_ENABLE_PASSPORT_KEYRING)
                {
                    ((INTERNET_HANDLE_OBJECT *)hInternet)->EnableKeyring();
                }
            }

            error = ERROR_SUCCESS;
        }
                    
        break;

    case WINHTTP_OPTION_SECURE_PROTOCOLS:

        if (handleType != TypeInternetHandle)
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else if (*(LPDWORD)lpBuffer & ~(WINHTTP_FLAG_SECURE_PROTOCOL_ALL))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            ((INTERNET_HANDLE_OBJECT *)hInternet)->SetSecureProtocols(
                *(LPDWORD)lpBuffer);

            error = ERROR_SUCCESS;
        }

        break;

    case WINHTTP_OPTION_PROXY:
        if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
        {
            WINHTTP_PROXY_INFOA * lpInfo = (WINHTTP_PROXY_INFOA *) lpBuffer;

            //
            // validate parameters
            //

            if (dwBufferLength != sizeof(*lpInfo))
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
            else if (!((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_DEFAULT_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NO_PROXY)
                    || (lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY))
            || ((lpInfo->dwAccessType == WINHTTP_ACCESS_TYPE_NAMED_PROXY)
                && ((lpInfo->lpszProxy == NULL) || (*lpInfo->lpszProxy == '\0'))))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                error = ((INTERNET_HANDLE_BASE *)hInternet)->SetProxyInfo(
                            lpInfo->dwAccessType,
                            lpInfo->lpszProxy,
                            lpInfo->lpszProxyBypass
                            );
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_USER_AGENT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if ((handleType == TypeInternetHandle) || (handleType == TypeHttpRequestHandle))
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetUserAgent((LPSTR)lpBuffer);
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;

    case WINHTTP_OPTION_PASSPORT_SIGN_OUT:
        if (*(LPSTR)lpBuffer == '\0') {
            error = ERROR_INSUFFICIENT_BUFFER;
        } else {
            if (handleType == TypeInternetHandle)
            {
                INTERNET_HANDLE_OBJECT* pInternet = ((INTERNET_HANDLE_OBJECT*)hInternet); 
                PP_CONTEXT hPP = pInternet->GetPPContext();
                
                pInternet->ClearPassportCookies((LPSTR)lpBuffer);

                if (hPP != NULL)
                {
                    ::PP_Logout(hPP, 0);
                }
            } else {
                error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            }
        }
        break;
        
    case WINHTTP_OPTION_REQUEST_PRIORITY:
        if (handleType == TypeHttpRequestHandle) {
            if (dwBufferLength == sizeof(LONG)) {
                ((HTTP_REQUEST_HANDLE_OBJECT *)hInternet)->
                    SetPriority(*(LPLONG)lpBuffer);
            } else {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } else {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;

    case WINHTTP_OPTION_HTTP_VERSION:
        if (dwBufferLength == sizeof(HTTP_VERSION_INFO))
        {
            HTTP_VERSION_INFO* pVersionInfo = (LPHTTP_VERSION_INFO)lpBuffer;
            if (pVersionInfo->dwMajorVersion != 1
                || (pVersionInfo->dwMinorVersion != 0
                    && pVersionInfo->dwMajorVersion != 1))
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                HttpVersionInfo = *(LPHTTP_VERSION_INFO)lpBuffer;
            }
        } else {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        break;

    case WINHTTP_OPTION_DISABLE_FEATURE:

        if (handleType == TypeHttpRequestHandle)
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            
            DWORD dwDisable = *((LPDWORD) lpBuffer);
            
            if (dwDisable & WINHTTP_DISABLE_KEEP_ALIVE)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags &= ~INTERNET_FLAG_KEEP_CONNECTION;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_REDIRECTS)
            {
                pRequest->SetDwordOption( WINHTTP_OPTION_REDIRECT_POLICY, WINHTTP_OPTION_REDIRECT_POLICY_NEVER);
            }
            if (dwDisable & WINHTTP_DISABLE_COOKIES)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_COOKIES;
                pRequest->SetOpenFlags (dwFlags);                
            }
            if (dwDisable & WINHTTP_DISABLE_AUTHENTICATION)
            {
                DWORD dwFlags = pRequest->GetOpenFlags();
                dwFlags |= INTERNET_FLAG_NO_AUTH;
                pRequest->SetOpenFlags (dwFlags);                
            }

            error = ERROR_SUCCESS;
        }
        else if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;
            
  
    case WINHTTP_OPTION_ENABLE_FEATURE:

        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INVALID_PARAMETER;
        }
        else if (handleType == TypeHttpRequestHandle)
        {
            HTTP_REQUEST_HANDLE_OBJECT *pRequest =
                (HTTP_REQUEST_HANDLE_OBJECT *) hInternet;
            DWORD dwEnable = *((LPDWORD) lpBuffer);

            // This one feature is only allowed to be set on the
            // session handle
            if (dwEnable & WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION)
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                pRequest->SetEnableFlags(*((LPDWORD) lpBuffer));
                error = ERROR_SUCCESS;
            }
        }
        else if (handleType == TypeInternetHandle)
        {
            INTERNET_HANDLE_OBJECT *pInternet =
                (INTERNET_HANDLE_OBJECT *) hInternet;
            DWORD dwEnable = *((LPDWORD) lpBuffer);

            // Consider the call invalid if anything else is being
            // set on the session handle.
            if (dwEnable & ~WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION)
            {
                error = ERROR_INVALID_PARAMETER;
            }
            else
            {
                // Error code could indicate that a request handle
                // has already been created, resulting in this call failing.
                error = pInternet->SetSslImpersonationLevel(
                    (*((LPDWORD) lpBuffer) & WINHTTP_ENABLE_SSL_REVERT_IMPERSONATION) ? FALSE : TRUE);
            }
        }
        else
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        break;
            
  
    case WINHTTP_OPTION_CODEPAGE:
        if ((hInternet == NULL) || (handleType == TypeHttpRequestHandle))
        {
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        }
        else
        {
            if (dwBufferLength == sizeof(DWORD)) 
            {
                ((INTERNET_HANDLE_BASE *)hInternet)->SetCodePage(*(LPDWORD)lpBuffer);
            } 
            else 
            {
                error = ERROR_INSUFFICIENT_BUFFER;
            }
        } 
        break;

    case WINHTTP_OPTION_MAX_CONNS_PER_SERVER:
    case WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER:
        if (handleType == TypeInternetHandle)
        {
            if (dwBufferLength == sizeof(DWORD))
            {
                ((INTERNET_HANDLE_OBJECT *)hInternet)->SetMaxConnectionsPerServer(dwOption, *(DWORD *)lpBuffer);
            }
            else
                error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
            error = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        break;

    case WINHTTP_OPTION_WORKER_THREAD_COUNT:
        
        if (dwBufferLength < sizeof(DWORD))
        {
            error = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            if (!g_cNumIOCPThreads)
            {
                g_cNumIOCPThreads = *(LPDWORD)lpBuffer;
                error = ERROR_SUCCESS;
            }
            else
            {
                error = ERROR_WINHTTP_OPTION_NOT_SETTABLE;
            }
        }
        break;
        
#if INET_DEBUG
    case WINHTTP_OPTION_SET_DEBUG_INFO:
        error = InternetSetDebugInfo((LPINTERNET_DEBUG_INFO)lpBuffer,
                                     dwBufferLength
                                     );
        break;

#endif // INET_DEBUG

    default:

        //
        // this option is not recognized
        //

        error = ERROR_WINHTTP_INVALID_OPTION;
    }

quit:

    if (hObjectMapped != NULL) {
        DereferenceObject((LPVOID)hObjectMapped);
    }

done:

    if (error != ERROR_SUCCESS) {

        DEBUG_ERROR(API, error);

        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);

    return success;
}

#define CHECK_MODIFY_TIMEOUT(nTimeout) \
{ \
    if (nTimeout <= 0) \
    { \
        if (nTimeout == 0) \
        { \
            nTimeout = (int)INFINITE; \
        } \
        else if (nTimeout < -1) \
        { \
            dwError = ERROR_INVALID_PARAMETER; \
            goto quit; \
        } \
    } \
}

INTERNETAPI
BOOL
WINAPI 
WinHttpSetTimeouts(    
    IN HINTERNET    hInternet,           // Session/Request handle.
    IN int        nResolveTimeout,
    IN int        nConnectTimeout,
    IN int        nSendTimeout,
    IN int        nReceiveTimeout
    )
{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpSetTimeouts",
                     "%#x, %d, %d, %d, %d",
                     hInternet,
                     nResolveTimeout,
                     nConnectTimeout,
                     nSendTimeout,
                     nReceiveTimeout
                     ));

    DWORD dwError = ERROR_SUCCESS;
    BOOL bRetval = FALSE;
    HINTERNET_HANDLE_TYPE handleType;
    HINTERNET hObjectMapped = NULL;

    if (!hInternet)
    {
        dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
        goto quit;
    }

    CHECK_MODIFY_TIMEOUT(nResolveTimeout);
    CHECK_MODIFY_TIMEOUT(nConnectTimeout);
    CHECK_MODIFY_TIMEOUT(nSendTimeout);
    CHECK_MODIFY_TIMEOUT(nReceiveTimeout);
    
    dwError = MapHandleToAddress(hInternet, (LPVOID *)&hObjectMapped, FALSE);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }
    
    dwError = RGetHandleType(hObjectMapped, &handleType);

    if (dwError != ERROR_SUCCESS)
    {
        goto quit;
    }

    switch(handleType)
    {
        case TypeInternetHandle:

            //only error possible is in allocing memory for OPTIONAL_PARAMS struct
            bRetval = ((INTERNET_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts(
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            if (!bRetval)
            {    
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                goto quit;
            }
            break;
            
        case TypeHttpRequestHandle:

            // no errors possible here
            bRetval = ((HTTP_REQUEST_HANDLE_OBJECT*)hObjectMapped)->SetTimeouts( 
                nResolveTimeout, nConnectTimeout, nSendTimeout, nReceiveTimeout);
            INET_ASSERT(bRetval);
            break;

        default:

            // any other handle type cannot have timeouts set for it
            dwError = ERROR_WINHTTP_INCORRECT_HANDLE_TYPE;
            break;
    }
    
quit:

    if (hObjectMapped) 
    {
        DereferenceObject((LPVOID)hObjectMapped);
    }

    if (dwError != ERROR_SUCCESS) 
    { 
        ::SetLastError(dwError); 
        INET_ASSERT(!bRetval);
    }
    
    DEBUG_LEAVE_API(bRetval);
    return bRetval;
}


INTERNETAPI
BOOL
WINAPI
WinHttpSetOption(
    IN HINTERNET hInternet OPTIONAL,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hInternet       -

    dwOption        -

    lpBuffer        -

    dwBufferLength  -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER2_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    TRACE_ENTER2_API((DBG_API,
                     Bool,
                     "WinHttpSetOption",
                     hInternet,
                     "%#x, %s (%d), %#x [%#x], %d",
                     hInternet,
                     InternetMapOption(dwOption),
                     dwOption,
                     lpBuffer,
                     lpBuffer
                        ? (!IsBadReadPtr(lpBuffer, sizeof(DWORD))
                            ? *(LPDWORD)lpBuffer
                            : 0)
                        : 0,
                     dwBufferLength
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    MEMORYPACKET mpBuffer;
    BOOL fResult = FALSE;

    //
    // validate parameters
    //

    if ((dwBufferLength == 0) || IsBadReadPtr(lpBuffer, dwBufferLength)) 
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
    
    switch (dwOption)
    {
    case WINHTTP_OPTION_USERNAME:
    case WINHTTP_OPTION_PASSWORD:
    case WINHTTP_OPTION_URL:
    case WINHTTP_OPTION_USER_AGENT:
    case WINHTTP_OPTION_PROXY_USERNAME:
    case WINHTTP_OPTION_PROXY_PASSWORD:
    case WINHTTP_OPTION_PASSPORT_SIGN_OUT:
        ALLOC_MB((LPWSTR)lpBuffer, dwBufferLength, mpBuffer);
        if (!mpBuffer.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI((LPWSTR)lpBuffer, mpBuffer);
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  mpBuffer.psStr,
                                  mpBuffer.dwSize
                                 );

        switch(dwOption)       
        {
        case WINHTTP_OPTION_USERNAME:
        case WINHTTP_OPTION_PASSWORD:
        case WINHTTP_OPTION_PROXY_USERNAME:
        case WINHTTP_OPTION_PROXY_PASSWORD:
            ZERO_MEMORY_ALLOC(mpBuffer);
        }
        break;

    case WINHTTP_OPTION_PROXY:
        {
            WINHTTP_PROXY_INFOW * pInfo = (WINHTTP_PROXY_INFOW *) lpBuffer;
            WINHTTP_PROXY_INFOA   InfoA;

            if (IsBadReadPtr(pInfo, sizeof(WINHTTP_PROXY_INFOW)) || (dwBufferLength < sizeof(WINHTTP_PROXY_INFOW)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            InfoA.dwAccessType = pInfo->dwAccessType;

            dwErr = WideCharToAscii(pInfo->lpszProxy, &InfoA.lpszProxy);

            if (dwErr == ERROR_SUCCESS)
            {
                dwErr = WideCharToAscii(pInfo->lpszProxyBypass, &InfoA.lpszProxyBypass);

                if (dwErr == ERROR_SUCCESS)
                {
                    fResult = InternetSetOptionA(hInternet, WINHTTP_OPTION_PROXY, &InfoA, sizeof(InfoA));

                    if (InfoA.lpszProxyBypass)
                    {
                        delete [] InfoA.lpszProxyBypass;
                    }
                }

                if (InfoA.lpszProxy)
                {
                    delete [] InfoA.lpszProxy;
                }
            }
        }
        break;

    case WINHTTP_OPTION_ENABLETRACING:
        {
            if(hInternet)
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            BOOL *pInfo = (BOOL *)lpBuffer;
            if (IsBadReadPtr(pInfo, sizeof(BOOL)) ||
                (dwBufferLength < sizeof(BOOL)))
            {
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

            if( *pInfo)
            {
                fResult = CTracer::GlobalTraceInit( TRUE);
                if( fResult != FALSE)
                    CTracer::EnableTracing();
            }
            else
            {
                CTracer::DisableTracing();
                fResult = TRUE;
            }
        }
        break;

    default:
        fResult = InternetSetOptionA(hInternet,
                                  dwOption,
                                  lpBuffer,
                                  dwBufferLength
                                 );
    }

cleanup:

    if (dwErr!=ERROR_SUCCESS)
    {
        SetLastError(dwErr);
        DEBUG_ERROR(INET, dwErr);
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}



PRIVATE
BOOL
FValidCacheHandleType(
    HINTERNET_HANDLE_TYPE   hType
    )
{
    return ((hType != TypeInternetHandle)   &&
            (hType != TypeHttpConnectHandle));
}

#ifdef ENABLE_DEBUG

#define CASE_OF(constant)   case constant: return # constant

LPSTR
InternetMapOption(
    IN DWORD Option
    )

/*++

Routine Description:

    Convert WINHTTP_OPTION_ value to symbolic name

Arguments:

    Option  - to map

Return Value:

    LPSTR - pointer to symbolic name, or "?" if unknown

--*/

{
    switch (Option) {
    CASE_OF(WINHTTP_OPTION_CALLBACK);
    CASE_OF(WINHTTP_OPTION_RESOLVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_CONNECT_RETRIES);
    CASE_OF(WINHTTP_OPTION_SEND_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_RECEIVE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_RECEIVE_RESPONSE_TIMEOUT);
    CASE_OF(WINHTTP_OPTION_HANDLE_TYPE);
    CASE_OF(WINHTTP_OPTION_READ_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_WRITE_BUFFER_SIZE);
    CASE_OF(WINHTTP_OPTION_PARENT_HANDLE);
    CASE_OF(WINHTTP_OPTION_EXTENDED_ERROR);
    CASE_OF(WINHTTP_OPTION_USERNAME);
    CASE_OF(WINHTTP_OPTION_PASSWORD);
    CASE_OF(WINHTTP_OPTION_SECURITY_FLAGS);
    CASE_OF(WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT);
    CASE_OF(WINHTTP_OPTION_URL);
    CASE_OF(WINHTTP_OPTION_SECURITY_KEY_BITNESS);
    CASE_OF(WINHTTP_OPTION_PROXY);
    CASE_OF(WINHTTP_OPTION_VERSION);
    CASE_OF(WINHTTP_OPTION_USER_AGENT);
    CASE_OF(WINHTTP_OPTION_PROXY_USERNAME);
    CASE_OF(WINHTTP_OPTION_PROXY_PASSWORD);
    CASE_OF(WINHTTP_OPTION_CONTEXT_VALUE);
    CASE_OF(WINHTTP_OPTION_CLIENT_CERT_CONTEXT);
    CASE_OF(WINHTTP_OPTION_REQUEST_PRIORITY);
    CASE_OF(WINHTTP_OPTION_HTTP_VERSION);
    CASE_OF(WINHTTP_OPTION_SECURITY_CONNECTION_INFO);
    // CASE_OF(WINHTTP_OPTION_DIAGNOSTIC_SOCKET_INFO);
    CASE_OF(WINHTTP_OPTION_SERVER_CERT_CONTEXT);
    }
    return "?";
}

#endif // ENABLE_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\rashelp.cxx ===
/////////////////////////////////////////////////////////////////////////////
//
// RAS API wrappers for wide/ansi
//
// Works on all NT platforms correctly, maintaining unicode
// whenever possible.
//
/////////////////////////////////////////////////////////////////////////////

#include "wininetp.h"
#include "rashelp.h"
#include "autodial.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
ENUM_TYPE GetOSVersion::_EnumType = ENUM_NONE;

GetOSVersion::GetOSVersion()
{
    if(_EnumType == ENUM_NONE)
    {
        if(0 == GlobalPlatformType)
            GlobalPlatformType = PlatformType(&GlobalPlatformVersion5);

        INET_ASSERT(PLATFORM_TYPE_WINNT == GlobalPlatformType);

        if(TRUE == GlobalPlatformVersion5)
            _EnumType = ENUM_WIN2K;
        else
            _EnumType = ENUM_UNICODE;
    }
}

GetOSVersion::~GetOSVersion()
{
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasEnumHelp::RasEnumHelp()
{
    DWORD           dwBufSize, dwStructSize = 0;

    // init
    _dwEntries = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        dwStructSize = sizeof(RASENTRYNAMEW);
        break;
    case ENUM_WIN2K:
        dwStructSize = sizeof(W2KRASENTRYNAMEW);
        break;
    }

    // allocate space for 16 entries
    dwBufSize = 16 * dwStructSize;
    _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
    if(_preList)
    {
        do
        {
            // set up list
            _preList[0].dwSize = dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            _dwLastError = _RasEnumEntriesW(
                            NULL,
                            NULL,
                            (LPRASENTRYNAMEW)_preList,
                            &dwBufSize,
                            &_dwEntries
                            );

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_preList);
                _preList = (LPRASENTRYNAMEA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _preList)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_preList && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_preList);
        _preList = NULL;
        _dwEntries = 0;
    }

    return;
}

RasEnumHelp::~RasEnumHelp()
{
    if(_preList)
    {
        LocalFree(_preList);
    }
}

DWORD
RasEnumHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumHelp::GetEntryCount()
{
    return _dwEntries;
}

LPWSTR
RasEnumHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if(dwConnectionNum >= _dwEntries)
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYNAMEW lpTemp = (LPRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYNAMEW lpTemp = (LPW2KRASENTRYNAMEW)_preList;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1,
                _szCurrentEntryA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szCurrentEntryA;
        }
        break;
        }
    }

    return pszName;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEnumConnHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEnumConnHelp::RasEnumConnHelp()
{
    DWORD           dwBufSize;

    // init
    _dwConnections = 0;
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASCONNW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASCONNW);
        break;
    }

    // allocate space for MAX_CONNECTION entries
    dwBufSize = MAX_CONNECTION * _dwStructSize;
    _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
    if(_pRasCon == NULL)
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasEnumConnHelp::~RasEnumConnHelp()
{
    if(_pRasCon)
    {
        LocalFree(_pRasCon);
        _pRasCon = NULL;
    }
}

DWORD RasEnumConnHelp::Enum()
{
    DWORD           dwBufSize;

    _dwLastError = 0;

    if(_pRasCon)
    {
        dwBufSize = MAX_CONNECTION * _dwStructSize;
        do
        {
            // set up list
            _pRasCon[0].dwSize = _dwStructSize;

            // call ras to enumerate
            _dwLastError = ERROR_UNKNOWN;
            switch(_EnumType)
            {
                case ENUM_UNICODE:
                case ENUM_WIN2K:
                    _dwLastError = _RasEnumConnectionsW((LPRASCONNW)_pRasCon, &dwBufSize, &_dwConnections);
                    break;
            }

            // reallocate buffer if necessary
            if(ERROR_BUFFER_TOO_SMALL == _dwLastError)
            {
                LocalFree(_pRasCon);
                _pRasCon = (LPRASCONNA)LocalAlloc(LPTR, dwBufSize);
                if(NULL == _pRasCon)
                {
                    _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
                    break;
                }
            }
            else
            {
                break;
            }

        } while(TRUE);
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetError()
{
    return _dwLastError;
}

DWORD
RasEnumConnHelp::GetConnectionsCount()
{
    return _dwConnections;
}

LPWSTR
RasEnumConnHelp::GetEntryW(DWORD dwConnectionNum)
{
    LPWSTR  pwszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
            pwszName = lpTemp[dwConnectionNum].szEntryName;
        break;
        }
    }

    return pwszName;
}

LPSTR
RasEnumConnHelp::GetEntryA(DWORD dwConnectionNum)
{
    LPSTR  pszName = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW )_pRasCon;
        if(*lpTemp[dwConnectionNum].szEntryName)
        {
            WideCharToMultiByte(CP_ACP, 0, lpTemp[dwConnectionNum].szEntryName, -1, _szEntryNameA, RAS_MaxEntryName + 1, NULL, NULL);
            pszName = _szEntryNameA;
        }
        break;
        }
    }

    return pszName;
}

LPWSTR
RasEnumConnHelp::GetLastEntryW(DWORD dwConnectionNum)
{
    UNREFERENCED_PARAMETER(dwConnectionNum);

    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameW;
}

LPSTR
RasEnumConnHelp::GetLastEntryA(DWORD dwConnectionNum)
{
    UNREFERENCED_PARAMETER(dwConnectionNum);

    if(_pRasCon == NULL)
        return NULL;

    return _szEntryNameA;
}

HRASCONN
RasEnumConnHelp::GetHandle(DWORD dwConnectionNum)
{
    HRASCONN hTemp = NULL;

    if((_pRasCon == NULL) || (dwConnectionNum >= _dwConnections))
    {
        return NULL;
    }

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASCONNW lpTemp = (LPRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASCONNW lpTemp = (LPW2KRASCONNW)_pRasCon;
        hTemp = lpTemp[dwConnectionNum].hrasconn;
        break;
        }
    }

    return hTemp;
}

/////////////////////////////////////////////////////////////////////////////
//
// RasEntryPropHelp
//
/////////////////////////////////////////////////////////////////////////////
RasEntryPropHelp::RasEntryPropHelp()
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        _dwStructSize = sizeof(RASENTRYW);
        break;
    case ENUM_WIN2K:
        _dwStructSize = sizeof(W2KRASENTRYW);
        break;
    }

    _pRasEntry = (LPRASENTRYA)LocalAlloc(LPTR, _dwStructSize * 2);
    if(_pRasEntry)
    {
        _pRasEntry->dwSize = _dwStructSize;
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    if(_pRasEntry && (ERROR_SUCCESS != _dwLastError))
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
    return;
}

RasEntryPropHelp::~RasEntryPropHelp()
{
    if(_pRasEntry)
    {
        LocalFree(_pRasEntry);
        _pRasEntry = NULL;
    }
}

DWORD RasEntryPropHelp::GetError()
{
    return _dwLastError;
}

DWORD RasEntryPropHelp::GetA(LPSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1 );
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        MultiByteToWideChar(CP_ACP, 0, lpszEntryName, -1, _szEntryNameW, RAS_MaxEntryName + 1);
        _dwLastError = _RasGetEntryPropertiesW(NULL, _szEntryNameW, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

DWORD RasEntryPropHelp::GetW(LPWSTR lpszEntryName)
{
    DWORD dwSize = _dwStructSize * 2;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
        {
        LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    case ENUM_WIN2K:
        {
        LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
        _dwLastError = _RasGetEntryPropertiesW(NULL, lpszEntryName, (LPRASENTRYW)lpTemp, &dwSize, NULL, NULL);
        break;
        }
    }

    return(_dwLastError);
}

LPWSTR RasEntryPropHelp::GetDeviceTypeW(VOID)
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
                lpwstr = lpTemp->szDeviceType;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetDeviceTypeA(VOID)
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szDeviceType)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szDeviceType, -1, _szDeviceTypeA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szDeviceTypeA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodiallDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
                lpwstr = lpTemp->szAutodialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodiallDllA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialDll)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialDll, -1, _szAutodialDllA, MAX_PATH, NULL, NULL);
                lpstr = _szAutodialDllA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetAutodialFuncW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
                lpwstr = lpTemp->szAutodialFunc;
            break;
            }
        }
    }

    return lpwstr;
}

LPSTR RasEntryPropHelp::GetAutodialFuncA()
{
    LPSTR lpstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAutodialFunc)
            {
                WideCharToMultiByte(CP_ACP, 0, lpTemp->szAutodialFunc, -1, _szAutodialFuncA, RAS_MaxDeviceType + 1, NULL, NULL);
                lpstr = _szAutodialFuncA;
            }
            break;
            }
        }
    }

    return lpstr;
}

LPWSTR RasEntryPropHelp::GetCustomDialDllW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:      // Not is NT4
            break;
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry  ;
            if(*lpTemp->szCustomDialDll)
                lpwstr = lpTemp->szCustomDialDll;
            break;
            }
        }
    }

    return lpwstr;
}

LPWSTR RasEntryPropHelp::GetPhoneNumberW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szLocalPhoneNumber)
                lpwstr = lpTemp->szLocalPhoneNumber;
            break;
            }
        }
    }

    return lpwstr;
}


DWORD RasEntryPropHelp::GetCountryCode()
{
    DWORD dwCode = 0;

    if(_pRasEntry)
    {
        // country code is at the same place for all versions of the struct,
        // so take the shortcut
        dwCode = _pRasEntry->dwCountryCode;
    }

    return dwCode;
}

DWORD RasEntryPropHelp::GetOptions()
{
    DWORD dwOptions = 0;

    if(_pRasEntry)
    {
        // dwfOptions is at the same place for all versions of the struct,
        // so take the shortcut
        dwOptions = _pRasEntry->dwfOptions;
    }

    return dwOptions;
}

LPWSTR RasEntryPropHelp::GetAreaCodeW()
{
    LPWSTR lpwstr = NULL;

    if(_pRasEntry)
    {
        switch(_EnumType)
        {
        case ENUM_UNICODE:
            {
            LPRASENTRYW lpTemp = (LPRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        case ENUM_WIN2K:
            {
            LPW2KRASENTRYW lpTemp = (LPW2KRASENTRYW)_pRasEntry;
            if(*lpTemp->szAreaCode)
                lpwstr = lpTemp->szAreaCode;
            break;
            }
        }
    }

    return lpwstr;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
RasGetConnectStatusHelp::RasGetConnectStatusHelp(HRASCONN hrasconn)
{
    // init
    _dwLastError = 0;

    switch(_EnumType)
    {
    case ENUM_UNICODE:
    case ENUM_WIN2K:
        _dwStructSize = sizeof(RASCONNSTATUSW);
        break;
    }

    _pRasConnStatus = (LPRASCONNSTATUSA)LocalAlloc(LPTR, _dwStructSize);
    if(_pRasConnStatus)
    {
        _pRasConnStatus->dwSize = _dwStructSize;

        _dwLastError = _RasGetConnectStatusW(hrasconn, (LPRASCONNSTATUSW)_pRasConnStatus);

        if(_pRasConnStatus && (ERROR_SUCCESS != _dwLastError))
        {
            LocalFree(_pRasConnStatus);
            _pRasConnStatus = NULL;
        }
    }
    else
    {
        _dwLastError = ERROR_NOT_ENOUGH_MEMORY;
    }

    return;
}

RasGetConnectStatusHelp::~RasGetConnectStatusHelp()
{
    _dwLastError = 0;
    if(_pRasConnStatus)
    {
        LocalFree(_pRasConnStatus);
        _pRasConnStatus = NULL;
    }
}

DWORD RasGetConnectStatusHelp::GetError()
{
    return _dwLastError;
}

RASCONNSTATE RasGetConnectStatusHelp::ConnState()
{
    RASCONNSTATE hConnState = (RASCONNSTATE)NULL;

    if(_pRasConnStatus)
    {
        LPRASCONNSTATUSW lpTemp = (LPRASCONNSTATUSW)_pRasConnStatus;
        hConnState = lpTemp->rasconnstate;
    }

    return hConnState;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\registry.cxx ===
/*++


Copyright (c) 1994  Microsoft Corporation

Module Name:

    registry.cxx

Abstract:

    Functions to read/write registry parameters

    Contents:
        OpenInternetSettingsKey
        CloseInternetSettingsKey
        InternetGetComputerName
        InternetDeleteRegistryValue
        InternetReadRegistryDword
        InternetWriteRegistryDword
        InternetReadRegistryString
        InternetWriteRegistryString
        InternetReadRegistryBinary
        (InternetReadRegistryDwordKey)
        (InternetReadRegistryStringKey)
        (InternetReadRegistryBinaryKey)
        (InternetGetPrivateProfileString)
        (ReadRegistryOemString)
        (WriteRegistryDword)
        ReadRegistryDword

Author:

    Richard L Firth (rfirth) 20-Mar-1995

Environment:

    Win32(s) user-level DLL

Revision History:

    20-Mar-1995 rfirth
        Created

--*/

#include <wininetp.h>

char vszDelimiters[] = ";, ";

//
// manifests
//

#define INTERNET_CLIENT_KEY         "Internet Settings"
#define SYSTEM_INI_FILE_NAME        "SYSTEM.INI"
#define NETWORK_SECTION_NAME        "Network"
#define COMPUTER_NAME_VALUE         "ComputerName"
#define PROFILE_INT_BUFFER_LENGTH   128

#define MIME_TO_FILE_EXTENSION_KEY  "MIME\\Database\\Content Type\\"
#define EXTENSION_VALUE             "Extension"

//
// macros
//

#define INTERNET_SETTINGS_KEY       "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
#define INTERNET_CACHE_SETTINGS_KEY "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\5.0\\Cache"

//
// private prototypes
//

PRIVATE
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue,
    IN LPCSTR keyToReadFrom
    );

PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength,
    IN LPCSTR keyToReadFrom
    );

//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    );

PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    );




PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    );

//
// private data
//

PRIVATE HKEY hKeyInternetSettings = NULL;

//
// functions
//


DWORD
OpenInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Opens registry key for Internet Settings branch

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_NOT_ENOUGH_MEMORY

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "OpenInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (!GeneralInitCritSec.Lock())
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
        goto quit;
    }

    if (hKeyInternetSettings == NULL) {

        DWORD dwDisposition;

        REGCREATEKEYEX(HKEY_LOCAL_MACHINE,
                       INTERNET_SETTINGS_KEY,
                       0,     // reserved
                       NULL,  // class
                       0,     // options
                       KEY_READ | KEY_WRITE,
                       NULL,  // security attributes
                       &hKeyInternetSettings,
                       &dwDisposition
                       );
    }

    GeneralInitCritSec.Unlock();

quit:
    DEBUG_LEAVE(error);

    return error;
}


DWORD
CloseInternetSettingsKey(
    VOID
    )

/*++

Routine Description:

    Closes Internet Settings registry key

Arguments:

    None.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure -

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "CloseInternetSettingsKey",
                 NULL
                 ));

    DWORD error = ERROR_SUCCESS;

    if (hKeyInternetSettings != NULL) {
        error = REGCLOSEKEY(hKeyInternetSettings);
        hKeyInternetSettings = NULL;
    }

    DEBUG_LEAVE(error);

    return error;
}


PUBLIC
DWORD
InternetDeleteRegistryValue(
    IN LPSTR ParameterName
    )

/*++

Routine Description:

    Delets an entry from a the Internet Client registry key if the platform
    is NT/Win95.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DWORD error;

    DEBUG_ENTER((DBG_REGISTRY,
                Dword,
                "InternetDeleteRegistryValue",
                "%q",
                ParameterName
                ));


    HKEY clientKey;

    //
    // open the registry key containing the Internet client values (this is
    // in the same place on NT and Win95)
    //

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_SETTINGS_KEY,
                         0, // reserved
                         KEY_ALL_ACCESS,
                         &clientKey
                         );


    if (error == ERROR_SUCCESS) {

        error = RegDeleteValue(clientKey,
                               ParameterName
                               );

        REGCLOSEKEY(clientKey);
    }


    DEBUG_LEAVE(error);

    return error;
}




DWORD
InternetReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = InternetReadRegistryDwordKey(HKEY_LOCAL_MACHINE,
                                               ParameterName,
                                               ParameterValue
                                               );

    DEBUG_LEAVE(error);

    return error;
}

#ifdef WININET6

DWORD
InternetIDEWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity 
                ? WriteIDRegDword(ParameterName, ParameterValue)
                : InternetWriteRegistryDword(ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetIDEReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    If we're in an identity-mode, we'll read from the special location.
    Otherwise, read from the old location.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetIDEReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = GlobalIdentity
                ? ReadIDRegDword(ParameterName, ParameterValue)
                : InternetReadRegistryDwordKey(HKEY_CURRENT_USER, ParameterName, ParameterValue);

    DEBUG_LEAVE(error);

    return error;
}
#endif


DWORD
InternetCacheReadRegistryDword(
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetCacheReadRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey;

    error = REGOPENKEYEX(HKEY_CURRENT_USER,
                         INTERNET_CACHE_SETTINGS_KEY,
                         0, // reserved
                         KEY_QUERY_VALUE,
                         &clientKey
                         );

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        REGCLOSEKEY(clientKey);
    }

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetWriteRegistryDword(
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a single DWORD from to the Internet Client registry key if the platform
    is NT/Win95, otherwise it fails.

Arguments:

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - value to store in registry.

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetWriteRegistryDword",
                 "%q, %x",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;

    if (hKeyInternetSettings != NULL) {
        error = WriteRegistryDword(hKeyInternetSettings,
                                   ParameterName,
                                   ParameterValue
                                   );
    } else {
        error = ERROR_SUCCESS;
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetWriteRegistryDword(%q): value = %d (%#x)\n",
                ParameterName,
                ParameterValue,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}



DWORD
InternetReadRegistryString(
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryString",
                 "%q, %x, %x [%d]",
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    DWORD error = InternetReadRegistryStringKey(HKEY_CURRENT_USER,
                                                ParameterName,
                                                ParameterValue,
                                                ParameterLength
                                                );

    DEBUG_LEAVE(error);

    return error;
}

//
//DWORD
//InternetWriteRegistryString(
//    IN LPCSTR ParameterName,
//    IN LPSTR ParameterValue
//    )
//
///*++
//
//Routine Description:
//
//    Writes a string to the Internet Client registry key on NT/Win95, or writes
//    the corresponding value to SYSTEM.INI on Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to string to write
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure -
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetWriteRegistryString",
//                 "%.40q, %.80q",
//                 ParameterName,
//                 ParameterValue
//                 ));
//
//    DWORD error;
//
//    if (IsPlatformWin32s()) {
//
//        BOOL ok;
//
//        ok = WritePrivateProfileString(INTERNET_CLIENT_KEY,
//                                       ParameterName,
//                                       ParameterValue,
//                                       SYSTEM_INI_FILE_NAME
//                                       );
//        error = ok ? ERROR_SUCCESS : GetLastError();
//    } else {
//
//        //
//        // BUGBUG - currently, nothing needs to write to registry if NT or Win95
//        //
//
//        INET_ASSERT(FALSE);
//
//    }
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//DWORD
//InternetReadRegistryBinary(
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinary",
//                 "%q, %#x, %#x [%d]",
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//
//    error = InternetReadRegistryBinaryKey(HKEY_CURRENT_USER,
//                                          ParameterName,
//                                          ParameterValue,
//                                          ParameterLength
//                                          );
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}

//
// private functions
//


PUBLIC
DWORD
InternetReadRegistryDwordKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue,
    IN LPCSTR keyToReadFrom
    )

/*++

Routine Description:

    Reads a single DWORD from a the Internet Client registry key if the platform
    is NT/Win95, else reads the value from SYSTEM.INI if we are running on Win32s.

    Does not modify the *ParameterValue if the registry variable cannot be read

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_CURRENT_USER)

    ParameterName   - name of the parameter to retrieve (e.g. AccessType)

    ParameterValue  - pointer to place to store retrieved value

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryDwordKey",
                 "%s, %q, %x",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             keyToReadFrom,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryDword(clientKey,
                                  ParameterName,
                                  ParameterValue
                                  );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryDwordKey(%q): value = %d (%#x)\n",
                ParameterName,
                *ParameterValue,
                *ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
InternetReadRegistryStringKey(
    IN HKEY ParameterKey,
    IN LPCSTR ParameterName,
    OUT LPSTR ParameterValue,
    IN OUT LPDWORD ParameterLength,
    IN LPCSTR keyToReadFrom
    )

/*++

Routine Description:

    Reads a string from the Internet Client registry key on NT/Win95, or reads
    the corresponding value from SYSTEM.INI on a Win32s platform

Arguments:

    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)

    ParameterName   - name of value parameter within key (e.g. EmailName)

    ParameterValue  - pointer to string buffer for returned string

    ParameterLength - IN: number of bytes in ParameterValue
                      OUT: number of bytes in string (excluding trailing '\0')

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "InternetReadRegistryStringKey",
                 "%s (%x), %q, %x, %x [%d]",
                 (ParameterKey == HKEY_LOCAL_MACHINE)
                    ? "HKEY_LOCAL_MACHINE"
                    : (ParameterKey == HKEY_CURRENT_USER)
                        ? "HKEY_CURRENT_USER"
                        : "???",
                 ParameterKey,
                 ParameterName,
                 ParameterValue,
                 ParameterLength,
                 *ParameterLength
                 ));

    //
    // zero-terminate the string
    //

    if (*ParameterLength > 0) {
        *ParameterValue = '\0';
    }

    DWORD error = ERROR_SUCCESS;
    HKEY clientKey = hKeyInternetSettings;

    if (ParameterKey != HKEY_CURRENT_USER) {
        error = REGOPENKEYEX(ParameterKey,
                             keyToReadFrom,
                             0, // reserved
                             KEY_QUERY_VALUE,
                             &clientKey
                             );
    } else if (clientKey == NULL) {
        error = ERROR_PATH_NOT_FOUND;
    }

    if (error == ERROR_SUCCESS) {
        error = ReadRegistryOemString(clientKey,
                                      ParameterName,
                                      ParameterValue,
                                      ParameterLength
                                      );
        if (clientKey != hKeyInternetSettings) {
            REGCLOSEKEY(clientKey);
        }
    }

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("InternetReadRegistryStringKey(%q): value = %q\n",
                ParameterName,
                ParameterValue
                ));

    DEBUG_LEAVE(error);

    return error;
}

//
//PRIVATE
//DWORD
//InternetReadRegistryBinaryKey(
//    IN HKEY ParameterKey,
//    IN LPCSTR ParameterName,
//    OUT LPBYTE ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads a binary value from the Internet Client registry key on NT/Win95, or
//    reads the corresponding value from SYSTEM.INI on a Win32s platform
//
//Arguments:
//
//    ParameterKey    - root registry key (e.g. HKEY_LOCAL_MACHINE)
//
//    ParameterName   - name of value parameter within key (e.g. EmailName)
//
//    ParameterValue  - pointer to buffer for returned data
//
//    ParameterLength - IN: number of bytes in ParameterValue
//                      OUT: number of bytes in buffer, or required size
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                    The parameter wasn't found
//
//                  ERROR_MORE_DATA
//                    The buffer isn't large enough
//
//--*/
//
//{
//    DEBUG_ENTER((DBG_REGISTRY,
//                 Dword,
//                 "InternetReadRegistryBinaryKey",
//                 "%s (%x), %q, %#x, %#x [%d]",
//                 (ParameterKey == HKEY_LOCAL_MACHINE)
//                    ? "HKEY_LOCAL_MACHINE"
//                    : (ParameterKey == HKEY_CURRENT_USER)
//                        ? "HKEY_CURRENT_USER"
//                        : "???",
//                 ParameterKey,
//                 ParameterName,
//                 ParameterValue,
//                 ParameterLength,
//                 *ParameterLength
//                 ));
//
//    DWORD error;
//    HKEY clientKey;
//
//    //
//    // open the registry key containing the Internet client values (this is
//    // in the same place on NT and Win95)
//    //
//
//    error = REGOPENKEYEX(ParameterKey,
//                         INTERNET_SETTINGS_KEY,
//                         0, // reserved
//                         KEY_QUERY_VALUE,
//                         &clientKey
//                         );
//
//    if (error == ERROR_SUCCESS) {
//
//        DWORD valueType;
//
//        error = RegQueryValueEx(clientKey,
//                                ParameterName,
//                                NULL,   // reserved
//                                &valueType,
//                                ParameterValue,
//                                ParameterLength
//                                );
//        REGCLOSEKEY(clientKey);
//    }
//
//    DEBUG_PRINT(REGISTRY,
//                INFO,
//                ("InternetReadRegistryBinaryKey(%q): length = %d\n",
//                ParameterName,
//                *ParameterLength
//                ));
//
//    DEBUG_LEAVE(error);
//
//    return error;
//}
//
//
//PRIVATE
//DWORD
//InternetGetPrivateProfileString(
//    IN LPSTR IniFileName,
//    IN LPSTR SectionName,
//    IN LPCSTR ParameterName,
//    OUT LPSTR ParameterValue,
//    IN OUT LPDWORD ParameterLength
//    )
//
///*++
//
//Routine Description:
//
//    Reads an string out of an INI file. Mainly just for Win32s
//
//Arguments:
//
//    IniFileName     - name of INI file to read
//
//    SectionName     - name of section in INI file to read
//
//    ParameterName   - name of entry in section to read
//
//    ParameterValue  - returned string
//
//    ParameterLength - IN: Length of ParameterValue
//                      OUT: Number of characters in ParameterValue, excluding
//                           terminating NUL
//
//Return Value:
//
//    DWORD
//        Success - ERROR_SUCCESS
//
//        Failure - ERROR_PATH_NOT_FOUND
//                  ERROR_FILE_NOT_FOUND
//
//--*/
//
//{
//    DWORD error;
//    DWORD nChars;
//
//    nChars = GetPrivateProfileString(SectionName,
//                                     ParameterName,
//                                     "",                // lpszDefault
//                                     ParameterValue,
//                                     *ParameterLength,
//                                     IniFileName
//                                     );
//    if (nChars > 0) {
//        *ParameterLength = nChars;
//        error = ERROR_SUCCESS;
//    } else {
//        error = ERROR_PATH_NOT_FOUND;
//    }
//    return error;
//}


PRIVATE
DWORD
ReadRegistryOemString(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPSTR String,
    IN OUT LPDWORD Length
    )

/*++

Routine Description:

    Reads a string out of the registry as an OEM string

Arguments:

    Key             - open registry key where to read value from

    ParameterName   - name of registry value to read

    String          - place to put it

    Length          - IN: length of String buffer in characters
                      OUT: length of String in characters, as if returned from
                      strlen()

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_FILE_NOT_FOUND
                    Couldn't find the parameter

                  ERROR_PATH_NOT_FOUND
                    Couldn't find the parameter
--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryOemString",
                 "%#x, %q, %#x, %#x [%d]",
                 Key,
                 ParameterName,
                 String,
                 Length,
                 *Length
                 ));

    LONG error;
    DWORD valueType;
    DWORD valueLength;

    //
    // first, get the length of the string
    //

    valueLength = *Length;
    error = RegQueryValueEx(Key,
                            ParameterName,
                            NULL, // reserved
                            &valueType,
                            (LPBYTE)String,
                            &valueLength
                            );
    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // we only support REG_SZ (single string) values in this function
    //

    if (valueType != REG_SZ) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // if 1 or 0 chars returned then the string is empty
    //

    if (valueLength <= sizeof(char)) {
        error = ERROR_PATH_NOT_FOUND;
        goto quit;
    }

    //
    // convert the ANSI string to OEM character set in place. According to Win
    // help, this always succeeds
    //

    CharToOem(String, String);

    //
    // return the length as if returned from strlen() (i.e. drop the '\0')
    //

    *Length = valueLength - sizeof(char);

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("ReadRegistryOemString(%q) returning %q (%d chars)\n",
                ParameterName,
                String,
                *Length
                ));

quit:

    DEBUG_LEAVE(error);

    return error;
}


DWORD
ReadRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    OUT LPDWORD ParameterValue
    )

/*++

Routine Description:

    Reads a DWORD parameter from the registry

    Won't modify *ParameterValue unless a valid value is read from the registry

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to read

    ParameterValue  - returned DWORD parameter read from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "ReadRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(*ParameterValue);
    error = (DWORD)RegQueryValueEx(Key,
                                   ParameterName,
                                   NULL, // reserved
                                   &valueType,
                                   (LPBYTE)&value,
                                   &valueLength
                                   );

    //
    // if the size or type aren't correct then return an error, else only if
    // success was returned do we modify *ParameterValue
    //

    if (error == ERROR_SUCCESS) {
        if (((valueType != REG_DWORD)
        && (valueType != REG_BINARY))
        || (valueLength != sizeof(DWORD))) {

            DEBUG_PRINT(REGISTRY,
                        ERROR,
                        ("valueType = %d, valueLength = %d\n",
                        valueType,
                        valueLength
                        ));

            error = ERROR_PATH_NOT_FOUND;
        } else {
            *ParameterValue = value;
        }
    }

    DEBUG_LEAVE(error);

    return error;
}


PRIVATE
DWORD
WriteRegistryDword(
    IN HKEY Key,
    IN LPCSTR ParameterName,
    IN DWORD ParameterValue
    )

/*++

Routine Description:

    Writes a DWORD parameter from the registry

    Will write ParameterValue to the key.

Arguments:

    Key             - handle of open registry key where parameter resides

    ParameterName   - name of DWORD parameter to write

    ParameterValue  - DWORD parameter to write from registry

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_PATH_NOT_FOUND
                    One of the following occurred:
                        - the parameter is not in the specified registry key
                        - the parameter is the wrong type
                        - the parameter is the wrong size

--*/

{
    DEBUG_ENTER((DBG_REGISTRY,
                 Dword,
                 "WriteRegistryDword",
                 "%x, %q, %x",
                 Key,
                 ParameterName,
                 ParameterValue
                 ));

    DWORD error;
    DWORD valueLength;
    DWORD valueType;
    DWORD value;

    valueLength = sizeof(ParameterValue);
    valueType   = REG_DWORD;
    value       = ParameterValue;

    error = (DWORD)RegSetValueEx(Key,
                                 ParameterName,
                                 NULL, // reserved
                                 valueType,
                                 (LPBYTE)&value,
                                 valueLength
                                 );

    DEBUG_PRINT(REGISTRY,
                INFO,
                ("added: valueType = %d, valueLength = %d\n",
                valueType,
                valueLength
                ));

    DEBUG_LEAVE(error);

    return error;
}

#if INET_DEBUG

typedef struct {
    LIST_ENTRY entry;
    HKEY hkey;
    char * file;
    int line;
    char name[1];
} DBGREGKEYINFO;

SERIALIZED_LIST DbgRegKeyList;

VOID DbgRegKey_Init(VOID) {
    InitializeSerializedList(&DbgRegKeyList);
}

VOID DbgRegKey_Terminate(VOID) {
    TerminateSerializedList(&DbgRegKeyList);
}

void regkey_add(const char * name, HKEY hkey, char * file, int line) {

    if (!name) {
        name = "";
    }

    int len = lstrlen(name);
    DBGREGKEYINFO * p = (DBGREGKEYINFO *)ALLOCATE_FIXED_MEMORY(sizeof(DBGREGKEYINFO) + len);

    if (p) {
//dprintf("Wininet.DbgRegKey: adding %q\n", name);
        memcpy(p->name, name, len + 1);
        p->line = line;
        p->file = file;
        p->hkey = hkey;
        InsertAtHeadOfSerializedList(&DbgRegKeyList, &p->entry);
    }
}

void regkey_remove(HKEY hkey) {
    if (LockSerializedList(&DbgRegKeyList))
    {

        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {
                RemoveFromSerializedList(&DbgRegKeyList, (PLIST_ENTRY)p);
//dprintf("Wininet.DbgRegKey: removing %q\n", p->name);
                FREE_MEMORY(p);
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }
}

char * regkey_name(HKEY hkey, const char * subname) {
    switch ((INT_PTR)hkey) {
    case (INT_PTR)HKEY_CLASSES_ROOT:
        return NEW_STRING("HKEY_CLASSES_ROOT");

    case (INT_PTR)HKEY_CURRENT_USER:
        return NEW_STRING("HKEY_CURRENT_USER");

    case (INT_PTR)HKEY_LOCAL_MACHINE:
        return NEW_STRING("HKEY_LOCAL_MACHINE");

    case (INT_PTR)HKEY_USERS:
        return NEW_STRING("HKEY_USERS");

    case (INT_PTR)HKEY_PERFORMANCE_DATA:
        return NEW_STRING("HKEY_PERFORMANCE_DATA");

    case (INT_PTR)HKEY_CURRENT_CONFIG:
        return NEW_STRING("HKEY_CURRENT_CONFIG");

    case (INT_PTR)HKEY_DYN_DATA:
        return NEW_STRING("HKEY_DYN_DATA");
    }

    char * name = NULL;

    if (LockSerializedList(&DbgRegKeyList))
    {
        DBGREGKEYINFO * p = (DBGREGKEYINFO *)HeadOfSerializedList(&DbgRegKeyList);

        while (p != (DBGREGKEYINFO *)SlSelf(&DbgRegKeyList)) {
            if (p->hkey == hkey) {

                int len = lstrlen(p->name);
                int slen = lstrlen(subname);

                name = (char *)ALLOCATE_FIXED_MEMORY(len + 1 + slen + 1);
                if (name) {
                    memcpy(name, p->name, len);
                    name[len] = '\\';
                    memcpy(name + len + 1, subname, slen + 1);
                }
                break;
            }
            p = (DBGREGKEYINFO *)p->entry.Flink;
        }
        UnlockSerializedList(&DbgRegKeyList);
    }

    return name;
}

void regkey_freename(char * name) {
    if (name) {
        FREE_MEMORY(name);
    }
}

LONG
DbgRegOpenKey(
    IN HKEY hKey,
    IN LPCTSTR lpszSubKey,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpszSubKey);
    LONG rc = RegOpenKey(hKey, lpszSubKey, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegOpenKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD ulOptions,
    IN REGSAM samDesired,
    OUT PHKEY phkResult,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegOpenKeyEx(hKey, lpSubKey, ulOptions, samDesired, phkResult);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCreateKeyEx(
    IN HKEY hKey,
    IN LPCSTR lpSubKey,
    IN DWORD Reserved,
    IN LPSTR lpClass,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD lpdwDisposition,
    char * file,
    int line
    )
{
    char * keyname = regkey_name(hKey, lpSubKey);
    LONG rc = RegCreateKeyEx(hKey, lpSubKey, Reserved, lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);

    if (rc == 0) {
        regkey_add(keyname, *phkResult, file, line);
    }
    regkey_freename(keyname);
    return rc;
}

LONG
DbgRegCloseKey(
    IN HKEY hKey
    )
{
    LONG rc = RegCloseKey(hKey);

    if (rc == 0) {
        regkey_remove(hKey);
    }
    return rc;
}

#endif // INET_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\thrdinfo.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    thrdinfo.cxx

Abstract:

    Functions to manipulate an INTERNET_THREAD_INFO

    Contents:
        InternetCreateThreadInfo
        InternetDestroyThreadInfo
        InternetTerminateThreadInfo
        InternetGetThreadInfo
        InternetSetThreadInfo
        InternetIndicateStatusAddress
        InternetIndicateStatusString
        InternetIndicateStatusNewHandle
        InternetIndicateStatus
        InternetSetLastError
        _InternetSetLastError
        InternetLockErrorText
        InternetUnlockErrorText
        InternetSetObjectHandle
        InternetGetObjectHandle
        InternetFreeThreadInfo

Author:

    Richard L Firth (rfirth) 16-Feb-1995

Environment:

    Win32 user-level DLL

Revision History:

    16-Feb-1995 rfirth
        Created

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// manifests
//

#define BAD_TLS_INDEX   0xffffffff  // according to online win32 SDK documentation
#ifdef SPX_SUPPORT
#define GENERIC_SPX_NAME   "SPX Server"
#endif //SPX_SUPPORT
//
// macros
//

#ifdef ENABLE_DEBUG

#define InitializeInternetThreadInfo(lpThreadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->Signature = INTERNET_THREAD_INFO_SIGNATURE; \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#else

#define InitializeInternetThreadInfo(threadInfo) \
    InitializeListHead(&lpThreadInfo->List); \
    lpThreadInfo->ThreadId = GetCurrentThreadId();

#endif // ENABLE_DEBUG

//
// private data
//

PRIVATE DWORD InternetTlsIndex = BAD_TLS_INDEX;
PRIVATE SERIALIZED_LIST ThreadInfoList;



LPINTERNET_THREAD_INFO
InternetCreateThreadInfo(
    IN BOOL SetTls,
    IN LPINTERNET_THREAD_INFO lpPreStaticAllocatedThreadInfo
    )

/*++

Routine Description:

    Creates, initializes an INTERNET_THREAD_INFO. Optionally (allocates and)
    sets this thread's Internet TLS

    Assumes: 1. The first time this function is called is in the context of the
                process attach library call, so we allocate the TLS index once

Arguments:

    SetTls  - TRUE if we are to set the INTERNET_THREAD_INFO TLS for this thread

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to allocated INTERNET_THREAD_INFO structure which has
                  been set as this threads value in its InternetTlsIndex slot

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    BOOL ok = FALSE;

    if (InDllCleanup)
    {
        goto quit;
    }

    if (InternetTlsIndex == BAD_TLS_INDEX)
    {

        //
        // first time through, initialize serialized list
        //

        InitializeSerializedList(&ThreadInfoList);

        //
        // we assume that if we are allocating the TLS index, then this is the
        // one and only thread in this process that can call into this DLL
        // right now - i.e. this thread is loading the DLL
        //

        InternetTlsIndex = TlsAlloc();
    }

    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        if (lpPreStaticAllocatedThreadInfo != NULL)
        {
            lpThreadInfo = lpPreStaticAllocatedThreadInfo;
            memset(lpThreadInfo, 0, sizeof(INTERNET_THREAD_INFO));
#if INET_DEBUG
            lpThreadInfo->fStaticAllocation = TRUE;
#endif
        }
        else
        {
            lpThreadInfo = NEW(INTERNET_THREAD_INFO);
            // lpThreadInfo->fStaticAllocation = FALSE; implicitly set
        }

        if (lpThreadInfo != NULL)
        {
            InitializeInternetThreadInfo(lpThreadInfo);
            if (SetTls)
            {
                ok = TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo);
                if (!ok) 
                {
                    DEBUG_PUT(("InternetCreateThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                             InternetTlsIndex,
                             lpThreadInfo,
                             GetLastError()
                             ));

                    DEBUG_BREAK(THRDINFO);
                }
            }
            else 
            {
                ok = TRUE;
            }
        }
        else 
        {
            DEBUG_PUT(("InternetCreateThreadInfo(): NEW(INTERNET_THREAD_INFO) returned NULL\n"));

            DEBUG_BREAK(THRDINFO);
        }
    }
    else 
    {
        DEBUG_PUT(("InternetCreateThreadInfo(): TlsAlloc() returns %#x, error %d\n",
                 BAD_TLS_INDEX,
                 GetLastError()
                 ));

        DEBUG_BREAK(THRDINFO);
    }

    if (ok)
    {
        // only dynamically allocated threadinfo's are put into the
        // ThreadInfoList -- statically preallocated threadinfo's must
        // not go into the ThreadInfoList
        if (lpPreStaticAllocatedThreadInfo == NULL)
        {
            if (!InsertAtHeadOfSerializedList(&ThreadInfoList, &lpThreadInfo->List))
            {
                ok = FALSE;
            }
        }
    }

    // If something failed, then delete any dynamically allocated threadinfo
    if (!ok)
    {
        if ((lpPreStaticAllocatedThreadInfo == NULL) && (lpThreadInfo != NULL))
        {
            DEL(lpThreadInfo);
        }

        lpThreadInfo = NULL;
    }

quit:
    return lpThreadInfo;
}


VOID
InternetDestroyThreadInfo(
    VOID
    )

/*++

Routine Description:

    Cleans up the INTERNET_THREAD_INFO - deletes any memory it owns and deletes
    it

Arguments:

    None.

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    IF_DEBUG(NOTHING)
    {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: Deleting INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }

    //
    // don't call InternetGetThreadInfo() - we don't need to create the
    // INTERNET_THREAD_INFO if it doesn't exist in this case
    //

    lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    if (lpThreadInfo != NULL)
    {
#if INET_DEBUG

        //
        // there shouldn't be anything in the debug record stack. On Win95, we
        // ignore this check if this is the async scheduler (nee worker) thread
        // AND there are entries in the debug record stack. The async thread
        // gets killed off before it has chance to DEBUG_LEAVE, then comes here,
        // causing this assert to be over-active
        //

        if (IsPlatformWin95() && lpThreadInfo->IsAsyncWorkerThread)
        {
            if (lpThreadInfo->CallDepth != 0)
            {
                DEBUG_PUT(("InternetDestroyThreadInfo(): "
                            "Thread %#x: "
                            "%d records in debug stack\n",
                            lpThreadInfo->CallDepth
                            ));
            }
        }
        else
        {
            INET_ASSERT(lpThreadInfo->Stack == NULL);

        }

#endif // INET_DEBUG

        InternetFreeThreadInfo(lpThreadInfo);

        INET_ASSERT(InternetTlsIndex != BAD_TLS_INDEX);

        TlsSetValue(InternetTlsIndex, NULL);
    }
    else
    {
        DEBUG_PUT(("InternetDestroyThreadInfo(): Thread %#x: no INTERNET_THREAD_INFO\n",
                    GetCurrentThreadId()
                    ));
    }
}


VOID
InternetFreeThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Removes the INTERNET_THREAD_INFO from the list and frees all allocated
    blocks

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO to remove and free

Return Value:

    None.

--*/

{
    if (RemoveFromSerializedList(&ThreadInfoList, &lpThreadInfo->List))
    {
        if (lpThreadInfo->hErrorText != NULL)
        {
            FREE_MEMORY(lpThreadInfo->hErrorText);
        }

        //if (lpThreadInfo->lpResolverInfo != NULL) {
        //    if (lpThreadInfo->lpResolverInfo->DnrSocketHandle != NULL) {
        //        lpThreadInfo->lpResolverInfo->DnrSocketHandle->Dereference();
        //    }
        //    DEL(lpThreadInfo->lpResolverInfo);
        //}

        INET_ASSERT(!lpThreadInfo->fStaticAllocation);
        DEL(lpThreadInfo);
    }
}


VOID
InternetTerminateThreadInfo(
    VOID
    )

/*++

Routine Description:

    Destroy all INTERNET_THREAD_INFO structures and terminate the serialized
    list. This funciton called at process detach time.

    At DLL_PROCESS_DETACH time, there may be other threads in the process for
    which we created an INTERNET_THREAD_INFO that aren't going to get the chance
    to delete the structure, so we do it here.

    Code in this module assumes that it is impossible for a new thread to enter
    this DLL while we are terminating in DLL_PROCESS_DETACH

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // get rid of this thread's info structure. No more debug output after this!
    //

    InternetDestroyThreadInfo();

    //
    // get rid of the thread info structures left by other threads
    //

    if (LockSerializedList(&ThreadInfoList))
    {
        LPINTERNET_THREAD_INFO lpThreadInfo;

        while (NULL != (lpThreadInfo = (LPINTERNET_THREAD_INFO)SlDequeueHead(&ThreadInfoList)))
        {
            //
            // already dequeued, no need to call InternetFreeThreadInfo()
            //

            INET_ASSERT(!lpThreadInfo->fStaticAllocation);
            FREE_MEMORY(lpThreadInfo);
        }

        UnlockSerializedList(&ThreadInfoList);
    }

    //
    // no more need for list
    //

    TerminateSerializedList(&ThreadInfoList);

    //
    // or TLS index
    //

    TlsFree(InternetTlsIndex);
    InternetTlsIndex = BAD_TLS_INDEX;
}


LPINTERNET_THREAD_INFO
InternetGetThreadInfo(
    VOID
    )

/*++

Routine Description:

    Gets the pointer to the INTERNET_THREAD_INFO for this thread and checks
    that it still looks good.

    If this thread does not have an INTERNET_THREAD_INFO then we create one,
    presuming that this is a new thread

Arguments:

    None.

Return Value:

    LPINTERNET_THREAD_INFO
        Success - pointer to INTERNET_THREAD_INFO block

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo = NULL;
    DWORD lastError;

    //
    // this is pretty bad - TlsGetValue() can destroy the per-thread last error
    // variable if it returns NULL (to indicate that NULL was actually set, and
    // that NULL does not indicate an error). So we have to read it before it is
    // potentially destroyed, and reset it before we quit.
    //
    // We do this here because typically, other functions will be completely
    // unsuspecting of this behaviour, and it is better to fix it once here,
    // than in several dozen other places, even though it is slightly
    // inefficient
    //

    lastError = GetLastError();

    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        lpThreadInfo = (LPINTERNET_THREAD_INFO)TlsGetValue(InternetTlsIndex);
    }

    //
    // we may be in the process of creating the INTERNET_THREAD_INFO, in
    // which case its okay for this to be NULL. According to online SDK
    // documentation, a threads TLS value will be initialized to NULL
    //

    if (lpThreadInfo == NULL)
    {
        //
        // we presume this is a new thread. Create an INTERNET_THREAD_INFO
        //

        IF_DEBUG(NOTHING) {
            DEBUG_PUT(("InternetGetThreadInfo(): Thread %#x: Creating INTERNET_THREAD_INFO\n",
                      GetCurrentThreadId()
                      ));
        }

        lpThreadInfo = InternetCreateThreadInfo(TRUE);
    }
    if (lpThreadInfo != NULL)
    {
        INET_ASSERT(lpThreadInfo->Signature == INTERNET_THREAD_INFO_SIGNATURE);
        INET_ASSERT(lpThreadInfo->ThreadId == GetCurrentThreadId());
    }
    else
    {
        DEBUG_PUT(("InternetGetThreadInfo(): Failed to get/create INTERNET_THREAD_INFO\n"));
    }

    //
    // as above - reset the last error variable in case TlsGetValue() trashed it
    //

    SetLastError(lastError);

    //
    // actual success/failure indicated by non-NULL/NULL pointer resp.
    //

    return lpThreadInfo;
}


VOID
InternetSetThreadInfo(
    IN LPINTERNET_THREAD_INFO lpThreadInfo
    )

/*++

Routine Description:

    Sets lpThreadInfo as the current thread's INTERNET_THREAD_INFO. Used within
    fibers

Arguments:

    lpThreadInfo    - new INTERNET_THREAD_INFO to set

Return Value:

    None.

--*/

{
    if (InternetTlsIndex != BAD_TLS_INDEX)
    {
        if (!TlsSetValue(InternetTlsIndex, (LPVOID)lpThreadInfo))
        {
            DEBUG_PUT(("InternetSetThreadInfo(): TlsSetValue(%d, %#x) returns %d\n",
                     InternetTlsIndex,
                     lpThreadInfo,
                     GetLastError()
                     ));

            INET_ASSERT(FALSE);
        }
    }
    else
    {

        DEBUG_PUT(("InternetSetThreadInfo(): InternetTlsIndex = %d\n",
                 InternetTlsIndex
                 ));

        INET_ASSERT(FALSE);
    }
}


DWORD
InternetIndicateStatusAddress(
    IN DWORD dwInternetStatus,
    IN LPSOCKADDR lpSockAddr,
    IN DWORD dwSockAddrLength
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a network address that we
    need to convert to a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpSockAddr          - pointer to full socket address

    dwSockAddrLength    - length of lpSockAddr in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    LPSTR lpAddress;
    INT len;
    
    UNREFERENCED_PARAMETER(dwSockAddrLength);

    INET_ASSERT(lpSockAddr != NULL);

    switch (lpSockAddr->sa_family) 
    {
    case AF_INET:
        lpAddress = _I_inet_ntoa(
                        ((struct sockaddr_in*)lpSockAddr)->sin_addr
                        );
        break;
        
    case AF_INET6:
        char Address[INET6_ADDRSTRLEN+3]; //  + 2 brkt chars + null char
        int error;

        Address[0] = '[';

        error = _I_getnameinfo(lpSockAddr, sizeof(SOCKADDR_IN6),
                               Address+1, sizeof(Address)-2, NULL, 0,
                               NI_NUMERICHOST);
        if (error)
            lpAddress = NULL;
        else {
            len = lstrlen(Address);
            Address[len] = ']';
            Address[len+1] = '\0';
            lpAddress = Address;
        }
        break;


    case AF_IPX:

        //
        // BUGBUG - this should be a call to WSAAddressToString, but that's not implemented yet
        //
#ifdef SPX_SUPPORT
        lpAddress = GENERIC_SPX_NAME;
#else
        lpAddress = NULL;
#endif //SPX_SUPPORT
        break;

    default:
        lpAddress = NULL;
        break;
    }
    // we don't want a client to mess around with a winsock-internal buffer
    return InternetIndicateStatusString(dwInternetStatus, lpAddress, TRUE/*bCopyBuffer*/);
}


DWORD
InternetIndicateStatusString(
    IN DWORD dwInternetStatus,
    IN LPSTR lpszStatusInfo OPTIONAL,
    IN BOOL  bCopyBuffer,
    IN BOOL  bConvertToUnicode
    )

/*++

Routine Description:

    Make a status callback to the app. The data is a string

Arguments:

    dwInternetStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpszStatusInfo      - string status data

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusString",
                "%d, %q",
                dwInternetStatus,
                lpszStatusInfo
                ));

    DWORD length;

    if (ARGUMENT_PRESENT(lpszStatusInfo)) 
    {
        length = strlen(lpszStatusInfo) + 1;
    } 
    else 
    {
        length = 0;
    }

    DWORD error;

    error = InternetIndicateStatus(dwInternetStatus, lpszStatusInfo, length, bCopyBuffer, bConvertToUnicode);

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatusNewHandle(
    IN LPVOID hInternetMapped
    )

/*++

Routine Description:

    Indicates to the app a new handle

Arguments:

    hInternetMapped - mapped address of new handle being indicated

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the either the new object handle or the
                    parent object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatusNewHandle",
                "%#x",
                hInternetMapped
                ));

    HANDLE_OBJECT * hObject = (HANDLE_OBJECT *)hInternetMapped;

    //
    // reference the new request handle, in case the app closes it in the
    // callback. The new handle now has a reference count of 3
    //

    hObject->Reference();

    INET_ASSERT(hObject->ReferenceCount() == 3);

    //
    // we indicate the pseudo handle to the app
    //

    HINTERNET hInternet = hObject->GetPseudoHandle();

    DWORD error = InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HANDLE_CREATED,
                                         (LPVOID)&hInternet,
                                         sizeof(hInternet)
                                         );

    //
    // dereference the new request handle. If this returns TRUE then the new
    // handle has been deleted (the app called InternetCloseHandle() against
    // it which dereferenced it to 1, and now we've dereferenced it to zero)
    //

    hObject->Dereference();
     
    if (error == ERROR_WINHTTP_OPERATION_CANCELLED) 
    {
        //
        // the parent handle was deleted. Kill off the new handle too
        //

        WinHttpCloseHandle(hObject);

        //BOOL ok;
        //ok = hObject->Dereference();

        // INET_ASSERT(ok);

        INET_ASSERT(hObject->ReferenceCount() == 1); // now only ref'ed by the API
    }
    else if (hObject->IsInvalidated())
    {
        INET_ASSERT(hObject->ReferenceCount() == 1);    // now only ref'ed by the API

        error = ERROR_WINHTTP_OPERATION_CANCELLED;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetIndicateStatus(
    IN DWORD dwStatus,
    IN LPVOID lpBuffer,
    IN DWORD dwLength,
    IN BOOL bCopyBuffer,
    IN BOOL bConvertToUnicode
    )

/*++

Routine Description:

    If the app has registered a callback function for the object that this
    thread is operating on, call it with the arguments supplied

Arguments:

    dwStatus    - WINHTTP_CALLBACK_STATUS_ value

    lpBuffer    - pointer to variable data buffer

    dwLength    - length of *lpBuffer in bytes

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - ERROR_WINHTTP_OPERATION_CANCELLED
                    The app closed the object handle during the callback

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetIndicateStatus",
                "%s, %#x, %d",
                InternetMapStatus(dwStatus),
                lpBuffer,
                dwLength
                ));

    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    DWORD error = ERROR_SUCCESS;

    //
    // the app can affect callback operation by specifying a zero context value
    // meaning no callbacks will be generated for this API
    //

    if (lpThreadInfo != NULL) 
    {

        INET_ASSERT(lpThreadInfo->hObject != NULL);
        INET_ASSERT(lpThreadInfo->hObjectMapped != NULL);

        //
        // if the context value in the thread info block is 0 then we use the
        // context from the handle object
        //

        DWORD_PTR context;

        context = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetContext();

        WINHTTP_STATUS_CALLBACK appCallback;

        appCallback = ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        IF_DEBUG(THRDINFO) 
        {
            switch (dwStatus) 
            {
                case WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s\n",
                                InternetMapStatus(dwStatus)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE:
                case WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: #bytes = %d [%#x]\n",
                                InternetMapStatus(dwStatus),
                                *((DWORD*)lpBuffer),
                                *((DWORD*)lpBuffer)
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_READ_COMPLETE:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: Buffer = %#x, Number of bytes = %d\n",
                                InternetMapStatus(dwStatus),
                                lpBuffer,
                                dwLength
                                ));
                    break;
                case WINHTTP_CALLBACK_STATUS_REQUEST_ERROR:
                    DEBUG_PRINT(THRDINFO,
                                INFO,
                                ("%s: failure api = %d, Number of bytes = %d [%#x, %#s] \n",
                                InternetMapStatus(dwStatus),
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwResult,
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError,
                                InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                                ));
            }

        }


        if( dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR)
        {
            TRACE_PRINT_API(THRDINFO,
                        INFO,
                        ("%s: Failure API = %s, Error = %s\n",
                        InternetMapStatus(dwStatus),
                        InternetMapRequestError( (DWORD) ((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwResult),
                        InternetMapError(((LPWINHTTP_ASYNC_RESULT)lpBuffer)->dwError)
                        ));
        }

        if ((appCallback != NULL) &&
            (((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsNotificationEnabled(dwStatus)) )
        {
            LPVOID pInfo; //reported thru callback
            DWORD infoLength; //reported thru callback
            BOOL isAsyncWorkerThread;
            BYTE buffer[256];

            //
            // we make a copy of the info to remove the app's opportunity to
            // change it. E.g. if we were about to resolve host name "foo" and
            // passed the pointer to our buffer containing "foo", the app could
            // change the name to "bar", changing the intended server
            //

            if (lpBuffer != NULL) 
            {
                if (bConvertToUnicode)
                {
                    INET_ASSERT( ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->IsUnicodeStatusCallback() );

                    INET_ASSERT(    
                        (dwStatus == WINHTTP_CALLBACK_STATUS_RESOLVING_NAME)        || 
                        (dwStatus == WINHTTP_CALLBACK_STATUS_NAME_RESOLVED)         ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_REDIRECT)              ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTING_TO_SERVER)  ||
                        (dwStatus == WINHTTP_CALLBACK_STATUS_CONNECTED_TO_SERVER)
                        );
                        
                    infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer,
                                                                dwLength, NULL, 0);
                    if (infoLength == 0)
                    {
                        pInfo = NULL;
                                
                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                    dwLength
                                    ));
                    }
                    else if (infoLength <= sizeof(buffer)/sizeof(WCHAR))
                    {
                        pInfo = buffer;
                    }
                    else
                    {
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(infoLength * sizeof(WCHAR));
                    }
                    
                    if (pInfo)
                    {
                        infoLength = MultiByteToWideChar(CP_ACP, 0, (LPSTR)lpBuffer, 
                                                                dwLength, (LPWSTR)pInfo, infoLength);
                        if (infoLength == 0)
                        {
                            //MBtoWC failed
                            if (pInfo != buffer)
                                FREE_FIXED_MEMORY(pInfo);
                            pInfo = NULL;
                                
                            DEBUG_PRINT(THRDINFO,
                                        ERROR,
                                        ("MultiByteToWideChar returned 0 for a %d-length MBCS string\n",
                                        dwLength
                                        ));
                        }
                    } //pInfo
                    else
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("MultiByteToWideChar() error OR Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    } //pInfo == NULL
                } //bConvertToUnicode
                else if (bCopyBuffer)
                {
                    if (dwLength <= sizeof(buffer))
                        pInfo = buffer;
                    else
                        pInfo = (LPVOID)ALLOCATE_FIXED_MEMORY(dwLength);

                    if (pInfo)
                    {
                        memcpy(pInfo, lpBuffer, dwLength);
                        infoLength = dwLength;
                    }
                    else 
                    {
                        infoLength = 0;

                        DEBUG_PRINT(THRDINFO,
                                    ERROR,
                                    ("Failed to allocate %d bytes for info\n",
                                    dwLength
                                    ));

                    }
                } //bCopyBuffer
                else
                {
                    pInfo = lpBuffer;
                    infoLength = dwLength;

                    INET_ASSERT(dwLength
                                || (WINHTTP_CALLBACK_STATUS_READ_COMPLETE == dwStatus));
                } //!bCopyBuffer && !bConvertToUnicode
            } //lpBuffer != NULL
            else 
            {
                pInfo = NULL;
                infoLength = 0;
            }

            //
            // we're about to call into the app. We may be in the context of an
            // async worker thread, and if the callback submits an async request
            // then we'll execute it synchronously. To avoid this, we will reset
            // the async worker thread indicator in the INTERNET_THREAD_INFO and
            // restore it when the app returns control to us. This way, if the
            // app makes an API request during the callback, on a handle that
            // has async I/O semantics, then we will simply queue it, and not
            // try to execute it synchronously
            //

            isAsyncWorkerThread = lpThreadInfo->IsAsyncWorkerThread;
            lpThreadInfo->IsAsyncWorkerThread = FALSE;

            BOOL bInCallback = lpThreadInfo->InCallback;

            lpThreadInfo->InCallback = TRUE;

            INET_ASSERT(!IsBadCodePtr((FARPROC)appCallback));

            DEBUG_ENTER((DBG_THRDINFO,
                         None,
                         "(*callback)",
                         "%#x, %#x, %s (%d), %#x [%#x], %d",
                         lpThreadInfo->hObject,
                         context,
                         InternetMapStatus(dwStatus),
                         dwStatus,
                         pInfo,
                         ((dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CREATED)
                         || (dwStatus == WINHTTP_CALLBACK_STATUS_HANDLE_CLOSING))
                            ? (DWORD_PTR)*(LPHINTERNET)pInfo
                            : (((dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_SENT)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_RESPONSE_RECEIVED)
                            || (dwStatus == WINHTTP_CALLBACK_STATUS_INTERMEDIATE_RESPONSE))
                                ? *(LPDWORD)pInfo
                                : 0),
                         infoLength
                         ));

            PERF_LOG(PE_APP_CALLBACK_START,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            HINTERNET hObject = lpThreadInfo->hObject;
            LPVOID hObjectMapped = lpThreadInfo->hObjectMapped;

            appCallback(lpThreadInfo->hObject,
                        context,
                        dwStatus,
                        pInfo,
                        infoLength
                        );

            lpThreadInfo->hObject = hObject;
            lpThreadInfo->hObjectMapped = hObjectMapped;

            PERF_LOG(PE_APP_CALLBACK_END,
                     dwStatus,
                     lpThreadInfo->ThreadId,
                     lpThreadInfo->hObject
                     );

            DEBUG_LEAVE(0);

            lpThreadInfo->InCallback = bInCallback;
            lpThreadInfo->IsAsyncWorkerThread = isAsyncWorkerThread;

            //
            // free the buffer
            //

            // We should free the memory only if we have done an ALLOCATE_FIXED_MEMORY in this function:
            if (pInfo != NULL && pInfo != lpBuffer && pInfo != buffer) {
                FREE_FIXED_MEMORY(pInfo);
            }
        } else {

            DEBUG_PRINT(THRDINFO,
                        ERROR,
                        ("%#x: callback = %#x, context = %#x\n",
                        lpThreadInfo->hObject,
                        appCallback,
                        context
                        ));

            //
            // if we're completing a request then we shouldn't be here - it
            // means we lost the context or callback address somewhere along the
            // way
            //

            // don't need the ASSERTS below.
            // It could also mean something as benign as the notification not being enabled:
            /*
            INET_ASSERT(
                    dwStatus != WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                &&  dwStatus != WINHTTP_CALLBACK_STATUS_READ_COMPLETE
                );
            */

#ifdef DEBUG
            if ( 
                    dwStatus == WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_WRITE_COMPLETE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_REQUEST_ERROR
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_DATA_AVAILABLE
                ||  dwStatus == WINHTTP_CALLBACK_STATUS_READ_COMPLETE
            )
            {
                INET_ASSERT(appCallback != NULL);
                /*
                    These are not valid asserts in winhttp.
                    Contexts don't control whether callbacks are made or not.
                 */
                //INET_ASSERT(context != NULL);
                //INET_ASSERT(_InternetGetContext(lpThreadInfo) != NULL);
            }
#endif


        }
        
        //
        // if the object is now invalid then the app closed the handle in
        // the callback, or from an external thread and the entire operation is cancelled
        // propagate this error back to calling code.
        //
        if (((HANDLE_OBJECT *)lpThreadInfo->hObjectMapped)->IsInvalidated()) 
        {
            error = ERROR_WINHTTP_OPERATION_CANCELLED;
        }
    } else {

        //
        // this is catastrophic if the indication was async request completion
        //

        DEBUG_PUT(("InternetIndicateStatus(): no INTERNET_THREAD_INFO?\n"));

    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
InternetSetLastError(
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Copies the error text to the per-thread error buffer (moveable memory)

Arguments:

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "InternetSetLastError",
                "%d, %.80q, %d, %#x",
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD error;
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {
        error = _InternetSetLastError(lpThreadInfo,
                                      ErrorNumber,
                                      ErrorText,
                                      ErrorTextLength,
                                      Flags
                                      );
    } else {

        DEBUG_PUT(("InternetSetLastError(): no INTERNET_THREAD_INFO\n"));

        error = ERROR_WINHTTP_INTERNAL_ERROR;
    }

    DEBUG_LEAVE(error);

    return error;
}


DWORD
_InternetSetLastError(
    IN LPINTERNET_THREAD_INFO lpThreadInfo,
    IN DWORD ErrorNumber,
    IN LPSTR ErrorText,
    IN DWORD ErrorTextLength,
    IN DWORD Flags
    )

/*++

Routine Description:

    Sets or resets the last error text in an INTERNET_THREAD_INFO block

Arguments:

    lpThreadInfo    - pointer to INTERNET_THREAD_INFO

    ErrorNumber     - protocol-specific error code

    ErrorText       - protocol-specific error text (from server). The buffer is
                      NOT zero-terminated

    ErrorTextLength - number of characters in ErrorText

    Flags           - Flags that control how this function operates:

                        SLE_APPEND          TRUE if ErrorText is to be appended
                                            to the text already in the buffer

                        SLE_ZERO_TERMINATE  TRUE if ErrorText must have a '\0'
                                            appended to it

Return Value:

    DWORD
        Success - ERROR_SUCCESS

        Failure - Win32 error

--*/

{
    DEBUG_ENTER((DBG_THRDINFO,
                Dword,
                "_InternetSetLastError",
                "%#x, %d, %.80q, %d, %#x",
                lpThreadInfo,
                ErrorNumber,
                ErrorText,
                ErrorTextLength,
                Flags
                ));

    DWORD currentLength = 0;
    DWORD newTextLength;
    DWORD error;

    newTextLength = ErrorTextLength;

    //
    // if we are appending text, then account for the '\0' currently at the end
    // of the buffer (if it exists)
    //

    if (Flags & SLE_APPEND) {
        currentLength = lpThreadInfo->ErrorTextLength;
        if (currentLength != 0) {
            --currentLength;
        }
        newTextLength += currentLength;
    }

    if (Flags & SLE_ZERO_TERMINATE) {
        ++newTextLength;
    }

    //
    // expect success (and why not?)
    //

    error = ERROR_SUCCESS;

    //
    // allocate, grow or shrink the buffer to fit. The buffer is moveable. If
    // the buffer is being shrunk to zero size then NULL will be returned as
    // the buffer handle from ResizeBuffer()
    //

    lpThreadInfo->hErrorText = ResizeBuffer(lpThreadInfo->hErrorText,
                                            newTextLength,
                                            FALSE
                                            );
    if (lpThreadInfo->hErrorText != NULL) {

        LPSTR lpErrorText;

        lpErrorText = (LPSTR)LOCK_MEMORY(lpThreadInfo->hErrorText);

        INET_ASSERT(lpErrorText != NULL);

        if (lpErrorText != NULL) {
            if (Flags & SLE_APPEND) {
                lpErrorText += currentLength;
            }
            memcpy(lpErrorText, ErrorText, ErrorTextLength);
            if (Flags & SLE_ZERO_TERMINATE) {
                lpErrorText[ErrorTextLength++] = '\0';
            }

            //
            // the text should always be zero-terminated. We expect this in
            // InternetGetLastResponseInfo()
            //

            INET_ASSERT(lpErrorText[ErrorTextLength - 1] == '\0');

            UNLOCK_MEMORY(lpThreadInfo->hErrorText);

        } else {

            //
            // real error occurred - failed to lock memory?
            //

            error = GetLastError();
        }
    } else {

        INET_ASSERT(newTextLength == 0);

        newTextLength = 0;
    }

    //
    // set the error code and text length
    //

    lpThreadInfo->ErrorTextLength = newTextLength;
    lpThreadInfo->ErrorNumber = ErrorNumber;

    DEBUG_LEAVE(error);

    return error;
}


LPSTR
InternetLockErrorText(
    VOID
    )

/*++

Routine Description:

    Returns a pointer to the locked per-thread error text buffer

Arguments:

    None.

Return Value:

    LPSTR
        Success - pointer to locked buffer

        Failure - NULL

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo != NULL) {

        HLOCAL lpErrorText;

        lpErrorText = lpThreadInfo->hErrorText;
        if (lpErrorText != (HLOCAL)NULL) {
            return (LPSTR)LOCK_MEMORY(lpErrorText);
        }
    }
    return NULL;
}

//
//VOID
//InternetUnlockErrorText(
//    VOID
//    )
//
///*++
//
//Routine Description:
//
//    Unlocks the per-thread error text buffer locked by InternetLockErrorText()
//
//Arguments:
//
//    None.
//
//Return Value:
//
//    None.
//
//--*/
//
//{
//    LPINTERNET_THREAD_INFO lpThreadInfo;
//
//    lpThreadInfo = InternetGetThreadInfo();
//
//    //
//    // assume that if we locked the error text, there must be an
//    // INTERNET_THREAD_INFO when we come to unlock it
//    //
//
//    INET_ASSERT(lpThreadInfo != NULL);
//
//    if (lpThreadInfo != NULL) {
//
//        HLOCAL hErrorText;
//
//        hErrorText = lpThreadInfo->hErrorText;
//
//        //
//        // similarly, there must be a handle to the error text buffer
//        //
//
//        INET_ASSERT(hErrorText != NULL);
//
//        if (hErrorText != (HLOCAL)NULL) {
//            UNLOCK_MEMORY(hErrorText);
//        }
//    }
//}


VOID
InternetSetObjectHandle(
    IN HINTERNET hInternet,
    IN HINTERNET hInternetMapped
    )

/*++

Routine Description:

    Sets the hObject field in the INTERNET_THREAD_INFO structure so we can get
    at the handle contents, even when we're in a function that does not take
    the hInternet as a parameter

Arguments:

    hInternet       - handle of object we may need info from

    hInternetMapped - mapped handle of object we may need info from

Return Value:

    None.

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        _InternetSetObjectHandle(lpThreadInfo, hInternet, hInternetMapped);
    }
}


HINTERNET
InternetGetObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObject value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObject;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}


HINTERNET
InternetGetMappedObjectHandle(
    VOID
    )

/*++

Routine Description:

    Just returns the hObjectMapped value stored in our INTERNET_THREAD_INFO

Arguments:

    None.

Return Value:

    HINTERNET
        Success - non-NULL handle value

        Failure - NULL object handle (may not have been set)

--*/

{
    LPINTERNET_THREAD_INFO lpThreadInfo;
    HINTERNET hInternet;

    lpThreadInfo = InternetGetThreadInfo();

    if (lpThreadInfo != NULL) {
        hInternet = lpThreadInfo->hObjectMapped;
    } else {
        hInternet = NULL;
    }
    return hInternet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\apsvc\apsvcdefs.h ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    apsvcdefs.cpp

Abstract:

    Auto-proxy service global definitions.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#ifndef _AUTO_PROXY_DEFS
#define _AUTO_PROXY_DEFS

#define AP_INFO                     4L
#define AP_WARNING                  2L
#define AP_ERROR                    1L

void LOG_EVENT(DWORD dwEventType, char* format, ...);

BOOL InitializeEventLog(void);
void TerminateEventLog(void);

#ifdef DBG
#define AP_ASSERT(fVal) if (!fVal) DebugBreak();
#else
#define AP_ASSERT(fVal)
#endif

#define AUTOPROXY_SERVICE_STOP_WAIT_HINT    8000
#define AUTOPROXY_SERVICE_START_WAIT_HINT   1000

#define WINHTTP_AUTOPROXY_SERVICE_NAME L"WinHttpAutoProxySvc"
#define AUTOPROXY_L_RPC_PROTOCOL_SEQUENCE L"ncalrpc"

#define AUTOPROXY_SVC_IDLE_TIMEOUT 15    // unit: minutes
#define AUTOPROXY_SVC_IDLE_CHECK_INTERVAL 90    // unit: seconds

void LOG_DEBUG_EVENT(DWORD dwEventType, char* format, ...);

void LOG_EVENT(DWORD dwEventType, DWORD dwEventID, LPCWSTR lpwszInsert = NULL);
void LOG_EVENT(DWORD dwEventType, DWORD dwEventID, LPCWSTR pwszFuncName, DWORD dwWin32Error);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\apsvc\eventlog.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    eventlog.cpp

Abstract:

    Implements NT event log for the Auto-Proxy Service.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#include "wininetp.h"

static HANDLE g_hEventLog = 0;

BOOL InitializeEventLog(void)
{
    g_hEventLog = ::RegisterEventSourceA(NULL, "WinHttpAutoProxySvc");

    return g_hEventLog != NULL;
}

int cdecl _sprintf(char* buffer, size_t buf_size, char* format, va_list args);

void LOG_DEBUG_EVENT(DWORD dwEventType, char* format, ...)
{
    if (g_hEventLog == NULL)
    {
        return;
    }

    va_list args;
    int n;
    char *pBuffer = (char *) ALLOCATE_FIXED_MEMORY(1024);

    if (pBuffer == NULL)
        return;

    va_start(args, format);
    n = _sprintf(pBuffer, 1024, format, args);    
    va_end(args);
    
    LPCSTR pszMessages[1];
    pszMessages[0] = &pBuffer[0];

    ::ReportEvent(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventType,
                  NULL,
                  1,
                  0,
                  &pszMessages[0],
                  NULL);

    FREE_MEMORY(pBuffer);
}

void LOG_EVENT(DWORD dwEventType, DWORD dwEventID, LPCWSTR pwszFuncName, DWORD dwWin32Error)
{
    DWORD dwFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_ARGUMENT_ARRAY;
    LPVOID lpvSource = NULL;
    LPWSTR lpwszWin32ErrorText = NULL;
    
    WCHAR wErrorCode[16] = {0};
    LPCWSTR Args[3] = { NULL };

    if ((dwWin32Error > WINHTTP_ERROR_BASE) && (dwWin32Error <= WINHTTP_ERROR_LAST))
    {
        dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;

        lpvSource = GetModuleHandle("winhttp.dll");
    }
    else
    {
        dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }

    ::FormatMessageW(dwFlags,
                     lpvSource,
                     dwWin32Error,
                     MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                     (LPWSTR)&lpwszWin32ErrorText,
                     0,
                     NULL);

    ::swprintf(wErrorCode, L"%d", dwWin32Error);

    Args[0] = pwszFuncName;
    Args[1] = lpwszWin32ErrorText;
    Args[2] = wErrorCode;

    ::ReportEventW(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventID,
                  NULL,
                  3,
                  0,
                  &Args[0],
                  NULL);

    if (lpwszWin32ErrorText)
    {
        ::LocalFree(lpwszWin32ErrorText);
    }
}

void LOG_EVENT(DWORD dwEventType, DWORD dwEventID, LPCWSTR lpwszInsert = NULL)
{
    LPCWSTR Args[1] = { NULL };
    LPCWSTR* pArgs = NULL;
    WORD nArgs = 0;

    if (lpwszInsert)
    {
        Args[0] = lpwszInsert;
        pArgs = &Args[0];
        nArgs = 1;
    }

    ::ReportEventW(g_hEventLog, 
                  (WORD)dwEventType,
                  0,
                  dwEventID,
                  NULL,
                  nArgs,
                  0,
                  pArgs,
                  NULL);
}

void TerminateEventLog(void)
{
    if (g_hEventLog)
    {
        ::DeregisterEventSource(g_hEventLog);
        g_hEventLog = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\auth.h ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    auth.h

Abstract:

    Private include file for 

Author:

    Rajeev Dujari (rajeevd) 28-Jul-97
    
Revision History:

--*/

//
// manifests
//
 
#define HTTP_AUTHORIZATION_SZ           "Authorization:"
#define HTTP_AUTHORIZATION_LEN          (sizeof(HTTP_AUTHORIZATION_SZ)-1)

#define HTTP_PROXY_AUTHORIZATION_SZ     "Proxy-Authorization:"
#define HTTP_PROXY_AUTHORIZATION_LEN    (sizeof(HTTP_PROXY_AUTHORIZATION_SZ)-1)


//
// prototypes - versions of spluginx.hxx for basic auth
//


void UrlZonesDetach (void);

//#ifdef __cplusplus
//extern "C" {
//#endif

extern DWORD g_cSspiContexts; // refcount of sspi contexts

DWORD SSPI_Unload();

DWORD_PTR SSPI_InitScheme (LPCSTR pszScheme);

//#ifdef __cplusplus
//} // end extern "C" {
//#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\api\sendapi.cxx ===
/*++

Copyright (c) 1994 Microsoft Corporation

Module Name:

    sendapi.cxx

Abstract:

    This file contains the implementation of the HttpSendRequestA API.

    Contents:
        WinHttpSendRequest
        HttpSendRequestA
        WinHttpReceiveResponse
        HttpWrapSendRequest

Author:

    Keith Moore (keithmo) 16-Nov-1994

Revision History:

      29-Apr-97 rfirth
        Conversion to FSM

--*/

#include <wininetp.h>
#include <perfdiag.hxx>

//
// private prototypes
//

PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    OUT HTTP_REQUEST_HANDLE_OBJECT** pHandleToDeref,
    IN DWORD_PTR dwContext=NULL
    );

//
// functions
//

INTERNETAPI
BOOL
WINAPI
HttpSendRequestA(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER((DBG_API,
                Bool,
                "HttpSendRequestA",
                "%#x, %.80q, %d, %#x, %d",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength
                ));


    BOOL fRet= HttpWrapSendRequest(
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                0,
                AR_HTTP_SEND_REQUEST,
                NULL
                );


    DEBUG_LEAVE(fRet);

    return fRet;
}

INTERNETAPI
BOOL
WINAPI
WinHttpSendRequest(
    IN HINTERNET hRequest,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwTotalLength,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

--*/

{
    DEBUG_ENTER2_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    TRACE_ENTER2_API((DBG_API,
                Bool,
                "WinHttpSendRequest",
                hRequest,
                "%#x, %.80wq, %d, %#x, %d, %d, %x",
                hRequest,
                !lpszHeaders || IsBadReadPtr(lpszHeaders, 1)? L"": lpszHeaders,
                dwHeadersLength,
                lpOptional,
                dwOptionalLength,
                dwTotalLength,
                dwContext
                ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;
    MEMORYPACKET mpHeaders;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
        goto cleanup;
    }

    if (lpszHeaders && IsBadReadPtr(lpszHeaders, 1))
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    if (dwHeadersLength == -1L)
    {
        dwHeadersLength = lpszHeaders ? lstrlenW(lpszHeaders) : 0;
    }

    if (lpszHeaders)
    {
        if ((dwHeadersLength == -1)
            ? IsBadStringPtrW(lpszHeaders, (UINT_PTR)-1)
            : IsBadReadPtr(lpszHeaders, dwHeadersLength))
        {
            dwErr = ERROR_INVALID_PARAMETER;
            goto cleanup;
        }
        ALLOC_MB(lpszHeaders, dwHeadersLength, mpHeaders);
        if (!mpHeaders.psStr)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanup;
        }
        UNICODE_TO_ANSI(lpszHeaders, mpHeaders);
    }
    if (lpOptional 
        && dwOptionalLength
        && IsBadReadPtr(lpOptional, dwOptionalLength) )
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }
            
    AR_TYPE ar;
    
    // Always require a WinHttpReceiveResponse to initiate
    // FSM_STATE_4 onwards in HTTP_REQUEST_HANDLE_OBJECT::HttpSendRequest_Start:
    if (dwOptionalLength <= dwTotalLength)
    {
        ar = AR_HTTP_BEGIN_SEND_REQUEST;
    }
    else
    {
        dwErr = ERROR_INVALID_PARAMETER;
        goto cleanup;
    }

    HTTP_REQUEST_HANDLE_OBJECT* pRequest = NULL;
    
    fResult = HttpWrapSendRequest(hRequest, mpHeaders.psStr, mpHeaders.dwSize,
                lpOptional, dwOptionalLength, dwTotalLength, ar, &pRequest, dwContext);
    // This calls SetLastError if fResult is FALSE.

    if (fResult)
    {
        if (pRequest)
        {
            InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_SENDREQUEST_COMPLETE,
                                   NULL,
                                   NULL
                                   );

            // So that we have a refcount on the object going into the callback.
            DereferenceObject((LPVOID)pRequest);
        }
    }
    else if ((dwErr = GetLastError()) == ERROR_IO_PENDING)
    {
        SetLastError(dwErr = ERROR_SUCCESS);
        fResult = TRUE;
    }
    
cleanup: 
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(HTTP, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


INTERNETAPI
BOOL
WINAPI
WinHttpReceiveResponse(
    IN HINTERNET hRequest,
    IN LPVOID lpBuffersOut OPTIONAL
    )

/*++

Routine Description:

    description-of-function.

Arguments:

    hRequest        -
    lpBuffersOut    -
    dwFlags         -
    dwContext       -

Return Value:

    BOOL

--*/

{
    DEBUG_ENTER_API((DBG_API,
                     Bool,
                     "WinHttpReceiveResponse",
                     "%#x, %#x",
                     hRequest,
                     lpBuffersOut
                     ));

    DWORD dwErr = ERROR_SUCCESS;
    BOOL fResult = FALSE;

    if (!hRequest)
    {
        dwErr = ERROR_INVALID_HANDLE;
    }
    else if (lpBuffersOut)
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        HTTP_REQUEST_HANDLE_OBJECT* pRequest = NULL;
        fResult = HttpWrapSendRequest(hRequest, NULL, 0, NULL, 0, 0, AR_HTTP_END_SEND_REQUEST, &pRequest);
        
        if (fResult)
        {
            if (pRequest)
            {
                InternetIndicateStatus(WINHTTP_CALLBACK_STATUS_HEADERS_AVAILABLE,
                                       NULL,
                                       NULL
                                       );

                // So that we have a refcount on the object going into the callback.
                DereferenceObject((LPVOID)pRequest);
            }
        }
        else if ((dwErr = GetLastError()) == ERROR_IO_PENDING)
        {
            SetLastError(dwErr = ERROR_SUCCESS);
            fResult = TRUE;
        }
    }
    
    if (dwErr!=ERROR_SUCCESS) 
    { 
        DEBUG_ERROR(HTTP, dwErr);
        SetLastError(dwErr); 
    }
    DEBUG_LEAVE_API(fResult);
    return fResult;
}


PRIVATE
BOOL
HttpWrapSendRequest(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength,
    IN DWORD dwOptionalLengthTotal,
    IN AR_TYPE arRequest,
    OUT HTTP_REQUEST_HANDLE_OBJECT** pHandleToDeref,
    IN DWORD_PTR dwContext
    )

/*++

Routine Description:

    Sends the specified request to the HTTP server.

Arguments:

    hRequest                - An open HTTP request handle returned by
                              HttpOpenRequest()

    lpszHeaders             - Additional headers to be appended to the request.
                              This may be NULL if there are no additional
                              headers to append

    dwHeadersLength         - The length (in characters) of the additional
                              headers. If this is -1L and lpszAdditional is
                              non-NULL, then lpszAdditional is assumed to be
                              zero terminated (ASCIIZ)

    lpOptionalData          - Any optional data to send immediately after the
                              request headers. This is typically used for POST
                              operations. This may be NULL if there is no
                              optional data to send

    dwOptionalDataLength    - The length (in BYTEs) of the optional data. This
                              may be zero if there is no optional data to send

    dwOptionalLengthTotal   - Total length need to be sent for File Upload.

    arRequest               - Which API the caller is making,
                                assumed to be HttpEndRequestA, HttpSendRequestExA, or
                                HttpSendRequestA

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. For more information call GetLastError(). If the
                  request was async, then GetLastError() will return
                  ERROR_IO_PENDING which means that the operation initially
                  succeeded, and that the caller should wait for the status
                  callback to discover the final success/failure status

Comments:

--*/

{
    DEBUG_ENTER((DBG_HTTP,
                 Bool,
                 "HttpWrapSendRequest",
                 "%#x, %.80q, %d, %#x, %d, %d, %x",
                 hRequest,
                 lpszHeaders,
                 dwHeadersLength,
                 lpOptional,
                 dwOptionalLength,
                 dwOptionalLengthTotal,
                 dwContext
                 ));

    PERF_ENTER(HttpWrapSendRequest);

    DWORD error = ERROR_SUCCESS;
    HINTERNET hRequestMapped = NULL;
    BOOL bDeref = TRUE;

    BOOL isLocal;
    BOOL isAsync = FALSE;

    if (!GlobalDataInitialized) {
        error = ERROR_WINHTTP_NOT_INITIALIZED;
        goto done;
    }

    //
    // we will need the thread info for several items
    //

    LPINTERNET_THREAD_INFO lpThreadInfo;

    lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo == NULL) {
        error = ERROR_WINHTTP_INTERNAL_ERROR;
        goto done;
    }

    //
    // the only FSMs that can come before this one are InternetOpenUrl() or
    // HttpSendRequest() when we are performing nested send for https://
    // tunnelling through proxy
    //

    INET_ASSERT((lpThreadInfo->Fsm == NULL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_PARSE_HTTP_URL)
                || (lpThreadInfo->Fsm->GetType() == FSM_TYPE_OPEN_PROXY_TUNNEL)
                );

    INET_ASSERT( arRequest == AR_HTTP_SEND_REQUEST ||
                 arRequest == AR_HTTP_BEGIN_SEND_REQUEST ||
                 arRequest == AR_HTTP_END_SEND_REQUEST );


    //
    // map the handle
    //
    error = MapHandleToAddress(hRequest, (LPVOID *)&hRequestMapped, FALSE);


    if ((error != ERROR_SUCCESS) && (hRequestMapped == NULL)) {
        goto quit;
    }

    //
    // Cast it to the object that we know. We are going to do caching
    // semantics with this
    //

    HTTP_REQUEST_HANDLE_OBJECT * pRequest;

    pRequest = (HTTP_REQUEST_HANDLE_OBJECT *)hRequestMapped;

    //
    // set the context and handle info & reset the error variables,
    // but only if not for a ReceiveResponse call.
    //
    if (arRequest != AR_HTTP_END_SEND_REQUEST)
    {
        if (dwContext)
            pRequest->SetContext(dwContext);
        
        // We need this information to special-case for Redirects and Auth because of RR FSM changes:
        pRequest->SetWriteRequired(dwOptionalLength < dwOptionalLengthTotal);
    }

    //
    //  For a call to WinHttpSendRequest (arRequst == AR_HTTP_BEGIN_SEND_REQUEST), SetProxyTunnelingSuppressWrite()
    //will be called again setting the value to TRUE iff we really are trying to tunnel through a proxy.
    //  For a call to WinHttpReceiveResponse (arRequest == AR_HTTP_END_SEND_REQUEST), WinHttpWriteData is no longer
    //valid to be called, and so writes are suppressed by the request state.  Its appropriate to call 
    //SetProxyTunnelingSuppressWrite(FALSE) in this case to ensure the request's state logic kicks in
    //for denying the request though.
    //
    pRequest->SetProxyTunnelingSuppressWrite(FALSE);
    
    _InternetSetObjectHandle(lpThreadInfo, hRequest, hRequestMapped);
    _InternetClearLastError(lpThreadInfo);

    //
    // quit now if the handle was invalid
    //

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    //
    // use RIsHandleLocal() to discover 4 things:
    //
    //  1. Handle is valid
    //  2. Handle is of expected type (HTTP Request in this case)
    //  3. Handle is local or remote
    //  4. Handle supports async I/O
    //

    error = RIsHandleLocal(hRequestMapped,
                           &isLocal,
                           &isAsync,
                           TypeHttpRequestHandle
                           );

    if (error != ERROR_SUCCESS) {
        goto quit;
    }

    if (isAsync)
    {
        error = InitializeAsyncSupport();
        if (error != ERROR_SUCCESS)
        {
            goto quit;
        }
    }
    //
    // For SEND_REQUEST, and BEGIN_SEND_REQUEST, we need
    //  to do some basic initalization
    //

    if ( arRequest == AR_HTTP_SEND_REQUEST ||
         arRequest == AR_HTTP_BEGIN_SEND_REQUEST)
    {
        error = pRequest->InitBeginSendRequest(lpszHeaders,
                                       dwHeadersLength,
                                       &lpOptional,
                                       &dwOptionalLength,
                                       dwOptionalLengthTotal
                                       );

        if ( error != ERROR_SUCCESS)
        {
            goto quit;
        }

        // (Re)set flag to indicate WinHttpReceiveResponse needs to be called.
        pRequest->SetReceiveResponseState(FALSE);

        // RENO 35599: If sending a new request, ensure the OptionalSaved member
        // variables are cleared out.
        pRequest->ClearSavedOptionalData();
    }
    else if (arRequest == AR_HTTP_END_SEND_REQUEST)
    {
        pRequest->SetReceiveResponseState(TRUE);
    }


    //
    // send the request to the server. This may involve redirections and user
    // authentication
    //

    //error = DoFsm(New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest));
    //if (error == ERROR_IO_PENDING) {
    //    bDeref = FALSE;
    //}
    CFsm_HttpSendRequest * pFsm;

    pFsm = New CFsm_HttpSendRequest(lpOptional, dwOptionalLength, pRequest, arRequest);

    if (pFsm != NULL)
    {
        if (isAsync && !lpThreadInfo->IsAsyncWorkerThread)
        {
            error = StartFsmChain(pFsm, pRequest, TRUE, TRUE);

            if ((error == ERROR_SUCCESS)
                && pHandleToDeref)
            {
                // Deref in the outer api call for sync success in async case.
                *pHandleToDeref = pRequest;
                bDeref = FALSE;
            }
        }
        else
        {
            error = StartFsmChain(pFsm, pRequest, FALSE, FALSE);
        }
        if (error == ERROR_IO_PENDING)
        {
            bDeref = FALSE;
        }
    }
    else
    {
        error = ERROR_NOT_ENOUGH_MEMORY;
    }

quit:

    //
    // if we went async don't deref the handle
    //

    if (bDeref && (hRequestMapped != NULL)) {
        DereferenceObject((LPVOID)hRequestMapped);
    }

done:

    BOOL success = TRUE;

    // SetLastError must be called after PERF_LEAVE !!!
    PERF_LEAVE(HttpWrapSendRequest);

    if (error != ERROR_SUCCESS) 
    {
        DEBUG_ERROR(HTTP, error);
        SetLastError(error);
        success = FALSE;
    }

    DEBUG_LEAVE(success);
    return success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\apsvc\rpcsrv.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    rpcsrv.cpp

Abstract:

    Implements the L-RPC server for the system Auto-Proxy Service.

Author:

    Biao Wang (biaow) 10-May-2002

--*/

#include "wininetp.h"
#include <Rpcdce.h>
#include "apsvcdefs.h"
#include "apsvc.h"
#include "rpcsrv.h"

extern AUTOPROXY_RPC_SERVER* g_pRpcSrv;

#ifdef ENABLE_DEBUG
extern HKEY                  g_hKeySvcParams;
#endif


/*
    This is the security callback function that we specified when we registered our RPC interface 
    during AUTOPROXY_RPC_SERVER::Open(). It will be called on every connect attempt by a client, 
    and in this context we need to make sure that the client call is via Local RPC from the local
    machine.
*/
RPC_STATUS 
RPC_ENTRY
RpcSecurityCallback (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    UNREFERENCED_PARAMETER(InterfaceUuid);

    // todo: sanity checking on InterfaceUuid ?

    if (g_pRpcSrv == NULL)
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT);

        return RPC_S_ACCESS_DENIED;
    }

    return g_pRpcSrv->OnSecurityCallback(Context);
}

RPC_STATUS AUTOPROXY_RPC_SERVER::OnSecurityCallback(void *Context)
{
    UNREFERENCED_PARAMETER(Context);

    RPC_STATUS RpcStatus;

    // note: I_RpcBindingInqTransportType() is a no-yet-published API that RPC folks told me to use
    //       for better performance
    
    unsigned int TransportType;
    RpcStatus = ::I_RpcBindingInqTransportType(NULL, // test the current call 
                                               &TransportType);
                                               
    if ((RpcStatus == RPC_S_OK) && (TransportType == TRANSPORT_TYPE_LPC))
    {
        return RPC_S_OK;
    }
    else
    {
        if (RpcStatus != RPC_S_OK)
        {
            LOG_EVENT(AP_ERROR,
                      MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                      L"I_RpcBindingInqTransportType()",
                      RpcStatus);
        }

        if (TransportType != TRANSPORT_TYPE_LPC)
        {
            WCHAR wTransType[16] = {0};
            ::swprintf(wTransType, L"%d", TransportType);
            LOG_EVENT(AP_ERROR, 
                      MSG_WINHTTP_AUTOPROXY_SVC_NON_LRPC_REQUEST, 
                      wTransType);
        }
        
        return RPC_S_ACCESS_DENIED;
    }
}

/*
    we registered this callback function to receive the internal BEGIN_PROXY_SCRIPT_RUN event if we 
    are impersonating a client. We need to revert the impersonation before we run the untrusted 
    proxy script code.
*/
VOID WinHttpStatusCallback(HINTERNET hInternet,
                           DWORD_PTR dwContext,
                           DWORD dwInternetStatus,
                           LPVOID lpvStatusInformation,
                           DWORD dwStatusInformationLength)
{
    UNREFERENCED_PARAMETER(lpvStatusInformation);
    UNREFERENCED_PARAMETER(dwStatusInformationLength);

    if (hInternet)
    {
        if (dwInternetStatus == WINHTTP_CALLBACK_STATUS_BEGIN_PROXY_SCRIPT_RUN)
        {
            // *note* Be aware that we are assuming this callback is coming in from the same 
            // thread that initiatedthe WinHttpGetProxyForUrl() call. Because of this 
            // assumption, we are accessing the local variables of the original call 
            // stck by pointers.

            LPBOOL pfImpersonating = (LPBOOL)dwContext; // this is the address of fImpersonating local variable in 
                                                        // AUTOPROXY_RPC_SERVER::GetProxyForUrl
            if (*pfImpersonating)
            {
                RPC_STATUS RpcStatus = ::RpcRevertToSelf();
                if (RpcStatus != RPC_S_OK)
                {
                    LOG_EVENT(AP_ERROR, 
                              MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                              L"RpcRevertToSelf()",
                              RpcStatus);
                }
                else
                {
                    // LOG_DEBUG_EVENT(AP_WARNING, 
                    //          "[debug] L-RPC: GetProxyForUrl() now reverted impersonating (about to run unsafe script)");
                    
                    *pfImpersonating = FALSE;    // this sets the local variable "fImpersonating" inside 
                                                 // AUTOPROXY_RPC_SERVER::GetProxyForUrl() to FALSE
                }
            }
        }
    }
}

AUTOPROXY_RPC_SERVER::AUTOPROXY_RPC_SERVER(VOID)
{
    _fInService = FALSE;
    _hSession = NULL;
    // _hClientBinding = NULL;
    _pServiceStatus = NULL;
    _hExitEvent = NULL;

    _fServiceIdle = TRUE;
    _dwIdleTimeStamp = ::GetTickCount();
}

AUTOPROXY_RPC_SERVER::~AUTOPROXY_RPC_SERVER(VOID)
{
    if (_hSession)
    {
        ::WinHttpCloseHandle(_hSession);
    }
    if (_hExitEvent)
    {
        ::CloseHandle(_hExitEvent);
    }
}

/*
    The Open() call registers w/ RPC runtime our Protocol Sequence (i.e. ncalrpc), the Auto-Proxy
    Interface, and the end point, then it enters the listening mode and we are ready to accept
    client requests. (upon successful security check)
*/
BOOL AUTOPROXY_RPC_SERVER::Open(LPSERVICE_STATUS pServiceStatus)
{
    BOOL fRet = FALSE;
    BOOL fServerRegistered = FALSE;

    AP_ASSERT(pServiceStatus != NULL);

    if (_pServiceStatus)
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_DATA_CORRUPT); 
        goto exit;
    }

    _pServiceStatus = pServiceStatus;

    if (InitializeSerializedList(&_PendingRequestList) == FALSE)
    {
        LOG_EVENT(AP_ERROR, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE); 
        goto exit;
    }

    _RpcStatus = ::RpcServerUseProtseqW(AUTOPROXY_L_RPC_PROTOCOL_SEQUENCE,
                                        0, // ignored for ncalrpc
                                        NULL);
    if (_RpcStatus != RPC_S_OK)
    {
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                  L"RpcServerUseProtseqW()",
                  _RpcStatus);
        goto exit;
    }

    _RpcStatus = ::RpcServerRegisterIf2(WINHTTP_AUTOPROXY_SERVICE_v5_1_s_ifspec,   // MIDL-generated constant
                                        NULL,    // UUID
                                        NULL,    // EPV
                                        RPC_IF_AUTOLISTEN,
                                        RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                                        (unsigned int) -1,      // no MaxRpcSize check
                                        RpcSecurityCallback);   // the callback will set _fInService to TRUE if access is granted

    if (_RpcStatus != RPC_S_OK)
    {
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                  L"RpcServerRegisterIf2()",
                  _RpcStatus);
        goto exit;
    }

    fServerRegistered = TRUE;

    RPC_BINDING_VECTOR* pBindingVector = NULL;

    _RpcStatus = ::RpcServerInqBindings(&pBindingVector);
    if (_RpcStatus != RPC_S_OK)
    {
        LOG_EVENT(AP_ERROR, 
                 MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                 L"RpcServerInqBindings()",
                 _RpcStatus);
        goto exit;
    }

    _RpcStatus = ::RpcEpRegisterW(WINHTTP_AUTOPROXY_SERVICE_v5_1_s_ifspec,
                                 pBindingVector,
                                 NULL,
                                 L"WinHttp Auto-Proxy Service");

    if (_RpcStatus != RPC_S_OK)
    {
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                  L"RpcEpRegisterW()",
                  _RpcStatus);
        goto exit;
    }

    _RpcStatus = ::RpcBindingVectorFree(&pBindingVector);
    if (_RpcStatus != RPC_S_OK)
    {
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                  L"RpcBindingVectorFree()",
                  _RpcStatus);
        goto exit;
    }

    _fInService = TRUE;

    fRet = TRUE;

exit:

    if (fRet == FALSE)
    {
        if (fServerRegistered)
        {
            _RpcStatus = ::RpcServerUnregisterIf(WINHTTP_AUTOPROXY_SERVICE_v5_1_s_ifspec,
                                                NULL,
                                                1   // wait for all RPC alls to complete
                                                );
            if (_RpcStatus != RPC_S_OK)
            {
                LOG_EVENT(AP_WARNING, 
                          MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                          L"RpcServerUnregisterIf()",
                          _RpcStatus);
            }
        }
    }

    return fRet;
}

/*
    The Close() method first cancel all on-going requests, it then waits for all canceled calls to abort
    gracefully
*/
BOOL AUTOPROXY_RPC_SERVER::Close(VOID)
{
    RPC_STATUS RpcStatus;
    BOOL fRet = TRUE;

    Pause();

    if (LockSerializedList(&_PendingRequestList))
    {
        if (!IsSerializedListEmpty(&_PendingRequestList))
        {
            _hExitEvent = ::CreateEvent(NULL, 
                                        TRUE,   // manual reset 
                                        FALSE,  // not initally set
                                        NULL);

            if (_hExitEvent == NULL)
            {
                DWORD dwError = ::GetLastError();
                LOG_EVENT(AP_WARNING, 
                          MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR,
                          L"CreateEvent()",
                          dwError);
                fRet = FALSE;
            }
        }

        UnlockSerializedList(&_PendingRequestList);

        if (_hExitEvent)
        {
            if (::WaitForSingleObject(_hExitEvent, AUTOPROXY_SERVICE_STOP_WAIT_HINT) == WAIT_TIMEOUT)
            {
                WCHAR wWaitHint[16] = {0};
                ::swprintf(wWaitHint, L"%d", AUTOPROXY_SERVICE_STOP_WAIT_HINT/1000);
                LOG_EVENT(AP_WARNING, 
                          MSG_WINHTTP_AUTOPROXY_SVC_TIMEOUT_GRACEFUL_SHUTDOWN, 
                           wWaitHint);
                fRet = FALSE;
            }
        
            ::CloseHandle(_hExitEvent);
            _hExitEvent = NULL;
        }
    }
    else
    {
        // LOG_DEBUG_EVENT(AP_WARNING, "The Auto-Proxy Service failed to shutdown gracefully");
        fRet = FALSE;
    }

    // if something goes wrong during close() we don't unregister L-RPC so that the service can be
    // resumed later.

    if (fRet == TRUE)
    {
        RpcStatus = ::RpcServerUnregisterIf(WINHTTP_AUTOPROXY_SERVICE_v5_1_s_ifspec,
                                            NULL,
                                            1   // wait for all RPC alls to complete
                                            );
        if (RpcStatus != RPC_S_OK)
        {
            LOG_EVENT(AP_WARNING, 
                      MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                      L"RpcServerUnregisterIf()",
                      RpcStatus);
            fRet = FALSE;
        }
    }

    return fRet;
}

/*
    This is the entry point of a RPC auto-proxy call. For each call request we create an object
    keeping track of its states and queue it in the pending request list. Then we call the
    WinHttpGetProxyForUrl() to resolve the proxy. At the end the object will be dequeued and
    deleted, and, assuming the call is not cancled, we then complete the RPC call. Call can be
    canceled by the client, or by SCM (e.g. service stop, system stand-by, and etc)
*/

/* [async] */ void  GetProxyForUrl( 
    /* [in] */ PRPC_ASYNC_STATE GetProxyForUrl_AsyncHandle,
    /* [in] */ handle_t hBinding,
    /* [string][in] */ const wchar_t *pcwszUrl,
    /* [in] */ const P_AUTOPROXY_OPTIONS pAutoProxyOptions,
    /* [in] */ const P_SESSION_OPTIONS pSessionOptions,
    /* [out][in] */ P_AUTOPROXY_RESULT pAutoProxyResult,
    /* [out][in] */ unsigned long *pdwLastError)
{
    g_pRpcSrv->GetProxyForUrl(GetProxyForUrl_AsyncHandle,
                                hBinding,
                                pcwszUrl,
                                pAutoProxyOptions,
                                pSessionOptions,
                                pAutoProxyResult,
                                pdwLastError);
}

VOID AUTOPROXY_RPC_SERVER::GetProxyForUrl(
    /* [in] */ PRPC_ASYNC_STATE GetProxyForUrl_AsyncHandle,
    /* [in] */ handle_t hBinding,
    /* [string][in] */ const wchar_t *pcwszUrl,
    /* [in] */ const P_AUTOPROXY_OPTIONS pAutoProxyOptions,
    /* [in] */ const P_SESSION_OPTIONS pSessionOptions,
    /* [out][in] */ P_AUTOPROXY_RESULT pAutoProxyResult,
    /* [out][in] */ unsigned long *pdwLastError)
{
    RPC_STATUS RpcStatus;

    // LOG_DEBUG_EVENT(AP_INFO, "[debug] L-RPC: GetProxyForUrl() called; url=%wq", pcwszUrl);

    if ((pdwLastError == NULL) || ::IsBadWritePtr(pdwLastError, sizeof(DWORD)) ||
        (pAutoProxyOptions == NULL) || ::IsBadWritePtr(pAutoProxyOptions, sizeof(_AUTOPROXY_OPTIONS)) ||
        (pSessionOptions == NULL) || ::IsBadWritePtr(pSessionOptions, sizeof(_SESSION_OPTIONS)))
    {
        // we call abort here because RpcAsyncCompleteCall() may not return LastError safely;
        // pdwLastError may not point to valid memory

        LOG_EVENT(AP_WARNING, MSG_WINHTTP_AUTOPROXY_SVC_INVALID_PARAMETER);

        RpcStatus = ::RpcAsyncAbortCall(GetProxyForUrl_AsyncHandle, 
                                        ERROR_WINHTTP_INTERNAL_ERROR);

        if (RpcStatus != RPC_S_OK)
        {
            // shoot, we failed to abort the call, something is really wrong here; 
            // all we can do is to raise an exception
            
            LOG_EVENT(AP_ERROR, 
                      MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                      L"RpcAsyncAbortCall()",
                      RpcStatus);
            
            ::RpcRaiseException(RpcStatus);
        }

        return;
    }

    // note: the validation of pcwszUrl, and pAutoProxyResult is deferred
    // to the WinHttpGetProxyForUrl() call

    BOOL fRet = FALSE;
    BOOL fImpersonating = FALSE;
    BOOL fCallCancelled = FALSE;
    BOOL fExitCritSec = FALSE;

    LPBOOL pfImpersonate = &fImpersonating; // allow the callback frunction to modify this variable by reference
    
    WINHTTP_PROXY_INFO ProxyInfo;

    ProxyInfo.dwAccessType = 0;
    ProxyInfo.lpszProxy = NULL;
    ProxyInfo.lpszProxyBypass = NULL;

    PENDING_CALL* pClientCall = NULL;

    // we will be touching global states of AUTOPROXY_RPC_SERVER (e.g. _hSession, pending call list, and etc)
    // so we acquire a critsec here.

    if (LockSerializedList(&_PendingRequestList) == FALSE)
    {
         LOG_EVENT(AP_WARNING, 
                   MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);
        
        *pdwLastError = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    fExitCritSec = TRUE;

    _fServiceIdle = FALSE;

    // since we are now in a critsec, we try-except the operations inside this critsec so that 
    // if one client call fails unexpectedly, other calls can still go thru.

    HINTERNET* phSession = NULL;

    RpcTryExcept
    {
        if (!_fInService)
        {
            LOG_EVENT(AP_WARNING, MSG_WINHTTP_AUTOPROXY_SVC_NOT_IN_SERVICE);
            
            *pdwLastError = ERROR_WINHTTP_OPERATION_CANCELLED;
            goto exit;
        }

        pClientCall = new PENDING_CALL;
        if (pClientCall == NULL)
        {
            LOG_EVENT(AP_WARNING, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);

            *pdwLastError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        if (pAutoProxyOptions->fAutoLogonIfChallenged)
        {
            // the client is asking auto-logon, we must impersonate to use client's logon/default
            // credential. However, by impersonating we also elevate the privileges of the auo-proxy
            // service, so we are only impersonating only to download the auto-proxy resource file.
            // once the wpad file is downloaded and before executing the java script, we will revert
            // to self (LocalService)
            
            RpcStatus = ::RpcImpersonateClient(NULL);

            if (RpcStatus != RPC_S_OK)
            {
                LOG_EVENT(AP_WARNING, 
                          MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                          L"RpcImpersonateClient()",
                          RpcStatus);
            }
            else
            {
                // LOG_DEBUG_EVENT(AP_WARNING, "[debug] L-RPC: GetProxyForUrl() now impersonating");
                fImpersonating = TRUE;
            }
        }

        // we maintain a per-call session handle for each impersonating client, because their states can not be shared.
        // And for non-impersonating client, they share one global session.

        phSession = fImpersonating ? &(pClientCall->hSession) : &_hSession;

        if (*phSession == NULL)
        {
            *phSession = ::WinHttpOpen(L"WinHttp-Autoproxy-Service/5.1",
                                        WINHTTP_ACCESS_TYPE_NO_PROXY,
                                        WINHTTP_NO_PROXY_NAME, 
                                        WINHTTP_NO_PROXY_BYPASS,
                                        0);

            if (*phSession == NULL)
            {
                *pdwLastError = ::GetLastError();
                LOG_EVENT(AP_ERROR, 
                          MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                          L"WinHttpOpen()",
                          *pdwLastError);
                goto exit;
            }

            ::WinHttpSetTimeouts(*phSession,
                                 pSessionOptions->nResolveTimeout,
                                 pSessionOptions->nConnectTimeout,
                                 pSessionOptions->nSendTimeout,
                                 pSessionOptions->nReceiveTimeout);

            ::WinHttpSetOption(*phSession,
                               WINHTTP_OPTION_CONNECT_RETRIES,
                               &pSessionOptions->nConnectRetries,
                               sizeof(DWORD));

            if (fImpersonating)
            {
                // we are impersonating, we need to setup a callback function indicating a proxy script
                // is to be run, upon which we must revert impersonation.

                AP_ASSERT((phSession == &(pClientCall->hSession)));

                ::WinHttpSetStatusCallback(*phSession, 
                                           WinHttpStatusCallback,
                                           WINHTTP_CALLBACK_FLAG_BEGIN_PROXY_SCRIPT_RUN,
                                           NULL);

                ::WinHttpSetOption(*phSession, 
                                   WINHTTP_OPTION_CONTEXT_VALUE,
                                   &pfImpersonate,
                                   sizeof(DWORD_PTR));
            }
        }   

        pClientCall->hAsyncRequest = GetProxyForUrl_AsyncHandle;
        pClientCall->hBinding = hBinding;
        pClientCall->pdwLastError = pdwLastError;   // so that the SCM thread can cancel the call w/ LastError set
    }
    RpcExcept(1)
    {
        WCHAR wExceptCode[16] = {0};
        ::swprintf(wExceptCode, L"%d", ::RpcExceptionCode());
        LOG_EVENT(AP_ERROR, 
                  MSG_WINHTTP_AUTOPROXY_SVC_WINHTTP_EXCEPTED, 
                  wExceptCode);
        *pdwLastError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }
    RpcEndExcept
    
    UnlockSerializedList(&_PendingRequestList);
    fExitCritSec = FALSE;

    // it's possible that the Pause/Stop function pre-empts this call to abort 
    // all pending requests while the current call will go thru. we can hang
    // on to the lock past this point, however since we won't hold the lock
    // while calling WinHttpGetProxyForUrl(), that possibility is always there,
    // and it will also complicate the retry logic. It's will not be end of the 
    // world so we don't worry that too much here.

retry:  // upon a critical power standby event, all requests will be abandoned and re-attemtepd
    
    fRet = FALSE;

    if (phSession == &(pClientCall->hSession)) // we need to impersonate...
    {
        if (!fImpersonating) // ...but we are not impersonating!...
        {
            // it must be the case that the WinHttpCallback function has reverted impersonation
            // since we are retrying, we need to turn it back on
            RpcStatus = ::RpcImpersonateClient(NULL);

            if (RpcStatus != RPC_S_OK)
            {
                LOG_EVENT(AP_WARNING, 
                          MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                          L"RpcImpersonateClient()",
                          RpcStatus);
            }
            else
            {
                // LOG_DEBUG_EVENT(AP_WARNING, "[debug] L-RPC: GetProxyForUrl() now impersonating");
                fImpersonating = TRUE;
            }
        }
    }

    // queue up the request

    if (InsertAtHeadOfSerializedList(&_PendingRequestList, &pClientCall->List) == FALSE)
    {
        LOG_EVENT(AP_WARNING, MSG_WINHTTP_AUTOPROXY_SVC_FAILED_ALLOCATE_RESOURCE);
        *pdwLastError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    if (ProxyInfo.lpszProxy)
    {
        ::GlobalFree((HGLOBAL)ProxyInfo.lpszProxy);
        ProxyInfo.lpszProxy = NULL;
    }
    if (ProxyInfo.lpszProxyBypass)
    {
        ::GlobalFree((HGLOBAL)ProxyInfo.lpszProxyBypass);
        ProxyInfo.lpszProxyBypass = NULL;
    }

    // the WINHTTP_AUTOPROXY_RUN_INPROCESS flag should not have been set, otherwise
    // we won't be here the first place
    AP_ASSERT(!(pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_INPROCESS));

    // we must set this flag because we are the service
    pAutoProxyOptions->dwFlags |= WINHTTP_AUTOPROXY_RUN_INPROCESS;
    DWORD dwSvcOnlyFlagSaved = (pAutoProxyOptions->dwFlags & WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY);
    pAutoProxyOptions->dwFlags &= ~dwSvcOnlyFlagSaved; // remove the WINHTTP_AUTOPROXY_RUN_OUTPROCESS_ONLY flag if present
    
    fRet = ::WinHttpGetProxyForUrl(*phSession, 
                                   pcwszUrl,
                                   (WINHTTP_AUTOPROXY_OPTIONS*)pAutoProxyOptions,
                                   &ProxyInfo);
#ifdef ENABLE_DEBUG
        DWORD dwSvcDelay = 0;

        DWORD dwRegVal;
        DWORD dwValType;
        DWORD dwValSize = sizeof(dwRegVal);
        if (::RegQueryValueExW(g_hKeySvcParams,
                              L"SvcDelay",
                              NULL,
                              &dwValType,
                              (LPBYTE)&dwRegVal,
                              &dwValSize) == ERROR_SUCCESS)
        {
            if ((dwValType == REG_DWORD) && (dwRegVal != 0))
            {
                dwSvcDelay = dwRegVal; // the value unit from registry is milli-sec.
            }
        }

        ::Sleep(dwSvcDelay);
#endif        

    // restore the flag
    pAutoProxyOptions->dwFlags &= ~WINHTTP_AUTOPROXY_RUN_INPROCESS;
    pAutoProxyOptions->dwFlags |= dwSvcOnlyFlagSaved;

    // this is only place that removes pending call from the list
    RemoveFromSerializedList(&_PendingRequestList, &pClientCall->List);

    if (_hExitEvent)
    {
        // the service is shuting down
        AP_ASSERT(_fInService == FALSE);

        // once is list is empty, it will remain empty since not more call
        // will be accepted; so we don't need to worry about race here
        if (IsSerializedListEmpty(&_PendingRequestList))
        {
            ::SetEvent(_hExitEvent);
        }
    }

    if (pClientCall->fCallCancelled == TRUE)    // call's been cancelled by SCM
    {
        fCallCancelled = TRUE;
        goto exit;
    }

    // the client may have cancelled the call, let's check that
    RpcStatus = ::RpcServerTestCancel(/*hBinding*/NULL);
    if (RpcStatus == RPC_S_OK)
    {
        *pdwLastError = ERROR_WINHTTP_OPERATION_CANCELLED;
        fRet = FALSE;
        goto exit;
    }

    // also the Svc Control may have told us to discard the current result
    // due to a critical power standby

    if (pClientCall->fDiscardAndRetry)
    {
        LOG_EVENT(AP_INFO, MSG_WINHTTP_AUTOPROXY_SVC_RETRY_REQUEST);
        pClientCall->fDiscardAndRetry = FALSE;
        goto retry;
    }

    if (fRet == TRUE)
    {
        pAutoProxyResult->dwAccessType = ProxyInfo.dwAccessType;
        
        // these two are [in,out,unique] pointer, so RpcAsyncCompleteCall() will
        // make a copy of the strings and return to the client. so we need to
        // delete the two strings to prevent memory leaks

        pAutoProxyResult->lpszProxy = ProxyInfo.lpszProxy;
        ProxyInfo.lpszProxy = NULL; // ownership transferred to RPC
        
        pAutoProxyResult->lpszProxyBypass = ProxyInfo.lpszProxyBypass;
        ProxyInfo.lpszProxyBypass = NULL; // ownership transferred to RPC

        // LOG_DEBUG_EVENT(AP_INFO, "[debug] L-RPC: GetProxyForUrl() returning; proxy=%wq", pAutoProxyResult->lpszProxy);
    }
    else
    {
        *pdwLastError = ::GetLastError();

#ifdef ENABLE_DEBUG
        //LOG_DEBUG_EVENT(AP_WARNING, 
        //         "[debug] L-RPC: GetProxyForUrl(): WinHttpGetProxyForUrl() faled; error = %d", 
        //         *pdwLastError);
#endif
    }

exit:

    if (fExitCritSec)
    {
        UnlockSerializedList(&_PendingRequestList);
    }

    if (pClientCall)
    {
        delete pClientCall;
        pClientCall = NULL;
    }

    if (!fCallCancelled)
    {
        RpcStatus = ::RpcAsyncCompleteCall(GetProxyForUrl_AsyncHandle, &fRet);
    
        if (RpcStatus != RPC_S_OK)
        {
            // we failed to complete the call; log an error and return. Not much we can do
            // here
            LOG_EVENT(AP_ERROR, 
                      MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                      L"RpcAsyncCompleteCall()",
                      RpcStatus);
         }
    }

    if (fImpersonating)
    {
        RpcStatus = ::RpcRevertToSelf();
        if (RpcStatus != RPC_S_OK)
        {
            LOG_EVENT(AP_ERROR, 
                      MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                      L"RpcRevertToSelf()",
                      RpcStatus);
        }
        else
        {
            // LOG_DEBUG_EVENT(AP_WARNING, "[debug] L-RPC: GetProxyForUrl() now reverted impersonating");
            fImpersonating = FALSE;
        }
    }

    if (ProxyInfo.lpszProxy)
    {
        ::GlobalFree((HGLOBAL)ProxyInfo.lpszProxy);
        ProxyInfo.lpszProxy = NULL;
    }
    if (ProxyInfo.lpszProxyBypass)
    {
        ::GlobalFree((HGLOBAL)ProxyInfo.lpszProxyBypass);
        ProxyInfo.lpszProxyBypass = NULL;
    }

    // if we don't have any requests pending, start up the idle timer; upon certain idle period
    // the service will be shutdown

    if (LockSerializedList(&_PendingRequestList))
    {
        if (IsSerializedListEmpty(&_PendingRequestList))
        {
            _fServiceIdle = TRUE;
            _dwIdleTimeStamp = ::GetTickCount();
        }

        UnlockSerializedList(&_PendingRequestList);
    }
}

BOOL AUTOPROXY_RPC_SERVER::IsIdle(DWORD dwMilliSeconds)
{
    BOOL fRet = FALSE;
    
    if (LockSerializedList(&_PendingRequestList))
    {
        if (_fServiceIdle)
        {
            DWORD dwElapsedTime = ::GetTickCount() - _dwIdleTimeStamp;
            if (dwElapsedTime > dwMilliSeconds)
            {
                fRet = TRUE;
            }

            AP_ASSERT(IsSerializedListEmpty(&_PendingRequestList));
        }

        UnlockSerializedList(&_PendingRequestList);
    }

    return fRet;
}

/*
    The Pause() function marks the service unavailable, abort call on going WinHttpGetProxyForUrl calls(), and then complete
    all pending RPC client requests as OPERATION_CANCELLED.
*/
BOOL AUTOPROXY_RPC_SERVER::Pause(VOID)
{
    BOOL fRet = FALSE;

    if (_fInService)
    {
        if (LockSerializedList(&_PendingRequestList))
        {
            // no need to check _fInService again because this is the only thread that will set it to FALSE

            _fInService = FALSE;

            LOG_EVENT(AP_INFO, MSG_WINHTTP_AUTOPROXY_SVC_SUSPEND_OPERATION);

            if (_hSession)
            {
                ::WinHttpCloseHandle(_hSession);    // close the global session, which will cause all anonymous calls to abort
                _hSession = NULL;
            }

            PLIST_ENTRY pEntry;
            for (pEntry = HeadOfSerializedList(&_PendingRequestList);
                 pEntry != (PLIST_ENTRY)SlSelf(&_PendingRequestList);
                 pEntry = pEntry->Flink)
            {
                PENDING_CALL* pPendingCall = (PENDING_CALL*)pEntry;
                AP_ASSERT(pPendingCall != NULL);
                
                AP_ASSERT(pPendingCall->pdwLastError != NULL);
                *(pPendingCall->pdwLastError) = ERROR_WINHTTP_OPERATION_CANCELLED;
                
                if (pPendingCall->hSession)
                {
                    ::WinHttpCloseHandle(pPendingCall->hSession);   // abort his impersonating call
                    pPendingCall->hSession = NULL;
                }

                BOOL fRpcRet = FALSE;

                AP_ASSERT(pPendingCall->hAsyncRequest != NULL);
                
                RPC_STATUS RpcStatus = ::RpcAsyncCompleteCall(pPendingCall->hAsyncRequest, &fRpcRet);
                if ((RpcStatus == RPC_S_OK) || (RpcStatus == RPC_S_CALL_CANCELLED))
                {
                    pPendingCall->fCallCancelled = TRUE;
                }
                else
                {
                    LOG_EVENT(AP_ERROR, 
                              MSG_WINHTTP_AUTOPROXY_SVC_WIN32_ERROR, 
                              L"RpcAsyncCompleteCall()",
                              RpcStatus);
                }
            }

            UnlockSerializedList(&_PendingRequestList);

            fRet = TRUE;
        }
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}

BOOL AUTOPROXY_RPC_SERVER::Resume(VOID)
{
    _fInService = TRUE;

    LOG_EVENT(AP_INFO, MSG_WINHTTP_AUTOPROXY_SVC_RESUME_OPERATION);
    
    return TRUE;
}

/*
    The Refresh() function marks all pending requests to "discard-and-retry", later when they are completed normally,
    their results will be discarded and operations retried. This function is called after resuming from a critical
    power event.
*/
BOOL AUTOPROXY_RPC_SERVER::Refresh(VOID)
{
    BOOL fRet = FALSE;

    if (_fInService)
    {
        if (LockSerializedList(&_PendingRequestList))
        {
            // no need to check _fInService again because this is the only thread that will set it to FALSE

            PLIST_ENTRY pEntry;
            for (pEntry = HeadOfSerializedList(&_PendingRequestList);
                 pEntry != (PLIST_ENTRY)SlSelf(&_PendingRequestList);
                 pEntry = pEntry->Flink)
            {
                PENDING_CALL* pPendingCall = (PENDING_CALL*)pEntry;
                AP_ASSERT(pPendingCall != NULL);
                
                pPendingCall->fDiscardAndRetry = TRUE;
            }

            UnlockSerializedList(&_PendingRequestList);

            fRet = TRUE;
        }
    }
    else
    {
        fRet = TRUE;
    }

    return fRet;
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/
 
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return(GlobalAlloc(GPTR, len));
}
 
void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    GlobalFree(ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\basic.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include "htuu.h"

/*---------------------------------------------------------------------------
BASIC_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
BASIC_CTX::BASIC_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
BASIC_CTX::~BASIC_CTX()
{}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PreAuthUser(IN LPSTR pBuf, IN OUT LPDWORD pcbBuf)
{
    DWORD dwRetVal = ERROR_WINHTTP_INTERNAL_ERROR;
    LPSTR pszUserPass = NULL;
    DWORD cbUserPass;
    LPSTR lpszPass = NULL;
    
    if (!_pCreds->lpszUser || !(lpszPass = _pCreds->GetPass()))
    {
        dwRetVal = ERROR_INVALID_PARAMETER;
        goto done;
    }
            
    // Prefix the header value with the auth type.
    const static BYTE szBasic[] = "Basic ";
    const DWORD BASIC_LEN = sizeof(szBasic) - 1;

    if (*pcbBuf < BASIC_LEN)
    {
        dwRetVal = ERROR_INSUFFICIENT_BUFFER;
        goto done;
    }
    
    memcpy (pBuf, szBasic, BASIC_LEN);
    pBuf += BASIC_LEN;

    // Generate rest of header value by uuencoding user:pass.
    DWORD cbMaxUserPathLen = strlen(_pCreds->lpszUser) + 1 
                             + strlen(lpszPass) + 1 
                             + 10;
                // HTUU_encode() parse the buffer 3 bytes at a time; 
                // In the worst case we will be two bytes short, so add at least 2 here. 
                // longer buffer doesn't matter, HTUU_encode will adjust appropreiately.

    pszUserPass = New CHAR[cbMaxUserPathLen];

    if (pszUserPass == NULL)
    {
        dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
        goto done;
    }
     
    cbUserPass = wsprintf(pszUserPass, "%s:%s", _pCreds->lpszUser, lpszPass);
    
    INET_ASSERT (cbUserPass < cbMaxUserPathLen);

    if( -1 == HTUU_encode ((PBYTE) pszUserPass, cbUserPass, pBuf, *pcbBuf - BASIC_LEN))
        goto done;

    *pcbBuf = BASIC_LEN + lstrlen (pBuf);
    
    _pvContext = (LPVOID) 1;

    dwRetVal = ERROR_SUCCESS;
 
done:
    if (pszUserPass != NULL)
        delete [] pszUserPass;
    
    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

    return dwRetVal;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    DWORD dwAuthIdx, cbRealm, dwError;
    LPSTR szRealm = NULL;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // Get any realm.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
        &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

    // No realm is OK.
    if (dwError != ERROR_SUCCESS)
        szRealm = NULL;

    // If we already have a Creds, ensure that the realm matches. If not,
    // find or create a new one and set it in the auth context.
    if (_pCreds)
    {
        INET_ASSERT(_pCreds->lpszRealm);
        if (/*_pCreds->lpszRealm && */szRealm && lstrcmp(_pCreds->lpszRealm, szRealm))
        {
            // Realms don't match - create a new Creds entry, release the old.
            delete _pCreds;
            _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
    }
    // If no password cache is set in the auth context,
    // find or create one and set it in the auth context.
    else
    {            
        // Find or create a password cache entry.
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        if (!_pCreds)
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
        INET_ASSERT(_pCreds->pSPM == _pSPMData);
        // _pCreds->nLockCount++;
    }

    if (!_pCreds)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_WINHTTP_INTERNAL_ERROR;
        goto exit;
    }

    dwError = ERROR_SUCCESS;
        
    exit:

    if (szRealm)
        delete []szRealm;

    return dwError;
}


/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD BASIC_CTX::PostAuthUser()
{
    DWORD dwRet;

    if (! _pvContext && !_pRequest->GetCreds() 
        && _pCreds->lpszUser && _pCreds->xszPass.GetPtr())
        dwRet = ERROR_WINHTTP_FORCE_RETRY;
    else
        dwRet = ERROR_WINHTTP_INCORRECT_PASSWORD;

    _pRequest->SetCreds(NULL);
    _pvContext = (LPVOID) 1;
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\digest.cxx ===
#include <wininetp.h>
#include <splugin.hxx>
#include <security.h>
#include "auth.h"

#define SSP_SPM_NT_DLL      "security.dll"

#define OUTPUT_BUFFER_LEN   10000

#define HEADER_IDX          0
#define REALM_IDX           1
#define HOST_IDX            2
#define URL_IDX             3
#define METHOD_IDX          4
#define USER_IDX            5
#define PASS_IDX            6
#define NONCE_IDX           7
#define NC_IDX              8
#define HWND_IDX            9
#define NUM_BUFF            10

#define ISC_MODE_AUTH        0
#define ISC_MODE_PREAUTH     1
#define ISC_MODE_UI          2

struct DIGEST_PKG_DATA
{
    LPSTR szAppCtx;
    LPSTR szUserCtx;
};

//
//  IsSecHandleZero( CtxtHandle)
//     Utility function for working with SSPI.  It can be used for Security Handles,
//  Context Handles, and Credential handles.
//
//  Some SSPI functions that maintain a context handle initially take NULL
//as the address of that handle, and then the address of the handle, as an
//input param.  To track whether or not it is an initial call, we check if
//the context handle is zero.
//
bool IsSecHandleZero( CtxtHandle h)
{
    return h.dwUpper == 0 && h.dwLower == 0;
};


/*-----------------------------------------------------------------------------
    DIGEST_CTX
-----------------------------------------------------------------------------*/

// Globals
CCritSec DIGEST_CTX::s_CritSection;
HINSTANCE DIGEST_CTX::g_hSecLib = NULL;
PSecurityFunctionTable DIGEST_CTX::g_pFuncTbl = NULL;
unsigned int DIGEST_CTX::g_iUniquePerDigestCtxInt;  // let it start at a mildly pseudorandom value.


/*---------------------------------------------------------------------------
static DIGEST_CTX::GlobalInitialize()
---------------------------------------------------------------------------*/
BOOL DIGEST_CTX::GlobalInitialize()
{
    if (g_pFuncTbl != NULL)
        return TRUE;
    else if (!s_CritSection.Lock())
        return FALSE;
    
    //
    // Get the global SSPI dispatch table.  (get g_hSecLib and then g_pFuncTbl)
    //
    if (g_hSecLib == NULL)
    {
        OSVERSIONINFO   VerInfo;

        VerInfo.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);

        GetVersionEx (&VerInfo);

        if (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
        {
            g_hSecLib = LoadLibrary (SSP_SPM_NT_DLL);
        }
    }

    if (g_pFuncTbl == NULL && g_hSecLib != NULL)
    {
        INIT_SECURITY_INTERFACE addrProcISI = NULL;
        addrProcISI = (INIT_SECURITY_INTERFACE) GetProcAddress(g_hSecLib, 
                        SECURITY_ENTRYPOINT_ANSI); 
        if (addrProcISI != NULL)
            g_pFuncTbl = (*addrProcISI)();
    }

    s_CritSection.Unlock();

    return g_pFuncTbl != NULL;
}

/*---------------------------------------------------------------------------
static DIGEST_CTX::GlobalRelease()
---------------------------------------------------------------------------*/
void DIGEST_CTX::GlobalRelease()
{
    g_pFuncTbl = NULL;

    if( g_hSecLib != NULL)
    {
        FreeLibrary( g_hSecLib);
        g_hSecLib = NULL;
    }
}

/*---------------------------------------------------------------------------
DIGEST_CTX::GetRequestUri
---------------------------------------------------------------------------*/
LPSTR DIGEST_CTX::GetRequestUri()
{
    LPSTR szUrl;
    DWORD cbUrl;

    URL_COMPONENTSA sUrl;        

    memset(&sUrl, 0, sizeof(sUrl));
    sUrl.dwStructSize = sizeof(sUrl);
    sUrl.dwHostNameLength = (DWORD)-1; 
    sUrl.dwUrlPathLength = (DWORD)-1; 
    sUrl.dwExtraInfoLength = (DWORD)-1; 

    szUrl = _pRequest->GetURL();

    // Generate request-uri
    if (WinHttpCrackUrlA(szUrl, strlen(szUrl), 0, &sUrl))
    {
        cbUrl = sUrl.dwUrlPathLength;
        szUrl = New CHAR[cbUrl+1];

        if (!szUrl)
        {
            // Alloc failure. Return NULL. We will
            // use _pRequest->GetURL instead.
            return NULL;
        }
    
        memcpy(szUrl, sUrl.lpszUrlPath, cbUrl);
        szUrl[cbUrl] = '\0';
    }
    else
    {
        // ICU failed. Return NULL which
        // will cause _pRequest->GetURL
        // to be used.
        return NULL;
    }

    return szUrl;
}


/*---------------------------------------------------------------------------
DIGEST_CTX::InitSecurityBuffers
---------------------------------------------------------------------------*/
VOID DIGEST_CTX::InitSecurityBuffers(LPSTR szOutBuf, DWORD cbOutBuf,
    LPDWORD pdwSecFlags, DWORD dwISCMode)
{
    LPSTR lpszPass = NULL;

    // Input Buffer.    
    _SecBuffInDesc.cBuffers = NUM_BUFF;
    _SecBuffInDesc.pBuffers = _SecBuffIn;

    // Set Header
    _SecBuffIn[HEADER_IDX].pvBuffer     = _szData;
    _SecBuffIn[HEADER_IDX].cbBuffer     = _cbData;
    _SecBuffIn[HEADER_IDX].BufferType   = SECBUFFER_TOKEN;
    
    // If credentials are supplied will be set to
    // ISC_REQ_USE_SUPPLIED_CREDS.
    // If prompting for auth dialog will be set to
    // ISC_REQ_PROMPT_FOR_CREDS.
    *pdwSecFlags = 0;
    
    // Set realm if no header, otherwise NULL.
    if (_SecBuffIn[HEADER_IDX].pvBuffer || _pCreds->lpszRealm == NULL)
    {
        _SecBuffIn[REALM_IDX].pvBuffer  = NULL;
        _SecBuffIn[REALM_IDX].cbBuffer  = 0;
    }
    else
    {
        // We are preauthenticating using the realm
        _SecBuffIn[REALM_IDX].pvBuffer = _pCreds->lpszRealm;
        _SecBuffIn[REALM_IDX].cbBuffer = strlen(_pCreds->lpszRealm);
    }
    
    // Host.
    _SecBuffIn[HOST_IDX].pvBuffer     = _pCreds->lpszHost;
    _SecBuffIn[HOST_IDX].cbBuffer     = strlen(_pCreds->lpszHost);
    _SecBuffIn[HOST_IDX].BufferType   = SECBUFFER_TOKEN;

    
    // Request URI.    
    if (!_szRequestUri)
    {
        _szRequestUri = GetRequestUri();
        if (_szRequestUri)
            _SecBuffIn[URL_IDX].pvBuffer     = _szRequestUri;
        else
             _SecBuffIn[URL_IDX].pvBuffer = _pRequest->GetURL();
    }

    _SecBuffIn[URL_IDX].cbBuffer     = strlen((LPSTR) _SecBuffIn[URL_IDX].pvBuffer);
    _SecBuffIn[URL_IDX].BufferType   = SECBUFFER_TOKEN;


    LPSTR lpszVerb;
    DWORD dwVerbLength;
    lpszVerb = _pRequest->_RequestHeaders.GetVerb(&dwVerbLength);
    if(NULL != _pszVerb)
        delete[] _pszVerb;
    _pszVerb = new CHAR[dwVerbLength+1];
    if (_pszVerb)
    {
        memcpy(_pszVerb, lpszVerb, dwVerbLength);
        _pszVerb[dwVerbLength] = 0;
    }

    // HTTP method.
    _SecBuffIn[METHOD_IDX].pvBuffer = _pszVerb;
    _SecBuffIn[METHOD_IDX].cbBuffer = dwVerbLength;
        // MapHttpMethodType(_pRequest->GetMethodType(), (LPCSTR*) &_SecBuffIn[METHOD_IDX].pvBuffer);
    _SecBuffIn[METHOD_IDX].BufferType   = SECBUFFER_TOKEN;

    if (_SecBuffIn[PASS_IDX].pvBuffer)
    {
        INET_ASSERT(strlen((LPCSTR)_SecBuffIn[PASS_IDX].pvBuffer) == _SecBuffIn[PASS_IDX].cbBuffer);
        SecureZeroMemory(_SecBuffIn[PASS_IDX].pvBuffer, _SecBuffIn[PASS_IDX].cbBuffer);
        FREE_MEMORY(_SecBuffIn[PASS_IDX].pvBuffer);
    }

    // User and pass might be provided from Creds entry. Use only if
    // we have a challenge header (we don't pre-auth using supplied creds).
    if (dwISCMode == ISC_MODE_AUTH && _pCreds->lpszUser && *_pCreds->lpszUser 
        && (lpszPass = _pCreds->GetPass()) && *lpszPass)
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = _pCreds->lpszUser;
        _SecBuffIn[USER_IDX].cbBuffer     = strlen(_pCreds->lpszUser);
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = lpszPass;
        _SecBuffIn[PASS_IDX].cbBuffer     = strlen(lpszPass);
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
        *pdwSecFlags = ISC_REQ_USE_SUPPLIED_CREDS;
    }
    else
    {
        // User.
        _SecBuffIn[USER_IDX].pvBuffer     = NULL;  
        _SecBuffIn[USER_IDX].cbBuffer     = 0;
        _SecBuffIn[USER_IDX].BufferType   = SECBUFFER_TOKEN;

        // Pass.
        _SecBuffIn[PASS_IDX].pvBuffer     = NULL;
        _SecBuffIn[PASS_IDX].cbBuffer     = 0;
        _SecBuffIn[PASS_IDX].BufferType   = SECBUFFER_TOKEN;
    }

    // If the 'if' statement above caused the lpszPass variable to be allocated
    // but it was not assigned to _SecBuffIn[PASS_IDX].pvBuffer, then free it.
    if (lpszPass != NULL && _SecBuffIn[PASS_IDX].pvBuffer == NULL)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }

    if (dwISCMode == ISC_MODE_UI)
        *pdwSecFlags = ISC_REQ_PROMPT_FOR_CREDS;
        
    // Out Buffer.
    _SecBuffOutDesc.cBuffers    = 1;
    _SecBuffOutDesc.pBuffers    = _SecBuffOut;
    _SecBuffOut[0].pvBuffer     = szOutBuf;
    _SecBuffOut[0].cbBuffer     = cbOutBuf;
    _SecBuffOut[0].BufferType   = SECBUFFER_TOKEN;
}


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
DIGEST_CTX::DIGEST_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy,
                 SPMData *pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;
    _pRequest = pRequest;

    _szAlloc      = NULL;
    _szData       = NULL;
    _pvContext    = NULL;
    _szRequestUri = NULL;
    _cbData       = 0;
    _cbContext    = 0;

    _pszVerb = NULL;
    
    
    // Zero out the security buffers and request context.
    memset(&_SecBuffInDesc,  0, sizeof(_SecBuffInDesc));
    memset(&_SecBuffOutDesc, 0, sizeof(_SecBuffInDesc));
    memset(_SecBuffIn,       0, sizeof(_SecBuffIn));
    memset(_SecBuffOut,      0, sizeof(_SecBuffOut));
    //  On the first call to InitializeSecurityContext() it doesn't have a valid handle,
    //but afterwards _hCtxt is a handle to accumulated data.
    memset(&_hCtxt,          0, sizeof(_hCtxt));
    _szUserCtx[0] = '\0';
    memset(&_hCred, 0, sizeof(_hCred));

    //
    //  Initialize class global stuff if necessary
    //
    if (!DIGEST_CTX::GlobalInitialize())
        return;  // failure indicated by IsSecHandleZero(_hCred)

    //
    //  Get credentials handle unique to this digest context
    // 
    SEC_WINNT_AUTH_IDENTITY_EXA SecIdExA;
    DIGEST_PKG_DATA PkgData;
    sprintf(_szUserCtx, "digest%pn%x", pRequest, g_iUniquePerDigestCtxInt++);

    PkgData.szAppCtx = PkgData.szUserCtx = _szUserCtx;
    memset(&SecIdExA, 0, sizeof(SEC_WINNT_AUTH_IDENTITY_EXA));

    SecIdExA.Version = sizeof(SEC_WINNT_AUTH_IDENTITY_EXA);
    SecIdExA.User = (unsigned char*) &PkgData;
    SecIdExA.UserLength = sizeof( PkgData);
    
    (*(g_pFuncTbl->AcquireCredentialsHandleA))
        (NULL, "Digest", SECPKG_CRED_OUTBOUND, NULL, &SecIdExA, NULL, 0, &_hCred, NULL);

    //  success indicated by !IsSecHandleZero(_hCred)
}


/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
DIGEST_CTX::~DIGEST_CTX()
{
    if(!IsSecHandleZero(_hCtxt))
    {
        (*(g_pFuncTbl->DeleteSecurityContext))( &_hCtxt);
    }
        
    if( !IsSecHandleZero( _hCred))
    {
        (*(g_pFuncTbl->FreeCredentialsHandle))(&_hCred);
    }
    
    if (_szAlloc)
        delete [] _szAlloc;

    if (_pvContext)
        delete [] _pvContext;

    if (_szRequestUri)
        delete [] _szRequestUri;

    if (_pszVerb)
        delete [] _pszVerb;

    if (_SecBuffIn[PASS_IDX].pvBuffer)
    {
        INET_ASSERT(strlen((LPCSTR)_SecBuffIn[PASS_IDX].pvBuffer) == _SecBuffIn[PASS_IDX].cbBuffer);
        SecureZeroMemory(_SecBuffIn[PASS_IDX].pvBuffer, _SecBuffIn[PASS_IDX].cbBuffer);
        FREE_MEMORY(_SecBuffIn[PASS_IDX].pvBuffer);
    }
}


/*---------------------------------------------------------------------------
    PreAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PreAuthUser(OUT LPSTR pBuff, IN OUT LPDWORD pcbBuff)
{
    SECURITY_STATUS ssResult = SEC_E_OK;
    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    if (IsSecHandleZero(_hCred))
        return ERROR_WINHTTP_INTERNAL_ERROR;

    if (AuthLock())
    {
        // If a response has been generated copy into output buffer.
        if (_cbContext)
        {
            memcpy(pBuff, _pvContext, _cbContext);
            *pcbBuff = _cbContext;
        }
        // Otherwise attempt to preauthenticate.
        else
        {
            // Call into the SSPI package.
            DWORD sf;
            InitSecurityBuffers(pBuff, *pcbBuff, &sf, ISC_MODE_AUTH);

            ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
                (&_hCred, (IsSecHandleZero(_hCtxt) ? NULL : &_hCtxt), NULL, sf, 0, 0, 
                 &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
            INET_ASSERT( !IsSecHandleZero( _hCtxt));

            *pcbBuff = _SecBuffOut[0].cbBuffer;
        }

        AuthUnlock();
    }
            
    return (DWORD) ssResult;
}

/*---------------------------------------------------------------------------
    UpdateFromHeaders
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::UpdateFromHeaders(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy)
{
    if (IsSecHandleZero(_hCred))
        return ERROR_WINHTTP_INTERNAL_ERROR;
    
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    DWORD dwError, dwAuthIdx;
    LPSTR szRealm; 
    DWORD cbRealm;
    
    // Get the associated header.
    if ((dwError = FindHdrIdxFromScheme(&dwAuthIdx)) != ERROR_SUCCESS)
        goto exit;

    // If this auth ctx does not have Creds then it has been
    // just been constructed in response to a 401.
    if (!_pCreds)
    {
        // Get any realm.
        dwError = GetAuthHeaderData(pRequest, fIsProxy, "Realm", 
            &szRealm, &cbRealm, ALLOCATE_BUFFER, dwAuthIdx);

        if (dwError != ERROR_SUCCESS)
        {
            goto exit;
        }
        
        _pCreds = CreateCreds(pRequest, fIsProxy, _pSPMData, szRealm);
        
        if (pRequest->_pszRealm)
        {
            FREE_MEMORY(pRequest->_pszRealm);
        }
        pRequest->_pszRealm = szRealm;
        szRealm = NULL;

        if (_pCreds)
        {
            INET_ASSERT(_pCreds->pSPM == _pSPMData);
        }
        else
        {
            dwError = ERROR_WINHTTP_INTERNAL_ERROR;
            goto exit;
        }
    } 
    else if (_pCreds != NULL && _cbContext)
    {
        //  else if we have credentials and had authorization data with the last request,
        //then we failed to authenticate.
        dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
        goto exit;
    }

    // Updating the buffer - delete old one if necessary.
    if (_szAlloc)
    {
        delete [] _szAlloc;
        _szAlloc = _szData = NULL;
        _cbData = 0;
    }

    // Get the entire authentication header.
    dwError = GetAuthHeaderData(pRequest, fIsProxy, NULL,
        &_szAlloc, &_cbData, ALLOCATE_BUFFER, dwAuthIdx);
    
    if (dwError != ERROR_SUCCESS)
    {
        goto exit;
    }

    // Point just past scheme
    _szData = _szAlloc;
    while (*_szData != ' ')
    {
        _szData++;
        _cbData--;
    }

    // The request will be retried.
    dwError = ERROR_SUCCESS;

exit:
    AuthUnlock();
    return dwError;
}



/*---------------------------------------------------------------------------
    PostAuthUser
---------------------------------------------------------------------------*/
DWORD DIGEST_CTX::PostAuthUser()
{
    if (IsSecHandleZero(_hCred))
        return ERROR_WINHTTP_INTERNAL_ERROR;
 
    if (!AuthLock())
    {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    INET_ASSERT(_pSPMData == _pCreds->pSPM);

    DWORD dwError;
    SECURITY_STATUS ssResult;

    // Allocate an output buffer if not done so already.
    if (!_pvContext)
    {
        _pvContext = New CHAR[OUTPUT_BUFFER_LEN];
        if (!_pvContext)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }

    _cbContext = OUTPUT_BUFFER_LEN;


    // Call into the SSPI package.

    DWORD sf;
    InitSecurityBuffers((LPSTR) _pvContext, _cbContext, &sf, ISC_MODE_AUTH);
    ssResult = (*(g_pFuncTbl->InitializeSecurityContext))
        (&_hCred, (IsSecHandleZero(_hCtxt) ? NULL : &_hCtxt), NULL, sf, 
         0, 0, &_SecBuffInDesc, 0, &_hCtxt, &_SecBuffOutDesc, NULL, NULL);
    INET_ASSERT(  !IsSecHandleZero( _hCtxt));
    _cbContext = _SecBuffOutDesc.pBuffers[0].cbBuffer;

    switch(ssResult)
    {
        case SEC_E_OK:
        {
            dwError = ERROR_WINHTTP_FORCE_RETRY;
            break;
        }
        case SEC_E_NO_CREDENTIALS:
        {
            dwError = ERROR_WINHTTP_INCORRECT_PASSWORD;
            break;
        }
        default:
            dwError = ERROR_WINHTTP_LOGIN_FAILURE;
    }

exit:
    _pRequest->SetCreds(NULL);
    AuthUnlock();
    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\winhttp\v5.1\auth\passport.cxx ===
#include <wininetp.h>
#include <urlmon.h>
#include <splugin.hxx>
#include "htuu.h"
#include "auth.h"

/*---------------------------------------------------------------------------
PASSPORT_CTX
---------------------------------------------------------------------------*/


/*---------------------------------------------------------------------------
    Constructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::PASSPORT_CTX(HTTP_REQUEST_HANDLE_OBJECT *pRequest, BOOL fIsProxy, 
                    SPMData* pSPM, AUTH_CREDS* pCreds)
    : AUTHCTX(pSPM, pCreds)
{
    _fIsProxy = fIsProxy;

    _pRequest = pRequest;
    
    m_hLogon = NULL;

    m_pNewThreadInfo = NULL;
    m_pwszPartnerInfo = NULL;
    m_lpszRetUrl = NULL;

    m_wRealm[0] = '\0';
    m_pszFromPP = NULL;

    m_fPreauthFailed = FALSE;
    m_fAnonymous = TRUE;

    // m_AuthComplete = FALSE;
    _fChallengeSeen = FALSE;

    m_pszCbUrl = NULL;
    m_pszCbTxt = NULL;

    m_wTarget[0] = 0;

    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->GetServerName(), -1, m_wTarget, MAX_AUTH_TARGET_LEN);
}

BOOL PASSPORT_CTX::Init(void)
{
    m_pNewThreadInfo = ::InternetCreateThreadInfo(FALSE);
    if (m_pNewThreadInfo == NULL)
    {
        return FALSE;
    }

    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    m_pInternet = GetRootHandle (_pRequest);
    
    if (!m_pInternet->GetPPContext())
    {
        PWSTR pProxyUser = NULL;
        PWSTR pProxyPass = NULL;

        if (!_pRequest->_pTweenerProxyCreds)
        {
            // prepare for the possibility that contacting Passport servers need to go thru auth'ing proxy
            LPSTR lpszUser, lpszPass = NULL;
            _pRequest->GetUserAndPass(TRUE/*proxy*/, &lpszUser, &lpszPass);

            if (lpszUser && lpszPass)
            {
                _pRequest->_pTweenerProxyCreds = CreateCreds(_pRequest, TRUE/*proxy*/, _pSPMData, NULL);

                if (_pRequest->_pTweenerProxyCreds)
                {
                    _pRequest->_pTweenerProxyCreds->SetUser(lpszUser);
                    _pRequest->_pTweenerProxyCreds->SetPass(lpszPass);
                }
            }

            if (lpszPass)
            {
                SecureZeroMemory(lpszPass, strlen(lpszPass));
                FREE_MEMORY(lpszPass);
            }
        }

        if (_pRequest->_pTweenerProxyCreds)
        {
            if (_pRequest->_pTweenerProxyCreds->lpszUser)
            {
                DWORD dwProxyUserLength = strlen(_pRequest->_pTweenerProxyCreds->lpszUser);
                pProxyUser = new WCHAR[dwProxyUserLength+1];
                if (pProxyUser)
                {
                    ::MultiByteToWideChar(CP_ACP, 0, _pRequest->_pTweenerProxyCreds->lpszUser, -1, pProxyUser, dwProxyUserLength+1); 
                }
            }

            LPSTR lpszPass = _pRequest->_pTweenerProxyCreds->GetPass();
            if (lpszPass)
            {
                DWORD dwProxyPassLength = strlen(lpszPass);
                pProxyPass = new WCHAR[dwProxyPassLength+1];
                if (pProxyPass)
                {
                    ::MultiByteToWideChar(CP_ACP, 0, lpszPass, -1, pProxyPass, dwProxyPassLength+1); 
                }

                SecureZeroMemory(lpszPass, dwProxyPassLength);
                FREE_MEMORY(lpszPass);
                lpszPass = NULL;
            }
        }

        PP_CONTEXT hPP = ::PP_InitContext(L"WinHttp.Dll", m_pInternet->GetPseudoHandle(), pProxyUser, pProxyPass);
        m_pInternet->SetPPContext(hPP);
        hPP = NULL;
        
        pProxyUser = NULL;
        pProxyPass = NULL;

    }
    
    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (!m_pInternet->GetPPContext())
    {
        return FALSE;
    }
    
    return TRUE;
}
/*---------------------------------------------------------------------------
    Destructor
---------------------------------------------------------------------------*/
PASSPORT_CTX::~PASSPORT_CTX()
{
    LPINTERNET_THREAD_INFO pCurrentThreadInfo = ::InternetGetThreadInfo();
    
    m_pNewThreadInfo->ThreadId = ::GetCurrentThreadId();
    ::InternetSetThreadInfo(m_pNewThreadInfo);
    
    if (m_hLogon)
    {
        ::PP_FreeLogonContext(m_hLogon);
        m_hLogon = NULL;
    }

    ::InternetSetThreadInfo(pCurrentThreadInfo);

    if (m_pNewThreadInfo)
    {
        ::InternetFreeThreadInfo(m_pNewThreadInfo);
    }

    if (m_pwszPartnerInfo)
    {
        delete [] m_pwszPartnerInfo;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    if (m_pszFromPP)
    {
        delete [] m_pszFromPP;
    }

    if (m_pszCbUrl != NULL)
    {
        delete [] m_pszCbUrl;
    }

    if (m_pszCbTxt != NULL)
    {
        delete [] m_pszCbTxt;
    }
}

BOOL PASSPORT_CTX::CallbackRegistered(void)
{
    LPINTERNET_THREAD_INFO lpThreadInfo = InternetGetThreadInfo();
    if (lpThreadInfo)
    {
        WINHTTP_STATUS_CALLBACK appCallback = 
            ((INTERNET_HANDLE_BASE *)lpThreadInfo->hObjectMapped)->GetStatusCallback();

        if (appCallback != NULL) 
        {
            return TRUE;
        }
    }

    return FALSE;
}


DWORD PASSPORT_CTX::HandleSuccessfulLogon(
    LPWSTR*  ppwszFromPP,
    PDWORD   pdwFromPP,
    BOOL     fPreAuth
    )
{
    // biaow-todo: I am betting the RU DWORD UrlLength = 1024;
    LPWSTR pwszUrl = (LPWSTR) ALLOCATE_FIXED_MEMORY(1024 * sizeof(WCHAR));
    DWORD dwwUrlLength = 1024;//             won't be too long, but I could be wrong 
    LPSTR pszUrl = (LPSTR) ALLOCATE_FIXED_MEMORY(dwwUrlLength * sizeof(CHAR));
    BOOL fRetrySameUrl;
    DWORD dwRet = ERROR_SUCCESS;

    if (pwszUrl == NULL || pszUrl == NULL)
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    *pdwFromPP = 0;

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  NULL, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        *ppwszFromPP = new WCHAR[*pdwFromPP];
        if (*ppwszFromPP == NULL)
        {
            dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
            goto exit;
        }
    }
    else
    {
        INET_ASSERT(FALSE); // this shouldn't happen
    }

    if (::PP_GetAuthorizationInfo(m_hLogon,
                                  *ppwszFromPP, 
                                  pdwFromPP,
                                  &fRetrySameUrl,
                                  pwszUrl,
                                  &dwwUrlLength
                                  ) == FALSE)
    {
        INET_ASSERT(FALSE); // this shouldn't happen
        dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
        goto exit;
    }

    // save the DA Host name for Logout security check
    /*
    WCHAR wszDAHost[256];
    DWORD dwHostLen = ARRAY_ELEMENTS(wszDAHost);
    if (::PP_GetLogonHost(m_hLogon, wszDAHost, &dwHostLen) == TRUE)
    {
        ::WideCharToMultiByte(CP_ACP, 0, wszDAHost, -1, g_szPassportDAHost, 256, NULL, NULL);
    }
    */

    if (!fRetrySameUrl)
    {
        if (_pRequest->GetMethodType() == HTTP_METHOD_TYPE_GET)
        {
            // DA wanted us to GET to a new Url
            ::WideCharToMultiByte(CP_ACP, 0, pwszUrl, -1, pszUrl, 1024, NULL, NULL);
        }
        else
        {
            fRetrySameUrl = TRUE; // *** WinHttp currently supports retry custom verb to same URL only ***
        }
    }
    
    if (fPreAuth)
    {
        // We are sending, in the context of AuthOnRequest.

        if (fRetrySameUrl)
        {
            // DA told us to keep Verb & Url, so there is nothing more needs to be done
            goto exit;
        }
        
        // Regardless whether we are asked to handle redirect, we'll need to fake
        // that a 302 just came in. 
        
        // biaow-todo: this is causing problem for QueryHeaders(StatusCode). I don't know why yet...
        /*
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_STATUS_TEXT, // use non-standard index, since we never query this normally
                                  "HTTP/1.0 302 Object Moved",
                                  strlen("HTTP/1.0 302 Object Moved")
                                  );
        _pRequest->AddInternalResponseHeader(HTTP_QUERY_LOCATION, 
                                             pszUrl, 
                                             strlen(pszUrl));
        */


        //
        //  todo:  if REDIRECT_POLICY is POLICY_DISALLOW_HTTPS_TO_HTTP, do not allow
        //the passport server to redirect to an HTTP site if the original request
        //was to an HTTPS site
        //
        if (_pRequest->GetDwordOption(WINHTTP_OPTION_REDIRECT_POLICY) == WINHTTP_OPTION_REDIRECT_POLICY_NEVER)
        {
            if (!CallbackRegistered())
            {
                _pRequest->SetPPAbort(TRUE);
                dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                goto exit;
            }
        }
        
        ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
    }
    else
    {
        // We are receiving a 302, in the context of AuthOnResponse.
        
        // Here we need to re-play the request to lpszRetUrl. One way to 
        // achieve this is returning ERROR_INTERNET_FORCE_RETRY. But before
        // that, we'll need to remember the lpszRetUrl.

        // *NOTE* This is in effective an 401. To prevent the send path from
        // following the 302 Location: header, caller must set the status code
        // to 401.

        if (!fRetrySameUrl)
        {
            //
            //  todo:  if REDIRECT_POLICY is POLICY_DISALLOW_HTTPS_TO_HTTP, do not allow
            //the passport server to redirect to an HTTP site if the original request
            //was to an HTTPS site
            //
            if (_pRequest->GetDwordOption(WINHTTP_OPTION_REDIRECT_POLICY) == WINHTTP_OPTION_REDIRECT_POLICY_NEVER)
            {
                if (!CallbackRegistered())
                {
                    dwRet = ERROR_WINHTTP_LOGIN_FAILURE;
                    goto exit;
                }

                ::InternetIndicateStatusString(WINHTTP_CALLBACK_STATUS_REDIRECT, pszUrl);
            }
        }
        
        dwRet = ERROR_WINHTTP_RESEND_REQUEST;
    }

    PCSTR lpszRetUrl = NULL;

    if (fRetrySameUrl)
    {
        lpszRetUrl = _pRequest->GetURL();
    }
    else
    {
        lpszRetUrl = pszUrl;
    }

    if (m_lpszRetUrl)
    {
        delete [] m_lpszRetUrl;
    }

    m_lpszRetUrl = new CHAR[strlen(lpszRetUrl) + 1];
    if (m_lpszRetUrl)
    {
        strcpy(m_lpszRetUrl, lpszRetUrl);
    }

exit:

    if (pwszUrl)
    {
        FREE_MEMORY(pwszUrl);
    }
    if (pszUrl)
    {
        FREE_MEMORY(pszUrl);
    }
    
    return dwRet;
}

DWORD PASSPORT_CTX::SetCreds(BOOL* pfCredSet)
{
    DWORD dwError = ERROR_SUCCESS;
    BOOL fUseDefaultCreds;
    LPWSTR pwszUser = NULL;
    LPWSTR pwszPass = NULL;
    LPSTR  lpszPass = _pCreds->GetPass();
    
    if (_pCreds->lpszUser && lpszPass) // both User and Pass are specified
    {
        fUseDefaultCreds = FALSE;
    }
    else if (!_pCreds->lpszUser && !lpszPass) // both User and Pass are NULL
    {
        fUseDefaultCreds = TRUE;
    }
    else
    {
        INET_ASSERT(FALSE); // this case should not happen
        fUseDefaultCreds = FALSE;
    }

    PSYSTEMTIME pCredTimestamp = NULL;
    SYSTEMTIME TimeCredsEntered;

    if (!fUseDefaultCreds)
    {
        pwszUser = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(_pCreds->lpszUser) + 1) * sizeof(WCHAR));
        pwszPass = (LPWSTR) ALLOCATE_FIXED_MEMORY((strlen(lpszPass) + 1) * sizeof(WCHAR));

        if (pwszUser && pwszPass)
        {
            if( (0 == ::MultiByteToWideChar(CP_ACP, 0, _pCreds->lpszUser, -1, pwszUser, strlen(_pCreds->lpszUser) + 1))
                || (0 ==::MultiByteToWideChar(CP_ACP, 0, lpszPass, -1, pwszPass, strlen(lpszPass) + 1)))
            {
                pwszUser[0] = L'\0';
                pwszPass[0] = L'\0';
                dwError=GetLastError();
            }
        }
        else
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
        }

        pCredTimestamp = &TimeCredsEntered;
        ::GetSystemTime(pCredTimestamp); // time-stamp the creds
    }

    if (dwError == ERROR_SUCCESS)
    {
        if (pwszUser == NULL && pwszPass == NULL && m_pInternet->KeyringDisabled())
        {
            *pfCredSet = FALSE;
        }
        else
        {
            *pfCredSet = ::PP_SetCredentials(m_hLogon, m_wRealm, m_wTarget, pwszUser, pwszPass, pCredTimestamp);
        }
    }

    if (pwszUser)
    {
        SecureZeroMemory( pwszUser, sizeof(pwszUser[0])*wcslen(pwszUser));
        FREE_MEMORY(pwszUser);
    }
    if (pwszPass)
    {
        SecureZeroMemory( pwszPass, sizeof(pwszPass[0])*wcslen(pwszPass));
        FREE_MEMORY(pwszPass);
    }

    if (lpszPass)
    {
        SecureZeroMemory(lpszPass, strlen(lpszPass));
        FREE_MEMORY(lpszPass);
    }
    
    return dwError;
}

DWORD PASSPORT_CTX::ModifyRequestBasedOnRU(void)
{
    DWORD dwError = ERROR_SUCCESS;
    
    INTERNET_SCHEME schemeType;
    INTERNET_SCHEME currentSchemeType;
    INTERNET_PORT currentHostPort;
    LPSTR currentHostName;
    DWORD currentHostNameLength;

    INTERNET_PORT port = 0;
    LPSTR pszHostName;
    DWORD dwHostNameLength = 0;
    LPSTR pszUrlPath;
    DWORD dwUrlPathLength = 0;
    LPSTR extra;
    DWORD extraLength;

    dwError = CrackUrl(m_lpszRetUrl,
             0,
             FALSE, // don't escape URL-path
             &schemeType,
             NULL,  // scheme name, don't care
             NULL,
             &pszHostName,
             &dwHostNameLength,
             FALSE, // -biaow- do NOT unscape hostnamesd
             &port,
             NULL,  // UserName, don't care
             NULL,  
             NULL,  // Password, don't care
             NULL,
             &pszUrlPath,
             &dwUrlPathLength,
             &extra,
             &extraLength,
 